# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: e658ed29
Difficulty: easy

=== Tags ===
- Diagonals
- Background filling
- Associate colors to colors

=== Description ===
The task involves transforming an input grid into an output grid by preserving
the main diagonal elements (cells where row index equals column index) and
filling all other cells with a color associated with the top-left diagonal
cell's color. Specifically, the color at position (0,0) in the input grid
determines the background color for the output: if the input (0,0) color is C,
the output background color is (C + 1) modulo 10. The diagonal elements remain
unchanged from the input, while all non-diagonal cells are set to this computed
background color. This transformation leverages diagonal structure, background
filling rules, and a direct color association mapping (C â†’ (C+1) mod 10) to
consistently generate the output grid from any valid input grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
def generate():
    n = random.randint(2, 30)
    C = random.randint(0, 9)
    input_grid = [[C] * n for _ in range(n)]
    B = (C + 1) % 10
    output_grid = []
    for i in range(n):
        output_row = []
        for j in range(n):
            if i == j:
                output_row.append(C)
            else:
                output_row.append(B)
        output_grid.append(output_row)
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid or not input_grid[0]:
        return input_grid
    C = input_grid[0][0]
    B = (C + 1) % 10
    rows = len(input_grid)
    cols = len(input_grid[0])
    output = [[B] * cols for _ in range(rows)]
    for i in range(min(rows, cols)):
        output[i][i] = input_grid[i][i]
    return output
