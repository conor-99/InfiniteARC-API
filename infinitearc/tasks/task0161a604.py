# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 0161a604
Difficulty: easy

=== Tags ===
- Recolor
- Nearest color fill
- Isolate largest component
- Pattern completion

=== Description ===
The task involves transforming an input grid of colored cells (values 0-9) into
an output grid by applying a consistent visual transformation. The input grid
contains multiple distinct regions of connected cells (4-connected, same color),
with varying sizes and colors. The output grid is generated by first identifying
the largest connected region (by area) in the input. All cells not part of this
largest region are then recolored to match the color of the nearest cell within
the largest region, using Manhattan distance to determine proximity. This
process effectively "fills" the grid with the dominant color of the largest
region, extending it to all areas nearest to it, thereby creating a unified
visual pattern. The transformation isolates the largest component while
completing the pattern through nearest-color propagation, resulting in an output
grid where the dominant color visually dominates the entire grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    width = common.randint(5, 15)
    height = common.randint(5, 15)
    main_color = common.random_color(exclude=[0])
    grid = [[main_color] * width for _ in range(height)]
    
    num_small = common.randint(3, 5)
    small_colors = common.random_colors(num_small, exclude=[main_color, 0])
    
    available = [(r, c) for r in range(height) for c in range(width)]
    selected = []
    
    for _ in range(num_small):
        if not available:
            break
        r, c = common.choice(available)
        selected.append((r, c))
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and (nr, nc) in available:
                available.remove((nr, nc))
        available.remove((r, c))
    
    for (r, c), color in zip(selected, small_colors):
        grid[r][c] = color
    
    output = [[main_color] * width for _ in range(height)]
    
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    rows = len(input_grid)
    cols = len(input_grid[0])
    visited = [[False] * cols for _ in range(rows)]
    components = []
    
    for r in range(rows):
        for c in range(cols):
            if not visited[r][c]:
                color = input_grid[r][c]
                stack = [(r, c)]
                visited[r][c] = True
                component = []
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append((len(component), color))
    
    largest_size, largest_color = max(components, key=lambda x: x[0])
    return [[largest_color] * cols for _ in range(rows)]
