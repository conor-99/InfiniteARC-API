# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: caede712
Difficulty: very hard

=== Tags ===
- Periodic offset matching
- Color by distance to edge
- Count touches

=== Description ===
The input grid consists of a 2D grid of colors (0-9) arranged in a non-uniform
pattern. The output grid is generated through a multi-step transformation that
integrates three distinct visual rules:  1. **Periodic offset matching**: For
each cell, the transformation uses the input color modulo 3 to determine a
periodic offset. This offset shifts the color mapping for cells sharing the same
input color value, creating a repeating pattern where colors cycle through three
distinct values (e.g., 1→2→3→1) based on input color parity.  2. **Color by
distance to edge**: Each cell's distance to the nearest grid edge (d = min(row,
height-1-row, column, width-1-column)) determines a base color index. This index
cycles through the same three-color palette (0→1→2→0) based on d modulo 3.  3.
**Count touches**: After applying the distance-based color with periodic offset,
each cell's output color is adjusted based on the count of adjacent cells
(up/down/left/right) sharing its current color. If this count equals or exceeds
2, the color index advances by 1 modulo 3 (e.g., 0→1→2→0), introducing localized
visual complexity.  The transformation requires simultaneously tracking edge-
distance patterns, input-color-dependent periodic offsets, and neighbor-based
color adjustments. The output grid maintains consistent visual relationships
across the entire grid, with no explicit reliance on numerical sums, bit
parities, or pixel-level matching. This interplay of spatial distance, periodic
color shifts, and adjacency-based corrections creates a visually demanding task
that necessitates multi-stage abstract reasoning to discover the consistent
pattern.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def transform(grid):
    height = len(grid)
    width = len(grid[0])
    output = [[0] * width for _ in range(height)]
    temp_colors = [[0] * width for _ in range(height)]
    
    for r in range(height):
        for c in range(width):
            d = min(r, height - 1 - r, c, width - 1 - c)
            base = d % 3
            input_color = grid[r][c]
            offset = input_color % 3
            combined = (base + offset) % 3
            temp_colors[r][c] = 1 + combined
    
    for r in range(height):
        for c in range(width):
            count = 0
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    if temp_colors[nr][nc] == temp_colors[r][c]:
                        count += 1
            if count >= 2:
                output[r][c] = (temp_colors[r][c] % 3) + 1
            else:
                output[r][c] = temp_colors[r][c]
    return output

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    input_grid = grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            input_grid[r][c] = random.randint(0, 9)
    output_grid = transform(input_grid)
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
from common import grid

def transform(grid):
    height = len(grid)
    width = len(grid[0])
    output = [[0] * width for _ in range(height)]
    temp_colors = [[0] * width for _ in range(height)]
    
    for r in range(height):
        for c in range(width):
            d = min(r, height - 1 - r, c, width - 1 - c)
            base = d % 3
            input_color = grid[r][c]
            offset = input_color % 3
            combined = (base + offset) % 3
            temp_colors[r][c] = 1 + combined
    
    for r in range(height):
        for c in range(width):
            count = 0
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    if temp_colors[nr][nc] == temp_colors[r][c]:
                        count += 1
            if count >= 2:
                output[r][c] = (temp_colors[r][c] % 3) + 1
            else:
                output[r][c] = temp_colors[r][c]
    return output

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    output_list = transform(input_list)
    return tuple(tuple(row) for row in output_list)
