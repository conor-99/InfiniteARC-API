# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 1e5b100f
Difficulty: hard

=== Tags ===
- Pattern sync
- Paint on collision
- Alternating rule composition
- Image within image
- Fill holes

=== Description ===
Input grids feature a large background (color 0) containing a compact,
contiguous inner image (typically 3-5x3-5 cells) made of non-zero colors
arranged in a repeating cyclic pattern (e.g., [red, blue, green, red, blue,
green...]). The main grid includes numerous "holes" (background cells)
positioned adjacent to the inner image's boundary or forming a connected region
around it.   Output grids fill all holes using a multi-layered rule sequence:
1. **Pattern Sync**: The inner image's color sequence defines a cyclic pattern.
Each hole adjacent to a specific edge (top/bottom/left/right) of the inner image
uses a corresponding color from the sequence (e.g., top edge = first color,
right edge = second color, etc.), cycling through the sequence as more edges are
processed.   2. **Paint on Collision**: Holes are filled in a wave-like
expansion from the inner image's boundary, with each newly filled hole's color
determined by the adjacency direction and pattern position. Filling direction
alternates between horizontal and vertical for successive layers (e.g., top-edge
holes filled left-to-right, right-edge holes filled top-to-bottom).   3.
**Alternating Rule Composition**: The filling sequence alternates between
filling all holes of one adjacency type (e.g., top-edge holes) before moving to
the next (e.g., right-edge holes), ensuring no overlaps with existing non-
background cells.   4. **Image within Image**: The inner image's exact color
sequence and shape dictate the filling pattern, requiring the solver to decode
its cyclic structure and apply it to the surrounding hole network.    The output
grid must fully fill all holes with colors from the inner image's pattern while
respecting edge adjacency, direction alternation, and no overlap with existing
structures. The inner image and non-hole background remain unchanged.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common
from common import grid, connected

def generate():
    width = random.randint(15, 25)
    height = random.randint(15, 25)
    bg = 0
    inner_size = random.randint(3, 5)
    cycle_length = 3
    colors = list(range(1, 10))
    cycle = random.sample(colors, cycle_length)
    
    inner_image = []
    for i in range(inner_size):
        row = []
        for j in range(inner_size):
            idx = (i * inner_size + j) % cycle_length
            row.append(cycle[idx])
        inner_image.append(row)
    
    x = random.randint(2, width - 2 - inner_size)
    y = random.randint(2, height - 2 - inner_size)
    input_grid = grid(width, height, bg)
    for i in range(inner_size):
        for j in range(inner_size):
            input_grid[y + i][x + j] = inner_image[i][j]
    
    adjacent_holes = []
    for i in range(inner_size):
        for j in range(inner_size):
            r = y + i
            c = x + j
            for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == bg:
                    adjacent_holes.append((nr, nc))
    
    visited = set()
    queue = list(adjacent_holes)
    holes = []
    while queue:
        r, c = queue.pop(0)
        if (r, c) in visited:
            continue
        visited.add((r, c))
        holes.append((r, c))
        for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == bg and (nr, nc) not in visited:
                queue.append((nr, nc))
    
    inner_top = y
    inner_bottom = y + inner_size - 1
    inner_left = x
    inner_right = x + inner_size - 1
    output_grid = [row[:] for row in input_grid]
    for (r, c) in holes:
        if r == inner_top - 1 and inner_left <= c <= inner_right:
            edge = 0
        elif c == inner_right + 1 and inner_top <= r <= inner_bottom:
            edge = 1
        elif r == inner_bottom + 1 and inner_left <= c <= inner_right:
            edge = 2
        elif c == inner_left - 1 and inner_top <= r <= inner_bottom:
            edge = 3
        else:
            edge = 0
        color = cycle[edge % cycle_length]
        output_grid[r][c] = color
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
from common import connected
from typing import Tuple, List

def p(input_grid: Tuple[Tuple[int, ...], ...]) -> Tuple[Tuple[int, ...], ...]:
    grid_list = [list(row) for row in input_grid]
    height = len(grid_list)
    width = len(grid_list[0])
    
    non_zero = []
    for r in range(height):
        for c in range(width):
            if grid_list[r][c] != 0:
                non_zero.append((r, c))
    
    inner_top = min(r for r, c in non_zero)
    inner_bottom = max(r for r, c in non_zero)
    inner_left = min(c for r, c in non_zero)
    inner_right = max(c for r, c in non_zero)
    
    inner_colors = []
    for r in range(inner_top, inner_bottom + 1):
        for c in range(inner_left, inner_right + 1):
            if grid_list[r][c] != 0:
                inner_colors.append(grid_list[r][c])
    
    cycle = inner_colors[:3]
    
    adjacent_holes = []
    for r in range(inner_top, inner_bottom + 1):
        for c in range(inner_left, inner_right + 1):
            for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid_list[nr][nc] == 0:
                    adjacent_holes.append((nr, nc))
    
    visited = set()
    queue = list(adjacent_holes)
    holes = []
    while queue:
        r, c = queue.pop(0)
        if (r, c) in visited:
            continue
        visited.add((r, c))
        holes.append((r, c))
        for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and grid_list[nr][nc] == 0 and (nr, nc) not in visited:
                queue.append((nr, nc))
    
    for (r, c) in holes:
        if r == inner_top - 1 and inner_left <= c <= inner_right:
            edge = 0
        elif c == inner_right + 1 and inner_top <= r <= inner_bottom:
            edge = 1
        elif r == inner_bottom + 1 and inner_left <= c <= inner_right:
            edge = 2
        elif c == inner_left - 1 and inner_top <= r <= inner_bottom:
            edge = 3
        else:
            edge = 0
        color = cycle[edge % len(cycle)]
        grid_list[r][c] = color
    
    return tuple(tuple(row) for row in grid_list)
