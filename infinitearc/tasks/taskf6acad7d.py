# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: f6acad7d
Difficulty: hard

=== Tags ===
- Image within image
- Sort rows by criteria

=== Description ===
Each input grid is a 10×10 grid containing a 3×3 embedded subgrid (the "image
within image") located at rows 2–4 and columns 2–4 (0-indexed). The top row of
this embedded subgrid (row 2, columns 2–4) contains three distinct non-zero
colors. The output grid is formed by sorting the rows of the main grid in
descending order based on the count of the first color in the embedded subgrid's
top row, followed by the count of the second color, and then the count of the
third color. If two rows have identical counts for all three colors, their
relative order remains unchanged. The sorting must be performed
lexicographically on the tuple (count_color1, count_color2, count_color3). This
requires identifying the embedded subgrid's top row colors, counting their
occurrences across each row of the main grid, and applying a multi-criteria sort
based on those counts. The task is challenging due to the need to process visual
patterns within the embedded image and apply a complex sorting rule that
dynamically depends on the input's internal structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    grid = [[0] * 10 for _ in range(10)]
    colors = common.random_colors(3, exclude=[0])
    A, B, C = colors
    grid[2][2], grid[2][3], grid[2][4] = A, B, C
    for i in range(10):
        for j in range(10):
            if i in [2,3,4] and 2 <= j <= 4:
                if i == 2:
                    continue
                else:
                    grid[i][j] = random.randint(0, 9)
            else:
                grid[i][j] = random.randint(0, 9)
    counts = []
    for i in range(10):
        cnt_a = sum(1 for j in range(10) if grid[i][j] == A)
        cnt_b = sum(1 for j in range(10) if grid[i][j] == B)
        cnt_c = sum(1 for j in range(10) if grid[i][j] == C)
        counts.append((cnt_a, cnt_b, cnt_c))
    sorted_indices = sorted(range(10), key=lambda i: counts[i], reverse=True)
    output_grid = [grid[i] for i in sorted_indices]
    return {
        "input": grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    A = input_grid[2][2]
    B = input_grid[2][3]
    C = input_grid[2][4]
    counts = []
    for i in range(10):
        cnt_a = sum(1 for j in range(10) if input_grid[i][j] == A)
        cnt_b = sum(1 for j in range(10) if input_grid[i][j] == B)
        cnt_c = sum(1 for j in range(10) if input_grid[i][j] == C)
        counts.append((cnt_a, cnt_b, cnt_c))
    sorted_rows = sorted(range(10), key=lambda i: counts[i], reverse=True)
    output_grid = [input_grid[i] for i in sorted_rows]
    return output_grid
