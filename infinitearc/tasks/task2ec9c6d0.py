# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 2ec9c6d0
Difficulty: medium–hard

=== Tags ===
- Local physics rule
- Order numbers

=== Description ===
Input grids consist of a background color (0) and multiple colored cells (1–9)
arranged in a 2D grid. The transformation applies a local rule sequentially:
each cell is processed in row-major order (top-left to bottom-right). For a
cell, if at least two of its orthogonally adjacent cells (up, down, left, right)
share the same color in the current state of the grid (which may include prior
updates), the cell changes to that color. This sequential processing means
earlier updated cells can influence subsequent cells, creating cascading
effects. The output grid reflects the final state after all cells have been
processed according to this rule. The task requires recognizing both the
neighbor-based condition and the critical role of processing order in
determining the outcome.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    width = random.randint(2, 30)
    height = random.randint(2, 30)
    input_grid = [[0] * width for _ in range(height)]
    X = random.randint(1, 9)
    Y = random.randint(1, 9)
    while Y == X:
        Y = random.randint(1, 9)
    input_grid[0][1] = X
    input_grid[1][0] = X
    input_grid[1][1] = Y
    output_grid = [row[:] for row in input_grid]
    for i in range(height):
        for j in range(width):
            neighbors = []
            if i > 0:
                neighbors.append(output_grid[i-1][j])
            if i < height - 1:
                neighbors.append(output_grid[i+1][j])
            if j > 0:
                neighbors.append(output_grid[i][j-1])
            if j < width - 1:
                neighbors.append(output_grid[i][j+1])
            color_count = {}
            for color in neighbors:
                color_count[color] = color_count.get(color, 0) + 1
            target_color = None
            for color, cnt in color_count.items():
                if cnt >= 2:
                    target_color = color
                    break
            if target_color is not None:
                output_grid[i][j] = target_color
    if input_grid == output_grid:
        return generate()
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])
    for i in range(h):
        for j in range(w):
            neighbors = []
            if i > 0:
                neighbors.append(grid[i-1][j])
            if i < h - 1:
                neighbors.append(grid[i+1][j])
            if j > 0:
                neighbors.append(grid[i][j-1])
            if j < w - 1:
                neighbors.append(grid[i][j+1])
            color_count = {}
            for color in neighbors:
                color_count[color] = color_count.get(color, 0) + 1
            target_color = None
            for color, cnt in color_count.items():
                if cnt >= 2:
                    target_color = color
                    break
            if target_color is not None:
                grid[i][j] = target_color
    return tuple(tuple(row) for row in grid)
