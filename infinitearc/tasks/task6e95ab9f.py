# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 6e95ab9f
Difficulty: insane

=== Tags ===
- Simulate gravity with obstacles
- Energy absorption
- Draw parallel line

=== Description ===
**Task Name: Gravity-Driven Energy Matrix**  **Tags:** Simulate gravity with
obstacles, Energy absorption, Draw parallel line  **Description:**  Input grids
are large (width and height ≥ 20) and contain a single background color (0).
Scattered across the grid are:  - **Obstacle clusters** (colors 1–4), each
representing a distinct orientation and energy absorption property:   - Color 1:
Horizontal wall (absorbs energy, emits horizontal lines)   - Color 2: Vertical
wall (absorbs energy, emits vertical lines)   - Color 3: Diagonal wall (top-left
to bottom-right; absorbs energy, emits diagonal lines)   - Color 4: Diagonal
wall (top-right to bottom-left; absorbs energy, emits diagonal lines)  -
**Energy particles** (color 5), which are subject to gravity (fall downward)
until they collide with an obstacle.  - **Static energy sources** (color 6),
which are unaffected by gravity and remain in place.  In the output grid:  1.
**Gravity simulation**: Each energy particle (color 5) falls vertically downward
until it hits the first obstacle (colors 1–4). Particles do not interact with
each other or static sources.  2. **Energy absorption**: Upon collision with an
obstacle:    - The particle’s color is replaced by the obstacle’s absorption
color (color 6 for color 1, 7 for color 2, 8 for color 3, 9 for color 4).    - A
**parallel line** is drawn in the direction corresponding to the obstacle’s
orientation:      - Horizontal wall (color 1) → horizontal line (same row,
left/right)      - Vertical wall (color 2) → vertical line (same column,
up/down)      - Diagonal wall (color 3) → diagonal line (top-left to bottom-
right)      - Diagonal wall (color 4) → diagonal line (top-right to bottom-left)
3. **Line drawing rules**:    - The line starts at the collision point and
extends in the obstacle’s direction for a length equal to the obstacle’s color
value (1–4 cells). For example, a color 1 obstacle (horizontal) draws a line of
length 1 (1 cell left/right), color 2 (vertical) draws length 2, etc.    - Lines
are drawn using the absorption color (6–9) and overwrite only background cells
(0), preserving obstacles and static sources.    - Multiple lines may originate
from the same obstacle but are drawn sequentially, with later collisions
overriding earlier ones in the same cell.  4. **Static elements remain
unchanged**:    - Obstacles (1–4), static sources (6), and background (0) are
preserved in the output, except where overwritten by lines.  **Key complexity
for "insane" difficulty**: - Obstacles of all four types coexist, requiring
precise orientation identification (e.g., distinguishing diagonal walls). - Line
lengths vary (1–4 cells) based on obstacle color, creating non-uniform patterns.
- Line directions must align with obstacle orientation (e.g., diagonal walls
produce two possible diagonal directions). - Overlapping lines must be resolved
via collision order (later collisions overwrite earlier ones in the same cell),
though the task ensures no ambiguous overlaps in valid inputs.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(20, 30)
    height = random.randint(20, 30)
    grid = [[0 for _ in range(width)] for _ in range(height)]

    obstacles = []
    # Place a random number of obstacles
    obstacle_count = random.randint(8, 16)
    attempts = 0
    while len(obstacles) < obstacle_count and attempts < obstacle_count * 20:
        r = random.randint(2, max(2, height - 3))
        c = random.randint(2, max(2, width - 3))
        if grid[r][c] == 0:
            color = random.randint(1, 4)
            grid[r][c] = color
            obstacles.append((r, c, color))
        attempts += 1

    # Place a few static sources (color 6), avoid being directly above any obstacle
    static_positions = []
    num_static = random.randint(1, 4)
    attempts = 0
    while len(static_positions) < num_static and attempts < 500:
        r = random.randint(0, height - 1)
        c = random.randint(0, width - 1)
        if grid[r][c] != 0:
            attempts += 1
            continue
        blocked = False
        for orow, ocol, _ in obstacles:
            if r == orow - 1 and c == ocol:
                blocked = True
                break
        if blocked:
            attempts += 1
            continue
        grid[r][c] = 6
        static_positions.append((r, c))
        attempts += 1

    # Place particles (color 5) above randomly chosen obstacles to guarantee collisions
    particles = []
    if obstacles:
        # Ensure at least 3 particles or up to half the obstacles
        num_particles = random.randint(1, max(1, min(len(obstacles), max(3, len(obstacles)//2))))
        chosen = random.sample(obstacles, num_particles)
        for orow, ocol, ocolor in chosen:
            # choose a row above the obstacle where we can place a particle
            # try to pick a cell that is empty and that has no obstacle between it and the obstacle
            placed = False
            for _ in range(50):
                pr = random.randint(0, orow - 1)
                if grid[pr][ocol] != 0:
                    continue
                blocked = False
                for rr in range(pr + 1, orow):
                    if grid[rr][ocol] in [1, 2, 3, 4]:
                        blocked = True
                        break
                if blocked:
                    continue
                # also avoid placing particle at a static source location (should be empty anyway)
                grid[pr][ocol] = 5
                particles.append((pr, ocol))
                placed = True
                break
            if not placed:
                # fallback: place immediately above the obstacle if empty
                pr = orow - 1
                if pr >= 0 and grid[pr][ocol] == 0:
                    grid[pr][ocol] = 5
                    particles.append((pr, ocol))

    # As a small variation, add a few random particles not above obstacles
    extra_particles = random.randint(0, 3)
    attempts = 0
    while extra_particles > 0 and attempts < 200:
        pr = random.randint(0, height - 1)
        pc = random.randint(0, width - 1)
        if grid[pr][pc] == 0:
            grid[pr][pc] = 5
            particles.append((pr, pc))
            extra_particles -= 1
        attempts += 1

    # Compute output by simulating gravity and drawing lines
    original = [row[:] for row in grid]
    output = [row[:] for row in grid]

    # Collect particles positions from original to ensure solver will match
    particle_positions = []
    for r in range(height):
        for c in range(width):
            if original[r][c] == 5:
                particle_positions.append((r, c))

    # Process particles top-to-bottom, left-to-right; later collisions overwrite earlier lines
    particle_positions.sort(key=lambda x: (x[0], x[1]))
    for pr, pc in particle_positions:
        # Drop particle until it meets first obstacle (1-4) or exits grid
        r = pr + 1
        while r < height and original[r][pc] not in [1, 2, 3, 4]:
            r += 1
        if r >= height:
            continue  # falls out of grid, no collision
        obstacle_r, obstacle_c = r, pc
        obstacle_color = original[obstacle_r][obstacle_c]
        absorption_color = 5 + obstacle_color
        # Collision cell is the cell directly above the obstacle
        collision_r, collision_c = obstacle_r - 1, obstacle_c
        if 0 <= collision_r < height and 0 <= collision_c < width:
            # Replace the particle (or background) at collision point with absorption color
            output[collision_r][collision_c] = absorption_color

            # Determine directions: draw symmetric line(s) along obstacle orientation
            if obstacle_color == 1:
                dirs = [(0, 1), (0, -1)]
            elif obstacle_color == 2:
                dirs = [(1, 0), (-1, 0)]
            elif obstacle_color == 3:
                dirs = [(1, 1), (-1, -1)]
            else:  # obstacle_color == 4
                dirs = [(1, -1), (-1, 1)]

            # Draw lines of length equal to the obstacle color, starting at the collision point.
            for dr, dc in dirs:
                for length in range(1, obstacle_color + 1):
                    nr = collision_r + dr * length
                    nc = collision_c + dc * length
                    if 0 <= nr < height and 0 <= nc < width:
                        # Only overwrite cells that were background in the original input.
                        if original[nr][nc] == 0:
                            output[nr][nc] = absorption_color

    # Ensure output differs from input (there should be at least one collision because we placed particles above obstacles)
    # As a safeguard, if identical (very unlikely), force-change one particle collision cell to absorption color
    if output == original:
        # find any particle and force a collision one cell below if possible
        for pr, pc in particle_positions:
            r = pr + 1
            while r < height and original[r][pc] not in [1, 2, 3, 4]:
                r += 1
            if r < height:
                collision_r, collision_c = r - 1, pc
                output[collision_r][collision_c] = 6
                break

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    original = [list(row) for row in input_grid]
    height = len(original)
    width = len(original[0])
    output = [row[:] for row in original]

    # Collect particle positions
    particles = []
    for r in range(height):
        for c in range(width):
            if original[r][c] == 5:
                particles.append((r, c))

    # Process particles in the same deterministic order
    particles.sort(key=lambda x: (x[0], x[1]))
    for pr, pc in particles:
        r = pr + 1
        while r < height and original[r][pc] not in [1, 2, 3, 4]:
            r += 1
        if r >= height:
            continue
        obstacle_r, obstacle_c = r, pc
        obstacle_color = original[obstacle_r][obstacle_c]
        absorption_color = 5 + obstacle_color
        collision_r, collision_c = obstacle_r - 1, obstacle_c
        if 0 <= collision_r < height and 0 <= collision_c < width:
            output[collision_r][collision_c] = absorption_color
            if obstacle_color == 1:
                dirs = [(0, 1), (0, -1)]
            elif obstacle_color == 2:
                dirs = [(1, 0), (-1, 0)]
            elif obstacle_color == 3:
                dirs = [(1, 1), (-1, -1)]
            else:
                dirs = [(1, -1), (-1, 1)]
            for dr, dc in dirs:
                for length in range(1, obstacle_color + 1):
                    nr = collision_r + dr * length
                    nc = collision_c + dc * length
                    if 0 <= nr < height and 0 <= nc < width and original[nr][nc] == 0:
                        output[nr][nc] = absorption_color

    # Return as tuple-of-tuples
    return tuple(tuple(row) for row in output)

