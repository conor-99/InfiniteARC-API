# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 259b1be1
Difficulty: hard

=== Tags ===
- Gravity with barriers
- Rule propagation
- Mapping by size relation
- Wavefront timing

=== Description ===
**Task Name: Gravity Wavefront Propagation**  **Description:**  Input grids
feature a background of color 0, barriers composed of contiguous cells in color
1 (forming walls or structures), and movable elements represented by single
cells of color 2. Barriers vary in vertical height (number of rows they occupy)
and may be positioned at different locations across the grid.  The
transformation involves two sequential phases:  1. **Gravity Phase**: Each
movable element (color 2) falls vertically downward until it collides with a
barrier (color 1) or the grid’s bottom boundary. Elements settle in the lowest
possible position above the barrier, maintaining their original horizontal
alignment.  2. **Wavefront Propagation Phase**: From each settled position of
the movable elements, a wavefront propagates outward in all four cardinal
directions (up, down, left, right). The distance the wavefront travels in each
direction is determined by the *vertical height* of the barrier directly below
the element. Specifically, the wavefront extends exactly as far as the barrier
spans vertically (e.g., a barrier 4 cells tall causes the wavefront to spread 4
cells in each direction from the element’s position). Propagation halts upon
encountering barriers (color 1), the grid edge, or an already occupied
wavefront.  The output grid replaces all original movable elements with the
wavefront color (color 3) and fills all cells reached by the wavefronts with
color 3. Background cells (color 0) and barriers (color 1) remain unchanged.
Wavefronts from multiple elements merge seamlessly where they overlap, with no
additional color or pattern.  This task requires recognizing barrier height as a
visual property, applying gravity to determine element positions, and mapping
barrier height to wavefront spread length—combining spatial reasoning, rule
application, and size-based scaling.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    """Generate an ARC-style pair for the Gravity Wavefront Propagation task.

    Grid legend:
      0 - background
      1 - barrier (contiguous vertical blocks anchored at the bottom)
      2 - movable single-cell elements
      3 - wavefront (output only)
    """
    # Choose a random but moderate size to keep generation fast and varied
    width = random.randint(5, 20)
    height = random.randint(5, 20)

    # Initialize input grid with background color 0
    ingrid = [[0 for _ in range(width)] for _ in range(height)]

    # Build vertical barriers anchored to the bottom. We'll allow some adjacent columns
    # to also get barrier cells to form thicker walls.
    barrier_heights = [0] * width

    # Ensure at least one barrier column
    cols = list(range(width))
    random.shuffle(cols)
    num_barriers = random.randint(1, max(1, width // 3))
    chosen = cols[:num_barriers]

    for c in chosen:
        # barrier height between 1 and height-2 to leave room above for movable elements
        h = random.randint(1, max(1, height - 2))
        for r in range(height - h, height):
            ingrid[r][c] = 1

        # Occasionally expand the barrier into adjacent columns with possibly smaller heights
        if random.random() < 0.35:
            for dc in (-1, 1):
                nc = c + dc
                if 0 <= nc < width and random.random() < 0.5:
                    h2 = random.randint(1, h)
                    for r in range(height - h2, height):
                        ingrid[r][nc] = 1

    # Recompute contiguous bottom-anchored barrier heights (robust even if we expanded adjacent cols)
    for c in range(width):
        h = 0
        rr = height - 1
        while rr >= 0 and ingrid[rr][c] == 1:
            h += 1
            rr -= 1
        barrier_heights[c] = h

    # Place movable elements (color 2). At most one per column; ensure at least one overall.
    twos = []
    cols = list(range(width))
    random.shuffle(cols)
    num_twos = random.randint(1, max(1, width // 3))
    for c in cols[:num_twos]:
        # topmost allowed row to place a 2 is the cell just above the barrier (or bottom if no barrier)
        top_limit = height - barrier_heights[c] - 1
        if top_limit < 0:
            # column completely filled with barrier, skip
            continue
        r = random.randint(0, top_limit)
        if ingrid[r][c] == 0:
            ingrid[r][c] = 2
            twos.append((r, c))

    # Guarantee at least one movable element
    if not twos:
        for c in range(width):
            top_limit = height - barrier_heights[c] - 1
            if top_limit >= 0:
                r = 0
                ingrid[r][c] = 2
                twos.append((r, c))
                break

    # Build the output by applying the same rules the solver will use.
    output = [row[:] for row in ingrid]

    # Record original 2 positions and clear them in the output (they will be replaced by wavefronts)
    original_twos = [(r, c) for r in range(height) for c in range(width) if ingrid[r][c] == 2]
    for r, c in original_twos:
        output[r][c] = 0

    # Process the wavefronts in reading order so the generator and solver are deterministic
    original_twos.sort()
    for r, c in original_twos:
        h = barrier_heights[c]
        # settled position: directly above the top of the barrier (or bottom row if no barrier)
        settled_row = height - h - 1
        if settled_row < 0 or settled_row >= height:
            # if barrier occupies entire column (shouldn't happen with our generation rules) skip
            continue
        # center of wavefront
        output[settled_row][c] = 3
        # propagate four cardinal directions exactly 'h' cells
        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            for i in range(1, h + 1):
                nr = settled_row + dr * i
                nc = c + dc * i
                if nr < 0 or nr >= height or nc < 0 or nc >= width:
                    break
                # propagation halts on barriers or already-occupied wavefront cells
                if output[nr][nc] == 1:
                    break
                if output[nr][nc] == 3:
                    break
                output[nr][nc] = 3

    return {"input": ingrid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Compute contiguous barrier heights anchored at the bottom for each column
    barrier_heights = [0] * width
    for c in range(width):
        h = 0
        r = height - 1
        while r >= 0 and grid[r][c] == 1:
            h += 1
            r -= 1
        barrier_heights[c] = h

    # Record original movable elements (color 2)
    twos = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == 2]

    # Prepare output grid and clear original 2s
    output = [row[:] for row in grid]
    for r, c in twos:
        output[r][c] = 0

    # Process elements in reading order (top-to-bottom, left-to-right)
    twos.sort()
    for r, c in twos:
        h = barrier_heights[c]
        settled_row = height - h - 1
        if settled_row < 0 or settled_row >= height:
            continue
        # center becomes wavefront color 3
        output[settled_row][c] = 3
        # propagate in four cardinal directions up to h steps, stopping on 1 or 3 or grid edge
        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            for i in range(1, h + 1):
                nr = settled_row + dr * i
                nc = c + dc * i
                if nr < 0 or nr >= height or nc < 0 or nc >= width:
                    break
                if output[nr][nc] == 1:
                    break
                if output[nr][nc] == 3:
                    break
                output[nr][nc] = 3

    return output

