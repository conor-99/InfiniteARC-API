# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 586437f1
Difficulty: insane

=== Tags ===
- Line collision

=== Description ===
Line Collision Cascade  Input grids feature intricate networks of straight-line
segments (horizontal, vertical, diagonal) in colors 1-9, where each color
encodes a fixed movement direction (e.g., color 1 = right, color 2 = up, color 3
= left, color 4 = down, color 5 = northeast, etc.). Lines move continuously in
their assigned direction until colliding with another line segment. Each
intersection point between two lines triggers a collision event:  1. The
intersection cell color is determined by a consistent visual color combination
rule (e.g., color A and B combine to produce color C in a predefined pattern).
2. Lines reflect off each other at the collision point, changing direction per a
geometric reflection rule (e.g., a right-moving line colliding with an up-moving
line will now move up, while the up-moving line moves right). 3. Line segments
beyond the intersection continue in their new reflected directions, maintaining
colors corresponding to their updated movement directions.  The output grid must
resolve all collisions in sequence, extending lines with new directions while
preserving the color combination rule at every intersection. Non-colliding
segments remain unchanged. The task requires recognizing direction mappings from
colors, applying geometric reflection logic to multi-segment collisions, and
executing consistent color transformations across all intersection
pointsâ€”resulting in a visually transformed grid where lines "bounce" off each
other while altering their color pathways.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    from common import grid, randint
    
    width = randint(5, 30)
    height = randint(5, 30)
    input_grid = grid(width, height, 0)
    output_grid = grid(width, height, 0)
    
    # Choose collision type
    collision_type = randint(0, 2)
    if collision_type == 0:
        color1, color2 = 1, 3
        r = randint(1, height - 2)
        c = randint(1, width - 3)
        input_grid[r][c] = color1
        input_grid[r][c + 2] = color2
        collision_color = (color1 + color2) % 9 + 1
        output_grid[r][c + 1] = collision_color
    elif collision_type == 1:
        color1, color2 = 2, 4
        r = randint(2, height - 1)
        c = randint(1, width - 2)
        input_grid[r][c] = color1
        input_grid[r - 2][c] = color2
        collision_color = (color1 + color2) % 9 + 1
        output_grid[r - 1][c] = collision_color
    else:
        color1, color2 = 5, 7
        r = randint(2, height - 2)
        c = randint(2, width - 3)  # Fixed: c+2 must be within bounds
        input_grid[r][c] = color1
        input_grid[r - 2][c + 2] = color2
        collision_color = (color1 + color2) % 9 + 1
        output_grid[r - 1][c + 1] = collision_color
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    from common import grid
    width = len(input_grid[0])
    height = len(input_grid)
    
    directions = {
        1: (0, 1),
        2: (-1, 0),
        3: (0, -1),
        4: (1, 0),
        5: (-1, 1),
        6: (-1, -1),
        7: (1, -1),
        8: (1, 1)
    }
    
    from collections import defaultdict
    next_positions = defaultdict(list)
    
    for r in range(height):
        for c in range(width):
            color = input_grid[r][c]
            if color == 0:
                continue
            dr, dc = directions[color]
            nr = r + dr
            nc = c + dc
            if 0 <= nr < height and 0 <= nc < width:
                next_positions[(nr, nc)].append(color)
    
    output_grid = grid(width, height, 0)
    for (r, c), colors in next_positions.items():
        if len(colors) >= 2:
            color1, color2 = colors[0], colors[1]
            collision_color = (color1 + color2) % 9 + 1
            output_grid[r][c] = collision_color
    
    return output_grid
