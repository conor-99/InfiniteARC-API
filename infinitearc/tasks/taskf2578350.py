# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: f2578350
Difficulty: hard

=== Tags ===
- Dual grid translation

=== Description ===
Task Name: Central Axis Symmetric Translation  Description: Input grids contain
a central axis (vertical or horizontal, corresponding to the grid's midpoint)
and two mirror-image patterns of distinct non-background colors positioned on
opposite sides of this axis. Each pattern consists of a contiguous region of
cells (connected orthogonally) of a single color. The output grid is generated
by translating each pattern toward the central axis by a distance equal to the
minimum distance between any cell in the pattern and the axis. For vertical axes
(midpoint column), the left pattern moves right and the right pattern moves
left; for horizontal axes (midpoint row), the top pattern moves down and the
bottom pattern moves up. The translation preserves the pattern's color and
shape, and stops when the pattern reaches the axis or grid boundary. Background
cells remain unchanged, and patterns do not overlap with the axis or each other
during translation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

# Generator for ARC task: Central Axis Symmetric Translation
# Produces grids with two mirror-image contiguous single-color patterns
# placed on opposite sides of a central axis (vertical or horizontal).
# Each pattern is translated toward the axis so its nearest cell becomes
# adjacent to the axis (one cell away). This avoids placing any pattern
# cell directly on the axis and ensures no overlap between patterns.

def _choose_odd(low, high):
    """Choose a random odd integer between low and high inclusive."""
    odds = [x for x in range(low, high + 1) if x % 2 == 1]
    return random.choice(odds)


def generate():
    # Try until we make a valid grid (rarely loops more than once)
    for _ in range(100):
        axis = random.choice(['vertical', 'horizontal'])
        # Pick sizes with enough room to place a shape and leave a gap to the axis
        if axis == 'vertical':
            width = _choose_odd(5, 29)  # ensure there is at least one column on each side and a center
            height = random.randint(3, 29)
            m = (width - 1) // 2  # center column index
            left_box_width = m - 1  # force at least one-column gap from axis initially
            if left_box_width < 1:
                continue

            # Size of the left pattern (contiguous creature)
            max_size = min(left_box_width * height, 12)
            size = random.randint(2, max(2, max_size))
            # Create a contiguous creature inside the left box (width=left_box_width)
            left_pixels = common.continuous_creature(size, left_box_width, height)
            # Shift vertically and (optionally) horizontally within the left box to randomize placement
            min_r = min(p[0] for p in left_pixels)
            max_r = max(p[0] for p in left_pixels)
            min_c = min(p[1] for p in left_pixels)
            max_c = max(p[1] for p in left_pixels)
            vert_span = max_r - min_r + 1
            horiz_span = max_c - min_c + 1
            r_offset = random.randint(0, height - vert_span)
            c_offset = random.randint(0, left_box_width - horiz_span)
            left_pixels = [(r + r_offset, c + c_offset) for (r, c) in left_pixels]

            # Mirror to the right side
            right_pixels = [(r, width - 1 - c) for (r, c) in left_pixels]

            # Pick two distinct non-zero colors
            color_left = common.random_color(exclude=[0])
            color_right = common.random_color(exclude=[0, color_left])

            # Build input grid
            grid_in = common.grid(width, height, 0)
            for (r, c) in left_pixels:
                grid_in[r][c] = color_left
            for (r, c) in right_pixels:
                grid_in[r][c] = color_right

            # Compute minimal distances to the central axis and the translation distances.
            # We translate so the nearest cell becomes adjacent to the axis (one cell away).
            min_dist_left = min(m - c for (r, c) in left_pixels)
            min_dist_right = min(c - m for (r, c) in right_pixels)
            d_left = max(0, min_dist_left - 1)
            d_right = max(0, min_dist_right - 1)

            # Create output grid by moving pixels toward the axis
            grid_out = common.grid(width, height, 0)
            for (r, c) in left_pixels:
                new_c = c + d_left
                # safety clamp
                new_c = min(new_c, m - 1)
                grid_out[r][new_c] = color_left
            for (r, c) in right_pixels:
                new_c = c - d_right
                new_c = max(new_c, m + 1)
                grid_out[r][new_c] = color_right

            # Sanity checks: ensure input != output and shapes don't touch the axis in input
            # (these should hold given construction)
            if grid_in != grid_out:
                return {"input": grid_in, "output": grid_out}

        else:
            # Horizontal axis
            height = _choose_odd(5, 29)
            width = random.randint(3, 29)
            n = (height - 1) // 2  # center row index
            top_box_height = n - 1
            if top_box_height < 1:
                continue

            max_size = min(width * top_box_height, 12)
            size = random.randint(2, max(2, max_size))
            top_pixels = common.continuous_creature(size, width, top_box_height)

            # Shift within the top box
            min_r = min(p[0] for p in top_pixels)
            max_r = max(p[0] for p in top_pixels)
            min_c = min(p[1] for p in top_pixels)
            max_c = max(p[1] for p in top_pixels)
            vert_span = max_r - min_r + 1
            horiz_span = max_c - min_c + 1
            r_offset = random.randint(0, top_box_height - vert_span)
            c_offset = random.randint(0, width - horiz_span)
            top_pixels = [(r + r_offset, c + c_offset) for (r, c) in top_pixels]

            # Mirror to bottom
            bottom_pixels = [(height - 1 - r, c) for (r, c) in top_pixels]

            color_top = common.random_color(exclude=[0])
            color_bottom = common.random_color(exclude=[0, color_top])

            grid_in = common.grid(width, height, 0)
            for (r, c) in top_pixels:
                grid_in[r][c] = color_top
            for (r, c) in bottom_pixels:
                grid_in[r][c] = color_bottom

            min_dist_top = min(n - r for (r, c) in top_pixels)
            min_dist_bottom = min(r - n for (r, c) in bottom_pixels)
            d_top = max(0, min_dist_top - 1)
            d_bottom = max(0, min_dist_bottom - 1)

            grid_out = common.grid(width, height, 0)
            for (r, c) in top_pixels:
                new_r = r + d_top
                new_r = min(new_r, n - 1)
                grid_out[new_r][c] = color_top
            for (r, c) in bottom_pixels:
                new_r = r - d_bottom
                new_r = max(new_r, n + 1)
                grid_out[new_r][c] = color_bottom

            if grid_in != grid_out:
                return {"input": grid_in, "output": grid_out}

    # Fallback (should never be reached)
    raise RuntimeError('Failed to generate a valid grid after many attempts')



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    # Convert to mutable list-of-lists
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])
    m = (width - 1) // 2
    n = (height - 1) // 2

    # Collect all non-zero pixels
    nonzero = []
    for r in range(height):
        for c in range(width):
            if grid_in[r][c] != 0:
                nonzero.append((r, c))

    # If no nonzero pixels, return original grid
    if not nonzero:
        return grid_in

    # Find connected components of non-zero pixels (orthogonal adjacency)
    visited = set()
    components = []  # list of lists of (r,c)
    for (sr, sc) in nonzero:
        if (sr, sc) in visited:
            continue
        color = grid_in[sr][sc]
        queue = [(sr, sc)]
        comp = []
        visited.add((sr, sc))
        while queue:
            cr, cc = queue.pop(0)
            comp.append((cr, cc))
            for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                nr, nc = cr + dr, cc + dc
                if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in visited and grid_in[nr][nc] != 0:
                    visited.add((nr, nc))
                    queue.append((nr, nc))
        components.append(comp)

    # Expect two components (top/bottom or left/right). If not, attempt grouping by color as fallback.
    if len(components) != 2:
        # Group pixels by color
        comps_by_color = {}
        for r in range(height):
            for c in range(width):
                v = grid_in[r][c]
                if v == 0: continue
                comps_by_color.setdefault(v, []).append((r,c))
        components = list(comps_by_color.values())

    # If still not 2, return input (nothing to do)
    if len(components) != 2:
        return grid_in

    comp_a, comp_b = components[0], components[1]

    # Compute bounding boxes for components
    def bbox(comp):
        rs = [p[0] for p in comp]
        cs = [p[1] for p in comp]
        return min(rs), max(rs), min(cs), max(cs)

    a_min_r, a_max_r, a_min_c, a_max_c = bbox(comp_a)
    b_min_r, b_max_r, b_min_c, b_max_c = bbox(comp_b)

    # Decide orientation: vertical if components lie strictly on opposite sides of center column m
    is_vertical = (a_max_c < m and b_min_c > m) or (b_max_c < m and a_min_c > m)
    is_horizontal = (a_max_r < n and b_min_r > n) or (b_max_r < n and a_min_r > n)

    # If ambiguous, decide by which separation is larger (avg distance to vertical vs horizontal axis)
    if not is_vertical and not is_horizontal:
        def avg_col(comp):
            return sum(p[1] for p in comp) / len(comp)
        def avg_row(comp):
            return sum(p[0] for p in comp) / len(comp)
        # If the components are more separated horizontally (by columns), treat as vertical axis
        col_sep = abs(avg_col(comp_a) - avg_col(comp_b))
        row_sep = abs(avg_row(comp_a) - avg_row(comp_b))
        is_vertical = col_sep >= row_sep
        is_horizontal = not is_vertical

    # Prepare output grid
    grid_out = common.grid(width, height, 0)

    if is_vertical:
        # Determine which is left and which is right
        # If ambiguous, pick by average column
        avg_col_a = sum(p[1] for p in comp_a) / len(comp_a)
        avg_col_b = sum(p[1] for p in comp_b) / len(comp_b)
        if avg_col_a < avg_col_b:
            left_comp, right_comp = comp_a, comp_b
        else:
            left_comp, right_comp = comp_b, comp_a

        # Compute distances to center column m and translate so nearest cell ends adjacent to axis
        d_left = max(0, min(m - c for (r,c) in left_comp) - 1)
        d_right = max(0, min(c - m for (r,c) in right_comp) - 1)

        # Move left component rightwards and right component leftwards
        for (r, c) in left_comp:
            new_c = c + d_left
            new_c = min(new_c, m - 1)
            grid_out[r][new_c] = grid_in[r][c]
        for (r, c) in right_comp:
            new_c = c - d_right
            new_c = max(new_c, m + 1)
            grid_out[r][new_c] = grid_in[r][c]

    else:
        # Horizontal axis: determine top and bottom by average row
        avg_row_a = sum(p[0] for p in comp_a) / len(comp_a)
        avg_row_b = sum(p[0] for p in comp_b) / len(comp_b)
        if avg_row_a < avg_row_b:
            top_comp, bottom_comp = comp_a, comp_b
        else:
            top_comp, bottom_comp = comp_b, comp_a

        d_top = max(0, min(n - r for (r,c) in top_comp) - 1)
        d_bottom = max(0, min(r - n for (r,c) in bottom_comp) - 1)

        for (r, c) in top_comp:
            new_r = r + d_top
            new_r = min(new_r, n - 1)
            grid_out[new_r][c] = grid_in[r][c]
        for (r, c) in bottom_comp:
            new_r = r - d_bottom
            new_r = max(new_r, n + 1)
            grid_out[new_r][c] = grid_in[r][c]

    return grid_out

