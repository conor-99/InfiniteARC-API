# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: e52a931f
Difficulty: insane

=== Tags ===
- Agent memory trace
- Connect nearest components
- Direction guessing

=== Description ===
Input grids consist of multiple colored trails (each color representing a
distinct agent's path), where each trail is a contiguous sequence of cells
connected horizontally or vertically. Each trail has a defined direction
determined by its final movement segment (e.g., a trail ending with cells moving
right implies a "right" direction). The direction must be inferred from the
geometric path shape, not numerical values or color properties.  The output grid
requires drawing single-cell-wide lines from the endpoint of each trail in the
direction of its last movement segment. The line extends until it first
encounters a cell belonging to another trail, connecting to that point. Lines
must be drawn exclusively over background cells, avoiding overlap with existing
trails, walls, or other lines. The nearest connection point is determined by the
first encountered cell of another trail along the movement direction, not by
Euclidean distance.  This task demands multi-step reasoning: first, identifying
the direction of each trail's final movement from its geometry; second, locating
the nearest point along that direction within another trail; third, drawing the
line without violating spatial constraints. The complexity arises from non-
linear trail paths, overlapping movement directions, and the need to
simultaneously track multiple agents' memory traces while avoiding path
obstructions. The "insane" difficulty is achieved through dense trail
configurations, ambiguous direction cues in winding paths, and the requirement
to resolve directional conflicts through contextual inference.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    """
    Generates an ARC-style input/output pair matching the task description.

    Strategy:
    - Create a central 1-row "hub" (one color) that will act as the target trail.
    - For each other trail (each its own color), create a vertical straight-line trail
      that ends somewhere above or below the hub in the same column as a unique hub cell.
      The trail's final movement is therefore vertically toward the hub.
    - The output is obtained by drawing a vertical line from each trail's endpoint toward
      the hub until the cell immediately before the hub cell (i.e., the first encountered
      non-background cell). Lines are drawn only over background cells and do not overwrite
      any trail cells.

    The generator ensures there is at least one drawn line (so input != output) and
    that trails do not overlap.
    """
    for overall_attempt in range(100):
        width = random.randint(15, 25)
        height = random.randint(15, 25)
        grid = [[0 for _ in range(width)] for _ in range(height)]

        # Choose how many trails (including hub) and colors
        total_colors = random.randint(4, 6)  # 1 hub + 3-5 peripheral trails
        colors = random.sample(list(range(1, 10)), total_colors)
        hub_color = colors[0]
        peripheral_colors = colors[1:]
        n_peripherals = len(peripheral_colors)

        # Place a single-row hub somewhere near the vertical center
        hub_row = height // 2
        # Make sure hub has at least as many cells as peripheral trails (unique targets)
        min_hub_cols = n_peripherals
        max_hub_cols = min(width - 4, n_peripherals + 2)
        if max_hub_cols < min_hub_cols:
            # If grid is too narrow to satisfy constraints, pick another overall size
            continue
        hub_cols = random.randint(min_hub_cols, max_hub_cols)
        hub_left = random.randint(2, width - hub_cols - 2)

        hub_positions = []
        for i in range(hub_cols):
            c = hub_left + i
            grid[hub_row][c] = hub_color
            hub_positions.append((hub_row, c))

        # Choose unique target hub cells for each peripheral trail
        targets = random.sample(hub_positions, n_peripherals)

        occupied = set(hub_positions)
        trails = []  # list of (color, path_cells_list)

        failed = False
        for color, target in zip(peripheral_colors, targets):
            tr, tc = target
            # Determine feasible approaches: above (draw down) or below (draw up)
            feasible = []
            if tr >= 2:
                feasible.append('above')
            if tr <= height - 3:
                feasible.append('below')
            if not feasible:
                failed = True
                break

            placed = False
            for attempt in range(60):
                side = random.choice(feasible)
                if side == 'above':
                    # endpoint must be at least 2 cells above the target to leave room to draw
                    r_end = random.randint(0, tr - 2)
                    # choose a small length for the trail (>=2), staying inside the grid
                    max_len = min(6, r_end + 1)
                    if max_len < 2:
                        continue
                    L = random.randint(2, max_len)
                    start_r = r_end - (L - 1)
                    # path ordered from start (furthest from hub) to endpoint (closest to hub)
                    path = [(r, tc) for r in range(start_r, r_end + 1)]
                else:  # below
                    r_end = random.randint(tr + 2, height - 1)
                    max_len = min(6, height - r_end)
                    if max_len < 2:
                        continue
                    L = random.randint(2, max_len)
                    # start_r is the farthest cell (furthest from hub), greater than r_end
                    start_r = r_end + (L - 1)
                    # path ordered from start (furthest from hub) down to endpoint r_end
                    path = [(r, tc) for r in range(start_r, r_end - 1, -1)]

                # ensure path does not collide with occupied cells
                collision = False
                for cell in path:
                    if cell in occupied:
                        collision = True
                        break
                if collision:
                    continue

                # place the path
                for (r, c) in path:
                    grid[r][c] = color
                    occupied.add((r, c))
                trails.append((color, path))
                placed = True
                break

            if not placed:
                failed = True
                break

        if failed:
            # try again from scratch
            continue

        # Build the output grid by drawing from each trail's endpoint towards the first encountered
        # other-trail cell in that direction. Lines are drawn over background cells only.
        output_grid = [row[:] for row in grid]
        drew_any = False
        for color, path in trails:
            if len(path) < 2:
                continue
            last = path[-1]
            prev = path[-2]
            dr = last[0] - prev[0]
            dc = last[1] - prev[1]
            r, c = last[0] + dr, last[1] + dc
            target = None
            while 0 <= r < height and 0 <= c < width:
                if grid[r][c] != 0:
                    if grid[r][c] != color:
                        target = (r, c)
                    break
                r += dr
                c += dc
            if target is None:
                continue
            # draw from the cell after last until the cell before target (do not overwrite target)
            r_draw, c_draw = last[0] + dr, last[1] + dc
            stop_r, stop_c = target[0] - dr, target[1] - dc
            # if the draw region is empty (endpoint adjacent to target), skip drawing
            if (r_draw, c_draw) == (target[0], target[1]):
                continue
            while True:
                if (r_draw, c_draw) in occupied and grid[r_draw][c_draw] != 0:
                    # Safety: don't overwrite other trails (shouldn't happen given construction)
                    break
                output_grid[r_draw][c_draw] = color
                drew_any = True
                if (r_draw, c_draw) == (stop_r, stop_c):
                    break
                r_draw += dr
                c_draw += dc

        if not drew_any:
            # ensure at least one line was drawn; otherwise regenerate
            continue

        # Final sanity checks: input must not equal output
        if grid == output_grid:
            continue

        return {"input": grid, "output": output_grid}

    # If we exit the loop without a valid construction, raise an error
    raise RuntimeError('Failed to generate a valid grid after many attempts')



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert immutable input to a list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # Prepare output as a copy of input
    output = [row[:] for row in grid]

    # Collect colors present (excluding background 0)
    colors = set()
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if v != 0:
                colors.add(v)

    # For each color, find its connected component cells and endpoints
    for color in colors:
        # collect cells of this color
        cells = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == color]
        if not cells:
            continue
        # For each cell compute number of orthogonal neighbors of same color
        endpoints = []
        for (r, c) in cells:
            neighbors = 0
            for dr, dc in ((1,0), (-1,0), (0,1), (0,-1)):
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == color:
                    neighbors += 1
            if neighbors == 1:
                endpoints.append((r, c))
        # For each endpoint, determine the direction of the last movement and draw
        for (r, c) in endpoints:
            # find the neighbor that belongs to the same color (the previous cell)
            prev = None
            for dr, dc in ((1,0), (-1,0), (0,1), (0,-1)):
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == color:
                    prev = (nr, nc)
                    break
            if prev is None:
                # isolated single-cell trail: no direction can be inferred
                continue
            dr_dir = r - prev[0]
            dc_dir = c - prev[1]

            # Step from the endpoint in the inferred direction until we hit a non-background cell
            rr, cc = r + dr_dir, c + dc_dir
            target = None
            while 0 <= rr < height and 0 <= cc < width:
                if grid[rr][cc] != 0:
                    # Stop at the first non-background cell
                    if grid[rr][cc] != color:
                        target = (rr, cc)
                    break
                rr += dr_dir
                cc += dc_dir

            # If we didn't find a different-colored target or we hit the border, do nothing
            if target is None:
                continue

            # Fill the background cells from the cell after the endpoint up to the cell
            # immediately before the target cell.
            r_fill, c_fill = r + dr_dir, c + dc_dir
            end_r, end_c = target[0] - dr_dir, target[1] - dc_dir
            # If endpoint is adjacent to the other trail, there's nothing to draw
            if (r_fill, c_fill) == (target[0], target[1]):
                continue

            while True:
                # Safety: do not overwrite non-background cells
                if grid[r_fill][c_fill] != 0:
                    break
                output[r_fill][c_fill] = color
                if (r_fill, c_fill) == (end_r, end_c):
                    break
                r_fill += dr_dir
                c_fill += dc_dir

    # Return as immutable tuple-of-tuples
    return tuple(tuple(row) for row in output)

