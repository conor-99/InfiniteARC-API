# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 695f0fb4
Difficulty: hard

=== Tags ===
- Cooperative rule network
- Separate images
- Repaint border

=== Description ===
# Cooperative Border Network  Input grids contain multiple disconnected, non-
overlapping shapes (referred to as "separate images") each defined by a solid
border of a single color (0-9) surrounding a filled interior. The background
color is a single uniform value distinct from all border colors. Shapes are
arranged such that some borders touch adjacent shapes (sharing edge pixels),
forming connected components where two shapes belong to the same component if
they are horizontally or vertically adjacent. Each shape's border color is
unique within the input grid.  The output grid transforms the input through a
cooperative border network rule: for each connected component of shapes,
determine the most frequently occurring border color among all shapes in that
component. In case of a tie for most frequent, select the smallest color number.
All shapes within the component have their borders repainted to this selected
color. Shapes with no adjacent neighbors (singleton components) retain their
original color if it's the most frequent (trivially), but will be repainted to
the smallest color in the tiebreaker case.  The transformation requires
examining the entire component structure and color distribution, making it
impossible to solve by processing individual shapes in isolation. The output
grid must preserve all shape positions and interior fills, with only border
colors changing according to the component-wide rule. This creates complex
visual patterns where borders merge and align across previously disconnected
shapes, forming larger coherent regions in the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid


def generate():
    """Generate an input/output pair for the Cooperative Border Network task.

    The generator builds a grid with a uniform background and several rectangular
    shapes. Each shape has a unique border color (different from the background)
    and a filled interior color (different from the background and from any
    border color). Shapes are placed without overlapping; some shapes are
    intentionally placed to touch another shape along their borders (edge
    adjacency). The output recolors all borders in each connected component of
    touching shapes to the most frequent border color in that component
    (ties -> smallest color).
    """
    # Try multiple times to produce a valid layout (avoid pathological failures)
    for attempt in range(200):
        width = random.randint(10, 30)
        height = random.randint(10, 30)
        bg = random.randint(0, 9)
        ingrid = grid(width, height, bg)

        # Available colors for borders (must be distinct from bg)
        available_border_colors = [c for c in range(10) if c != bg]
        max_shapes = min(len(available_border_colors), random.randint(3, 6))

        shapes = []  # list of dicts with keys: r,c,w,h,border,interior
        used_border_colors = set()

        def area_is_free(r, c, w, h):
            if r < 0 or c < 0 or r + h > height or c + w > width:
                return False
            for rr in range(r, r + h):
                for cc in range(c, c + w):
                    if ingrid[rr][cc] != bg:
                        return False
            return True

        def place_rectangle(r, c, w, h, border_col, interior_col):
            for rr in range(r, r + h):
                for cc in range(c, c + w):
                    if rr == r or rr == r + h - 1 or cc == c or cc == c + w - 1:
                        ingrid[rr][cc] = border_col
                    else:
                        ingrid[rr][cc] = interior_col
            shapes.append({
                'r': r, 'c': c, 'w': w, 'h': h,
                'border': border_col, 'interior': interior_col
            })

        ensured_adjacent = False
        failed = False

        for si in range(max_shapes):
            # choose border color distinct from bg and previously used border colors
            border_choices = [c for c in range(10) if c != bg and c not in used_border_colors]
            if not border_choices:
                failed = True
                break
            border_col = random.choice(border_choices)
            used_border_colors.add(border_col)

            # choose interior color distinct from bg and from any border color
            interior_choices = [c for c in range(10) if c != bg and c not in used_border_colors]
            if not interior_choices:
                # If no interior choices left (very unlikely), allow any non-bg color
                interior_choices = [c for c in range(10) if c != bg]
            interior_col = random.choice(interior_choices)

            placed = False

            # Prefer adjacency for the second shape to guarantee at least one touching pair
            if si > 0 and not ensured_adjacent:
                # Try to place adjacent to an existing shape
                base_indices = list(range(len(shapes)))
                random.shuffle(base_indices)
                for base_idx in base_indices:
                    base = shapes[base_idx]
                    r0, c0, w0, h0 = base['r'], base['c'], base['w'], base['h']
                    # try sides in random order
                    sides = ['below', 'above', 'right', 'left']
                    random.shuffle(sides)
                    for side in sides:
                        # try a few random sizes and alignments for the new rectangle
                        for _try in range(60):
                            new_w = random.randint(3, min(8, width))
                            new_h = random.randint(3, min(8, height))
                            if side == 'below':
                                new_r = r0 + h0  # immediate row below base
                                if new_r + new_h > height:
                                    continue
                                # ensure horizontal intervals overlap so borders touch
                                min_c = max(0, c0 - new_w + 1)
                                max_c_ = min(width - new_w, c0 + w0 - 1)
                                if min_c > max_c_:
                                    continue
                                new_c = random.randint(min_c, max_c_)
                            elif side == 'above':
                                new_r = r0 - new_h
                                if new_r < 0:
                                    continue
                                min_c = max(0, c0 - new_w + 1)
                                max_c_ = min(width - new_w, c0 + w0 - 1)
                                if min_c > max_c_:
                                    continue
                                new_c = random.randint(min_c, max_c_)
                            elif side == 'right':
                                new_c = c0 + w0
                                if new_c + new_w > width:
                                    continue
                                min_r = max(0, r0 - new_h + 1)
                                max_r_ = min(height - new_h, r0 + h0 - 1)
                                if min_r > max_r_:
                                    continue
                                new_r = random.randint(min_r, max_r_)
                            else:  # left
                                new_c = c0 - new_w
                                if new_c < 0:
                                    continue
                                min_r = max(0, r0 - new_h + 1)
                                max_r_ = min(height - new_h, r0 + h0 - 1)
                                if min_r > max_r_:
                                    continue
                                new_r = random.randint(min_r, max_r_)

                            if area_is_free(new_r, new_c, new_w, new_h):
                                place_rectangle(new_r, new_c, new_w, new_h, border_col, interior_col)
                                placed = True
                                ensured_adjacent = True
                                break
                        if placed:
                            break
                    if placed:
                        break

            # If not placed yet, do a generic placement anywhere free
            if not placed:
                # Try some random placements
                for _try in range(600):
                    new_w = random.randint(3, min(8, width))
                    new_h = random.randint(3, min(8, height))
                    new_r = random.randint(0, height - new_h)
                    new_c = random.randint(0, width - new_w)
                    if area_is_free(new_r, new_c, new_w, new_h):
                        place_rectangle(new_r, new_c, new_w, new_h, border_col, interior_col)
                        placed = True
                        break

            if not placed:
                failed = True
                break

        if failed:
            continue

        # Compute adjacency among placed shapes (by border pixel neighbors)
        border_sets = []
        for s in shapes:
            br = set()
            for rr in range(s['r'], s['r'] + s['h']):
                for cc in range(s['c'], s['c'] + s['w']):
                    if rr == s['r'] or rr == s['r'] + s['h'] - 1 or cc == s['c'] or cc == s['c'] + s['w'] - 1:
                        br.add((rr, cc))
            border_sets.append(br)

        n = len(shapes)
        adj = [[False] * n for _ in range(n)]
        for i in range(n):
            for j in range(i + 1, n):
                found = False
                Bs = border_sets[i]
                Bt = border_sets[j]
                # iterate the smaller set for speed
                if len(Bs) < len(Bt):
                    small, big = Bs, Bt
                else:
                    small, big = Bt, Bs
                for (rr, cc) in small:
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        if (rr + dr, cc + dc) in big:
                            adj[i][j] = True
                            adj[j][i] = True
                            found = True
                            break
                    if found:
                        break

        # Ensure at least one adjacency exists (some touching pair). If not, retry.
        any_adj = any(adj[i][j] for i in range(n) for j in range(i + 1, n))
        if not any_adj:
            # force regeneration to satisfy the problem constraint that some borders touch
            continue

        # Build components of shapes and compute target colors for each component
        visited = [False] * n
        components = []
        for i in range(n):
            if not visited[i]:
                stack = [i]
                comp = []
                visited[i] = True
                while stack:
                    node = stack.pop()
                    comp.append(node)
                    for j in range(n):
                        if adj[node][j] and not visited[j]:
                            visited[j] = True
                            stack.append(j)
                components.append(comp)

        # Create output by copying input and repainting borders
        output = [row[:] for row in ingrid]
        for comp in components:
            border_colors = [shapes[idx]['border'] for idx in comp]
            # count frequencies
            freq = {}
            for col in border_colors:
                freq[col] = freq.get(col, 0) + 1
            max_count = max(freq.values())
            candidates = [col for col, ct in freq.items() if ct == max_count]
            target = min(candidates)
            for idx in comp:
                s = shapes[idx]
                for rr in range(s['r'], s['r'] + s['h']):
                    for cc in range(s['c'], s['c'] + s['w']):
                        if rr == s['r'] or rr == s['r'] + s['h'] - 1 or cc == s['c'] or cc == s['c'] + s['w'] - 1:
                            output[rr][cc] = target

        return {"input": ingrid, "output": output}

    # If generation loop fails too many times, raise an error
    raise RuntimeError('Failed to generate a valid grid after many attempts')



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import Counter

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Determine background color as the most frequent color in the grid
    counts = {}
    for r in range(height):
        for c in range(width):
            counts[grid[r][c]] = counts.get(grid[r][c], 0) + 1
    bg = max(counts.items(), key=lambda x: x[1])[0]

    # Find connected components of same color (4-connected)
    visited = [[False] * width for _ in range(height)]
    comps_by_color = {}  # color -> list of components (each a list of (r,c))
    for r in range(height):
        for c in range(width):
            if grid[r][c] == bg or visited[r][c]:
                continue
            col = grid[r][c]
            stack = [(r, c)]
            visited[r][c] = True
            comp = []
            while stack:
                rr, cc = stack.pop()
                comp.append((rr, cc))
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == col:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            comps_by_color.setdefault(col, []).append(comp)

    # Identify rectangular shapes by finding components that exactly form a rectangular border
    shapes = []  # list of dicts with keys: r,c,w,h,border,interior,border_positions
    for color, comp_list in comps_by_color.items():
        for comp in comp_list:
            coords = comp
            min_r = min(p[0] for p in coords)
            max_r = max(p[0] for p in coords)
            min_c = min(p[1] for p in coords)
            max_c = max(p[1] for p in coords)
            h = max_r - min_r + 1
            w = max_c - min_c + 1
            if h < 3 or w < 3:
                continue
            # expected border positions for that bounding box
            border_positions = set()
            for rr in range(min_r, max_r + 1):
                for cc in range(min_c, max_c + 1):
                    if rr == min_r or rr == max_r or cc == min_c or cc == max_c:
                        border_positions.add((rr, cc))
            comp_set = set(coords)
            if comp_set != border_positions:
                continue
            # check interior is uniform and not equal to border or background
            interior_colors = set()
            for rr in range(min_r + 1, max_r):
                for cc in range(min_c + 1, max_c):
                    interior_colors.add(grid[rr][cc])
            if len(interior_colors) != 1:
                continue
            interior_col = next(iter(interior_colors))
            if interior_col == bg or interior_col == color:
                continue
            shapes.append({
                'r': min_r, 'c': min_c, 'w': w, 'h': h,
                'border': color, 'interior': interior_col,
                'border_positions': border_positions
            })

    # Build adjacency between shapes: two shapes adjacent if any border cell is orthogonally next to a border cell of the other
    n = len(shapes)
    adj = [[False] * n for _ in range(n)]
    for i in range(n):
        for j in range(i + 1, n):
            Bi = shapes[i]['border_positions']
            Bj = shapes[j]['border_positions']
            # iterate smaller set for speed
            if len(Bi) < len(Bj):
                small, big = Bi, Bj
            else:
                small, big = Bj, Bi
            found = False
            for (rr, cc) in small:
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    if (rr + dr, cc + dc) in big:
                        adj[i][j] = True
                        adj[j][i] = True
                        found = True
                        break
                if found:
                    break

    # Find connected groups of shapes
    visited_shape = [False] * n
    groups = []
    for i in range(n):
        if not visited_shape[i]:
            stack = [i]
            visited_shape[i] = True
            group = []
            while stack:
                node = stack.pop()
                group.append(node)
                for nb in range(n):
                    if adj[node][nb] and not visited_shape[nb]:
                        visited_shape[nb] = True
                        stack.append(nb)
            groups.append(group)

    # Repaint borders per group according to most frequent border color (ties -> smallest)
    output = [row[:] for row in grid]
    for group in groups:
        border_colors = [shapes[i]['border'] for i in group]
        if not border_colors:
            continue
        cnt = Counter(border_colors)
        max_count = max(cnt.values())
        candidates = [col for col, ct in cnt.items() if ct == max_count]
        target = min(candidates)
        for idx in group:
            for (rr, cc) in shapes[idx]['border_positions']:
                output[rr][cc] = target

    return tuple(tuple(row) for row in output)

