# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: a7aca30e
Difficulty: very hard

=== Tags ===
- Cyclic painting
- Pattern completion
- Transformation stack
- Recursive partition

=== Description ===
Input grids consist of a single background color (0) and multiple contiguous
colored regions (4-connected) that form irregular shapes. Each region contains a
partial sequence of colors cycling through a fixed order (e.g., 1→2→3→...→9→1),
but some cells within the region are missing their color (background 0). The
output grid completes each region by filling missing cells with the next color
in the cycle, where the direction (forward or reverse) depends on the region's
position within a recursively partitioned grid structure.  The grid undergoes
recursive quadrant partitioning: at each level, the current grid is divided into
four quadrants (top-left, top-right, bottom-left, bottom-right). For each
quadrant, the pattern completion is applied using a cycle direction determined
by the quadrant's position (top-left/bottom-right: forward; top-right/bottom-
left: reverse) and the recursion depth (even depths: forward; odd depths:
reverse). Each recursive step processes sub-quadrants until they reach a minimum
size (2×2). The transformation stack sequentially applies these recursive
completions, advancing the cycle direction at each level. Missing cells are
filled only over background, preserving all original non-background cells and
ensuring no overlaps. The completed patterns maintain visual continuity across
recursive levels, with cycle direction alternations creating intricate, non-
repeating visual sequences.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = 16
    height = 16
    output_grid = grid(width, height, 0)

    def add_color(c, delta):
        return ((c - 1 + delta) % 9) + 1

    def process(r0, r1, c0, c1, depth, q_last):
        h = r1 - r0
        w = c1 - c0
        if h == 2 and w == 2:
            # Determine base direction from this quadrant index (relative to parent)
            if q_last is None:
                base_dir = True
            else:
                base_dir = (q_last in (0, 3))
            final_dir = base_dir if (depth % 2 == 0) else (not base_dir)

            start_color = random.randint(1, 9)
            idx = 0
            for rr in range(r0, r1):
                for cc in range(c0, c1):
                    if final_dir:
                        color = add_color(start_color, idx)
                    else:
                        color = add_color(start_color, -idx)
                    output_grid[rr][cc] = color
                    idx += 1
            return

        mid_r = (r0 + r1) // 2
        mid_c = (c0 + c1) // 2
        # TL
        process(r0, mid_r, c0, mid_c, depth + 1, 0)
        # TR
        process(r0, mid_r, mid_c, c1, depth + 1, 1)
        # BL
        process(mid_r, r1, c0, mid_c, depth + 1, 2)
        # BR
        process(mid_r, r1, mid_c, c1, depth + 1, 3)

    process(0, height, 0, width, 0, None)

    # Create input by blanking some cells in each 2x2 block, ensuring at least one cell remains
    input_grid = [row[:] for row in output_grid]
    blank_p = 0.4
    for r0 in range(0, height, 2):
        for c0 in range(0, width, 2):
            # Blank each cell with probability blank_p
            for rr in range(r0, r0 + 2):
                for cc in range(c0, c0 + 2):
                    if random.random() < blank_p:
                        input_grid[rr][cc] = 0
            # Ensure at least one cell remains non-zero in the block
            all_zero = True
            for rr in range(r0, r0 + 2):
                for cc in range(c0, c0 + 2):
                    if input_grid[rr][cc] != 0:
                        all_zero = False
                        break
                if not all_zero:
                    break
            if all_zero:
                rr = r0 + random.randint(0, 1)
                cc = c0 + random.randint(0, 1)
                input_grid[rr][cc] = output_grid[rr][cc]

    if input_grid == output_grid:
        return generate()

    return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid_list = [list(row) for row in input_grid]
    height = len(grid_list)
    width = len(grid_list[0])

    def add_color(c, delta):
        return ((c - 1 + delta) % 9) + 1

    def compute_last_q_and_depth(r0, c0):
        top_r = 0
        bottom_r = height
        left_c = 0
        right_c = width
        depth = 0
        q_last = None
        while (bottom_r - top_r) > 2 and (right_c - left_c) > 2:
            mid_r = (top_r + bottom_r) // 2
            mid_c = (left_c + right_c) // 2
            if r0 < mid_r:
                if c0 < mid_c:
                    q = 0
                    bottom_r = mid_r
                    right_c = mid_c
                else:
                    q = 1
                    bottom_r = mid_r
                    left_c = mid_c
            else:
                if c0 < mid_c:
                    q = 2
                    top_r = mid_r
                    right_c = mid_c
                else:
                    q = 3
                    top_r = mid_r
                    left_c = mid_c
            q_last = q
            depth += 1
        return q_last, depth

    for r0 in range(0, height, 2):
        for c0 in range(0, width, 2):
            q_last, depth = compute_last_q_and_depth(r0, c0)
            base_dir = True if (q_last in (0, 3) or q_last is None) else False
            final_dir = base_dir if (depth % 2 == 0) else (not base_dir)

            positions = [(r0, c0), (r0, c0 + 1), (r0 + 1, c0), (r0 + 1, c0 + 1)]
            colors = [grid_list[r][c] for r, c in positions]

            known_idx = None
            known_color = None
            for idx, col in enumerate(colors):
                if col != 0:
                    known_idx = idx
                    known_color = col
                    break
            if known_idx is None:
                continue

            if final_dir:
                C0 = add_color(known_color, -known_idx)
                for idx, (rr, cc) in enumerate(positions):
                    grid_list[rr][cc] = add_color(C0, idx)
            else:
                C0 = add_color(known_color, known_idx)
                for idx, (rr, cc) in enumerate(positions):
                    grid_list[rr][cc] = add_color(C0, -idx)

    return tuple(tuple(row) for row in grid_list)

