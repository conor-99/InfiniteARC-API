# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 06b32261
Difficulty: insane

=== Tags ===
- Rule priority resolution
- Alternating direction
- Simulate billiards shot
- Local symmetry matching

=== Description ===
Symmetric Billiard Reflections  Input grids feature a background color (0), with
horizontal and vertical wall segments (1â€“9) that do not touch each other. A
single billiard ball (a distinct non-background, non-wall cell) resides within
the grid. The ball moves diagonally in a consistent starting direction (e.g.,
northeast) until it encounters a wall segment. Upon impact, the reflection
direction is determined by the wall's color, with lower-numbered colors having
higher priority if multiple walls are hit at a corner. Each color corresponds to
a unique reflection rule:  - **Color 1**: Standard reflection (angle of
incidence = angle of reflection).   - **Color 2**: Mirror reflection (path
reverses direction relative to the wall).   - **Color 3**: Alternating
reflection (reflects as Color 1 on odd bounces, Color 2 on even bounces).    The
output grid must depict the ball's complete path from start to exit, using the
ball's color. Paths must exhibit **local symmetry** around each bounce point:
the segment of the path before a bounce must mirror the segment after the bounce
across the wall's axis. Walls are not overwritten, and paths never overlap or
intersect other walls. The background remains unchanged except for the drawn
path.  **Key Rules:**   1. **Rule Priority Resolution**: At corner impacts, the
wall with the lowest color number is prioritized.   2. **Alternating
Direction**: For Color 3 walls, the reflection alternates between standard and
mirror rules based on bounce count.   3. **Local Symmetry Matching**: Each
bounce must reflect the path symmetrically across the wall's axis.
**Difficulty**: Insane (requires tracking multiple reflection rules, priority
resolution, and verifying symmetry constraints across a long path).
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    """
    Generate an ARC-style input/output pair for the "Symmetric Billiard Reflections" task.

    Grid values: 0 = background, 1-9 = walls (colored), ball_color = a color not used by any wall
    The ball starts moving in a fixed diagonal direction (NE = dr=-1, dc=+1).
    Walls are horizontal or vertical segments (length >= 2) and are placed so they don't touch
    (no surrounding 8-neighborhood overlap). The generator simulates the ball's path using the
    same rules that the solver will implement.

    Returns:
      {"input": grid, "output": output_grid}
    """
    # Helper: check inside
    def inside(r, c, H, W):
        return 0 <= r < H and 0 <= c < W

    # We'll try multiple times until we produce a valid configuration
    for attempt in range(200):
        width = random.randint(15, 30)
        height = random.randint(15, 30)
        grid = [[0 for _ in range(width)] for _ in range(height)]

        # Place non-touching wall segments. Each segment has orientation 'h' or 'v', length >= 2.
        cell_to_wall = {}  # (r,c) -> (color, orientation)
        segments = []  # list of (cells, color, orientation)
        seg_target = random.randint(5, 10)

        tries = 0
        while len(segments) < seg_target and tries < seg_target * 40:
            tries += 1
            orient = random.choice(['h', 'v'])
            # length at least 2
            if orient == 'h':
                max_len = max(2, min(6, width - 2))
                if max_len < 2:
                    continue
                length = random.randint(2, max_len)
                r = random.randint(1, height - 2)
                c0 = random.randint(1, width - length - 1)
                cells = [(r, c0 + i) for i in range(length)]
            else:
                max_len = max(2, min(6, height - 2))
                if max_len < 2:
                    continue
                length = random.randint(2, max_len)
                c = random.randint(1, width - 2)
                r0 = random.randint(1, height - length - 1)
                cells = [(r0 + i, c) for i in range(length)]

            # Choose a color for the segment
            color = random.randint(1, 9)

            # Validate that none of the cells or their 8-neighborhood overlap any existing wall
            ok = True
            for (rr, cc) in cells:
                if grid[rr][cc] != 0:
                    ok = False
                    break
                for dr_off in (-1, 0, 1):
                    for dc_off in (-1, 0, 1):
                        nr = rr + dr_off
                        nc = cc + dc_off
                        if inside(nr, nc, height, width) and grid[nr][nc] != 0:
                            ok = False
                            break
                    if not ok:
                        break
                if not ok:
                    break
            if not ok:
                continue

            # place the wall
            for (rr, cc) in cells:
                grid[rr][cc] = color
                cell_to_wall[(rr, cc)] = (color, orient)
            segments.append((cells, color, orient))

        # Require minimum number of segments placed
        if len(segments) < 5:
            continue

        wall_colors = set(seg[1] for seg in segments)
        # choose ball color not used by walls
        possible_ball_colors = [c for c in range(1, 10) if c not in wall_colors]
        if not possible_ball_colors:
            continue
        ball_color = random.choice(possible_ball_colors)

        # place ball somewhere empty
        empty_cells = [(r, c) for r in range(1, height - 1) for c in range(1, width - 1) if grid[r][c] == 0]
        if not empty_cells:
            continue
        br, bc = random.choice(empty_cells)
        grid[br][bc] = ball_color

        # Fixed starting direction for both generator and solver (NE)
        dr, dc = -1, 1

        # Simulate the billiard path using exact same rules the solver will use
        path = [(br, bc)]
        r, c = br, bc
        color3_bounce_count = 0
        max_steps = width * height * 4
        steps = 0
        valid_path = True

        while True:
            steps += 1
            if steps > max_steps:
                valid_path = False
                break
            nr, nc = r + dr, c + dc
            # exit if leaving grid
            if not inside(nr, nc, height, width):
                break

            # detect possible obstructing walls: orthogonal neighbors and diagonal cell
            obstructs = []  # list of (orientation, color, cell)

            # orthogonal neighbor in the vertical direction of movement (row changed)
            hcell = (r + dr, c)
            if inside(hcell[0], hcell[1], height, width):
                val = grid[hcell[0]][hcell[1]]
                if val != 0 and val != ball_color:
                    # this cell should belong to a wall; orientation from placement
                    if (hcell[0], hcell[1]) in cell_to_wall:
                        wcol, worient = cell_to_wall[(hcell[0], hcell[1])]
                    else:
                        # fallback: deduce orientation by neighbors
                        wcol = val
                        # if left/right neighbor same color -> horizontal
                        if (hcell[1] - 1 >= 0 and grid[hcell[0]][hcell[1] - 1] == val) or (hcell[1] + 1 < width and grid[hcell[0]][hcell[1] + 1] == val):
                            worient = 'h'
                        else:
                            worient = 'v'
                    obstructs.append((worient, wcol, hcell))

            # orthogonal neighbor in the horizontal direction of movement (column changed)
            vcell = (r, c + dc)
            if inside(vcell[0], vcell[1], height, width):
                val = grid[vcell[0]][vcell[1]]
                if val != 0 and val != ball_color:
                    if (vcell[0], vcell[1]) in cell_to_wall:
                        wcol, worient = cell_to_wall[(vcell[0], vcell[1])]
                    else:
                        wcol = val
                        if (vcell[1] - 1 >= 0 and grid[vcell[0]][vcell[1] - 1] == val) or (vcell[1] + 1 < width and grid[vcell[0]][vcell[1] + 1] == val):
                            worient = 'h'
                        else:
                            worient = 'v'
                    obstructs.append((worient, wcol, vcell))

            # diagonal target cell
            if inside(nr, nc, height, width):
                val = grid[nr][nc]
                if val != 0 and val != ball_color:
                    if (nr, nc) in cell_to_wall:
                        wcol, worient = cell_to_wall[(nr, nc)]
                    else:
                        wcol = val
                        if (nc - 1 >= 0 and grid[nr][nc - 1] == val) or (nc + 1 < width and grid[nr][nc + 1] == val):
                            worient = 'h'
                        else:
                            worient = 'v'
                    obstructs.append((worient, wcol, (nr, nc)))

            if not obstructs:
                # move into diagonal cell
                r, c = nr, nc
                # safety checks
                if grid[r][c] != 0:
                    valid_path = False
                    break
                if (r, c) in path:
                    valid_path = False
                    break
                path.append((r, c))
                continue

            # resolve priority if multiple walls present: choose lowest color number
            min_color = min(item[1] for item in obstructs)
            chosen = None
            for item in obstructs:
                if item[1] == min_color:
                    chosen = item
                    break
            orientation, wcolor, wcell = chosen

            # handle color 3 alternating rule
            if wcolor == 3:
                color3_bounce_count += 1
                # odd -> behave like color 1, even -> behave like color 2
                effective = 1 if (color3_bounce_count % 2 == 1) else 2
            else:
                effective = wcolor

            # Reflection rules: we implement the flip of the component perpendicular to the wall axis
            # (this preserves the required local symmetry across the wall axis)
            if effective in (1, 2):
                if orientation == 'v':
                    dc = -dc
                else:
                    dr = -dr
            else:
                # fallback (shouldn't happen with our color choices) - behave like standard reflection
                if orientation == 'v':
                    dc = -dc
                else:
                    dr = -dr

            # after reflection we remain at (r,c) and will attempt to move in the new direction on the next loop
            # quick check to avoid immediate stuck/bounce loops: if the immediate next cell would be a wall or already visited, abandon and retry whole generation
            new_nr, new_nc = r + dr, c + dc
            if not inside(new_nr, new_nc, height, width):
                # will leave on next move; that's fine
                continue
            if grid[new_nr][new_nc] != 0 and grid[new_nr][new_nc] != ball_color:
                valid_path = False
                break
            if (new_nr, new_nc) in path:
                valid_path = False
                break

        if not valid_path:
            continue

        # create output grid by drawing the path using the ball_color (do not overwrite walls)
        output = [row[:] for row in grid]
        for (pr, pc) in path:
            output[pr][pc] = ball_color

        # ensure input != output
        if grid == output:
            continue

        return {"input": grid, "output": output}

    # If we fail to create a valid grid in all attempts, fall back to a tiny hand-coded example
    # (unlikely to be used, but valid)
    grid = [[0] * 15 for _ in range(15)]
    # horizontal wall
    for c in range(4, 9):
        grid[7][c] = 1
    # vertical wall
    for r in range(2, 6):
        grid[r][10] = 2
    grid[12][2] = 4
    ball_color = 9
    grid[2][2] = ball_color
    # simulate trivial path (NE)
    r, c = 2, 2
    dr, dc = -1, 1
    path = [(r, c)]
    while True:
        nr, nc = r + dr, c + dc
        if not (0 <= nr < 15 and 0 <= nc < 15):
            break
        # simple reflection off row 7
        if nr == 7 and grid[nr][nc] != 0:
            dr = -dr
        r, c = nr, nc
        path.append((r, c))
    output = [row[:] for row in grid]
    for (pr, pc) in path:
        output[pr][pc] = ball_color
    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input (tuple of tuples) to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # Helper
    def inside(r, c):
        return 0 <= r < height and 0 <= c < width

    # Find the unique ball color (the color that appears exactly once)
    color_count = {}
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if v == 0:
                continue
            color_count[v] = color_count.get(v, 0) + 1
    ball_color = None
    for color, cnt in color_count.items():
        if cnt == 1:
            ball_color = color
            break
    if ball_color is None:
        # fallback: if none unique, try to pick a color that seems not to form a line (rare)
        # pick the smallest nonzero color
        ball_color = min([k for k in color_count.keys() if k != 0]) if color_count else 9

    # Locate ball position
    ball_pos = None
    for r in range(height):
        for c in range(width):
            if grid[r][c] == ball_color:
                ball_pos = (r, c)
                break
        if ball_pos:
            break
    if ball_pos is None:
        return grid

    # Build a mapping of wall cells to their (color, orientation)
    # Orientation is determined by looking for same-color neighbors: left/right -> horizontal, up/down -> vertical
    cell_to_wall = {}
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if v == 0 or v == ball_color:
                continue
            # try to detect orientation
            orient = None
            if c - 1 >= 0 and grid[r][c - 1] == v:
                orient = 'h'
            if c + 1 < width and grid[r][c + 1] == v:
                orient = 'h'
            if r - 1 >= 0 and grid[r - 1][c] == v:
                orient = 'v'
            if r + 1 < height and grid[r + 1][c] == v:
                orient = 'v'
            # Prefer the orientation found; if ambiguous choose 'h' first
            if orient is None:
                # as a fallback, if no neighbor of same color, try to deduce by scanning row/col
                # but in generator walls have length >=2 so this should not happen
                # choose horizontal if possible, else vertical
                if (c - 1 >= 0 and grid[r][c - 1] != 0) or (c + 1 < width and grid[r][c + 1] != 0):
                    orient = 'h'
                else:
                    orient = 'v'
            cell_to_wall[(r, c)] = (v, orient)

    # Simulate path using the same rules as the generator
    r, c = ball_pos
    path = [(r, c)]
    dr, dc = -1, 1  # fixed starting direction (NE)
    color3_bounce_count = 0
    max_steps = width * height * 4
    steps = 0

    while True:
        steps += 1
        if steps > max_steps:
            break
        nr, nc = r + dr, c + dc
        # exit if leaving grid
        if not inside(nr, nc):
            break

        obstructs = []
        # orthogonal neighbor in row-direction
        hcell = (r + dr, c)
        if inside(hcell[0], hcell[1]):
            v = grid[hcell[0]][hcell[1]]
            if v != 0 and v != ball_color:
                if (hcell[0], hcell[1]) in cell_to_wall:
                    wcol, worient = cell_to_wall[(hcell[0], hcell[1])]
                else:
                    wcol = v
                    # deduce orientation
                    if (hcell[1] - 1 >= 0 and grid[hcell[0]][hcell[1] - 1] == v) or (hcell[1] + 1 < width and grid[hcell[0]][hcell[1] + 1] == v):
                        worient = 'h'
                    else:
                        worient = 'v'
                obstructs.append((worient, wcol, hcell))

        # orthogonal neighbor in column-direction
        vcell = (r, c + dc)
        if inside(vcell[0], vcell[1]):
            v = grid[vcell[0]][vcell[1]]
            if v != 0 and v != ball_color:
                if (vcell[0], vcell[1]) in cell_to_wall:
                    wcol, worient = cell_to_wall[(vcell[0], vcell[1])]
                else:
                    wcol = v
                    if (vcell[1] - 1 >= 0 and grid[vcell[0]][vcell[1] - 1] == v) or (vcell[1] + 1 < width and grid[vcell[0]][vcell[1] + 1] == v):
                        worient = 'h'
                    else:
                        worient = 'v'
                obstructs.append((worient, wcol, vcell))

        # diagonal target cell
        if inside(nr, nc):
            v = grid[nr][nc]
            if v != 0 and v != ball_color:
                if (nr, nc) in cell_to_wall:
                    wcol, worient = cell_to_wall[(nr, nc)]
                else:
                    wcol = v
                    if (nc - 1 >= 0 and grid[nr][nc - 1] == v) or (nc + 1 < width and grid[nr][nc + 1] == v):
                        worient = 'h'
                    else:
                        worient = 'v'
                obstructs.append((worient, wcol, (nr, nc)))

        if not obstructs:
            # move into diagonal
            r, c = nr, nc
            # do not overwrite walls (should not happen)
            if grid[r][c] != 0:
                break
            if (r, c) in path:
                break
            path.append((r, c))
            continue

        # pick the wall with lowest color number when multiple
        min_color = min(item[1] for item in obstructs)
        chosen = None
        for item in obstructs:
            if item[1] == min_color:
                chosen = item
                break
        orientation, wcolor, wcell = chosen

        # color 3 alternates between behaving like color1 and color2
        if wcolor == 3:
            color3_bounce_count += 1
            effective = 1 if (color3_bounce_count % 2 == 1) else 2
        else:
            effective = wcolor

        # Reflection: flip the component perpendicular to wall axis (preserves local symmetry)
        if effective in (1, 2):
            if orientation == 'v':
                dc = -dc
            else:
                dr = -dr
        else:
            if orientation == 'v':
                dc = -dc
            else:
                dr = -dr

        # check if next immediate move would get stuck; if so stop
        new_nr, new_nc = r + dr, c + dc
        if not inside(new_nr, new_nc):
            continue
        if grid[new_nr][new_nc] != 0 and grid[new_nr][new_nc] != ball_color:
            break
        if (new_nr, new_nc) in path:
            break

    # Draw path on a copy of the input grid
    out = [row[:] for row in grid]
    for (pr, pc) in path:
        out[pr][pc] = ball_color
    return out

