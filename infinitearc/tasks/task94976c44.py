# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 94976c44
Difficulty: very hard

=== Tags ===
- Goal conditioned path
- Coordinate warp
- Recursive partition
- Take negative

=== Description ===
Input grids are large (25×25) visual representations of recursively nested
geometric patterns, featuring concentric spiral formations composed of colored
tiles arranged in interlocking diamond shapes. Each spiral layer has a distinct
color, with the innermost layer containing a single goal cell marked by a unique
color (e.g., cyan) located at the spiral's center. Background cells are
uniformly colored (e.g., black). The spiral pattern exhibits self-similarity
across scales, with each layer offset by one cell from the previous, creating a
continuous path from the outer edge toward the center.  The transformation
process involves four sequential steps:  1. **Recursive partition**: The grid is
recursively divided into quadrants (top-left, top-right, bottom-left, bottom-
right) until each subgrid reaches 3×3 size. Each partition corresponds to a
segment of the spiral path, with the goal's location determining the recursive
depth at which transformations apply.  2. **Coordinate warp**: Each 3×3 subgrid
undergoes a coordinate transformation based on its recursion depth `d`. For even
`d`, the subgrid is rotated 90° clockwise; for odd `d`, it is reflected
horizontally. The rotation center is fixed at the subgrid's top-left corner,
preserving the spiral's structural continuity.  3. **Goal conditioned path**:
The transformation applied to the subgrid containing the goal cell is inverted
(e.g., clockwise rotation becomes counterclockwise). This creates a directional
path from the goal outward, with alternating warp directions that emphasize the
spiral's inward trajectory.  4. **Take negative**: The final output grid is
generated by inverting all colors (non-background becomes background and vice
versa), except for the goal cell, which retains its original color. The
background color is also inverted (e.g., black becomes white), creating a high-
contrast visual representation that highlights the spiral's recursive structure
through the goal's influence.  The output grid reveals a visually inverted,
warped spiral path centered on the goal, with all non-goal elements transformed
through recursive coordinate warps and color inversion, while maintaining the
spiral's self-similar recursive structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import math
# ARC Task 480 generator
# Produces 25x25 grids with nested diamond rings and a unique goal cell. The output is produced by
# recursively partitioning the grid into quadrants until subgrids reach small sizes and applying
# local coordinate warps (rotations/reflections) determined by recursion depth and whether the
# subgrid contains the goal. Finally the grid colors are inverted (background <-> foreground),
# preserving the goal cell color.

from common import grid

# A simple persistent call counter so each call to generate produces a different pattern location
CALL_COUNTER = {"n": 0}


def generate():
    """Generate a single input/output pair for the ARC task.

    Returns:
        dict: {"input": List[List[int]], "output": List[List[int]]}
    """
    CALL_COUNTER["n"] += 1
    call_id = CALL_COUNTER["n"]

    size = 25
    bg = 0                 # background color (black)
    invert_color = 1       # color used for inverted background (white-like)
    goal_color = 8         # unique goal color (cyan)

    # Available ring colors (avoid bg, invert_color and goal_color)
    available_colors = [2, 3, 4, 5, 6, 7, 9]
    max_rings = len(available_colors)

    # Construct input grid and paint diamond rings around the center.
    input_grid = grid(size, size, bg)
    center = (size // 2, size // 2)  # (12, 12)

    # Determine how many rings to draw (1..max_rings). Use the call id to vary patterns.
    ring_count = 4 + (call_id % (max_rings - 3))  # values in 4..max_rings

    # Rotate the palette with call id to ensure many distinct outputs over repeated calls
    colors = [available_colors[(i + call_id) % max_rings] for i in range(ring_count)]

    for k in range(1, ring_count + 1):
        color = colors[k - 1]
        # Diamond (Manhattan) ring at distance k from center
        for r in range(size):
            for c in range(size):
                if abs(r - center[0]) + abs(c - center[1]) == k:
                    input_grid[r][c] = color

    # Place the unique goal at the exact center
    input_grid[center[0]][center[1]] = goal_color

    # Add a small marker that depends on the call id to guarantee uniqueness across many calls.
    # The marker uses invert_color which is not used as a ring color.
    marker_r = ((call_id - 1) // size) % size
    marker_c = (call_id - 1) % size
    if (marker_r, marker_c) == center:
        marker_c = (marker_c + 1) % size
    input_grid[marker_r][marker_c] = invert_color

    # Apply the same recursive coordinate-warping rules to produce the transformed intermediate grid
    transformed = apply_recursive_transform(input_grid, goal_color)

    # Finally take the negative (swap background and non-background) preserving the goal color
    output_grid = take_negative(transformed, goal_color, bg, invert_color)

    return {"input": input_grid, "output": output_grid}


# --------- Helper transformation functions used by the generator ---------

def rotate_90_cw(block):
    # Standard matrix 90-degree clockwise rotation (works for square 3x3 blocks used here)
    return [list(row) for row in zip(*block[::-1])]


def rotate_90_ccw(block):
    # Standard matrix 90-degree counterclockwise rotation
    return [list(row) for row in zip(*block)][::-1]


def reflect_horiz(block):
    # Reflect each row (mirror left-right)
    return [row[::-1] for row in block]


def reflect_vert(block):
    # Reflect rows top-bottom
    return block[::-1]


def apply_recursive_transform(input_grid, goal_color):
    """Recursively partition the grid into quadrants and apply local warps to small blocks.

    The recursion splits each rectangle into four parts (top-left, top-right, bottom-left, bottom-right)
    by integer midpoints. When a subgrid becomes small (both height and width <= 3) we apply the
    coordinate warp:
      - even depth: rotate 90 deg clockwise
      - odd depth: reflect horizontally
    If the subgrid contains the goal cell, the transformation is inverted:
      - rotation <-> counterrotation, reflection <-> vertical reflection

    For subgrids that are smaller than 3x3 (e.g. 2x2 or 3x2) we apply only reflections to preserve
    the shape (rotations would change dimensions). This keeps the transformation well-defined.
    """
    h = len(input_grid)
    w = len(input_grid[0])
    out = [[None for _ in range(w)] for _ in range(h)]

    def write_block(r0, c0, block):
        for dr in range(len(block)):
            for dc in range(len(block[0])):
                out[r0 + dr][c0 + dc] = block[dr][dc]

    def get_block(r0, c0, hh, ww):
        return [input_grid[r][c0:c0 + ww] for r in range(r0, r0 + hh)]

    def rec(r0, c0, hh, ww, depth):
        # Leaf condition: both dims small enough
        if hh <= 3 and ww <= 3:
            block = get_block(r0, c0, hh, ww)
            contains_goal = any(goal_color in row for row in block)

            if hh == 3 and ww == 3:
                # Full 3x3 transforms (rotations preserve shape)
                if contains_goal:
                    if depth % 2 == 0:
                        block2 = rotate_90_ccw(block)
                    else:
                        block2 = reflect_vert(block)
                else:
                    if depth % 2 == 0:
                        block2 = rotate_90_cw(block)
                    else:
                        block2 = reflect_horiz(block)
            else:
                # Small rectangular blocks - only reflections to preserve dimensions
                if contains_goal:
                    # Invert the standard reflection if this block contains the goal
                    if depth % 2 == 0:
                        block2 = reflect_vert(block)
                    else:
                        block2 = reflect_vert(block)
                else:
                    if depth % 2 == 0:
                        # Keep unchanged for even depth to avoid transposing shapes
                        block2 = block
                    else:
                        block2 = reflect_horiz(block)

            write_block(r0, c0, block2)
            return

        # Otherwise split into four roughly-equal quadrants using integer midpoints
        mid_r = r0 + hh // 2
        mid_c = c0 + ww // 2

        # top-left
        rec(r0, c0, mid_r - r0, mid_c - c0, depth + 1)
        # top-right
        rec(r0, mid_c, mid_r - r0, c0 + ww - mid_c, depth + 1)
        # bottom-left
        rec(mid_r, c0, r0 + hh - mid_r, mid_c - c0, depth + 1)
        # bottom-right
        rec(mid_r, mid_c, r0 + hh - mid_r, c0 + ww - mid_c, depth + 1)

    rec(0, 0, h, w, 0)

    # Ensure all cells have been written (they should have been)
    for rr in range(h):
        for cc in range(w):
            if out[rr][cc] is None:
                out[rr][cc] = input_grid[rr][cc]
    return out


def take_negative(grid_in, goal_color, bg, invert_color):
    """Swap background and non-background colors (binary inversion), preserving the goal color.

    All cells equal to bg become invert_color; all non-bg (and non-goal) become bg. The goal_color
    is left unchanged.
    """
    h = len(grid_in)
    w = len(grid_in[0])
    out = [[0 for _ in range(w)] for _ in range(h)]
    for r in range(h):
        for c in range(w):
            v = grid_in[r][c]
            if v == goal_color:
                out[r][c] = goal_color
            elif v == bg:
                out[r][c] = invert_color
            else:
                out[r][c] = bg
    return out



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

# Solver for ARC Task 480
# Implements the same recursive partition + coordinate warp + negative operation used by the generator.

from common import grid


def p(input_grid):
    # Convert tuple-of-tuples to mutable list-of-lists
    g = [list(row) for row in input_grid]
    h = len(g)
    w = len(g[0])

    # Detect the goal color. The generator places a unique goal color at the spiral center. We
    # prefer any color that appears exactly once and is not the obvious background.
    from collections import Counter
    counter = Counter()
    for r in range(h):
        for c in range(w):
            counter[g[r][c]] += 1

    # Determine background as the most frequent color
    bg = counter.most_common(1)[0][0]

    # Candidate unique colors excluding the background
    candidates = [color for color, cnt in counter.items() if cnt == 1 and color != bg]

    goal_color = None
    goal_pos = None
    center = (h // 2, w // 2)
    if candidates:
        # Choose the candidate whose single occurrence is closest to the center
        best = None
        best_dist = None
        for r in range(h):
            for c in range(w):
                v = g[r][c]
                if v in candidates:
                    d = abs(r - center[0]) + abs(c - center[1])
                    if best is None or d < best_dist:
                        best = (r, c, v)
                        best_dist = d
        goal_pos = (best[0], best[1])
        goal_color = best[2]
    else:
        # Fallback: assume the center cell is the goal
        goal_pos = center
        goal_color = g[center[0]][center[1]]

    # Choose an invert color that is distinct from bg and goal
    invert_color = 1
    if invert_color == bg or invert_color == goal_color:
        for candidate in range(1, 10):
            if candidate != bg and candidate != goal_color:
                invert_color = candidate
                break

    # Now apply the same recursive transform used by the generator
    def rotate_90_cw(block):
        return [list(row) for row in zip(*block[::-1])]

    def rotate_90_ccw(block):
        return [list(row) for row in zip(*block)][::-1]

    def reflect_horiz(block):
        return [row[::-1] for row in block]

    def reflect_vert(block):
        return block[::-1]

    def get_block(r0, c0, hh, ww):
        return [g[r][c0:c0 + ww] for r in range(r0, r0 + hh)]

    out = [[None for _ in range(w)] for _ in range(h)]

    def write_block(r0, c0, block):
        for dr in range(len(block)):
            for dc in range(len(block[0])):
                out[r0 + dr][c0 + dc] = block[dr][dc]

    def rec(r0, c0, hh, ww, depth):
        if hh <= 3 and ww <= 3:
            block = get_block(r0, c0, hh, ww)
            contains_goal = any(goal_color in row for row in block)

            if hh == 3 and ww == 3:
                if contains_goal:
                    if depth % 2 == 0:
                        block2 = rotate_90_ccw(block)
                    else:
                        block2 = reflect_vert(block)
                else:
                    if depth % 2 == 0:
                        block2 = rotate_90_cw(block)
                    else:
                        block2 = reflect_horiz(block)
            else:
                if contains_goal:
                    if depth % 2 == 0:
                        block2 = reflect_vert(block)
                    else:
                        block2 = reflect_vert(block)
                else:
                    if depth % 2 == 0:
                        block2 = block
                    else:
                        block2 = reflect_horiz(block)

            write_block(r0, c0, block2)
            return

        mid_r = r0 + hh // 2
        mid_c = c0 + ww // 2
        rec(r0, c0, mid_r - r0, mid_c - c0, depth + 1)
        rec(r0, mid_c, mid_r - r0, c0 + ww - mid_c, depth + 1)
        rec(mid_r, c0, r0 + hh - mid_r, mid_c - c0, depth + 1)
        rec(mid_r, mid_c, r0 + hh - mid_r, c0 + ww - mid_c, depth + 1)

    rec(0, 0, h, w, 0)

    # Fill any None with original values (should not be necessary)
    for r in range(h):
        for c in range(w):
            if out[r][c] is None:
                out[r][c] = g[r][c]

    # Take negative: bg -> invert_color, non-bg (except goal) -> bg, preserve goal
    result = [[0 for _ in range(w)] for _ in range(h)]
    for r in range(h):
        for c in range(w):
            v = out[r][c]
            if v == goal_color:
                result[r][c] = goal_color
            elif v == bg:
                result[r][c] = invert_color
            else:
                result[r][c] = bg

    return tuple(tuple(row) for row in result)
