# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: a7a98d16
Difficulty: very hard

=== Tags ===
- Oscillating rule
- Color by distance to edge
- Nonlocal dependency
- Guided flow

=== Description ===
The input grid is a square or rectangular grid (minimum 3×3) with a uniform
background color (0). Four corner cells (top-left, top-right, bottom-left,
bottom-right) are filled with distinct non-background colors (1–9), which serve
as the key guide elements. The output grid transforms each cell's color based on
its minimum distance to any grid edge (top, bottom, left, or right), using a
cyclic sequence derived from the sorted values of the corner colors.
Specifically, the four corner colors are sorted in ascending order to form a
sequence, and the output color for a cell at distance *d* from the nearest edge
is the (*d* mod 4)-th color in this sequence. This creates a visually distinct,
oscillating pattern of colors that flows outward from the grid's edges, with
each concentric layer adopting the next color in the sorted sequence. The
transformation requires recognizing the corner guide cells, sorting their
colors, and applying the cyclic rule, making it a complex task that combines
distance-based coloring, nonlocal dependency on corner values, and an
oscillating color sequence.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    input_grid = common.grid(width, height, 0)
    corners = random.sample(range(1, 10), 4)
    input_grid[0][0] = corners[0]
    input_grid[0][width-1] = corners[1]
    input_grid[height-1][0] = corners[2]
    input_grid[height-1][width-1] = corners[3]
    
    sorted_corners = sorted(corners)
    output_grid = common.grid(width, height, 0)
    for i in range(height):
        for j in range(width):
            d = min(i, height - 1 - i, j, width - 1 - j)
            output_grid[i][j] = sorted_corners[d % 4]
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    corners = [
        grid[0][0],
        grid[0][width-1],
        grid[height-1][0],
        grid[height-1][width-1]
    ]
    sorted_corners = sorted(corners)
    
    output_grid = [[0] * width for _ in range(height)]
    for i in range(height):
        for j in range(width):
            d = min(i, height - 1 - i, j, width - 1 - j)
            output_grid[i][j] = sorted_corners[d % 4]
    return output_grid
