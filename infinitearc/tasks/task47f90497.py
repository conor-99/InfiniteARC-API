# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 47f90497
Difficulty: hard

=== Tags ===
- Ripple spread
- Line collision
- State transition by contact
- Count patterns

=== Description ===
Input grids consist of a background color (0), multiple horizontal or vertical
lines of distinct colors (1-9), and isolated colored source cells (1-9, not part
of any line). The transformation applies the following rules: each source emits
a ripple in all four directions, moving through background cells until it
contacts a line. Upon contact, the ripple follows the line's orientation,
extending the line's path. If multiple ripples collide on a line, they merge,
adopting the line's color, which updates the line's color throughout its extent.
The output grid displays all lines extended to include the ripple paths, with
colors reflecting the merged state, and the extension length determined by the
count of background cells between the source and line (count pattern). Line
collisions result in state transitions, altering the line's color to match the
merged ripple's state, and all paths are drawn using the updated line color.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Generator for ARC task 402: ripple-line interactions

def neighbors_orth(r, c, height, width):
    for dr, dc in ((1,0), (-1,0), (0,1), (0,-1)):
        nr, nc = r + dr, c + dc
        if 0 <= nr < height and 0 <= nc < width:
            yield (nr, nc)


def scan_lines(g):
    """
    Detect straight lines (horizontal or vertical) made of contiguous identical non-zero colors.
    Returns a list of lines and a mapping from cell coord to line id.
    Each line is a dict: {"color", "cells", "orientation"}
    """
    height = len(g)
    width = len(g[0])
    cell_to_line = {}
    lines = []

    # Find horizontal runs
    for r in range(height):
        c = 0
        while c < width:
            val = g[r][c]
            if val == 0:
                c += 1
                continue
            c2 = c + 1
            while c2 < width and g[r][c2] == val:
                c2 += 1
            run_len = c2 - c
            if run_len >= 2:
                cells = [(r, cc) for cc in range(c, c2)]
                line_id = len(lines)
                lines.append({"color": val, "cells": cells, "orientation": "h"})
                for cell in cells:
                    cell_to_line[cell] = line_id
                c = c2
            else:
                c += 1

    # Find vertical runs (that were not already captured)
    for c in range(width):
        r = 0
        while r < height:
            val = g[r][c]
            if val == 0:
                r += 1
                continue
            r2 = r + 1
            while r2 < height and g[r2][c] == val:
                r2 += 1
            run_len = r2 - r
            if run_len >= 2:
                cells = [(rr, c) for rr in range(r, r2)]
                # Skip if any of these cells already assigned to a horizontal line (intersection unlikely in generator)
                if any(cell in cell_to_line for cell in cells):
                    r = r2
                    continue
                line_id = len(lines)
                lines.append({"color": val, "cells": cells, "orientation": "v"})
                for cell in cells:
                    cell_to_line[cell] = line_id
                r = r2
            else:
                r += 1

    return lines, cell_to_line


def find_source_candidates(g, cell_to_line):
    height = len(g)
    width = len(g[0])
    candidates = []
    for r in range(height):
        for c in range(width):
            if g[r][c] != 0:
                continue
            # ensure orth neighbors are zero (isolated if used as a source)
            adj_nonzero = False
            for nr, nc in neighbors_orth(r, c, height, width):
                if g[nr][nc] != 0:
                    adj_nonzero = True
                    break
            if adj_nonzero:
                continue
            # Check that at least one cardinal direction sees a line (no other non-zero in between)
            sees_line = False
            for dr, dc in ((1,0), (-1,0), (0,1), (0,-1)):
                nr, nc = r + dr, c + dc
                path_blocked = False
                while 0 <= nr < height and 0 <= nc < width:
                    if g[nr][nc] != 0:
                        # It's a non-zero cell; check if it's a line cell
                        if (nr, nc) in cell_to_line:
                            sees_line = True
                        else:
                            # non-line non-zero blocks the sight
                            pass
                        break
                    nr += dr; nc += dc
            if sees_line:
                candidates.append((r, c))
    return candidates


def select_non_adjacent(candidates, k):
    # Greedy selection: shuffle and pick ensuring no orth adjacency among chosen
    random.shuffle(candidates)
    chosen = []
    taken = set()
    for (r, c) in candidates:
        if len(chosen) >= k:
            break
        conflict = False
        for (rr, cc) in chosen:
            if abs(rr - r) + abs(cc - c) == 1:
                conflict = True
                break
        if conflict:
            continue
        chosen.append((r, c))
    return chosen


def apply_rules(inp):
    # inp is a list-of-lists grid
    height = len(inp)
    width = len(inp[0])
    lines, cell_to_line = scan_lines(inp)

    # Identify sources: non-zero cells not part of any line, and orth neighbors all zero
    sources = []
    for r in range(height):
        for c in range(width):
            if inp[r][c] == 0:
                continue
            if (r, c) in cell_to_line:
                continue
            # check orth neighbors
            adj_nonzero = False
            for nr, nc in neighbors_orth(r, c, height, width):
                if inp[nr][nc] != 0:
                    adj_nonzero = True
                    break
            if not adj_nonzero:
                sources.append((r, c, inp[r][c]))

    # For each source and each direction, find ripples that hit a line
    ripples_by_line = {i: [] for i in range(len(lines))}
    for (sr, sc, scol) in sources:
        for dr, dc in ((1,0), (-1,0), (0,1), (0,-1)):
            nr, nc = sr + dr, sc + dc
            path = []
            while 0 <= nr < height and 0 <= nc < width and inp[nr][nc] == 0:
                path.append((nr, nc))
                nr += dr; nc += dc
            if not (0 <= nr < height and 0 <= nc < width):
                continue
            if inp[nr][nc] == 0:
                continue
            # contact with a non-zero cell
            if (nr, nc) not in cell_to_line:
                continue
            line_id = cell_to_line[(nr, nc)]
            ripples_by_line.setdefault(line_id, []).append({
                "source": (sr, sc),
                "s_color": scol,
                "path_len": len(path),
                "path": path,
                "contact": (nr, nc),
            })

    # Build output grid
    out = [row[:] for row in inp]

    # Process each line deterministically in the order discovered
    for lid, line in enumerate(lines):
        ripples = ripples_by_line.get(lid, [])
        if not ripples:
            # no change to this line
            continue
        # choose final color: ripple with minimal (path_len, s_color, source_row, source_col)
        def ripple_key(rp):
            return (rp['path_len'], rp['s_color'], rp['source'][0], rp['source'][1])
        chosen = min(ripples, key=ripple_key)
        final_color = chosen['s_color']
        # recolor the whole original line to final_color
        for (rr, cc) in line['cells']:
            out[rr][cc] = final_color
        # compute endpoints for extension
        if line['orientation'] == 'h':
            row = line['cells'][0][0]
            cols = [c for (_, c) in line['cells']]
            cmin, cmax = min(cols), max(cols)
            for rp in ripples:
                k = rp['path_len']
                # paint the path between source and contact (do not overwrite sources)
                for (pr, pc) in rp['path']:
                    if out[pr][pc] == 0:
                        out[pr][pc] = final_color
                # extend left and right by k cells where background
                for i in range(1, k+1):
                    cl = cmin - i
                    if cl >= 0 and out[row][cl] == 0:
                        out[row][cl] = final_color
                    cr = cmax + i
                    if cr < width and out[row][cr] == 0:
                        out[row][cr] = final_color
        else:
            col = line['cells'][0][1]
            rows = [r for (r, _) in line['cells']]
            rmin, rmax = min(rows), max(rows)
            for rp in ripples:
                k = rp['path_len']
                for (pr, pc) in rp['path']:
                    if out[pr][pc] == 0:
                        out[pr][pc] = final_color
                for i in range(1, k+1):
                    rt = rmin - i
                    if rt >= 0 and out[rt][col] == 0:
                        out[rt][col] = final_color
                    rb = rmax + i
                    if rb < height and out[rb][col] == 0:
                        out[rb][col] = final_color

    return out


def generate():
    # Try to create a grid where at least one source will contact a line so output != input
    attempts = 0
    while True:
        attempts += 1
        if attempts > 200:
            # fallback to a simple deterministic construction if randomness fails
            width = 10; height = 10
        else:
            width = random.randint(8, 14)
            height = random.randint(8, 14)
        g = grid(width, height, 0)

        # Place a few straight lines (horizontal or vertical), distinct colors
        num_lines = random.randint(2, 3)
        colors = random.sample(range(1, 10), num_lines)
        placed = 0
        place_attempts = 0
        success = True
        while placed < num_lines and place_attempts < 200:
            place_attempts += 1
            orient = random.choice(('h', 'v'))
            L = random.randint(3, 6)
            color = colors[placed]
            if orient == 'h':
                r = random.randint(1, height-2)
                c0 = random.randint(1, width - L - 1)
                cells = [(r, c0 + i) for i in range(L)]
            else:
                c = random.randint(1, width-2)
                r0 = random.randint(1, height - L - 1)
                cells = [(r0 + i, c) for i in range(L)]
            # ensure cells and their 3x3 neighborhood are free
            conflict = False
            for (rr, cc) in cells:
                if g[rr][cc] != 0:
                    conflict = True; break
                for dr in (-1, 0, 1):
                    for dc in (-1, 0, 1):
                        nr, nc = rr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and g[nr][nc] != 0:
                            conflict = True; break
                    if conflict: break
                if conflict: break
            if conflict:
                continue
            # place
            for (rr, cc) in cells:
                g[rr][cc] = color
            placed += 1

        if placed < num_lines:
            continue

        # detect lines to know where sources can see them
        lines, cell_to_line = scan_lines(g)
        candidates = find_source_candidates(g, cell_to_line)
        if len(candidates) < 2:
            # not enough source positions, retry
            if attempts > 200:
                # force at least one candidate by carving a zero-line
                pass
            continue

        num_sources = random.randint(2, min(4, len(candidates)))
        chosen = select_non_adjacent(candidates, num_sources)
        if len(chosen) < 1:
            continue
        # If we couldn't select enough non-adjacent, reduce number
        if len(chosen) < num_sources:
            num_sources = len(chosen)
            chosen = chosen[:num_sources]

        # assign source colors (allow duplicates)
        source_colors = [random.randint(1, 9) for _ in range(len(chosen))]
        for (pos, scol) in zip(chosen, source_colors):
            r, c = pos
            g[r][c] = scol

        out = apply_rules(g)
        # ensure output differs from input
        if out != g:
            return {"input": g, "output": out}
        # else retry




# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert tuple-of-tuples to list-of-lists
    g = [list(row) for row in input_grid]
    height = len(g)
    width = len(g[0])

    def neighbors_orth(r, c):
        for dr, dc in ((1,0), (-1,0), (0,1), (0,-1)):
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width:
                yield (nr, nc)

    def scan_lines(grid):
        cell_to_line = {}
        lines = []
        # horizontal
        for r in range(height):
            c = 0
            while c < width:
                val = grid[r][c]
                if val == 0:
                    c += 1
                    continue
                c2 = c + 1
                while c2 < width and grid[r][c2] == val:
                    c2 += 1
                run_len = c2 - c
                if run_len >= 2:
                    cells = [(r, cc) for cc in range(c, c2)]
                    line_id = len(lines)
                    lines.append({"color": val, "cells": cells, "orientation": "h"})
                    for cell in cells:
                        cell_to_line[cell] = line_id
                    c = c2
                else:
                    c += 1
        # vertical
        for c in range(width):
            r = 0
            while r < height:
                val = grid[r][c]
                if val == 0:
                    r += 1
                    continue
                r2 = r + 1
                while r2 < height and grid[r2][c] == val:
                    r2 += 1
                run_len = r2 - r
                if run_len >= 2:
                    cells = [(rr, c) for rr in range(r, r2)]
                    if any(cell in cell_to_line for cell in cells):
                        r = r2
                        continue
                    line_id = len(lines)
                    lines.append({"color": val, "cells": cells, "orientation": "v"})
                    for cell in cells:
                        cell_to_line[cell] = line_id
                    r = r2
                else:
                    r += 1
        return lines, cell_to_line

    lines, cell_to_line = scan_lines(g)

    # identify sources
    sources = []
    for r in range(height):
        for c in range(width):
            if g[r][c] == 0:
                continue
            if (r, c) in cell_to_line:
                continue
            adj_nonzero = False
            for nr, nc in neighbors_orth(r, c):
                if g[nr][nc] != 0:
                    adj_nonzero = True
                    break
            if not adj_nonzero:
                sources.append((r, c, g[r][c]))

    # collect ripples
    ripples_by_line = {i: [] for i in range(len(lines))}
    for (sr, sc, scol) in sources:
        for dr, dc in ((1,0), (-1,0), (0,1), (0,-1)):
            nr, nc = sr + dr, sc + dc
            path = []
            while 0 <= nr < height and 0 <= nc < width and g[nr][nc] == 0:
                path.append((nr, nc))
                nr += dr; nc += dc
            if not (0 <= nr < height and 0 <= nc < width):
                continue
            if g[nr][nc] == 0:
                continue
            if (nr, nc) not in cell_to_line:
                continue
            line_id = cell_to_line[(nr, nc)]
            ripples_by_line.setdefault(line_id, []).append({
                "source": (sr, sc),
                "s_color": scol,
                "path_len": len(path),
                "path": path,
                "contact": (nr, nc),
            })

    out = [row[:] for row in g]

    for lid, line in enumerate(lines):
        ripples = ripples_by_line.get(lid, [])
        if not ripples:
            continue
        def ripple_key(rp):
            return (rp['path_len'], rp['s_color'], rp['source'][0], rp['source'][1])
        chosen = min(ripples, key=ripple_key)
        final_color = chosen['s_color']
        for (rr, cc) in line['cells']:
            out[rr][cc] = final_color
        if line['orientation'] == 'h':
            row = line['cells'][0][0]
            cols = [c for (_, c) in line['cells']]
            cmin, cmax = min(cols), max(cols)
            for rp in ripples:
                k = rp['path_len']
                for (pr, pc) in rp['path']:
                    if out[pr][pc] == 0:
                        out[pr][pc] = final_color
                for i in range(1, k+1):
                    cl = cmin - i
                    if cl >= 0 and out[row][cl] == 0:
                        out[row][cl] = final_color
                    cr = cmax + i
                    if cr < width and out[row][cr] == 0:
                        out[row][cr] = final_color
        else:
            col = line['cells'][0][1]
            rows = [r for (r, _) in line['cells']]
            rmin, rmax = min(rows), max(rows)
            for rp in ripples:
                k = rp['path_len']
                for (pr, pc) in rp['path']:
                    if out[pr][pc] == 0:
                        out[pr][pc] = final_color
                for i in range(1, k+1):
                    rt = rmin - i
                    if rt >= 0 and out[rt][col] == 0:
                        out[rt][col] = final_color
                    rb = rmax + i
                    if rb < height and out[rb][col] == 0:
                        out[rb][col] = final_color

    return out

