# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: a9f48baa
Difficulty: easy

=== Tags ===
- Color by distance to a single point
- Associate images to images
- Loop filling
- Associate colors to shapes

=== Description ===
The input grid contains a rectangular loop (boundary) formed by cells of color
5, enclosing a region. Inside this region, a single cell with color 1 serves as
the reference point. The output grid retains the loop boundary (color 5) and
fills all interior cells (excluding the boundary) with colors determined by
their Manhattan distance from the reference point. Distance 0 (the reference
point itself) is colored 2, distance 1 uses color 3, and distance 2 uses color
4. Cells outside the loop remain unchanged from the input. The transformation is
purely based on geometric distance from a single marked point within the loop,
with no reliance on numerical sums, pixel patterns, or external features.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = [[0] * width for _ in range(height)]
    
    t = random.randint(0, height - 5)
    l = random.randint(0, width - 5)
    
    for c in range(l, l+5):
        grid[t][c] = 5
        grid[t+4][c] = 5
    for r in range(t, t+5):
        grid[r][l] = 5
        grid[r][l+4] = 5
    
    r_ref = t + 2
    c_ref = l + 2
    grid[r_ref][c_ref] = 1
    
    output = [row[:] for row in grid]
    for r in range(t+1, t+4):
        for c in range(l+1, l+4):
            dist = abs(r - r_ref) + abs(c - c_ref)
            if dist == 0:
                output[r][c] = 2
            elif dist == 1:
                output[r][c] = 3
            elif dist == 2:
                output[r][c] = 4
            else:
                output[r][c] = 0
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    rows_5 = []
    cols_5 = []
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] == 5:
                rows_5.append(r)
                cols_5.append(c)
    
    if not rows_5:
        return input_grid
    
    t = min(rows_5)
    b = max(rows_5)
    l = min(cols_5)
    r = max(cols_5)
    
    r_ref, c_ref = -1, -1
    for r_idx in range(t+1, b):
        for c_idx in range(l+1, r):
            if input_grid[r_idx][c_idx] == 1:
                r_ref, c_ref = r_idx, c_idx
                break
        if r_ref != -1:
            break
    
    if r_ref == -1:
        r_ref = (t + b) // 2
        c_ref = (l + r) // 2
    
    output = [row[:] for row in input_grid]
    for r_idx in range(t+1, b):
        for c_idx in range(l+1, r):
            dist = abs(r_idx - r_ref) + abs(c_idx - c_ref)
            if dist == 0:
                output[r_idx][c_idx] = 2
            elif dist == 1:
                output[r_idx][c_idx] = 3
            elif dist == 2:
                output[r_idx][c_idx] = 4
            else:
                output[r_idx][c_idx] = 0
    
    return output
