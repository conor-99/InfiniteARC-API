# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 441055a1
Difficulty: insane

=== Tags ===
- Substitution rule discovery
- Pattern rotation

=== Description ===
Input grids feature a complex arrangement of disconnected, contiguous colored
patterns (e.g., L-shapes, T-shapes, squares, and irregular blobs) scattered
across a uniform background. Each pattern is composed of a single, solid color
(0-9, visually distinct), and patterns may overlap in position but never in
color. The output grid requires two sequential transformations: first, a
substitution rule discovery phase where each pattern's color maps to a specific
rotation angle (90°, 180°, or 270°), and second, the application of that
rotation to each pattern's shape. The substitution rule is not directly visible
in the input and must be deduced from the relationship between color and the
rotation direction/angle in the examples. For instance, a pattern of color 2
might rotate 90° clockwise in one example but 180° in another—indicating the
rule depends on the pattern's *relative position* to other colors in the grid,
not its numerical value. The rotation must preserve the pattern's internal
structure and be applied in place without distorting the background or
overlapping other elements. Patterns are rotated as rigid blocks (e.g., an
L-shape remains an L-shape after rotation), and the output grid must reflect all
rotations consistently across the entire grid. The background color remains
unchanged, and no new elements are added or removed. The task demands
recognizing that the substitution rule is context-dependent (e.g., color 3
rotates 180° only when adjacent to color 7, but 90° when adjacent to color 4),
requiring multiple examples to infer the non-linear mapping.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, rand_sprite

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    input_grid = grid(width, height, 0)
    colors = random.sample(range(1, 10), 3)
    
    # Create contiguous patterns using rand_sprite
    for color in colors:
        pixels = rand_sprite('el', width, height)
        for r, c in pixels:
            if 0 <= r < height and 0 <= c < width:
                input_grid[r][c] = color

    output_grid = [row[:] for row in input_grid]
    
    for color in colors:
        adj_colors = set()
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == color:
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0:
                            adj_colors.add(input_grid[nr][nc])
        
        rotation = 90 if len(adj_colors) == 1 else 180

        color_pixels = []
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == color:
                    color_pixels.append((r, c))
        
        if rotation == 90:
            min_r = min(r for r, c in color_pixels)
            max_r = max(r for r, c in color_pixels)
            min_c = min(c for r, c in color_pixels)
            max_c = max(c for r, c in color_pixels)
            
            subgrid = [[0] * (max_c - min_c + 1) for _ in range(max_r - min_r + 1)]
            for r, c in color_pixels:
                subgrid[r - min_r][c - min_c] = 1
            
            rotated_subgrid = [list(x)[::-1] for x in zip(*subgrid)]
            
            for i in range(len(rotated_subgrid)):
                for j in range(len(rotated_subgrid[0])):
                    if rotated_subgrid[i][j] == 1:
                        new_r = i + min_r
                        new_c = j + min_c
                        if 0 <= new_r < height and 0 <= new_c < width:
                            output_grid[new_r][new_c] = color
        else:
            for r, c in color_pixels:
                new_r = height - 1 - r
                new_c = width - 1 - c
                if 0 <= new_r < height and 0 <= new_c < width:
                    output_grid[new_r][new_c] = color

    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    input_grid = [list(row) for row in input_grid]
    output_grid = [row[:] for row in input_grid]
    
    colors = set()
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                colors.add(input_grid[r][c])

    for color in colors:
        adj_colors = set()
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == color:
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0:
                            adj_colors.add(input_grid[nr][nc])
        
        rotation = 90 if len(adj_colors) == 1 else 180

        color_pixels = []
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == color:
                    color_pixels.append((r, c))
        
        if rotation == 90:
            min_r = min(r for r, c in color_pixels)
            max_r = max(r for r, c in color_pixels)
            min_c = min(c for r, c in color_pixels)
            max_c = max(c for r, c in color_pixels)
            
            subgrid = [[0] * (max_c - min_c + 1) for _ in range(max_r - min_r + 1)]
            for r, c in color_pixels:
                subgrid[r - min_r][c - min_c] = 1
            
            rotated_subgrid = [list(x)[::-1] for x in zip(*subgrid)]
            
            for i in range(len(rotated_subgrid)):
                for j in range(len(rotated_subgrid[0])):
                    if rotated_subgrid[i][j] == 1:
                        new_r = i + min_r
                        new_c = j + min_c
                        if 0 <= new_r < height and 0 <= new_c < width:
                            output_grid[new_r][new_c] = color
        else:
            for r, c in color_pixels:
                new_r = height - 1 - r
                new_c = width - 1 - c
                if 0 <= new_r < height and 0 <= new_c < width:
                    output_grid[new_r][new_c] = color

    return output_grid
