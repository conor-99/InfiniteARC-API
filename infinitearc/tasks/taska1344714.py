# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: a1344714
Difficulty: very hard

=== Tags ===
- Momentum conservation path
- Enclosure completion
- Example condition induction
- Source target routing
- Close line gaps
- Detect hor lines

=== Description ===
Input grids are large (20×20 or larger) with a uniform background color.
Overlaid are incomplete horizontal line segments ("hor lines") of a distinct
color, each spanning a range of columns at a fixed row but containing gaps
(missing cells between endpoints). Sources (single cells of color S) appear on
the left edge (x=0), and targets (single cells of color T) appear on the right
edge (x=max). The grid also contains incidental vertical lines and scattered
background elements, but these are irrelevant to the task.    The transformation
requires two sequential steps:   1. **Enclosure completion**: Close all gaps
within horizontal line segments on the same row by filling missing cells with
the line color. For example, if a row has segments [2-4] and [6-8], the gap at
column 5 is filled to form a continuous segment [2-8]. This creates fully
enclosed horizontal barriers or guides.   2. **Source-target routing with
momentum conservation**: Route a path from each source to its target by moving
along completed horizontal segments. At the endpoint of a horizontal segment
(left or right), the path turns 90 degrees (up or down) to move vertically,
repeating this horizontal-vertical pattern until reaching the target. The path
must follow the "momentum conservation" rule: direction changes are strictly
90-degree turns at segment endpoints, never diagonal or arbitrary. The path
color cycles through a predefined sequence (e.g., S → A → B → S...) but only
occupies background cells, avoiding walls, lines, and other paths.    The output
must show all completed horizontal lines (no gaps) and all source-target paths
routed without overlaps, with paths ending precisely at target cells. The
solution requires detecting hor lines, closing gaps to complete enclosures, then
applying the routing rule with strict direction changes, all inferred from input
patterns rather than memorized pixel patterns.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    size = 20
    bg = 0
    grid_input = grid(size, size, bg)
    
    # Choose colors
    line_color = random.choice([1,2,3,4,5,6,7,8,9])
    S = random.choice([2,3,4,5,6,7,8,9])
    while S == line_color:
        S = random.choice([2,3,4,5,6,7,8,9])
    T = random.choice([2,3,4,5,6,7,8,9])
    while T == S or T == line_color:
        T = random.choice([2,3,4,5,6,7,8,9])
    
    # Create horizontal segments with gaps
    rows = [5, 7, 9]
    for r in rows:
        # Create two segments with gap
        for c in range(2, 5):  # first segment
            grid_input[r][c] = line_color
        for c in range(6, 9):  # second segment
            grid_input[r][c] = line_color
        # Source and target
        grid_input[r][0] = S
        grid_input[r][size-1] = T
    
    # Add vertical lines
    for r in range(size):
        grid_input[r][3] = 4  # vertical line
    
    # Add scattered elements
    grid_input[10][10] = 5
    grid_input[15][15] = 5
    
    # Create output grid by filling gaps
    grid_output = [row[:] for row in grid_input]
    for r in rows:
        for c in range(5, 6):  # fill gap at column 5
            grid_output[r][c] = line_color
    
    # Draw paths
    path_colors = [S, 6, 7]
    for r in rows:
        col = 1
        idx = 0
        while col < size - 1:
            if grid_output[r][col] == bg:
                grid_output[r][col] = path_colors[idx % len(path_colors)]
                idx += 1
            col += 1
    
    return {
        "input": grid_input,
        "output": grid_output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    size = len(input_grid)
    grid = [list(row) for row in input_grid]
    
    # Find line_color (not source, target, or background)
    line_color = 1
    for r in range(size):
        if grid[r][0] != 0 and grid[r][size-1] != 0:
            for c in range(size):
                if grid[r][c] != 0 and grid[r][c] != grid[r][0] and grid[r][c] != grid[r][size-1]:
                    line_color = grid[r][c]
                    break
            break
    
    # Fill horizontal gaps
    for r in range(size):
        cols = [c for c in range(size) if grid[r][c] == line_color]
        if not cols:
            continue
        min_c, max_c = min(cols), max(cols)
        for c in range(min_c, max_c + 1):
            if grid[r][c] == 0:
                grid[r][c] = line_color
    
    # Draw paths
    for r in range(size):
        if grid[r][0] != 0 and grid[r][0] != line_color and grid[r][size-1] != grid[r][0]:
            s_color = grid[r][0]
            path_colors = [s_color, 6, 7]
            col = 1
            idx = 0
            while col < size - 1:
                if grid[r][col] == 0:
                    grid[r][col] = path_colors[idx % len(path_colors)]
                    idx += 1
                col += 1
    
    return [tuple(row) for row in grid]
