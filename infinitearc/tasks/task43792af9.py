# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 43792af9
Difficulty: mediumâ€“hard

=== Tags ===
- Pattern sync
- Ripple spread
- Momentum conservation path
- Color particle fall
- Associate colors to numbers
- Seal gaps inside shape

=== Description ===
Input grids consist of a uniform background color (0) overlaid with solid,
enclosed shapes formed by non-zero colors (1-9), each containing at least one
enclosed background gap (a hole or void within the shape). Scattered above these
shapes are single-colored "particles" (1-9) positioned in background cells.   In
the output grid, particles fall vertically until contacting the topmost solid
cell of a shape beneath them. Upon impact, the particle's color propagates
diagonally outward from the contact point through all connected background gaps
inside the shape, filling every enclosed void with the particle's color. The
ripple spreads in all four diagonal directions (northeast, northwest, southeast,
southwest) until blocked by solid shape cells or grid boundaries. Solid shape
outlines remain unchanged, gaps are sealed with the ripple color, and no trace
of the original particle position remains. The transformation requires
identifying the fall path, impact point, and diagonal gap-filling propagation
while respecting shape geometry.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_color

def generate():
    grid_size = random.randint(6, 30)
    input_grid = grid(grid_size, grid_size, 0)
    shape_color = random_color(exclude=[0])
    
    start_r = random.randint(2, grid_size - 4)
    start_c = random.randint(2, grid_size - 4)
    
    max_r = grid_size - start_r - 2
    max_c = grid_size - start_c - 2
    min_dim = 3
    
    if max_r < min_dim:
        max_r = min_dim
    if max_c < min_dim:
        max_c = min_dim
    
    end_r = start_r + random.randint(min_dim, max_r)
    end_c = start_c + random.randint(min_dim, max_c)
    
    for r in range(start_r, end_r + 1):
        if r == start_r or r == end_r:
            for c in range(start_c, end_c + 1):
                input_grid[r][c] = shape_color
        else:
            input_grid[r][start_c] = shape_color
            input_grid[r][end_c] = shape_color
    
    hole_start_r, hole_end_r = start_r + 1, end_r - 1
    hole_start_c, hole_end_c = start_c + 1, end_c - 1
    
    particle_col = random.randint(hole_start_c, hole_end_c)
    particle_row = start_r - 1
    particle_color = random_color(exclude=[shape_color, 0])
    
    input_grid[particle_row][particle_col] = particle_color
    
    output_grid = [row[:] for row in input_grid]
    for r in range(hole_start_r, hole_end_r + 1):
        for c in range(hole_start_c, hole_end_c + 1):
            output_grid[r][c] = particle_color
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    
    non_zero_cells = []
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] != 0:
                non_zero_cells.append((r, c))
    
    if not non_zero_cells:
        return input_grid
    
    min_r = min(r for r, c in non_zero_cells)
    max_r = max(r for r, c in non_zero_cells)
    min_c = min(c for r, c in non_zero_cells)
    max_c = max(c for r, c in non_zero_cells)
    
    particle_color = None
    # Check all rows up to min_r (including min_r) to find the particle
    for r in range(min_r + 1):
        for c in range(len(input_grid[0])):
            if r + 1 < len(input_grid) and input_grid[r][c] != 0 and input_grid[r+1][c] != 0:
                particle_color = input_grid[r][c]
                break
        if particle_color is not None:
            break
    
    if particle_color is None:
        particle_color = input_grid[0][0]
    
    output_grid = [row[:] for row in input_grid]
    for r in range(min_r + 1, max_r):
        for c in range(min_c + 1, max_c):
            if input_grid[r][c] == 0:
                output_grid[r][c] = particle_color
    
    return output_grid
