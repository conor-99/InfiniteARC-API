# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: b449612e
Difficulty: insane

=== Tags ===
- Crop
- Minimal description length

=== Description ===
The output grid is the smallest rectangle that contains all instances of the
most frequent non-zero color in the input grid. This requires identifying the
color with the highest count among non-zero values and cropping the grid to the
minimal bounding box encompassing all its occurrences.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    c = random.randint(1, 9)
    ow = random.randint(1, 29)
    oh = random.randint(1, 29)
    iw = ow + random.randint(1, 30 - ow)
    ih = oh + random.randint(1, 30 - oh)
    input_grid = grid(iw, ih, 0)
    x = random.randint(0, iw - ow)
    y = random.randint(0, ih - oh)
    for i in range(oh):
        for j in range(ow):
            input_grid[y + i][x + j] = c
    output_grid = [row[x:x + ow] for row in input_grid[y:y + oh]]
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid or not input_grid[0]:
        return []
    non_zero = {}
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            color = input_grid[r][c]
            if color != 0:
                non_zero[color] = non_zero.get(color, 0) + 1
    if not non_zero:
        return input_grid
    target = max(non_zero, key=non_zero.get)
    rows, cols = [], []
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] == target:
                rows.append(r)
                cols.append(c)
    min_r, max_r = min(rows), max(rows)
    min_c, max_c = min(cols), max(cols)
    return [row[min_c:max_c + 1] for row in input_grid[min_r:max_r + 1]]
