# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 4c4c2b7b
Difficulty: hard

=== Tags ===
- Create image from info

=== Description ===
The input grid is a 2D array of integers (0-9), where each non-zero value
represents the size of a square to be drawn starting at that cell's position.
The output grid is constructed by filling all cells covered by any such square
(using a fixed non-zero color, e.g., 1) while leaving other cells as 0. Squares
are drawn starting at (r, c) and extending v rows downward and v columns to the
right (covering rows r to r+v-1 and columns c to c+v-1). Overlapping squares
merge (all covered cells are set to the fixed color). The output grid's
dimensions are dynamically determined to encompass all squares, ensuring it
remains within 1×1 to 30×30. The task requires identifying the relationship
between input cell values and the geometric pattern they encode in the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
def generate():
    H = random.randint(1, 30)
    W = random.randint(1, 30)
    input_grid = [[0] * W for _ in range(H)]
    
    num_nonzero = random.randint(1, 10)
    for _ in range(num_nonzero):
        r = random.randint(0, H-1)
        c = random.randint(0, W-1)
        max_v = min(30 - r, 30 - c)
        if max_v > 0:
            v = random.randint(1, min(max_v, 9))
            input_grid[r][c] = v
    
    max_row = 0
    max_col = 0
    covered = set()
    
    for r in range(H):
        for c in range(W):
            v = input_grid[r][c]
            if v > 0:
                max_row = max(max_row, r + v)
                max_col = max(max_col, c + v)
                for dr in range(v):
                    for dc in range(v):
                        covered.add((r + dr, c + dc))
    
    output_grid = [[0] * max_col for _ in range(max_row)]
    for (r, c) in covered:
        if r < max_row and c < max_col:
            output_grid[r][c] = 1
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    H = len(input_grid)
    W = len(input_grid[0])
    max_row = 0
    max_col = 0
    covered = set()
    
    for r in range(H):
        for c in range(W):
            v = input_grid[r][c]
            if v > 0:
                max_row = max(max_row, r + v)
                max_col = max(max_col, c + v)
                for dr in range(v):
                    for dc in range(v):
                        covered.add((r + dr, c + dc))
    
    output_grid = [[0] * max_col for _ in range(max_row)]
    for (r, c) in covered:
        if r < max_row and c < max_col:
            output_grid[r][c] = 1
    return output_grid
