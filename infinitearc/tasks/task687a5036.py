# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 687a5036
Difficulty: mediumâ€“hard

=== Tags ===
- Feature binding
- Layered occlusion unfolding

=== Description ===
Input grids feature multiple overlapping rectangular regions of distinct colors
(1-9) on a black background (0), forming a layered structure where higher-
numbered colors represent topmost layers occluding lower-numbered layers
beneath. Each color is bound to a directional shift vector: color c maps to (dx,
dy) = (c mod 3 - 1, c mod 3 - 1), where (1,0) = right, (-1,0) = left, (0,1) =
down, (0,-1) = up. The output grid is generated by applying the following steps:
(1) Sort all rectangles by color in descending order (topmost layers first); (2)
For each rectangle, shift it in its bound direction by one cell if all cells in
the target position are background (0); (3) The original positions of shifted
rectangles become background (0), while the new positions retain the rectangle's
color; (4) Unshifted rectangles remain in place. This process "unfolds" the
occlusion by revealing lower layers in positions vacated by shifted top layers,
with shifts applied in priority order to avoid conflicts. The output retains all
original background and lower-layer colors, now visible in areas vacated by
shifting top layers, while maintaining the structural integrity of all
rectangles.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    while True:
        width = random.randint(1, 30)
        height = random.randint(1, 30)
        grid = [[0] * width for _ in range(height)]
        
        colors = random.sample([2, 3, 5, 6, 8, 9], 3)
        colors.sort(reverse=True)
        
        rectangles = []
        for color in colors:
            r1 = random.randint(0, height - 1)
            c1 = random.randint(0, width - 1)
            r2 = min(r1 + random.randint(1, 5), height - 1)
            c2 = min(c1 + random.randint(1, 5), width - 1)
            rectangles.append((color, r1, c1, r2, c2))
        
        for color, r1, c1, r2, c2 in rectangles:
            for r in range(r1, r2 + 1):
                for c in range(c1, c2 + 1):
                    if color > grid[r][c]:
                        grid[r][c] = color
        
        output = [row[:] for row in grid]
        shifted = False
        for color in sorted(colors, reverse=True):
            min_r = height
            max_r = -1
            min_c = width
            max_c = -1
            for r in range(height):
                for c in range(width):
                    if output[r][c] == color:
                        min_r = min(min_r, r)
                        max_r = max(max_r, r)
                        min_c = min(min_c, c)
                        max_c = max(max_c, c)
            if min_r > max_r or min_c > max_c:
                continue
            dx = (color % 3) - 1
            dy = (color % 3) - 1
            target_r1 = min_r + dx
            target_r2 = max_r + dx
            target_c1 = min_c + dy
            target_c2 = max_c + dy
            
            if target_r1 < 0 or target_r2 >= height or target_c1 < 0 or target_c2 >= width:
                continue
            
            valid = True
            for r in range(target_r1, target_r2 + 1):
                for c in range(target_c1, target_c2 + 1):
                    if output[r][c] != 0:
                        valid = False
                        break
                if not valid:
                    break
            
            if valid:
                for r in range(min_r, max_r + 1):
                    for c in range(min_c, max_c + 1):
                        output[r][c] = 0
                for r in range(target_r1, target_r2 + 1):
                    for c in range(target_c1, target_c2 + 1):
                        output[r][c] = color
                shifted = True
        
        if shifted and grid != output:
            return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    colors = set()
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                colors.add(grid[r][c])
    colors = sorted(colors, reverse=True)
    
    for color in colors:
        min_r = height
        max_r = -1
        min_c = width
        max_c = -1
        for r in range(height):
            for c in range(width):
                if grid[r][c] == color:
                    min_r = min(min_r, r)
                    max_r = max(max_r, r)
                    min_c = min(min_c, c)
                    max_c = max(max_c, c)
        if min_r > max_r or min_c > max_c:
            continue
        dx = (color % 3) - 1
        dy = (color % 3) - 1
        target_r1 = min_r + dx
        target_r2 = max_r + dx
        target_c1 = min_c + dy
        target_c2 = max_c + dy
        
        if target_r1 < 0 or target_r2 >= height or target_c1 < 0 or target_c2 >= width:
            continue
        
        valid = True
        for r in range(target_r1, target_r2 + 1):
            for c in range(target_c1, target_c2 + 1):
                if grid[r][c] != 0:
                    valid = False
                    break
            if not valid:
                break
        
        if valid:
            for r in range(min_r, max_r + 1):
                for c in range(min_c, max_c + 1):
                    grid[r][c] = 0
            for r in range(target_r1, target_r2 + 1):
                for c in range(target_c1, target_c2 + 1):
                    grid[r][c] = color
    
    return tuple(tuple(row) for row in grid)
