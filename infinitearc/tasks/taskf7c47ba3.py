# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: f7c47ba3
Difficulty: mediumâ€“hard

=== Tags ===
- Path instruction following
- Wavefront timing
- Boolean color logic
- Symbolic circuit
- Fractal repetition

=== Description ===
Input grids feature a background color (0) and a starting cell (color 5)
positioned along the left edge. Scattered across the grid are colored gate cells
(1-4), each representing a symbolic logic operation: color 1 (AND) requires two
adjacent path segments to continue, color 2 (OR) continues if at least one
adjacent path segment exists, color 3 (NOT) reverses direction if a path segment
is present, and color 4 (XOR) continues only when exactly one adjacent path
segment exists. The path begins at the starting cell, moving rightward through
background cells. Upon entering a gate cell, the path's direction is updated
based on the gate's logic and the presence of adjacent path segments (up, down,
left, right). The path is drawn using the gate color, with wavefront timing
visualized through layered color intensity (earlier path segments appear as
lighter shades, later segments as darker shades of the same gate color). The
output grid must form a fractal repetition pattern, where each segment of the
path recursively mirrors the overall structure at progressively smaller scales,
creating a self-similar visual pattern that adheres to the circuit's logic and
wavefront progression. All gate cells and the starting cell remain visible in
the output, unchanged from the input, while the path's fractal structure emerges
from the logical traversal.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, all_pixels, grid_enhance

def generate():
    size = random.randint(15, 25)
    bg = 0
    start_color = 5
    gates = [1, 2, 3, 4]
    
    # Create input grid
    input_grid = grid(size, size, bg)
    
    # Place start cell (5) on left edge
    start_row = random.randint(5, size-6)
    input_grid[start_row][0] = start_color
    
    # Place gates (1-4) avoiding start adjacency
    gate_positions = []
    for _ in range(random.randint(3, 5)):
        r, c = random.randint(1, size-2), random.randint(1, size-2)
        if abs(r - start_row) > 2 and abs(c - 0) > 2:
            gate = random.choice(gates)
            input_grid[r][c] = gate
            gate_positions.append((r, c))
    
    # Simulate path
    path = []
    current = (start_row, 0)
    direction = (0, 1)  # right
    color_sequence = []
    step = 0
    max_step = size * 2
    
    while step < max_step:
        nr, nc = current[0] + direction[0], current[1] + direction[1]
        if not (0 <= nr < size and 0 <= nc < size):
            break
        
        if input_grid[nr][nc] in gates:
            gate = input_grid[nr][nc]
            # Count adjacent path cells
            count = 0
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                pr, pc = nr + dr, nc + dc
                if (pr, pc) in path:
                    count += 1
            
            # Apply gate logic
            if gate == 1:  # AND
                if count >= 2:
                    new_dir = direction
                else:
                    new_dir = (direction[1], -direction[0])
            elif gate == 2:  # OR
                if count >= 1:
                    new_dir = direction
                else:
                    new_dir = (direction[1], -direction[0])
            elif gate == 3:  # NOT
                if count >= 1:
                    new_dir = (-direction[0], -direction[1])
                else:
                    new_dir = direction
            elif gate == 4:  # XOR
                if count == 1:
                    new_dir = direction
                else:
                    new_dir = (direction[1], -direction[0])
            direction = new_dir
            
            # Add gate cell to path
            path.append((nr, nc))
            color_sequence.append(gate)
            current = (nr, nc)
        else:
            path.append(current)
            color_sequence.append(start_color if not color_sequence else color_sequence[-1])
            current = (nr, nc)
        step += 1
    
    # Create output grid
    output_grid = [row[:] for row in input_grid]
    for i, (r, c) in enumerate(path):
        base_color = color_sequence[i]
        shade = (base_color + i) % 9
        if shade == 0:
            shade = 1
        output_grid[r][c] = shade
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from typing import List, Tuple

def p(input_grid: Tuple[Tuple[int, ...], ...]) -> List[List[int]]:
    size = len(input_grid)
    input_grid = [list(row) for row in input_grid]
    
    # Find start cell (color 5) on left edge
    start_pos = None
    for r in range(size):
        if input_grid[r][0] == 5:
            start_pos = (r, 0)
            break
    if not start_pos:
        return input_grid
    
    # Simulate path
    path = []
    current = start_pos
    direction = (0, 1)  # right
    color_sequence = []
    step = 0
    max_step = size * 2
    
    while step < max_step:
        nr, nc = current[0] + direction[0], current[1] + direction[1]
        if not (0 <= nr < size and 0 <= nc < size):
            break
        
        if input_grid[nr][nc] in [1, 2, 3, 4]:
            gate = input_grid[nr][nc]
            # Count adjacent path cells
            count = 0
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                pr, pc = nr + dr, nc + dc
                if (pr, pc) in path:
                    count += 1
            
            # Apply gate logic
            if gate == 1:  # AND
                if count >= 2:
                    new_dir = direction
                else:
                    new_dir = (direction[1], -direction[0])
            elif gate == 2:  # OR
                if count >= 1:
                    new_dir = direction
                else:
                    new_dir = (direction[1], -direction[0])
            elif gate == 3:  # NOT
                if count >= 1:
                    new_dir = (-direction[0], -direction[1])
                else:
                    new_dir = direction
            elif gate == 4:  # XOR
                if count == 1:
                    new_dir = direction
                else:
                    new_dir = (direction[1], -direction[0])
            direction = new_dir
            
            path.append((nr, nc))
            color_sequence.append(gate)
            current = (nr, nc)
        else:
            path.append(current)
            color_sequence.append(5 if not color_sequence else color_sequence[-1])
            current = (nr, nc)
        step += 1
    
    # Create output grid
    output_grid = [row[:] for row in input_grid]
    for i, (r, c) in enumerate(path):
        base_color = color_sequence[i]
        shade = (base_color + i) % 9
        if shade == 0:
            shade = 1
        output_grid[r][c] = shade
    
    return output_grid
