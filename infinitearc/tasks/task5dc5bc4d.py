# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 5dc5bc4d
Difficulty: very hard

=== Tags ===
- Diagonal weaving
- Boundary tracing
- Symmetry completion
- Move object to first unoccupied space
- Connect all dots of same color

=== Description ===
The input grid is a 2D representation of a complex visual pattern composed of
scattered colored dots (0-9, where 0 denotes background) arranged across a grid
of dimensions 1×1 to 30×30. Each dot of a specific color represents a node that
must be connected to all other dots of the same color through a continuous
diagonal path. These paths must weave diagonally (moving only through adjacent
diagonal cells, such as (r+1,c+1) or (r-1,c+1)), forming minimal-length
connections that avoid intersecting paths of other colors while maintaining
visual clarity.   After all same-colored dots are connected via diagonal paths,
the outer boundary of each connected region must be traced using a fixed
boundary color (e.g., color 5), following the perimeter of the region in a
clockwise direction and marking all adjacent background cells. This boundary
tracing must be precise, ensuring no gaps or overlaps in the traced line.  Next,
the entire grid must undergo symmetry completion with respect to its vertical
midline. If the grid is asymmetric (i.e., the left and right halves differ), the
right half must be mirrored to the left (or vice versa) to produce a fully
symmetrical pattern. This step requires adjusting both the diagonal paths and
boundary traces to maintain consistency across the mirrored regions, potentially
necessitating path modifications to align with the symmetry.  Finally, any
remaining unconnected elements (such as isolated boundary segments or residual
pattern fragments not part of the connected regions) must be moved to the first
unoccupied background cell (color 0) in row-major order (top-left to bottom-
right). This movement must be deterministic, ensuring all elements are relocated
without overlapping or disrupting the established connections, boundaries, or
symmetry.  The output grid must synthesize all these transformations: connected
diagonal paths for each color, traced boundaries, symmetrical alignment, and
relocated elements, all while preserving the visual integrity of the original
input's structure and ensuring no input grid matches its output. The task
demands sequential application of multiple interdependent rules, requiring users
to simultaneously track path connectivity, boundary logic, symmetry constraints,
and spatial movement—all without relying on non-visual cues like pixel counts or
arithmetic properties.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Helper to distribute +1 and -1 moves across steps as evenly as possible
# Deterministic integer arithmetic used to avoid floating point differences.
def _distribute_signs(k, plus_count):
    if k <= 0:
        return []
    arr = []
    used = 0
    # i runs 1..k inclusive
    for i in range(1, k + 1):
        # target number of +1 that should be used by step i (rounded)
        target = (i * plus_count + k // 2) // k
        if target > used:
            arr.append(1)
            used += 1
        else:
            arr.append(-1)
    return arr


def _connect_diagonal(output, start, end, color):
    h = len(output)
    w = len(output[0])
    r1, c1 = start
    r2, c2 = end
    dr = r2 - r1
    dc = c2 - c1
    steps = max(abs(dr), abs(dc))
    if steps == 0:
        return
    row_plus = (dr + steps) // 2
    col_plus = (dc + steps) // 2
    row_moves = _distribute_signs(steps, row_plus)
    col_moves = _distribute_signs(steps, col_plus)
    r, c = r1, c1
    for i in range(steps):
        r += row_moves[i]
        c += col_moves[i]
        if 0 <= r < h and 0 <= c < w:
            # Only paint empty cells (do not overwrite other colors)
            if output[r][c] == 0:
                output[r][c] = color


def generate():
    # Choose a moderate size to allow diagonal weaving while keeping generation fast
    width = random.randint(6, 12)
    height = random.randint(6, 12)
    input_grid = grid(width, height, 0)

    # Choose 2-4 distinct colors from 1..9 excluding 5 (reserved for boundaries)
    available = [c for c in range(1, 10) if c != 5]
    num_colors = random.randint(2, min(4, len(available)))
    colors = random.sample(available, num_colors)

    occupied = set()
    positions_by_color = {}

    for color in colors:
        # pick a parity so that diagonal-only connectivity is possible
        parity = random.choice([0, 1])
        # collect eligible cells (correct parity and not occupied)
        eligible = [(r, c) for r in range(height) for c in range(width)
                    if ((r + c) % 2 == parity) and ((r, c) not in occupied)]
        if len(eligible) < 2:
            # if not enough on this parity, try the other parity
            parity = 1 - parity
            eligible = [(r, c) for r in range(height) for c in range(width)
                        if ((r + c) % 2 == parity) and ((r, c) not in occupied)]
        # ensure at least two dots per color
        max_dots = min(4, len(eligible))
        if max_dots < 2:
            # not enough room for another color; stop adding colors
            break
        num_dots = random.randint(2, max_dots)
        chosen = random.sample(eligible, num_dots)
        positions_by_color[color] = chosen
        for (r, c) in chosen:
            input_grid[r][c] = color
            occupied.add((r, c))

    # Make a deep copy for output and then perform the transformations
    output_grid = [row[:] for row in input_grid]

    # 1) Connect same-colored dots by diagonal-only weaving, color-by-color (sorted order)
    for color in sorted(positions_by_color.keys()):
        positions = sorted(positions_by_color[color])
        for i in range(len(positions) - 1):
            _connect_diagonal(output_grid, positions[i], positions[i + 1], color)

    # 2) Mark boundary cells (color 5) on background cells adjacent (4-neighbors) to any colored cell
    h = height
    w = width
    for r in range(h):
        for c in range(w):
            if output_grid[r][c] != 0 and output_grid[r][c] != 5:
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < h and 0 <= nc < w and output_grid[nr][nc] == 0:
                        output_grid[nr][nc] = 5

    # 3) Symmetry completion: mirror right half onto left half (vertical midline symmetry)
    for r in range(h):
        for c in range(w // 2):
            output_grid[r][c] = output_grid[r][w - 1 - c]

    # 4) Move isolated/unconnected boundary segments (5's with no adjacent non-boundary color)
    unconnected = []
    for r in range(h):
        for c in range(w):
            if output_grid[r][c] == 5:
                has_region = False
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < h and 0 <= nc < w and output_grid[nr][nc] not in (0, 5):
                        has_region = True
                        break
                if not has_region:
                    unconnected.append((r, c))

    zero_cells = [(r, c) for r in range(h) for c in range(w) if output_grid[r][c] == 0]

    for i, (r, c) in enumerate(unconnected):
        if i < len(zero_cells):
            # move the isolated 5 to the i-th free cell in row-major order
            output_grid[r][c] = 0
            zr, zc = zero_cells[i]
            output_grid[zr][zc] = 5

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

# The solver implements the same deterministic steps as the generator so that it
# reproduces the generator's output for any valid generated input.

def _distribute_signs(k, plus_count):
    if k <= 0:
        return []
    arr = []
    used = 0
    for i in range(1, k + 1):
        target = (i * plus_count + k // 2) // k
        if target > used:
            arr.append(1)
            used += 1
        else:
            arr.append(-1)
    return arr


def _connect_diagonal(output, start, end, color):
    h = len(output)
    w = len(output[0])
    r1, c1 = start
    r2, c2 = end
    dr = r2 - r1
    dc = c2 - c1
    steps = max(abs(dr), abs(dc))
    if steps == 0:
        return
    row_plus = (dr + steps) // 2
    col_plus = (dc + steps) // 2
    row_moves = _distribute_signs(steps, row_plus)
    col_moves = _distribute_signs(steps, col_plus)
    r, c = r1, c1
    for i in range(steps):
        r += row_moves[i]
        c += col_moves[i]
        if 0 <= r < h and 0 <= c < w:
            if output[r][c] == 0:
                output[r][c] = color


def p(input_grid):
    # Convert input to a mutable list of lists
    grid_in = [list(row) for row in input_grid]
    h = len(grid_in)
    w = len(grid_in[0])

    # Collect colors present in the input (exclude background 0 and boundary color 5)
    colors = sorted({grid_in[r][c] for r in range(h) for c in range(w) if grid_in[r][c] not in (0, 5)})

    # 1) Connect same-colored dots by diagonal weaving using the same deterministic method
    for color in colors:
        positions = [(r, c) for r in range(h) for c in range(w) if grid_in[r][c] == color]
        positions.sort()
        for i in range(len(positions) - 1):
            _connect_diagonal(grid_in, positions[i], positions[i + 1], color)

    # 2) Mark boundary color 5 on background cells adjacent (4-neighbors) to any colored cell
    for r in range(h):
        for c in range(w):
            if grid_in[r][c] != 0 and grid_in[r][c] != 5:
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < h and 0 <= nc < w and grid_in[nr][nc] == 0:
                        grid_in[nr][nc] = 5

    # 3) Symmetry completion: mirror right half onto left half
    for r in range(h):
        for c in range(w // 2):
            grid_in[r][c] = grid_in[r][w - 1 - c]

    # 4) Move isolated/unconnected boundary segments (5's that don't touch any color cell)
    unconnected = []
    for r in range(h):
        for c in range(w):
            if grid_in[r][c] == 5:
                has_region = False
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < h and 0 <= nc < w and grid_in[nr][nc] not in (0, 5):
                        has_region = True
                        break
                if not has_region:
                    unconnected.append((r, c))

    zero_cells = [(r, c) for r in range(h) for c in range(w) if grid_in[r][c] == 0]

    for i, (r, c) in enumerate(unconnected):
        if i < len(zero_cells):
            grid_in[r][c] = 0
            zr, zc = zero_cells[i]
            grid_in[zr][zc] = 5

    return tuple(tuple(row) for row in grid_in)

