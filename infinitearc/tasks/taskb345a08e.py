# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: b345a08e
Difficulty: medium

=== Tags ===
- Tiled majority vote
- Compare image
- Count tiles
- Count touches

=== Description ===
The input grid is divided into non-overlapping 2×2 tiles. For each tile, the
output color is determined by the following rules:   1. If one color appears
most frequently (three or four times) in the tile, that color is selected.   2.
If two colors tie for the most frequent appearance (two times each), the color
with more adjacent same-color pairs (horizontally or vertically within the tile)
is chosen.   3. If the adjacency count is still tied, the color appearing first
in row-major order (top-left to bottom-right) within the tile is selected.
The output grid is formed by replacing each 2×2 tile with the selected color,
maintaining the tile structure. This task requires recognizing tile patterns,
applying majority-based selection, and resolving ties through adjacency
counting—a medium-difficulty challenge involving visual pattern analysis.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.choice([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30])
    height = random.choice([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30])
    input_grid = [[random.randint(0,9) for _ in range(width)] for _ in range(height)]
    output_grid = [[0] * (width//2) for _ in range(height//2)]
    
    def get_tile_color(tile):
        colors = [tile[0][0], tile[0][1], tile[1][0], tile[1][1]]
        from collections import Counter
        count = Counter(colors)
        max_count = max(count.values())
        max_colors = [c for c, cnt in count.items() if cnt == max_count]
        
        if len(max_colors) == 1:
            return max_colors[0]
        
        adj_counts = {}
        for color in max_colors:
            h1 = 1 if tile[0][0] == color and tile[0][1] == color else 0
            h2 = 1 if tile[1][0] == color and tile[1][1] == color else 0
            v1 = 1 if tile[0][0] == color and tile[1][0] == color else 0
            v2 = 1 if tile[0][1] == color and tile[1][1] == color else 0
            total = h1 + h2 + v1 + v2
            adj_counts[color] = total
        
        max_adj = max(adj_counts.values())
        max_adj_colors = [c for c, cnt in adj_counts.items() if cnt == max_adj]
        
        if len(max_adj_colors) == 1:
            return max_adj_colors[0]
        
        for c in [tile[0][0], tile[0][1], tile[1][0], tile[1][1]]:
            if c in max_adj_colors:
                return c
    
    for i in range(width//2):
        for j in range(height//2):
            tile = [
                [input_grid[2*j][2*i], input_grid[2*j][2*i+1]],
                [input_grid[2*j+1][2*i], input_grid[2*j+1][2*i+1]]
            ]
            output_grid[j][i] = get_tile_color(tile)
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import Counter

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    if width % 2 != 0 or height % 2 != 0:
        raise ValueError("Input must have even dimensions")
    output_grid = [[0] * (width//2) for _ in range(height//2)]
    
    def get_tile_color(tile):
        colors = [tile[0][0], tile[0][1], tile[1][0], tile[1][1]]
        count = Counter(colors)
        max_count = max(count.values())
        max_colors = [c for c, cnt in count.items() if cnt == max_count]
        
        if len(max_colors) == 1:
            return max_colors[0]
        
        adj_counts = {}
        for color in max_colors:
            h1 = 1 if tile[0][0] == color and tile[0][1] == color else 0
            h2 = 1 if tile[1][0] == color and tile[1][1] == color else 0
            v1 = 1 if tile[0][0] == color and tile[1][0] == color else 0
            v2 = 1 if tile[0][1] == color and tile[1][1] == color else 0
            total = h1 + h2 + v1 + v2
            adj_counts[color] = total
        
        max_adj = max(adj_counts.values())
        max_adj_colors = [c for c, cnt in adj_counts.items() if cnt == max_adj]
        
        if len(max_adj_colors) == 1:
            return max_adj_colors[0]
        
        for c in [tile[0][0], tile[0][1], tile[1][0], tile[1][1]]:
            if c in max_adj_colors:
                return c
    
    for i in range(width//2):
        for j in range(height//2):
            tile = [
                [input_grid[2*j][2*i], input_grid[2*j][2*i+1]],
                [input_grid[2*j+1][2*i], input_grid[2*j+1][2*i+1]]
            ]
            output_grid[j][i] = get_tile_color(tile)
    
    return output_grid
