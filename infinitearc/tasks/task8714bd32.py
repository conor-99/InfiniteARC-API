# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 8714bd32
Difficulty: very hard

=== Tags ===
- Shape attribute projection

=== Description ===
Input grids contain multiple disconnected colored shapes (connected regions of
the same color), where each shape is oriented horizontally (wider than it is
tall), vertically (taller than it is wide), or square (equal width and height).
The output grid is generated by projecting the color of each horizontal shape
onto the square shape directly above it (same column, one row up), and the color
of each vertical shape onto the square shape directly to its left (same row, one
column left). If a square shape is targeted by both a horizontal and vertical
projection, the horizontal projection takes precedence. All other cells remain
unchanged. Background cells (color 0) are not considered part of any shape and
are unaffected. The transformation requires precise identification of shape
orientations and their spatial relationships to determine the correct color
assignments in the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_color

def generate():
    while True:
        width = random.randint(5, 30)
        height = random.randint(5, 30)
        input_grid = grid(width, height, 0)
        
        # Add horizontal shapes
        for _ in range(random.randint(1, 3)):
            color = random_color(exclude=[0])
            width_h = random.randint(2, 5)
            row = random.randint(1, height - 2)
            col = random.randint(0, width - width_h)
            for c in range(col, col + width_h):
                input_grid[row][c] = color
            
            # Place square above
            square_size = random.randint(2, 3)
            square_row = row - 1
            square_col = col
            for r in range(square_row, square_row + square_size):
                for c in range(square_col, square_col + square_size):
                    if 0 <= r < height and 0 <= c < width:
                        input_grid[r][c] = random_color(exclude=[0, color])

        # Add vertical shapes
        for _ in range(random.randint(1, 3)):
            color = random_color(exclude=[0])
            height_v = random.randint(2, 5)
            col = random.randint(1, width - 2)
            row = random.randint(0, height - height_v)
            for r in range(row, row + height_v):
                input_grid[r][col] = color
            
            # Place square to the left
            square_size = random.randint(2, 3)
            square_row = row
            square_col = col - 1
            for r in range(square_row, square_row + square_size):
                for c in range(square_col, square_col + square_size):
                    if 0 <= r < height and 0 <= c < width:
                        input_grid[r][c] = random_color(exclude=[0, color])

        # Add a square targeted by both
        if width > 2 and height > 2:
            h_row = random.randint(1, height - 2)
            v_col = random.randint(1, width - 2)
            square_size = 2
            square_row = h_row - 1
            square_col = v_col - 1
            for r in range(square_row, square_row + square_size):
                for c in range(square_col, square_col + square_size):
                    if 0 <= r < height and 0 <= c < width:
                        input_grid[r][c] = random_color(exclude=[0])

        # Compute output by applying transformation
        def apply_transformation(grid):
            grid = [list(row) for row in grid]
            visited = [[False] * len(grid[0]) for _ in range(len(grid))]
            components = []
            
            for r in range(len(grid)):
                for c in range(len(grid[0])):
                    if grid[r][c] != 0 and not visited[r][c]:
                        color = grid[r][c]
                        comp = []
                        queue = [(r, c)]
                        visited[r][c] = True
                        while queue:
                            cr, cc = queue.pop(0)
                            comp.append((cr, cc))
                            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                                nr, nc = cr + dr, cc + dc
                                if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and not visited[nr][nc] and grid[nr][nc] == color:
                                    visited[nr][nc] = True
                                    queue.append((nr, nc))
                        components.append(comp)
            
            comp_info = []
            for comp in components:
                min_r = min(r for r, c in comp)
                max_r = max(r for r, c in comp)
                min_c = min(c for r, c in comp)
                max_c = max(c for r, c in comp)
                width = max_c - min_c + 1
                height = max_r - min_r + 1
                color = grid[comp[0][0]][comp[0][1]]
                if width > height:
                    typ = 'horizontal'
                elif height > width:
                    typ = 'vertical'
                else:
                    typ = 'square'
                comp_info.append((comp, typ, color, min_r, max_r, min_c, max_c))
            
            horizontal_targets = []
            vertical_targets = []
            
            for comp, typ, color, min_r, max_r, min_c, max_c in comp_info:
                if typ == 'horizontal':
                    for comp2, typ2, color2, min_r2, max_r2, min_c2, max_c2 in comp_info:
                        if typ2 == 'square' and min_r2 == max_r - 1 and min_c2 <= max_c and max_c2 >= min_c:
                            horizontal_targets.append((comp2, color))
                elif typ == 'vertical':
                    for comp2, typ2, color2, min_r2, max_r2, min_c2, max_c2 in comp_info:
                        if typ2 == 'square' and max_c2 == min_c - 1 and min_r2 <= max_r and max_r2 >= min_r:
                            vertical_targets.append((comp2, color))
            
            output_grid = [row[:] for row in grid]
            updated_squares = set()
            
            for comp, color in horizontal_targets:
                for r, c in comp:
                    output_grid[r][c] = color
                updated_squares.add(tuple(sorted(comp)))
            
            for comp, color in vertical_targets:
                comp_tuple = tuple(sorted(comp))
                if comp_tuple not in updated_squares:
                    for r, c in comp:
                        output_grid[r][c] = color
            
            return output_grid

        output_grid = apply_transformation(input_grid)
        
        # Ensure input and output differ
        if input_grid != output_grid:
            return {
                "input": input_grid,
                "output": output_grid
            }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    visited = [[False] * len(grid[0]) for _ in range(len(grid))]
    components = []
    
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            if grid[r][c] != 0 and not visited[r][c]:
                color = grid[r][c]
                comp = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    comp.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                components.append(comp)
    
    comp_info = []
    for comp in components:
        min_r = min(r for r, c in comp)
        max_r = max(r for r, c in comp)
        min_c = min(c for r, c in comp)
        max_c = max(c for r, c in comp)
        width = max_c - min_c + 1
        height = max_r - min_r + 1
        color = grid[comp[0][0]][comp[0][1]]
        if width > height:
            typ = 'horizontal'
        elif height > width:
            typ = 'vertical'
        else:
            typ = 'square'
        comp_info.append((comp, typ, color, min_r, max_r, min_c, max_c))
    
    horizontal_targets = []
    vertical_targets = []
    
    for comp, typ, color, min_r, max_r, min_c, max_c in comp_info:
        if typ == 'horizontal':
            for comp2, typ2, color2, min_r2, max_r2, min_c2, max_c2 in comp_info:
                if typ2 == 'square' and min_r2 == max_r - 1 and min_c2 <= max_c and max_c2 >= min_c:
                    horizontal_targets.append((comp2, color))
        elif typ == 'vertical':
            for comp2, typ2, color2, min_r2, max_r2, min_c2, max_c2 in comp_info:
                if typ2 == 'square' and max_c2 == min_c - 1 and min_r2 <= max_r and max_r2 >= min_r:
                    vertical_targets.append((comp2, color))
    
    output_grid = [row[:] for row in grid]
    updated_squares = set()
    
    for comp, color in horizontal_targets:
        for r, c in comp:
            output_grid[r][c] = color
        updated_squares.add(tuple(sorted(comp)))
    
    for comp, color in vertical_targets:
        comp_tuple = tuple(sorted(comp))
        if comp_tuple not in updated_squares:
            for r, c in comp:
                output_grid[r][c] = color
    
    return output_grid
