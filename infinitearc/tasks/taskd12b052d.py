# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: d12b052d
Difficulty: hard

=== Tags ===
- Proximity guessing
- Concentric
- Draw pattern from point
- Mirror pairing

=== Description ===
The input grid contains a single cell with color 5, which serves as the
designated center point. The output grid is generated by assigning each cell a
color based on its Manhattan distance from the center (distance 0 corresponds to
color 1, distance 1 to color 2, and so on, cycling through colors 1–9 for
distances 0–8, 9–17, etc.). The grid is then mirrored vertically across the
center column, ensuring that for every cell (i, j), the color at (i, j) matches
the color at (i, 2c - j), where c is the column index of the center. This
mirroring enforces vertical symmetry, and the concentric pattern emerges
naturally from the distance-based coloring, with each "ring" representing a
fixed distance from the center. The task requires identifying the center,
computing distances, mapping to colors, and enforcing symmetry, making it
challenging due to the need to handle variable grid sizes, distance cycling, and
implicit symmetry enforcement.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    r = random.randint(0, height - 1)
    c = random.randint(0, width - 1)
    input_grid = [[0] * width for _ in range(height)]
    input_grid[r][c] = 5
    output_grid = [[0] * width for _ in range(height)]
    for i in range(height):
        for j in range(width):
            d = abs(i - r) + abs(j - c)
            output_grid[i][j] = (d % 9) + 1
    mirrored = [[0] * width for _ in range(height)]
    for i in range(height):
        for j in range(width):
            mirror_j = 2 * c - j
            if mirror_j < 0:
                mirror_j = 0
            elif mirror_j >= width:
                mirror_j = width - 1
            mirrored[i][j] = output_grid[i][mirror_j]
    return {
        "input": input_grid,
        "output": mirrored
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    r, c = -1, -1
    for i in range(height):
        for j in range(width):
            if input_grid[i][j] == 5:
                r, c = i, j
                break
        if r != -1:
            break
    output_grid = [[0] * width for _ in range(height)]
    for i in range(height):
        for j in range(width):
            d = abs(i - r) + abs(j - c)
            output_grid[i][j] = (d % 9) + 1
    mirrored = [[0] * width for _ in range(height)]
    for i in range(height):
        for j in range(width):
            mirror_j = 2 * c - j
            if mirror_j < 0:
                mirror_j = 0
            elif mirror_j >= width:
                mirror_j = width - 1
            mirrored[i][j] = output_grid[i][mirror_j]
    return mirrored
