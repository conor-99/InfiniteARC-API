# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 30347c3d
Difficulty: medium

=== Tags ===
- Connect the dots

=== Description ===
The input grid consists of a 2D array of integers from 0 to 9, where non-zero
values represent colored dots. For each row, the output grid connects dots of
the same color by filling all cells between the leftmost and rightmost
occurrence of each color in that row with the same color. This creates
contiguous horizontal blocks of color between the outermost dots of each color
within every row, effectively "connecting" the dots horizontally. The
transformation is applied independently to each row, and the background (value
0) remains unchanged where no dots exist.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import *

def generate():
    width = random.randint(3, 30)
    height = random.randint(1, 30)
    input_grid = [[0] * width for _ in range(height)]
    
    # Ensure at least one row has a color repeated with 0s in between
    row_idx = random.randint(0, height-1)
    color = random.randint(1, 9)
    col1 = random.randint(0, width - 3)
    col2 = random.randint(col1 + 2, width - 1)
    input_grid[row_idx][col1] = color
    input_grid[row_idx][col2] = color
    
    # Fill other cells with random colors (1-9) with 50% chance
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0 and random.random() < 0.5:
                input_grid[r][c] = random.randint(1, 9)
    
    # Generate output
    output_grid = [row[:] for row in input_grid]
    for r in range(height):
        color_positions = {}
        for c in range(width):
            color_val = input_grid[r][c]
            if color_val != 0:
                if color_val not in color_positions:
                    color_positions[color_val] = [c, c]
                else:
                    color_positions[color_val][0] = min(color_positions[color_val][0], c)
                    color_positions[color_val][1] = max(color_positions[color_val][1], c)
        for color_val, (min_c, max_c) in color_positions.items():
            for c in range(min_c, max_c + 1):
                output_grid[r][c] = color_val
    
    return {
        "input": input_grid,
        "output": output_grid
    }

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = [row[:] for row in input_grid]
    for r in range(height):
        color_positions = {}
        for c in range(width):
            color_val = input_grid[r][c]
            if color_val != 0:
                if color_val not in color_positions:
                    color_positions[color_val] = [c, c]
                else:
                    color_positions[color_val][0] = min(color_positions[color_val][0], c)
                    color_positions[color_val][1] = max(color_positions[color_val][1], c)
        for color_val, (min_c, max_c) in color_positions.items():
            for c in range(min_c, max_c + 1):
                output_grid[r][c] = color_val
    return output_grid


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = [row[:] for row in input_grid]
    for r in range(height):
        color_positions = {}
        for c in range(width):
            color_val = input_grid[r][c]
            if color_val != 0:
                if color_val not in color_positions:
                    color_positions[color_val] = [c, c]
                else:
                    color_positions[color_val][0] = min(color_positions[color_val][0], c)
                    color_positions[color_val][1] = max(color_positions[color_val][1], c)
        for color_val, (min_c, max_c) in color_positions.items():
            for c in range(min_c, max_c + 1):
                output_grid[r][c] = color_val
    return output_grid
