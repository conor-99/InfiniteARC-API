# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: c634856c
Difficulty: insane

=== Tags ===
- Rule composition
- Alternating rule composition
- Pattern alignment
- Detect vertical symmetry

=== Description ===
Input grids feature multiple disconnected, contiguous regions of uniform color
(each region is a connected group of cells sharing the same color value,
connected edge-to-edge). Each region may exhibit vertical symmetry (mirroring
across a vertical axis through its center) or lack it. The output grid requires
two sequential transformations applied to each region:  1. **Vertical Symmetry
Enforcement**: For regions lacking vertical symmetry, reflect the region across
its central vertical axis to create a symmetric shape. Symmetric regions remain
unchanged. This step ensures all regions in the output grid are vertically
symmetric.  2. **Alternating Color Transformation**: After symmetry enforcement,
process regions in row-major order (top-to-bottom, left-to-right). For the first
asymmetric region (after reflection), replace its color with the next color in
the sequence (0→1→2→…→9→0). For the second region, replace its color with the
previous color (0→9→8→…→1→0). The third region reverts to "next," alternating
direction with each subsequent region. Symmetric regions (unchanged during step
1) follow the same alternating pattern based on their order.  The output grid
displays all regions in their symmetric form with colors transformed according
to the alternating sequence. Background cells (color 0) remain unmodified, and
all transformations are applied without overlapping or extending beyond original
region boundaries. The task demands detecting symmetry in complex, irregular
regions while composing multiple alternating rules to generate the final output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def find_regions(grid):
    height = len(grid)
    width = len(grid[0])
    visited = [[False] * width for _ in range(height)]
    regions = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and not visited[r][c]:
                region = []
                stack = [(r, c)]
                color = grid[r][c]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    region.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                regions.append((color, region))
    return regions

def is_vertical_symmetric(region):
    if not region:
        return True
    min_col = min(c for r, c in region)
    max_col = max(c for r, c in region)
    for r, c in region:
        mirror_c = min_col + max_col - c
        if (r, mirror_c) not in region:
            return False
    return True

def reflect_region(region):
    min_col = min(c for r, c in region)
    max_col = max(c for r, c in region)
    return [(r, min_col + max_col - c) for r, c in region]

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid_input = common.grid(width, height, 0)
    colors = list(range(1, 10))
    
    # Create at least one asymmetric region
    r_start = random.randint(1, height - 3)
    c_start = random.randint(1, width - 4)
    color1 = random.choice(colors)
    
    # Symmetric region (3 cells)
    for c in range(c_start, c_start + 3):
        grid_input[r_start][c] = color1
    
    # Asymmetric region (4 cells: 3 + 1 extra on left)
    color2 = random.choice([c for c in colors if c != color1])
    for c in range(c_start, c_start + 3):
        grid_input[r_start + 1][c] = color2
    grid_input[r_start + 1][c_start - 1] = color2
    
    # Find regions
    regions = find_regions(grid_input)
    regions.sort(key=lambda x: (min(r for r, c in x[1]), min(c for r, c in x[1])))
    
    # Create output grid
    grid_output = common.grid(width, height, 0)
    for idx, (color, region) in enumerate(regions):
        if not is_vertical_symmetric(region):
            region = reflect_region(region)
        new_color = (color + (1 if idx % 2 == 0 else -1)) % 10
        if new_color == 0:
            new_color = 1
        for (r, c) in region:
            if 0 <= r < height and 0 <= c < width:
                grid_output[r][c] = new_color
    
    return {
        "input": grid_input,
        "output": grid_output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def find_regions(grid):
    height = len(grid)
    width = len(grid[0])
    visited = [[False] * width for _ in range(height)]
    regions = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and not visited[r][c]:
                region = []
                stack = [(r, c)]
                color = grid[r][c]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    region.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                regions.append((color, region))
    return regions

def is_vertical_symmetric(region):
    if not region:
        return True
    min_col = min(c for r, c in region)
    max_col = max(c for r, c in region)
    for r, c in region:
        mirror_c = min_col + max_col - c
        if (r, mirror_c) not in region:
            return False
    return True

def reflect_region(region):
    min_col = min(c for r, c in region)
    max_col = max(c for r, c in region)
    return [(r, min_col + max_col - c) for r, c in region]

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    regions = find_regions(grid)
    regions.sort(key=lambda x: (min(r for r, c in x[1]), min(c for r, c in x[1])))
    
    output = common.grid(width, height, 0)
    for idx, (color, region) in enumerate(regions):
        if not is_vertical_symmetric(region):
            region = reflect_region(region)
        new_color = (color + (1 if idx % 2 == 0 else -1)) % 10
        if new_color == 0:
            new_color = 1
        for (r, c) in region:
            if 0 <= r < height and 0 <= c < width:
                output[r][c] = new_color
    
    return output
