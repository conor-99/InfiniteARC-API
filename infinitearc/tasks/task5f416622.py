# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 5f416622
Difficulty: medium

=== Tags ===
- Create grid
- Find and fix broken symmetry
- Bounce
- Recolor object based on its size

=== Description ===
The input grid features a bounce path that is asymmetrically drawn, breaking the
expected symmetry of a bouncing motion along the grid's width. The output grid
corrects this by adjusting the path to symmetrically bounce between the left and
right edges, mirroring the path's trajectory across the grid's vertical
centerline. The corrected path is then recolored using a color equal to the
path's length (number of cells), which corresponds to the grid's height (e.g., a
4x4 grid recolors the path to color 4).
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import bounce

def generate():
    H = random.randint(1, 9)
    W = random.randint(2, 30)
    _, output_grid = bounce(W, H, 0, 0, H)
    path_positions = []
    for r in range(H):
        for c in range(W):
            if output_grid[r][c] == H:
                path_positions.append((r, c))
    if not path_positions:
        return generate()
    middle_row = H // 2
    candidates = [pos for pos in path_positions if pos[0] != middle_row]
    if not candidates:
        candidates = path_positions
    r, c = random.choice(candidates)
    new_c = None
    for offset in [1, -1]:
        new_c_candidate = c + offset
        if 0 <= new_c_candidate < W:
            new_c = new_c_candidate
            break
    if new_c is None:
        return generate()
    input_grid = [row[:] for row in output_grid]
    input_grid[r][c] = 0
    input_grid[r][new_c] = H
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    H = len(input_grid)
    W = len(input_grid[0])
    correct_path = [0] * H
    c = 0
    c_dir = 1
    for r in range(H-1, -1, -1):
        correct_path[r] = c
        c += c_dir
        if c == 0 or c == W-1:
            c_dir = -c_dir
    output_grid = [[0] * W for _ in range(H)]
    for r in range(H):
        output_grid[r][correct_path[r]] = H
    return output_grid
