# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 5996b602
Difficulty: insane

=== Tags ===
- Parse and render drawing commands

=== Description ===
The task involves parsing a sequence of points encoded within an input grid and
rendering a continuous path that connects these points in row-major order. Input
grids consist of 2D arrangements of numbers (0-9), where non-zero values
(colors) represent distinct points. The output grid is generated by:  1.
Identifying all non-zero cells in the input grid, sorted by row (top to bottom)
and then column (left to right). 2. Drawing straight-line segments between
consecutive points in this sorted sequence. Horizontal/vertical segments are
drawn directly; diagonal segments use a staircase pattern (alternating
horizontal/vertical moves to approximate the diagonal). 3. The rendered path
uses a fixed color (e.g., value 1), while all other cells remain 0 (background).
For "insane" difficulty, input grids contain 15–25 non-zero points arranged in
complex, non-linear patterns (e.g., overlapping paths, sharp turns, diagonal
sequences), requiring precise sorting and staircase-line rendering to avoid
visual misalignment. The output must accurately reflect the connectivity and
geometry of the input point sequence without relying on numerical values (e.g.,
color values are irrelevant—only positions matter).
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid
def draw_line(grid, r1, c1, r2, c2):
    if r1 == r2:
        for c in range(min(c1, c2), max(c1, c2) + 1):
            grid[r1][c] = 1
    elif c1 == c2:
        for r in range(min(r1, r2), max(r1, r2) + 1):
            grid[r][c1] = 1
    else:
        r, c = r1, c1
        grid[r][c] = 1
        while r < r2 or c < c2:
            if (r2 - r) > (c2 - c):
                r += 1
            else:
                c += 1
            grid[r][c] = 1
def generate():
    width = random.randint(10, 25)
    height = random.randint(10, 25)
    input_grid = grid(width, height, 0)
    num_points = random.randint(15, 25)
    points = []
    while len(points) < num_points:
        r = random.randint(0, height - 1)
        c = random.randint(0, width - 1)
        if (r, c) not in points:
            points.append((r, c))
            input_grid[r][c] = random.randint(1, 9)
    sorted_points = sorted(points, key=lambda p: (p[0], p[1]))
    output_grid = grid(width, height, 0)
    for i in range(len(sorted_points) - 1):
        r1, c1 = sorted_points[i]
        r2, c2 = sorted_points[i + 1]
        draw_line(output_grid, r1, c1, r2, c2)
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid
def p(input_grid):
    def draw_line(grid, r1, c1, r2, c2):
        if r1 == r2:
            for c in range(min(c1, c2), max(c1, c2) + 1):
                grid[r1][c] = 1
        elif c1 == c2:
            for r in range(min(r1, r2), max(r1, r2) + 1):
                grid[r][c1] = 1
        else:
            r, c = r1, c1
            grid[r][c] = 1
            while r < r2 or c < c2:
                if (r2 - r) > (c2 - c):
                    r += 1
                else:
                    c += 1
                grid[r][c] = 1
    width = len(input_grid[0])
    height = len(input_grid)
    points = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                points.append((r, c))
    sorted_points = sorted(points, key=lambda p: (p[0], p[1]))
    output_grid = grid(width, height, 0)
    if len(sorted_points) > 1:
        for i in range(len(sorted_points) - 1):
            r1, c1 = sorted_points[i]
            r2, c2 = sorted_points[i + 1]
            draw_line(output_grid, r1, c1, r2, c2)
    elif len(sorted_points) == 1:
        r, c = sorted_points[0]
        output_grid[r][c] = 1
    return output_grid
