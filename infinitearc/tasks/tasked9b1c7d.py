# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: ed9b1c7d
Difficulty: hard

=== Tags ===
- Cave escape
- Draw line of sight
- Teleporter network routing

=== Description ===
Input grids depict a cave-like environment with walls represented by a single
color (e.g., red) and a background color (e.g., black). Embedded within the cave
are teleporter pairs—each consisting of two distinct cells sharing a unique
color (e.g., green for one pair, blue for another), positioned such that their
direct horizontal, vertical, or diagonal line of sight may be obstructed by
walls. The cave also contains a single exit cell (e.g., yellow) positioned at
the edge of the grid.   The transformation rule requires drawing straight-line
connections between each teleporter pair *only if* the direct path between their
two cells is unobstructed (i.e., no wall cells lie along the line segment
connecting them). These connections must be drawn using the teleporter pair’s
color and span the exact distance between the two points, occupying only
background cells (never overlapping walls or other elements). Teleporter pairs
with obstructed paths are ignored. The exit cell remains visually distinct but
is not directly connected in the output; instead, the network of unobstructed
teleporter connections forms a path that logically leads to the exit, with no
additional lines drawn to it.   Key complexity arises from the need to check all
intermediate cells along potential lines of sight (including diagonals), avoid
overwriting existing elements, and recognize that wall placements may block some
connections while allowing others. The task demands precise geometric reasoning
about line-of-sight obstruction across varying grid scales, with no reliance on
numerical properties of colors or positions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def get_line_cells(r1, c1, r2, c2):
    # Bresenham's line algorithm adapted for grid coordinates (row, col)
    cells = []
    x0, y0 = r1, c1
    x1, y1 = r2, c2
    dx = abs(x1 - x0)
    dy = abs(y1 - y0)
    sx = 1 if x0 < x1 else -1
    sy = 1 if y0 < y1 else -1
    err = dx - dy
    while True:
        cells.append((x0, y0))
        if x0 == x1 and y0 == y1:
            break
        e2 = 2 * err
        if e2 > -dy:
            err -= dy
            x0 += sx
        if e2 < dx:
            err += dx
            y0 += sy
    return cells


def generate():
    # Grid size
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    grid = [[0 for _ in range(width)] for _ in range(height)]

    # Place a single wall segment (color 2), horizontal or vertical
    orientation = random.choice(['h', 'v'])
    wall_coords = []  # list of (r,c) cells that are walls
    if orientation == 'v':
        wall_col = random.randint(3, max(3, width - 4))
        start = random.randint(1, max(1, height // 3))
        length = random.randint(3, max(3, height - start - 2))
        end = min(height - 1, start + length)
        for r in range(start, end):
            grid[r][wall_col] = 2
            wall_coords.append((r, wall_col))
    else:
        wall_row = random.randint(3, max(3, height - 4))
        start = random.randint(1, max(1, width // 3))
        length = random.randint(3, max(3, width - start - 2))
        end = min(width - 1, start + length)
        for c in range(start, end):
            grid[wall_row][c] = 2
            wall_coords.append((wall_row, c))

    # Place an exit cell (color 5) somewhere on the edge, avoiding walls
    edges = []
    for c in range(width):
        edges.append((0, c))
        edges.append((height - 1, c))
    for r in range(1, height - 1):
        edges.append((r, 0))
        edges.append((r, width - 1))
    random.shuffle(edges)
    exit_r, exit_c = None, None
    for (r, c) in edges:
        if grid[r][c] == 0:
            exit_r, exit_c = r, c
            grid[r][c] = 5
            break
    if exit_r is None:
        exit_r, exit_c = 0, 0
        grid[exit_r][exit_c] = 5

    # Pick two teleporter colors
    color_pool = [3, 4, 6, 7, 8, 9]
    colors = random.sample(color_pool, 2)

    pairs = {}

    # Helper to check cell availability
    def free_cell(r, c):
        return 0 <= r < height and 0 <= c < width and grid[r][c] == 0 and (r, c) != (exit_r, exit_c)

    # Create one guaranteed unobstructed pair (with at least one intermediate cell)
    c_clear = colors[0]
    placed = False
    attempts = 0
    while not placed and attempts < 1000:
        attempts += 1
        if orientation == 'v':
            # choose side left or right
            side = random.choice(['left', 'right'])
            r = random.randint(1, height - 2)
            if side == 'left':
                c1 = random.randint(1, max(1, wall_col - 2))
                c2 = random.randint(1, max(1, wall_col - 2))
            else:
                c1 = random.randint(wall_col + 2, width - 2) if wall_col + 2 < width - 1 else random.randint(1, width - 2)
                c2 = random.randint(wall_col + 2, width - 2) if wall_col + 2 < width - 1 else random.randint(1, width - 2)
            if abs(c1 - c2) < 2:
                continue
            if free_cell(r, c1) and free_cell(r, c2):
                p1 = (r, c1)
                p2 = (r, c2)
                cells = get_line_cells(r, c1, r, c2)
                if not any(grid[x][y] == 2 for (x, y) in cells) and all(grid[x][y] == 0 or (x, y) in (p1, p2) for (x, y) in cells) and len(cells) >= 3:
                    grid[p1[0]][p1[1]] = c_clear
                    grid[p2[0]][p2[1]] = c_clear
                    pairs[c_clear] = (p1, p2)
                    placed = True
        else:
            # horizontal wall: choose above or below
            side = random.choice(['above', 'below'])
            c = random.randint(1, width - 2)
            if side == 'above':
                r1 = random.randint(1, max(1, wall_row - 2))
                r2 = random.randint(1, max(1, wall_row - 2))
            else:
                r1 = random.randint(wall_row + 2, height - 2) if wall_row + 2 < height - 1 else random.randint(1, height - 2)
                r2 = random.randint(wall_row + 2, height - 2) if wall_row + 2 < height - 1 else random.randint(1, height - 2)
            if abs(r1 - r2) < 2:
                continue
            if free_cell(r1, c) and free_cell(r2, c):
                p1 = (r1, c)
                p2 = (r2, c)
                cells = get_line_cells(r1, c, r2, c)
                if not any(grid[x][y] == 2 for (x, y) in cells) and all(grid[x][y] == 0 or (x, y) in (p1, p2) for (x, y) in cells) and len(cells) >= 3:
                    grid[p1[0]][p1[1]] = c_clear
                    grid[p2[0]][p2[1]] = c_clear
                    pairs[c_clear] = (p1, p2)
                    placed = True
    if not placed:
        # fallback: scan deterministically for a pair that meets criteria
        empties = [(r, c) for r in range(1, height - 1) for c in range(1, width - 1) if grid[r][c] == 0]
        found = False
        for i in range(len(empties)):
            for j in range(i + 1, len(empties)):
                p1 = empties[i]
                p2 = empties[j]
                cells = get_line_cells(p1[0], p1[1], p2[0], p2[1])
                if len(cells) < 3:
                    continue
                if any(grid[x][y] == 2 for (x, y) in cells):
                    continue
                if all(grid[x][y] == 0 or (x, y) in (p1, p2) for (x, y) in cells):
                    grid[p1[0]][p1[1]] = c_clear
                    grid[p2[0]][p2[1]] = c_clear
                    pairs[c_clear] = (p1, p2)
                    found = True
                    break
            if found:
                break
        if not found:
            return generate()

    # Create one blocked pair across the wall using the other color
    c_block = colors[1]
    placed = False
    attempts = 0
    while not placed and attempts < 1000:
        attempts += 1
        if orientation == 'v':
            # pick a row that intersects the vertical wall
            r_choices = [r for (r, c) in wall_coords]
            if not r_choices:
                break
            r = random.choice(r_choices)
            # pick columns on either side of the wall
            c1 = random.randint(1, wall_col - 1) if wall_col - 1 >= 1 else 1
            c2 = random.randint(wall_col + 1, width - 2) if wall_col + 1 <= width - 2 else width - 2
            if free_cell(r, c1) and free_cell(r, c2):
                p1 = (r, c1)
                p2 = (r, c2)
                grid[p1[0]][p1[1]] = c_block
                grid[p2[0]][p2[1]] = c_block
                pairs[c_block] = (p1, p2)
                placed = True
        else:
            # horizontal wall: pick a column that intersects the horizontal wall
            c_choices = [c for (r, c) in wall_coords]
            if not c_choices:
                break
            c = random.choice(c_choices)
            r1 = random.randint(1, wall_row - 1) if wall_row - 1 >= 1 else 1
            r2 = random.randint(wall_row + 1, height - 2) if wall_row + 1 <= height - 2 else height - 2
            if free_cell(r1, c) and free_cell(r2, c):
                p1 = (r1, c)
                p2 = (r2, c)
                grid[p1[0]][p1[1]] = c_block
                grid[p2[0]][p2[1]] = c_block
                pairs[c_block] = (p1, p2)
                placed = True
    if not placed:
        # fallback: place two random empties
        empties = [(r, c) for r in range(1, height - 1) for c in range(1, width - 1) if grid[r][c] == 0]
        if len(empties) >= 2:
            p1, p2 = random.sample(empties, 2)
            grid[p1[0]][p1[1]] = c_block
            grid[p2[0]][p2[1]] = c_block
            pairs[c_block] = (p1, p2)

    # Build the output by drawing unobstructed connections (only on background cells)
    output = [row[:] for row in grid]
    for color in sorted(pairs.keys()):
        (r1, c1), (r2, c2) = pairs[color]
        cells = get_line_cells(r1, c1, r2, c2)
        if len(cells) >= 3 and not any(grid[r][c] == 2 for (r, c) in cells) and all(grid[r][c] == 0 or (r, c) in ((r1, c1), (r2, c2)) for (r, c) in cells):
            for (r, c) in cells:
                if grid[r][c] == 0:
                    output[r][c] = color

    return {'input': grid, 'output': output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    def get_line_cells(r1, c1, r2, c2):
        cells = []
        x0, y0 = r1, c1
        x1, y1 = r2, c2
        dx = abs(x1 - x0)
        dy = abs(y1 - y0)
        sx = 1 if x0 < x1 else -1
        sy = 1 if y0 < y1 else -1
        err = dx - dy
        while True:
            cells.append((x0, y0))
            if x0 == x1 and y0 == y1:
                break
            e2 = 2 * err
            if e2 > -dy:
                err -= dy
                x0 += sx
            if e2 < dx:
                err += dx
                y0 += sy
        return cells

    orig = [row[:] for row in grid]
    output = [row[:] for row in grid]

    # Find teleporter colors: colors that appear exactly twice and are not wall(2) or exit(5) or background(0)
    pairs = {}
    for r in range(height):
        for c in range(width):
            v = orig[r][c]
            if v in (0, 2, 5):
                continue
            pairs.setdefault(v, []).append((r, c))
    pairs = {k: tuple(v) for k, v in pairs.items() if len(v) == 2}

    for color in sorted(pairs.keys()):
        (r1, c1), (r2, c2) = pairs[color]
        cells = get_line_cells(r1, c1, r2, c2)
        if len(cells) >= 3 and not any(orig[r][c] == 2 for (r, c) in cells) and all(orig[r][c] == 0 or (r, c) in ((r1, c1), (r2, c2)) for (r, c) in cells):
            for (r, c) in cells:
                if orig[r][c] == 0:
                    output[r][c] = color

    return output

