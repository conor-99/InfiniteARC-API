# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 5eb4309c
Difficulty: medium–hard

=== Tags ===
- Pattern intersection
- Teleporter network routing
- Pattern sync
- Obstacles
- Rotate each quadrant

=== Description ===
The input grid consists of a square or rectangular grid divided into four
quadrants, each containing a distinct pattern (e.g., a sequence of colored cells
forming a path) that terminates at a teleporter pair—a pair of cells sharing the
same non-background color acting as entry and exit points. Obstacles
(background-colored cells) block certain paths. The teleporters are positioned
such that when each quadrant is rotated 90 degrees clockwise, the teleporter
pairs from adjacent quadrants align to form a continuous network.   The output
grid is generated by rotating each quadrant 90 degrees clockwise, then drawing a
continuous pattern (the "pattern sync") that connects all aligned teleporter
pairs while navigating around obstacles. The pattern must follow the rotational
direction of the quadrants, ensuring no path crosses obstacles or overlaps with
existing patterns. The background remains unchanged except for the newly drawn
pattern, which synchronizes with the transformed quadrants to create a seamless,
obstacle-avoiding route through the grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Helper rotations for square blocks

def rotate_cw(block):
    # Rotate a square block 90 degrees clockwise
    return [list(row) for row in zip(*block[::-1])]


def rotate_ccw(block):
    # Rotate a square block 90 degrees counter-clockwise
    return [list(row) for row in zip(*block)][::-1]


def place_snake(grid_out, r0, c0, n, end_r, end_c, color, forbidden, min_len=2, max_len=None):
    # Place a self-avoiding walk starting at (end_r,end_c) and extending inward
    if max_len is None:
        max_len = max(2, n + 1)
    tries = 0
    while tries < 50:
        tries += 1
        length = random.randint(min_len, max_len)
        path = [(end_r, end_c)]
        visited = set(path) | set(forbidden)
        success = True
        for _ in range(length - 1):
            r, c = path[-1]
            neighbors = []
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if nr < r0 or nr >= r0 + n or nc < c0 or nc >= c0 + n:
                    continue
                if (nr, nc) in visited:
                    continue
                neighbors.append((nr, nc))
            if not neighbors:
                success = False
                break
            nxt = random.choice(neighbors)
            path.append(nxt)
            visited.add(nxt)
        if not success:
            continue
        # commit the path
        for (r, c) in path:
            grid_out[r][c] = color
        return set(path)
    # fallback: place the endpoint only
    grid_out[end_r][end_c] = color
    return {(end_r, end_c)}


def generate():
    # Choose an even size at least 6 so we have a clear central 2x2 and surrounding ring
    size = random.choice([6, 8, 10, 12, 14, 16])
    n = size // 2

    # Build the target output first (this is what the solver should produce after rotating quadrants)
    output_grid = grid(size, size, 0)

    # Reserve colors: 0 background, 1 obstacles, 9 ring/path
    obstacle_color = 1
    ring_color = 9

    # Pick four distinct colors for quadrant patterns (avoid 0,1,9)
    available = [c for c in range(2, 9) if c not in [1, 9]]
    quad_colors = random.sample(available, 4)

    # Coordinates of the teleporter endpoint (inner corner) for each quadrant in output grid
    quad_info = [
        # (r0, c0, end_r, end_c) for TL, TR, BR, BL
        (0, 0, n - 1, n - 1),        # TL ends at (n-1, n-1)
        (0, n, n - 1, n),            # TR ends at (n-1, n)
        (n, n, n, n),                # BR ends at (n, n)
        (n, 0, n, n - 1)             # BL ends at (n, n-1)
    ]

    # Reserve ring coordinates (the 4x4 square around the center minus the central 2x2)
    ring_coords = set()
    for r in range(n - 2, n + 2):
        for c in range(n - 2, n + 2):
            # skip the central 2x2
            if n - 1 <= r <= n and n - 1 <= c <= n:
                continue
            if 0 <= r < size and 0 <= c < size:
                ring_coords.add((r, c))

    occupied = set()

    # Place quadrant patterns (snakes) ending at the inner corner; forbid ring coords
    for i, (r0, c0, end_r, end_c) in enumerate(quad_info):
        color = quad_colors[i]
        forbidden = set(occupied) | set(ring_coords)
        placed = place_snake(output_grid, r0, c0, n, end_r, end_c, color, forbidden, min_len=2, max_len=n + 2)
        occupied |= placed

    # Place some obstacles randomly inside each quadrant but never on ring or on existing patterns
    for (r0, c0, _, _) in quad_info:
        # up to a few obstacles per quadrant
        obs_count = random.randint(0, max(0, n // 2 - 1))
        tries = 0
        placed = 0
        while placed < obs_count and tries < 50:
            tries += 1
            rr = random.randint(r0, r0 + n - 1)
            cc = random.randint(c0, c0 + n - 1)
            if (rr, cc) in occupied or (rr, cc) in ring_coords:
                continue
            # Avoid placing obstacle on the central corner cells
            if (rr, cc) in [(info[2], info[3]) for info in quad_info]:
                continue
            output_grid[rr][cc] = obstacle_color
            occupied.add((rr, cc))
            placed += 1

    # Now draw the ring path around the central 2x2 using ring_color; these cells must be background
    for (r, c) in ring_coords:
        # ensure not to overwrite any color (should be background if generation succeeded)
        if output_grid[r][c] == 0:
            output_grid[r][c] = ring_color

    # Now create the input by rotating each quadrant counter-clockwise (so solving requires clockwise rotation)
    input_grid = grid(size, size, 0)
    for (r0, c0, _, _), _color in zip(quad_info, quad_colors):
        # extract the n x n block from output
        block = [row[c0:c0 + n] for row in output_grid[r0:r0 + n]]
        # rotate this block CCW to make input (so rotating CW returns output)
        rotated = rotate_ccw(block)
        # write into input grid
        for dr in range(n):
            for dc in range(n):
                input_grid[r0 + dr][c0 + dc] = rotated[dr][dc]

    return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def rotate_cw(block):
    return [list(row) for row in zip(*block[::-1])]


def p(input_grid):
    # Convert to mutable list-of-lists
    g = [list(row) for row in input_grid]
    size = len(g)
    n = size // 2

    # Prepare output as a copy
    output = [row[:] for row in g]

    # Rotate each quadrant 90 degrees clockwise into place
    quad_coords = [
        (0, 0),    # TL
        (0, n),    # TR
        (n, n),    # BR
        (n, 0)     # BL
    ]
    for (r0, c0) in quad_coords:
        # extract block
        block = [row[c0:c0 + n] for row in g[r0:r0 + n]]
        rotated = rotate_cw(block)
        # write back
        for dr in range(n):
            for dc in range(n):
                output[r0 + dr][c0 + dc] = rotated[dr][dc]

    # Draw the ring around the central 2x2 using color 9 if those cells are empty (background)
    ring_color = 9
    for r in range(n - 2, n + 2):
        for c in range(n - 2, n + 2):
            # skip central 2x2
            if n - 1 <= r <= n and n - 1 <= c <= n:
                continue
            if 0 <= r < size and 0 <= c < size:
                if output[r][c] == 0:
                    output[r][c] = ring_color

    return output

