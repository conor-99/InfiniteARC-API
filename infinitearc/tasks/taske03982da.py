# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: e03982da
Difficulty: very hard

=== Tags ===
- Elastic reflection
- Multi agent path weaving
- Cut and unfold
- Progressive rule shift
- Color guessing
- Summarize

=== Description ===
Elastic Unfolding Weave  Input grids feature a central rectangular cut zone (3×3
to 5×5) embedded within a larger background grid (15×15 to 25×25). The cut zone
is a folded representation of a larger area, created by sequentially folding the
grid along horizontal and vertical axes. Each fold causes overlapping paths
(contiguous sequences of cells in a single color) to weave through each other,
with each path's color corresponding to its layer in the folding sequence. The
background color (0) surrounds all elements.  In the output grid, the cut zone
is unfolded to its original size (e.g., a 3×3 folded zone unfolds to a 6×6 zone
if folded twice). During unfolding, each fold is reversed, applying an elastic
reflection: paths crossing a fold line change direction by 90 degrees (e.g.,
moving left becomes moving down), and their color shifts progressively (e.g.,
red → orange → yellow → red... for each fold). The multi-agent path weaving
ensures that paths maintain their over/under relationships at intersections. The
color guessing component requires inferring the color shift cycle from the input
(e.g., a red path that undergoes two reflections becomes yellow). The output
grid summarizes the unfolded paths with colors indicating their reflection
history, omitting background cells.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    bg_size = random.randint(15, 25)
    bg = grid(bg_size, bg_size, 0)
    folded_size = random.randint(3, 5)
    original_size = folded_size * 2
    C = random.randint(1, 9)
    
    # Create original grid with diagonal path
    original = grid(original_size, original_size, 0)
    for i in range(original_size):
        original[i][i] = C
    
    # Apply two folds with color shifts
    folded = grid(folded_size, folded_size, 0)
    for i in range(folded_size):
        for j in range(folded_size):
            folded[i][j] = (C + 2 - 1) % 9 + 1
    
    # Place folded grid in center
    center = (bg_size - folded_size) // 2
    for i in range(folded_size):
        for j in range(folded_size):
            bg[center + i][center + j] = folded[i][j]
    
    # Create output with unfolded grid
    output = grid(bg_size, bg_size, 0)
    for i in range(original_size):
        for j in range(original_size):
            output[center + i][center + j] = original[i][j]
    
    return {
        "input": bg,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    n = len(input_grid)
    # Find actual cut zone diagonal length
    folded_size = 0
    start = None
    for i in range(n):
        if input_grid[i][i] != 0:
            start = i
            break
    if start is None:
        start = 0
    for i in range(start, n):
        if input_grid[i][i] != 0:
            folded_size += 1
        else:
            break
    
    original_size = folded_size * 2
    center = (n - folded_size) // 2
    
    # Get color from diagonal
    color = input_grid[center][center]
    
    # Reverse color shift (2 folds)
    orig_color = (color - 1 - 2) % 9 + 1
    if orig_color == 0:
        orig_color = 9
    
    # Create output grid with diagonal path
    output = grid(n, n, 0)
    for i in range(original_size):
        output[center + i][center + i] = orig_color
    
    return output
