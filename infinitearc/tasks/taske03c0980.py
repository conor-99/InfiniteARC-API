# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: e03c0980
Difficulty: very hard

=== Tags ===
- Periodic offset matching
- Multi condition recolor
- Connect the dots
- Close line gaps

=== Description ===
Input grids are large (20×20 or larger) with a single background color. Overlaid
on this background are multiple disjoint horizontal and vertical line segments,
each composed of consecutive cells of a distinct non-background color. Each line
segment has periodic gaps (missing cells) following a repeating pattern dictated
by a global "period pattern" strip located at the top-left corner of the grid.
The period pattern strip is a horizontal sequence of colors (e.g., red, blue,
green) that defines offset values (e.g., red=0, blue=1, green=2). For a
horizontal line in row *i*, the offset is determined by the color at column *i*
in the period pattern strip (wrapping cyclically if the strip is shorter than
the grid width). For a vertical line in column *j*, the offset is determined by
the color at row *j* in the period pattern strip.   The output grid must fill
all gaps within line segments to make them continuous while adhering to a multi-
condition recolor rule: a gap at position *k* within a line is filled with color
*C* if *k mod period* equals the line's offset; otherwise, it is filled with a
secondary color derived from the line's color and the period pattern's color
(e.g., line color + pattern color modulo 9). Additionally, "connect the dots"
requires linking disconnected line segments by filling gaps between them (not
part of the periodic pattern) with the same multi-condition recolor logic.
"Close line gaps" ensures all gaps—both periodic and non-periodic—are filled
without overwriting existing line segments or the period pattern strip. The
period pattern strip, background, and all line segments remain visible in the
output, with only the gap-filling operations modifying the grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common


def generate():
    """
    Generates a single input/output pair for the described task.
    The grid is large (20x20..30x30). A period pattern strip is placed at the top-left
    (row 0, columns 0..p-1). Multiple disjoint horizontal and vertical fragmented
    line segments are placed elsewhere. Each fragment only contains cells at positions
    where (k % period) == offset. The output fills all gaps between fragments
    (min..max) using the multi-condition recolor rule described in the prompt.
    """
    width = random.randint(20, 30)
    height = random.randint(20, 30)
    bg = 0

    # Create empty grid
    ingrid = common.grid(width, height, bg)

    # Period pattern strip (top-left horizontal)
    period = random.randint(3, 5)
    # choose unique non-background colors for the strip
    strip_colors = random.sample([c for c in range(1, 10)], period)
    for c, col_color in enumerate(strip_colors):
        ingrid[0][c] = col_color

    horizontals = []  # list of tuples (row, start, end, color)

    # Create a few horizontal fragmented segments (one row may have multiple fragments)
    num_h_rows = random.randint(3, 6)
    used_rows = set()
    for _ in range(num_h_rows):
        # pick a row that is not the top strip and not row 1 (leave some spacing)
        tries = 0
        while True:
            tries += 1
            if tries > 400:
                break
            r = random.randint(2, height - 1)
            if r not in used_rows:
                used_rows.add(r)
                break
        # pick a line color distinct from background and strip colors
        line_color = common.random_color(exclude=[bg] + strip_colors)

        # decide how many separate fragments in this row (1..3)
        seg_count = random.randint(1, 3)
        segments = []
        min_len = 6
        max_len = min(18, width - 2)

        # try to place non-overlapping fragments in the row
        attempts = 0
        while len(segments) < seg_count and attempts < 400:
            attempts += 1
            start = random.randint(1, width - min_len - 1)
            length = random.randint(min_len, max_len)
            end = min(start + length, width - 1)
            # ensure no overlap with existing segments in this row
            overlap = False
            for s, e in segments:
                if not (end <= s or start >= e):
                    overlap = True
                    break
            if overlap:
                continue
            segments.append((start, end))

        # If we failed to place anything valid, skip this row
        if not segments:
            continue

        # Fill fragmented pattern: only positions where (k % period) == offset_index get the line color
        offset_index = r % period
        for start, end in segments:
            horizontals.append((r, start, end, line_color))
            for idx, c in enumerate(range(start, end)):
                if (idx % period) == offset_index:
                    ingrid[r][c] = line_color

    # Create vertical fragmented segments that do not intersect existing horizontal fragments
    verticals = []  # list of tuples (col, list_of_segments, color)
    num_v_cols = random.randint(3, 6)
    used_cols = set()
    attempts_col_total = 0
    for _ in range(num_v_cols):
        attempts_col_total += 1
        if attempts_col_total > 1000:
            break
        col = None
        segs = None
        tries_col = 0
        while tries_col < 400:
            tries_col += 1
            c = random.randint(1, width - 1)
            if c in used_cols:
                continue
            # now try to find 1..3 vertical fragments in this column that avoid conflicts
            seg_count = random.randint(1, 3)
            segs_try = []
            min_len_v = 6
            max_len_v = min(18, height - 2)
            tries_seg = 0
            while len(segs_try) < seg_count and tries_seg < 400:
                tries_seg += 1
                start = random.randint(2, height - min_len_v - 1)
                length = random.randint(min_len_v, max_len_v)
                end = min(start + length, height - 1)
                # ensure no overlap with other vertical fragments in same column
                overlap = False
                for s, e in segs_try:
                    if not (end <= s or start >= e):
                        overlap = True
                        break
                if overlap:
                    continue
                # ensure no conflict with horizontal fragments: any horizontal at row h in [start,end) with column c inside its span
                conflict = False
                for hr in horizontals:
                    hr_row, hr_start, hr_end, _ = hr
                    if hr_row >= start and hr_row < end and (c >= hr_start and c < hr_end):
                        conflict = True
                        break
                if conflict:
                    continue
                segs_try.append((start, end))
            if not segs_try:
                continue
            # accept this column
            col = c
            segs = segs_try
            used_cols.add(col)
            break

        if col is None or segs is None:
            continue

        v_color = common.random_color(exclude=[bg] + strip_colors)
        offset_index = col % period
        verticals.append((col, segs, v_color))
        for start, end in segs:
            for idx, r in enumerate(range(start, end)):
                if (idx % period) == offset_index:
                    ingrid[r][col] = v_color

    # Prepare input and output copies
    input_grid = [row[:] for row in ingrid]
    output_grid = [row[:] for row in ingrid]

    # Fill horizontal gaps first (row-wise), using the multi-condition recolor rule
    for r in range(1, height):
        # collect distinct non-bg, non-strip colors on this row
        row_colors = set()
        for c in range(width):
            v = ingrid[r][c]
            if v != bg and v not in strip_colors:
                row_colors.add(v)
        for color in row_colors:
            cols = [c for c in range(width) if ingrid[r][c] == color]
            if not cols:
                continue
            min_col = min(cols)
            max_col = max(cols)
            offset_index = r % period
            offset_color = strip_colors[offset_index]
            for c in range(min_col, max_col + 1):
                if output_grid[r][c] == bg:
                    k = c - min_col
                    if (k % period) == offset_index:
                        output_grid[r][c] = color
                    else:
                        # secondary color derived from line color and the pattern color
                        sec = ((color + offset_color - 1) % 9) + 1
                        output_grid[r][c] = sec

    # Then fill vertical gaps (column-wise)
    for c in range(width):
        col_colors = set()
        for r in range(height):
            v = ingrid[r][c]
            if v != bg and v not in strip_colors:
                col_colors.add(v)
        for color in col_colors:
            rows_list = [r for r in range(height) if ingrid[r][c] == color]
            if not rows_list:
                continue
            min_row = min(rows_list)
            max_row = max(rows_list)
            offset_index = c % period
            offset_color = strip_colors[offset_index]
            for r in range(min_row, max_row + 1):
                if output_grid[r][c] == bg:
                    k = r - min_row
                    if (k % period) == offset_index:
                        output_grid[r][c] = color
                    else:
                        sec = ((color + offset_color - 1) % 9) + 1
                        output_grid[r][c] = sec

    return {
        'input': input_grid,
        'output': output_grid
    }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    """
    Solver that reconstructs the filled grid from the input according to the rules
    used in the generator. It detects the period pattern at row 0 (top-left), then
    fills row-wise (connect fragments and fill periodic/non-periodic gaps) and then
    column-wise, matching the generator ordering to avoid conflicts.
    """
    g = [list(row) for row in input_grid]
    height = len(g)
    width = len(g[0])
    bg = 0

    # detect the period pattern strip length by scanning row 0 from column 0
    strip_length = 0
    while strip_length < width and g[0][strip_length] != bg:
        strip_length += 1
    if strip_length == 0:
        # fallback (shouldn't happen for generator examples) but pick 3
        strip_length = 3

    strip_colors = [g[0][c] for c in range(strip_length)]

    out = [row[:] for row in g]

    # Fill horizontally first (same order as generator)
    for r in range(1, height):
        row_colors = set()
        for c in range(width):
            v = g[r][c]
            if v != bg and v not in strip_colors:
                row_colors.add(v)
        for color in row_colors:
            cols = [c for c in range(width) if g[r][c] == color]
            if not cols:
                continue
            min_col = min(cols)
            max_col = max(cols)
            offset_index = r % strip_length
            offset_color = strip_colors[offset_index]
            for c in range(min_col, max_col + 1):
                if out[r][c] == bg:
                    k = c - min_col
                    if (k % strip_length) == offset_index:
                        out[r][c] = color
                    else:
                        out[r][c] = ((color + offset_color - 1) % 9) + 1

    # Fill vertically next
    for c in range(width):
        col_colors = set()
        for r in range(height):
            v = g[r][c]
            if v != bg and v not in strip_colors:
                col_colors.add(v)
        for color in col_colors:
            rows_list = [r for r in range(height) if g[r][c] == color]
            if not rows_list:
                continue
            min_row = min(rows_list)
            max_row = max(rows_list)
            offset_index = c % strip_length
            offset_color = strip_colors[offset_index]
            for r in range(min_row, max_row + 1):
                if out[r][c] == bg:
                    k = r - min_row
                    if (k % strip_length) == offset_index:
                        out[r][c] = color
                    else:
                        out[r][c] = ((color + offset_color - 1) % 9) + 1

    return tuple(tuple(row) for row in out)

