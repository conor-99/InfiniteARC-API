# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 1dfa93d2
Difficulty: very hard

=== Tags ===
- Pattern alignment
- Color the column with fewest dots

=== Description ===
Input grids feature a dominant background color (the most frequently occurring
color) and non-background regions composed of connected cells (4-directionally
adjacent) forming distinct "dots". For each column, the number of connected dot
regions (not individual cells) is counted. The output grid retains all input
features unchanged except for the entire column containing the smallest number
of connected dot regions, which is recolored using a new color (not present in
the input grid). The new color must be distinct from all colors used in the
input, ensuring no visual overlap with existing elements. This task requires
identifying background color, analyzing connected regions per column, and
applying a column-wide recoloring rule that is not immediately obvious from
simple cell counts. The complexity arises from the need to distinguish between
connected regions versus isolated cells, and the requirement that the solution
must identify the unique column with the minimum connected region count across
all columns, then apply a global transformation to that column without altering
any other grid elements.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common


def generate():
    """
    Generator that builds a grid with a dominant background color and single-column-connected "dots".
    For robustness we place only single-cell segments (connected components of size 1) and ensure
    adjacent columns never occupy the same rows so no component spans multiple columns. One column
    (target_col) is chosen to have strictly fewer components than every other column.
    """
    # Try multiple attempts to produce a valid configuration
    for _ in range(200):
        width = random.randint(5, 12)
        height = random.randint(5, 15)

        # Pick a background color (0..9)
        background = random.randint(0, 9)
        grid = common.grid(width, height, background)

        # Choose a target column that will have the minimum number of connected regions
        target_col = random.randrange(width)
        target_segments = random.choice([0, 1])

        # We'll store the chosen rows (single-cell segments) for each column
        rows_per_column = [set() for _ in range(width)]
        left_occupied = set()  # rows occupied by previous column (to avoid horizontal adjacency)
        total_segments = 0
        ok = True

        for col in range(width):
            # Build intervals of rows that are not blocked by the left neighbor
            intervals = []
            r = 0
            while r < height:
                if r not in left_occupied:
                    s = r
                    while r < height and r not in left_occupied:
                        r += 1
                    e = r - 1
                    intervals.append((s, e))
                else:
                    r += 1

            # From each interval we can pick positions separated by at least one row
            candidates = []
            for (s, e) in intervals:
                if s > e:
                    continue
                # Randomize parity so placements vary
                offset = random.randint(0, 1)
                start = s + offset
                if start > e:
                    start = s
                positions = list(range(start, e + 1, 2))
                if not positions:
                    positions = list(range(s, e + 1, 2))
                candidates.extend(positions)

            max_segments = len(candidates)

            if col == target_col:
                desired = target_segments
                if desired > max_segments:
                    ok = False
                    break
            else:
                min_required = target_segments + 1
                if min_required > max_segments:
                    ok = False
                    break
                # Limit how many segments a column can have (keeps non-background < half the grid)
                upper = min(max_segments, max(min_required, 3))
                desired = random.randint(min_required, upper)

            if desired > max_segments:
                ok = False
                break

            chosen = set()
            if desired > 0:
                # Randomly sample from candidates; candidates are already spaced by >=2 inside an interval
                chosen = set(random.sample(candidates, desired))

            rows_per_column[col] = chosen
            left_occupied = chosen
            total_segments += len(chosen)

        if not ok:
            continue

        # Ensure the number of non-background cells is strictly less than half the grid
        if total_segments * 1 >= (width * height) // 2:
            # Too many non-background cells; try again
            continue

        # Choose a set of colors to use for the dots, but leave at least one color unused
        available_colors = [c for c in range(10) if c != background]
        # Ensure we don't use all available colors so there is always at least one unused color for the recolor
        used_count = random.randint(1, max(1, len(available_colors) - 1))
        used_colors = random.sample(available_colors, used_count)

        # Paint the single-cell components into the grid
        for col in range(width):
            for r in rows_per_column[col]:
                grid[r][col] = random.choice(used_colors)

        # Verify background is the unique most frequent color
        counts = {}
        for row in grid:
            for v in row:
                counts[v] = counts.get(v, 0) + 1

        bg_count = counts.get(background, 0)
        max_count = max(counts.values())
        if bg_count != max_count:
            continue
        if list(counts.values()).count(max_count) != 1:
            continue

        # Pick a new color (deterministically) not present in the input grid: choose the smallest such color
        unused_colors = [c for c in range(10) if c not in counts]
        if not unused_colors:
            # If by chance all colors are used, try again
            continue
        new_color = min(unused_colors)

        # Build the output grid by recoloring the entire target column
        output_grid = [row[:] for row in grid]
        for r in range(height):
            output_grid[r][target_col] = new_color

        return {"input": grid, "output": output_grid}

    # If we fail after many attempts, raise an error (shouldn't happen in practice)
    raise RuntimeError("Failed to generate a valid task after many attempts")



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # Find background color (most frequent)
    counts = {}
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            counts[v] = counts.get(v, 0) + 1
    background = max(counts.items(), key=lambda x: x[1])[0]

    # Label connected components (4-connected) of non-background cells
    comp_id = [[-1] * width for _ in range(height)]
    comp_columns = []  # list of sets: which columns each component touches
    comp_index = 0

    for r in range(height):
        for c in range(width):
            if grid[r][c] != background and comp_id[r][c] == -1:
                # BFS to mark this component
                q = deque()
                q.append((r, c))
                comp_id[r][c] = comp_index
                cols = {c}
                while q:
                    rr, cc = q.popleft()
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = rr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width:
                            if grid[nr][nc] != background and comp_id[nr][nc] == -1:
                                comp_id[nr][nc] = comp_index
                                cols.add(nc)
                                q.append((nr, nc))
                comp_columns.append(cols)
                comp_index += 1

    # Count how many distinct components intersect each column
    col_counts = [0] * width
    for cols in comp_columns:
        for col in cols:
            col_counts[col] += 1

    # If there are no components, all counts are zero; choose the first column as the target
    if width == 0:
        return tuple(tuple(row) for row in grid)

    min_count = min(col_counts)
    target_col = col_counts.index(min_count)

    # Find a new color not present in the input
    used = set()
    for row in grid:
        for v in row:
            used.add(v)
    new_color = None
    for c in range(10):
        if c not in used:
            new_color = c
            break
    # (Generator guarantees at least one unused color exists.)
    if new_color is None:
        # As a fallback (should not be needed), pick a color different from used by cycling
        new_color = 0
        while new_color in used:
            new_color = (new_color + 1) % 10

    # Recolor the entire target column
    output = [row[:] for row in grid]
    for r in range(height):
        output[r][target_col] = new_color

    return tuple(tuple(row) for row in output)

