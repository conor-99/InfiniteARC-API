# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: b4ab9690
Difficulty: hard

=== Tags ===
- Alternating agents
- Color by distance to edge
- Find shape in negative space

=== Description ===
Input grids consist of a uniform background color (0) with irregular foreground
shapes (non-zero colors) arranged to enclose a distinct, closed negative space
shape within the grid. The negative space shape is formed by contiguous
background cells that form a recognizable silhouette, such as a letter,
geometric figure, or simple organic form, surrounded by foreground elements.
The transformation to the output grid follows three key rules:  1. **Color by
distance to edge**: Each cell is recolored based on its minimum Manhattan
distance to the grid's boundary (top, bottom, left, right), alternating between
two fixed colors (e.g., color 1 for even distances, color 2 for odd distances).
2. **Alternating agents**: The foreground shapes are interpreted as "agents"
whose positions define the negative space boundary, with their arrangement
causing the distance-based coloring to alternate in a non-linear pattern across
the grid.  3. **Find shape in negative space**: The boundary of the enclosed
negative space shape is identified and recolored with a distinct third color
(e.g., color 5), overriding the distance-based coloring for all cells forming
the shape's outline. This boundary is determined by cells adjacent to both
foreground (non-zero) and background (0) cells.   The output grid thus displays
a visually distinct pattern where the negative space shape is clearly outlined,
while the rest of the grid shows alternating color bands radiating from the
edges, with the foreground elements effectively erased to reveal the underlying
shape.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import hollow_conway

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = [[0] * width for _ in range(height)]
    
    # Ensure spr_width/spr_height are at least 3
    spr_width = random.randint(3, max(3, min(width - 4, 10)))
    spr_height = random.randint(3, max(3, min(height - 4, 10)))
    rows, cols = hollow_conway(spr_width, spr_height, tries=random.randint(2, 5))
    
    color = random.randint(1, 9)
    for r, c in zip(rows, cols):
        if 2 <= r + 2 < height and 2 <= c + 2 < width:
            input_grid[r + 2][c + 2] = color
    
    visited = [[False] * width for _ in range(height)]
    edges = []
    for c in range(width):
        edges.append((0, c))
        edges.append((height-1, c))
    for r in range(height):
        edges.append((r, 0))
        edges.append((r, width-1))
    
    from collections import deque
    queue = deque()
    for r, c in edges:
        if input_grid[r][c] == 0 and not visited[r][c]:
            visited[r][c] = True
            queue.append((r, c))
    
    while queue:
        r, c = queue.popleft()
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == 0:
                visited[nr][nc] = True
                queue.append((nr, nc))
    
    boundary = set()
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0 and not visited[r][c]:
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0:
                        boundary.add((r, c))
                        break
    
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if (r, c) in boundary:
                output_grid[r][c] = 5
            else:
                d = min(r, height - 1 - r, c, width - 1 - c)
                output_grid[r][c] = 1 if d % 2 == 0 else 2
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    
    visited = [[False] * width for _ in range(height)]
    edges = []
    for c in range(width):
        edges.append((0, c))
        edges.append((height-1, c))
    for r in range(height):
        edges.append((r, 0))
        edges.append((r, width-1))
    
    queue = deque()
    for r, c in edges:
        if input_grid[r][c] == 0 and not visited[r][c]:
            visited[r][c] = True
            queue.append((r, c))
    
    while queue:
        r, c = queue.popleft()
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == 0:
                visited[nr][nc] = True
                queue.append((nr, nc))
    
    boundary = set()
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0 and not visited[r][c]:
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0:
                        boundary.add((r, c))
                        break
    
    output = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if (r, c) in boundary:
                output[r][c] = 5
            else:
                d = min(r, height - 1 - r, c, width - 1 - c)
                output[r][c] = 1 if d % 2 == 0 else 2
    
    return tuple(tuple(row) for row in output)
