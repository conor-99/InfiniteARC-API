# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 47551aa8
Difficulty: very hard

=== Tags ===
- Zigzag path
- Line collision
- Echo trail
- Reflect across detected axis
- Copy object and apply one change

=== Description ===
Input grids feature a continuous zigzag path composed of a single color (e.g.,
color 5) that alternates between right and left movements at each step, forming
a symmetric wave-like pattern. The path is symmetric along a vertical axis,
which can be determined by finding the vertical line that mirrors the left and
right sides of the path. Overlaid on the background (color 0), there are
multiple straight-line segments (color 2) moving toward the zigzag path. Each
line segment moves in a consistent direction (horizontal or vertical) until it
collides with the zigzag path.  Upon collision, the line segment is reflected
across the detected vertical axis of symmetry. The reflected segment is then
drawn as a new "echo trail" using a distinct color (color 6), positioned such
that it mirrors the original segment's location relative to the axis. The
original line segment is removed from the grid (as it has been reflected), and
the echo trail is added to the background. The zigzag path and all other grid
elements remain unchanged.  The output grid is identical to the input except for
the addition of these echo trails at collision points. Each collision results in
exactly one echo trail, and no two echo trails overlap or interfere with each
other. The axis of reflection is uniquely determined by the symmetry of the
zigzag path, and the echo trails must be accurately reflected across this axis.
To increase difficulty, the zigzag path may be positioned such that the axis is
not immediately obvious (e.g., the path spans a non-symmetric area, but the
symmetry is only visible when considering the entire path), and multiple line
segments may collide at different points, requiring the solver to correctly
identify the axis and apply the reflection to each collision individually.
Additionally, the echo trails must be drawn without overlapping existing path
elements or altering the original grid structure beyond the reflected segments.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = random.randint(15, 30)
    height = random.randint(15, 30)
    grid = common.grid(width, height, 0)
    
    mid = random.randint(5, width - 6)
    
    left_path = []
    r, c = 0, mid - 2
    while r < height - 2:
        for _ in range(random.randint(2, 4)):
            if c < mid - 1:
                left_path.append((r, c))
                c += 1
        r += 1
        for _ in range(random.randint(2, 4)):
            if c > mid - 2:
                left_path.append((r, c))
                c -= 1
        r += 1
    right_path = [(r, 2 * mid - c) for (r, c) in left_path]
    path_points = left_path + right_path
    for (r, c) in path_points:
        if 0 <= r < height and 0 <= c < width:
            grid[r][c] = 5
    
    line_segments = []
    for _ in range(random.randint(3, 5)):
        direction = random.choice(['h', 'v'])
        r_start = random.randint(0, height - 1)
        c_start = random.randint(0, mid - 3)
        length = random.randint(2, 4)
        if direction == 'h':
            segment = []
            for c in range(c_start, c_start + length):
                if c < mid - 1:
                    segment.append((r_start, c))
            if segment:
                line_segments.append(segment)
                for (r, c) in segment:
                    if 0 <= r < height and 0 <= c < width:
                        grid[r][c] = 2
        else:
            segment = []
            for r in range(r_start, r_start + length):
                if r < height - 1 and c_start < mid - 1:
                    segment.append((r, c_start))
            if segment:
                line_segments.append(segment)
                for (r, c) in segment:
                    if 0 <= r < height and 0 <= c < width:
                        grid[r][c] = 2
    
    output_grid = [row[:] for row in grid]
    for segment in line_segments:
        reflected_segment = [(r, 2 * mid - c) for (r, c) in segment]
        for (r, c) in reflected_segment:
            if 0 <= r < height and 0 <= c < width and output_grid[r][c] == 0:
                output_grid[r][c] = 6
        for (r, c) in segment:
            if 0 <= r < height and 0 <= c < width:
                output_grid[r][c] = 0
    
    return {
        'input': grid,
        'output': output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    path_points = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 5:
                path_points.append((r, c))
    
    if not path_points:
        return input_grid
    
    leftmost = min(c for r, c in path_points)
    rightmost = max(c for r, c in path_points)
    mid = (leftmost + rightmost) // 2
    
    visited = [[False] * width for _ in range(height)]
    line_segments = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 2 and not visited[r][c]:
                segment = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    segment.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 2 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                line_segments.append(segment)
    
    output_grid = [row[:] for row in grid]
    for segment in line_segments:
        reflected_segment = [(r, 2 * mid - c) for (r, c) in segment]
        for (r, c) in reflected_segment:
            if 0 <= r < height and 0 <= c < width and output_grid[r][c] == 0:
                output_grid[r][c] = 6
        for (r, c) in segment:
            if 0 <= r < height and 0 <= c < width:
                output_grid[r][c] = 0
    
    return output_grid
