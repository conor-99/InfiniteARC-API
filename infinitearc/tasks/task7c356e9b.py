# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 7c356e9b
Difficulty: medium–hard

=== Tags ===
- Alternating rule composition
- Recursive path tracing

=== Description ===
Input grids are composed of a single background color (0) with a starting
token—a small colored square (non-zero color) positioned on the left edge,
facing right. Scattered across the grid are multiple distinct colored cells
(each a unique non-background color), arranged such that the token’s path will
encounter them sequentially without overlapping. The grid dimensions are at
least 10×10, with no walls or obstacles blocking the path.   The output grid
reproduces the input’s structure but adds a continuous path traced from the
token’s starting position. The path begins moving east (right) through
background cells. Each time the path encounters a colored cell (not the
background), the direction alternates between a 90° left turn and a 90° right
turn (starting with a left turn on the first encounter), and the path’s drawing
color switches to the color of the encountered cell for all subsequent cells
until the next encounter. The path continues in the new direction until exiting
the grid. The path is drawn exclusively over background cells, preserving all
input elements (token, colored cells, background), with no overwriting of non-
background regions. The sequence of turns and color switches creates a visually
recursive pattern where each segment’s direction and color depend on the prior
segment’s interaction with a colored cell, requiring the solver to track both
the alternating direction rule and the color-mapping rule in sequence.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Create a grid and place a left-edge token and a sequence of distinct colored triggers
    # Build a monotonic east->north zigzag path so turns alternate left/right starting with left.
    for attempt in range(200):
        W = random.randint(12, 25)
        H = random.randint(12, 25)
        # number of triggers (distinct colored cells encountered)
        n = random.randint(2, 4)

        # Determine a fixed vertical step size for simplicity (1 or 2)
        vert_step = random.choice([1, 2])
        req_vert = (n // 2) * vert_step

        # Choose a feasible start row that allows the required upward movements
        min_start = req_vert + 1
        max_start = H - 3
        if min_start > max_start:
            continue
        start_row = random.randint(min_start, max_start)

        token_color = random.randint(1, 9)
        # Choose n distinct trigger colors different from token color
        available = [c for c in range(1, 10) if c != token_color]
        if len(available) < n:
            continue
        trigger_colors = random.sample(available, n)

        # We'll build triggers by alternating horizontal (east) and vertical (north) segments
        curr_r, curr_c = start_row, 0
        curr_dir = (0, 1)  # start moving east
        triggers = []
        # Count how many horizontal segments remain to reserve space
        total_horiz = (n + 1) // 2
        horiz_used = 0
        ok = True

        for i in range(n):
            dr, dc = curr_dir
            if dr == 0 and dc == 1:
                # horizontal east segment: pick length ensuring future horizontals still fit
                remaining_horiz = total_horiz - horiz_used - 1
                min_d = 2
                # Reserve 2 cells for each remaining horizontal segment
                max_d = W - curr_c - 2 - remaining_horiz * 2
                if max_d < min_d:
                    ok = False
                    break
                d = random.randint(min_d, max_d)
                new_r, new_c = curr_r, curr_c + d
                horiz_used += 1
            else:
                # vertical north segment
                min_d = vert_step
                max_d = curr_r - 1  # must stay >= 0 after moving
                if max_d < min_d:
                    ok = False
                    break
                d = vert_step
                new_r, new_c = curr_r - d, curr_c

            # record trigger location
            triggers.append((new_r, new_c))

            # update position and direction: turns alternate left, right starting with left
            # compute turn: even-indexed encounter -> left, odd -> right
            if i % 2 == 0:
                # left turn
                nd = (-dc, dr)
            else:
                # right turn
                nd = (dc, -dr)
            curr_r, curr_c = new_r, new_c
            curr_dir = nd

        if not ok:
            continue

        # After creating triggers, build the input grid and then draw the path to produce output
        grid = [[0 for _ in range(W)] for _ in range(H)]
        grid[start_row][0] = token_color
        for (r, c), col in zip(triggers, trigger_colors):
            # Safety check: don't overwrite token
            if (r, c) == (start_row, 0):
                ok = False
                break
            grid[r][c] = col
        if not ok:
            continue

        # Now draw the path on a copy of the grid following the rules
        output = [row[:] for row in grid]
        cur_r, cur_c = start_row, 0
        dr, dc = (0, 1)
        cur_color = token_color
        turn_count = 0

        while True:
            nr, nc = cur_r + dr, cur_c + dc
            if not (0 <= nr < H and 0 <= nc < W):
                break
            if grid[nr][nc] != 0:
                # encountered a colored cell: switch drawing color and turn
                cur_color = grid[nr][nc]
                # apply alternating turns: left on first encounter
                if turn_count % 2 == 0:
                    dr, dc = (-dc, dr)
                else:
                    dr, dc = (dc, -dr)
                turn_count += 1
                cur_r, cur_c = nr, nc
                continue
            # draw on background only
            output[nr][nc] = cur_color
            cur_r, cur_c = nr, nc

        # Ensure input != output
        if grid == output:
            continue

        return {"input": grid, "output": output}

    # Fallback deterministic small example if generation fails after attempts
    W, H = 12, 12
    grid = [[0]*W for _ in range(H)]
    start_row = H - 4
    token_color = 1
    grid[start_row][0] = token_color
    triggers = [(start_row, 4), (start_row-2, 7), (start_row-2, 10)]
    colors = [2,3,4]
    for (r,c),col in zip(triggers, colors):
        grid[r][c] = col
    output = [row[:] for row in grid]
    cur_r, cur_c = start_row, 0
    dr, dc = (0,1)
    cur_color = token_color
    turn_count = 0
    while True:
        nr, nc = cur_r + dr, cur_c + dc
        if not (0 <= nr < H and 0 <= nc < W): break
        if grid[nr][nc] != 0:
            cur_color = grid[nr][nc]
            if turn_count % 2 == 0:
                dr, dc = (-dc, dr)
            else:
                dr, dc = (dc, -dr)
            turn_count += 1
            cur_r, cur_c = nr, nc
            continue
        output[nr][nc] = cur_color
        cur_r, cur_c = nr, nc
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0])

    # Find the start token on the left edge (first non-zero in column 0)
    start_row = None
    for r in range(H):
        if grid[r][0] != 0:
            start_row = r
            break
    if start_row is None:
        # No token found; return unchanged
        return grid

    token_color = grid[start_row][0]
    output = [row[:] for row in grid]

    cur_r, cur_c = start_row, 0
    dr, dc = (0, 1)  # start moving east
    cur_color = token_color
    turn_count = 0

    while True:
        nr, nc = cur_r + dr, cur_c + dc
        if not (0 <= nr < H and 0 <= nc < W):
            break
        if grid[nr][nc] != 0:
            # encounter a colored cell: switch drawing color and turn (alternate L/R starting with left)
            cur_color = grid[nr][nc]
            if turn_count % 2 == 0:
                dr, dc = (-dc, dr)
            else:
                dr, dc = (dc, -dr)
            turn_count += 1
            cur_r, cur_c = nr, nc
            continue
        # draw on background only
        output[nr][nc] = cur_color
        cur_r, cur_c = nr, nc

    return output
