# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 0d78fd3c
Difficulty: hard

=== Tags ===
- Neighbor color sum modulo n
- Maze
- Obstacles
- Occlusion reasoning

=== Description ===
The task involves transforming a grid where certain cells are occluded (color
0), while others form a maze with obstacles (color 1) and path segments (color
2). The output grid reveals occluded cells by computing, for each occluded cell,
the sum of its four orthogonal neighbors' colors (ignoring occluded neighbors,
i.e., color 0) modulo 3, then setting the cell's color to this result. Non-
occluded cells remain unchanged. The maze structure features intricate paths,
dead ends, and obstacles arranged to obscure the solution, requiring the solver
to infer hidden regions through consistent neighbor analysis. Occlusions are
strategically placed across the grid, demanding multi-step reasoning to apply
the neighbor sum modulo 3 rule correctly, especially in regions where multiple
occluded cells interact with visible maze elements. The challenge lies in
distinguishing visible neighbors from occluded ones and accurately applying the
modulo operation without error, despite the visual complexity of the maze.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
def generate():
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    grid = [[2] * width for _ in range(height)]
    
    obstacle_count = int(width * height * 0.3)
    for _ in range(obstacle_count):
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        grid[r][c] = 1
    
    occlusion_count = int(width * height * 0.2)
    occlusions = []
    for _ in range(occlusion_count):
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        has_nonzero_neighbor = False
        for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                has_nonzero_neighbor = True
                break
        if has_nonzero_neighbor:
            grid[r][c] = 0
            occlusions.append((r, c))
    
    all_zero = True
    for (r, c) in occlusions:
        total = 0
        for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                total += grid[nr][nc]
        if total % 3 != 0:
            all_zero = False
            break
    
    if all_zero:
        for (r, c) in occlusions:
            for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                    grid[nr][nc] = 1 if grid[nr][nc] == 2 else 2
                    total = 0
                    for dr2, dc2 in [(0,1), (0,-1), (1,0), (-1,0)]:
                        nr2, nc2 = r + dr2, c + dc2
                        if 0 <= nr2 < height and 0 <= nc2 < width and grid[nr2][nc2] != 0:
                            total += grid[nr2][nc2]
                    if total % 3 != 0:
                        break
            else:
                continue
            break
    
    output_grid = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0:
                total = 0
                for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                        total += grid[nr][nc]
                output_grid[r][c] = total % 3
    
    return {"input": grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid[0], tuple):
        input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    output = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                total = 0
                for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0:
                        total += input_grid[nr][nc]
                output[r][c] = total % 3
    return output
