# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 8b3c6c40
Difficulty: mediumâ€“hard

=== Tags ===
- Maze wave
- Portals

=== Description ===
Input grids feature a maze-like structure composed of walls (solid color 1),
open paths (background color 0), and portal pairs. Portals consist of exactly
two cells sharing a unique non-wall, non-background color (e.g., color 5),
forming bidirectional teleportation connections. The maze always contains a
designated start point at the top-left corner (cell (0,0)), which is guaranteed
to be an open path cell (color 0). The wave originates from this start point and
propagates through adjacent open path cells in four cardinal directions, marking
visited cells. When the wave encounters a portal cell, it immediately teleports
to the paired portal cell of the same color and continues propagation from
there. Walls block propagation and remain untraversable.   The output grid
preserves all walls (color 1) and portals (original color) exactly as in the
input. All other cells that were part of the wave's path (i.e., reachable
through propagation and portal teleportation) are recolored to a distinct wave
color (e.g., color 7), while background cells not traversed by the wave remain
unchanged. The transformation requires simulating wave propagation with
bidirectional portal teleportation, ensuring correct path marking without
altering portal identities.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
from collections import deque
import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid_input = common.grid(width, height, 0)
    
    # Place walls
    num_walls = random.randint(8, 20)
    for _ in range(num_walls):
        if random.randint(0, 1):
            row = random.randint(0, height-1)
            start_col = random.randint(0, width-3)
            length = random.randint(1, 3)
            for col in range(start_col, start_col + length):
                grid_input[row][col] = 1
        else:
            col = random.randint(0, width-1)
            start_row = random.randint(0, height-3)
            length = random.randint(1, 3)
            for row in range(start_row, start_row + length):
                grid_input[row][col] = 1
    
    # Place portals
    portal_colors = []
    num_portals = random.randint(2, 4)
    for _ in range(num_portals):
        color = random.randint(5, 9)
        while color in portal_colors:
            color = random.randint(5, 9)
        portal_colors.append(color)
        pos1 = None
        pos2 = None
        attempts = 0
        while attempts < 100:
            r1, c1 = random.randint(0, height-1), random.randint(0, width-1)
            if grid_input[r1][c1] != 0 or (r1, c1) == (0, 0):
                attempts += 1
                continue
            near_wall = False
            for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                r2, c2 = r1 + dr, c1 + dc
                if 0 <= r2 < height and 0 <= c2 < width and grid_input[r2][c2] == 1:
                    near_wall = True
                    break
            if near_wall:
                attempts += 1
                continue
            pos1 = (r1, c1)
            break
        if pos1 is None:
            pos1 = (1, 1)
        attempts = 0
        while attempts < 100:
            r2, c2 = random.randint(0, height-1), random.randint(0, width-1)
            if (r2, c2) == pos1 or grid_input[r2][c2] != 0 or (r2, c2) == (0, 0):
                attempts += 1
                continue
            near_wall = False
            for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                r3, c3 = r2 + dr, c2 + dc
                if 0 <= r3 < height and 0 <= c3 < width and grid_input[r3][c3] == 1:
                    near_wall = True
                    break
            if near_wall:
                attempts += 1
                continue
            pos2 = (r2, c2)
            break
        if pos2 is None:
            pos2 = (1, 2)
        grid_input[pos1[0]][pos1[1]] = color
        grid_input[pos2[0]][pos2[1]] = color
    
    # Ensure start is open
    grid_input[0][0] = 0
    
    # BFS for path
    visited = set()
    queue = deque()
    queue.append((0, 0))
    visited.add((0, 0))
    portal_map = {}
    
    for r in range(height):
        for c in range(width):
            color_val = grid_input[r][c]
            if color_val != 0 and color_val != 1:
                if color_val not in portal_map:
                    portal_map[color_val] = []
                portal_map[color_val].append((r, c))
    
    while queue:
        r, c = queue.popleft()
        color_val = grid_input[r][c]
        if color_val != 0 and color_val != 1:
            pair = portal_map[color_val]
            if len(pair) == 2:
                r2, c2 = pair[0] if (r, c) == pair[1] else pair[1]
                if (r2, c2) not in visited:
                    visited.add((r2, c2))
                    queue.append((r2, c2))
        else:
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    if (nr, nc) not in visited and grid_input[nr][nc] != 1:
                        visited.add((nr, nc))
                        queue.append((nr, nc))
    
    # Build output
    grid_output = [[0]*width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if grid_input[r][c] == 1:
                grid_output[r][c] = 1
            elif grid_input[r][c] != 0 and grid_input[r][c] != 1:
                grid_output[r][c] = grid_input[r][c]
            else:
                grid_output[r][c] = 7 if (r, c) in visited else 0
    
    return {
        "input": grid_input,
        "output": grid_output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
from collections import deque

def p(input_grid):
    grid_input = [list(row) for row in input_grid]
    width = len(grid_input[0])
    height = len(grid_input)
    
    # BFS for path
    visited = set()
    queue = deque()
    queue.append((0, 0))
    visited.add((0, 0))
    portal_map = {}
    
    for r in range(height):
        for c in range(width):
            color_val = grid_input[r][c]
            if color_val != 0 and color_val != 1:
                if color_val not in portal_map:
                    portal_map[color_val] = []
                portal_map[color_val].append((r, c))
    
    while queue:
        r, c = queue.popleft()
        color_val = grid_input[r][c]
        if color_val != 0 and color_val != 1:
            pair = portal_map[color_val]
            if len(pair) == 2:
                r2, c2 = pair[0] if (r, c) == pair[1] else pair[1]
                if (r2, c2) not in visited:
                    visited.add((r2, c2))
                    queue.append((r2, c2))
        else:
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    if (nr, nc) not in visited and grid_input[nr][nc] != 1:
                        visited.add((nr, nc))
                        queue.append((nr, nc))
    
    # Build output
    grid_output = [[0]*width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if grid_input[r][c] == 1:
                grid_output[r][c] = 1
            elif grid_input[r][c] != 0 and grid_input[r][c] != 1:
                grid_output[r][c] = grid_input[r][c]
            else:
                grid_output[r][c] = 7 if (r, c) in visited else 0
    
    return tuple(tuple(row) for row in grid_output)
