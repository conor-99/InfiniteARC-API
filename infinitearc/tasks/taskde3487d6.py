# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: de3487d6
Difficulty: very hard

=== Tags ===
- Pattern to sequence mapping
- Coordinate warp
- Tile mutation rule
- Elastic reflection
- Encircle all pixels of one color
- Isolate largest component

=== Description ===
The task requires identifying the largest connected component (by pixel count)
of a single color in the input grid. The output grid must encircle this
component with a border that adheres to three interdependent rules: (1) the
border's color follows a fixed visual transformation sequence (e.g., color 1
becomes 2, 2 becomes 3, etc., modulo 10), (2) the border's shape applies an
elastic reflection principleâ€”concave sections of the component's outline are
replaced with convex bulges to create a smooth, uniformly thick perimeter, and
(3) the border isolates the component by filling all adjacent background pixels
without gaps. The transformation must be applied without altering the
component's internal structure or other colors, and the elastic reflection
ensures the border adapts to the component's most extended points while ignoring
minor indentations. The solver must deduce both the component's identification,
the color transformation sequence, and the elastic reflection behavior from a
minimal set of examples, requiring multi-step reasoning across visual patterns
and spatial relationships.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

from common import grid, randint, continuous_creature, random_colors
import random

# Morphological helpers operating on boolean masks

def dilate_bool(mask, radius=1):
    h = len(mask)
    w = len(mask[0])
    result = [row[:] for row in mask]
    for _ in range(radius):
        new = [[False] * w for _ in range(h)]
        for r in range(h):
            for c in range(w):
                if result[r][c]:
                    for dr in (-1, 0, 1):
                        for dc in (-1, 0, 1):
                            rr, cc = r + dr, c + dc
                            if 0 <= rr < h and 0 <= cc < w:
                                new[rr][cc] = True
        result = new
    return result


def erode_bool(mask, radius=1):
    h = len(mask)
    w = len(mask[0])
    result = [row[:] for row in mask]
    for _ in range(radius):
        new = [[False] * w for _ in range(h)]
        for r in range(h):
            for c in range(w):
                # keep only if all neighbors (8-neighborhood including self) are True
                ok = True
                for dr in (-1, 0, 1):
                    for dc in (-1, 0, 1):
                        rr, cc = r + dr, c + dc
                        if not (0 <= rr < h and 0 <= cc < w and result[rr][cc]):
                            ok = False
                            break
                    if not ok:
                        break
                if ok:
                    new[r][c] = True
        result = new
    return result


def closing(mask, radius):
    return erode_bool(dilate_bool(mask, radius), radius)


# Helpers to place sprites into the grid without overlap (with a buffer)

def can_place(occupied, sprite, offset_r, offset_c, buffer):
    h = len(occupied)
    w = len(occupied[0])
    for (pr, pc) in sprite:
        rr = pr + offset_r
        cc = pc + offset_c
        if not (0 <= rr < h and 0 <= cc < w):
            return False
        # check buffer box around every target cell
        r0 = max(0, rr - buffer)
        r1 = min(h - 1, rr + buffer)
        c0 = max(0, cc - buffer)
        c1 = min(w - 1, cc + buffer)
        for r in range(r0, r1 + 1):
            for c in range(c0, c1 + 1):
                if occupied[r][c]:
                    return False
    return True


def place_sprite_on_grid(grid_in, occupied, sprite, offset_r, offset_c, color):
    for (pr, pc) in sprite:
        rr = pr + offset_r
        cc = pc + offset_c
        grid_in[rr][cc] = color
        occupied[rr][cc] = True


def generate():
    # We pick a reasonably sized grid to allow multiple non-overlapping components
    for attempt in range(200):
        width = randint(12, 20)
        height = randint(12, 20)
        grid_input = grid(width, height, 0)
        occupied = [[False] * width for _ in range(height)]

        # number of components: between 2 and 5 (bounded by grid size)
        max_comps = min(5, max(2, (width * height) // 120 + 2))
        num_components = randint(2, max_comps)
        colors = random_colors(num_components)
        random.shuffle(colors)

        placed_components = []
        buffer = 2

        for idx, color in enumerate(colors):
            placed = False
            # try multiple attempts to place a contiguous sprite of this color
            for _try in range(60):
                # a sprite box to generate a contiguous creature inside
                if idx == 0:
                    # make the first (target largest) sprite somewhat larger
                    max_box_w = max(4, min(10, width - 2 * buffer))
                    max_box_h = max(4, min(10, height - 2 * buffer))
                    box_w = randint(4, max_box_w)
                    box_h = randint(4, max_box_h)
                else:
                    max_box_w = max(3, min(8, width - 2 * buffer))
                    max_box_h = max(3, min(8, height - 2 * buffer))
                    box_w = randint(3, max_box_w)
                    box_h = randint(3, max_box_h)
                max_size = box_w * box_h
                if idx == 0:
                    size = randint(max(6, int(max_size * 0.6)), max_size)
                else:
                    size = randint(max(3, max_size // 6), max(4, max_size // 3))
                sprite = continuous_creature(size, box_w, box_h)
                off_r = randint(buffer, height - box_h - buffer)
                off_c = randint(buffer, width - box_w - buffer)
                if can_place(occupied, sprite, off_r, off_c, buffer):
                    place_sprite_on_grid(grid_input, occupied, sprite, off_r, off_c, color)
                    abs_pixels = [(pr + off_r, pc + off_c) for (pr, pc) in sprite]
                    placed_components.append({"color": color, "pixels": abs_pixels})
                    placed = True
                    break
            # continue to next color (may skip if couldn't place)

        if len(placed_components) < 2:
            # retry a new random layout
            continue

        # ensure the largest component is unique; if tie, retry
        sizes = [len(c["pixels"]) for c in placed_components]
        largest_size = max(sizes)
        if sizes.count(largest_size) > 1:
            continue

        # select the largest connected placed component
        largest = max(placed_components, key=lambda x: len(x["pixels"]))
        largest_color = largest["color"]
        largest_pixels = largest["pixels"]

        # build boolean mask for the largest component
        h = height
        w = width
        original_mask = [[False] * w for _ in range(h)]
        for r, c in largest_pixels:
            original_mask[r][c] = True

        # bounding box to decide structural radius for closing (elastic reflection)
        rows = [p[0] for p in largest_pixels]
        cols = [p[1] for p in largest_pixels]
        min_row, max_row = min(rows), max(rows)
        min_col, max_col = min(cols), max(cols)
        max_dim = max(max_row - min_row + 1, max_col - min_col + 1)
        struct_radius = 2 if max_dim >= 9 else 1

        # perform closing to smooth concavities (elastic reflection approximation)
        smoothed = closing(original_mask, struct_radius)

        # create a one-pixel outer ring around the smoothed shape
        dilated_smoothed = dilate_bool(smoothed, 1)
        border_mask = [[dilated_smoothed[r][c] and (not smoothed[r][c]) for c in range(w)] for r in range(h)]

        # border color: next color in cycle 1..9 (avoid 0 background)
        border_color = (largest_color % 9) + 1

        # produce output by overlaying border only onto background pixels (color 0)
        grid_output = [row[:] for row in grid_input]
        applied = False
        for r in range(h):
            for c in range(w):
                if border_mask[r][c] and grid_input[r][c] == 0:
                    grid_output[r][c] = border_color
                    applied = True

        # ensure we actually changed the grid (i.e., border applied). If not, retry.
        if not applied:
            continue

        return {"input": grid_input, "output": grid_output}

    # fallback (very unlikely)
    width = 12
    height = 12
    grid_input = grid(width, height, 0)
    sprite = continuous_creature(10, 5, 5)
    occupied = [[False] * width for _ in range(height)]
    place_sprite_on_grid(grid_input, occupied, sprite, 3, 3, 1)
    grid_output = [row[:] for row in grid_input]
    for r in range(2, 10):
        grid_output[2][r] = 2
        grid_output[9][r] = 2
    for r in range(2, 10):
        grid_output[r][2] = 2
        grid_output[r][9] = 2
    return {"input": grid_input, "output": grid_output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # find all 4-connected components (non-zero colors)
    visited = [[False] * width for _ in range(height)]
    components = []

    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 or visited[r][c]:
                continue
            color = grid[r][c]
            stack = [(r, c)]
            visited[r][c] = True
            pixels = []
            while stack:
                cr, cc = stack.pop()
                pixels.append((cr, cc))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            components.append({"color": color, "pixels": pixels})

    if not components:
        return tuple(tuple(row) for row in grid)

    # choose the largest component by pixel count
    largest = max(components, key=lambda x: len(x["pixels"]))
    largest_color = largest["color"]
    largest_pixels = largest["pixels"]

    # bounding box
    rows = [p[0] for p in largest_pixels]
    cols = [p[1] for p in largest_pixels]
    min_row, max_row = min(rows), max(rows)
    min_col, max_col = min(cols), max(cols)
    max_dim = max(max_row - min_row + 1, max_col - min_col + 1)

    # structural radius decision must match the generator
    struct_radius = 2 if max_dim >= 9 else 1

    # morphological helpers (same logic as generator)
    def dilate_bool(mask, radius=1):
        h = len(mask)
        w = len(mask[0])
        result = [row[:] for row in mask]
        for _ in range(radius):
            new = [[False] * w for _ in range(h)]
            for r in range(h):
                for c in range(w):
                    if result[r][c]:
                        for dr in (-1, 0, 1):
                            for dc in (-1, 0, 1):
                                rr, cc = r + dr, c + dc
                                if 0 <= rr < h and 0 <= cc < w:
                                    new[rr][cc] = True
            result = new
        return result

    def erode_bool(mask, radius=1):
        h = len(mask)
        w = len(mask[0])
        result = [row[:] for row in mask]
        for _ in range(radius):
            new = [[False] * w for _ in range(h)]
            for r in range(h):
                for c in range(w):
                    ok = True
                    for dr in (-1, 0, 1):
                        for dc in (-1, 0, 1):
                            rr, cc = r + dr, c + dc
                            if not (0 <= rr < h and 0 <= cc < w and result[rr][cc]):
                                ok = False
                                break
                        if not ok:
                            break
                    if ok:
                        new[r][c] = True
            result = new
        return result

    def closing(mask, radius):
        return erode_bool(dilate_bool(mask, radius), radius)

    # build original mask for the largest component
    original_mask = [[False] * width for _ in range(height)]
    for r, c in largest_pixels:
        original_mask[r][c] = True

    # smooth concavities (elastic reflection approximation)
    smoothed = closing(original_mask, struct_radius)

    # outer ring around smoothed mask
    dilated_smoothed = dilate_bool(smoothed, 1)
    border_mask = [[dilated_smoothed[r][c] and (not smoothed[r][c]) for c in range(width)] for r in range(height)]

    # border color mapping (same as generator): next in 1..9 cycle
    border_color = (largest_color % 9) + 1

    output = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if border_mask[r][c] and grid[r][c] == 0:
                output[r][c] = border_color

    return tuple(tuple(row) for row in output)

