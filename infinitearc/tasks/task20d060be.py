# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 20d060be
Difficulty: hard

=== Tags ===
- Pattern to sequence mapping
- Pattern modification
- Multi source interaction
- Heat map draw
- Row parity coloring

=== Description ===
Input grids contain overlapping geometric patterns (e.g., horizontal stripes,
diagonal lines, and circular motifs) rendered in distinct colors. Each pattern’s
visual properties are defined by position, orientation, and color, with no
numerical values encoded. The output grid transforms these inputs into a heat
map where color intensity at each cell represents the combined influence of all
intersecting patterns through visual blending. Key operations include: (1)
**Pattern modification**—overlapping patterns blend their colors (e.g., red +
blue = purple) without numerical summation, creating new hues based on spatial
interaction; (2) **Multi-source interaction**—each pattern’s contribution to a
cell’s color is determined by proximity and orientation, with dominant patterns
visually emphasized; (3) **Heat map draw**—color transitions form a smooth
gradient across the grid, reflecting cumulative pattern influence; (4) **Row
parity coloring**—even-indexed rows shift blended colors toward cooler tones
(e.g., blueish), while odd-indexed rows shift toward warmer tones (e.g.,
reddish), modulating the final hue through visual dominance rather than
arithmetic. The transformation requires recognizing pattern interactions,
applying parity-based color shifts, and synthesizing a coherent heat map without
explicit numerical rules, demanding multi-step visual reasoning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Mapping from a combined pattern mask (bitwise OR of pattern indices) to a visible
# input color. We reserve colors 1..7 for input visuals (masks up to 7). This is
# injective so the solver can reconstruct the mask from the input color.
mask_to_input_color = {
    1: 1,
    2: 2,
    4: 3,
    3: 4,
    5: 5,
    6: 6,
    7: 7,
}


def make_horizontal(width, height):
    """Create a horizontal-stripe pattern (set of (r,c) cells)."""
    thickness = random.randint(1, max(1, height // 4))
    spacing = random.randint(1, max(1, height // 4))
    start = random.randint(0, thickness + spacing - 1)
    cells = set()
    for r in range(height):
        if ((r - start) % (thickness + spacing)) < thickness:
            for c in range(width):
                cells.add((r, c))
    if not cells:
        r = height // 2
        for c in range(width):
            cells.add((r, c))
    return cells


def make_diagonal(width, height):
    """Create a diagonal-line pattern (main or anti-diagonal) with some thickness."""
    orientation = random.choice([0, 1])  # 0 = main, 1 = anti
    # small thickness so diagonals remain line-like
    thickness = random.randint(0, max(0, min(width, height) // 6))
    # offset lets diagonals be shifted
    offset = random.randint(-(height - 1), width - 1)
    cells = set()
    for r in range(height):
        for c in range(width):
            if orientation == 0:
                if abs(c - r - offset) <= thickness:
                    cells.add((r, c))
            else:
                if abs(c + r - offset) <= thickness:
                    cells.add((r, c))
    if not cells:
        cells.add((height // 2, width // 2))
    return cells


def make_circle(width, height):
    """Create a circular motif (either filled disc or thin ring)."""
    cx = random.uniform(0, max(0, width - 1))
    cy = random.uniform(0, max(0, height - 1))
    maxr = max(1.0, min(width, height) / 2.0)
    radius = random.uniform(max(1.0, maxr / 4.0), maxr)
    filled = random.choice([True, False])
    thickness = random.uniform(0.5, 1.5)
    cells = set()
    for r in range(height):
        for c in range(width):
            d = ((c - cx) ** 2 + (r - cy) ** 2) ** 0.5
            if filled:
                if d <= radius:
                    cells.add((r, c))
            else:
                if abs(d - radius) <= thickness:
                    cells.add((r, c))
    if not cells:
        cells.add((height // 2, width // 2))
    return cells


def generate():
    """Generates a single input/output pair.

    Input: multiple overlapping geometric patterns encoded as visible colors
    determined by a mask-to-color mapping. Output: a parity-modulated heatmap
    where the presence of any pattern at a cell produces a cool color on even
    rows and a warm color on odd rows (values 8 and 9), computed deterministically
    from the mask and row parity.
    """
    width = random.randint(4, 20)
    height = random.randint(4, 20)
    # number of source patterns (2 or 3)
    n = random.randint(2, 3)

    # Build pattern masks
    patterns = []
    for _ in range(n):
        t = random.choice(["h", "d", "c"])
        if t == "h":
            cells = make_horizontal(width, height)
        elif t == "d":
            cells = make_diagonal(width, height)
        else:
            cells = make_circle(width, height)
        patterns.append(cells)

    # Compose masks into a single integer mask per cell (bit i corresponds to
    # pattern i). This preserves full information about which sources cover
    # each cell.
    mask_grid = [[0 for _ in range(width)] for __ in range(height)]
    for i, cells in enumerate(patterns):
        bit = 1 << i
        for (r, c) in cells:
            if 0 <= r < height and 0 <= c < width:
                mask_grid[r][c] |= bit

    # Create the input grid by mapping each non-empty mask to a visible color.
    input_grid = grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            mask = mask_grid[r][c]
            if mask == 0:
                input_grid[r][c] = 0
            else:
                # deterministic visible color for that mask (1..7)
                input_grid[r][c] = mask_to_input_color.get(mask, 1)

    # Create the output "heat map". We encode a parity-based cool/warm shift
    # by producing two distinct colors (8=coolish, 9=warmish). The choice is
    # deterministic and depends on the mask and the row parity, ensuring a
    # visible modulation across rows.
    output_grid = grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            mask = mask_grid[r][c]
            if mask == 0:
                output_grid[r][c] = 0
            else:
                # produce 8 or 9 based on mask+row parity (stable, non-arithmetic
                # blend but reflective of multi-source interaction and parity)
                output_grid[r][c] = 8 + ((mask + r) % 2)

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert tuple-of-tuples input to a mutable list-of-lists
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0]) if height > 0 else 0

    # The generator encodes the set of overlapping patterns using an
    # injective map from bitmask->visible input color. We replicate the same
    # mapping here so we can invert it and recover the underlying mask per cell.
    mask_to_input_color = {
        1: 1,
        2: 2,
        4: 3,
        3: 4,
        5: 5,
        6: 6,
        7: 7,
    }
    color_to_mask = {v: k for k, v in mask_to_input_color.items()}

    output = [[0 for _ in range(width)] for __ in range(height)]
    for r in range(height):
        for c in range(width):
            color = input_grid[r][c]
            if color == 0:
                output[r][c] = 0
                continue
            mask = color_to_mask.get(color, 0)
            if mask == 0:
                # Unknown color -> treat as empty
                output[r][c] = 0
            else:
                # Same parity-based mapping as the generator: 8 (cool) or 9 (warm)
                output[r][c] = 8 + ((mask + r) % 2)
    return output

