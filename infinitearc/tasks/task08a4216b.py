# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 08a4216b
Difficulty: insane

=== Tags ===
- Indexed painting
- Line collision
- Bidirectional mapping
- Pattern rotation

=== Description ===
Input grids consist of a 20×20 canvas with a uniform background color. Overlaid
on this background are multiple straight, orthogonal lines of distinct colors
(e.g., red, blue, green), each extending continuously from one grid edge to
another. Scattered throughout the grid are 3×3 pattern blocks, each centered on
a unique color that serves as its identifier. Each pattern block contains an
internal cyclic arrangement of colors arranged in a specific rotational pattern
(e.g., a repeating sequence of colors forming a visual cycle).   The
transformation process involves detecting collisions between lines and pattern
blocks (where a line's path intersects a block's 3×3 area). For each collision,
the block's internal color sequence undergoes a rotation based on a
bidirectional mapping rule: the rotation direction (clockwise or
counterclockwise) is determined by the relative order of the line's color and
the block's identifier color in a standard color sequence (e.g., red → blue →
green → yellow). The rotation angle (90° or 180°) is dictated by whether the
line's color is classified as primary (red, blue, yellow) or secondary (green,
purple, orange). All collisions are processed to determine the final rotated
state of each block's pattern. The output grid retains all lines, background,
and block positions unchanged, but displays each pattern block with its internal
sequence rotated according to the collision rules. No two lines intersect, and
all rotations are deterministic and consistent with the mapping.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Grid size and basic settings
    size = 20
    bg = 0
    grid = [[bg for _ in range(size)] for _ in range(size)]

    # Fixed color sequence and classifications used by both generator and solver
    color_sequence = [2, 1, 3, 4, 6, 7, 5, 8, 9]
    primary_colors = {1, 2, 4}      # treated as primary (90-degree rotation)
    secondary_colors = {3, 6, 7}    # treated as secondary (180-degree rotation)

    # Choose orientation for all lines (to avoid intersections): horizontal or vertical
    orientation = random.choice(["h", "v"])

    # Choose number of lines and their positions (keep margin so blocks won't cover edges)
    n_lines = random.randint(2, 4)
    # pick indices in 2..17 so 3x3 blocks centered in [2..17] won't touch border 0 or 19
    index_pool = list(range(2, 18))

    # Choose line indices with at least spacing of 3 between them to avoid overlapping collisions
    shuffled = index_pool[:]
    random.shuffle(shuffled)
    line_indices = []
    for idx in shuffled:
        if len(line_indices) >= n_lines:
            break
        ok = True
        for sel in line_indices:
            if abs(sel - idx) < 3:
                ok = False
                break
        if ok:
            line_indices.append(idx)
    # If we couldn't fill due to spacing constraints, fill greedily from the sorted pool
    if len(line_indices) < n_lines:
        for idx in sorted(index_pool):
            if len(line_indices) >= n_lines:
                break
            ok = True
            for sel in line_indices:
                if abs(sel - idx) < 3:
                    ok = False
                    break
            if ok:
                line_indices.append(idx)
    line_indices = sorted(line_indices)

    # Choose colors for the lines from primary+secondary only to avoid undefined rotation angle
    line_color_pool = list(primary_colors | secondary_colors)
    line_colors = random.sample(line_color_pool, len(line_indices))

    # Paint the lines across the whole grid
    lines = []
    if orientation == "h":
        for r, color in zip(line_indices, line_colors):
            for c in range(size):
                grid[r][c] = color
            lines.append((r, color))
    else:
        for cidx, color in zip(line_indices, line_colors):
            for r in range(size):
                grid[r][cidx] = color
            lines.append((cidx, color))

    # Helper to check overlapping 3x3 blocks (centers must not make 3x3s overlap)
    centers = []  # store tuples (r, c, id_color)
    def overlaps_existing(r, c):
        for (er, ec, _) in centers:
            # If both row and col ranges overlap within 2 cells, 3x3 areas overlap
            if abs(er - r) <= 2 and abs(ec - c) <= 2:
                return True
        return False

    # Place some number of blocks
    n_blocks = random.randint(3, 6)
    used_id_colors = set()

    # First, ensure at least one block collides with each line (place a center adjacent to each line)
    for ln_idx, ln_color in zip(line_indices, line_colors):
        if len(centers) >= n_blocks:
            break
        placed = False
        for _ in range(200):
            if orientation == "h":
                r = ln_idx + random.choice([-1, 1])
                c = random.randint(2, 17)
            else:
                c = ln_idx + random.choice([-1, 1])
                r = random.randint(2, 17)
            if r < 2 or r > 17 or c < 2 or c > 17:
                continue
            if overlaps_existing(r, c):
                continue
            # id color must be unique and not equal to any line color
            candidates = [col for col in range(1, 10) if col not in line_colors and col not in used_id_colors]
            if not candidates:
                continue
            id_color = random.choice(candidates)
            used_id_colors.add(id_color)
            centers.append((r, c, id_color))
            placed = True
            break
        if not placed:
            # fallback: place any valid non-overlapping center
            for _ in range(200):
                r = random.randint(2, 17)
                c = random.randint(2, 17)
                if orientation == "h" and r in line_indices:
                    continue
                if orientation == "v" and c in line_indices:
                    continue
                if overlaps_existing(r, c):
                    continue
                candidates = [col for col in range(1, 10) if col not in line_colors and col not in used_id_colors]
                if not candidates:
                    continue
                id_color = random.choice(candidates)
                used_id_colors.add(id_color)
                centers.append((r, c, id_color))
                break

    # Fill the remaining blocks randomly (avoid overlaps and lines)
    attempts = 0
    while len(centers) < n_blocks and attempts < 2000:
        attempts += 1
        r = random.randint(2, 17)
        c = random.randint(2, 17)
        if orientation == "h" and r in line_indices:
            continue
        if orientation == "v" and c in line_indices:
            continue
        if overlaps_existing(r, c):
            continue
        candidates = [col for col in range(1, 10) if col not in line_colors and col not in used_id_colors]
        if not candidates:
            break
        id_color = random.choice(candidates)
        used_id_colors.add(id_color)
        centers.append((r, c, id_color))

    # Build patterns for each center: use a 3-length repeating sequence to avoid rotational invariance
    offsets = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)]
    blocks = []
    # used_id_colors currently contains all block id colors; exclude these from neighbor palettes
    for (r, c, id_color) in centers:
        # use k=3 to avoid patterns that are invariant under 90/180 deg rotations
        k = 3
        # exclude any block identifier from neighbor colors so ids remain unique in the whole grid
        choices = [col for col in range(1, 10) if col not in used_id_colors]
        # If choices is empty (rare), fall back to any non-id color
        if not choices:
            choices = [col for col in range(1, 10) if col != id_color]
        seq = [random.choice(choices) for _ in range(k)]
        pattern = [seq[i % k] for i in range(8)]
        # Place center and pattern into the grid (blocks overlay lines)
        grid[r][c] = id_color
        for (dr, dc), col in zip(offsets, pattern):
            rr = r + dr
            cc = c + dc
            grid[rr][cc] = col
        blocks.append((r, c, id_color, pattern))

    # Now compute the output by applying rotations for each collision
    output = [row[:] for row in grid]

    for (r, c, id_color, initial_pattern) in blocks:
        # start from the pattern currently present in the input
        pattern = [grid[r + dr][c + dc] for (dr, dc) in offsets]

        # Gather collisions: lines that pass through any of the 3 rows/cols overlapping the 3x3
        collisions = []
        if orientation == "h":
            for ln_idx, ln_color in zip(line_indices, line_colors):
                if ln_idx >= r - 1 and ln_idx <= r + 1:
                    collisions.append((ln_idx, ln_color))
            collisions.sort(key=lambda x: x[0])
        else:
            for ln_idx, ln_color in zip(line_indices, line_colors):
                if ln_idx >= c - 1 and ln_idx <= c + 1:
                    collisions.append((ln_idx, ln_color))
            collisions.sort(key=lambda x: x[0])

        # Apply each collision sequentially to the block's pattern
        for (_, ln_color) in collisions:
            pos_line = color_sequence.index(ln_color)
            pos_id = color_sequence.index(id_color)
            rotate_clockwise = pos_line < pos_id
            shift = 2 if ln_color in primary_colors else 4
            if rotate_clockwise:
                pattern = pattern[-shift:] + pattern[:-shift]
            else:
                pattern = pattern[shift:] + pattern[:shift]

        # Write the final rotated pattern back into the output grid (center unchanged)
        for (dr, dc), col in zip(offsets, pattern):
            rr = r + dr
            cc = c + dc
            output[rr][cc] = col
        output[r][c] = id_color

    # Ensure output differs from input: there should always be at least one block rotated by design
    # (spacing of lines + length-3 patterns guarantee non-invariance), return pair
    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    size = len(grid)

    # Same color sequence and classification used in the generator
    color_sequence = [2, 1, 3, 4, 6, 7, 5, 8, 9]
    primary_colors = {1, 2, 4}
    secondary_colors = {3, 6, 7}

    # Offsets for the 8-neighbor cyclic order (top, top-right, right, ...)
    offsets = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)]

    # Detect full horizontal lines by checking the two border columns (blocks don't touch col 0/19)
    horizontal_lines = []  # list of (row_index, color)
    for r in range(size):
        if grid[r][0] != 0 and grid[r][0] == grid[r][size - 1]:
            horizontal_lines.append((r, grid[r][0]))

    # Detect full vertical lines by checking the two border rows (blocks don't touch row 0/19)
    vertical_lines = []  # list of (col_index, color)
    for c in range(size):
        if grid[0][c] != 0 and grid[0][c] == grid[size - 1][c]:
            vertical_lines.append((c, grid[0][c]))

    # Count occurrences of each color to find unique center identifiers
    counts = [0] * 10
    for r in range(size):
        for c in range(size):
            counts[grid[r][c]] += 1

    # Find centers: color that appears exactly once and has all eight neighbors non-zero
    centers = []  # list of (r, c, id_color)
    for r in range(2, size - 2):
        for c in range(2, size - 2):
            v = grid[r][c]
            if v == 0:
                continue
            if counts[v] != 1:
                continue
            ok = True
            for dr, dc in offsets:
                if grid[r + dr][c + dc] == 0:
                    ok = False
                    break
            if ok:
                centers.append((r, c, v))

    # Work on a copy for the output
    output = [row[:] for row in grid]

    # For each center, determine collisions and apply rotations sequentially
    for (r, c, id_color) in centers:
        # read the current pattern from the input
        pattern = [grid[r + dr][c + dc] for (dr, dc) in offsets]

        # Collect colliding lines (either horizontal or vertical depending on which exist)
        collisions = []
        if horizontal_lines:
            for ln_idx, ln_color in horizontal_lines:
                if ln_idx >= r - 1 and ln_idx <= r + 1:
                    collisions.append((ln_idx, ln_color))
            collisions.sort(key=lambda x: x[0])
        elif vertical_lines:
            for ln_idx, ln_color in vertical_lines:
                if ln_idx >= c - 1 and ln_idx <= c + 1:
                    collisions.append((ln_idx, ln_color))
            collisions.sort(key=lambda x: x[0])

        # Apply each collision in order
        for (_, ln_color) in collisions:
            pos_line = color_sequence.index(ln_color)
            pos_id = color_sequence.index(id_color)
            rotate_clockwise = pos_line < pos_id
            shift = 2 if ln_color in primary_colors else 4
            if rotate_clockwise:
                pattern = pattern[-shift:] + pattern[:-shift]
            else:
                pattern = pattern[shift:] + pattern[:shift]

        # Write rotated pattern back to the output grid (center unchanged)
        for (dr, dc), col in zip(offsets, pattern):
            output[r + dr][c + dc] = col
        output[r][c] = id_color

    # Return as immutable tuple-of-tuples
    return tuple(tuple(row) for row in output)
