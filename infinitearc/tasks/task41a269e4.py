# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 41a269e4
Difficulty: hard

=== Tags ===
- Out of boundary
- Interpolate between frames

=== Description ===
The task involves transforming an input grid into an output grid by
interpolating the positions of moving objects based on their color-coded
movement directions, while handling boundary conditions. Each distinct non-zero
color in the input grid represents an object moving in a specific direction
(e.g., red = right, blue = down, green = left, yellow = up). For each object,
the transformation calculates its interpolated position between its current
location and the next position it would occupy in the subsequent frame. If the
next position would move the object outside the grid boundaries, the direction
is reflected (e.g., a right-moving object at the right edge moves left instead),
and the interpolation uses this adjusted next position. The output grid places
each object at its interpolated position (computed as the integer average of
current and adjusted next coordinates), with all other cells set to the
background color (0). The challenge lies in identifying multiple color-direction
mappings, applying boundary reflection logic, and correctly computing discrete
interpolation for all objects simultaneously across a complex grid with
overlapping movement paths and edge cases.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    input_grid = [[0] * width for _ in range(height)]
    directions = {
        1: (0, 1),
        2: (1, 0),
        3: (0, -1),
        4: (-1, 0)
    }
    num_objects = random.randint(1, min(10, width * height))
    placed = set()
    for _ in range(num_objects):
        r = random.randint(0, height - 1)
        c = random.randint(0, width - 1)
        if (r, c) in placed:
            continue
        placed.add((r, c))
        color = random.choice([1, 2, 3, 4])
        input_grid[r][c] = color
    output_grid = [[0] * width for _ in range(height)]
    positions = []
    for r in range(height):
        for c in range(width):
            color = input_grid[r][c]
            if color not in directions:
                continue
            dr, dc = directions[color]
            next_r, next_c = r + dr, c + dc
            if next_r < 0 or next_r >= height or next_c < 0 or next_c >= width:
                dr, dc = -dr, -dc
                next_r, next_c = r + dr, c + dc
            new_r = (r + next_r) // 2
            new_c = (c + next_c) // 2
            if new_r == r and new_c == c:
                return generate()
            positions.append((new_r, new_c))
            output_grid[new_r][new_c] = color
    if len(positions) != len(set(positions)):
        return generate()
    if input_grid == output_grid:
        return generate()
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid:
        return []
    height = len(input_grid)
    width = len(input_grid[0])
    directions = {
        1: (0, 1),
        2: (1, 0),
        3: (0, -1),
        4: (-1, 0)
    }
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            color = input_grid[r][c]
            if color not in directions:
                continue
            dr, dc = directions[color]
            next_r, next_c = r + dr, c + dc
            if next_r < 0 or next_r >= height or next_c < 0 or next_c >= width:
                dr, dc = -dr, -dc
                next_r, next_c = r + dr, c + dc
            new_r = (r + next_r) // 2
            new_c = (c + next_c) // 2
            output_grid[new_r][new_c] = color
    return output_grid
