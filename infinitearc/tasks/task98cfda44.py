# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 98cfda44
Difficulty: mediumâ€“hard

=== Tags ===
- Laser diffusion
- Dual grid translation
- Embedded rule repetition
- Measure length

=== Description ===
The input grid features a laser source (a single cell of color 1) and a maze of
mirror cells (color 2) arranged to create a deterministic path. The laser
propagates orthogonally in a fixed initial direction (e.g., right) until
encountering a mirror, where it reflects 90 degrees (left or right based on
mirror orientation). The path continues until the laser exits the grid boundary.
The output grid displays the complete laser path as connected cells of color 1.
Simultaneously, an embedded secondary pattern (a contiguous shape of color 3) is
translated within the grid. The translation distance equals the path length
(number of cells traversed) modulo the grid width, and the direction alternates
horizontally for even path lengths and vertically for odd path lengths. The
translation preserves the pattern's internal structure but shifts its position.
All background cells (color 0) remain unchanged, and the secondary pattern does
not overlap with the laser path. The task requires identifying the reflection
pattern, measuring the path length, and applying the dual translation rule to
both the laser path and the embedded pattern.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    import common
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid_input = common.grid(width, height, 0)
    grid_output = common.grid(width, height, 0)

    r = random.randint(1, height - 4)
    grid_input[r][0] = 1
    mirror1 = (r, 3)
    mirror2 = (r + 3, 3)
    grid_input[mirror1[0]][mirror1[1]] = 2
    grid_input[mirror2[0]][mirror2[1]] = 2

    path = []
    current = (r, 0)
    direction = (0, 1)
    while True:
        path.append(current)
        next_cell = (current[0] + direction[0], current[1] + direction[1])
        if not (0 <= next_cell[0] < height and 0 <= next_cell[1] < width):
            break
        if next_cell == mirror1 or next_cell == mirror2:
            direction = (direction[1], -direction[0])
        current = next_cell

    L = len(path)

    pattern_cells = common.continuous_creature(3, width, height)
    while any(cell in path for cell in pattern_cells):
        pattern_cells = common.continuous_creature(3, width, height)

    dist = L % width
    if L % 2 == 0:
        new_pattern = [(r, c + dist) for r, c in pattern_cells]
    else:
        new_pattern = [(r + dist, c) for r, c in pattern_cells]
    new_pattern = [(r % height, c % width) for r, c in new_pattern]

    for (r, c) in path:
        grid_output[r][c] = 1
    for (r, c) in new_pattern:
        grid_output[r][c] = 3
    for (r, c) in pattern_cells:
        grid_input[r][c] = 3

    return {"input": grid_input, "output": grid_output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    import common
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)

    source_pos = None
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 1:
                source_pos = (r, c)
                break
        if source_pos:
            break
    if not source_pos:
        source_pos = (0, 0)

    path = []
    current = source_pos
    direction = (0, 1)
    while True:
        path.append(current)
        next_cell = (current[0] + direction[0], current[1] + direction[1])
        if not (0 <= next_cell[0] < height and 0 <= next_cell[1] < width):
            break
        if grid[next_cell[0]][next_cell[1]] == 2:
            direction = (direction[1], -direction[0])
        current = next_cell

    L = len(path)

    pattern_cells = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 3:
                pattern_cells.append((r, c))

    dist = L % width
    if L % 2 == 0:
        new_pattern = [(r, c + dist) for r, c in pattern_cells]
    else:
        new_pattern = [(r + dist, c) for r, c in pattern_cells]
    new_pattern = [(r % height, c % width) for r, c in new_pattern]

    output = common.grid(width, height, 0)
    for (r, c) in path:
        output[r][c] = 1
    for (r, c) in new_pattern:
        output[r][c] = 3

    return output
