# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 9511eac6
Difficulty: medium–hard

=== Tags ===
- Flow with decay
- Remove border

=== Description ===
Input grids are rectangular with dimensions between 5×5 and 30×30. The
background color is 0 (black), and all border cells (outermost rows and columns)
are uniformly colored with a single non-background color (e.g., red). Within the
interior (non-border area), the grid contains one or more isolated source cells
(color A) surrounded by background (0) cells, with at least one background cell
separating each source from the border.   The transformation applies two rules:
1. **Border removal**: All border cells are replaced with the background color
(0).   2. **Flow with decay**: Starting from each source cell, a color sequence
propagates outward through adjacent background cells (up/down/left/right), with
each successive cell away from the nearest source cycling through a fixed
sequence of colors (e.g., A → B → C → A → ...). The color for any interior cell
is determined by its minimum distance to the nearest source, with the sequence
repeating every three steps (e.g., distance 0 = A, distance 1 = B, distance 2 =
C, distance 3 = A, etc.). Cells influenced by multiple sources use the color
corresponding to the distance to the closest source.    The output grid matches
the input grid's dimensions, with border cells set to 0 and interior cells
filled according to the flow decay pattern. The task requires recognizing the
source positions, computing minimum distances, and applying the cyclic color
sequence while ignoring the original border color.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    X = random.randint(1, 9)
    A = random.randint(1, 9)
    while A == X:
        A = random.randint(1, 9)
    colors = list(range(1, 10))
    colors.remove(X)
    colors.remove(A)
    colors.sort()
    B, C = colors[0], colors[1]
    input_grid = [[X] * width for _ in range(height)]
    for r in range(1, height-1):
        for c in range(1, width-1):
            input_grid[r][c] = 0
    src_r = random.randint(1, height-2)
    src_c = random.randint(1, width-2)
    input_grid[src_r][src_c] = A
    output_grid = [[0] * width for _ in range(height)]
    for r in range(1, height-1):
        for c in range(1, width-1):
            dist = abs(r - src_r) + abs(c - src_c)
            color = [A, B, C][dist % 3]
            output_grid[r][c] = color
    return {
        'input': input_grid,
        'output': output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    X = grid[0][0]
    interior_colors = set()
    for r in range(1, height-1):
        for c in range(1, width-1):
            if grid[r][c] != 0 and grid[r][c] != X:
                interior_colors.add(grid[r][c])
    A = next(iter(interior_colors))
    colors = list(range(1, 10))
    colors.remove(X)
    colors.remove(A)
    colors.sort()
    B, C = colors[0], colors[1]
    sources = []
    for r in range(1, height-1):
        for c in range(1, width-1):
            if grid[r][c] == A:
                sources.append((r, c))
    output = [[0] * width for _ in range(height)]
    for r in range(1, height-1):
        for c in range(1, width-1):
            min_dist = float('inf')
            for sr, sc in sources:
                dist = abs(r - sr) + abs(c - sc)
                if dist < min_dist:
                    min_dist = dist
            color = [A, B, C][min_dist % 3]
            output[r][c] = color
    return output
