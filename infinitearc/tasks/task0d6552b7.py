# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 0d6552b7
Difficulty: easy

=== Tags ===
- Direction guessing
- Projection unto rectangle
- Fill smallest enclosed hole
- Remove noise

=== Description ===
The input grid contains a main shape represented by a single color (e.g., color
1) with a small enclosed hole (color 0), some disconnected noise pixels (color
2), and a direction indicator (color 3) positioned to indicate a specific edge
(e.g., bottom edge). The transformation to the output grid follows four
sequential steps: (1) Remove all noise pixels (isolated small components not
connected to the main shape), (2) Fill the smallest enclosed hole within the
main shape (smallest area of color 0), (3) Align the main shape to the edge of
the grid corresponding to the direction indicator (e.g., direction down aligns
the shape to the bottom row), and (4) Ensure all other elements (e.g., direction
indicator) are removed or adjusted to maintain consistency. The task requires
recognizing the direction from the indicator, identifying noise and the smallest
hole, and applying the alignment rule to produce the output. The solution is
visually intuitive for easy difficulty, relying on spatial reasoning rather than
numerical computation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 10)
    height = random.randint(5, 10)
    
    input_grid = [[0] * width for _ in range(height)]
    
    row_start = random.randint(1, height - 4)
    col_start = random.randint(1, width - 4)
    main_shape = [
        [1, 1, 1],
        [1, 0, 1],
        [1, 1, 1]
    ]
    for r in range(3):
        for c in range(3):
            input_grid[row_start + r][col_start + c] = main_shape[r][c]
    
    input_grid[0][0] = 2
    input_grid[height-1][width-1] = 2
    
    direction = random.choice(['top', 'bottom', 'left', 'right'])
    if direction == 'bottom':
        input_grid[height-1][col_start + 1] = 3
    elif direction == 'top':
        input_grid[0][col_start + 1] = 3
    elif direction == 'left':
        input_grid[row_start + 1][0] = 3
    elif direction == 'right':
        input_grid[row_start + 1][width-1] = 3
    
    output_grid = [[0] * width for _ in range(height)]
    
    if direction == 'bottom':
        new_row_start = height - 3
        for r in range(3):
            for c in range(3):
                output_grid[new_row_start + r][col_start + c] = 1
    elif direction == 'top':
        for r in range(3):
            for c in range(3):
                output_grid[r][col_start + c] = 1
    elif direction == 'left':
        new_col_start = 0
        for r in range(3):
            for c in range(3):
                output_grid[row_start + r][new_col_start + c] = 1
    elif direction == 'right':
        new_col_start = width - 3
        for r in range(3):
            for c in range(3):
                output_grid[row_start + r][new_col_start + c] = 1
    
    return {
        'input': input_grid,
        'output': output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    
    direction = None
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 3:
                if r == 0:
                    direction = 'top'
                elif r == height - 1:
                    direction = 'bottom'
                elif c == 0:
                    direction = 'left'
                elif c == width - 1:
                    direction = 'right'
    if direction is None:
        direction = 'bottom'
    
    temp_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] in [2, 3]:
                temp_grid[r][c] = 0
            else:
                temp_grid[r][c] = input_grid[r][c]
    
    for r in range(height):
        for c in range(width):
            if temp_grid[r][c] == 0:
                top = temp_grid[r-1][c] == 1 if r > 0 else False
                bottom = temp_grid[r+1][c] == 1 if r < height-1 else False
                left = temp_grid[r][c-1] == 1 if c > 0 else False
                right = temp_grid[r][c+1] == 1 if c < width-1 else False
                if top and bottom and left and right:
                    temp_grid[r][c] = 1
    
    min_row = height
    max_row = -1
    min_col = width
    max_col = -1
    for r in range(height):
        for c in range(width):
            if temp_grid[r][c] == 1:
                min_row = min(min_row, r)
                max_row = max(max_row, r)
                min_col = min(min_col, c)
                max_col = max(max_col, c)
    
    if min_row > max_row:
        return [[0]*width for _ in range(height)]
    
    height_main = max_row - min_row + 1
    width_main = max_col - min_col + 1
    
    output_grid = [[0] * width for _ in range(height)]
    if direction in ['bottom', 'top']:
        new_min_row = height - height_main if direction == 'bottom' else 0
        new_min_col = min_col
    else:
        new_min_col = width - width_main if direction == 'right' else 0
        new_min_row = min_row
    
    for r in range(height_main):
        for c in range(width_main):
            if new_min_row + r < height and new_min_col + c < width:
                output_grid[new_min_row + r][new_min_col + c] = 1
    
    return output_grid
