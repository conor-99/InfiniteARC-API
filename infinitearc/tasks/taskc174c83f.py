# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: c174c83f
Difficulty: medium

=== Tags ===
- Tiled majority vote

=== Description ===
The task involves transforming an input grid by dividing it into non-overlapping
2x2 tiles. For each tile, the most frequent color (majority) is determined. If
multiple colors tie for the majority (e.g., two colors each appearing twice),
the smallest numerical value among the tied colors is selected. If all four
colors in a tile are distinct, the smallest color value is used. The output grid
is constructed by replacing each 2x2 tile in the input with a uniform 2x2 block
of the determined majority color. The transformation requires consistent
application of majority voting across all tiles, with tie-breaking rules
ensuring determinism. Input and output grids must differ, requiring at least one
tile to contain a non-uniform color distribution.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randrange(2, 31, 2)
    height = random.randrange(2, 31, 2)
    input_grid = grid(width, height)
    for r in range(height):
        for c in range(width):
            input_grid[r][c] = random.randint(0, 9)
    
    output_grid = grid(width, height)
    for r in range(0, height, 2):
        for c in range(0, width, 2):
            colors = [
                input_grid[r][c],
                input_grid[r][c+1],
                input_grid[r+1][c],
                input_grid[r+1][c+1]
            ]
            count = {}
            for color in colors:
                count[color] = count.get(color, 0) + 1
            max_count = max(count.values())
            candidates = [color for color, cnt in count.items() if cnt == max_count]
            majority = min(candidates)
            for dr in range(2):
                for dc in range(2):
                    output_grid[r+dr][c+dc] = majority
    
    if input_grid == output_grid:
        return generate()
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = grid(width, height)
    for r in range(0, height, 2):
        for c in range(0, width, 2):
            colors = [
                input_grid[r][c],
                input_grid[r][c+1],
                input_grid[r+1][c],
                input_grid[r+1][c+1]
            ]
            count = {}
            for color in colors:
                count[color] = count.get(color, 0) + 1
            max_count = max(count.values())
            candidates = [color for color, cnt in count.items() if cnt == max_count]
            majority = min(candidates)
            for dr in range(2):
                for dc in range(2):
                    output_grid[r+dr][c+dc] = majority
    return output_grid
