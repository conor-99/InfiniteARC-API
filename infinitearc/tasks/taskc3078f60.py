# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: c3078f60
Difficulty: hard

=== Tags ===
- Alternating rule composition

=== Description ===
The input grid consists of multiple disconnected colored shapes (contiguous
blocks of a single non-zero color) distributed across a background of color 0.
Each shape occupies a distinct region of the grid, with no overlapping or
touching edges between shapes. The output grid applies two distinct geometric
transformations in sequence: first, each shape is rotated 90 degrees clockwise
if it spans an even-numbered row (0-indexed) in its original position, or
reflected vertically if it spans an odd-numbered row. Second, all transformed
shapes are repositioned to maintain their relative spatial arrangement, ensuring
no shape overlaps with another or the grid boundaries. The background (color 0)
remains unchanged throughout the transformation. The key challenge lies in
identifying each shape's row-based position, applying the alternating
transformation rule, and reassembling the grid without distortion or overlap,
requiring multi-step visual reasoning to distinguish row parity and apply the
correct operation per shape.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, continuous_creature, randint, random_colors


def generate():
    """
    Generates an input/output pair according to the task specification.
    - Creates a grid with several non-touching contiguous colored shapes.
    - For each shape, if it covers any even row (0-indexed) it is rotated 90 degrees clockwise,
      otherwise it is reflected vertically (flipped top-to-bottom).
    - Transformed shapes are then placed back onto the output grid trying to preserve their
      original top-left positions; if a transformed shape would overlap or go out of bounds
      the generator searches (wrapping from the original position) for the nearest valid
      placement. Shapes are placed in sorted order by their original top-left so the solver
      can reproduce the same ordering.
    """
    # Try repeatedly until we produce a valid, non-trivial pair.
    for _ in range(1000):
        width = randint(6, 20)
        height = randint(6, 20)
        num_shapes = randint(2, 4)
        colors = random_colors(num_shapes, exclude=[0])

        input_grid = grid(width, height, 0)
        occupancy = [[0 for _ in range(width)] for _ in range(height)]
        shapes = []  # will store dicts with color and absolute pixels

        ok = True
        # Place shapes one by one ensuring no edge-touching and no overlap.
        for color in colors:
            placed = False
            # Try many random placements and shape footprints; restart whole generation if impossible.
            for _attempt in range(250):
                sh_h = randint(2, min(6, height))
                sh_w = randint(2, min(6, width))
                max_cells = sh_h * sh_w
                size = randint(2, min(max_cells, 8))
                local_pixels = continuous_creature(size, width=sh_w, height=sh_h)

                if height - sh_h < 0 or width - sh_w < 0:
                    continue

                r0 = randint(0, height - sh_h)
                c0 = randint(0, width - sh_w)
                abs_pixels = [(r0 + r, c0 + c) for (r, c) in local_pixels]

                # Check overlap and edge-touching (4-neighbour) with existing shapes.
                valid = True
                for (r, c) in abs_pixels:
                    if occupancy[r][c] != 0:
                        valid = False
                        break
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        rr, cc = r + dr, c + dc
                        if 0 <= rr < height and 0 <= cc < width and occupancy[rr][cc] != 0:
                            valid = False
                            break
                    if not valid:
                        break

                if not valid:
                    continue

                # Commit placement
                for (r, c) in abs_pixels:
                    occupancy[r][c] = color
                    input_grid[r][c] = color
                shapes.append({"color": color, "pixels": abs_pixels})
                placed = True
                break

            if not placed:
                ok = False
                break

        if not ok:
            # Failed to place all shapes; try new grid/layout
            continue

        # Prepare output grid and place transformed shapes.
        output_grid = grid(width, height, 0)

        # Helper transforms
        def rotate90_cw(local, color):
            h = len(local)
            w = len(local[0])
            res = [[0 for _ in range(h)] for _ in range(w)]
            for i in range(h):
                for j in range(w):
                    if local[i][j]:
                        res[j][h - 1 - i] = color
            return res

        def flip_vertical(local, color):
            h = len(local)
            w = len(local[0])
            res = [[0 for _ in range(w)] for _ in range(h)]
            for i in range(h):
                for j in range(w):
                    if local[i][j]:
                        res[h - 1 - i][j] = color
            return res

        # Sort shapes by their bounding-box top-left so placement order is deterministic.
        for s in shapes:
            min_r = min(r for r, c in s["pixels"])
            min_c = min(c for r, c in s["pixels"])
            s["min_r"] = min_r
            s["min_c"] = min_c
        shapes.sort(key=lambda s: (s["min_r"], s["min_c"]))

        placement_ok = True
        for s in shapes:
            pixels = s["pixels"]
            color = s["color"]
            min_r = min(r for r, c in pixels)
            max_r = max(r for r, c in pixels)
            min_c = min(c for r, c in pixels)
            max_c = max(c for r, c in pixels)

            local_h = max_r - min_r + 1
            local_w = max_c - min_c + 1
            local = [[0 for _ in range(local_w)] for _ in range(local_h)]
            for (r, c) in pixels:
                local[r - min_r][c - min_c] = 1

            spans_even = any((r % 2) == 0 for r, c in pixels)
            if spans_even:
                transformed = rotate90_cw(local, color)
            else:
                transformed = flip_vertical(local, color)

            t_h = len(transformed)
            t_w = len(transformed[0])

            # If transformed shape is bigger than the grid, give up and restart generation.
            if t_h > height or t_w > width:
                placement_ok = False
                break

            # Search for a placement starting from the original top-left and wrapping.
            r_slots = height - t_h + 1
            c_slots = width - t_w + 1
            found = False
            for r_off in range(r_slots):
                r_try = (min_r + r_off) % r_slots
                for c_off in range(c_slots):
                    c_try = (min_c + c_off) % c_slots
                    can_place = True
                    for i in range(t_h):
                        for j in range(t_w):
                            if transformed[i][j]:
                                rr = r_try + i
                                cc = c_try + j
                                if output_grid[rr][cc] != 0:
                                    can_place = False
                                    break
                        if not can_place:
                            break
                    if can_place:
                        for i in range(t_h):
                            for j in range(t_w):
                                if transformed[i][j]:
                                    output_grid[r_try + i][c_try + j] = color
                        found = True
                        break
                if found:
                    break

            if not found:
                placement_ok = False
                break

        if not placement_ok:
            continue

        # Make sure the input and output are not identical (transformation had an effect).
        if input_grid == output_grid:
            continue

        return {"input": input_grid, "output": output_grid}

    # If we somehow failed many times, fall back to a simple guaranteed example (should not happen).
    # Build a tiny guaranteed pair.
    in_g = grid(6, 6, 0)
    out_g = grid(6, 6, 0)
    in_g[1][1] = 1
    in_g[1][2] = 1
    in_g[2][1] = 1
    out_g[1][1] = 1
    out_g[2][1] = 1
    out_g[1][2] = 1
    return {"input": in_g, "output": out_g}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque


def p(input_grid):
    # Convert to mutable list-of-lists
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])

    visited = [[False for _ in range(width)] for _ in range(height)]
    shapes = []  # each shape: {color, pixels:list of (r,c)}

    # Find connected components (4-connected) of non-zero colors.
    for r in range(height):
        for c in range(width):
            if grid_in[r][c] == 0 or visited[r][c]:
                continue
            color = grid_in[r][c]
            # BFS to collect this component
            q = deque()
            q.append((r, c))
            visited[r][c] = True
            comp = []
            while q:
                pr, pc = q.popleft()
                comp.append((pr, pc))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = pr + dr, pc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid_in[nr][nc] == color:
                        visited[nr][nc] = True
                        q.append((nr, nc))
            shapes.append({"color": color, "pixels": comp})

    # Sort shapes by their bounding-box top-left so placement order matches the generator.
    for s in shapes:
        s_min_r = min(r for r, c in s["pixels"])
        s_min_c = min(c for r, c in s["pixels"])
        s["min_r"] = s_min_r
        s["min_c"] = s_min_c
    shapes.sort(key=lambda s: (s["min_r"], s["min_c"]))

    # Helper transforms (must match generator behavior)
    def rotate90_cw(local, color):
        h = len(local)
        w = len(local[0])
        res = [[0 for _ in range(h)] for _ in range(w)]
        for i in range(h):
            for j in range(w):
                if local[i][j]:
                    res[j][h - 1 - i] = color
        return res

    def flip_vertical(local, color):
        h = len(local)
        w = len(local[0])
        res = [[0 for _ in range(w)] for _ in range(h)]
        for i in range(h):
            for j in range(w):
                if local[i][j]:
                    res[h - 1 - i][j] = color
        return res

    output = [[0 for _ in range(width)] for _ in range(height)]

    # Place transformed shapes using same placement strategy as the generator
    for s in shapes:
        pixels = s["pixels"]
        color = s["color"]
        min_r = min(r for r, c in pixels)
        max_r = max(r for r, c in pixels)
        min_c = min(c for r, c in pixels)
        max_c = max(c for r, c in pixels)

        local_h = max_r - min_r + 1
        local_w = max_c - min_c + 1
        local = [[0 for _ in range(local_w)] for _ in range(local_h)]
        for (r, c) in pixels:
            local[r - min_r][c - min_c] = 1

        spans_even = any((r % 2) == 0 for r, c in pixels)
        if spans_even:
            transformed = rotate90_cw(local, color)
        else:
            transformed = flip_vertical(local, color)

        t_h = len(transformed)
        t_w = len(transformed[0])

        # Find a placement starting from original top-left and wrapping through possible slots
        r_slots = height - t_h + 1
        c_slots = width - t_w + 1
        if r_slots <= 0 or c_slots <= 0:
            # If a transformed shape cannot fit, return a safe fallback (shouldn't happen for valid inputs)
            return tuple(tuple(row) for row in output)

        found = False
        for r_off in range(r_slots):
            r_try = (min_r + r_off) % r_slots
            for c_off in range(c_slots):
                c_try = (min_c + c_off) % c_slots
                can_place = True
                for i in range(t_h):
                    for j in range(t_w):
                        if transformed[i][j]:
                            rr = r_try + i
                            cc = c_try + j
                            if output[rr][cc] != 0:
                                can_place = False
                                break
                    if not can_place:
                        break
                if can_place:
                    for i in range(t_h):
                        for j in range(t_w):
                            if transformed[i][j]:
                                output[r_try + i][c_try + j] = color
                    found = True
                    break
            if found:
                break

        # If not found, give up (should not happen on valid inputs) and return what we have.
        if not found:
            return tuple(tuple(row) for row in output)

    return tuple(tuple(row) for row in output)

