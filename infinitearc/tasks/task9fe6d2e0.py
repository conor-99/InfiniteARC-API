# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 9fe6d2e0
Difficulty: very hard

=== Tags ===
- Pattern sync
- Propagate label
- Pattern bounce
- Chain reaction
- Jigsaw

=== Description ===
Jigsaw Chain Reaction  Input grids feature a background color (0) overlaid with
multiple distinct, contiguous colored jigsaw pieces (each a single color from
1-9), arranged in a scattered, non-symmetrical layout. Each piece has a fixed
orientation (horizontal, vertical, or diagonal) determined by its geometric
shape (e.g., width > height for horizontal, height > width for vertical, or
diagonal alignment for diagonal). Additionally, a central "propagation source"
cell (color 1) is present, initiating the transformation.  The transformation
rule begins with **propagating** the source color outward in all four cardinal
directions (up, down, left, right) through background cells. Upon encountering a
jigsaw piece, the propagation **bounces** according to the piece's orientation:
horizontal pieces reverse horizontal propagation (left→right, right→left),
vertical pieces reverse vertical propagation (up→down, down→up), and diagonal
pieces reverse both direction components (e.g., northeast diagonal reverses both
horizontal and vertical directions). Each bounce triggers a new propagation path
from the impact point, creating a **chain reaction** that continues until all
propagations reach grid boundaries.  The **pattern sync** rule requires that
jigsaw pieces move along the propagation path direction until they can no longer
move (due to grid boundaries or overlapping with another piece). The output grid
is formed by moving all pieces according to their triggered propagation paths,
resulting in a synchronized arrangement where all pieces align along their
propagation vectors without overlapping. The final configuration forms a
coherent geometric pattern (e.g., all pieces aligned horizontally), representing
the "sync" state. The jigsaw aspect is that the transformation requires pieces
to rearrange into this aligned pattern through the chain reaction of bounces,
with the output grid reflecting the final synchronized state.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    # Grid size (kept moderate for speed but variable for diversity)
    w = random.randint(7, 15)
    h = random.randint(7, 15)
    grid = [[0 for _ in range(w)] for _ in range(h)]

    # Place central propagation source (color 1)
    sr, sc = h // 2, w // 2
    grid[sr][sc] = 1

    # Decide number of pieces and colors
    n_pieces = random.randint(3, 6)
    available_colors = list(range(2, 10))
    random.shuffle(available_colors)
    colors = available_colors[:n_pieces]

    pieces = []  # list of dicts: {color, pixels(set), orientation}
    occupied = set()
    occupied.add((sr, sc))

    # Helper to compute orientation from a set of pixels
    def compute_orientation(pixels):
        rs = [p[0] for p in pixels]
        cs = [p[1] for p in pixels]
        bw = max(cs) - min(cs) + 1
        bh = max(rs) - min(rs) + 1
        if bw > bh:
            return 'horizontal'
        elif bh > bw:
            return 'vertical'
        else:
            return 'diagonal'

    # Place a guaranteed target piece in a clear cardinal direction so propagation will trigger movement
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    special_dir = random.choice(directions)

    def try_place_single_pixel_at(r, c, color):
        if (r, c) in occupied:
            return False
        grid[r][c] = color
        occupied.add((r, c))
        pieces.append({'color': color, 'pixels': {(r, c)}, 'orientation': 'diagonal'})
        return True

    # Try to place special one-cell piece along chosen direction at a distance >=2 from the source
    placed_special = False
    drs, dcs = special_dir
    for offset in range(2, max(3, max(h, w) // 2)):
        rr = sr + drs * offset
        cc = sc + dcs * offset
        if 0 <= rr < h and 0 <= cc < w and (rr, cc) not in occupied:
            special_color = colors[0]
            placed_special = try_place_single_pixel_at(rr, cc, special_color)
            if placed_special:
                break

    # Place the remaining pieces using contiguous sprites
    for color in colors:
        # skip color already used for special piece
        if any(isinstance(p, dict) and p.get('color') == color for p in pieces):
            continue
        placed = False
        tries = 0
        while not placed and tries < 60:
            tries += 1
            # pick bounding box for sprite
            sw = random.randint(1, 5)
            sh = random.randint(1, 5)
            max_cells = sw * sh
            size = random.randint(1, min(7, max_cells))
            # create a contiguous creature within sw x sh
            sprite = common.continuous_creature(size, width=sw, height=sh)
            # choose anchor so sprite fits in grid
            max_ar = h - sh
            max_ac = w - sw
            if max_ar < 0 or max_ac < 0:
                continue
            ar = random.randint(0, max_ar)
            ac = random.randint(0, max_ac)
            global_pixels = {(ar + r, ac + c) for (r, c) in sprite}
            if occupied & global_pixels:
                continue
            # avoid placing directly on source
            if (sr, sc) in global_pixels:
                continue
            # place it
            for (r, c) in global_pixels:
                grid[r][c] = color
            occupied |= global_pixels
            orient = compute_orientation(global_pixels)
            pieces.append({'color': color, 'pixels': set(global_pixels), 'orientation': orient})
            placed = True
        # end while
    # If too few pieces placed, try again (rare)
    if len(pieces) < 2:
        return generate()

    # Build a map for simulation (robust against malformed entries)
    output = [row[:] for row in grid]
    piece_map = {}
    for p in pieces:
        if not isinstance(p, dict):
            continue
        if 'color' not in p or 'pixels' not in p or 'orientation' not in p:
            continue
        piece_map[p['color']] = {'pixels': set(p['pixels']), 'orientation': p['orientation'], 'color': p['color']}

    # Propagation BFS queue: up, down, left, right (deterministic order)
    rays = [(sr, sc, -1, 0), (sr, sc, 1, 0), (sr, sc, 0, -1), (sr, sc, 0, 1)]
    visited = set()
    steps = 0
    MAX_STEPS = 5000

    while rays and steps < MAX_STEPS:
        steps += 1
        r, c, dr, dc = rays.pop(0)
        # advance until boundary or non-zero
        nr, nc = r + dr, c + dc
        while 0 <= nr < h and 0 <= nc < w and output[nr][nc] == 0:
            nr += dr
            nc += dc
        # if we went out of bounds, this ray finishes
        if not (0 <= nr < h and 0 <= nc < w):
            continue
        # hit something
        cell = output[nr][nc]
        if cell == 1:
            # hit the source: treat as blocker and stop
            continue
        if cell == 0:
            continue
        # cell > 1 an actual piece
        piece = piece_map.get(cell)
        if piece is None:
            continue
        # compute bounce direction based on piece orientation
        br, bc = dr, dc
        if piece['orientation'] == 'horizontal':
            bc = -bc
        elif piece['orientation'] == 'vertical':
            br = -br
        else:
            br, bc = -br, -bc
        # spawn bounced ray if unseen
        key = (nr, nc, br, bc)
        if key not in visited:
            visited.add(key)
            rays.append((nr, nc, br, bc))
        # Move the piece along the incoming direction (dr,dc) as far as it can go
        while True:
            new_positions = {(r0 + dr, c0 + dc) for (r0, c0) in piece['pixels']}
            blocked = False
            for (r0, c0) in new_positions:
                if not (0 <= r0 < h and 0 <= c0 < w):
                    blocked = True
                    break
                occ = output[r0][c0]
                if occ != 0 and occ != piece['color']:
                    blocked = True
                    break
            if blocked:
                break
            # perform move
            for (r0, c0) in piece['pixels']:
                output[r0][c0] = 0
            for (r0, c0) in new_positions:
                output[r0][c0] = piece['color']
            piece['pixels'] = new_positions
    # If nothing changed (rare), regenerate to ensure input != output
    if output == grid:
        return generate()

    return {'input': grid, 'output': output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input tuple to mutable list of lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])
    # find source
    sr = None
    sc = None
    for r in range(h):
        for c in range(w):
            if grid[r][c] == 1:
                sr, sc = r, c
                break
        if sr is not None:
            break
    if sr is None:
        return grid
    # collect piece colors and pixels
    colors = set()
    for r in range(h):
        for c in range(w):
            val = grid[r][c]
            if val > 1:
                colors.add(val)
    pieces = []
    for color in colors:
        pixels = []
        for r in range(h):
            for c in range(w):
                if grid[r][c] == color:
                    pixels.append((r, c))
        rs = [p[0] for p in pixels]
        cs = [p[1] for p in pixels]
        bw = max(cs) - min(cs) + 1
        bh = max(rs) - min(rs) + 1
        if bw > bh:
            orientation = 'horizontal'
        elif bh > bw:
            orientation = 'vertical'
        else:
            orientation = 'diagonal'
        pieces.append({'color': color, 'pixels': set(pixels), 'orientation': orientation})

    # Prepare output grid and piece map
    output = [row[:] for row in grid]
    piece_map = {p['color']: {'pixels': set(p['pixels']), 'orientation': p['orientation'], 'color': p['color']} for p in pieces}

    # BFS propagation queue
    rays = [(sr, sc, -1, 0), (sr, sc, 1, 0), (sr, sc, 0, -1), (sr, sc, 0, 1)]
    visited = set()
    steps = 0
    MAX_STEPS = 5000

    while rays and steps < MAX_STEPS:
        steps += 1
        r, c, dr, dc = rays.pop(0)
        nr, nc = r + dr, c + dc
        while 0 <= nr < h and 0 <= nc < w and output[nr][nc] == 0:
            nr += dr
            nc += dc
        if not (0 <= nr < h and 0 <= nc < w):
            continue
        cell = output[nr][nc]
        if cell == 1:
            continue
        if cell == 0:
            continue
        piece = piece_map.get(cell)
        if piece is None:
            continue
        br, bc = dr, dc
        if piece['orientation'] == 'horizontal':
            bc = -bc
        elif piece['orientation'] == 'vertical':
            br = -br
        else:
            br, bc = -br, -bc
        key = (nr, nc, br, bc)
        if key not in visited:
            visited.add(key)
            rays.append((nr, nc, br, bc))
        # Move piece along incoming (dr,dc)
        while True:
            new_positions = {(r0 + dr, c0 + dc) for (r0, c0) in piece['pixels']}
            blocked = False
            for (r0, c0) in new_positions:
                if not (0 <= r0 < h and 0 <= c0 < w):
                    blocked = True
                    break
                occ = output[r0][c0]
                if occ != 0 and occ != piece['color']:
                    blocked = True
                    break
            if blocked:
                break
            for (r0, c0) in piece['pixels']:
                output[r0][c0] = 0
            for (r0, c0) in new_positions:
                output[r0][c0] = piece['color']
            piece['pixels'] = new_positions
    return output

