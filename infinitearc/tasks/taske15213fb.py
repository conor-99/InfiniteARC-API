# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: e15213fb
Difficulty: hard

=== Tags ===
- Sequential path painting
- Connect the dots

=== Description ===
Input grids consist of a uniform background color (0) and multiple uniquely
colored points (each using a distinct color from 1 to 9, representing their
sequential label). The points are positioned such that each is surrounded by
background cells, and no two points are adjacent. The output grid must connect
each point labeled k to the point labeled k+1 (for k from 1 to n-1) with a path
drawn through background cells only. Each path segment between label k and k+1
is painted using the color corresponding to label k+1. The path must follow the
shortest possible route (using 4-directional movement), and when multiple
shortest paths exist, the path must prioritize moving right over up, and down
over left. The original labeled points and background remain unchanged except
for the newly drawn paths. The output grid should not contain any new colored
points beyond the original labels and the path segments.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common
from collections import deque

# Generator for ARC task: place isolated labeled points and connect k->k+1 with shortest path
# Tie-breaking for multiple equal shortest paths: prioritize Right, then Up, then Down, then Left.

def _shortest_path_between(input_grid, start, end):
    """
    BFS shortest path between start and end allowing traversal through background (0) and
    allowing the end cell even though it is non-background. Neighbor order enforces tie-break.
    Returns list of cells from start (excluded) to end (included).
    """
    height = len(input_grid)
    width = len(input_grid[0])
    directions = [(0, 1), (-1, 0), (1, 0), (0, -1)]  # right, up, down, left
    visited = [[False] * width for _ in range(height)]
    parent = {}
    q = deque([start])
    visited[start[0]][start[1]] = True
    found = False
    while q and not found:
        r, c = q.popleft()
        if (r, c) == end:
            found = True
            break
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc]:
                # allow moving into background or into the destination cell
                if input_grid[nr][nc] == 0 or (nr, nc) == end:
                    visited[nr][nc] = True
                    parent[(nr, nc)] = (r, c)
                    q.append((nr, nc))
    if not found:
        return None
    # reconstruct path from start (excluded) to end (included)
    path = []
    cur = end
    while cur != start:
        path.append(cur)
        cur = parent[cur]
    path.reverse()
    return path


def generate():
    """
    Produces an input grid with isolated labeled points 1..n and an output grid where
    each point k is connected to k+1 by the shortest path painted with color k+1.
    """
    attempts = 0
    while True:
        attempts += 1
        if attempts > 200:
            # extremely unlikely, but ensures we don't loop forever
            raise RuntimeError("Failed to generate a valid grid after many attempts")

        # Choose a random size (bounded to ARC limits)
        width = random.randint(5, 20)
        height = random.randint(5, 20)

        # Choose number of labeled points (2..9), but never exceed available space
        max_possible = min(9, max(2, (width * height) // 8))
        n = random.randint(2, max_possible)

        # Try to pick n cells that are pairwise non-adjacent (4-neighborhood)
        cells = [(r, c) for r in range(height) for c in range(width)]
        random.shuffle(cells)
        chosen = []
        occupied = set()
        for (r, c) in cells:
            # candidate valid if no already chosen cell is 4-neighbor
            ok = True
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                if (r + dr, c + dc) in occupied:
                    ok = False
                    break
            if not ok:
                continue
            chosen.append((r, c))
            occupied.add((r, c))
            if len(chosen) == n:
                break

        if len(chosen) < n:
            # not enough non-adjacent spots, try again with new size/placement
            continue

        # Assign colors 1..n to chosen positions in a random mapping to vary examples
        order = list(range(n))
        random.shuffle(order)
        pos_by_color = {}
        input_grid = common.grid(width, height, 0)
        for color_idx in range(n):
            pos = chosen[order[color_idx]]
            r, c = pos
            input_grid[r][c] = color_idx + 1
            pos_by_color[color_idx + 1] = pos

        # Build output by connecting each k -> k+1 with shortest path colored k+1
        output_grid = [row[:] for row in input_grid]
        failed = False
        for k in range(1, n):
            start = pos_by_color[k]
            end = pos_by_color[k + 1]
            path = _shortest_path_between(input_grid, start, end)
            if path is None:
                failed = True
                break
            # paint only background cells so original labeled points remain unchanged
            for (r, c) in path:
                if input_grid[r][c] == 0:
                    output_grid[r][c] = k + 1

        if failed:
            # try a fresh layout
            continue

        # Ensure we actually added at least one painted cell (input != output)
        if input_grid == output_grid:
            # very unlikely since points are non-adjacent, but just in case, retry
            continue

        return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    # Convert input (tuple of tuples) to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Find labeled points (colors 1..9)
    points = {}
    for r in range(height):
        for c in range(width):
            val = grid[r][c]
            if 1 <= val <= 9:
                points[val] = (r, c)

    if not points:
        return [tuple(row) for row in grid]

    # Ensure labels are a contiguous sequence 1..n
    n = max(points.keys())
    for k in range(1, n + 1):
        if k not in points:
            # malformed input for this task, return unchanged
            return [tuple(row) for row in grid]

    # BFS neighbor order defines tie-breaks: right, up, down, left
    directions = [(0, 1), (-1, 0), (1, 0), (0, -1)]

    output = [row[:] for row in grid]

    for k in range(1, n):
        start = points[k]
        end = points[k + 1]

        visited = [[False] * width for _ in range(height)]
        parent = {}
        q = deque([start])
        visited[start[0]][start[1]] = True
        found = False

        while q and not found:
            r, c = q.popleft()
            if (r, c) == end:
                found = True
                break
            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc]:
                    # allow moving onto background cells or into the endpoint
                    if grid[nr][nc] == 0 or (nr, nc) == end:
                        visited[nr][nc] = True
                        parent[(nr, nc)] = (r, c)
                        q.append((nr, nc))

        if not found:
            # no path found (shouldn't happen for well-formed generator), skip
            continue

        # Reconstruct path from start (excluded) to end (included)
        path = []
        cur = end
        while cur != start:
            path.append(cur)
            cur = parent[cur]
        path.reverse()

        # Paint only background cells to preserve original labels
        for (r, c) in path:
            if grid[r][c] == 0:
                output[r][c] = k + 1

    return [tuple(row) for row in output]
