# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 1db3291f
Difficulty: insane

=== Tags ===
- Pattern modification
- Color modulated motion
- Select every nth row

=== Description ===
Input grids are rectangular 2D arrays of colored cells, where each cell contains
a number from 0 to 9 representing a distinct visual color. The output grid is
generated through a multi-step transformation that combines selection and
modification based on color properties. First, the value at position (0,0)
determines the step size: if this value is 0, it is treated as 1. Every row
whose index is divisible by this step size is selected for inclusion in the
output. For each selected row, the value in the first column of that row
determines a transformation: if this value is even, the row is reversed; if odd,
the row is rotated left by one position (with the first element wrapping to the
end). The output grid is formed by concatenating these transformed rows in their
original order. This process requires the solver to identify and apply two
distinct color-dependent operations in sequence, leveraging the numerical
properties of colors (which are visually distinguishable in the task) to
determine both row selection and row modification. The solution demands careful
tracking of multiple color values across different grid positions and their
combined effects on the output structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
def generate():
    while True:
        width = random.randint(1, 30)
        height = random.randint(1, 30)
        input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
        step = input_grid[0][0] if input_grid[0][0] != 0 else 1
        selected_rows = [input_grid[i] for i in range(height) if i % step == 0]
        transformed = []
        for row in selected_rows:
            first_val = row[0]
            if first_val % 2 == 0:
                transformed.append(row[::-1])
            else:
                transformed.append(row[1:] + [row[0]])
        output_grid = transformed
        if output_grid != input_grid:
            return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    step = input_list[0][0] if input_list[0][0] != 0 else 1
    selected_rows = [input_list[i] for i in range(len(input_list)) if i % step == 0]
    transformed = []
    for row in selected_rows:
        first_val = row[0]
        if first_val % 2 == 0:
            transformed.append(row[::-1])
        else:
            transformed.append(row[1:] + [row[0]])
    return tuple(tuple(row) for row in transformed)
