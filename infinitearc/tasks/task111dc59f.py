# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 111dc59f
Difficulty: hard

=== Tags ===
- Shape extrusion
- Color transfer on contact
- Expand repeating unit

=== Description ===
**Task Name**: Repeating Shape Expansion with Contact Color Transfer  **Tags**:
Shape extrusion, Color transfer on contact, Expand repeating unit
**Description**:  Input grids display a tiled pattern of distinct, non-
overlapping colored shapes (each shape is a connected region of a single color)
against a uniform background. The pattern repeats periodically across the grid,
with each tile containing the same arrangement of shapes. Shapes do not touch
each other (separated by background cells) and are positioned such that their
relative placement defines the repeating unit.  The output grid is generated
through three sequential transformations:  1. **Shape Extrusion**: Each shape
expands outward by one cell in all four orthogonal directions (up, down, left,
right), but only into background cells. Expansion halts when adjacent to other
shapes' original regions or grid boundaries.  2. **Color Transfer on Contact**:
When expansions from two distinct shapes would occupy the same cell (contact),
the cell adopts a new color determined by a fixed, consistent rule. For example,
a shape of color A and a shape of color B meeting at a cell results in a cell of
color C, where C is predetermined by the pair (A,B) and applies universally
across all such contacts.  3. **Expand Repeating Unit**: The entire repeating
pattern is scaled up, such that each tile in the input is replaced by a larger
tile in the output. The scaling preserves the relative positions of shapes
within the tile, with expanded shapes and contact colors integrated into the new
tile structure. The repetition of the pattern continues seamlessly across the
output grid, now with enlarged tiles.  The output grid must display all expanded
shapes, contact colors, and the scaled repeating pattern without overlapping or
missing elements. Background cells remain unchanged except where overwritten by
expansions or contact transfers.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, connected, random_pixels

def generate_base_tile(T):
    base = [[0] * T for _ in range(T)]
    color1 = random.randint(1, 9)
    color2 = random.randint(1, 9)
    if color1 == color2:
        color2 = 1 if color2 != 1 else 2
    
    # Create top-left shape
    for c in range(T // 2):
        base[0][c] = color1
    
    # Create bottom-right shape
    for r in range(T-1, T//2, -1):
        base[r][T-1] = color2
    
    return base

def generate():
    T = random.randint(2, 4)
    base = generate_base_tile(T)
    rows = random.randint(2, 3)
    cols = random.randint(2, 3)
    
    input_grid = []
    for _ in range(rows):
        for row in base:
            input_grid.append(row * cols)
    
    output_grid = [[0] * len(input_grid[0]) for _ in range(len(input_grid))]
    directions = [(1,0), (-1,0), (0,1), (0,-1)]
    
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] > 0:
                output_grid[r][c] = input_grid[r][c]
            else:
                colors = set()
                for dr, dc in directions:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < len(input_grid) and 0 <= nc < len(input_grid[0]) and input_grid[nr][nc] > 0:
                        colors.add(input_grid[nr][nc])
                if len(colors) == 0:
                    output_grid[r][c] = 0
                elif len(colors) == 1:
                    output_grid[r][c] = next(iter(colors))
                else:
                    a, b = sorted(colors)
                    output_grid[r][c] = (a + b) % 9 + 1
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def contact_color(a, b):
    if a == b:
        return a
    return (a + b) % 9 + 1

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    output = [[0] * width for _ in range(height)]
    directions = [(1,0), (-1,0), (0,1), (0,-1)]
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] > 0:
                output[r][c] = input_grid[r][c]
            else:
                colors = set()
                for dr, dc in directions:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] > 0:
                        colors.add(input_grid[nr][nc])
                if len(colors) == 0:
                    output[r][c] = 0
                elif len(colors) == 1:
                    output[r][c] = next(iter(colors))
                else:
                    a, b = sorted(colors)
                    output[r][c] = contact_color(a, b)
    
    return tuple(tuple(row) for row in output)
