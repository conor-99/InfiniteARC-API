# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 9f5333ab
Difficulty: insane

=== Tags ===
- Elastic wave
- Temporal wave step
- Emergent behavior

=== Description ===
Input grids are large (20×20 or larger) with a uniform gray background. Overlaid
are red dots (pulse sources) and irregularly shaped blue blocks (resonance
dampers). The dampers are single-color barriers that do not touch but may be
adjacent to each other or the grid edges.   The transformation involves
simulating elastic wave propagation from each red dot. Waves travel in four
cardinal directions simultaneously, moving one cell per "temporal step" through
background cells. Upon striking a resonance damper, a wave changes color
cyclically (red → yellow → green → red) and bends 90° clockwise (e.g., right-
moving becomes down-moving). If waves intersect at a cell, the path adopts the
color of the earliest-arriving wave (with color cycle applied per step), and
subsequent waves merge into a single path. Waves continue until exiting the
grid. The output grid renders all wave paths using the color corresponding to
the step when the cell was first entered. Emergent behavior manifests as new
geometric patterns—such as closed loops, symmetrical bridges, or interconnected
networks—formed by merged wave paths, which are not directly visible in the
input. The final output shows only the wave paths, with dampers and sources
unchanged but no longer visible as distinct features (only their influence on
wave direction remains).
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random
from collections import deque


def generate():
    # Grid size between 20 and 30
    size = random.randint(20, 30)
    width = size
    height = size

    # Start with uniform gray background
    grid_input = common.grid(width, height, common.gray())

    # Place several irregular dampers (blue contiguous shapes)
    num_dampers = random.randint(3, 6)
    damper_cells = set()
    dampers = []

    for _ in range(num_dampers):
        # Try to place one damper; use a small bounding box and a contiguous creature sprite
        placed = False
        attempts = 0
        while not placed and attempts < 200:
            attempts += 1
            box_w = random.randint(2, 6)
            box_h = random.randint(2, 6)
            max_cells = box_w * box_h
            size_cells = random.randint(3, max(3, min(max_cells, random.randint(3, max_cells))))
            pixels = common.continuous_creature(size_cells, box_w, box_h)
            # Determine a valid top-left anchor so the sprite fits
            max_pr = max(pr for pr, pc in pixels)
            max_pc = max(pc for pr, pc in pixels)
            r0 = random.randint(0, height - 1 - max_pr)
            c0 = random.randint(0, width - 1 - max_pc)
            candidate = [(r0 + pr, c0 + pc) for pr, pc in pixels]

            # Ensure candidate cells are inside and do not touch existing dampers (no 8-neighbor contact)
            ok = True
            for (r, c) in candidate:
                if not (0 <= r < height and 0 <= c < width):
                    ok = False
                    break
                # cannot overlap or be adjacent (8-neighborhood) to existing damper cells
                for dr in (-1, 0, 1):
                    for dc in (-1, 0, 1):
                        nr, nc = r + dr, c + dc
                        if (nr, nc) in damper_cells:
                            ok = False
                            break
                    if not ok:
                        break
                if not ok:
                    break
            if not ok:
                continue

            # Place the damper
            for (r, c) in candidate:
                grid_input[r][c] = common.blue()
                damper_cells.add((r, c))
            dampers.append(candidate)
            placed = True

    # Choose source candidates: background gray cells that aren't adjacent (8-neighborhood) to dampers
    candidates = []
    for r in range(height):
        for c in range(width):
            if grid_input[r][c] != common.gray():
                continue
            blocked = False
            has_gray_neighbor = False
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    if grid_input[nr][nc] == common.gray():
                        has_gray_neighbor = True
            for dr in (-1, 0, 1):
                for dc in (-1, 0, 1):
                    nr, nc = r + dr, c + dc
                    if (nr, nc) in damper_cells:
                        blocked = True
                        break
                if blocked:
                    break
            if not blocked and has_gray_neighbor:
                candidates.append((r, c))

    if not candidates:
        # If no safe candidates found (very unlikely), allow any gray cell with at least one gray neighbor
        for r in range(height):
            for c in range(width):
                if grid_input[r][c] != common.gray():
                    continue
                for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and grid_input[nr][nc] == common.gray():
                        candidates.append((r, c))
                        break

    num_sources = random.randint(2, 5)
    num_sources = min(num_sources, len(candidates))
    # Pick sources but sort them so the seeding order is deterministic with respect to the input grid
    if num_sources > 0:
        sources = sorted(random.sample(candidates, num_sources))
    else:
        sources = []

    for (r, c) in sources:
        grid_input[r][c] = common.red()

    # Prepare output as a copy of input (waves are drawn on top)
    grid_output = [row[:] for row in grid_input]

    # Multi-source BFS simulation of waves.
    visited = [[False] * width for _ in range(height)]
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # clockwise order: right, down, left, up
    colors = [common.red(), common.yellow(), common.green()]

    q = deque()
    # Seed queue with the immediate neighbors of each source (step 1, hits 0)
    for (sr, sc) in sources:
        for d_idx, (dr, dc) in enumerate(directions):
            nr, nc = sr + dr, sc + dc
            if 0 <= nr < height and 0 <= nc < width and grid_input[nr][nc] == common.gray() and not visited[nr][nc]:
                visited[nr][nc] = True
                q.append((nr, nc, 1, d_idx, 0))

    # If no wave could start (shouldn't happen), try to force one neighbor from a source if possible
    if not q and sources:
        sr, sc = sources[0]
        for d_idx, (dr, dc) in enumerate(directions):
            nr, nc = sr + dr, sc + dc
            if 0 <= nr < height and 0 <= nc < width and grid_input[nr][nc] == common.gray():
                visited[nr][nc] = True
                q.append((nr, nc, 1, d_idx, 0))
                break

    while q:
        r, c, step, d_idx, hits = q.popleft()
        # Color the cell according to arrival step plus any damper-induced cycles (hits)
        color_idx = ((step - 1) + hits) % 3
        if grid_output[r][c] == common.gray():
            grid_output[r][c] = colors[color_idx]

        # Compute next position in current direction, rotating clockwise for blue dampers
        new_d_idx = d_idx
        rotations = 0
        dr, dc = directions[new_d_idx]
        nr, nc = r + dr, c + dc

        # If there's a damper directly ahead, rotate clockwise until a non-damper cell or boundary found
        while 0 <= nr < height and 0 <= nc < width and grid_input[nr][nc] == common.blue():
            new_d_idx = (new_d_idx + 1) % 4
            rotations += 1
            # Prevent infinite rotation if completely surrounded by blue
            if rotations >= 4:
                break
            dr, dc = directions[new_d_idx]
            nr, nc = r + dr, c + dc

        if rotations >= 4:
            # Fully blocked by dampers around this cell
            continue

        # If next step goes off-grid, the wave exits and stops
        if not (0 <= nr < height and 0 <= nc < width):
            continue

        # Waves only travel through background cells; do not enter dampers or sources
        if grid_input[nr][nc] != common.gray():
            continue

        if not visited[nr][nc]:
            visited[nr][nc] = True
            q.append((nr, nc, step + 1, new_d_idx, hits + rotations))

    return {'input': grid_input, 'output': grid_output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
from collections import deque


def p(input_grid):
    # Convert to mutable list of lists
    grid_input = [list(row) for row in input_grid]
    height = len(grid_input)
    width = len(grid_input[0]) if height else 0

    # Prepare output as a copy of input
    grid_output = [row[:] for row in grid_input]

    # Find sources (red dots)
    sources = []
    for r in range(height):
        for c in range(width):
            if grid_input[r][c] == common.red():
                sources.append((r, c))

    # BFS simulation like in the generator
    visited = [[False] * width for _ in range(height)]
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up
    colors = [common.red(), common.yellow(), common.green()]

    q = deque()
    for (sr, sc) in sources:
        for d_idx, (dr, dc) in enumerate(directions):
            nr, nc = sr + dr, sc + dc
            if 0 <= nr < height and 0 <= nc < width and grid_input[nr][nc] == common.gray() and not visited[nr][nc]:
                visited[nr][nc] = True
                q.append((nr, nc, 1, d_idx, 0))

    # If nothing queued but there are sources, try to start at least one neighbor
    if not q and sources:
        sr, sc = sources[0]
        for d_idx, (dr, dc) in enumerate(directions):
            nr, nc = sr + dr, sc + dc
            if 0 <= nr < height and 0 <= nc < width and grid_input[nr][nc] == common.gray():
                visited[nr][nc] = True
                q.append((nr, nc, 1, d_idx, 0))
                break

    while q:
        r, c, step, d_idx, hits = q.popleft()
        # Paint cell if not already painted
        color_idx = ((step - 1) + hits) % 3
        if grid_output[r][c] == common.gray():
            grid_output[r][c] = colors[color_idx]

        # Compute next position and handle dampers (blue) by rotating clockwise
        new_d_idx = d_idx
        rotations = 0
        dr, dc = directions[new_d_idx]
        nr, nc = r + dr, c + dc

        while 0 <= nr < height and 0 <= nc < width and grid_input[nr][nc] == common.blue():
            new_d_idx = (new_d_idx + 1) % 4
            rotations += 1
            if rotations >= 4:
                break
            dr, dc = directions[new_d_idx]
            nr, nc = r + dr, c + dc

        if rotations >= 4:
            continue
        if not (0 <= nr < height and 0 <= nc < width):
            continue
        if grid_input[nr][nc] != common.gray():
            continue
        if not visited[nr][nc]:
            visited[nr][nc] = True
            q.append((nr, nc, step + 1, new_d_idx, hits + rotations))

    # Return as immutable tuple of tuples
    return tuple(tuple(row) for row in grid_output)

