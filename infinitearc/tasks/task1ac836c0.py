# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 1ac836c0
Difficulty: very hard

=== Tags ===
- Mapping by size relation
- Loopless path
- Multi object alignment
- Gravity

=== Description ===
# Task Description  Input grids consist of a uniform background (color 0)
populated with multiple non-overlapping rectangular blocks of varying dimensions
(widths and heights between 2 and 5 cells). Each block has a unique color (1-9)
and occupies a contiguous rectangular area. Blocks are placed at arbitrary
positions without overlapping.  The output grid must transform the input through
the following consistent, deterministic rules:  1. **Gravity application**: All
blocks fall vertically downward until they rest on the grid's bottom edge or
directly on top of another block (i.e., each block's bottom edge aligns with the
grid's bottom or the top edge of the block beneath it).  2. **Multi-object
alignment**: The blocks must be rearranged into a loopless path where
consecutive blocks satisfy a size relation: the width of the current block must
equal the height of the previous block in the sequence. The path must start with
the block having the smallest height and proceed through blocks in a sequence
that never repeats or forms cycles.  3. **Path formation**: The aligned blocks
must form a continuous, single-line path where each consecutive block is
adjacent (horizontally or vertically) to the previous one. The path direction
(horizontal or vertical) is determined by the size relations and must be
consistent for all blocks in the sequence.  4. **Size relation mapping**: The
sequence is determined solely by comparing block dimensions: for blocks A and B
to be consecutive, width(B) must equal height(A). This creates a chain where
each block's dimensions "connect" to the next.  The output grid will display the
blocks arranged in the required path, aligned by gravity, with all background
cells remaining color 0. The path must use every block exactly once, form a
single unbroken line without branches or intersections, and satisfy the size
relation constraint between consecutive blocks. The transformation requires
recognizing the size relation pattern, sequencing the blocks accordingly, and
applying gravity to position all blocks at the grid's bottom.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid


def generate():
    """
    Generator for ARC task 456.

    Produces a grid with a small number of non-overlapping rectangular blocks (colors 1-9),
    and an output grid where the same blocks are arranged left-to-right in a path
    that satisfies width(next) == height(current) and are bottom-aligned (gravity).
    """
    # Number of blocks: choose 3 to keep size-space manageable (heights 2..5)
    num_blocks = random.randint(3, 3)

    # Allowed block side lengths
    SIZE_POOL = [2, 3, 4, 5]

    # Pick distinct heights so the chain is unambiguous
    heights = random.sample(SIZE_POOL, num_blocks)
    heights.sort()  # ensure the smallest height is first (start of path)

    # Choose a width for the first block that is NOT equal to any chosen height
    # (this avoids extra edges back into the chain and makes the path loopless)
    leftover = [s for s in SIZE_POOL if s not in heights]
    if leftover:
        w0 = random.choice(leftover)
    else:
        # Fallback (shouldn't happen for num_blocks==3), pick any valid width
        w0 = random.choice(SIZE_POOL)

    # Build blocks: block 0 has (h0, w0); for i>=1, w_i = h_{i-1} to guarantee width(next)=height(prev)
    blocks = []
    blocks.append((heights[0], w0))
    for i in range(1, num_blocks):
        blocks.append((heights[i], heights[i - 1]))

    # Assign unique colors to blocks
    colors = random.sample(list(range(1, 10)), num_blocks)

    # Compute layout requirements
    total_width = sum(w for h, w in blocks)
    max_height = max(h for h, w in blocks)

    # Choose grid size ensuring there's room for the arranged path at the bottom
    grid_width = random.randint(total_width, 20)
    grid_height = random.randint(max_height, 20)

    def rects_overlap(r1, c1, h1, w1, r2, c2, h2, w2):
        # return True if rectangles overlap (share at least one cell)
        if r1 + h1 <= r2 or r2 + h2 <= r1:  # one is strictly above the other
            return False
        if c1 + w1 <= c2 or c2 + w2 <= c1:  # one is strictly left of the other
            return False
        return True

    # Try to place all blocks randomly (restart whole placement on failure)
    max_placement_attempts = 200
    placed = None
    input_grid = None
    for attempt in range(max_placement_attempts):
        input_grid = grid(grid_width, grid_height, 0)
        placed_list = []
        ok = True
        for i, (h, w) in enumerate(blocks):
            placed_flag = False
            for _ in range(300):
                r = random.randint(0, grid_height - h)
                c = random.randint(0, grid_width - w)
                # check overlap
                overlap = False
                for (pr, pc, ph, pw) in placed_list:
                    if rects_overlap(r, c, h, w, pr, pc, ph, pw):
                        overlap = True
                        break
                if not overlap:
                    # place block
                    col = colors[i]
                    for dr in range(h):
                        for dc in range(w):
                            input_grid[r + dr][c + dc] = col
                    placed_list.append((r, c, h, w))
                    placed_flag = True
                    break
            if not placed_flag:
                ok = False
                break
        if ok:
            placed = placed_list
            break
    # If we couldn't place randomly, deterministically pack left-to-right on a non-zero start column
    if placed is None:
        input_grid = grid(grid_width, grid_height, 0)
        placed = []
        cur_c = 1 if grid_width - total_width >= 1 else 0
        for i, (h, w) in enumerate(blocks):
            r = grid_height - h  # bottom aligned
            c = cur_c
            for dr in range(h):
                for dc in range(w):
                    input_grid[r + dr][c + dc] = colors[i]
            placed.append((r, c, h, w))
            cur_c += w

    # Build output grid: left-to-right ordered path at the bottom (gravity)
    output_grid = grid(grid_width, grid_height, 0)
    cur_c = 0
    for i, (h, w) in enumerate(blocks):
        col = colors[i]
        base_r = grid_height - h  # bottom-aligned
        for dr in range(h):
            for dc in range(w):
                output_grid[base_r + dr][cur_c + dc] = col
        cur_c += w

    # Ensure input != output; if equal, nudge a block slightly
    if input_grid == output_grid:
        # Try moving the first block by one cell if possible
        r, c, h, w = placed[0]
        input_grid = [row[:] for row in input_grid]
        # clear old
        for dr in range(h):
            for dc in range(w):
                input_grid[r + dr][c + dc] = 0
        new_r = r
        new_c = c
        if c + 1 + w <= grid_width:
            new_c = c + 1
        elif r + 1 + h <= grid_height:
            new_r = r + 1
        for dr in range(h):
            for dc in range(w):
                input_grid[new_r + dr][new_c + dc] = colors[0]

    return {
        "input": input_grid,
        "output": output_grid
    }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to list of lists
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])

    # Detect blocks by color and bounding boxes
    boxes = {}  # color -> [min_r, min_c, max_r, max_c]
    for r in range(height):
        for c in range(width):
            col = grid_in[r][c]
            if col == 0:
                continue
            if col not in boxes:
                boxes[col] = [r, c, r, c]
            else:
                b = boxes[col]
                if r < b[0]: b[0] = r
                if c < b[1]: b[1] = c
                if r > b[2]: b[2] = r
                if c > b[3]: b[3] = c

    # Build blocks mapping color -> (h, w)
    blocks = {}
    for col, (min_r, min_c, max_r, max_c) in boxes.items():
        h = max_r - min_r + 1
        w = max_c - min_c + 1
        # Ideally verify it's a filled rectangle; but assume generator produced rectangles
        blocks[col] = (h, w)

    # Build directed adjacency: A -> B if width(B) == height(A)
    graph = {col: [] for col in blocks}
    for a in blocks:
        ha, wa = blocks[a]
        for b in blocks:
            if a == b:
                continue
            hb, wb = blocks[b]
            if wb == ha:
                graph[a].append(b)
    # deterministic neighbor order
    for k in graph:
        graph[k].sort()

    # Start node: smallest height, tie-break by smallest color id
    start = min(blocks.keys(), key=lambda col: (blocks[col][0], col))

    # DFS to find a Hamiltonian path
    n = len(blocks)
    def dfs(path, visited):
        if len(path) == n:
            return path
        last = path[-1]
        for neigh in graph[last]:
            if neigh in visited:
                continue
            visited.add(neigh)
            res = dfs(path + [neigh], visited)
            if res is not None:
                return res
            visited.remove(neigh)
        return None

    path = dfs([start], {start})
    if path is None:
        # fallback: try all possible starts (deterministic order)
        for s in sorted(blocks.keys(), key=lambda col: (blocks[col][0], col)):
            res = dfs([s], {s})
            if res is not None:
                path = res
                break

    if path is None:
        # If no path found, return blank grid
        return [[0] * width for _ in range(height)]

    # Construct output grid: left-to-right, bottom-aligned
    output = [[0] * width for _ in range(height)]
    cur_c = 0
    for col in path:
        h, w = blocks[col]
        base_r = height - h
        for dr in range(h):
            for dc in range(w):
                output[base_r + dr][cur_c + dc] = col
        cur_c += w

    return output

