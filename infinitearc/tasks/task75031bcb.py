# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 75031bcb
Difficulty: insane

=== Tags ===
- Staircase construction
- Pattern intersection
- Energy loss per bounce
- Propagation by rule weight
- Color matching

=== Description ===
Input grids feature a 15×15 to 25×25 grid with a primary staircase path
constructed from connected cells of a single background color (0), forming a
diagonal sequence of right-angled turns from the bottom-left to top-right
corner. This path contains precisely positioned pattern markers (colors 2-9) at
every intersection point where the path changes direction. Scattered along the
path are multiple agents (represented by colors 3-8), each initialized with
energy equal to their color value. Agents begin moving rightward along the path,
following its turns.  The transformation applies these rules sequentially:  1.
Agents move along the staircase path in the current direction until encountering
a pattern marker or grid boundary. 2. At pattern markers, agents check if their
current color matches the marker's color. A match allows straight continuation;
a mismatch triggers a 90° direction change (bounce), reducing energy by 1. 3.
Hitting a grid boundary (wall) triggers a direction change (bounce), reducing
energy by 1. 4. Agents stop when energy reaches 0, marking their final position
with their color. 5. The output grid retains the primary staircase path (color
0) while the agents' stopping positions form a secondary staircase pattern. Each
step aligns with a path intersection, with step height corresponding to the
agent's initial energy minus total bounces. The secondary staircase visually
demonstrates energy loss progression: higher-energy agents (e.g., color 8) stop
at upper steps after more bounces, while lower-energy agents (e.g., color 3)
stop at lower steps after fewer bounces. Pattern markers remain visible but
unchanged, and no two agents occupy the same cell at stopping.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# We'll embed the same solver logic inside the generator to ensure the generator's output
# is computed exactly the same way the solver will compute it. This prevents mismatches
# caused by ordering or subtle differences.

def _compute_output_from_input(ing):
    # ing is a list-of-lists mutable grid
    height = len(ing)
    width = len(ing[0])
    # determine background color (most frequent)
    counts = {}
    for r in range(height):
        for c in range(width):
            v = ing[r][c]
            counts[v] = counts.get(v, 0) + 1
    background = max(counts.items(), key=lambda x: x[1])[0]
    # path cells: any cell not equal to background
    path_set = set()
    for r in range(height):
        for c in range(width):
            if ing[r][c] != background:
                path_set.add((r, c))
    # adjacency map for path
    neighbors = {}
    for (r, c) in path_set:
        neis = []
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if (nr, nc) in path_set:
                neis.append((nr, nc))
        neighbors[(r, c)] = neis
    # choose start
    start = (height - 1, 0)
    if start not in path_set:
        # fallback to any endpoint
        endpoints = [p for p, neis in neighbors.items() if len(neis) <= 1]
        if endpoints:
            start = endpoints[0]
    # reconstruct ordered path
    path = []
    visited = set()
    cur = start
    prev = None
    while True:
        path.append(cur)
        visited.add(cur)
        nexts = [n for n in neighbors.get(cur, []) if n != prev]
        if not nexts:
            break
        prev = cur
        cur = nexts[0]
        if cur in visited:
            break
    # find turn points
    turn_points = set()
    for i in range(1, len(path) - 1):
        r1, c1 = path[i - 1]
        r2, c2 = path[i]
        r3, c3 = path[i + 1]
        if (r2 - r1, c2 - c1) != (r3 - r2, c3 - c2):
            turn_points.add((r2, c2))
    marker_colors = {tp: ing[tp[0]][tp[1]] for tp in turn_points}

    # detect agents (colors 3-8) on non-turn path cells
    agent_starts = []
    for r, c in path:
        if (r, c) in turn_points:
            continue
        val = ing[r][c]
        if 3 <= val <= 8:
            agent_starts.append(((r, c), val))

    # simulation (clockwise rotation on bounce/mismatch)
    def rotate_clockwise(d):
        dr, dc = d
        return (dc, -dr)

    def simulate_agent(start, color):
        r, c = start
        dr, dc = (0, 1)
        energy = color
        while energy > 0:
            nr, nc = r + dr, c + dc
            # boundary bounce
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                energy -= 1
                dr, dc = rotate_clockwise((dr, dc))
                continue
            # marker interaction
            if (nr, nc) in marker_colors:
                marker = marker_colors[(nr, nc)]
                if color == marker:
                    r, c = nr, nc
                else:
                    r, c = nr, nc
                    energy -= 1
                    dr, dc = rotate_clockwise((dr, dc))
            else:
                r, c = nr, nc
        return (r, c)

    finals = []
    colors = []
    for start, col in agent_starts:
        finals.append(simulate_agent(start, col))
        colors.append(col)

    # build output grid
    out = [[background for _ in range(width)] for _ in range(height)]
    for (r, c) in path:
        out[r][c] = 0
    for tp, col in marker_colors.items():
        out[tp[0]][tp[1]] = col
    for pos, col in zip(finals, colors):
        if pos in marker_colors:
            continue
        out[pos[0]][pos[1]] = col
    return out


def generate():
    width = random.randint(15, 25)
    height = random.randint(15, 25)
    background = 1
    path_color = 0

    # create base input grid
    input_grid = grid(width, height, background)

    # choose number of pairs
    max_pairs = min(8, width - 1, height - 1)
    min_pairs = min(3, max_pairs)
    if min_pairs < 2:
        min_pairs = 2
    n_pairs = random.randint(min_pairs, max_pairs)

    # partition helper
    def partition_sum(total, parts):
        if parts == 1:
            return [total]
        cuts = sorted(random.sample(range(1, total), parts - 1))
        parts_list = []
        prev = 0
        for c in cuts:
            parts_list.append(c - prev)
            prev = c
        parts_list.append(total - prev)
        return parts_list

    h_lengths = partition_sum(width - 1, n_pairs)
    v_lengths = partition_sum(height - 1, n_pairs)

    # build path
    path = []
    r, c = height - 1, 0
    path.append((r, c))
    for i in range(n_pairs):
        for _ in range(h_lengths[i]):
            c += 1
            path.append((r, c))
        for _ in range(v_lengths[i]):
            r -= 1
            path.append((r, c))

    path_set = set(path)
    # paint path in input
    for (rr, cc) in path_set:
        input_grid[rr][cc] = path_color

    # turn points
    turn_points = set()
    for i in range(1, len(path) - 1):
        r1, c1 = path[i - 1]
        r2, c2 = path[i]
        r3, c3 = path[i + 1]
        if (r2 - r1, c2 - c1) != (r3 - r2, c3 - c2):
            turn_points.add((r2, c2))

    # place markers on input
    marker_colors = {}
    for tp in turn_points:
        col = random.randint(2, 9)
        input_grid[tp[0]][tp[1]] = col
        marker_colors[tp] = col

    # choose agent candidate positions (prefer horizontal segments)
    horizontal_positions = []
    for i in range(0, len(path) - 1):
        pos = path[i]
        next_pos = path[i + 1]
        if pos in turn_points or next_pos in turn_points:
            continue
        if i == 0 or i == len(path) - 1:
            continue
        if next_pos[0] == pos[0] and next_pos[1] == pos[1] + 1:
            horizontal_positions.append(pos)

    if len(horizontal_positions) < 3:
        horizontal_positions = [p for p in path if p not in turn_points and p != path[0] and p != path[-1]]

    num_agents = random.randint(3, 5)
    num_agents = min(num_agents, len(horizontal_positions))
    agent_positions = random.sample(horizontal_positions, num_agents)

    # place agent colors on input
    agents = []
    for (rr, cc) in agent_positions:
        col = random.randint(3, 8)
        input_grid[rr][cc] = col
        agents.append(((rr, cc), col))

    # Now compute the output using the exact same logic the solver will use
    # If the output doesn't satisfy constraints (unique final positions, not overlapping markers,
    # input != output), then resample agent colors up to a few times.
    tries = 60
    for _ in range(tries):
        out = _compute_output_from_input([list(row) for row in input_grid])
        # check constraints
        # 1) input != output
        if out == input_grid:
            # change agent colors and retry
            agents = []
            for (rr, cc) in agent_positions:
                col = random.randint(3, 8)
                input_grid[rr][cc] = col
                agents.append(((rr, cc), col))
            continue
        # 2) no agent stops on marker
        marker_set = set(marker_colors.keys())
        # collect final agent positions from out by scanning for agent colors at positions that were not markers
        final_positions = []
        for (rr, cc) in agent_positions:
            # find if this agent's color ended somewhere in out; we instead collect all non-marker, non-path background cells with agent colors
            pass
        # We'll simply check that none of the marker coordinates were overwritten by non-marker colors
        overwritten_marker = any(out[tp[0]][tp[1]] != marker_colors[tp] for tp in marker_colors)
        if overwritten_marker:
            # change agent colors and retry
            agents = []
            for (rr, cc) in agent_positions:
                col = random.randint(3, 8)
                input_grid[rr][cc] = col
                agents.append(((rr, cc), col))
            continue
        # 3) unique final positions: quick check by collecting all agent-colored cells in out (exclude markers)
        agent_cells = []
        for r in range(height):
            for c in range(width):
                v = out[r][c]
                if 3 <= v <= 8 and (r, c) not in marker_set:
                    agent_cells.append((r, c))
        if len(agent_cells) != len(set(agent_cells)):
            agents = []
            for (rr, cc) in agent_positions:
                col = random.randint(3, 8)
                input_grid[rr][cc] = col
                agents.append(((rr, cc), col))
            continue
        # All good
        return {'input': input_grid, 'output': out}

    # If we failed to find a satisfying coloring after a number of tries, return the generated grids anyway
    out = _compute_output_from_input([list(row) for row in input_grid])
    return {'input': input_grid, 'output': out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    # Convert to mutable grid
    height = len(input_grid)
    width = len(input_grid[0])
    ing = [list(row) for row in input_grid]

    # Determine background color as the most frequent value
    counts = {}
    for r in range(height):
        for c in range(width):
            v = ing[r][c]
            counts[v] = counts.get(v, 0) + 1
    background = max(counts.items(), key=lambda x: x[1])[0]

    # Path cells are those not equal to background
    path_set = set()
    for r in range(height):
        for c in range(width):
            if ing[r][c] != background:
                path_set.add((r, c))

    # Build adjacency for path cells
    neighbors = {}
    for (r, c) in path_set:
        neis = []
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if (nr, nc) in path_set:
                neis.append((nr, nc))
        neighbors[(r, c)] = neis

    # Find endpoints (degree 1) and prefer bottom-left as start
    endpoints = [p for p, neis in neighbors.items() if len(neis) <= 1]
    start = (height - 1, 0)
    if start not in path_set:
        if endpoints:
            start = endpoints[0]

    # Walk the path in order
    path = []
    visited = set()
    cur = start
    prev = None
    while True:
        path.append(cur)
        visited.add(cur)
        nexts = [n for n in neighbors[cur] if n != prev]
        if not nexts:
            break
        prev = cur
        cur = nexts[0]
        if cur in visited:
            break

    # Determine turn points (where the direction changes)
    turn_points = set()
    for i in range(1, len(path) - 1):
        r1, c1 = path[i - 1]
        r2, c2 = path[i]
        r3, c3 = path[i + 1]
        v1 = (r2 - r1, c2 - c1)
        v2 = (r3 - r2, c3 - c2)
        if v1 != v2:
            turn_points.add((r2, c2))

    # Marker colors from input
    marker_colors = {tp: ing[tp[0]][tp[1]] for tp in turn_points}

    # Detect agents: colors 3-8 on non-turn path cells
    agent_starts = []
    for r, c in path:
        if (r, c) in turn_points:
            continue
        val = ing[r][c]
        if 3 <= val <= 8:
            agent_starts.append(((r, c), val))

    # Movement simulation (must mirror generator logic)
    def rotate_clockwise(d):
        dr, dc = d
        return (dc, -dr)

    def simulate_agent(start, color):
        r, c = start
        dr, dc = (0, 1)
        energy = color
        while energy > 0:
            nr, nc = r + dr, c + dc
            # boundary bounce
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                energy -= 1
                dr, dc = rotate_clockwise((dr, dc))
                continue
            # marker interaction
            if (nr, nc) in marker_colors:
                marker = marker_colors[(nr, nc)]
                if color == marker:
                    r, c = nr, nc
                else:
                    r, c = nr, nc
                    energy -= 1
                    dr, dc = rotate_clockwise((dr, dc))
            else:
                r, c = nr, nc
        return (r, c)

    finals = []
    colors = []
    for start, col in agent_starts:
        finals.append(simulate_agent(start, col))
        colors.append(col)

    # Build output grid: start from background, paint path (0), markers, then agent final positions
    out = [[background for _ in range(width)] for _ in range(height)]
    for (r, c) in path:
        out[r][c] = 0
    for tp, col in marker_colors.items():
        out[tp[0]][tp[1]] = col
    for pos, col in zip(finals, colors):
        if pos in marker_colors:
            # markers remain unchanged
            continue
        out[pos[0]][pos[1]] = col

    return out

