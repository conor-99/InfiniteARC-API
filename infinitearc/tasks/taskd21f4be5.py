# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: d21f4be5
Difficulty: hard

=== Tags ===
- Portal momentum pathing
- Hierarchical repetition
- Detect hor lines
- Obstacles

=== Description ===
The task involves transforming an input grid into an output grid through a
series of visual, hierarchical operations based on pathing dynamics and
structural detection. Input grids contain three distinct visual elements:
**horizontal lines** (represented by color 5), **obstacles** (color 6), and a
**path** (color 3). The path begins at the leftmost cell of the topmost row
containing color 3 and moves rightward with momentum. Upon encountering a
horizontal line (color 5), the path reflects (alternating direction between
upward and downward for each reflection) while maintaining momentum. Obstacles
(color 6) halt the path entirely.   The output grid preserves all horizontal
lines and obstacles but replaces the path with a **hierarchical repetition** of
its trajectory. Specifically, for each segment of the path between two
horizontal lines (or between the start and the first horizontal line), the
output includes two scaled-down copies of that segment: one positioned above the
horizontal line and one below, each reduced to half the original segment length.
The scaling is applied recursively, creating a nested structure where each
reflection point generates a new layer of smaller paths. Obstacles are retained
as blockers but do not contribute to the hierarchical structure. The
transformation requires detecting horizontal lines, tracking path momentum,
reflecting directionally, and applying recursive scaling to generate the
outputâ€™s layered path pattern.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(5, 20)
    height = random.randint(5, 20)
    input_grid = grid(width, height, 0)
    
    # Place horizontal lines (color 5)
    for _ in range(random.randint(2, 5)):
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        input_grid[r][c] = 5
    
    # Place obstacles (color 6)
    for _ in range(random.randint(1, 3)):
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        input_grid[r][c] = 6
    
    # Generate path starting at (0,0)
    input_grid[0][0] = 3
    r, c = 0, 0
    direction = (0, 1)  # right
    
    while True:
        nr, nc = r + direction[0], c + direction[1]
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        if input_grid[nr][nc] == 5:
            # Reflect direction
            direction = (direction[1], -direction[0])
        elif input_grid[nr][nc] == 6:
            break
        else:
            input_grid[nr][nc] = 3
            r, c = nr, nc
    
    # Create output grid with hierarchical repetition
    output_grid = grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 5:
                output_grid[r][c] = 5
            elif input_grid[r][c] == 6:
                output_grid[r][c] = 6
    
    # Add hierarchical path copies based on parity
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 3 and r % 2 == 0 and c % 2 == 0:
                output_grid[r][c] = 3
                if r > 0:
                    output_grid[r-1][c] = 3
                if r < height-1:
                    output_grid[r+1][c] = 3
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = grid(width, height, 0)
    
    # Preserve horizontal lines (color 5) and obstacles (color 6)
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 5 or input_grid[r][c] == 6:
                output_grid[r][c] = input_grid[r][c]
    
    # Generate hierarchical path copies using parity check
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 3 and r % 2 == 0 and c % 2 == 0:
                output_grid[r][c] = 3
                if r > 0:
                    output_grid[r-1][c] = 3
                if r < height-1:
                    output_grid[r+1][c] = 3
    
    return output_grid
