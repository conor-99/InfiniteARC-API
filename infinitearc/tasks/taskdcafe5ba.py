# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: dcafe5ba
Difficulty: hard

=== Tags ===
- Coordinate system translation
- Local rule cascade
- Pattern intersection
- Circuit reflection
- Draw line from border
- Direction guesingcrop

=== Description ===
Input grids are 20×20 or larger, featuring a background color (0) and multiple
distinct elements. Directional markers—single cells of color 5—appear on the
grid's perimeter (top/bottom/left/right edges), with their border position
determining the initial path direction: top-edge markers start paths moving
downward, bottom-edge markers start upward paths, left-edge markers start
rightward paths, and right-edge markers start leftward paths. Reflection nodes
(color 6) are scattered within the grid (not on borders), reversing a path's
direction upon contact (e.g., right → left, up → down). The grid may contain
pre-existing intersection points (color 7), but these are not part of the input
and are generated in the output where paths cross.  The transformation process
involves:   1. For each directional marker, initiate a path in its border-
determined direction.   2. Trace the path cell-by-cell over background (0),
marking each step with color 8.   3. Upon hitting a reflection node (6), reverse
direction and continue tracing through the node (the node remains color 6).   4.
If two paths cross at a cell (both would mark it as color 8), replace it with
color 7 (intersection point), and both paths continue through the cell without
direction change.   5. Paths terminate when exiting the grid (reaching another
border), with no drawing beyond the border.    The output grid retains all input
elements (directional markers, reflection nodes, pre-existing intersections) and
adds circuit paths (color 8) and new intersection points (color 7) as defined.
This task demands sequential path tracing across multiple reflections, careful
conflict resolution at intersections, and inference of path directions from
border markers—all requiring layered reasoning to handle overlapping paths and
dynamic direction changes.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = 20
    height = 20
    grid = [[0] * width for _ in range(height)]
    
    top = [(0, c) for c in range(1, width-1)]
    bottom = [(height-1, c) for c in range(1, width-1)]
    left = [(r, 0) for r in range(1, height-1)]
    right = [(r, width-1) for r in range(1, height-1)]
    edges = top + bottom + left + right
    num_markers = random.randint(3, 5)
    markers = random.sample(edges, num_markers)
    
    for r, c in markers:
        grid[r][c] = 5
    
    interior = [(r, c) for r in range(1, height-1) for c in range(1, width-1)]
    num_reflections = random.randint(3, 5)
    reflections = random.sample(interior, num_reflections)
    
    for r, c in reflections:
        grid[r][c] = 6
    
    output = [row[:] for row in grid]
    path_count = [[0] * width for _ in range(height)]
    
    def get_direction(r, c):
        if r == 0:
            return (1, 0)
        if r == height-1:
            return (-1, 0)
        if c == 0:
            return (0, 1)
        if c == width-1:
            return (0, -1)
        return (0, 0)
    
    for r, c in markers:
        dr, dc = get_direction(r, c)
        cr, cc = r + dr, c + dc
        visited = set()
        while 0 <= cr < height and 0 <= cc < width:
            state = (cr, cc, dr, dc)
            if state in visited:
                break
            visited.add(state)
            
            if grid[cr][cc] == 6:
                dr, dc = -dr, -dc
                cr += dr
                cc += dc
                continue
            
            path_count[cr][cc] += 1
            cr += dr
            cc += dc
    
    for r in range(height):
        for c in range(width):
            if path_count[r][c] == 1:
                output[r][c] = 8
            elif path_count[r][c] > 1:
                output[r][c] = 7
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    markers = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 5 and (r == 0 or r == height-1 or c == 0 or c == width-1):
                markers.append((r, c))
    
    path_count = [[0] * width for _ in range(height)]
    
    def get_direction(r, c):
        if r == 0:
            return (1, 0)
        if r == height-1:
            return (-1, 0)
        if c == 0:
            return (0, 1)
        if c == width-1:
            return (0, -1)
        return (0, 0)
    
    for r, c in markers:
        dr, dc = get_direction(r, c)
        cr, cc = r + dr, c + dc
        visited = set()
        while 0 <= cr < height and 0 <= cc < width:
            state = (cr, cc, dr, dc)
            if state in visited:
                break
            visited.add(state)
            
            if grid[cr][cc] == 6:
                dr, dc = -dr, -dc
                cr += dr
                cc += dc
                continue
            
            path_count[cr][cc] += 1
            cr += dr
            cc += dc
    
    output = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if path_count[r][c] == 1:
                output[r][c] = 8
            elif path_count[r][c] > 1:
                output[r][c] = 7
    
    return output
