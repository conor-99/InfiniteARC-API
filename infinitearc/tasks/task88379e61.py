# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 88379e61
Difficulty: hard

=== Tags ===
- Sort columns by criteria
- Layered occlusion unfolding
- Periodic boundary conditions

=== Description ===
The task involves transforming an input grid into an output grid by sorting its
columns based on a specific visual criterion that requires unfolding layered
occlusions through periodic boundary conditions. Each input grid is a 2D array
of colors (0-9), where color 5 represents the target for the sorting key. For
each column, the sorting key is determined by the smallest row index where color
5 appears when traversing the column in a circular manner (i.e., after reaching
the bottom row, the traversal continues from the top row). If color 5 does not
appear in a column, the key defaults to the gridâ€™s height, placing such columns
at the end of the sorted order. The output grid is formed by rearranging the
input columns in ascending order of these keys, preserving all original column
contents. This process requires recognizing the circular traversal pattern
(periodic boundary) to correctly identify the key position, despite the presence
of occluded color patterns in some columns, and avoids reliance on numerical
properties of colors or pixel-level analysis.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    while True:
        width = random.randint(2, 30)
        height = random.randint(1, 30)
        input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
        keys = []
        for c in range(width):
            has_5 = random.random() < 0.8
            if has_5:
                k = random.randint(0, height-1)
                for r in range(k):
                    input_grid[r][c] = random.choice([i for i in range(10) if i != 5])
                input_grid[k][c] = 5
                for r in range(k+1, height):
                    input_grid[r][c] = random.randint(0, 9)
                keys.append(k)
            else:
                for r in range(height):
                    input_grid[r][c] = random.choice([i for i in range(10) if i != 5])
                keys.append(height)
        sorted_indices = sorted(range(width), key=lambda c: keys[c])
        output_grid = [[input_grid[r][c] for c in sorted_indices] for r in range(height)]
        if input_grid != output_grid:
            return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    keys = []
    for c in range(width):
        for r in range(height):
            if input_grid[r][c] == 5:
                keys.append(r)
                break
        else:
            keys.append(height)
    sorted_indices = sorted(range(width), key=lambda c: keys[c])
    output_grid = [[input_grid[r][c] for c in sorted_indices] for r in range(height)]
    return output_grid
