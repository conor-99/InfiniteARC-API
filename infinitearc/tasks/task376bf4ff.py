# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 376bf4ff
Difficulty: hard

=== Tags ===
- Transformation stack

=== Description ===
The input grids are medium-sized (15×15) with a background color (0) and
multiple disconnected colored objects (1-9) arranged in distinct shapes. The
output grid is generated by applying three sequential transformations to the
input grid:   1. **Per-object rotation**: Each connected component (object) is
rotated 90° clockwise around its geometric center (determined by the bounding
box of the object), maintaining its position within the grid. Objects with even
dimensions may require rounding the center point.  2. **Global mirroring**: The
entire grid is mirrored horizontally (left-right flip), applying to the result
of the rotation step.  3. **Color cycle**: A cyclic color mapping is applied to
all non-background colors: 1 → 4, 2 → 5, 3 → 6, 4 → 1 (colors 5-9 remain
unchanged).  The background color (0) remains unchanged throughout all
transformations. The challenge lies in recognizing that the first transformation
acts on individual objects (not the entire grid), requiring the solver to
identify connected components and apply object-specific geometry. The subsequent
steps combine global grid manipulation with a non-obvious color mapping,
demanding compositional reasoning across multiple transformation layers.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    size = 15
    grid = common.grid(size, size, 0)
    colors = list(range(1, 10))
    random.shuffle(colors)
    num_objects = random.randint(2, 4)
    placed = []
    for _ in range(num_objects):
        color = colors.pop()
        r = random.randint(0, size - 3)
        c = random.randint(0, size - 3)
        while any((r + dr, c + dc) in placed for dr in range(3) for dc in range(3)):
            r = random.randint(0, size - 3)
            c = random.randint(0, size - 3)
        for dr in range(3):
            for dc in range(3):
                grid[r + dr][c + dc] = color
                placed.append((r + dr, c + dc))
    rotated = [row[:] for row in grid]
    for color in range(1, 10):
        pixels = [(r, c) for r in range(size) for c in range(size) if grid[r][c] == color]
        if not pixels:
            continue
        min_r, max_r = min(p[0] for p in pixels), max(p[0] for p in pixels)
        min_c, max_c = min(p[1] for p in pixels), max(p[1] for p in pixels)
        cx, cy = (min_r + max_r) / 2.0, (min_c + max_c) / 2.0
        new_pixels = []
        for (r, c) in pixels:
            new_r = cx + (c - cy)
            new_c = cy - (r - cx)
            new_pixels.append((int(round(new_r)), int(round(new_c))))
        for (r, c) in pixels:
            rotated[r][c] = 0
        for (r, c) in new_pixels:
            if 0 <= r < size and 0 <= c < size:
                rotated[r][c] = color
    mirrored = [row[::-1] for row in rotated]
    output = [row[:] for row in mirrored]
    for r in range(size):
        for c in range(size):
            if output[r][c] == 1:
                output[r][c] = 4
            elif output[r][c] == 2:
                output[r][c] = 5
            elif output[r][c] == 3:
                output[r][c] = 6
            elif output[r][c] == 4:
                output[r][c] = 1
    return {'input': grid, 'output': output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    size = len(input_grid)
    rotated = [row[:] for row in input_grid]
    for color in range(1, 10):
        pixels = [(r, c) for r in range(size) for c in range(size) if input_grid[r][c] == color]
        if not pixels:
            continue
        min_r, max_r = min(p[0] for p in pixels), max(p[0] for p in pixels)
        min_c, max_c = min(p[1] for p in pixels), max(p[1] for p in pixels)
        cx, cy = (min_r + max_r) / 2.0, (min_c + max_c) / 2.0
        new_pixels = []
        for (r, c) in pixels:
            new_r = cx + (c - cy)
            new_c = cy - (r - cx)
            new_pixels.append((int(round(new_r)), int(round(new_c))))
        for (r, c) in pixels:
            rotated[r][c] = 0
        for (r, c) in new_pixels:
            if 0 <= r < size and 0 <= c < size:
                rotated[r][c] = color
    mirrored = [row[::-1] for row in rotated]
    output = [row[:] for row in mirrored]
    for r in range(size):
        for c in range(size):
            if output[r][c] == 1:
                output[r][c] = 4
            elif output[r][c] == 2:
                output[r][c] = 5
            elif output[r][c] == 3:
                output[r][c] = 6
            elif output[r][c] == 4:
                output[r][c] = 1
    return output
