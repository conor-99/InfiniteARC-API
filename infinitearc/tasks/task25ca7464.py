# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 25ca7464
Difficulty: easy

=== Tags ===
- Fill holes
- Contouring
- Detect closed curves
- Mark centroid

=== Description ===
The input grid contains a single closed contour (a loop of connected cells
forming a boundary) made of a distinct color, enclosing an area that may contain
empty cells (holes). The transformation process involves two main steps: first,
filling all empty cells inside the closed contour with a consistent new color
(e.g., replacing all 0s within the contour with color 2), and second,
identifying the centroid (geometric center) of the filled region and marking it
with a distinct marker color (e.g., color 3). The contour itself remains
unchanged in the output. For example, a 5Ã—5 input with a square contour (color
1) and one empty cell in the center would result in the center cell being filled
with color 2 and then changed to color 3 in the output. This task requires
recognizing closed boundaries, identifying enclosed regions, and applying simple
geometric marking rules, all of which are visually intuitive for an "easy"
difficulty level.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid
def generate():
    W = random.randint(3, 30)
    H = random.randint(3, 30)
    input_grid = grid(W, H, 0)
    for i in range(W):
        input_grid[0][i] = 1
        input_grid[H-1][i] = 1
    for i in range(1, H-1):
        input_grid[i][0] = 1
        input_grid[i][W-1] = 1
    output_grid = [row[:] for row in input_grid]
    for i in range(1, H-1):
        for j in range(1, W-1):
            output_grid[i][j] = 2
    cr = (H - 1) // 2
    cc = (W - 1) // 2
    output_grid[cr][cc] = 3
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    H = len(input_grid)
    W = len(input_grid[0])
    output_grid = [list(row) for row in input_grid]
    for i in range(1, H-1):
        for j in range(1, W-1):
            output_grid[i][j] = 2
    cr = (H - 1) // 2
    cc = (W - 1) // 2
    output_grid[cr][cc] = 3
    return output_grid
