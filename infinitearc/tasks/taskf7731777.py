# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: f7731777
Difficulty: very hard

=== Tags ===
- Gravity with barriers
- Spring chain
- Heat map draw
- Relational projection
- Center object in canvas
- Only one

=== Description ===
The task involves transforming a grid by applying gravitational forces to a
spring chain structure, then generating a heat map based on the chain's new
position. The input grid features a single central object (a solitary cell of a
unique color positioned at the grid's geometric center), surrounded by barriers
(walls of a distinct color that obstruct movement), and a spring chainâ€”a
connected sequence of cells forming a linear or curved structure that is
initially suspended above a barrier.   First, the spring chain undergoes
gravitational pull, moving downward as a cohesive unit until it makes contact
with a barrier or the grid's bottom edge. This movement is constrained by the
grid's boundaries and barriers; the chain cannot pass through barriers or
overlap with them.   Next, a heat map is generated by projecting a radial
gradient from the spring chain's final position. The intensity of the heat map
(represented by a progression of colors) decreases with increasing Manhattan
distance from the nearest cell of the spring chain. The gradient uses a
contiguous range of colors, with the highest intensity (e.g., the most vibrant
color) assigned to spring chain cells themselves, and lower intensities assigned
to cells farther away. Barriers remain visible as solid blocks, the central
object retains its original position and color, and the background is replaced
by the heat map gradient.   The output grid must satisfy all constraints: the
spring chain is correctly positioned after gravity, the heat map accurately
reflects distance-based intensity, and all original elements (barriers, central
object) are preserved in their respective locations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    w = random.randint(10, 20)
    h = random.randint(10, 20)
    grid = [[0] * w for _ in range(h)]
    center_x = h // 2
    center_y = w // 2
    grid[center_x][center_y] = 1
    barrier_offset = random.randint(2, 5)
    barrier_row = center_x + barrier_offset
    if barrier_row >= h:
        barrier_row = h - 1
    for c in range(center_y - 1, center_y + 2):
        if 0 <= c < w:
            grid[barrier_row][c] = 2
    spring_start = barrier_row - 3
    if spring_start < 0:
        spring_start = 0
    for r in range(spring_start, spring_start + 3):
        if 0 <= r < h:
            grid[r][center_y] = 3
    spring_cells = []
    for r in range(h):
        for c in range(w):
            if grid[r][c] == 3:
                spring_cells.append((r, c))
    min_steps = h
    for r, c in spring_cells:
        steps = 0
        while r + steps + 1 < h and grid[r + steps + 1][c] == 0:
            steps += 1
        if steps < min_steps:
            min_steps = steps
    for r, c in spring_cells:
        grid[r][c] = 0
    for r, c in spring_cells:
        new_r = r + min_steps
        if new_r < h:
            grid[new_r][c] = 3
    output = [[0] * w for _ in range(h)]
    for r in range(h):
        for c in range(w):
            if grid[r][c] == 2 or grid[r][c] == 1:
                output[r][c] = grid[r][c]
            else:
                min_dist = h + w
                for sr in range(h):
                    for sc in range(w):
                        if grid[sr][sc] == 3:
                            dist = abs(r - sr) + abs(c - sc)
                            if dist < min_dist:
                                min_dist = dist
                color = 4 + min(min_dist, 5)
                output[r][c] = color
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])
    spring_cells = []
    for r in range(h):
        for c in range(w):
            if grid[r][c] == 3:
                spring_cells.append((r, c))
    min_steps = h
    for r, c in spring_cells:
        steps = 0
        while r + steps + 1 < h and grid[r + steps + 1][c] == 0:
            steps += 1
        if steps < min_steps:
            min_steps = steps
    new_spring_cells = [(r + min_steps, c) for r, c in spring_cells]
    output = [[0] * w for _ in range(h)]
    for r in range(h):
        for c in range(w):
            if grid[r][c] == 2 or grid[r][c] == 1:
                output[r][c] = grid[r][c]
            else:
                min_dist = h + w
                for sr, sc in new_spring_cells:
                    dist = abs(r - sr) + abs(c - sc)
                    if dist < min_dist:
                        min_dist = dist
                color = 4 + min(min_dist, 5)
                output[r][c] = color
    return output
