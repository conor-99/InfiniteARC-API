# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 06b2ffc9
Difficulty: insane

=== Tags ===
- Periodic offset matching
- Coordinate warp
- Tiled majority vote
- Reflect by color

=== Description ===
Input grids are 25×25 grids with background color 0 (black), containing multiple
distinct colored regions (colors 1–9). The grid features irregularly shaped
colored clusters that form natural tile boundaries. The transformation process
involves four interdependent steps:  1. **Tiled Majority Vote**: The grid is
divided into non-overlapping 3×3 tiles. For each tile, the majority color
(ignoring background 0) is determined. In case of a tie, the smallest color
number is selected.  2. **Reflect by Color**: Each tile is reflected based on
its majority color:    - Color 1 (red) → Horizontal reflection (left-right flip)
- Color 2 (blue) → Vertical reflection (up-down flip)    - Color 3 (green) →
Main diagonal reflection (top-left to bottom-right)    - Color 4 (yellow) →
Anti-diagonal reflection (top-right to bottom-left)    - Colors 5–9 → Use (color
mod 4), with 0 interpreted as 4 (e.g., color 5 → color 1)  3. **Periodic Offset
Matching**: After reflection, the tiles are reassembled. For every tile row
index divisible by 3 (0, 3, 6, ...), each tile in that row is shifted right by 1
cell (wrapping to the left edge if necessary). This creates a periodic
horizontal offset pattern across the grid.  4. **Coordinate Warp**: The entire
grid undergoes a coordinate transformation where each cell at position (x, y) is
mapped to (x + (y mod 3), y + (x mod 3)). This non-linear warp distorts the grid
in a periodic, wave-like pattern aligned with the offset from Step 3.  The
output grid combines all transformations: reflected tiles (Step 2) arranged with
periodic offsets (Step 3), then warped to create a visually complex, yet
deterministic, pattern. Background 0 cells remain unchanged, while all colored
regions are transformed through the four-step process. No two input grids
produce identical outputs, and the transformation is fully reversible through
the described rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from typing import List, Tuple

def generate():
    width = 25
    height = 25
    input_grid = [[0] * width for _ in range(height)]
    
    # Create multiple colored clusters
    colors = list(range(1, 10))
    for _ in range(random.randint(3, 6)):
        color = random.choice(colors)
        center_x = random.randint(0, width-1)
        center_y = random.randint(0, height-1)
        for r in range(max(0, center_y-2), min(height, center_y+3)):
            for c in range(max(0, center_x-2), min(width, center_x+3)):
                if random.random() > 0.4:
                    input_grid[r][c] = color
    
    # Ensure non-empty grid
    if all(cell == 0 for row in input_grid for cell in row):
        input_grid[0][0] = 1
    
    # Apply transformations to get output
    output_grid = apply_reflections(input_grid)
    output_grid = apply_periodic_offset(output_grid)
    output_grid = apply_coordinate_warp(output_grid)
    
    return {"input": input_grid, "output": output_grid}

def majority_vote(tile):
    counts = [0] * 10
    for row in tile:
        for color in row:
            if color != 0:
                counts[color] += 1
    if max(counts) == 0:
        return 0
    max_count = max(counts)
    for color in range(1, 10):
        if counts[color] == max_count:
            return color
    return 0

def reflect_tile(tile, color):
    if 5 <= color <= 9:
        mod_color = color % 4
        color = mod_color if mod_color != 0 else 4
    
    if color == 1:
        return [row[::-1] for row in tile]
    if color == 2:
        return tile[::-1]
    if color == 3:
        return [list(x) for x in zip(*tile)]
    if color == 4:
        flipped = [row[::-1] for row in tile]
        return [list(x) for x in zip(*flipped)]
    return tile

def apply_reflections(grid):
    tile_size = 3
    height, width = len(grid), len(grid[0])
    tiles = []
    for i in range(0, height, tile_size):
        for j in range(0, width, tile_size):
            tile = []
            for r in range(i, min(i + tile_size, height)):
                tile.append(grid[r][j:j+tile_size])
            tiles.append((i, j, tile))
    
    reflected_tiles = []
    for i, j, tile in tiles:
        majority = majority_vote(tile)
        reflected_tile = reflect_tile(tile, majority)
        reflected_tiles.append((i, j, reflected_tile))
    
    output_grid = [[0] * width for _ in range(height)]
    for i, j, tile in reflected_tiles:
        for r in range(len(tile)):
            for c in range(len(tile[0])):
                if i + r < height and j + c < width:
                    output_grid[i + r][j + c] = tile[r][c]
    return output_grid

def apply_periodic_offset(grid):
    tile_size = 3
    height, width = len(grid), len(grid[0])
    num_tile_rows = (height + tile_size - 1) // tile_size
    num_tile_cols = (width + tile_size - 1) // tile_size
    
    tile_grid = []
    for i in range(num_tile_rows):
        tile_row = []
        for j in range(num_tile_cols):
            start_i, start_j = i * tile_size, j * tile_size
            tile = []
            for r in range(start_i, min(start_i + tile_size, height)):
                tile.append(grid[r][start_j:start_j + tile_size])
            tile_row.append(tile)
        tile_grid.append(tile_row)
    
    for i in range(num_tile_rows):
        if i % 3 == 0:
            tile_grid[i] = [tile_grid[i][-1]] + tile_grid[i][:-1]
    
    output_grid = [[0] * width for _ in range(height)]
    for i in range(num_tile_rows):
        for j in range(num_tile_cols):
            tile = tile_grid[i][j]
            start_i, start_j = i * tile_size, j * tile_size
            for r in range(len(tile)):
                for c in range(len(tile[0])):
                    if start_i + r < height and start_j + c < width:
                        output_grid[start_i + r][start_j + c] = tile[r][c]
    return output_grid

def apply_coordinate_warp(grid):
    height = len(grid)
    width = len(grid[0])
    output_grid = [[0] * width for _ in range(height)]
    for x in range(height):
        for y in range(width):
            new_x = (x + (y % 3)) % height
            new_y = (y + (x % 3)) % width
            output_grid[new_x][new_y] = grid[x][y]
    return output_grid


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    grid = apply_reflections(grid)
    grid = apply_periodic_offset(grid)
    grid = apply_coordinate_warp(grid)
    return grid

def apply_reflections(grid):
    tile_size = 3
    height, width = len(grid), len(grid[0])
    tiles = []
    for i in range(0, height, tile_size):
        for j in range(0, width, tile_size):
            tile = []
            for r in range(i, min(i + tile_size, height)):
                tile.append(grid[r][j:j+tile_size])
            tiles.append((i, j, tile))
    
    reflected_tiles = []
    for i, j, tile in tiles:
        majority = majority_vote(tile)
        reflected_tile = reflect_tile(tile, majority)
        reflected_tiles.append((i, j, reflected_tile))
    
    output_grid = [[0] * width for _ in range(height)]
    for i, j, tile in reflected_tiles:
        for r in range(len(tile)):
            for c in range(len(tile[0])):
                if i + r < height and j + c < width:
                    output_grid[i + r][j + c] = tile[r][c]
    return output_grid

def majority_vote(tile):
    counts = [0] * 10
    for row in tile:
        for color in row:
            if color != 0:
                counts[color] += 1
    if max(counts) == 0:
        return 0
    max_count = max(counts)
    for color in range(1, 10):
        if counts[color] == max_count:
            return color
    return 0

def reflect_tile(tile, color):
    if 5 <= color <= 9:
        mod_color = color % 4
        color = mod_color if mod_color != 0 else 4
    
    if color == 1:
        return [row[::-1] for row in tile]
    if color == 2:
        return tile[::-1]
    if color == 3:
        return [list(x) for x in zip(*tile)]
    if color == 4:
        flipped = [row[::-1] for row in tile]
        return [list(x) for x in zip(*flipped)]
    return tile

def apply_periodic_offset(grid):
    tile_size = 3
    height, width = len(grid), len(grid[0])
    num_tile_rows = (height + tile_size - 1) // tile_size
    num_tile_cols = (width + tile_size - 1) // tile_size
    
    tile_grid = []
    for i in range(num_tile_rows):
        tile_row = []
        for j in range(num_tile_cols):
            start_i, start_j = i * tile_size, j * tile_size
            tile = []
            for r in range(start_i, min(start_i + tile_size, height)):
                tile.append(grid[r][start_j:start_j + tile_size])
            tile_row.append(tile)
        tile_grid.append(tile_row)
    
    for i in range(num_tile_rows):
        if i % 3 == 0:
            tile_grid[i] = [tile_grid[i][-1]] + tile_grid[i][:-1]
    
    output_grid = [[0] * width for _ in range(height)]
    for i in range(num_tile_rows):
        for j in range(num_tile_cols):
            tile = tile_grid[i][j]
            start_i, start_j = i * tile_size, j * tile_size
            for r in range(len(tile)):
                for c in range(len(tile[0])):
                    if start_i + r < height and start_j + c < width:
                        output_grid[start_i + r][start_j + c] = tile[r][c]
    return output_grid

def apply_coordinate_warp(grid):
    height = len(grid)
    width = len(grid[0])
    output_grid = [[0] * width for _ in range(height)]
    for x in range(height):
        for y in range(width):
            new_x = (x + (y % 3)) % height
            new_y = (y + (x % 3)) % width
            output_grid[new_x][new_y] = grid[x][y]
    return output_grid
