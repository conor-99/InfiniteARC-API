# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 9a892713
Difficulty: very hard

=== Tags ===
- Loopless feedback
- Staircase construction
- Wraparound copy

=== Description ===
Input grids feature a sparse arrangement of uniquely colored "anchor" cells,
typically appearing in isolated positions without alignment along any diagonal.
Each anchor cell is a distinct color (e.g., red, blue, green) but the specific
color is irrelevant to the transformation—only the spatial pattern matters. The
output grid must construct a diagonal "staircase" for each anchor cell by
extending a sequence of the same color in the northeast direction (down-right),
wrapping around grid boundaries (right edge wraps to left, bottom edge wraps to
top). Each staircase continues for exactly the grid's maximum dimension (e.g.,
30 cells in a 30×30 grid), but stops before overlapping with any existing
staircase from another anchor. The transformation is strictly loopless—no
staircase ever revisits a cell—and wraparound ensures seamless continuation
across edges. Background cells remain unchanged except where staircases are
added. The key challenge lies in resolving spatial conflicts when multiple
staircases would intersect, requiring the solver to prioritize anchors based on
their row-major order (top-left to bottom-right) to determine which staircase
occupies a cell.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(2, 30)
    height = random.randint(2, 30)
    max_dim = max(width, height)
    num_anchors = random.randint(2, 5)
    
    anchors = []
    used_d = set()
    while len(anchors) < num_anchors:
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        d = r - c
        if d not in used_d:
            used_d.add(d)
            anchors.append((r, c))
    
    colors = random.sample(range(1, 10), num_anchors)
    
    input_grid = grid(width, height, 0)
    for (r, c), color in zip(anchors, colors):
        input_grid[r][c] = color
    
    # Sort anchors and colors together
    sorted_anchors_colors = sorted(zip(anchors, colors), key=lambda x: (x[0][0], x[0][1]))
    output_grid = [row[:] for row in input_grid]
    
    for (r, c), color in sorted_anchors_colors:
        for step in range(1, max_dim):
            nr = (r + step) % height
            nc = (c + step) % width
            if output_grid[nr][nc] == 0:
                output_grid[nr][nc] = color
            else:
                break
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    max_dim = max(width, height)
    
    anchors = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                anchors.append((r, c, input_grid[r][c]))
    
    anchors.sort(key=lambda x: (x[0], x[1]))
    
    output_grid = [row[:] for row in input_grid]
    
    for r, c, color in anchors:
        for step in range(1, max_dim):
            nr = (r + step) % height
            nc = (c + step) % width
            if output_grid[nr][nc] == 0:
                output_grid[nr][nc] = color
            else:
                break
    
    return output_grid
