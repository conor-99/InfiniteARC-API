# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 7c36f7db
Difficulty: medium–hard

=== Tags ===
- Local rule cascade
- Path following
- Order numbers
- Add frame

=== Description ===
Input grids are medium-sized (15×15 to 25×25) with a single background color
(0). Over this background lies a continuous, non-branching path formed by
connected cells (4-directional adjacency) where each cell along the path has a
unique color from 1 to N (N ≥ 3, N ≤ 9), arranged such that colors increase
sequentially along the path (color 1 → color 2 → ... → color N). The path is
entirely internal (does not touch grid edges) and is surrounded by background
cells.    The transformation process consists of two phases:   1. **Local Rule
Cascade**: For each color k (from 1 to N in order), starting at the cell with
color k, propagate k steps in a direction determined by k mod 4 (0: right, 1:
up, 2: left, 3: down). During propagation, every background cell (color 0)
encountered along the path is recolored to k. Propagation stops at non-
background cells or grid edges.   2. **Frame Addition**: After all propagations,
all border cells (top row, bottom row, leftmost column, rightmost column) that
remain background (color 0) are recolored to the value of N (the final color in
the path).    The output grid retains all path cells and background except for
the propagated colors and the added frame. This task requires identifying the
path's color sequence, applying directional propagation rules in order, and
recognizing that the frame color is determined by the path's terminal color.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(15, 25)
    height = random.randint(15, 25)
    N = random.randint(3, 9)
    
    min_row, min_col = 1, 1
    max_row, max_col = height - 2, width - 2
    path = []
    while len(path) < N:
        start = (random.randint(min_row, max_row), random.randint(min_col, max_col))
        path = [start]
        for _ in range(N-1):
            current = path[-1]
            candidates = []
            for dr, dc in [(0,1), (1,0), (0,-1), (-1,0)]:
                nr, nc = current[0] + dr, current[1] + dc
                if min_row <= nr <= max_row and min_col <= nc <= max_col and (nr, nc) not in path:
                    candidates.append((dr, dc))
            if not candidates:
                break
            dr, dc = random.choice(candidates)
            path.append((current[0] + dr, current[1] + dc))
    
    input_grid = grid(width, height, 0)
    for idx, (r, c) in enumerate(path):
        input_grid[r][c] = idx + 1
    
    output_grid = [row[:] for row in input_grid]
    for k in range(1, N+1):
        for r in range(height):
            for c in range(width):
                if output_grid[r][c] == k:
                    dir = k % 4
                    dr, dc = (0, 1) if dir == 0 else (-1, 0) if dir == 1 else (0, -1) if dir == 2 else (1, 0)
                    for step in range(k):
                        nr = r + dr * (step + 1)
                        nc = c + dc * (step + 1)
                        if nr < 0 or nr >= height or nc < 0 or nc >= width:
                            break
                        if output_grid[nr][nc] != 0:
                            break
                        output_grid[nr][nc] = k
                    break
            else:
                continue
            break
    
    for c in range(width):
        if output_grid[0][c] == 0:
            output_grid[0][c] = N
        if output_grid[height-1][c] == 0:
            output_grid[height-1][c] = N
    for r in range(1, height-1):
        if output_grid[r][0] == 0:
            output_grid[r][0] = N
        if output_grid[r][width-1] == 0:
            output_grid[r][width-1] = N
    
    if input_grid == output_grid:
        return generate()
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    height = len(input_list)
    width = len(input_list[0])
    
    path = []
    for r in range(height):
        for c in range(width):
            if input_list[r][c] == 1:
                path = [(r, c)]
                current = (r, c)
                for k in range(2, 10):
                    found = False
                    for dr, dc in [(0,1), (1,0), (0,-1), (-1,0)]:
                        nr, nc = current[0] + dr, current[1] + dc
                        if 0 <= nr < height and 0 <= nc < width and input_list[nr][nc] == k:
                            path.append((nr, nc))
                            current = (nr, nc)
                            found = True
                            break
                    if not found:
                        break
                break
        if path:
            break
    
    N = len(path)
    output_grid = [row[:] for row in input_list]
    
    for k in range(1, N+1):
        for r in range(height):
            for c in range(width):
                if output_grid[r][c] == k:
                    dir = k % 4
                    dr, dc = (0, 1) if dir == 0 else (-1, 0) if dir == 1 else (0, -1) if dir == 2 else (1, 0)
                    for step in range(k):
                        nr = r + dr * (step + 1)
                        nc = c + dc * (step + 1)
                        if nr < 0 or nr >= height or nc < 0 or nc >= width:
                            break
                        if output_grid[nr][nc] != 0:
                            break
                        output_grid[nr][nc] = k
                    break
            else:
                continue
            break
    
    for c in range(width):
        if output_grid[0][c] == 0:
            output_grid[0][c] = N
        if output_grid[height-1][c] == 0:
            output_grid[height-1][c] = N
    for r in range(1, height-1):
        if output_grid[r][0] == 0:
            output_grid[r][0] = N
        if output_grid[r][width-1] == 0:
            output_grid[r][width-1] = N
    
    return output_grid
