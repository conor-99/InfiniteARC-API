# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 1bf9b7ff
Difficulty: hard

=== Tags ===
- Tetris piece packing
- Ex nihilo

=== Description ===
The input grid consists of multiple disconnected Tetris-like polyomino shapes,
each defined by a connected region of non-zero cells (colors are irrelevant, as
the transformation depends solely on spatial arrangement). The output grid is
constructed by sorting these polyominoes by their area (number of cells) in
ascending order, then arranging them horizontally in sequence without any gaps
between adjacent pieces. Each polyomino retains its original orientation and
color, while all empty cells in the output grid are set to color 0. The
transformation requires identifying connected components (using 4-connectivity),
sorting them by size, and spatially concatenating them into a single row. This
task demands complex pattern recognition, multi-step reasoning, and the ability
to abstract spatial relationships from visual cues rather than numerical
properties.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = 30
    height = 30
    input_grid = [[0] * width for _ in range(height)]
    n = random.randint(2, 5)
    colors = list(range(1, n+1))
    
    for i in range(n):
        name = random.choice(['el', 'you', 'aitch'])
        pixels = common.rand_sprite(name, 3, 3)
        color = colors[i]
        for (r, c) in pixels:
            if 0 <= i*5 + r < height and 0 <= i*5 + c < width:
                input_grid[i*5 + r][i*5 + c] = color
    
    visited = [[False] * width for _ in range(height)]
    components = []
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and input_grid[r][c] != 0:
                stack = [(r, c)]
                visited[r][c] = True
                comp = []
                while stack:
                    cr, cc = stack.pop()
                    comp.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] != 0:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append(comp)
    
    components.sort(key=lambda comp: len(comp))
    
    max_height = 0
    total_width = 0
    for comp in components:
        min_r = min(p[0] for p in comp)
        max_r = max(p[0] for p in comp)
        min_c = min(p[1] for p in comp)
        max_c = max(p[1] for p in comp)
        comp_width = max_c - min_c + 1
        comp_height = max_r - min_r + 1
        max_height = max(max_height, comp_height)
        total_width += comp_width
    
    output_grid = [[0] * total_width for _ in range(max_height)]
    
    current_col = 0
    for comp in components:
        min_r = min(p[0] for p in comp)
        max_r = max(p[0] for p in comp)
        min_c = min(p[1] for p in comp)
        max_c = max(p[1] for p in comp)
        for (r, c) in comp:
            rel_r = r - min_r
            rel_c = c - min_c
            output_grid[rel_r][current_col + rel_c] = input_grid[r][c]
        current_col += (max_c - min_c + 1)
    
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    visited = [[False] * width for _ in range(height)]
    components = []
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and input_grid[r][c] != 0:
                stack = [(r, c)]
                visited[r][c] = True
                comp = []
                while stack:
                    cr, cc = stack.pop()
                    comp.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] != 0:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append(comp)
    
    components.sort(key=lambda x: len(x))
    
    max_height = 0
    total_width = 0
    for comp in components:
        min_r = min(p[0] for p in comp)
        max_r = max(p[0] for p in comp)
        min_c = min(p[1] for p in comp)
        max_c = max(p[1] for p in comp)
        comp_width = max_c - min_c + 1
        comp_height = max_r - min_r + 1
        max_height = max(max_height, comp_height)
        total_width += comp_width
    
    output_grid = [[0] * total_width for _ in range(max_height)]
    
    current_col = 0
    for comp in components:
        min_r = min(p[0] for p in comp)
        max_r = max(p[0] for p in comp)
        min_c = min(p[1] for p in comp)
        max_c = max(p[1] for p in comp)
        for (r, c) in comp:
            rel_r = r - min_r
            rel_c = c - min_c
            output_grid[rel_r][current_col + rel_c] = input_grid[r][c]
        current_col += (max_c - min_c + 1)
    
    return output_grid
