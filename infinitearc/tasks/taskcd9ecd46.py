# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: cd9ecd46
Difficulty: hard

=== Tags ===
- Chain reaction
- Phase transition path
- Bounce marking
- State machine grid

=== Description ===
# Task Description: Phase-Transition Bounce Path  Input grids feature a single
cell of color 5 (the trigger) positioned anywhere on a uniform background of
color 0. All other cells are color 0. The grid dimensions range from 3×3 to
30×30, with the trigger cell never positioned on the edge.  The transformation
applies a deterministic chain reaction starting from the trigger cell. The
reaction propagates in a fixed initial direction (right) along the grid,
coloring each subsequent cell with the next phase in the sequence (5 → 6 → 7 → 8
→ 9 → 5 → 6 → ...). When the path encounters a grid boundary, it reverses
direction (e.g., right becomes left, down becomes up). The chain reaction
continues until the next cell in the current direction would either overlap with
an already colored cell or exit the grid boundaries. The trigger cell remains
color 5, while all other cells along the path display their phase transition
color.  The output grid must display the complete path with sequential phase
colors, fully respecting boundary bounces and color cycling. The path forms a
continuous, non-overlapping trajectory that may zig-zag across the grid multiple
times before termination. The transformation requires tracking both directional
changes at boundaries and the cyclic color sequence, with no cell appearing in
multiple phases within the path.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    from common import grid
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    r = random.randint(1, height - 2)
    c = random.randint(1, width - 2)
    input_grid = grid(width, height, 0)
    input_grid[r][c] = 5
    output_grid = grid(width, height, 0)
    path = [(r, c)]
    dr, dc = 0, 1
    cr, cc = r, c
    while True:
        nr, nc = cr + dr, cc + dc
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            dr, dc = -dr, -dc
            nr, nc = cr + dr, cc + dc
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                break
        if (nr, nc) in path:
            break
        path.append((nr, nc))
        cr, cc = nr, nc
    for idx, (r, c) in enumerate(path):
        output_grid[r][c] = 5 + (idx % 5)
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    from common import grid
    width = len(input_grid[0])
    height = len(input_grid)
    trigger_r, trigger_c = -1, -1
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 5:
                trigger_r, trigger_c = r, c
                break
        if trigger_r != -1:
            break
    path = [(trigger_r, trigger_c)]
    dr, dc = 0, 1
    cr, cc = trigger_r, trigger_c
    while True:
        nr, nc = cr + dr, cc + dc
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            dr, dc = -dr, -dc
            nr, nc = cr + dr, cc + dc
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                break
        if (nr, nc) in path:
            break
        path.append((nr, nc))
        cr, cc = nr, nc
    output_grid = grid(width, height, 0)
    for idx, (r, c) in enumerate(path):
        output_grid[r][c] = 5 + (idx % 5)
    return output_grid
