# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 84d12255
Difficulty: insane

=== Tags ===
- Propagation by rule weight
- Pattern mirroring chain

=== Description ===
The input grid features a central, multi-colored pattern composed of non-
background cells (colors 1-9) surrounded by a uniform background (color 0).
Scattered around the pattern are isolated "rule markers"—single cells of
distinct colors (1–9) that encode directional mirror rules. Each color
corresponds to a specific mirroring axis: color 1 = horizontal (vertical mirror
line), color 2 = vertical (horizontal mirror line), color 3 = diagonal (top-left
to bottom-right), color 4 = anti-diagonal (top-right to bottom-left). The rule
markers are processed in ascending order of their color value (e.g., all color-1
markers before color-2). For each marker, the current pattern (initially the
central pattern) is mirrored across its specified axis. Mirrored cells are
placed **only on background cells** (color 0), preserving all existing non-
background cells from prior mirrors. The mirrored pattern becomes the new
current pattern for subsequent operations. Rule markers are removed from the
output. The mirroring sequence creates a chain of transformations where each
operation depends on the result of the previous one, requiring careful handling
of pattern evolution, boundary constraints, and non-overwriting placement. The
output grid reflects the final transformed pattern after all mirror operations,
with all rule markers absent and no cell overwritten by non-background content.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    # Choose a reasonably sized grid
    width = random.randint(7, 20)
    height = random.randint(7, 20)
    grid = [[0 for _ in range(width)] for _ in range(height)]

    # Pick a bounding box for the central contiguous pattern
    max_box_w = max(3, min(7, width - 4))
    max_box_h = max(3, min(7, height - 4))
    pw = random.randint(3, max_box_w)
    ph = random.randint(3, max_box_h)

    # Size of the contiguous creature (must fit into pw*ph)
    max_size = pw * ph
    size = random.randint(3, min(10, max_size))

    # Create a contiguous sprite inside the bounding box
    sprite = common.continuous_creature(size, pw, ph)

    # Anchor the bounding box in the center of the whole grid
    anchor_r = (height - ph) // 2
    anchor_c = (width - pw) // 2

    # Assign colors for the pattern from the set {5,6,7,8,9} to avoid colliding with rule-marker colors 1..4
    pattern_cells = []
    for (pr, pc) in sprite:
        r = anchor_r + pr
        c = anchor_c + pc
        color = random.randint(5, 9)
        grid[r][c] = color
        pattern_cells.append((r, c, color))

    # Find candidate positions for isolated markers: must be background, not adjacent to pattern, and have empty 4-neighbors
    candidates = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                continue
            # ensure not too close to the pattern (require Chebyshev distance > 1)
            too_close = False
            for pr, pc, _ in pattern_cells:
                if max(abs(pr - r), abs(pc - c)) <= 1:
                    too_close = True
                    break
            if too_close:
                continue
            # ensure immediate 4-neighbors are background so marker will be isolated
            neighbors_ok = True
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                    neighbors_ok = False
                    break
            if not neighbors_ok:
                continue
            candidates.append((r, c))

    # If there are no good isolated positions (rare for small grids), relax constraints
    if not candidates:
        for r in range(height):
            for c in range(width):
                if grid[r][c] == 0:
                    candidates.append((r, c))

    # Choose 1..4 markers (at least one)
    desired_marker_count = random.randint(1, 4)

    # Select markers sequentially to ensure they are not adjacent to each other (remain isolated in the final input)
    random.shuffle(candidates)
    chosen_positions = []
    for (r, c) in candidates:
        if len(chosen_positions) >= desired_marker_count:
            break
        conflict = False
        for (pr, pc) in chosen_positions:
            # do not allow 4-neighbor adjacency between markers
            if abs(pr - r) + abs(pc - c) == 1:
                conflict = True
                break
        if conflict:
            continue
        chosen_positions.append((r, c))

    marker_count = len(chosen_positions)
    if marker_count == 0:
        # Fallback: force at least one marker somewhere outside the pattern bounding box
        fallback = None
        for r in range(height):
            for c in range(width):
                if grid[r][c] == 0 and max(abs(r - anchor_r), abs(c - anchor_c)) > 1:
                    fallback = (r, c)
                    break
            if fallback:
                break
        if not fallback:
            # As ultimate fallback place marker anywhere zero
            for r in range(height):
                for c in range(width):
                    if grid[r][c] == 0:
                        fallback = (r, c)
                        break
                if fallback:
                    break
        chosen_positions = [fallback]
        marker_count = 1

    # Assign marker colors from 1..4 (these encode reflection axes). Allow duplicates (multiple markers of same color).
    marker_colors = [random.randint(1, 4) for _ in range(marker_count)]

    markers = []
    for (pos, col) in zip(chosen_positions, marker_colors):
        r, c = pos
        grid[r][c] = col
        markers.append((r, c, col))

    # Copy grid to build the output; markers remain present as non-background during mirroring checks
    out = [row[:] for row in grid]

    # Identify the central pattern as the largest connected component of non-marker non-zero cells
    visited = [[False] * width for _ in range(height)]
    components = []
    marker_set = {(mr, mc) for mr, mc, _ in markers}

    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0:
                continue
            if (r, c) in marker_set:
                continue
            if visited[r][c]:
                continue
            # BFS / flood fill
            stack = [(r, c)]
            visited[r][c] = True
            comp = []
            while stack:
                cr, cc = stack.pop()
                comp.append((cr, cc, grid[cr][cc]))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] != 0 and (nr, nc) not in marker_set:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            components.append(comp)

    if not components:
        # No pattern found (should not happen) — return trivial output
        return {"input": grid, "output": out}

    main = max(components, key=len)
    current_pattern = [(r, c, col) for (r, c, col) in main]

    # Mirror helper: reflect point (sr,sc) across line determined by marker (mr,mc) and kind
    def mirror_point(sr, sc, mr, mc, kind):
        if kind == 1:
            # vertical mirror line (mirror across column mc)
            return (sr, 2 * mc - sc)
        if kind == 2:
            # horizontal mirror line (mirror across row mr)
            return (2 * mr - sr, sc)
        if kind == 3:
            # diagonal (top-left to bottom-right): line r - c = d0
            d0 = mr - mc
            return (sc + d0, sr - d0)
        if kind == 4:
            # anti-diagonal (top-right to bottom-left): line r + c = s0
            s0 = mr + mc
            return (s0 - sc, s0 - sr)
        return (sr, sc)

    # Process markers in ascending color order; for markers with the same color process them in reading order
    for kind in range(1, 5):
        same_color = sorted([m for m in markers if m[2] == kind], key=lambda x: (x[0], x[1]))
        for mr, mc, mv in same_color:
            new_pattern = []
            for sr, sc, scol in current_pattern:
                tr, tc = mirror_point(sr, sc, mr, mc, kind)
                if 0 <= tr < height and 0 <= tc < width and out[tr][tc] == 0:
                    out[tr][tc] = scol
                    new_pattern.append((tr, tc, scol))
            # The mirrored cells become the new current pattern for the next marker
            current_pattern = new_pattern

    # Remove markers from the output as specified
    for mr, mc, mv in markers:
        out[mr][mc] = 0

    # Ensure the output differs from the input; if not, regenerate to avoid trivial cases
    if out == grid:
        return generate()

    return {"input": grid, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Detect isolated rule markers: colors 1..4 that have no non-background 4-neighbors
    markers = []
    for r in range(height):
        for c in range(width):
            val = grid[r][c]
            if val in (1, 2, 3, 4):
                isolated = True
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                        isolated = False
                        break
                if isolated:
                    markers.append((r, c, val))

    marker_set = {(mr, mc) for mr, mc, _ in markers}

    # Find the central pattern as the largest connected component of non-marker non-zero cells
    visited = [[False] * width for _ in range(height)]
    components = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 or (r, c) in marker_set or visited[r][c]:
                continue
            # flood fill
            stack = [(r, c)]
            visited[r][c] = True
            comp = []
            while stack:
                cr, cc = stack.pop()
                comp.append((cr, cc, grid[cr][cc]))
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] != 0 and (nr, nc) not in marker_set:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            components.append(comp)

    current_pattern = []
    if components:
        main = max(components, key=lambda comp: len(comp))
        current_pattern = [(r, c, col) for (r, c, col) in main]

    # Helper to mirror a point across a marker axis
    def mirror_point(sr, sc, mr, mc, kind):
        if kind == 1:
            return (sr, 2 * mc - sc)
        if kind == 2:
            return (2 * mr - sr, sc)
        if kind == 3:
            d0 = mr - mc
            return (sc + d0, sr - d0)
        if kind == 4:
            s0 = mr + mc
            return (s0 - sc, s0 - sr)
        return (sr, sc)

    # Work on a copy of the grid; markers remain until final removal so they block placements during mirroring
    out = [row[:] for row in grid]

    # Process in ascending color order; same-color markers processed in reading order
    for kind in range(1, 5):
        group = sorted([m for m in markers if m[2] == kind], key=lambda x: (x[0], x[1]))
        for mr, mc, mv in group:
            new_pattern = []
            for sr, sc, scol in current_pattern:
                tr, tc = mirror_point(sr, sc, mr, mc, kind)
                if 0 <= tr < height and 0 <= tc < width and out[tr][tc] == 0:
                    out[tr][tc] = scol
                    new_pattern.append((tr, tc, scol))
            current_pattern = new_pattern

    # Remove markers from the output
    for mr, mc, mv in markers:
        out[mr][mc] = 0

    return out

