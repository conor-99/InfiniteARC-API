# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 5d4dbf7e
Difficulty: very hard

=== Tags ===
- Color transfer on contact

=== Description ===
Input grids consist of a background color (0) and multiple contiguous regions of
non-background colors (1-9), arranged in a complex, non-uniform pattern. Each
region is categorized as either a "color source" (odd-numbered colors: 1, 3, 5,
7, 9) or a "color target" (even-numbered colors: 2, 4, 6, 8). Source regions are
always isolated from other sources of the same color and surrounded by at least
one target region. Target regions are contiguous areas adjacent to one or more
source regions.  The output grid applies a cascading color transfer rule: each
target region changes to the color of the nearest source region, where "nearest"
is determined by the minimum Manhattan distance to any source region with a
lower numerical value. If multiple sources of the same lower numerical value are
equidistant, the target region adopts the lowest-numbered source color.
Crucially, source regions must be strictly lower in numerical value than the
target they influence (e.g., a source of color 3 can transfer to a target of
color 4, but a source of color 5 cannot transfer to a target of color 2).   This
process requires sequential application: all targets influenced by the lowest-
numbered sources (1, 3, etc.) are updated first, followed by higher-numbered
sources. The transformation results in a visually complex grid where target
regions absorb the color of the closest valid source, creating layered color
propagation patterns that depend on both spatial arrangement and numerical
hierarchy. The background remains unchanged, and no regions change color more
than once during the transformation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = random.randint(10, 25)
    height = random.randint(10, 25)
    input_grid = [[0] * width for _ in range(height)]
    sources = []

    source_colors = [1, 3, 5, 7, 9]
    random.shuffle(source_colors)
    num_sources = random.randint(2, 4)

    for color in source_colors[:num_sources]:
        size = random.randint(3, 8)
        r0 = random.randint(0, height-1)
        c0 = random.randint(0, width-1)
        region = [(r0, c0)]
        while len(region) < size and len(region) < 30:
            r, c = random.choice(region)
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in region:
                    region.append((nr, nc))
                    break
            else:
                break
        for r, c in region:
            input_grid[r][c] = color
        sources.append((color, region))

    for color, region in sources:
        target_color = color + 1
        if target_color > 8:
            target_color = 8
        adj_cells = []
        for r, c in region:
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 0:
                    adj_cells.append((nr, nc))
        if not adj_cells:
            continue
        r, c = random.choice(adj_cells)
        target_region = [(r, c)]
        size = random.randint(2, 4)
        while len(target_region) < size and len(target_region) < 30:
            r, c = random.choice(target_region)
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 0:
                    target_region.append((nr, nc))
                    break
            else:
                break
        for r, c in target_region:
            input_grid[r][c] = target_color

    output_grid = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width):
            cell_color = input_grid[r][c]
            if cell_color == 0 or cell_color % 2 != 0:
                continue
            best_source_color = None
            min_dist = float('inf')
            for src_color, src_region in sources:
                if src_color >= cell_color:
                    continue
                dist = min(abs(r - sr) + abs(c - sc) for sr, sc in src_region)
                if dist < min_dist or (dist == min_dist and src_color < best_source_color):
                    min_dist = dist
                    best_source_color = src_color
            if best_source_color is not None:
                output_grid[r][c] = best_source_color

    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Ensure input is list of lists
    if isinstance(input_grid, tuple) and all(isinstance(row, tuple) for row in input_grid):
        input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = [row[:] for row in input_grid]
    source_cells = []
    for r in range(height):
        for c in range(width):
            color = input_grid[r][c]
            if color % 2 == 1 and color != 0:
                source_cells.append((r, c, color))
    
    for r in range(height):
        for c in range(width):
            color = input_grid[r][c]
            if color == 0 or color % 2 == 1:
                continue
            min_dist = float('inf')
            best_source_color = None
            for sr, sc, src_color in source_cells:
                if src_color >= color:
                    continue
                dist = abs(r - sr) + abs(c - sc)
                if dist < min_dist or (dist == min_dist and src_color < best_source_color):
                    min_dist = dist
                    best_source_color = src_color
            if best_source_color is not None:
                output_grid[r][c] = best_source_color
    return output_grid
