# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: bb12ce79
Difficulty: hard

=== Tags ===
- Measure distance from side

=== Description ===
The input grid features a connected region of a single non-zero color, forming a
distinct shape. The output grid is constructed such that each cell's value
corresponds to the minimum distance to the nearest edge of the bounding box that
encloses this shape. The bounding box is defined by the extreme rows and columns
of the shape's cells. The distance for a cell is computed as the smallest of its
distances to the top, bottom, left, or right edge of the bounding box, with
values capped at 9 to fit within the 0-9 color range. This transformation
requires identifying the shape's bounding box and applying distance
calculations, making it challenging due to the need for precise spatial
reasoning and handling of irregularly shaped regions within the grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    width = common.randint(1, 30)
    height = common.randint(1, 30)
    shape_size = common.randint(2, min(15, width * height))
    pixels = common.continuous_creature(shape_size, width, height)
    color = common.random_color(exclude=[0])
    input_grid = common.grid(width, height, 0)
    for (r, c) in pixels:
        input_grid[r][c] = color
    min_r = min(r for r, c in pixels)
    max_r = max(r for r, c in pixels)
    min_c = min(c for r, c in pixels)
    max_c = max(c for r, c in pixels)
    output_grid = common.grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            dist_top = abs(r - min_r)
            dist_bottom = abs(r - max_r)
            dist_left = abs(c - min_c)
            dist_right = abs(c - max_c)
            min_dist = min(dist_top, dist_bottom, dist_left, dist_right)
            output_grid[r][c] = min(min_dist, 9)
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    non_zero = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                non_zero.append((r, c))
    if not non_zero:
        return common.grid(width, height, 0)
    min_r = min(r for r, c in non_zero)
    max_r = max(r for r, c in non_zero)
    min_c = min(c for r, c in non_zero)
    max_c = max(c for r, c in non_zero)
    output_grid = common.grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            dist_top = abs(r - min_r)
            dist_bottom = abs(r - max_r)
            dist_left = abs(c - min_c)
            dist_right = abs(c - max_c)
            min_dist = min(dist_top, dist_bottom, dist_left, dist_right)
            output_grid[r][c] = min(min_dist, 9)
    return output_grid
