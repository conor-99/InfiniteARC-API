# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 3089d250
Difficulty: insane

=== Tags ===
- Constraint satisfaction coloring
- Indexed painting
- Teleporter network routing

=== Description ===
Input grids are large (20×20 or larger) with a uniform background color (0).
Scattered throughout are teleporter pairs (two cells of identical non-zero color
C) and a single index cell (color I, I ≠ 0, I ≠ C) positioned directly above
each pair. The token begins at the top-left corner (0,0), moving right. Upon
entering a teleporter cell (C), the token instantly teleports to the paired cell
of color C, turns 90° clockwise, and the path is drawn using the index color I.
The path continues until the token exits the grid. The output grid displays the
complete path with index colors (I), preserving all teleporter pairs and index
cells. The input is explicitly designed to ensure consecutive path segments use
distinct colors, satisfying the constraint that no two adjacent path cells share
the same color. The transformation requires tracking multiple teleporter
interactions, directional changes, and index-based color mapping across a
complex, interconnected network.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, grid_enhance, all_pixels

def generate():
    # Create a 20x20 grid with background 0
    size = 20
    ingrid = grid(size, size, 0)
    output = grid(size, size, 0)
    
    # Choose initial color (1) if available
    initial_color = 1
    used_colors = {0, initial_color}
    
    # Create 3 teleporter pairs
    teleporters = []
    for _ in range(3):
        # Choose C (teleporter color) and I (index color)
        C = random.choice([c for c in range(1, 10) if c not in used_colors])
        I = random.choice([c for c in range(1, 10) if c not in used_colors and c != C])
        used_colors.add(C)
        used_colors.add(I)
        
        # Place teleporter pair vertically (same column, adjacent rows)
        col = random.randint(1, size-2)
        row = random.randint(1, size-3)
        ingrid[row][col] = C
        ingrid[row+1][col] = C
        # Place index cell above the top teleporter
        ingrid[row-1][col] = I
        teleporters.append((row, col, C, I))
    
    # Simulate token path
    path_color = initial_color
    x, y = 0, 0
    direction = (0, 1)  # right
    
    # Copy input to output as base
    for r in range(size):
        for c in range(size):
            output[r][c] = ingrid[r][c]
    
    # Simulate movement until exit
    while 0 <= x < size and 0 <= y < size:
        # If current cell is background (0), draw path
        if ingrid[x][y] == 0:
            output[x][y] = path_color
        else:
            # Teleporter hit - teleport to pair and change color
            for row, col, C, I in teleporters:
                if (x, y) == (row, col) or (x, y) == (row+1, col):
                    # Find paired cell
                    if (x, y) == (row, col):
                        x, y = row+1, col
                    else:
                        x, y = row, col
                    path_color = I
                    # Turn 90° clockwise
                    direction = (direction[1], -direction[0])
                    break
            else:
                # Not a teleporter, stop
                break
        
        # Move in current direction
        x += direction[0]
        y += direction[1]
        
    return {
        "input": ingrid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    size = len(input_grid)
    ingrid = [list(row) for row in input_grid]
    output = [list(row) for row in input_grid]
    
    # Find all teleporter pairs and index cells
    teleporters = []
    for r in range(size):
        for c in range(size):
            if ingrid[r][c] > 0:
                # Check for vertical pair
                if r+1 < size and ingrid[r][c] == ingrid[r+1][c]:
                    C = ingrid[r][c]
                    I = ingrid[r-1][c] if r-1 >= 0 else None
                    if I and I > 0 and I != C:
                        teleporters.append((r, c, C, I))
    
    # Simulate token path
    path_color = 1  # Initial color (1)
    x, y = 0, 0
    direction = (0, 1)  # right
    
    while 0 <= x < size and 0 <= y < size:
        # If current cell is background (0), draw path
        if ingrid[x][y] == 0:
            output[x][y] = path_color
        else:
            # Teleporter hit - teleport to pair and change color
            for row, col, C, I in teleporters:
                if (x, y) == (row, col) or (x, y) == (row+1, col):
                    # Find paired cell
                    if (x, y) == (row, col):
                        x, y = row+1, col
                    else:
                        x, y = row, col
                    path_color = I
                    # Turn 90° clockwise
                    direction = (direction[1], -direction[0])
                    break
            else:
                break
        
        # Move in current direction
        x += direction[0]
        y += direction[1]
    
    return output
