# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: dbe10435
Difficulty: hard

=== Tags ===
- Pattern reflection
- Multi object alignment

=== Description ===
The task involves transforming an input grid containing multiple distinct
objects (non-zero connected regions) into an output grid. For each object, the
transformation consists of two steps: first, reflecting the object horizontally
(left-right flip) across the grid's vertical axis; second, shifting the object
vertically upward until its topmost pixel aligns with the top row of the grid.
The reflection of an object's pixels (r, c) is computed as (r, width - 1 - c),
where width is the grid's width. After reflection, the object is moved up such
that its highest row index becomes 0. The background (value 0) remains
unchanged. The output grid preserves all reflected and aligned objects within
the original grid dimensions, with the background filled with 0s. This requires
identifying all objects, applying per-object reflection, and then aligning each
object to the top row, making the task challenging due to the combination of
spatial transformations applied to multiple independently positioned objects.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    w = random.randint(5, 30)
    h = random.randint(5, 30)
    input_grid = common.grid(w, h, 0)
    used_colors = []
    
    num_objects = random.randint(2, 3)
    for _ in range(num_objects):
        name = random.choice(["el", "you", "aitch"])
        sprite = common.rand_sprite(name, w, h)
        max_dr = max(dr for dr, dc in sprite) if sprite else 0
        max_dc = max(dc for dr, dc in sprite) if sprite else 0
        r0 = random.randint(0, h - max_dr - 1)
        c0 = random.randint(0, w - max_dc - 1)
        
        overlap = False
        for dr, dc in sprite:
            r, c = r0 + dr, c0 + dc
            if input_grid[r][c] != 0:
                overlap = True
                break
        if overlap:
            for _ in range(10):
                r0 = random.randint(0, h - max_dr - 1)
                c0 = random.randint(0, w - max_dc - 1)
                overlap = False
                for dr, dc in sprite:
                    r, c = r0 + dr, c0 + dc
                    if input_grid[r][c] != 0:
                        overlap = True
                        break
                if not overlap:
                    break
            if overlap:
                continue
        
        color = common.random_color(exclude=used_colors)
        used_colors.append(color)
        for dr, dc in sprite:
            r, c = r0 + dr, c0 + dc
            input_grid[r][c] = color
    
    output_grid = common.grid(w, h, 0)
    for color in used_colors:
        pixels = []
        for r in range(h):
            for c in range(w):
                if input_grid[r][c] == color:
                    pixels.append((r, c))
        if not pixels:
            continue
        reflected = [(r, w - 1 - c) for r, c in pixels]
        min_r = min(r for r, c in reflected)
        shifted = [(r - min_r, c) for r, c in reflected]
        for r, c in shifted:
            if 0 <= r < h and 0 <= c < w:
                output_grid[r][c] = color
    
    if input_grid == output_grid:
        return generate()
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    w = len(input_grid[0])
    h = len(input_grid)
    output_grid = common.grid(w, h, 0)
    for color in range(1, 10):
        pixels = []
        for r in range(h):
            for c in range(w):
                if input_grid[r][c] == color:
                    pixels.append((r, c))
        if not pixels:
            continue
        reflected = [(r, w - 1 - c) for r, c in pixels]
        min_r = min(r for r, c in reflected)
        shifted = [(r - min_r, c) for r, c in reflected]
        for r, c in shifted:
            if 0 <= r < h and 0 <= c < w:
                output_grid[r][c] = color
    return output_grid
