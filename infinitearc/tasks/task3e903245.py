# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 3e903245
Difficulty: easy

=== Tags ===
- Obstacles
- Mark extrema corners
- Isolate largest component

=== Description ===
The input grid consists of a 2D arrangement of colored cells (0-9) forming
multiple connected regions. The output grid is generated through two clear
steps: first, isolating the largest connected component (using 4-directional
adjacency) by retaining only its cells (preserving their original colors) and
setting all other cells to background (0); second, marking the four corners of
the grid (top-left, top-right, bottom-left, bottom-right) with a distinct color
(1), overriding any prior values. This results in an output grid where the
largest region is visually prominent against a background, with its corners
explicitly highlighted.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    from common import grid
    W = random.randint(1, 30)
    H = random.randint(1, 30)
    input_grid = grid(W, H, 0)
    main_color = random.randint(2, 9)
    main_width = min(W, W // 2 + random.randint(0, W // 2))
    main_height = min(H, H // 2 + random.randint(0, H // 2))
    for r in range(main_height):
        for c in range(main_width):
            input_grid[r][c] = main_color
    small_colors = [c for c in range(2, 10) if c != main_color]
    for _ in range(random.randint(1, 3)):
        if not small_colors:
            break
        color = random.choice(small_colors)
        sw = random.randint(1, 3)
        sh = random.randint(1, 3)
        start_r = max(0, H - sh - 1)
        start_c = max(0, W - sw - 1)
        for r in range(start_r, min(H, start_r + sh)):
            for c in range(start_c, min(W, start_c + sw)):
                input_grid[r][c] = color
    visited = [[False] * W for _ in range(H)]
    largest_component = []
    max_size = 0
    for r in range(H):
        for c in range(W):
            if input_grid[r][c] != 0 and not visited[r][c]:
                comp = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    comp.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < H and 0 <= nc < W and input_grid[nr][nc] != 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                if len(comp) > max_size:
                    max_size = len(comp)
                    largest_component = comp
    output_grid = [[0] * W for _ in range(H)]
    for r, c in largest_component:
        output_grid[r][c] = input_grid[r][c]
    corners = [(0,0), (0, W-1), (H-1, 0), (H-1, W-1)]
    for r, c in corners:
        output_grid[r][c] = 1
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    H = len(input_grid)
    W = len(input_grid[0])
    visited = [[False] * W for _ in range(H)]
    largest_component = []
    max_size = 0
    for r in range(H):
        for c in range(W):
            if input_grid[r][c] != 0 and not visited[r][c]:
                comp = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    comp.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < H and 0 <= nc < W and input_grid[nr][nc] != 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                if len(comp) > max_size:
                    max_size = len(comp)
                    largest_component = comp
    output_grid = [[0] * W for _ in range(H)]
    for r, c in largest_component:
        output_grid[r][c] = input_grid[r][c]
    corners = [(0,0), (0, W-1), (H-1, 0), (H-1, W-1)]
    for r, c in corners:
        output_grid[r][c] = 1
    return output_grid
