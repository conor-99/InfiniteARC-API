# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 077b69bc
Difficulty: easy

=== Tags ===
- Pairwise analogy
- Count shapes
- Seal gaps inside shape

=== Description ===
The input grid displays a single closed shape (such as a rectangle or square)
outlined with a consistent non-zero color, containing one or more empty cells
(represented by 0) entirely enclosed within its boundary. The output grid is
formed by filling all such enclosed empty cells with the shape's outline color.
This transformation follows a consistent rule where any cell inside the shape's
boundary that is empty (0) is replaced by the color used for the shape's
outline, resulting in a solid, gap-free shape. The task requires recognizing
enclosed regions within the shape's boundary and applying the fill operation
uniformly, without altering the shape's outline or external elements.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    C = random.randint(1, 9)
    r1 = random.randint(0, height - 3)
    r2 = random.randint(r1 + 2, height - 1)
    c1 = random.randint(0, width - 3)
    c2 = random.randint(c1 + 2, width - 1)
    input_grid = grid(width, height, 0)
    for r in [r1, r2]:
        for c in range(c1, c2 + 1):
            input_grid[r][c] = C
    for c in [c1, c2]:
        for r in range(r1 + 1, r2):
            input_grid[r][c] = C
    output_grid = [row[:] for row in input_grid]
    for r in range(r1 + 1, r2):
        for c in range(c1 + 1, c2):
            output_grid[r][c] = C
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    non_zero = []
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] != 0:
                non_zero.append((r, c))
    if not non_zero:
        return input_grid
    min_row = min(r for r, c in non_zero)
    max_row = max(r for r, c in non_zero)
    min_col = min(c for r, c in non_zero)
    max_col = max(c for r, c in non_zero)
    color = input_grid[min_row][min_col]
    output = [list(row) for row in input_grid]
    for r in range(min_row + 1, max_row):
        for c in range(min_col + 1, max_col):
            output[r][c] = color
    return output
