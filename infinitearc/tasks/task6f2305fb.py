# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 6f2305fb
Difficulty: medium–hard

=== Tags ===
- Enclosure completion
- Close line gaps

=== Description ===
Input grids depict a single-color closed loop (enclosure) with one or more small
gaps—single missing cells that break the continuity of the loop. Each gap
appears as a straight-line interruption between two existing perimeter cells
(horizontally or vertically adjacent to the gap cell). The output grid completes
the loop by filling each gap with the same color as the perimeter, resulting in
a fully enclosed shape with no gaps. The transformation requires identifying all
such gaps and filling them without modifying any other elements, ensuring the
loop remains closed and continuous. Gaps are uniquely determined by their
position between two adjacent perimeter cells in a straight line, with no
ambiguity in which cell must be added to restore the loop's integrity. The task
demands careful visual analysis to distinguish true perimeter gaps from isolated
cells or non-enclosure structures.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Grid size: keep at least 5x5 so we can place an internal rectangular ring
    width = random.randint(5, 15)
    height = random.randint(5, 15)

    # Choose an internal rectangle (ring) that does not touch the outer border
    r0 = random.randint(1, height - 4)
    r1 = random.randint(r0 + 2, height - 2)
    c0 = random.randint(1, width - 4)
    c1 = random.randint(c0 + 2, width - 2)

    color = random.randint(1, 9)

    grid_in = [[0 for _ in range(width)] for __ in range(height)]

    # Draw rectangle ring (1-pixel thick)
    for c in range(c0, c1 + 1):
        grid_in[r0][c] = color
        grid_in[r1][c] = color
    for r in range(r0 + 1, r1):
        grid_in[r][c0] = color
        grid_in[r][c1] = color

    # Candidate gap positions: non-corner ring cells (straight-line interruptions)
    candidates = []
    for c in range(c0 + 1, c1):
        candidates.append((r0, c))
        candidates.append((r1, c))
    for r in range(r0 + 1, r1):
        candidates.append((r, c0))
        candidates.append((r, c1))

    random.shuffle(candidates)

    # Select a small number of single-cell gaps, avoiding adjacent gaps
    max_gaps = max(1, len(candidates) // 4)
    k = random.randint(1, min(max_gaps, len(candidates)))
    selected = []
    for pos in candidates:
        if len(selected) >= k:
            break
        r, c = pos
        ok = True
        for (sr, sc) in selected:
            if abs(sr - r) + abs(sc - c) == 1:
                ok = False
                break
        if not ok:
            continue
        selected.append(pos)

    if not selected:
        # fallback: pick one candidate if adjacency rules prevented selection
        selected = [candidates[len(candidates) // 2]]

    grid_out = [row[:] for row in grid_in]

    # Create gaps in the input (set to 0) and ensure output has them filled
    for (r, c) in selected:
        grid_in[r][c] = 0
        grid_out[r][c] = color

    return {"input": grid_in, "output": grid_out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0]) if H > 0 else 0

    # Find the most frequent non-zero color (the loop's color)
    freq = {}
    for r in range(H):
        for c in range(W):
            v = grid[r][c]
            if v == 0:
                continue
            freq[v] = freq.get(v, 0) + 1
    if not freq:
        return grid
    loop_color = max(freq.keys(), key=lambda k: freq[k])

    # Find bounding rectangle of that color
    coords = [(r, c) for r in range(H) for c in range(W) if grid[r][c] == loop_color]
    if not coords:
        return grid
    min_r = min(r for r, _ in coords)
    max_r = max(r for r, _ in coords)
    min_c = min(c for _, c in coords)
    max_c = max(c for _, c in coords)

    # Fill the rectangle perimeter with the loop color (this completes single-cell gaps)
    out = [row[:] for row in grid]
    for c in range(min_c, max_c + 1):
        out[min_r][c] = loop_color
        out[max_r][c] = loop_color
    for r in range(min_r, max_r + 1):
        out[r][min_c] = loop_color
        out[r][max_c] = loop_color

    return out

