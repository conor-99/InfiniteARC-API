# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: e3fcae47
Difficulty: medium–hard

=== Tags ===
- Mirror twins
- Gradient flood
- Bridges
- Binary rule overlay

=== Description ===
Input grids feature a central bridge (a continuous horizontal or vertical line
of a single color) connecting two mirror twin regions. The left and right
regions (relative to the bridge) are exact mirror images of each other across
the bridge line, with distinct color patterns that maintain symmetry. Background
cells are uniformly colored (e.g., 0), while the bridge and mirror twins occupy
non-background colors. The task requires applying a gradient flood starting from
the bridge, where the gradient spreads to adjacent background cells in all
directions but follows a side-dependent binary rule: cells on the left side of
the bridge increment their color sequentially (e.g., bridge color → next color →
next), while cells on the right side decrement their color sequentially (e.g.,
bridge color → previous color → previous). The binary rule overlay dictates the
direction of the gradient based on spatial position relative to the bridge,
creating a visually asymmetric yet logically consistent color progression. The
original mirror twin patterns, bridge, and background remain intact, with the
gradient only filling background cells and never overwriting existing non-
background elements. This task demands recognition of mirror symmetry, bridge
identification, and application of a context-sensitive color transformation rule
to generate the output grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    orientation = random.choice(['vertical', 'horizontal'])
    
    input_grid = grid(width, height, 0)
    
    if orientation == 'vertical':
        bridge_col = random.randint(1, width - 2)
        left_dist = bridge_col
        right_dist = width - 1 - bridge_col
        min_color = right_dist
        max_color = 9 - left_dist
        if min_color > max_color:
            return generate()
        bridge_color = random.randint(min_color, max_color)
        
        for r in range(height):
            input_grid[r][bridge_col] = bridge_color
        
        for r in range(height):
            for c in range(bridge_col):
                if random.random() > 0.5:
                    color = random.randint(1, 9)
                    input_grid[r][c] = color
                    mirror_c = 2 * bridge_col - c
                    if mirror_c < width and mirror_c >= 0:
                        input_grid[r][mirror_c] = color
        
        if all(all(cell != 0 for cell in row) for row in input_grid):
            return generate()
    else:
        bridge_row = random.randint(1, height - 2)
        top_dist = bridge_row
        bottom_dist = height - 1 - bridge_row
        min_color = bottom_dist
        max_color = 9 - top_dist
        if min_color > max_color:
            return generate()
        bridge_color = random.randint(min_color, max_color)
        
        for c in range(width):
            input_grid[bridge_row][c] = bridge_color
        
        for c in range(width):
            for r in range(bridge_row):
                if random.random() > 0.5:
                    color = random.randint(1, 9)
                    input_grid[r][c] = color
                    mirror_r = 2 * bridge_row - r
                    if mirror_r < height and mirror_r >= 0:
                        input_grid[mirror_r][c] = color
        
        if all(all(cell != 0 for cell in row) for row in input_grid):
            return generate()
    
    output_grid = [row[:] for row in input_grid]
    if orientation == 'vertical':
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == 0:
                    if c < bridge_col:
                        d = bridge_col - c
                        output_grid[r][c] = bridge_color + d
                    elif c > bridge_col:
                        d = c - bridge_col
                        output_grid[r][c] = bridge_color - d
    else:
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == 0:
                    if r < bridge_row:
                        d = bridge_row - r
                        output_grid[r][c] = bridge_color + d
                    elif r > bridge_row:
                        d = r - bridge_row
                        output_grid[r][c] = bridge_color - d
    
    if input_grid == output_grid:
        return generate()
    
    return {
        'input': input_grid,
        'output': output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    
    bridge_col = None
    bridge_color = None
    for c in range(width):
        col = [input_grid[r][c] for r in range(height)]
        if all(x == col[0] and x != 0 for x in col):
            bridge_col = c
            bridge_color = col[0]
            break
    
    bridge_row = None
    if bridge_col is None:
        for r in range(height):
            row = input_grid[r]
            if all(x == row[0] and x != 0 for x in row):
                bridge_row = r
                bridge_color = row[0]
                break
    
    if bridge_col is not None:
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == 0:
                    if c < bridge_col:
                        d = bridge_col - c
                        input_grid[r][c] = bridge_color + d
                    elif c > bridge_col:
                        d = c - bridge_col
                        input_grid[r][c] = bridge_color - d
    else:
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == 0:
                    if r < bridge_row:
                        d = bridge_row - r
                        input_grid[r][c] = bridge_color + d
                    elif r > bridge_row:
                        d = r - bridge_row
                        input_grid[r][c] = bridge_color - d
    
    return input_grid
