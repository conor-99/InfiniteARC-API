# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: dd341a9e
Difficulty: insane

=== Tags ===
- Token following
- Recursive partition
- Elastic reflection
- Beam splitter
- Swap rows

=== Description ===
Input grids are large (20×20 or larger) with a single background color (0).
Walls (color 1) form orthogonal barriers of varying lengths, creating enclosed
regions. Beam splitters (color 2) appear as cross-shaped patterns at
intersections of walls. Tokens (color 3) begin at the left edge in open
background cells, moving east initially.   The transformation applies these
rules sequentially:   1. **Token movement**: Tokens move orthogonally until
hitting a wall or beam splitter.   2. **Beam splitting**: Upon hitting a beam
splitter, a token splits into two tokens moving perpendicular to the original
direction (e.g., east splits into north and south).   3. **Elastic reflection**:
Tokens reflect off walls with mirror symmetry (e.g., east-moving tokens hitting
vertical walls reflect west).   4. **Recursive partitioning**: Each split
creates a new partition; path segments in deeper partitions use colors from a
cyclic sequence (e.g., 3 → 4 → 5 → 3 → ...), with the sequence advancing per
segment.   5. **Row swapping**: After path generation, rows containing beam
splitters (color 2) are swapped with adjacent rows based on parity (even rows
swap downward, odd rows swap upward), applied iteratively until no further swaps
occur.    Output grids show all token paths drawn in the cyclic color sequence,
walls and beam splitters unchanged, and rows swapped as per the final rule.
Paths never overwrite walls, beam splitters, or other paths, and all tokens exit
the grid without loops.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common
from collections import deque

def generate():
    # Try multiple attempts to produce a valid grid meeting constraints
    for attempt in range(100):
        width = random.randint(20, 24)
        height = random.randint(20, 24)
        # initialize empty background
        grid = common.grid(width, height, 0)

        # Place a small number of horizontal wall segments
        horiz_segments = []
        nh = random.randint(1, 3)
        for _ in range(nh):
            r = random.randint(1, height - 2)
            L = random.randint(4, max(4, width - 6))
            c_start = random.randint(1, max(1, width - L - 1))
            c_end = c_start + L - 1
            horiz_segments.append((r, c_start, c_end))
            for c in range(c_start, c_end + 1):
                grid[r][c] = 1

        # Place a small number of vertical wall segments
        vert_segments = []
        nv = random.randint(1, 3)
        for _ in range(nv):
            c = random.randint(1, width - 2)
            L = random.randint(4, max(4, height - 6))
            r_start = random.randint(1, max(1, height - L - 1))
            r_end = r_start + L - 1
            vert_segments.append((c, r_start, r_end))
            for r in range(r_start, r_end + 1):
                grid[r][c] = 1

        # Turn some intersections of segments into beam splitters (crosses)
        intersections = []
        for (r, cs, ce) in horiz_segments:
            for (c, rs, re) in vert_segments:
                if cs <= c <= ce and rs <= r <= re and 0 < r < height - 1 and 0 < c < width - 1:
                    intersections.append((r, c))
        # pick up to two intersections to be beam splitters
        if intersections:
            chosen = random.sample(intersections, min(len(intersections), random.randint(1, min(2, len(intersections)))))
            for (r, c) in chosen:
                grid[r][c] = 2
                grid[r-1][c] = 2
                grid[r+1][c] = 2
                grid[r][c-1] = 2
                grid[r][c+1] = 2

        # Ensure some openings at left edge for tokens
        candidate_rows = [r for r in range(1, height - 1) if grid[r][0] == 0 and grid[r][1] == 0]
        if not candidate_rows:
            # carve an opening near the middle
            r = height // 2
            grid[r][1] = 0
            candidate_rows = [r]

        # Place a small random number of tokens on left edge (color 3)
        k = random.randint(1, min(3, len(candidate_rows)))
        starts = random.sample(candidate_rows, k)
        for r in starts:
            grid[r][0] = 3

        # Now simulate token paths and produce an output
        success, output = _simulate_and_draw(grid)
        if not success:
            continue
        # Ensure output is different from input
        if output == grid:
            continue
        return { "input": grid, "output": output }

    # If generation fails after many attempts, fall back to a deterministic simple layout
    width = 20
    height = 20
    grid = common.grid(width, height, 0)
    # single horizontal wall with a beam in the middle
    r = height // 2
    for c in range(3, width - 3):
        grid[r][c] = 1
    c = width // 2
    if 0 < r < height - 1 and 0 < c < width - 1:
        grid[r][c] = 2
        grid[r-1][c] = 2
        grid[r+1][c] = 2
        grid[r][c-1] = 2
        grid[r][c+1] = 2
    grid[height//2][0] = 3
    success, output = _simulate_and_draw(grid)
    return {"input": grid, "output": output}


def _simulate_and_draw(in_grid):
    # copy
    grid = [row[:] for row in in_grid]
    height = len(grid)
    width = len(grid[0])
    output = [row[:] for row in grid]

    # collect initial tokens from left edge (cells with 3)
    tokens = deque()
    for r in range(height):
        if grid[r][0] == 3:
            tokens.append([r, 0, 0, 1, 0])  # r, c, dr, dc, depth

    # safety limits
    total_steps = 0
    max_total_steps = width * height * 50

    while tokens:
        r, c, dr, dc, depth = tokens.popleft()
        visited = set()
        while True:
            if (r, c, dr, dc, depth) in visited:
                return False, None
            visited.add((r, c, dr, dc, depth))
            total_steps += 1
            if total_steps > max_total_steps:
                return False, None

            nr = r + dr
            nc = c + dc
            # exit
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                break
            val = output[nr][nc]
            if val == 2:
                # split into perpendicular directions
                nd1 = (-dc, dr)
                nd2 = (dc, -dr)
                tokens.append([nr, nc, nd1[0], nd1[1], depth + 1])
                tokens.append([nr, nc, nd2[0], nd2[1], depth + 1])
                break
            elif val == 0:
                color = 3 + (depth % 3)
                output[nr][nc] = color
                r, c = nr, nc
                continue
            else:
                # encountered wall (1) or existing path (3-5) or token start -> treat as reflective obstacle
                dr, dc = -dr, -dc
                continue

    # apply iterative row swaps based on presence of beam splitters (2)
    grid_rows = [row[:] for row in output]
    max_iters = max(8, height * 3)
    iters = 0
    while True:
        iters += 1
        if iters > max_iters:
            break
        scheduled = [False] * height
        new_rows = [row[:] for row in grid_rows]
        changed = False
        for i in range(height):
            if scheduled[i]:
                continue
            if 2 in grid_rows[i]:
                if i % 2 == 0 and i < height - 1 and not scheduled[i+1]:
                    new_rows[i] = grid_rows[i+1][:]
                    new_rows[i+1] = grid_rows[i][:]
                    scheduled[i] = scheduled[i+1] = True
                    changed = True
                elif i % 2 == 1 and i > 0 and not scheduled[i-1]:
                    new_rows[i] = grid_rows[i-1][:]
                    new_rows[i-1] = grid_rows[i][:]
                    scheduled[i] = scheduled[i-1] = True
                    changed = True
        if not changed:
            break
        grid_rows = new_rows
    final_output = grid_rows
    return True, final_output



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
from collections import deque

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    output = [row[:] for row in grid]

    tokens = deque()
    for r in range(height):
        if grid[r][0] == 3:
            tokens.append([r, 0, 0, 1, 0])  # r, c, dr, dc, depth

    total_steps = 0
    max_total_steps = width * height * 50

    while tokens:
        r, c, dr, dc, depth = tokens.popleft()
        visited = set()
        while True:
            state = (r, c, dr, dc, depth)
            if state in visited:
                # Loop detected - but valid tasks should not have loops.
                break
            visited.add(state)
            total_steps += 1
            if total_steps > max_total_steps:
                break
            nr = r + dr
            nc = c + dc
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                break
            val = output[nr][nc]
            if val == 2:
                nd1 = (-dc, dr)
                nd2 = (dc, -dr)
                tokens.append([nr, nc, nd1[0], nd1[1], depth + 1])
                tokens.append([nr, nc, nd2[0], nd2[1], depth + 1])
                break
            elif val == 0:
                color = 3 + (depth % 3)
                output[nr][nc] = color
                r, c = nr, nc
                continue
            else:
                dr, dc = -dr, -dc
                continue

    # row swapping
    grid_rows = [row[:] for row in output]
    max_iters = max(8, height * 3)
    iters = 0
    while True:
        iters += 1
        if iters > max_iters:
            break
        scheduled = [False] * height
        new_rows = [row[:] for row in grid_rows]
        changed = False
        for i in range(height):
            if scheduled[i]:
                continue
            if 2 in grid_rows[i]:
                if i % 2 == 0 and i < height - 1 and not scheduled[i+1]:
                    new_rows[i] = grid_rows[i+1][:]
                    new_rows[i+1] = grid_rows[i][:]
                    scheduled[i] = scheduled[i+1] = True
                    changed = True
                elif i % 2 == 1 and i > 0 and not scheduled[i-1]:
                    new_rows[i] = grid_rows[i-1][:]
                    new_rows[i-1] = grid_rows[i][:]
                    scheduled[i] = scheduled[i-1] = True
                    changed = True
        if not changed:
            break
        grid_rows = new_rows

    return tuple(tuple(row) for row in grid_rows)

