# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: c0dccf78
Difficulty: mediumâ€“hard

=== Tags ===
- Bidirectional escape
- Seal gaps inside shape
- Remove singletons

=== Description ===
Input grids feature a single closed-loop shape (a border of a specific color)
enclosing multiple internal gaps (background areas). The grid also contains
isolated single cells (singletons) of various colors, not connected to any other
cells of the same color.   The output grid is formed by: 1. Sealing all internal
gaps within the main shape (filling enclosed background regions inside the
border with the border's color). 2. Removing all singleton cells (setting
isolated single cells to background), regardless of location.  This
transformation requires identifying the main shape's border, determining
enclosed interior regions, filling them, and eliminating all disconnected single
pixels. The task involves bidirectional processing: gaps must be sealed from all
directions within the shape, and singletons must be removed regardless of
whether they reside inside or outside the main shape's boundary.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Grid size chosen to allow a reasonably large interior region
    width = random.randint(9, 20)
    height = random.randint(9, 20)
    grid = [[0 for _ in range(width)] for _ in range(height)]

    # Choose a border margin so that the interior (between the border lines)
    # has at least 5x5 area (when possible) to allow multiple internal gaps.
    max_top = max(1, (height - 7) // 2)
    max_left = max(1, (width - 7) // 2)
    top = random.randint(1, max_top)
    left = random.randint(1, max_left)
    bottom = height - 1 - top
    right = width - 1 - left

    # Border color
    C = random.randint(1, 9)

    # Draw rectangular border (closed-loop shape)
    for c in range(left, right + 1):
        grid[top][c] = C
        grid[bottom][c] = C
    for r in range(top, bottom + 1):
        grid[r][left] = C
        grid[r][right] = C

    # Fill interior with a 2-color checkerboard (colors different from C)
    choices = [col for col in range(1, 10) if col != C]
    # pick two interior colors (guaranteed available because len(choices) >= 8)
    interior_colors = random.sample(choices, 2)
    for r in range(top + 1, bottom):
        for c in range(left + 1, right):
            grid[r][c] = interior_colors[(r + c) % 2]

    inner_h = max(0, (bottom - top - 1))
    inner_w = max(0, (right - left - 1))
    inner_area = inner_h * inner_w

    # Create multiple internal gaps (enclosed background regions) inside the border.
    # We create a few contiguous zero-clusters (size >= 2) to ensure they persist when filled.
    max_gaps = min(4, max(2, inner_area // 6))
    gap_count = random.randint(2, max_gaps)

    occupied_zero = set()
    for _ in range(gap_count):
        # desired cluster size (make clusters at least size 2 so they are not singletons after fill)
        size = random.randint(2, min(4, max(2, inner_area)))
        tries = 0
        placed = False
        while tries < 200 and not placed:
            tries += 1
            sr = random.randint(top + 1, bottom - 1)
            sc = random.randint(left + 1, right - 1)
            if (sr, sc) in occupied_zero:
                continue
            # avoid starting next to existing zero cluster (to avoid merges)
            near_existing = False
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                if (sr + dr, sc + dc) in occupied_zero:
                    near_existing = True
                    break
            if near_existing:
                continue
            # Grow a small contiguous cluster
            cluster = {(sr, sc)}
            grow_tries = 0
            while len(cluster) < size and grow_tries < 200:
                grow_tries += 1
                base = random.choice(list(cluster))
                br, bc = base
                neighs = []
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = br + dr, bc + dc
                    if nr < top + 1 or nr > bottom - 1 or nc < left + 1 or nc > right - 1:
                        continue
                    if (nr, nc) in cluster or (nr, nc) in occupied_zero:
                        continue
                    # avoid placing a new zero cell adjacent to any existing zero outside this cluster
                    adj_existing = False
                    for dr2, dc2 in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        if (nr + dr2, nc + dc2) in occupied_zero:
                            adj_existing = True
                            break
                    if adj_existing:
                        continue
                    neighs.append((nr, nc))
                if neighs:
                    cluster.add(random.choice(neighs))
                else:
                    # cannot expand from this base; try another base or break
                    continue
            if len(cluster) >= 2:
                for (cr, cc) in cluster:
                    grid[cr][cc] = 0
                occupied_zero.update(cluster)
                placed = True
        # if not placed after tries, skip this gap

    # Add some external singletons (isolated single cells) outside the border
    ext_singletons = random.randint(2, 6)
    for _ in range(ext_singletons):
        tries = 0
        while tries < 200:
            tries += 1
            rr = random.randint(0, height - 1)
            cc = random.randint(0, width - 1)
            # don't put on the border itself
            if (rr == top and left <= cc <= right) or (rr == bottom and left <= cc <= right) or \
               (cc == left and top <= rr <= bottom) or (cc == right and top <= rr <= bottom):
                continue
            # prefer outside area but allow any non-border position
            # choose a color different from border
            color = random.choice([col for col in range(1, 10) if col != C])
            # ensure no orthogonal neighbor has the same color
            bad = False
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = rr + dr, cc + dc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == color:
                    bad = True
                    break
            if bad:
                continue
            # don't overwrite border
            if grid[rr][cc] == C:
                continue
            grid[rr][cc] = color
            break

    # Optionally add a couple of small same-color blocks inside the interior to create
    # non-singleton internal elements (but keep them small so border stays the largest component)
    block_count = random.randint(0, 2)
    for _ in range(block_count):
        bw, bh = random.choice([(2, 1), (1, 2), (2, 2)])
        tries = 0
        placed = False
        while tries < 200 and not placed:
            tries += 1
            br0 = random.randint(top + 1, bottom - bh)
            bc0 = random.randint(left + 1, right - bw)
            color = random.choice([col for col in range(1, 10) if col != C])
            ok = True
            for dr in range(bh):
                for dc in range(bw):
                    rr = br0 + dr
                    cc = bc0 + dc
                    if grid[rr][cc] == 0:
                        ok = False
                        break
                    # avoid creating adjacency to same color outside block
                    for adr, adc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = rr + adr, cc + adc
                        if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == color:
                            ok = False
                            break
                if not ok:
                    break
            if ok:
                for dr in range(bh):
                    for dc in range(bw):
                        grid[br0 + dr][bc0 + dc] = color
                placed = True

    # Build the output by applying the two-step transformation:
    # 1) Fill enclosed zeros inside the main shape (border's color)
    # 2) Remove all singleton cells
    out = [row[:] for row in grid]

    # Find the largest same-color connected component (the main border shape)
    h = height
    w = width
    visited = [[False] * w for _ in range(h)]
    largest_comp = []
    largest_color = None
    for rr in range(h):
        for cc in range(w):
            if grid[rr][cc] != 0 and not visited[rr][cc]:
                col = grid[rr][cc]
                stack = [(rr, cc)]
                comp = [(rr, cc)]
                visited[rr][cc] = True
                while stack:
                    cr, cc2 = stack.pop()
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc2 + dc
                        if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] == col:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                            comp.append((nr, nc))
                if len(comp) > len(largest_comp):
                    largest_comp = comp
                    largest_color = col

    if largest_color is None:
        # no non-background cells; nothing to do
        return {"input": grid, "output": out}

    # Mark zeros reachable from the outside (these are not enclosed)
    reachable = [[False] * w for _ in range(h)]
    stack = []
    for rr in range(h):
        for cc in range(w):
            if (rr == 0 or rr == h - 1 or cc == 0 or cc == w - 1) and grid[rr][cc] == 0:
                reachable[rr][cc] = True
                stack.append((rr, cc))
    while stack:
        cr, cc2 = stack.pop()
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = cr + dr, cc2 + dc
            if 0 <= nr < h and 0 <= nc < w and not reachable[nr][nc] and grid[nr][nc] == 0:
                reachable[nr][nc] = True
                stack.append((nr, nc))

    # Fill enclosed zeros with the border color
    for rr in range(h):
        for cc in range(w):
            if grid[rr][cc] == 0 and not reachable[rr][cc]:
                out[rr][cc] = largest_color

    # Remove singletons (any cell with no orthogonal neighbor of same color)
    remove = []
    for rr in range(h):
        for cc in range(w):
            col = out[rr][cc]
            if col == 0:
                continue
            has_adj = False
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = rr + dr, cc + dc
                if 0 <= nr < h and 0 <= nc < w and out[nr][nc] == col:
                    has_adj = True
                    break
            if not has_adj:
                remove.append((rr, cc))
    for (rr, cc) in remove:
        out[rr][cc] = 0

    return {"input": grid, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to a mutable grid (list of lists)
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # Find the largest same-color connected component among non-zero colors
    visited = [[False] * width for _ in range(height)]
    largest_comp = []
    largest_color = None
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and not visited[r][c]:
                col = grid[r][c]
                stack = [(r, c)]
                comp = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == col:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                            comp.append((nr, nc))
                if len(comp) > len(largest_comp):
                    largest_comp = comp
                    largest_color = col

    if largest_color is None:
        return grid

    # Find zeros reachable from outside (these are not enclosed)
    reachable = [[False] * width for _ in range(height)]
    stack = []
    for r in range(height):
        for c in range(width):
            if (r == 0 or r == height - 1 or c == 0 or c == width - 1) and grid[r][c] == 0:
                reachable[r][c] = True
                stack.append((r, c))
    while stack:
        cr, cc = stack.pop()
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = cr + dr, cc + dc
            if 0 <= nr < height and 0 <= nc < width and not reachable[nr][nc] and grid[nr][nc] == 0:
                reachable[nr][nc] = True
                stack.append((nr, nc))

    # Fill enclosed zeros with the main shape's color
    out = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 and not reachable[r][c]:
                out[r][c] = largest_color

    # Remove singletons (cells with no orthogonal neighbor of the same color)
    to_remove = []
    for r in range(height):
        for c in range(width):
            if out[r][c] == 0:
                continue
            col = out[r][c]
            has_adj = False
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and out[nr][nc] == col:
                    has_adj = True
                    break
            if not has_adj:
                to_remove.append((r, c))
    for (r, c) in to_remove:
        out[r][c] = 0

    return out

