# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 410272b4
Difficulty: hard

=== Tags ===
- Fluid spread
- Pathfinding with state
- Maze
- Pattern mirroring chain
- Loop filling

=== Description ===
Input grids consist of a maze-like structure where paths are formed by
contiguous cells of a single color (e.g., blue), separated by background cells
(e.g., white). Within the maze, certain cells contain reflective symbols (e.g.,
mirrored patterns) that reverse the direction of any traversing pathâ€”horizontal
paths become horizontal in the opposite direction upon reflection, and vertical
paths become vertical in the opposite direction. A distinct starting point
(e.g., a red dot) is positioned within the maze. The task requires simulating a
fluid that originates from the starting point, propagating through adjacent path
cells in all four cardinal directions. Upon encountering a reflective cell, the
fluid's direction reverses without changing its path. Propagation continues
until a closed loop is detected (i.e., the fluid returns to a cell in the same
direction it was previously traversing). The output grid fills all such detected
loops with a new color (e.g., green), while preserving the original maze
structure, reflective symbols, and starting point. The transformation requires
tracking directional state during propagation and identifying loops formed
through repeated directional mirroring, creating a chain of mirrored path
segments that must close into a cycle. The solution must handle multiple
concurrent propagation paths and correctly identify all loops formed via this
mirroring chain.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

_used_signatures = set()


def _compute_loops(input_grid, path_color=3, mirror_color=6, start_color=2):
    """
    Given a grid, simulate deterministic fluid propagation from every start cell (start_color).
    Returns a set of coordinates (r,c) that are part of detected cycles (only path cells will
    be filled later).
    """
    h = len(input_grid)
    w = len(input_grid[0])
    drs = [-1, 0, 1, 0]
    dcs = [0, 1, 0, -1]

    def is_passable(val):
        return val == path_color or val == mirror_color or val == start_color

    starts = [(r, c) for r in range(h) for c in range(w) if input_grid[r][c] == start_color]
    loop_cells = set()

    for start in starts:
        sr, sc = start
        for d in range(4):
            nr = sr + drs[d]
            nc = sc + dcs[d]
            if not (0 <= nr < h and 0 <= nc < w):
                continue
            if not is_passable(input_grid[nr][nc]):
                continue

            # deterministic simulation from this initial state
            pos = (nr, nc)
            dircur = d
            seen = {}  # map (r,c,dir) -> index in history
            history = []
            steps = 0
            max_steps = h * w * 10
            while True:
                r, c = pos
                if not (0 <= r < h and 0 <= c < w):
                    break
                cell = input_grid[r][c]
                if not is_passable(cell):
                    break
                state = (r, c, dircur)
                if state in seen:
                    idx = seen[state]
                    # every state from idx..end is part of a loop; record path-color cells
                    for i in range(idx, len(history)):
                        rr, cc, _ = history[i]
                        if input_grid[rr][cc] == path_color:
                            loop_cells.add((rr, cc))
                    break
                seen[state] = len(history)
                history.append((r, c, dircur))

                # reflect if hitting a mirror cell
                if cell == mirror_color:
                    dircur = (dircur + 2) % 4

                # step forward
                r2 = r + drs[dircur]
                c2 = c + dcs[dircur]
                pos = (r2, c2)

                steps += 1
                if steps > max_steps:
                    # safety
                    break
    return loop_cells


def generate():
    """Generate an input/output pair for the task.

    Layout:
      - background 0
      - path color = 3
      - mirror color = 6 (a path cell that reverses direction)
      - start color = 2 (single cell)
      - fill color (in output) = 4

    We ensure there is at least one detectable loop reachable from the start and that the
    output differs from the input. We also maintain a module-level set to avoid exact
    duplicate inputs across repeated calls.
    """
    global _used_signatures
    path_color = 3
    mirror_color = 6
    start_color = 2
    fill_color = 4

    attempts = 0
    while True:
        attempts += 1
        w = random.randint(7, 15)
        h = random.randint(7, 15)
        grid = [[0 for _ in range(w)] for _ in range(h)]

        # choose a rectangular perimeter (ring) to guarantee a closed loop
        if h < 5 or w < 5:
            continue
        r0 = random.randint(1, h - 4)
        r1 = random.randint(r0 + 2, h - 2)
        c0 = random.randint(1, w - 4)
        c1 = random.randint(c0 + 2, w - 2)

        ring_cells = set()
        for c in range(c0, c1 + 1):
            grid[r0][c] = path_color
            ring_cells.add((r0, c))
            grid[r1][c] = path_color
            ring_cells.add((r1, c))
        for r in range(r0, r1 + 1):
            grid[r][c0] = path_color
            ring_cells.add((r, c0))
            grid[r][c1] = path_color
            ring_cells.add((r, c1))

        # add a few random straight corridors to add diversity and connectivity
        ncorr = random.randint(0, 6)
        for _ in range(ncorr):
            existing = [(r, c) for r in range(h) for c in range(w) if grid[r][c] == path_color]
            if not existing:
                break
            sr, sc = random.choice(existing)
            orientation = random.choice([0, 1])  # 0=horizontal, 1=vertical
            maxlen = (w if orientation == 0 else h) // 2
            length = random.randint(2, max(2, maxlen))
            if orientation == 0:
                dirc = random.choice([-1, 1])
                for k in range(1, length + 1):
                    cc = sc + dirc * k
                    if cc < 0 or cc >= w:
                        break
                    grid[sr][cc] = path_color
            else:
                dirc = random.choice([-1, 1])
                for k in range(1, length + 1):
                    rr = sr + dirc * k
                    if rr < 0 or rr >= h:
                        break
                    grid[rr][sc] = path_color

        path_cells = [(r, c) for r in range(h) for c in range(w) if grid[r][c] == path_color]
        if not path_cells:
            continue

        # pick one ring cell to preserve as a regular path cell (not to be turned into a mirror)
        ring_preserve = None
        if ring_cells:
            ring_preserve = random.choice(list(ring_cells))

        # place some mirrors among path cells but avoid the preserved ring cell so we have at least
        # one non-mirror path cell on the ring (this guarantees the output will differ when the ring is detected)
        p = random.uniform(0.05, 0.25)
        nm = max(1, int(len(path_cells) * p))
        mirror_candidates = [pc for pc in path_cells if pc != ring_preserve]
        if nm > len(mirror_candidates):
            nm = len(mirror_candidates)
        mirrors = set(random.sample(mirror_candidates, nm)) if mirror_candidates else set()
        for (r, c) in mirrors:
            grid[r][c] = mirror_color

        # choose a start position: choose a regular path cell (not a mirror) and not the ring_preserve
        possible_starts = [pc for pc in path_cells if grid[pc[0]][pc[1]] == path_color and pc != ring_preserve]
        if not possible_starts:
            possible_starts = [pc for pc in path_cells if grid[pc[0]][pc[1]] == path_color]
            if not possible_starts:
                continue
        start_pos = random.choice(possible_starts)
        grid[start_pos[0]][start_pos[1]] = start_color

        # compute the output by detecting loops reachable from the start(s)
        loop_cells = _compute_loops(grid, path_color=path_color, mirror_color=mirror_color, start_color=start_color)
        out = [row[:] for row in grid]
        for (r, c) in loop_cells:
            if out[r][c] == path_color:
                out[r][c] = fill_color

        # ensure output differs from input (we must change at least one cell)
        changed = any(grid[r][c] != out[r][c] for r in range(h) for c in range(w))
        if not changed:
            # try carving a small extra corridor to create a non-mirror path cell inside the ring
            if ring_preserve:
                rr, cc = ring_preserve
                if grid[rr][cc] == start_color:
                    others = [rc for rc in ring_cells if grid[rc[0]][rc[1]] == path_color and rc != start_pos]
                    if others:
                        ring_preserve = others[0]
                center_r = (r0 + r1) // 2
                center_c = (c0 + c1) // 2
                dir_r = 1 if center_r > rr else -1 if center_r < rr else 0
                dir_c = 1 if center_c > cc else -1 if center_c < cc else 0
                r2, c2 = rr, cc
                for _s in range(3):
                    r2 += dir_r
                    c2 += dir_c
                    if not (0 <= r2 < h and 0 <= c2 < w):
                        break
                    grid[r2][c2] = path_color
                # recompute
                loop_cells = _compute_loops(grid, path_color=path_color, mirror_color=mirror_color, start_color=start_color)
                out = [row[:] for row in grid]
                for (r, c) in loop_cells:
                    if out[r][c] == path_color:
                        out[r][c] = fill_color
                changed = any(grid[r][c] != out[r][c] for r in range(h) for c in range(w))
            if not changed:
                # give up on this configuration and try again
                continue

        sig = tuple(tuple(row) for row in grid)
        if sig in _used_signatures:
            # regenerate if we've produced this exact input before (keeps the 100-run uniqueness very likely)
            if attempts > 1000:
                # after too many attempts, accept duplicates
                pass
            else:
                continue
        _used_signatures.add(sig)
        return {"input": grid, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable grid
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])

    path_color = 3
    mirror_color = 6
    start_color = 2
    fill_color = 4

    def _compute_loops(input_grid, path_color=3, mirror_color=6, start_color=2):
        drs = [-1, 0, 1, 0]
        dcs = [0, 1, 0, -1]

        def is_passable(val):
            return val == path_color or val == mirror_color or val == start_color

        starts = [(r, c) for r in range(len(input_grid)) for c in range(len(input_grid[0])) if input_grid[r][c] == start_color]
        loop_cells = set()

        for start in starts:
            sr, sc = start
            for d in range(4):
                nr = sr + drs[d]
                nc = sc + dcs[d]
                if not (0 <= nr < len(input_grid) and 0 <= nc < len(input_grid[0])):
                    continue
                if not is_passable(input_grid[nr][nc]):
                    continue

                pos = (nr, nc)
                dircur = d
                seen = {}
                history = []
                steps = 0
                max_steps = len(input_grid) * len(input_grid[0]) * 10
                while True:
                    r, c = pos
                    if not (0 <= r < len(input_grid) and 0 <= c < len(input_grid[0])):
                        break
                    cell = input_grid[r][c]
                    if not is_passable(cell):
                        break
                    state = (r, c, dircur)
                    if state in seen:
                        idx = seen[state]
                        for i in range(idx, len(history)):
                            rr, cc, _ = history[i]
                            if input_grid[rr][cc] == path_color:
                                loop_cells.add((rr, cc))
                        break
                    seen[state] = len(history)
                    history.append((r, c, dircur))

                    if cell == mirror_color:
                        dircur = (dircur + 2) % 4

                    r2 = r + drs[dircur]
                    c2 = c + dcs[dircur]
                    pos = (r2, c2)

                    steps += 1
                    if steps > max_steps:
                        break
        return loop_cells

    loop_cells = _compute_loops(grid, path_color=path_color, mirror_color=mirror_color, start_color=start_color)
    out = [row[:] for row in grid]
    for (r, c) in loop_cells:
        if out[r][c] == path_color:
            out[r][c] = fill_color
    return out

