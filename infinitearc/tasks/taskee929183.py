# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: ee929183
Difficulty: hard

=== Tags ===
- Shape to color encoding
- Pressure release
- Hierarchical reasoning
- Follow color path to destination

=== Description ===
Input grids feature a central 3Ã—3 chamber composed of color 5, surrounded by a
labyrinthine path of cells. Each cell in the path contains a direction-encoded
color (1=right, 2=up, 3=left, 4=down), forming a single continuous path that
begins at the chamber's perimeter and follows the directional cues until exiting
the grid. The output grid transforms the path by applying a hierarchical color
encoding based on the path's length (pressure). The pressure level determines
the starting point of a fixed color cycle [1,2,3,4], calculated as (pressure -
1) mod 4. Each cell in the path is assigned a color by advancing through the
cycle in order: the first cell uses the starting color, the second the next, and
so on, wrapping around the cycle. The destination cell (exit point) is colored
with the final cycle color. Non-path cells and the central chamber retain their
original colors. This requires hierarchical reasoning to compute the path
length, determine the cycle offset, and sequentially apply the color
transformation along the path's trajectory.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(8, 30)
    height = random.randint(8, 30)
    grid = [[0] * width for _ in range(height)]
    
    chamber_size = 3
    chamber_start_row = (height - chamber_size) // 2
    chamber_start_col = (width - chamber_size) // 2
    for r in range(chamber_start_row, chamber_start_row + chamber_size):
        for c in range(chamber_start_col, chamber_start_col + chamber_size):
            grid[r][c] = 5
    
    start_row = chamber_start_row - 1
    start_col = chamber_start_col + 1
    max_L = width - start_col
    L = random.randint(5, max_L)
    
    for i in range(L):
        r, c = start_row, start_col + i
        if 0 <= r < height and 0 <= c < width:
            grid[r][c] = 1
    
    output = [row[:] for row in grid]
    start_index = (L - 1) % 4
    cycle = [1, 2, 3, 4]
    for i in range(L):
        r, c = start_row, start_col + i
        if 0 <= r < height and 0 <= c < width:
            output[r][c] = cycle[(start_index + i) % 4]
    
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    chamber_size = 3
    chamber_start_row, chamber_start_col = -1, -1
    for r in range(len(input_list) - chamber_size + 1):
        for c in range(len(input_list[0]) - chamber_size + 1):
            if all(input_list[r+i][c+j] == 5 for i in range(chamber_size) for j in range(chamber_size)):
                chamber_start_row, chamber_start_col = r, c
                break
        if chamber_start_row != -1:
            break
    if chamber_start_row == -1:
        chamber_start_row = len(input_list) // 2 - 1
        chamber_start_col = len(input_list[0]) // 2 - 1
    
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    start_row, start_col = -1, -1
    for dr, dc in directions:
        r, c = chamber_start_row + dr, chamber_start_col + dc
        if 0 <= r < len(input_list) and 0 <= c < len(input_list[0]) and input_list[r][c] in [1,2,3,4]:
            start_row, start_col = r, c
            break
    if start_row == -1:
        start_row, start_col = chamber_start_row - 1, chamber_start_col + 1
    
    path = []
    cur_r, cur_c = start_row, start_col
    while 0 <= cur_r < len(input_list) and 0 <= cur_c < len(input_list[0]):
        if input_list[cur_r][cur_c] not in [1,2,3,4]:
            break
        path.append((cur_r, cur_c))
        d = input_list[cur_r][cur_c]
        dr, dc = 0, 0
        if d == 1: dc = 1
        elif d == 2: dr = -1
        elif d == 3: dc = -1
        elif d == 4: dr = 1
        cur_r += dr
        cur_c += dc
    
    L = len(path)
    start_index = (L - 1) % 4
    cycle = [1, 2, 3, 4]
    output = [row[:] for row in input_list]
    for i, (r, c) in enumerate(path):
        output[r][c] = cycle[(start_index + i) % 4]
    
    return tuple(tuple(row) for row in output)
