# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: e24544be
Difficulty: insane

=== Tags ===
- Color implication network
- Rule embedding
- Split and merge

=== Description ===
Input grids are large, complex 20x20 grids with a background color (0) and
multiple contiguous regions of colors 1-9. Embedded in the top-left 2x2 corner
is a rule matrix that defines a dynamic color implication network: the four
cells (0,0), (0,1), (1,0), (1,1) represent colors S, T, U, V. The split rule
states that whenever a region of color S is adjacent (horizontally or
vertically) to a region of color T, the boundary between them splits into a new
region of color U. The merge rule states that whenever a region of color U is
adjacent to a region of color V, they merge into a single region of color V. The
output grid is generated by iteratively applying all possible split and merge
operations defined by the rule matrix until no further changes can occur. Each
operation must be applied in a specific order (splits before merges), with new
regions created during splits potentially triggering additional operations in
subsequent iterations. The background remains color 0, and all other regions
remain unchanged. The rule matrix is dynamically embedded within each input
grid, requiring the solver to extract the specific rules (S, T, U, V) from the
top-left corner before applying the transformations. The task requires
recognizing the embedded rules, handling cascading operations, and resolving
complex interactions between split and merge sequences in a visually driven
network of color relationships.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    size = 20
    colors = list(range(1, 10))
    random.shuffle(colors)
    S, T, U, V = colors[:4]
    grid = common.grid(size, size, 0)
    grid[0][0] = S
    grid[0][1] = T
    grid[1][0] = U
    grid[1][1] = V
    for r in range(2, 5):
        for c in range(2, 5):
            grid[r][c] = S
    for r in range(2, 5):
        for c in range(6, 9):
            grid[r][c] = T
    for r in range(12, 15):
        for c in range(2, 5):
            grid[r][c] = U
    for r in range(12, 15):
        for c in range(6, 9):
            grid[r][c] = V
    for r in range(size):
        for c in range(size):
            if grid[r][c] == 0:
                choices = [col for col in range(1, 10) if col not in (S, T, U, V)]
                grid[r][c] = random.choice(choices)
    output = apply_transform(grid, S, T, U, V)
    return {'input': grid, 'output': output}

def apply_transform(grid, S, T, U, V):
    current = [row[:] for row in grid]
    changed = True
    while changed:
        changed = False
        for r in range(len(current)):
            for c in range(len(current[0])):
                if current[r][c] == S:
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < len(current) and 0 <= nc < len(current[0]) and current[nr][nc] == T:
                            current[r][c] = U
                            changed = True
                            break
        for r in range(len(current)):
            for c in range(len(current[0])):
                if current[r][c] == U:
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < len(current) and 0 <= nc < len(current[0]) and current[nr][nc] == V:
                            current[r][c] = V
                            changed = True
                            break
    return current


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    S = input_grid[0][0]
    T = input_grid[0][1]
    U = input_grid[1][0]
    V = input_grid[1][1]
    current = [row[:] for row in input_grid]
    changed = True
    while changed:
        changed = False
        for r in range(len(current)):
            for c in range(len(current[0])):
                if current[r][c] == S:
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < len(current) and 0 <= nc < len(current[0]) and current[nr][nc] == T:
                            current[r][c] = U
                            changed = True
                            break
        for r in range(len(current)):
            for c in range(len(current[0])):
                if current[r][c] == U:
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < len(current) and 0 <= nc < len(current[0]) and current[nr][nc] == V:
                            current[r][c] = V
                            changed = True
                            break
    return current
