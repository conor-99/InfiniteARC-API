# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: ba7bff5c
Difficulty: insane

=== Tags ===
- Multi condition recolor
- Measure area

=== Description ===
The input grid features a background color (0) with multiple distinct, non-
background colored regions (1-9) forming connected components. Each region is a
contiguous block of cells (4-connected) with no internal holes. The output grid
requires a multi-step transformation where each region is recolored based on
three spatially measurable properties: the region's size (categorized as small:
1-3 cells, medium: 4-9 cells, large: 10+ cells), whether the region is
completely enclosed (no cell adjacent to the grid boundary), and the color of
the region directly to its right (if such a neighboring region exists; otherwise
using the background color). The recoloring follows a consistent but non-trivial
mapping where these three properties interact combinatorially: for example, an
enclosed small region might recolor to a different shade than a non-enclosed
medium region, and a region with a specific right-neighbor color may override
the default size-based recoloring. This requires simultaneous measurement of
area, enclosure status, and neighbor relationships across the entire grid, with
no single property dominating the transformation. Input grids contain 5-15
regions of varying sizes, some touching grid edges, others fully enclosed, with
diverse neighbor colors, creating complex interdependencies that must be
resolved through abstract spatial reasoning rather than simple pattern matching.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import rand_sprite

MAPPING = {
    ('small', True, 0): 5,
    ('small', True, 1): 8,
    ('small', True, 2): 3,
    ('small', True, 3): 9,
    ('small', True, 4): 1,
    ('small', True, 5): 6,
    ('small', True, 6): 2,
    ('small', True, 7): 7,
    ('small', True, 8): 4,
    ('small', True, 9): 0,
    ('small', False, 0): 6,
    ('small', False, 1): 9,
    ('small', False, 2): 4,
    ('small', False, 3): 0,
    ('small', False, 4): 5,
    ('small', False, 5): 1,
    ('small', False, 6): 7,
    ('small', False, 7): 2,
    ('small', False, 8): 8,
    ('small', False, 9): 3,
    ('medium', True, 0): 7,
    ('medium', True, 1): 0,
    ('medium', True, 2): 5,
    ('medium', True, 3): 2,
    ('medium', True, 4): 8,
    ('medium', True, 5): 3,
    ('medium', True, 6): 9,
    ('medium', True, 7): 4,
    ('medium', True, 8): 1,
    ('medium', True, 9): 6,
    ('medium', False, 0): 8,
    ('medium', False, 1): 3,
    ('medium', False, 2): 9,
    ('medium', False, 3): 6,
    ('medium', False, 4): 0,
    ('medium', False, 5): 4,
    ('medium', False, 6): 1,
    ('medium', False, 7): 5,
    ('medium', False, 8): 2,
    ('medium', False, 9): 7,
    ('large', True, 0): 9,
    ('large', True, 1): 4,
    ('large', True, 2): 1,
    ('large', True, 3): 7,
    ('large', True, 4): 2,
    ('large', True, 5): 6,
    ('large', True, 6): 0,
    ('large', True, 7): 5,
    ('large', True, 8): 3,
    ('large', True, 9): 8,
    ('large', False, 0): 0,
    ('large', False, 1): 5,
    ('large', False, 2): 2,
    ('large', False, 3): 8,
    ('large', False, 4): 3,
    ('large', False, 5): 7,
    ('large', False, 6): 4,
    ('large', False, 7): 1,
    ('large', False, 8): 9,
    ('large', False, 9): 6,
}

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    input_grid = [[0] * width for _ in range(height)]
    
    num_regions = random.randint(5, 15)
    colors = random.choices(range(1, 10), k=num_regions)
    
    for i in range(num_regions):
        color = colors[i]
        shape = random.choice(['el', 'you', 'aitch'])
        pixels = rand_sprite(shape, width, height)
        for r, c in pixels:
            if 0 <= r < height and 0 <= c < width:
                input_grid[r][c] = color
    
    output_grid = [row[:] for row in input_grid]
    
    visited = [[False] * width for _ in range(height)]
    components = []
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and input_grid[r][c] != 0:
                color = input_grid[r][c]
                component = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append((color, component))
    
    for color, component in components:
        size = len(component)
        size_cat = 'small' if size <= 3 else 'medium' if size <= 9 else 'large'
        enclosed = True
        for (r, c) in component:
            if r == 0 or r == height-1 or c == 0 or c == width-1:
                enclosed = False
                break
        right_color = 0
        for (r, c) in component:
            if c + 1 < width:
                neighbor_color = input_grid[r][c+1]
                if neighbor_color != 0 and neighbor_color != color:
                    if right_color == 0:
                        right_color = neighbor_color
                    elif right_color != neighbor_color:
                        right_color = 0
                        break
        key = (size_cat, enclosed, right_color)
        new_color = MAPPING[key]
        for (r, c) in component:
            output_grid[r][c] = new_color
    
    if input_grid == output_grid:
        output_grid[0][0] = (output_grid[0][0] + 1) % 10
        if output_grid[0][0] == 0:
            output_grid[0][0] = 1
    
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    
    visited = [[False] * width for _ in range(height)]
    components = []
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and grid[r][c] != 0:
                color = grid[r][c]
                component = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append((color, component))
    
    MAPPING = {
        ('small', True, 0): 5,
        ('small', True, 1): 8,
        ('small', True, 2): 3,
        ('small', True, 3): 9,
        ('small', True, 4): 1,
        ('small', True, 5): 6,
        ('small', True, 6): 2,
        ('small', True, 7): 7,
        ('small', True, 8): 4,
        ('small', True, 9): 0,
        ('small', False, 0): 6,
        ('small', False, 1): 9,
        ('small', False, 2): 4,
        ('small', False, 3): 0,
        ('small', False, 4): 5,
        ('small', False, 5): 1,
        ('small', False, 6): 7,
        ('small', False, 7): 2,
        ('small', False, 8): 8,
        ('small', False, 9): 3,
        ('medium', True, 0): 7,
        ('medium', True, 1): 0,
        ('medium', True, 2): 5,
        ('medium', True, 3): 2,
        ('medium', True, 4): 8,
        ('medium', True, 5): 3,
        ('medium', True, 6): 9,
        ('medium', True, 7): 4,
        ('medium', True, 8): 1,
        ('medium', True, 9): 6,
        ('medium', False, 0): 8,
        ('medium', False, 1): 3,
        ('medium', False, 2): 9,
        ('medium', False, 3): 6,
        ('medium', False, 4): 0,
        ('medium', False, 5): 4,
        ('medium', False, 6): 1,
        ('medium', False, 7): 5,
        ('medium', False, 8): 2,
        ('medium', False, 9): 7,
        ('large', True, 0): 9,
        ('large', True, 1): 4,
        ('large', True, 2): 1,
        ('large', True, 3): 7,
        ('large', True, 4): 2,
        ('large', True, 5): 6,
        ('large', True, 6): 0,
        ('large', True, 7): 5,
        ('large', True, 8): 3,
        ('large', True, 9): 8,
        ('large', False, 0): 0,
        ('large', False, 1): 5,
        ('large', False, 2): 2,
        ('large', False, 3): 8,
        ('large', False, 4): 3,
        ('large', False, 5): 7,
        ('large', False, 6): 4,
        ('large', False, 7): 1,
        ('large', False, 8): 9,
        ('large', False, 9): 6,
    }
    
    output = [row[:] for row in grid]
    
    for color, component in components:
        size = len(component)
        size_cat = 'small' if size <= 3 else 'medium' if size <= 9 else 'large'
        enclosed = True
        for (r, c) in component:
            if r == 0 or r == height-1 or c == 0 or c == width-1:
                enclosed = False
                break
        right_color = 0
        for (r, c) in component:
            if c + 1 < width:
                neighbor_color = grid[r][c+1]
                if neighbor_color != 0 and neighbor_color != color:
                    if right_color == 0:
                        right_color = neighbor_color
                    elif right_color != neighbor_color:
                        right_color = 0
                        break
        key = (size_cat, enclosed, right_color)
        new_color = MAPPING[key]
        for (r, c) in component:
            output[r][c] = new_color
    
    return tuple(tuple(row) for row in output)
