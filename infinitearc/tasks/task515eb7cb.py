# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 515eb7cb
Difficulty: hard

=== Tags ===
- Detect repetition
- Detect hor lines

=== Description ===
The task involves transforming an input grid by identifying horizontal lines
(rows where every cell in the row shares the same color) and detecting instances
where such lines are repeated across the grid. The output grid is generated by
modifying all cells within any horizontal line that appears more than once
(i.e., another row exactly matches its color sequence) to a distinct, uniform
color, while preserving all other cells in their original state. The
transformation requires recognizing both the horizontal line structure and the
repetition of these lines, which may be non-adjacent and spread across the grid.
Input grids feature complex arrangements of horizontal lines interspersed with
non-uniform rows, demanding careful analysis to distinguish valid horizontal
lines from random patterns and to detect subtle repetitions in their color
sequences.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    from collections import defaultdict
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = [[0] * width for _ in range(height)]
    
    num_solid = random.randint(2, min(5, height))
    color_assignments = [0] * 2 + [random.randint(1, 8) for _ in range(num_solid - 2)]
    
    solid_row_indices = random.sample(range(height), num_solid)
    for idx, color in zip(solid_row_indices, color_assignments):
        input_grid[idx] = [color] * width
    
    for r in range(height):
        if r not in solid_row_indices:
            while True:
                row = [random.randint(0, 8) for _ in range(width)]
                if len(set(row)) > 1:
                    input_grid[r] = row
                    break
    
    output_grid = [row[:] for row in input_grid]
    solid_colors = []
    for r in range(height):
        if all(x == input_grid[r][0] for x in input_grid[r]):
            solid_colors.append(input_grid[r][0])
    
    color_count = defaultdict(int)
    for color in solid_colors:
        color_count[color] += 1
    
    for r in range(height):
        if all(x == input_grid[r][0] for x in input_grid[r]):
            color = input_grid[r][0]
            if color_count[color] > 1:
                output_grid[r] = [9] * width
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    from collections import defaultdict
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = [row[:] for row in input_grid]
    solid_colors = []
    for r in range(height):
        if all(x == input_grid[r][0] for x in input_grid[r]):
            solid_colors.append(input_grid[r][0])
    
    color_count = defaultdict(int)
    for color in solid_colors:
        color_count[color] += 1
    
    for r in range(height):
        if all(x == input_grid[r][0] for x in input_grid[r]):
            color = input_grid[r][0]
            if color_count[color] > 1:
                output_grid[r] = [9] * width
    
    return output_grid
