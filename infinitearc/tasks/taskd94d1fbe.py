# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: d94d1fbe
Difficulty: hard

=== Tags ===
- Friction path

=== Description ===
Input grids are large (20×20 or larger) with a uniform background color. The
grid contains a single, straight-line path composed of a distinct color (e.g.,
color 1), oriented either horizontally or vertically, stretching from one grid
edge to the opposite edge. Scattered along this path are friction
elements—single cells of a secondary color (e.g., color 2)—positioned such that
their placement relative to the path’s current direction dictates a 90° turn.
When moving in a given direction (e.g., east), a friction element located north
of the path causes a left turn (north), while one positioned south causes a
right turn (south). This rule applies consistently for all directions: for
north-moving paths, west-positioned friction elements cause left turns (west),
and east-positioned ones cause right turns (east); similarly for south and west-
moving paths. The output grid retains all input elements (background, path,
friction elements) but modifies the path to follow these turns at each friction
element location. The path continues in the new direction until it exits the
grid, with all turns applied sequentially. Friction elements remain visible in
the output and do not overwrite the path. The transformation requires tracking
the path’s direction through multiple sequential turns, making the task
challenging due to the need for dynamic directional reasoning based on relative
positioning rather than fixed rules or numerical values.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(20, 30)
    height = random.randint(20, 30)
    input_grid = [[0] * width for _ in range(height)]
    path_color = 1
    friction_color = 2
    
    if random.choice([True, False]):
        row = random.randint(1, height - 2)
        for c in range(width):
            input_grid[row][c] = path_color
        col = random.randint(1, width - 2)
        friction_row = row - 1 if random.choice([True, False]) else row + 1
        input_grid[friction_row][col] = friction_color
        output_grid = [row[:] for row in input_grid]
        if friction_row == row - 1:
            for r in range(row, -1, -1):
                output_grid[r][col] = path_color
        else:
            for r in range(row, height):
                output_grid[r][col] = path_color
    else:
        col = random.randint(1, width - 2)
        for r in range(height):
            input_grid[r][col] = path_color
        row = random.randint(1, height - 2)
        friction_col = col - 1 if random.choice([True, False]) else col + 1
        input_grid[row][friction_col] = friction_color
        output_grid = [row[:] for row in input_grid]
        if friction_col == col - 1:
            for c in range(col, -1, -1):
                output_grid[row][c] = path_color
        else:
            for c in range(col, width):
                output_grid[row][c] = path_color
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    path_color = 1
    friction_color = 2
    
    # Check for horizontal path
    for r in range(height):
        if all(cell == path_color for cell in input_grid[r]):
            path_row = r
            # Find friction element
            friction_col = None
            friction_row = None
            for c in range(width):
                if input_grid[path_row - 1][c] == friction_color:
                    friction_col = c
                    friction_row = path_row - 1
                    break
                elif input_grid[path_row + 1][c] == friction_color:
                    friction_col = c
                    friction_row = path_row + 1
                    break
            if friction_col is not None:
                if friction_row == path_row - 1:
                    for r2 in range(path_row, -1, -1):
                        input_grid[r2][friction_col] = path_color
                else:
                    for r2 in range(path_row, height):
                        input_grid[r2][friction_col] = path_color
            return input_grid

    # Check for vertical path
    for c in range(width):
        if all(input_grid[r][c] == path_color for r in range(height)):
            path_col = c
            friction_row = None
            friction_col = None
            for r in range(height):
                if input_grid[r][path_col - 1] == friction_color:
                    friction_row = r
                    friction_col = path_col - 1
                    break
                elif input_grid[r][path_col + 1] == friction_color:
                    friction_row = r
                    friction_col = path_col + 1
                    break
            if friction_row is not None:
                if friction_col == path_col - 1:
                    for c2 in range(path_col, -1, -1):
                        input_grid[friction_row][c2] = path_color
                else:
                    for c2 in range(path_col, width):
                        input_grid[friction_row][c2] = path_color
            return input_grid

    return input_grid
