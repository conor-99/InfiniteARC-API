# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 2c59e03d
Difficulty: insane

=== Tags ===
- Shape morphing
- Dual source paths
- Color majority row

=== Description ===
Input grids are 20×20, featuring a single background color (0) and two distinct
source elements: a color 1 cell at the top-left corner (0,0) and a color 2 cell
at the bottom-right corner (19,19). Each source emits a path moving orthogonally
in a fixed initial direction (color 1 path moves east, color 2 path moves west).
As each path traverses a new row, the majority color (non-background, non-zero)
of that row dictates three transformations: (1) the path's color updates to
match the majority color, (2) the path's direction rotates 90° counterclockwise
for odd majority colors or clockwise for even majority colors relative to its
current direction, and (3) the path's width in that row morphs to equal the
majority color's numeric value (e.g., a majority color of 5 creates a 5-cell-
wide segment). Paths move cell-by-cell in the new direction until exiting the
grid (color 1 path exits right, color 2 path exits left), with all
transformations applied sequentially per row traversed. The output grid renders
both paths with updated colors, directions, and morphed widths while preserving
background elements and ensuring no path overlaps or overwrites other grid
features.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random


def get_majority_color(grid, row):
    counts = [0] * 10
    for color in grid[row]:
        if color != 0:
            counts[color] += 1
    # If there are no non-zero colors in the row, choose a default majority (1)
    if sum(counts[1:]) == 0:
        return 1
    max_count = max(counts[1:])
    candidates = [color for color in range(1, 10) if counts[color] == max_count]
    return min(candidates)


def _simulate_path(input_grid, output_grid, start_r, start_c, start_dir, directions):
    height = len(input_grid)
    width = len(input_grid[0])
    r, c = start_r, start_c
    current_dir = start_dir
    # safety guard to prevent infinite loops in degenerate configurations
    steps = 0
    while 0 <= r < height and 0 <= c < width and steps < 1000:
        m = get_majority_color(input_grid, r)
        # update direction: odd -> CCW, even -> CW
        if m % 2 == 1:
            current_dir = (current_dir + 3) % 4
        else:
            current_dir = (current_dir + 1) % 4
        dr, dc = directions[current_dir]
        # paint a segment of length m in the new direction (color = m)
        last_r, last_c = r, c
        for step in range(m):
            nr = r + step * dr
            nc = c + step * dc
            if 0 <= nr < height and 0 <= nc < width:
                output_grid[nr][nc] = m
                last_r, last_c = nr, nc
            else:
                # left the grid while painting; set last painted outside so the next
                # head will be outside and terminate the loop
                last_r = nr
                last_c = nc
                break
        # move head one cell beyond the last painted cell to ensure progress
        r = last_r + dr
        c = last_c + dc
        steps += 1


def generate():
    width = 20
    height = 20
    # start with background
    input_grid = [[0 for _ in range(width)] for _ in range(height)]
    # place the two sources
    input_grid[0][0] = 1
    input_grid[height - 1][width - 1] = 2

    # For each row choose a majority color and place several occurrences of it.
    # This guarantees a clear majority color per row for the solver to detect.
    for r in range(height):
        m = random.randint(1, 9)
        occurrences = random.randint(3, 12)
        placed = 0
        tries = 0
        while placed < occurrences and tries < occurrences * 10:
            c = random.randrange(width)
            # never overwrite the source cells
            if (r == 0 and c == 0) or (r == height - 1 and c == width - 1):
                tries += 1
                continue
            if input_grid[r][c] == 0:
                input_grid[r][c] = m
                placed += 1
            else:
                # occasionally allow replacing to keep randomness but avoid infinite loops
                tries += 1

    # build output by simulating the two paths on a copy of the input
    output_grid = [row[:] for row in input_grid]
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # E, S, W, N

    # Path 1: starts at top-left, initial direction east (index 0)
    _simulate_path(input_grid, output_grid, 0, 0, 0, directions)
    # Path 2: starts at bottom-right, initial direction west (index 2)
    _simulate_path(input_grid, output_grid, height - 1, width - 1, 2, directions)

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def get_majority_color(grid, row):
    counts = [0] * 10
    for color in grid[row]:
        if color != 0:
            counts[color] += 1
    if sum(counts[1:]) == 0:
        return 1
    max_count = max(counts[1:])
    candidates = [color for color in range(1, 10) if counts[color] == max_count]
    return min(candidates)


def _simulate_path(input_grid, output_grid, start_r, start_c, start_dir, directions):
    height = len(input_grid)
    width = len(input_grid[0])
    r, c = start_r, start_c
    current_dir = start_dir
    steps = 0
    while 0 <= r < height and 0 <= c < width and steps < 1000:
        m = get_majority_color(input_grid, r)
        if m % 2 == 1:
            current_dir = (current_dir + 3) % 4
        else:
            current_dir = (current_dir + 1) % 4
        dr, dc = directions[current_dir]
        last_r, last_c = r, c
        for step in range(m):
            nr = r + step * dr
            nc = c + step * dc
            if 0 <= nr < height and 0 <= nc < width:
                output_grid[nr][nc] = m
                last_r, last_c = nr, nc
            else:
                last_r = nr
                last_c = nc
                break
        r = last_r + dr
        c = last_c + dc
        steps += 1


def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = [row[:] for row in input_grid]
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    # Path 1
    _simulate_path(input_grid, output_grid, 0, 0, 0, directions)
    # Path 2
    _simulate_path(input_grid, output_grid, height - 1, width - 1, 2, directions)
    return output_grid

