# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: e23e8b07
Difficulty: insane

=== Tags ===
- Momentum conservation path
- Associate colors to colors
- Propagate label

=== Description ===
Momentum Conservation Path with Color Association and Propagation  Input grids
are large (30×30) with a single token (a 1×1 colored square) positioned along
the left edge facing right. The background consists of uniform color 0.
Scattered throughout are colored markers (1-9) that serve as directional
triggers. Each color trigger has a fixed direction change rule: color 1 = turn
left (90° CCW), color 2 = turn right (90° CW), color 3 = reverse direction,
color 4 = continue straight. The token moves cell-by-cell through background
cells until entering a trigger cell, where it changes direction per the
trigger's rule.  The path is drawn using a color association mapping: each
trigger color C maps to a distinct output color C' (e.g., C=1 → C'=5, C=2 →
C'=8, C=3 → C'=3, C=4 → C'=9). The token's starting position is marked with its
original color, and the path continues until the token exits the grid through
any boundary.  The propagation rule requires that after path drawing, all
background cells directly adjacent (orthogonally) to the path are colored with
the same C' as the nearest path segment. This creates a "color field" extending
one cell outward from the path. Directional triggers remain visible in their
original colors, and background cells not adjacent to the path remain color 0.
The path must follow momentum conservation (direction changes must be consistent
with trigger rules), and propagation must strictly apply to background cells
only. The output grid must show the complete path with associated colors, the
propagated color fields, and all input elements preserved.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = 30
    height = 30
    input_grid = [[0] * width for _ in range(height)]
    
    start_row = random.randint(1, 28)
    S = random.randint(1, 9)
    input_grid[start_row][0] = S
    
    trigger_mapping = {1: 5, 2: 8, 3: 3, 4: 9}
    
    first_trigger_col = random.randint(5, 15)
    first_trigger_col = min(first_trigger_col, width - 1)
    second_trigger_row = min(start_row + random.randint(3, 8), height - 1)
    second_trigger_col = min(random.randint(first_trigger_col + 5, 25), width - 1)
    
    trigger_positions = [(start_row, first_trigger_col), (second_trigger_row, second_trigger_col)]
    trigger_colors = [random.choice([1, 2, 3, 4]) for _ in range(len(trigger_positions))]
    
    for i, (r, c) in enumerate(trigger_positions):
        input_grid[r][c] = trigger_colors[i]
    
    output_grid = [[0] * width for _ in range(height)]
    output_grid[start_row][0] = S
    current_pos = (start_row, 0)
    direction = (0, 1)
    path_color = S
    
    max_steps = 900
    steps = 0
    while steps < max_steps:
        steps += 1
        next_pos = (current_pos[0] + direction[0], current_pos[1] + direction[1])
        if next_pos[0] < 0 or next_pos[0] >= height or next_pos[1] < 0 or next_pos[1] >= width:
            break
        cell_color = input_grid[next_pos[0]][next_pos[1]]
        if 1 <= cell_color <= 4:
            if cell_color == 1:
                direction = (-direction[1], direction[0])
            elif cell_color == 2:
                direction = (direction[1], -direction[0])
            elif cell_color == 3:
                direction = (-direction[0], -direction[1])
            path_color = trigger_mapping[cell_color]
        output_grid[next_pos[0]][next_pos[1]] = path_color
        current_pos = next_pos
    
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] == 0:
                closest_color = 0
                min_dist = float('inf')
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        if output_grid[nr][nc] != 0:
                            dist = abs(r - nr) + abs(c - nc)
                            if dist < min_dist:
                                min_dist = dist
                                closest_color = output_grid[nr][nc]
                if closest_color != 0:
                    output_grid[r][c] = closest_color
    
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    start_row = None
    for r in range(height):
        if input_grid[r][0] != 0:
            start_row = r
            break
    if start_row is None:
        return [[0] * width for _ in range(height)]
    
    S = input_grid[start_row][0]
    trigger_mapping = {1: 5, 2: 8, 3: 3, 4: 9}
    
    output = [[0] * width for _ in range(height)]
    output[start_row][0] = S
    current_pos = (start_row, 0)
    direction = (0, 1)
    path_color = S
    
    max_steps = 900
    steps = 0
    while steps < max_steps:
        steps += 1
        next_pos = (current_pos[0] + direction[0], current_pos[1] + direction[1])
        if next_pos[0] < 0 or next_pos[0] >= height or next_pos[1] < 0 or next_pos[1] >= width:
            break
        cell_color = input_grid[next_pos[0]][next_pos[1]]
        if 1 <= cell_color <= 4:
            if cell_color == 1:
                direction = (-direction[1], direction[0])
            elif cell_color == 2:
                direction = (direction[1], -direction[0])
            elif cell_color == 3:
                direction = (-direction[0], -direction[1])
            path_color = trigger_mapping[cell_color]
        output[next_pos[0]][next_pos[1]] = path_color
        current_pos = next_pos
    
    for r in range(height):
        for c in range(width):
            if output[r][c] == 0:
                closest_color = 0
                min_dist = float('inf')
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        if output[nr][nc] != 0:
                            dist = abs(r - nr) + abs(c - nc)
                            if dist < min_dist:
                                min_dist = dist
                                closest_color = output[nr][nc]
                if closest_color != 0:
                    output[r][c] = closest_color
    
    return output
