# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 1194e2a7
Difficulty: mediumâ€“hard

=== Tags ===
- Gate chain construction
- Tunnel connection
- Take minimum
- Select every nth column

=== Description ===
Input grids feature vertical "gate" structures (each a vertical line of a single
color) positioned in various columns, surrounded by a background color.
Horizontal "tunnel" segments (of a distinct color) are present in some columns
between the gates. The output grid connects all gates in left-to-right order by
constructing a continuous tunnel path: for each consecutive gate pair, the path
extends through columns that are multiples of a fixed interval (e.g., every 3rd
column), selecting the topmost (minimum row index) tunnel segment in each
selected column to form the connection. Existing tunnels and gates remain
unchanged, while new tunnel segments are added to bridge gaps between gates,
ensuring no overlaps with non-background elements. The resulting tunnel chain
must form a seamless path from the leftmost to the rightmost gate, with all
connections adhering strictly to the column selection rule and minimum row
selection.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    """
    Generates an ARC-style input/output pair for the gate-and-tunnel chaining task.

    Structure produced:
    - Background color 0.
    - Gates: vertical contiguous segments of color 2 placed in equally spaced columns
      (columns = offset + i * n). Gates are placed below the top row so the topmost
      row(s) remain available for tunnel creation.
    - Some existing tunnel pixels (color 3) are placed at the topmost row (row 0) in a
      random subset of the gate columns. Additional noisy tunnels (color 3) may
      appear in lower rows but only outside the gate-range so they do not interfere
      with the topmost-row anchor.
    - The output ensures that every column between the leftmost and rightmost gate
      (inclusive) has at least one tunnel pixel: if a column lacks any tunnel pixel,
      a tunnel pixel is placed at the topmost available background cell (i.e. the
      first row with value 0). This produces a continuous horizontal chain at that
      topmost row because the generator avoids putting non-background cells above it
      in the affected columns.
    """
    # Choose interval and number of gates
    n = random.choice([2, 3, 4])
    num_gates = random.randint(3, 5)

    # Choose an offset so that all gates fit in the grid
    offset = random.randint(0, n - 1)
    min_width = offset + (num_gates - 1) * n + 1
    width = random.randint(min_width, min(30, min_width + random.randint(0, 7)))
    height = random.randint(6, min(30, 20))

    # Colors (fixed for simplicity and to make solver deterministic)
    BACK = 0
    GATE = 2
    TUNNEL = 3

    # initialize grid
    grid = [[BACK for _ in range(width)] for _ in range(height)]

    # compute gate columns (equally spaced)
    gate_columns = [offset + i * n for i in range(num_gates)]

    # Place gates: vertical contiguous segments placed below the top row
    for c in gate_columns:
        max_gheight = max(2, min(6, height - 2))
        gheight = random.randint(2, max_gheight)
        top_min = 1
        top_max = height - gheight
        if top_max < top_min:
            top_min = 1
            top_max = 1
        top = random.randint(top_min, top_max)
        for r in range(top, top + gheight):
            grid[r][c] = GATE

    left = gate_columns[0]
    right = gate_columns[-1]

    # Place some existing tunnel markers at the topmost row (row 0) in a random subset
    # of the gate/selected columns. We never prefill all of them so the input differs
    # from the output (ensures at least one new tunnel must be added).
    selected = gate_columns[:]
    max_prefill = max(0, len(selected) - 1)
    k = random.randint(0, max_prefill)
    prefill_cols = random.sample(selected, k) if k > 0 else []
    for c in prefill_cols:
        grid[0][c] = TUNNEL

    # Add some noisy tunnel pixels in lower rows, but only outside the selected [left,right]
    # interval so we don't create columns that already contain a tunnel in the selected
    # interval at a lower row (which would prevent the generator from adding a topmost
    # tunnel in that column).
    allowed_cols = [c for c in range(width) if c < left or c > right]
    noise = random.randint(0, max(0, (width * height) // 20))
    for _ in range(noise):
        if not allowed_cols:
            break
        c = random.choice(allowed_cols)
        r = random.randint(1, height - 1)
        if grid[r][c] == BACK:
            grid[r][c] = TUNNEL

    # Build output: ensure every column between left and right (inclusive) has at least
    # one TUNNEL pixel; if it doesn't, place one at the topmost available background
    # cell (first BACK). This mirrors the solver strategy of "placing at the
    # topmost 0" when a tunnel is missing.
    out = [row[:] for row in grid]
    for c in range(left, right + 1):
        has_tunnel = any(out[r][c] == TUNNEL for r in range(height))
        if not has_tunnel:
            for r in range(height):
                if out[r][c] == BACK:
                    out[r][c] = TUNNEL
                    break

    return {"input": grid, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    BACK = 0
    GATE = 2
    TUNNEL = 3

    # Detect gate columns: any column that contains the gate color
    gate_columns = []
    for c in range(width):
        for r in range(height):
            if grid[r][c] == GATE:
                gate_columns.append(c)
                break
    gate_columns = sorted(set(gate_columns))
    if len(gate_columns) < 2:
        # Nothing to connect if fewer than 2 gates
        return grid

    # Compute step (n) as gcd of differences between consecutive gate columns
    import math
    diffs = [gate_columns[i+1] - gate_columns[i] for i in range(len(gate_columns) - 1)]
    step = diffs[0]
    for d in diffs[1:]:
        step = math.gcd(step, d)

    left = gate_columns[0]
    right = gate_columns[-1]

    # Selected columns are those from left to right with the computed step
    selected = list(range(left, right + 1, step))

    # For each selected column, find the topmost existing tunnel (TUNNEL). If none
    # exists, choose the topmost available background cell (first BACK). This yields
    # the anchor rows the description requires ("select the topmost tunnel segment
    # in each selected column, or create one at the topmost 0").
    anchor_rows = []
    for c in selected:
        rows_with_tunnel = [r for r in range(height) if grid[r][c] == TUNNEL]
        if rows_with_tunnel:
            anchor_rows.append(min(rows_with_tunnel))
        else:
            # find first BACK cell
            r0 = 0
            while r0 < height and grid[r0][c] != BACK:
                r0 += 1
            if r0 == height:
                # no background found (extremely unlikely with generator); fall back
                # to row 0 so we don't crash
                r0 = 0
            anchor_rows.append(r0)

    # Choose the minimal anchor row across selected columns (consistent with the
    # "take minimum" tag) and build a continuous horizontal tunnel at that row
    # between the leftmost and rightmost gate. This matches the generator's policy
    # of placing missing tunnels at the topmost available row.
    chain_row = min(anchor_rows) if anchor_rows else 0

    out = [row[:] for row in grid]
    for c in range(left, right + 1):
        if out[chain_row][c] == BACK:
            out[chain_row][c] = TUNNEL

    return out

