# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: a7fa498a
Difficulty: mediumâ€“hard

=== Tags ===
- Meta rule switching
- Elastic wave
- Echo trail

=== Description ===
# Task Description: Meta Wave Echo  Input grids feature a diamond-shaped
wavefront expanding outward from a central source, represented by a continuous
ring of color A. The wavefront is the outermost contiguous ring of color A,
forming a diamond pattern centered within the grid (with the source at the
center). Scattered within the grid is a single control line of color B, either
vertical or horizontal, positioned away from the wavefront. The grid background
consists of color 0.  The transformation requires two key operations: 1. **Echo
Trail Generation**: The previous wavefront (one ring inward from the current
wavefront) is identified and colored with a trail color determined by the
control line's orientation. 2. **Meta Rule Switching**: If the control line is
vertical, the echo trail uses color C; if horizontal, it uses color D. The
control line itself remains unchanged, and the wavefront (color A) is preserved.
The output grid retains the input's wavefront, control line, and background,
while adding the echo trail as a single ring inside the current wavefront with
the color determined by the control line's orientation. The wavefront expands
uniformly without obstacles, making the echo trail the only transformation
applied.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import random_color

def generate():
    n = random.randint(5, 29)
    if n % 2 == 0:
        n -= 1
    center = (n // 2, n // 2)
    max_r = (n - 1) // 2
    r = random.randint(1, max_r - 1)
    A = random_color(exclude=[0])
    B = random_color(exclude=[0, A])
    
    input_grid = [[0] * n for _ in range(n)]
    
    for i in range(n):
        for j in range(n):
            dist = abs(i - center[0]) + abs(j - center[1])
            if dist == r:
                input_grid[i][j] = A
    
    if random.choice([True, False]):
        col = random.choice([0, n-1])
        for i in range(n):
            input_grid[i][col] = B
        control_type = 'vertical'
    else:
        row = random.choice([0, n-1])
        for j in range(n):
            input_grid[row][j] = B
        control_type = 'horizontal'
    
    output_grid = [row[:] for row in input_grid]
    trail_color = 3 if control_type == 'vertical' else 4
    for i in range(n):
        for j in range(n):
            dist = abs(i - center[0]) + abs(j - center[1])
            if dist == r - 1:
                output_grid[i][j] = trail_color
    
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    
    n = len(input_grid)
    center = (n // 2, n // 2)
    
    colors = set()
    for row in input_grid:
        for cell in row:
            if cell != 0:
                colors.add(cell)
    
    if len(colors) != 2:
        A = next(iter(colors))
        B = A
    else:
        B = None
        for i in range(n):
            if all(input_grid[i][j] == input_grid[i][0] and input_grid[i][0] != 0 for j in range(n)):
                B = input_grid[i][0]
                break
        if B is None:
            for j in range(n):
                if all(input_grid[i][j] == input_grid[0][j] and input_grid[0][j] != 0 for i in range(n)):
                    B = input_grid[0][j]
                    break
        A = (colors - {B}).pop()
    
    r = 0
    for i in range(n):
        for j in range(n):
            if input_grid[i][j] == A:
                dist = abs(i - center[0]) + abs(j - center[1])
                if dist > r:
                    r = dist
    
    control_type = 'vertical'
    for i in range(n):
        if all(input_grid[i][j] == B for j in range(n)):
            control_type = 'horizontal'
            break
    
    trail_color = 3 if control_type == 'vertical' else 4
    
    output = [row[:] for row in input_grid]
    for i in range(n):
        for j in range(n):
            dist = abs(i - center[0]) + abs(j - center[1])
            if dist == r - 1:
                output[i][j] = trail_color
    
    return output
