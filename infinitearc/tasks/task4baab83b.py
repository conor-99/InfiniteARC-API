# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 4baab83b
Difficulty: medium

=== Tags ===
- Rectangle guessing

=== Description ===
The task involves identifying a single hollow rectangle (a border of a solid
color with an empty interior) within the input grid. The output grid is
generated by filling the interior of this hollow rectangle with the same color
while leaving all other grid elements unchanged. The hollow rectangle must be
axis-aligned, have a minimum size of 3Ã—3 to ensure an interior, and be the only
such rectangle present in the input. The transformation requires visual
recognition of the border structure and application of a fill operation to the
enclosed region, without relying on numerical properties or pixel-level
patterns.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    input_grid = common.grid(width, height, 0)
    color = random.randint(1, 9)
    w = random.randint(3, width)
    h = random.randint(3, height)
    r = random.randint(0, height - h)
    c = random.randint(0, width - w)
    
    # Draw top and bottom borders
    for col in range(c, c + w):
        input_grid[r][col] = color
        input_grid[r + h - 1][col] = color
    
    # Draw left and right borders
    for row in range(r + 1, r + h - 1):
        input_grid[row][c] = color
        input_grid[row][c + w - 1] = color
    
    output_grid = [row[:] for row in input_grid]
    
    # Fill interior
    for row in range(r + 1, r + h - 1):
        for col in range(c + 1, c + w - 1):
            output_grid[row][col] = color
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    non_zero = []
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] != 0:
                non_zero.append((r, c))
    
    if not non_zero:
        return input_grid
    
    min_r = min(r for r, c in non_zero)
    max_r = max(r for r, c in non_zero)
    min_c = min(c for r, c in non_zero)
    max_c = max(c for r, c in non_zero)
    
    border_color = input_grid[min_r][min_c]
    
    # Check top/bottom rows
    top_ok = all(input_grid[min_r][c] == border_color for c in range(min_c, max_c + 1))
    bottom_ok = all(input_grid[max_r][c] == border_color for c in range(min_c, max_c + 1))
    
    # Check left/right columns
    left_ok = all(input_grid[r][min_c] == border_color for r in range(min_r, max_r + 1))
    right_ok = all(input_grid[r][max_c] == border_color for r in range(min_r, max_r + 1))
    
    # Check interior is empty
    interior_ok = True
    for r in range(min_r + 1, max_r):
        for c in range(min_c + 1, max_c):
            if input_grid[r][c] != 0:
                interior_ok = False
                break
        if not interior_ok:
            break
    
    if not (top_ok and bottom_ok and left_ok and right_ok and interior_ok):
        return input_grid
    
    # Convert to mutable lists if needed
    output = [list(row)[:] for row in input_grid]
    for r in range(min_r + 1, max_r):
        for c in range(min_c + 1, max_c):
            output[r][c] = border_color
    return output
