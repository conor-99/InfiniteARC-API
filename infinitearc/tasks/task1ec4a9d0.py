# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 1ec4a9d0
Difficulty: very hard

=== Tags ===
- Wave reflection
- Constraint satisfaction coloring
- Alternating agents
- Recolor object based on its size
- Pattern coloring

=== Description ===
Input grids feature a neutral background color overlaid with multiple disjoint
rectangular objects of varying sizes, each occupying a contiguous block of cells
with a uniform, non-background color. Objects are arranged such that some are
adjacent (sharing an edge), potentially creating color conflicts where
neighboring rectangles share the same input color. Additionally, the grid
contains isolated "source" cells positioned along the perimeter, each located in
a background cell adjacent to the edge.  The output grid requires the following
transformations:  1. **Size-based recoloring**: Each rectangle's color is
determined by its area (width × height), using a repeating 9-color sequence
(e.g., red → green → blue → yellow → purple → orange → black → white → gray →
red...). The starting position in the sequence for a rectangle is calculated as
(area mod 9), with the sequence cycling through all 9 colors. If two adjacent
rectangles would inherit the same color from this rule, their colors are
adjusted using an alternating constraint resolution pattern: the first
conflicting rectangle shifts to the next color in the sequence, the next shifts
to the previous, and this alternation continues until all adjacent pairs have
distinct colors.  2. **Wave reflection paths**: From each source cell, a
diagonal wave (a line of color 9) is emitted in a direction aligned with its
edge (top-edge sources emit downward-right, right-edge sources emit downward-
left, etc.). The wave travels diagonally through background cells until it hits
a rectangle. Upon impact, the wave reflects perfectly (angle of incidence =
angle of reflection), changes color to match the rectangle's recolored color,
and continues. Each subsequent reflection updates the wave's color to the
current rectangle's color while maintaining the reflection path. Waves terminate
when they exit the grid or after 10 reflections (to prevent infinite loops).
The output grid displays the recolored rectangles (ensuring no adjacent
conflicts via alternating constraint resolution) and the wave paths (as diagonal
lines of the current wave color), with reflections occurring at every rectangle
intersection. This task demands simultaneous reasoning about size-dependent
coloring, constraint satisfaction with alternating adjustments, and wave
reflection dynamics, requiring the solver to track multiple interdependent rules
across a complex grid structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid


def generate():
    # Size of the grid
    width = random.randint(10, 20)
    height = random.randint(10, 20)

    # Initialize input and output grids with background 0
    input_grid = grid(width, height, 0)

    # Place several non-overlapping axis-aligned filled rectangles strictly inside
    # the grid (leave a 1-cell border free so perimeter background cells exist).
    rectangles = []  # list of tuples (r, c, w, h)
    occupied = [[False] * width for _ in range(height)]

    rect_count = random.randint(3, 6)
    attempts = 0
    max_attempts = rect_count * 60
    while len(rectangles) < rect_count and attempts < max_attempts:
        attempts += 1
        # choose rectangle size (leave room for 1-cell margin on every side)
        max_w = min(6, width - 4)
        max_h = min(6, height - 4)
        if max_w < 1 or max_h < 1:
            break
        w = random.randint(1, max_w)
        h = random.randint(1, max_h)
        r = random.randint(1, height - 1 - h)
        c = random.randint(1, width - 1 - w)

        # Check overlap
        overlap = False
        for rr in range(r, r + h):
            for cc in range(c, c + w):
                if occupied[rr][cc]:
                    overlap = True
                    break
            if overlap:
                break
        if overlap:
            continue

        # Temporarily mark the rectangle area as occupied (input color assigned later)
        for rr in range(r, r + h):
            for cc in range(c, c + w):
                occupied[rr][cc] = True
        rectangles.append((r, c, w, h))

    # Sort rectangles by top-left position to make ordering deterministic
    rectangles.sort(key=lambda t: (t[0], t[1]))

    # Build adjacency: rectangles are adjacent if they share an edge (intervals overlap)
    adjacency = {i: set() for i in range(len(rectangles))}
    for i, (r1, c1, w1, h1) in enumerate(rectangles):
        for j, (r2, c2, w2, h2) in enumerate(rectangles):
            if i == j:
                continue
            # vertical adjacency (one on top of the other)
            if r1 + h1 == r2 or r2 + h2 == r1:
                # check column intervals overlap
                if not (c1 + w1 - 1 < c2 or c2 + w2 - 1 < c1):
                    adjacency[i].add(j)
                    adjacency[j].add(i)
            # horizontal adjacency (one to the left of the other)
            if c1 + w1 == c2 or c2 + w2 == c1:
                # check row intervals overlap
                if not (r1 + h1 - 1 < r2 or r2 + h2 - 1 < r1):
                    adjacency[i].add(j)
                    adjacency[j].add(i)

    # Assign input colors (non-zero) so that adjacent rectangles do not share the same input color.
    # This ensures components are separable in the solver.
    input_colors = [None] * len(rectangles)
    for i in range(len(rectangles)):
        used = set()
        for nb in adjacency[i]:
            if input_colors[nb] is not None:
                used.add(input_colors[nb])
        # choose a color from 1..9 not used by neighbors
        for col in range(1, 10):
            if col not in used:
                input_colors[i] = col
                break
        if input_colors[i] is None:
            # fallback, shouldn't happen with 9 colors
            input_colors[i] = 1

    # Fill input_grid with these input colors for each rectangle
    for idx, (r, c, w, h) in enumerate(rectangles):
        col = input_colors[idx]
        for rr in range(r, r + h):
            for cc in range(c, c + w):
                input_grid[rr][cc] = col

    # Precompute base indices (0..8) from area, as described: start index = area % 9
    base_idx = [(w * h) % 9 for (r, c, w, h) in rectangles]

    # Resolve color conflicts using an alternating offset strategy.
    # Colors are indices 0..8 corresponding to values 1..9 in the grid (value = idx+1).
    offsets = [1, -1, 2, -2, 3, -3, 4, -4]
    assigned_idx = [None] * len(rectangles)

    visited = set()
    for start in range(len(rectangles)):
        if start in visited:
            continue
        # BFS a connected component in a deterministic way (sorted neighbors)
        queue = [start]
        visited.add(start)
        order = []
        while queue:
            u = queue.pop(0)
            order.append(u)
            for v in sorted(adjacency[u]):
                if v not in visited:
                    visited.add(v)
                    queue.append(v)

        # Assign colors greedily for this component using the alternating offsets
        for u in order:
            b = base_idx[u]
            neighbor_used = set()
            for nb in adjacency[u]:
                if assigned_idx[nb] is not None:
                    neighbor_used.add(assigned_idx[nb])
            if b not in neighbor_used:
                assigned_idx[u] = b
            else:
                found = None
                for off in offsets:
                    cand = (b + off) % 9
                    if cand not in neighbor_used:
                        found = cand
                        break
                if found is None:
                    # fallback: pick any color not used by neighbors
                    for cand in range(9):
                        if cand not in neighbor_used:
                            found = cand
                            break
                assigned_idx[u] = found

    # Map to actual color values 1..9
    assigned_colors = [idx + 1 for idx in assigned_idx]

    # Build an output grid and a rect_id map for quick lookup of which rectangle occupies a cell
    output_grid = grid(width, height, 0)
    rect_id = [[-1] * width for _ in range(height)]
    for idx, (r, c, w, h) in enumerate(rectangles):
        col = assigned_colors[idx]
        for rr in range(r, r + h):
            for cc in range(c, c + w):
                output_grid[rr][cc] = col
                rect_id[rr][cc] = idx

    # Find perimeter background cells (sources). Deterministic scanning order:
    sources = []
    for cc in range(width):
        if input_grid[0][cc] == 0:
            sources.append((0, cc))
        if input_grid[height - 1][cc] == 0:
            sources.append((height - 1, cc))
    for rr in range(1, height - 1):
        if input_grid[rr][0] == 0:
            sources.append((rr, 0))
        if input_grid[rr][width - 1] == 0:
            sources.append((rr, width - 1))

    # If for some reason there are no perimeter background cells (shouldn't happen because
    # we left a 1-cell border free), create a single source at (0,0)
    if not sources:
        input_grid[0][0] = 0
        sources = [(0, 0)]

    # Edge-aligned diagonal directions (clockwise order): top -> down-right,
    # right -> down-left, bottom -> up-left, left -> up-right
    def source_direction(r, c):
        if r == 0:
            return (1, 1)
        if c == width - 1:
            return (1, -1)
        if r == height - 1:
            return (-1, -1)
        if c == 0:
            return (-1, 1)
        return (1, 1)

    # Simulate waves from each source. Waves start with color 9 and change color to the
    # rectangle's assigned color upon each reflection. Reflections limited to 10.
    max_reflections = 10
    for (sr, sc) in sources:
        dr, dc = source_direction(sr, sc)
        cr, cc = sr, sc
        current_color = 9
        output_grid[cr][cc] = current_color
        reflections = 0
        steps = 0
        # Safety cap to prevent pathological infinite loops
        safety = width * height * 4
        while True:
            nr = cr + dr
            nc = cc + dc
            steps += 1
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                break
            # If the diagonal next cell is part of a rectangle (in the input), reflect
            if input_grid[nr][nc] != 0:
                ridx = rect_id[nr][nc]
                if ridx >= 0:
                    # Determine which faces are blocked by checking the two orthogonal
                    # neighbors adjacent to the diagonal step
                    a_r, a_c = cr + dr, cc
                    b_r, b_c = cr, cc + dc
                    a_block = (0 <= a_r < height and 0 <= a_c < width and input_grid[a_r][a_c] != 0)
                    b_block = (0 <= b_r < height and 0 <= b_c < width and input_grid[b_r][b_c] != 0)
                    if a_block and b_block:
                        dr, dc = -dr, -dc
                    elif a_block:
                        dr = -dr
                    elif b_block:
                        dc = -dc
                    else:
                        # diagonal corner hit with no orthogonal blocks: reflect both
                        dr, dc = -dr, -dc

                    # Update wave color to the rectangle's recolored value
                    current_color = assigned_colors[ridx]
                    reflections += 1
                    if reflections >= max_reflections:
                        break

                    # Move one step in the new direction after reflection
                    cr += dr
                    cc += dc
                    if cr < 0 or cr >= height or cc < 0 or cc >= width:
                        break
                    if input_grid[cr][cc] == 0:
                        output_grid[cr][cc] = current_color
                else:
                    break
            else:
                # Empty/background cell: paint the wave path with the current color
                output_grid[nr][nc] = current_color
                cr, cc = nr, nc

            if steps > safety:
                break

    return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])

    # Find connected components of non-background pixels (4-connected)
    visited = [[False] * width for _ in range(height)]
    components = []  # list of lists of (r,c)
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                color = input_grid[r][c]
                queue = [(r, c)]
                visited[r][c] = True
                comp = []
                while queue:
                    cr, cc = queue.pop(0)
                    comp.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                components.append(comp)

    # From components, extract rectangles (bounding boxes) and ensure they are filled
    rectangles = []  # list of (r, c, w, h)
    for comp in components:
        min_r = min(r for r, c in comp)
        max_r = max(r for r, c in comp)
        min_c = min(c for r, c in comp)
        max_c = max(c for r, c in comp)
        is_rect = True
        for rr in range(min_r, max_r + 1):
            for cc in range(min_c, max_c + 1):
                if (rr, cc) not in comp:
                    is_rect = False
                    break
            if not is_rect:
                break
        if is_rect:
            w = max_c - min_c + 1
            h = max_r - min_r + 1
            rectangles.append((min_r, min_c, w, h))

    # Sort rectangles by top-left to match generator ordering
    rectangles.sort(key=lambda t: (t[0], t[1]))

    # Compute base indices
    base_idx = [(w * h) % 9 for (r, c, w, h) in rectangles]

    # Build adjacency (share an edge)
    adjacency = {i: set() for i in range(len(rectangles))}
    for i, (r1, c1, w1, h1) in enumerate(rectangles):
        for j, (r2, c2, w2, h2) in enumerate(rectangles):
            if i == j:
                continue
            # vertical adjacency
            if r1 + h1 == r2 or r2 + h2 == r1:
                if not (c1 + w1 - 1 < c2 or c2 + w2 - 1 < c1):
                    adjacency[i].add(j)
                    adjacency[j].add(i)
            # horizontal adjacency
            if c1 + w1 == c2 or c2 + w2 == c1:
                if not (r1 + h1 - 1 < r2 or r2 + h2 - 1 < r1):
                    adjacency[i].add(j)
                    adjacency[j].add(i)

    # Resolve colors with same alternating offset strategy as generator
    offsets = [1, -1, 2, -2, 3, -3, 4, -4]
    assigned_idx = [None] * len(rectangles)
    visited_nodes = set()
    for start in range(len(rectangles)):
        if start in visited_nodes:
            continue
        queue = [start]
        visited_nodes.add(start)
        order = []
        while queue:
            u = queue.pop(0)
            order.append(u)
            for v in sorted(adjacency[u]):
                if v not in visited_nodes:
                    visited_nodes.add(v)
                    queue.append(v)
        for u in order:
            b = base_idx[u]
            neighbor_used = set()
            for nb in adjacency[u]:
                if assigned_idx[nb] is not None:
                    neighbor_used.add(assigned_idx[nb])
            if b not in neighbor_used:
                assigned_idx[u] = b
            else:
                found = None
                for off in offsets:
                    cand = (b + off) % 9
                    if cand not in neighbor_used:
                        found = cand
                        break
                if found is None:
                    for cand in range(9):
                        if cand not in neighbor_used:
                            found = cand
                            break
                assigned_idx[u] = found

    assigned_colors = [idx + 1 for idx in assigned_idx]

    # Build output grid and rect_id map
    output_grid = [[0] * width for _ in range(height)]
    rect_id = [[-1] * width for _ in range(height)]
    for idx, (r, c, w, h) in enumerate(rectangles):
        col = assigned_colors[idx]
        for rr in range(r, r + h):
            for cc in range(c, c + w):
                output_grid[rr][cc] = col
                rect_id[rr][cc] = idx

    # Find sources deterministically (same scan order as generator)
    sources = []
    for cc in range(width):
        if input_grid[0][cc] == 0:
            sources.append((0, cc))
        if input_grid[height - 1][cc] == 0:
            sources.append((height - 1, cc))
    for rr in range(1, height - 1):
        if input_grid[rr][0] == 0:
            sources.append((rr, 0))
        if input_grid[rr][width - 1] == 0:
            sources.append((rr, width - 1))

    if not sources:
        sources = [(0, 0)]

    def source_direction(r, c):
        if r == 0:
            return (1, 1)
        if c == width - 1:
            return (1, -1)
        if r == height - 1:
            return (-1, -1)
        if c == 0:
            return (-1, 1)
        return (1, 1)

    max_reflections = 10
    for (sr, sc) in sources:
        dr, dc = source_direction(sr, sc)
        cr, cc = sr, sc
        current_color = 9
        output_grid[cr][cc] = current_color
        reflections = 0
        steps = 0
        safety = width * height * 4
        while True:
            nr = cr + dr
            nc = cc + dc
            steps += 1
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                break
            if input_grid[nr][nc] != 0:
                ridx = rect_id[nr][nc]
                if ridx >= 0:
                    a_r, a_c = cr + dr, cc
                    b_r, b_c = cr, cc + dc
                    a_block = (0 <= a_r < height and 0 <= a_c < width and input_grid[a_r][a_c] != 0)
                    b_block = (0 <= b_r < height and 0 <= b_c < width and input_grid[b_r][b_c] != 0)
                    if a_block and b_block:
                        dr, dc = -dr, -dc
                    elif a_block:
                        dr = -dr
                    elif b_block:
                        dc = -dc
                    else:
                        dr, dc = -dr, -dc
                    current_color = assigned_colors[ridx]
                    reflections += 1
                    if reflections >= max_reflections:
                        break
                    cr += dr
                    cc += dc
                    if cr < 0 or cr >= height or cc < 0 or cc >= width:
                        break
                    if input_grid[cr][cc] == 0:
                        output_grid[cr][cc] = current_color
                else:
                    break
            else:
                output_grid[nr][nc] = current_color
                cr, cc = nr, nc
            if steps > safety:
                break

    return output_grid

