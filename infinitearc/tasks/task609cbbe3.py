# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 609cbbe3
Difficulty: hard

=== Tags ===
- Local rule cascade
- Mapping by size relation
- Sand simulation
- Compare image
- Adapt image to grid

=== Description ===
Sand Cascade Mapping  Input grids are 20×20 with a background of color 0.
Obstacles (colors 2–9) form irregularly shaped structures that block sand
movement. Sand particles (color 1) are distributed above these structures. The
transformation begins with a sand simulation: each sand particle falls
vertically until it either hits an obstacle, another sand particle, or the grid
bottom. This forms stable sand piles where particles accumulate horizontally and
vertically.  Next, a local rule cascade applies: for each connected sand pile,
its horizontal width (number of columns spanned) is measured. This width is
mapped to a color using a fixed, deterministic relation (e.g., width 3 → color
5, width 4 → color 7). The output grid retains all obstacles but replaces sand
particles with their mapped colors.  A critical comparison step follows: the
input grid contains a reference region (top-left) and a target region (bottom-
right) with similar structural layouts. The output compares the width of the
sand pile in the reference region to that in the target region. If the target's
width exceeds the reference's, the target's sand is recolored using the
reference's mapped color; otherwise, it retains its own mapped color. This
comparison adapts the target region to align with the reference's size relation,
fulfilling the "adapt image to grid" requirement.  The transformation requires
identifying sand pile widths, deducing the color mapping, and applying the
reference-target comparison—three interdependent rules that must be discovered
through induction. No two grids in the training set share identical obstacle
configurations, ensuring the rules are learned through abstraction rather than
memorization. The output grid preserves all obstacle structures while
dynamically adapting sand colors based on size relations and comparative
analysis.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque
from common import grid

def generate():
    """
    Generates a 20x20 input grid with irregular obstacles (colors 2-9) and sand (color 1)
    distributed above obstacles. Simulates sand falling to form piles, computes connected
    sand components, maps component widths to colors, compares reference (top-left)
    and target (bottom-right) components and possibly recolors the target component.

    The generator uses an internal counter to ensure different outputs across calls.
    """
    width = 20
    height = 20

    # Use a deterministic-but-different seed each call to guarantee uniqueness across calls
    if not hasattr(generate, "counter"):
        generate.counter = 0
    seed = 123456789 ^ generate.counter
    rng = random.Random(seed)
    generate.counter += 1

    # Start with an empty grid
    input_grid = grid(width, height, 0)

    # Create several contiguous obstacle blobs with colors in 2..9
    blob_count = rng.randint(6, 12)
    for _ in range(blob_count):
        blob_size = rng.randint(5, 60)
        start_r = rng.randint(0, height - 1)
        start_c = rng.randint(0, width - 1)
        color = rng.randint(2, 9)
        cells = {(start_r, start_c)}
        attempts = 0
        # Grow the blob by random neighbor additions
        while len(cells) < blob_size and attempts < blob_size * 10:
            attempts += 1
            r, c = rng.choice(tuple(cells))
            dr, dc = rng.choice([(1, 0), (-1, 0), (0, 1), (0, -1)])
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width:
                cells.add((nr, nc))
        for (r, c) in cells:
            input_grid[r][c] = color

    # Place sand (color 1) above the first obstacle in each column with some randomness
    any_sand = False
    for c in range(width):
        top_obstacle = height
        for r in range(height):
            if input_grid[r][c] >= 2:
                top_obstacle = r
                break
        if top_obstacle <= 0:
            continue
        # Decide how many sand cells to place in this column (could be zero)
        if rng.random() < 0.85:
            max_possible = top_obstacle
            sand_count = rng.randint(0, max(1, max_possible))
        else:
            sand_count = 0
        if sand_count > 0 and top_obstacle > 0:
            sand_rows = rng.sample(list(range(0, top_obstacle)), k=min(sand_count, top_obstacle))
            for r in sand_rows:
                input_grid[r][c] = 1
                any_sand = True

    # Ensure there is at least one sand particle somewhere
    if not any_sand:
        c = rng.randint(0, width - 1)
        top_obstacle = height
        for r in range(height):
            if input_grid[r][c] >= 2:
                top_obstacle = r
                break
        if top_obstacle <= 0:
            r = 0
        else:
            r = rng.randint(0, top_obstacle - 1)
        input_grid[r][c] = 1

    # Simulate sand falling column by column: sand occupies the lowest free cells (grid value < 2)
    simulated = [[0] * width for _ in range(height)]
    # Copy obstacles to the simulated grid
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] >= 2:
                simulated[r][c] = input_grid[r][c]

    for c in range(width):
        free_rows = [r for r in range(height) if input_grid[r][c] < 2]
        # Fill from bottom up
        free_rows.sort(reverse=True)
        sand_count = sum(1 for r in range(height) if input_grid[r][c] == 1)
        fill_count = min(sand_count, len(free_rows))
        for i in range(fill_count):
            r = free_rows[i]
            simulated[r][c] = 1

    # Find connected sand components (4-neighborhood)
    visited = [[False] * width for _ in range(height)]
    sand_components = []
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]

    for r in range(height):
        for c in range(width):
            if simulated[r][c] == 1 and not visited[r][c]:
                q = deque()
                q.append((r, c))
                visited[r][c] = True
                comp = []
                while q:
                    r1, c1 = q.popleft()
                    comp.append((r1, c1))
                    for dr, dc in directions:
                        r2, c2 = r1 + dr, c1 + dc
                        if 0 <= r2 < height and 0 <= c2 < width and not visited[r2][c2] and simulated[r2][c2] == 1:
                            visited[r2][c2] = True
                            q.append((r2, c2))
                sand_components.append(comp)

    # Compute widths for each component (number of columns spanned)
    comp_widths = []
    for comp in sand_components:
        cols = [c for r, c in comp]
        min_col = min(cols)
        max_col = max(cols)
        comp_widths.append(max_col - min_col + 1)

    # Deterministic mapping from width -> color
    def get_mapped_color(w):
        # map to an even/large palette and cap within 1..9
        return min(9, max(1, 2 * w))

    comp_colors = [get_mapped_color(w) for w in comp_widths]

    # Reference and target regions
    ref_region = set((r, c) for r in range(5) for c in range(5))
    target_region = set((r, c) for r in range(height - 5, height) for c in range(width - 5, width))

    def pick_component_for_region(components, region):
        if not components:
            return None
        counts = [sum(1 for p in comp if p in region) for comp in components]
        max_count = max(counts)
        if max_count > 0:
            candidates = [i for i, v in enumerate(counts) if v == max_count]
            if len(candidates) == 1:
                return candidates[0]
            # tie-breaker: choose component with largest area among candidates
            areas = [len(components[i]) for i in candidates]
            return candidates[areas.index(max(areas))]
        # If nothing directly in the region, pick the component whose closest pixel is nearest to the region center
        region_rows = [r for r, c in region]
        region_cols = [c for r, c in region]
        center_r = (min(region_rows) + max(region_rows)) / 2.0
        center_c = (min(region_cols) + max(region_cols)) / 2.0
        best_idx = None
        best_dist = float('inf')
        for i, comp in enumerate(components):
            dmin = min(abs(r - center_r) + abs(c - center_c) for r, c in comp)
            if dmin < best_dist:
                best_dist = dmin
                best_idx = i
            elif dmin == best_dist:
                # tie-breaker: larger component
                if len(comp) > len(components[best_idx]):
                    best_idx = i
        return best_idx

    ref_idx = pick_component_for_region(sand_components, ref_region)
    if ref_idx is None:
        # safe fallback: choose largest component
        ref_idx = 0 if not sand_components else max(range(len(sand_components)), key=lambda i: len(sand_components[i]))

    target_idx = pick_component_for_region(sand_components, target_region)
    if target_idx is None:
        target_idx = 0 if not sand_components else max(range(len(sand_components)), key=lambda i: len(sand_components[i]))

    ref_width = comp_widths[ref_idx]
    ref_color = get_mapped_color(ref_width)
    target_width = comp_widths[target_idx]

    if target_width > ref_width:
        applied_target_color = ref_color
    else:
        applied_target_color = get_mapped_color(target_width)

    # Build output: preserve obstacles, replace sand with mapped colors; recolor target component if rule applies
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] >= 2:
                output_grid[r][c] = input_grid[r][c]

    for i, comp in enumerate(sand_components):
        color = comp_colors[i]
        if i == target_idx:
            color = applied_target_color
        for r, c in comp:
            output_grid[r][c] = color

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input (tuple of tuples) to mutable list of lists
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0]) if height > 0 else 0

    # Simulate sand falling: sand (1) occupies lowest available cells in each column (cells with value < 2)
    simulated = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if grid_in[r][c] >= 2:
                simulated[r][c] = grid_in[r][c]

    for c in range(width):
        free_rows = [r for r in range(height) if grid_in[r][c] < 2]
        free_rows.sort(reverse=True)  # bottom-up
        sand_count = sum(1 for r in range(height) if grid_in[r][c] == 1)
        fill_count = min(sand_count, len(free_rows))
        for i in range(fill_count):
            r = free_rows[i]
            simulated[r][c] = 1

    # Find sand components (4-neighborhood)
    visited = [[False] * width for _ in range(height)]
    from collections import deque
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    sand_components = []
    for r in range(height):
        for c in range(width):
            if simulated[r][c] == 1 and not visited[r][c]:
                q = deque()
                q.append((r, c))
                visited[r][c] = True
                comp = []
                while q:
                    r1, c1 = q.popleft()
                    comp.append((r1, c1))
                    for dr, dc in directions:
                        r2, c2 = r1 + dr, c1 + dc
                        if 0 <= r2 < height and 0 <= c2 < width and not visited[r2][c2] and simulated[r2][c2] == 1:
                            visited[r2][c2] = True
                            q.append((r2, c2))
                sand_components.append(comp)

    # Compute widths
    comp_widths = []
    for comp in sand_components:
        cols = [c for r, c in comp]
        min_col = min(cols)
        max_col = max(cols)
        comp_widths.append(max_col - min_col + 1)

    # Same deterministic mapping function used by the generator
    def get_mapped_color(w):
        return min(9, max(1, 2 * w))

    comp_colors = [get_mapped_color(w) for w in comp_widths]

    # Define reference and target regions
    ref_region = set((r, c) for r in range(5) for c in range(5))
    target_region = set((r, c) for r in range(height - 5, height) for c in range(width - 5, width))

    def pick_component_for_region(components, region):
        if not components:
            return None
        counts = [sum(1 for p in comp if p in region) for comp in components]
        max_count = max(counts)
        if max_count > 0:
            candidates = [i for i, v in enumerate(counts) if v == max_count]
            if len(candidates) == 1:
                return candidates[0]
            areas = [len(components[i]) for i in candidates]
            return candidates[areas.index(max(areas))]
        region_rows = [r for r, c in region]
        region_cols = [c for r, c in region]
        center_r = (min(region_rows) + max(region_rows)) / 2.0
        center_c = (min(region_cols) + max(region_cols)) / 2.0
        best_idx = None
        best_dist = float('inf')
        for i, comp in enumerate(components):
            dmin = min(abs(r - center_r) + abs(c - center_c) for r, c in comp)
            if dmin < best_dist:
                best_dist = dmin
                best_idx = i
            elif dmin == best_dist:
                if len(comp) > len(components[best_idx]):
                    best_idx = i
        return best_idx

    ref_idx = pick_component_for_region(sand_components, ref_region)
    if ref_idx is None:
        ref_idx = 0 if not sand_components else max(range(len(sand_components)), key=lambda i: len(sand_components[i]))
    target_idx = pick_component_for_region(sand_components, target_region)
    if target_idx is None:
        target_idx = 0 if not sand_components else max(range(len(sand_components)), key=lambda i: len(sand_components[i]))

    ref_width = comp_widths[ref_idx]
    ref_color = get_mapped_color(ref_width)
    target_width = comp_widths[target_idx]

    if target_width > ref_width:
        applied_target_color = ref_color
    else:
        applied_target_color = get_mapped_color(target_width)

    # Build the output grid: copy obstacles and color sand components
    output = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if grid_in[r][c] >= 2:
                output[r][c] = grid_in[r][c]

    for i, comp in enumerate(sand_components):
        color = comp_colors[i]
        if i == target_idx:
            color = applied_target_color
        for r, c in comp:
            output[r][c] = color

    # Return as a grid (list of lists)
    return output

