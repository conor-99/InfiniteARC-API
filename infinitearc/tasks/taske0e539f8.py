# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: e0e539f8
Difficulty: easy

=== Tags ===
- Image reflection
- Draw line from point
- Size guessing
- Proximity guessing

=== Description ===
The task involves transforming an input grid into an output grid through a
combination of image reflection and line drawing based on proximity. The input
grid contains a single non-background pixel (color 2) representing a point,
surrounded by background pixels (color 0). The transformation rules are as
follows:    1. **Image Reflection**: The input grid is reflected horizontally
(left-right flip), so the point's column position is mirrored across the
vertical center of the grid.   2. **Proximity Guessing**: After reflection, the
nearest edge (left, right, top, or bottom) to the point's new position is
determined by calculating the minimum distance to any grid boundary. In case of
ties (e.g., equal distance to multiple edges), the order of priority is left →
right → top → bottom.   3. **Line Drawing**: A straight line (using color 1) is
drawn from the reflected point to the nearest edge, including all pixels along
the path. The point's original color (2) is replaced by the line color (1) in
the output.    The output grid is always distinct from the input due to the
reflection and line addition. The task relies on visual reasoning (edge
proximity and reflection) rather than numerical calculations, making it
accessible for "easy" difficulty. The grid size varies between 3×3 and 10×10,
ensuring the point is never on the edge in the input to avoid trivial line
paths.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(3, 10)
    height = random.randint(3, 10)
    input_grid = grid(width, height, 0)
    r = random.randint(1, height - 2)
    c = random.randint(1, width - 2)
    input_grid[r][c] = 2
    c_ref = width - 1 - c
    left = c_ref
    right = width - 1 - c_ref
    top = r
    bottom = height - 1 - r
    edges = [('left', left), ('right', right), ('top', top), ('bottom', bottom)]
    edges.sort(key=lambda x: (x[1], ['left', 'right', 'top', 'bottom'].index(x[0])))
    nearest = edges[0][0]
    output_grid = grid(width, height, 0)
    if nearest == 'left':
        for col in range(0, c_ref + 1):
            output_grid[r][col] = 1
    elif nearest == 'right':
        for col in range(c_ref, width):
            output_grid[r][col] = 1
    elif nearest == 'top':
        for row in range(0, r + 1):
            output_grid[row][c_ref] = 1
    elif nearest == 'bottom':
        for row in range(r, height):
            output_grid[row][c_ref] = 1
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    h = len(input_grid)
    w = len(input_grid[0])
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] == 2:
                c_ref = w - 1 - c
                left = c_ref
                right = w - 1 - c_ref
                top = r
                bottom = h - 1 - r
                edges = [('left', left), ('right', right), ('top', top), ('bottom', bottom)]
                edges.sort(key=lambda x: (x[1], ['left', 'right', 'top', 'bottom'].index(x[0])))
                nearest = edges[0][0]
                output_grid = grid(w, h, 0)
                if nearest == 'left':
                    for col in range(0, c_ref + 1):
                        output_grid[r][col] = 1
                elif nearest == 'right':
                    for col in range(c_ref, w):
                        output_grid[r][col] = 1
                elif nearest == 'top':
                    for row in range(0, r + 1):
                        output_grid[row][c_ref] = 1
                elif nearest == 'bottom':
                    for row in range(r, h):
                        output_grid[row][c_ref] = 1
                return output_grid
