# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 08232b3e
Difficulty: hard

=== Tags ===
- Weave patterns
- Count different colors

=== Description ===
The task involves transforming an input grid into an output grid based on the
counts of distinct non-zero colors present. The input grid is a 2D grid of
values between 0 and 9, where 0 represents a background color. The
transformation requires identifying all non-zero colors in the input, sorting
them in descending order of their occurrence counts, and constructing an output
grid of size NÃ—N (where N is the number of distinct non-zero colors). Each cell
(i, j) in the output grid is filled with the color at position (i + j) mod N in
the sorted list of colors. This creates a diagonal weave pattern where colors
alternate based on their relative frequencies, forming a consistent yet non-
obvious visual structure. The output grid is guaranteed to differ from the input
grid, as it is derived from abstract color statistics rather than direct pixel
mapping.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import math

def generate():
    N = random.randint(2, 9)
    colors = random.sample(range(1, 10), N)
    total_non_zero = N * (N + 1) // 2
    M = max(2, math.ceil(math.sqrt(total_non_zero)))
    while M > 30 or M * M < total_non_zero:
        M += 1
    width, height = M, M
    input_grid = [[0] * width for _ in range(height)]
    positions = [(r, c) for r in range(height) for c in range(width)]
    random.shuffle(positions)
    counts = list(range(1, N+1))
    random.shuffle(counts)
    for color, count in zip(colors, counts):
        for _ in range(count):
            r, c = positions.pop()
            input_grid[r][c] = color
    color_counts = {}
    for row in input_grid:
        for val in row:
            if val != 0:
                color_counts[val] = color_counts.get(val, 0) + 1
    sorted_colors = sorted(color_counts.keys(), key=lambda x: (-color_counts[x], x))
    output_grid = [[0] * N for _ in range(N)]
    for i in range(N):
        for j in range(N):
            idx = (i + j) % N
            output_grid[i][j] = sorted_colors[idx]
    if input_grid == output_grid:
        return generate()
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    color_counts = {}
    for row in input_grid:
        for val in row:
            if val != 0:
                color_counts[val] = color_counts.get(val, 0) + 1
    sorted_colors = sorted(color_counts.keys(), key=lambda x: (-color_counts[x], x))
    N = len(sorted_colors)
    output = [[0] * N for _ in range(N)]
    for i in range(N):
        for j in range(N):
            idx = (i + j) % N
            output[i][j] = sorted_colors[idx]
    return output
