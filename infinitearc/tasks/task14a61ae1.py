# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 14a61ae1
Difficulty: hard

=== Tags ===
- Rule composition
- Impact highlight
- Coordinate system translation
- Periodic reflection
- Swap rows
- Project shadow

=== Description ===
**Task Name: Reflective Shadow Composition**    **Tags:** Rule composition,
Impact highlight, Coordinate system translation, Periodic reflection, Swap rows,
Project shadow    **Description:**    Input grids feature a background color (0)
and multiple visual elements:   - A **main object** (a contiguous shape of a
single non-background color, e.g., a 3×3 square of color 5).   - A **coordinate
system indicator** (a horizontal or vertical line of a distinct color, e.g.,
color 2, with length *N*).   - A **direction indicator** (a single cell of color
3 pointing in one of eight compass directions, e.g., ↘).   - Optional **impact
markers** (e.g., color 7 for highlighting).    The transformation applies the
following rules in sequence:   1. **Coordinate system translation**: The main
object is shifted *N* units in the direction of the coordinate line. A
horizontal line (e.g., in row 0) shifts the object *N* units right; a vertical
line (e.g., in column 0) shifts it *N* units down.   2. **Shadow projection**:
From the translated object’s position, a shadow is cast in the direction of the
indicator (e.g., ↘). The shadow travels in a straight line until it hits a grid
boundary, then **reflects periodically** (reversing the direction component
corresponding to the boundary edge, e.g., hitting a vertical edge reverses
horizontal direction).   3. **Impact highlight**: Each boundary hit (top,
bottom, left, right) is marked with a new color (e.g., color 8), visible in the
output.   4. **Row swap**: All rows containing at least one impact highlight are
swapped with the row immediately below them (bottom row swaps with the row
above). Swaps occur top-to-bottom: the topmost impacted row is swapped first,
and subsequent swaps use the updated grid.    The output grid retains all
original elements (background, coordinate line, direction indicator, translated
object) but includes the shadow path (drawn in a consistent shadow color, e.g.,
color 4), impact highlights, and swapped rows. No original elements (e.g.,
coordinate line, direction indicator) are modified, and swaps are applied only
to rows with impact highlights. The shadow’s reflection path and row swaps
create a complex, visually coherent transformation requiring multi-step
reasoning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, continuous_creature

def generate():
    # Grid size
    width = random.randint(12, 20)
    height = random.randint(12, 20)
    in_grid = grid(width, height, 0)

    # Main object (contiguous creature)
    main_size = random.randint(3, 7)
    box_w = random.randint(3, 6)
    box_h = random.randint(3, 6)
    main_size = min(main_size, box_w * box_h)
    sprite = continuous_creature(main_size, box_w, box_h)  # list of (r,c)

    # Coordinate line (horizontal or vertical) anchored at left/top
    coord_type = random.choice(['horizontal', 'vertical'])
    N = random.randint(2, 6)
    if coord_type == 'horizontal':
        coord_row = random.randint(0, 2)
        for c in range(N):
            in_grid[coord_row][c] = 2
    else:
        coord_col = random.randint(0, 2)
        for r in range(N):
            in_grid[r][coord_col] = 2

    # Sprite bounding box (within its local box)
    sr_coords = [p[0] for p in sprite]
    sc_coords = [p[1] for p in sprite]
    sprite_h = max(sr_coords) - min(sr_coords) + 1
    sprite_w = max(sc_coords) - min(sc_coords) + 1

    # Choose base position so the original and translated fits inside the canvas
    margin = 3
    if coord_type == 'horizontal':
        min_br = margin
        max_br = height - sprite_h - margin
        min_bc = margin
        max_bc = width - sprite_w - N - margin
    else:
        min_br = margin
        max_br = height - sprite_h - N - margin
        min_bc = margin
        max_bc = width - sprite_w - margin

    if max_br < min_br:
        min_br = margin
        max_br = margin
    if max_bc < min_bc:
        min_bc = margin
        max_bc = margin

    base_r = random.randint(min_br, max_br)
    base_c = random.randint(min_bc, max_bc)

    main_cells = []
    for rr, cc in sprite:
        r = base_r + rr
        c = base_c + cc
        in_grid[r][c] = 5
        main_cells.append((r, c))

    # Top-left of main object
    min_r = min(r for r, c in main_cells)
    min_c = min(c for r, c in main_cells)

    # Direction indicator chosen from 8 compass directions
    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
    dr, dc = random.choice(directions)

    # Place the direction indicator (color 3) somewhere along that ray from top-left
    placed = False
    for dist in range(2, max(width, height)):
        rr = min_r + dr * dist
        cc = min_c + dc * dist
        if 0 <= rr < height and 0 <= cc < width and in_grid[rr][cc] == 0:
            in_grid[rr][cc] = 3
            dir_pos = (rr, cc)
            placed = True
            break
    if not placed:
        # fallback: place anywhere empty
        found = False
        for rr in range(height):
            for cc in range(width):
                if in_grid[rr][cc] == 0:
                    in_grid[rr][cc] = 3
                    dir_pos = (rr, cc)
                    found = True
                    break
            if found:
                break

    # Optional impact markers (color 7)
    for _ in range(random.randint(0, 3)):
        tries = 0
        while tries < 50:
            rr = random.randint(0, height - 1)
            cc = random.randint(0, width - 1)
            if in_grid[rr][cc] == 0:
                in_grid[rr][cc] = 7
                break
            tries += 1

    # Compute translated main object cells (translation by N units)
    trans_main = []
    if coord_type == 'horizontal':
        for r, c in main_cells:
            trans_main.append((r, c + N))
    else:
        for r, c in main_cells:
            trans_main.append((r + N, c))

    # Shadow starts at the top-left of the translated object
    start_r = min(r for r, c in trans_main)
    start_c = min(c for r, c in trans_main)
    cur_r, cur_c = start_r, start_c
    drr, dcc = dr, dc
    shadow = [(cur_r, cur_c)]
    impacts = []
    seen = set()
    max_steps = width * height * 4
    steps = 0
    while True:
        state = (cur_r, cur_c, drr, dcc)
        if state in seen:
            break
        seen.add(state)
        if steps > max_steps:
            break
        steps += 1
        nr = cur_r + drr
        nc = cur_c + dcc
        if not (0 <= nr < height) or not (0 <= nc < width):
            # record impact at the current cell and reflect
            impacts.append((cur_r, cur_c))
            if not (0 <= nr < height):
                drr = -drr
            if not (0 <= nc < width):
                dcc = -dcc
            nr = cur_r + drr
            nc = cur_c + dcc
            if not (0 <= nr < height) or not (0 <= nc < width):
                break
            cur_r, cur_c = nr, nc
            shadow.append((cur_r, cur_c))
        else:
            cur_r, cur_c = nr, nc
            shadow.append((cur_r, cur_c))

    # Build output grid: preserve originals
    out = [row.copy() for row in in_grid]

    # Place translated main without overwriting non-zero cells
    for r, c in trans_main:
        if 0 <= r < height and 0 <= c < width and out[r][c] == 0:
            out[r][c] = 5

    # Draw shadow (color 4) only on empty cells
    for r, c in shadow:
        if 0 <= r < height and 0 <= c < width and out[r][c] == 0:
            out[r][c] = 4

    # Mark impacts (color 8) only on empty cells
    for r, c in impacts:
        if 0 <= r < height and 0 <= c < width and out[r][c] == 0:
            out[r][c] = 8

    # Identify rows with impact and perform top-to-bottom swaps
    rows_with_impact = sorted({r for r in range(height) if 8 in out[r]})
    for r in rows_with_impact:
        if r < height - 1:
            out[r], out[r + 1] = out[r + 1], out[r]
        else:
            # bottom row swaps with row above
            out[r], out[r - 1] = out[r - 1], out[r]

    return {'input': in_grid, 'output': out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0]) if height > 0 else 0

    # Find main object cells (color 5)
    main_cells = [(r, c) for r in range(height) for c in range(width) if grid_in[r][c] == 5]
    if not main_cells:
        return grid_in

    min_r = min(r for r, c in main_cells)
    min_c = min(c for r, c in main_cells)

    # Find direction indicator (color 3)
    dir_cells = [(r, c) for r in range(height) for c in range(width) if grid_in[r][c] == 3]
    if not dir_cells:
        return grid_in
    dir_r, dir_c = dir_cells[0]

    def sign(x):
        return 1 if x > 0 else (-1 if x < 0 else 0)

    dr = sign(dir_r - min_r)
    dc = sign(dir_c - min_c)
    if dr == 0 and dc == 0:
        dr, dc = 1, 0

    # Detect coordinate line (color 2), choose line with the largest count
    row_counts = [(r, sum(1 for c in range(width) if grid_in[r][c] == 2)) for r in range(height)]
    col_counts = [(c, sum(1 for r in range(height) if grid_in[r][c] == 2)) for c in range(width)]
    best_row, best_row_count = max(row_counts, key=lambda x: x[1])
    best_col, best_col_count = max(col_counts, key=lambda x: x[1])

    if best_row_count >= best_col_count and best_row_count > 0:
        coord_type = 'horizontal'
        coord_pos = best_row
        N = best_row_count
    elif best_col_count > 0:
        coord_type = 'vertical'
        coord_pos = best_col
        N = best_col_count
    else:
        return grid_in

    # Translate main cells
    trans_main = []
    for r, c in main_cells:
        if coord_type == 'horizontal':
            trans_main.append((r, c + N))
        else:
            trans_main.append((r + N, c))

    # Shadow start = top-left of translated main
    start_r = min(r for r, c in trans_main)
    start_c = min(c for r, c in trans_main)

    # Simulate shadow with periodic reflection
    cur_r, cur_c = start_r, start_c
    drr, dcc = dr, dc
    shadow = [(cur_r, cur_c)]
    impacts = []
    seen = set()
    max_steps = width * height * 4
    steps = 0
    while True:
        state = (cur_r, cur_c, drr, dcc)
        if state in seen:
            break
        seen.add(state)
        if steps > max_steps:
            break
        steps += 1
        nr = cur_r + drr
        nc = cur_c + dcc
        if not (0 <= nr < height) or not (0 <= nc < width):
            impacts.append((cur_r, cur_c))
            if not (0 <= nr < height):
                drr = -drr
            if not (0 <= nc < width):
                dcc = -dcc
            nr = cur_r + drr
            nc = cur_c + dcc
            if not (0 <= nr < height) or not (0 <= nc < width):
                break
            cur_r, cur_c = nr, nc
            shadow.append((cur_r, cur_c))
        else:
            cur_r, cur_c = nr, nc
            shadow.append((cur_r, cur_c))

    # Build output grid by copying input (preserve originals)
    out = [row.copy() for row in grid_in]

    # Add translated main object (without overwriting existing non-zero cells)
    for r, c in trans_main:
        if 0 <= r < height and 0 <= c < width and out[r][c] == 0:
            out[r][c] = 5

    # Draw shadow (color 4) only on empty cells
    for r, c in shadow:
        if 0 <= r < height and 0 <= c < width and out[r][c] == 0:
            out[r][c] = 4

    # Mark impacts (color 8) only on empty cells
    for r, c in impacts:
        if 0 <= r < height and 0 <= c < width and out[r][c] == 0:
            out[r][c] = 8

    # Swap rows that contain impact highlights top-to-bottom
    rows_with_impact = sorted({r for r in range(height) if 8 in out[r]})
    for r in rows_with_impact:
        if r < height - 1:
            out[r], out[r + 1] = out[r + 1], out[r]
        else:
            out[r], out[r - 1] = out[r - 1], out[r]

    return out

