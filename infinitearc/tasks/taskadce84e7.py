# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: adce84e7
Difficulty: easy

=== Tags ===
- Collapse duplicates
- Swap columns
- Extend line to edge
- Measure length

=== Description ===
The task involves identifying the longest horizontal sequence of the same color
in the input grid. The length (L) of this sequence is measured. The sequence is
then extended to the left edge of the grid, making it start at column 0.
Finally, the first column (column 0) is swapped with the column at position L.
The "collapse duplicates" tag refers to measuring the length of the repeated
sequence (i.e., the number of duplicate adjacent cells), while "extend line to
edge" and "measure length" directly describe the sequence extension and length
determination. The "swap columns" rule applies the swap between column 0 and
column L after the sequence is extended. All transformations are visually
intuitive, relying on sequence length and grid geometry without numerical or
parity-based rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(1, 30)
    grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
    
    max_len = 0
    max_run = None
    
    for r in range(height):
        c = 0
        while c < width:
            color = grid[r][c]
            length = 0
            while c + length < width and grid[r][c + length] == color:
                length += 1
            if length > max_len:
                max_len = length
                max_run = (r, c, color)
            c += length
    
    if max_len < 2:
        return generate()
    
    L = max_len
    r, start, color = max_run
    
    output = [row[:] for row in grid]
    for c in range(start):
        output[r][c] = color
    
    for r in range(height):
        output[r][0], output[r][L] = output[r][L], output[r][0]
    
    if grid == output:
        return generate()
    
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    
    max_len = 0
    max_run = None
    
    for r in range(len(input_grid)):
        c = 0
        while c < len(input_grid[0]):
            color = input_grid[r][c]
            length = 0
            while c + length < len(input_grid[0]) and input_grid[r][c + length] == color:
                length += 1
            if length > max_len:
                max_len = length
                max_run = (r, c, color)
            c += length
    
    if max_len < 2:
        return input_grid
    
    L = max_len
    r, start, color = max_run
    
    output = [row[:] for row in input_grid]
    for c in range(start):
        output[r][c] = color
    
    for r in range(len(output)):
        output[r][0], output[r][L] = output[r][L], output[r][0]
    
    return output
