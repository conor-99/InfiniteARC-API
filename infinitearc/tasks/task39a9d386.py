# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 39a9d386
Difficulty: insane

=== Tags ===
- Diagonal symmetry

=== Description ===
The task requires transforming an input grid into an output grid by transposing
the input, meaning that each element at position (i, j) in the input is moved to
position (j, i) in the output. This operation mirrors the grid across the main
diagonal (top-left to bottom-right), causing rows to become columns and columns
to become rows. Input grids are intricate and complex, featuring large
dimensions (up to 30Ã—30) with numerous distinct patterns, shapes, and color
arrangements distributed asymmetrically across the grid. The output grid must
reflect the exact transposition of all elements, requiring the solver to
recognize that every pixel's position is mirrored relative to the main diagonal.
For instance, a red pixel located at row 2, column 5 in the input will appear at
row 5, column 2 in the output, while maintaining its structural relationship to
other elements. The complexity arises from the need to track multiple
overlapping patterns and color transitions across the diagonal in large,
visually dense grids, making the transposition rule non-trivial to identify
without systematic reasoning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    w = random.randint(1, 30)
    h = random.randint(1, 30)
    input_grid = common.grid(w, h)
    for i in range(h):
        for j in range(w):
            input_grid[i][j] = random.choice(range(0, 10))
    if h == w:
        symmetric = True
        for i in range(h):
            for j in range(i+1, w):
                if input_grid[i][j] != input_grid[j][i]:
                    symmetric = False
                    break
            if not symmetric:
                break
        if symmetric:
            i, j = 0, 1
            original = input_grid[i][j]
            new_color = original
            while new_color == original:
                new_color = random.choice(range(0, 10))
            input_grid[i][j] = new_color
    output_grid = common.transpose(input_grid)
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    return common.transpose(input_grid)
