# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 4c851446
Difficulty: hard

=== Tags ===
- Pattern moving
- Image resizing
- Pocket fill
- Pattern completion

=== Description ===
The task involves transforming an input grid into an output grid through a
sequence of abstract operations that combine pattern movement, image resizing,
pocket filling, and pattern completion. The input grid contains a pattern
composed of non-zero colors (1–9) with enclosed pockets—empty cells (value 0)
completely surrounded by non-zero values in all four cardinal directions (up,
down, left, right). The transformation proceeds as follows:  1. **Pocket fill**:
All pockets (enclosed 0 cells) are filled with color 5, completing the pattern
by eliminating internal gaps.   2. **Image resizing**: The grid is scaled by a
factor of 2, where each cell in the input becomes a 2×2 block of identical color
in the output.   3. **Pattern moving**: The entire pattern (including filled
pockets) is shifted one cell to the right, resulting in the leftmost column of
the resized grid being filled with zeros (0), while the pattern aligns to
columns 1–N+1.    This process requires the solver to detect enclosed pockets
through relational reasoning, apply deterministic resizing, and execute a
precise positional shift—all while ensuring the output grid remains within valid
dimensions (1×1 to 30×30) and all transformations follow consistent, abstract
rules. The task is challenging due to the need to interleave multiple operations
(filling, scaling, shifting) and correctly identify pockets that require
completion.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    H = random.randint(3, 15)
    W = random.randint(3, 14)
    grid_input = [[1] * W for _ in range(H)]
    r = random.randint(1, H-2)
    c = random.randint(1, W-2)
    grid_input[r][c] = 0
    grid_filled = [[5 if cell == 0 else cell for cell in row] for row in grid_input]
    H2, W2 = 2 * H, 2 * W
    grid_resized = [[0] * W2 for _ in range(H2)]
    for i in range(H):
        for j in range(W):
            val = grid_filled[i][j]
            grid_resized[2*i][2*j] = val
            grid_resized[2*i][2*j+1] = val
            grid_resized[2*i+1][2*j] = val
            grid_resized[2*i+1][2*j+1] = val
    H3, W3 = H2, W2 + 1
    grid_output = [[0] * W3 for _ in range(H3)]
    for i in range(H2):
        for j in range(W2):
            grid_output[i][j+1] = grid_resized[i][j]
    return {"input": grid_input, "output": grid_output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    H, W = len(input_grid), len(input_grid[0])
    grid_filled = [row[:] for row in input_grid]
    for r in range(H):
        for c in range(W):
            if input_grid[r][c] == 0:
                up = input_grid[r-1][c] if r > 0 else 0
                down = input_grid[r+1][c] if r < H-1 else 0
                left = input_grid[r][c-1] if c > 0 else 0
                right = input_grid[r][c+1] if c < W-1 else 0
                if up > 0 and down > 0 and left > 0 and right > 0:
                    grid_filled[r][c] = 5
    H2, W2 = 2 * H, 2 * W
    grid_resized = [[0] * W2 for _ in range(H2)]
    for i in range(H):
        for j in range(W):
            val = grid_filled[i][j]
            grid_resized[2*i][2*j] = val
            grid_resized[2*i][2*j+1] = val
            grid_resized[2*i+1][2*j] = val
            grid_resized[2*i+1][2*j+1] = val
    H3, W3 = H2, W2 + 1
    grid_output = [[0] * W3 for _ in range(H3)]
    for i in range(H2):
        for j in range(W2):
            grid_output[i][j+1] = grid_resized[i][j]
    return grid_output
