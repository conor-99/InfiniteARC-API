# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 61e44ebd
Difficulty: hard

=== Tags ===
- Hierarchical logic composition
- Zigzag path
- Image expasion

=== Description ===
Input grids are medium to large (15×15 to 30×30), featuring a single background
color with a hierarchical arrangement of nested colored regions. Each region is
a rectangular block of uniform color (non-background) that contains child
regions within its bounds, forming a tree-like hierarchy with nesting depths of
1–3 levels. The regions are non-overlapping and arranged such that parent
regions fully enclose child regions without touching boundaries.  The zigzag
path originates at the top-left corner of the grid, moving rightward through
background cells. Upon entering the boundary of a region (i.e., adjacent to its
perimeter), the path direction changes: it turns 90° clockwise if the region’s
nesting level is odd, and counterclockwise if even. The path is rendered on
background cells with a thickness equal to the region’s nesting level (e.g.,
level 1 = single-cell width, level 2 = two-cell width, level 3 = three-cell
width), using the region’s color. The path never overlaps regions, existing path
segments, or background obstacles, and regions remain fully visible in the
output. The transformation follows the hierarchical structure, with each
region’s level determining the path’s direction change and expansion thickness,
creating a visually distinct zigzag pattern that scales with the depth of
nesting.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    size = random.randint(15, 30)
    grid = [[0] * size for _ in range(size)]
    
    # Create hierarchical regions (levels 1,2,3 with colors 1,2,3)
    r1 = random.randint(3, 5)
    c1 = random.randint(5, 10)
    
    # Ensure valid region bounds
    lower_r = r1 + 5
    upper_r = size - 5
    r2 = random.randint(lower_r, upper_r) if lower_r <= upper_r else upper_r
    
    lower_c = c1 + 5
    upper_c = size - 5
    c2 = random.randint(lower_c, upper_c) if lower_c <= upper_c else upper_c
    
    # Level 1 (color 1)
    for r in range(r1, r2 + 1):
        for c in range(c1, c2 + 1):
            grid[r][c] = 1
    
    # Level 2 (color 2) inside level 1
    r1c, c1c = r1 + 1, c1 + 1
    r2c, c2c = r2 - 1, c2 - 1
    for r in range(r1c, r2c + 1):
        for c in range(c1c, c2c + 1):
            grid[r][c] = 2
    
    # Level 3 (color 3) inside level 2
    r1gc, c1gc = r1c + 1, c1c + 1
    r2gc, c2gc = r2c - 1, c2c - 1
    for r in range(r1gc, r2gc + 1):
        for c in range(c1gc, c2gc + 1):
            grid[r][c] = 3
    
    # Create output grid by drawing path
    output = [row[:] for row in grid]
    
    # Draw path
    r, c = 0, 0
    dr, dc = 0, 1  # Start moving right
    
    while 0 <= r < size and 0 <= c < size:
        nr, nc = r + dr, c + dc
        if not (0 <= nr < size and 0 <= nc < size):
            break
        
        if grid[nr][nc] != 0:  # Hit region
            level = grid[nr][nc]
            
            # Determine new direction
            if level % 2 == 1:  # Clockwise
                dr, dc = dc, -dr
            else:  # Counterclockwise
                dr, dc = -dc, dr
            
            # Draw path segment with current thickness (level)
            for d in range(level):
                pr, pc = r + (d - level // 2), c
                if 0 <= pr < size and 0 <= pc < size:
                    output[pr][pc] = level
            
            # Move to next cell
            r, c = nr, nc
        else:
            # Draw current path cell
            for d in range(1):  # Level 1 thickness for background path
                pr, pc = r + (d - 1 // 2), c
                if 0 <= pr < size and 0 <= pc < size:
                    output[pr][pc] = 1  # Default path color
            r, c = nr, nc

    return {'input': grid, 'output': output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    size = len(grid)
    output = [row[:] for row in grid]
    
    r, c = 0, 0
    dr, dc = 0, 1  # Start moving right
    
    while 0 <= r < size and 0 <= c < size:
        nr, nc = r + dr, c + dc
        if not (0 <= nr < size and 0 <= nc < size):
            break
        
        if grid[nr][nc] != 0:  # Hit region
            level = grid[nr][nc]
            
            # Determine new direction
            if level % 2 == 1:  # Clockwise
                dr, dc = dc, -dr
            else:  # Counterclockwise
                dr, dc = -dc, dr
            
            # Draw path segment with current thickness (level)
            for d in range(level):
                pr, pc = r + (d - level // 2), c
                if 0 <= pr < size and 0 <= pc < size:
                    output[pr][pc] = level
            
            r, c = nr, nc
        else:
            # Draw path with default thickness (level 1)
            for d in range(1):
                pr, pc = r + (d - 1 // 2), c
                if 0 <= pr < size and 0 <= pc < size:
                    output[pr][pc] = 1
            r, c = nr, nc

    return output
