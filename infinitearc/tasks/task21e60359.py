# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 21e60359
Difficulty: insane

=== Tags ===
- Loopless path
- Mask based logic

=== Description ===
Input grids feature a background color (0) overlaid with a mask region of a
single non-background color (1) that forms a connected, cycle-containing shape
(e.g., a ring or maze-like structure), and a distinct start marker (color 2)
positioned within the mask. The output grid must generate a loopless path that
traverses every cell within the mask region exactly once, beginning at the start
marker and ending at a terminal cell. This path is constructed by selecting a
spanning tree of the mask region rooted at the start marker, using a depth-first
search (DFS) traversal to ensure no cycles are formed. All cells along this path
are recolored with a new color (3), while the original mask color (1) and
background (0) remain unchanged elsewhere. The transformation requires
identifying the mask's structure, eliminating cycles through DFS, and precisely
mapping the path sequence to the grid, making it challenging due to the need for
combinatorial pathfinding within complex, cycle-containing regions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = random.randint(5, 10)
    height = random.randint(5, 10)
    rows, cols = common.hollow_conway(width, height, tries=5)
    if not rows:
        return generate()
    input_grid = common.grid(width, height, 0)
    for r, c in zip(rows, cols):
        input_grid[r][c] = 1
    start_idx = random.randint(0, len(rows) - 1)
    start_r, start_c = rows[start_idx], cols[start_idx]
    input_grid[start_r][start_c] = 2
    output_grid = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] == 1 or output_grid[r][c] == 2:
                output_grid[r][c] = 3
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    for i in range(len(input_list)):
        for j in range(len(input_list[0])):
            if input_list[i][j] == 1 or input_list[i][j] == 2:
                input_list[i][j] = 3
    return tuple(tuple(row) for row in input_list)
