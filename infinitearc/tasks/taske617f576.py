# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: e617f576
Difficulty: very hard

=== Tags ===
- Pattern expansion

=== Description ===
Geometric Pattern Growth  Input grids feature multiple distinct colored patterns
(each a connected region of a single color) on a background (color 0). Each
pattern's geometric shape dictates its expansion direction: horizontal lines
(spanning multiple columns in a single row) expand left and right, vertical
lines (spanning multiple rows in a single column) expand up and down, squares
(2x2 or larger contiguous blocks) expand in all four directions, and L-shaped
patterns expand along their two arms. The output grid is generated by expanding
each pattern outward by exactly two cells in all applicable directions, stopping
at grid boundaries or non-background cells. New cells are filled with the
pattern's original color; expansions do not overlap existing patterns or grid
boundaries. Original patterns and their colors remain unchanged, with no color
substitutions or additional transformations applied. The complexity arises from
correctly identifying the shape and orientation of each pattern amidst
overlapping regions and ensuring expansions stop precisely at boundaries without
overwriting.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import random_colors

def generate():
    """
    Generate a grid with multiple colored patterns (horizontal/vertical lines, squares, L-shapes)
    placed with a 2-cell padding so their expansions won't conflict. Then produce the
    output grid by expanding each pattern by up to two cells in their applicable directions.
    """
    # Helper: find connected regions in a grid (based on original input grid)
    def find_regions(grid):
        h = len(grid)
        w = len(grid[0])
        visited = [[False] * w for _ in range(h)]
        regions = []  # list of (color, list_of_coords)
        for r in range(h):
            for c in range(w):
                col = grid[r][c]
                if col == 0 or visited[r][c]:
                    continue
                stack = [(r, c)]
                visited[r][c] = True
                region = []
                while stack:
                    cr, cc = stack.pop()
                    region.append((cr, cc))
                    for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] == col:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                regions.append((col, region))
        return regions

    # Helper: expand a single region into outgrid according to rules
    def expand_region(grid_in, outgrid, region_coords, color):
        h = len(grid_in)
        w = len(grid_in[0])
        region_set = set(region_coords)
        min_r = min(r for r, c in region_coords)
        max_r = max(r for r, c in region_coords)
        min_c = min(c for r, c in region_coords)
        max_c = max(c for r, c in region_coords)

        # Detect shape
        shape = None
        corner = None
        h_range = None
        v_range = None

        if min_r == max_r:
            shape = 'horizontal'
        elif min_c == max_c:
            shape = 'vertical'
        else:
            size_r = max_r - min_r + 1
            size_c = max_c - min_c + 1
            # Perfect filled square
            if size_r == size_c and len(region_coords) == size_r * size_c and size_r >= 2:
                shape = 'square'
            else:
                # Try to detect an L-shape: union of a contiguous horizontal segment and a contiguous vertical segment
                found = False
                for (r0, c0) in region_coords:
                    # horizontal contiguous segment at row r0
                    left = c0
                    while (r0, left - 1) in region_set:
                        left -= 1
                    right = c0
                    while (r0, right + 1) in region_set:
                        right += 1
                    horiz = set((r0, cc) for cc in range(left, right + 1))
                    # vertical contiguous segment at column c0
                    up = r0
                    while (up - 1, c0) in region_set:
                        up -= 1
                    down = r0
                    while (down + 1, c0) in region_set:
                        down += 1
                    vert = set((rr, c0) for rr in range(up, down + 1))
                    union = horiz.union(vert)
                    if union == region_set and len(horiz) >= 2 and len(vert) >= 2:
                        found = True
                        shape = 'L'
                        corner = (r0, c0)
                        h_range = (left, right)
                        v_range = (up, down)
                        break
                if not found:
                    # Fallback: treat irregular multi-row/multi-column block as a block expanding in four directions
                    shape = 'block'

        # Expansion helper: try to apply a layer of target cells; stop direction if any target invalid
        def try_fill(targets):
            for (rr, cc) in targets:
                if rr < 0 or rr >= h or cc < 0 or cc >= w:
                    return False
                if outgrid[rr][cc] != 0:
                    return False
            for (rr, cc) in targets:
                outgrid[rr][cc] = color
            return True

        if shape == 'horizontal':
            # left
            for step in (1, 2):
                targets = {(r, c - step) for (r, c) in region_set}
                if not try_fill(targets):
                    break
            # right
            for step in (1, 2):
                targets = {(r, c + step) for (r, c) in region_set}
                if not try_fill(targets):
                    break

        elif shape == 'vertical':
            # up
            for step in (1, 2):
                targets = {(r - step, c) for (r, c) in region_set}
                if not try_fill(targets):
                    break
            # down
            for step in (1, 2):
                targets = {(r + step, c) for (r, c) in region_set}
                if not try_fill(targets):
                    break

        elif shape == 'square' or shape == 'block':
            rows = range(min_r, max_r + 1)
            cols = range(min_c, max_c + 1)
            # left
            for step in (1, 2):
                targets = {(r, min_c - step) for r in rows}
                if not try_fill(targets):
                    break
            # right
            for step in (1, 2):
                targets = {(r, max_c + step) for r in rows}
                if not try_fill(targets):
                    break
            # up
            for step in (1, 2):
                targets = {(min_r - step, c) for c in cols}
                if not try_fill(targets):
                    break
            # down
            for step in (1, 2):
                targets = {(max_r + step, c) for c in cols}
                if not try_fill(targets):
                    break

        elif shape == 'L':
            # Determine horizontal arm endpoint and direction
            r0, c0 = corner
            left, right = h_range
            up, down = v_range
            if left == c0:
                h_end_col = right
                h_dir = 1
            elif right == c0:
                h_end_col = left
                h_dir = -1
            else:
                # choose side where the arm extends farther
                if (right - c0) >= (c0 - left):
                    h_end_col = right
                    h_dir = 1
                else:
                    h_end_col = left
                    h_dir = -1
            if up == r0:
                v_end_row = down
                v_dir = 1
            elif down == r0:
                v_end_row = up
                v_dir = -1
            else:
                if (down - r0) >= (r0 - up):
                    v_end_row = down
                    v_dir = 1
                else:
                    v_end_row = up
                    v_dir = -1

            # extend horizontal arm outward beyond its endpoint
            for step in (1, 2):
                targets = {(r0, h_end_col + step * h_dir)}
                if not try_fill(targets):
                    break
            # extend vertical arm outward beyond its endpoint
            for step in (1, 2):
                targets = {(v_end_row + step * v_dir, c0)}
                if not try_fill(targets):
                    break

    # Attempt generation until we produce a nontrivial example (input != output)
    for attempt in range(200):
        width = random.randint(7, 18)
        height = random.randint(7, 18)
        grid_in = [[0 for _ in range(width)] for _ in range(height)]

        used_padded = []  # list of (pad_minr, pad_maxr, pad_minc, pad_maxc) to avoid placing shapes too close
        placed_any = False

        n_shapes = random.randint(2, min(5, 9))
        colors = random_colors(n_shapes, exclude=[0])

        for color in colors:
            placed = False
            for _ in range(200):
                shape = random.choice(['horizontal', 'vertical', 'square', 'L'])
                coords = []
                # Build a candidate shape placed with at least a 2-cell padding from edges to allow expansions
                if shape == 'horizontal':
                    max_len = min(6, width - 6)
                    if max_len < 2:
                        continue
                    length = random.randint(2, max_len)
                    row = random.randint(2, height - 3)
                    start_col = random.randint(2, width - length - 3)
                    coords = [(row, start_col + i) for i in range(length)]
                elif shape == 'vertical':
                    max_len = min(6, height - 6)
                    if max_len < 2:
                        continue
                    length = random.randint(2, max_len)
                    col = random.randint(2, width - 3)
                    start_row = random.randint(2, height - length - 3)
                    coords = [(start_row + i, col) for i in range(length)]
                elif shape == 'square':
                    max_s = min(6, width - 6, height - 6)
                    if max_s < 2:
                        continue
                    size = random.randint(2, max_s)
                    top = random.randint(2, height - size - 3)
                    left = random.randint(2, width - size - 3)
                    coords = [(r, c) for r in range(top, top + size) for c in range(left, left + size)]
                elif shape == 'L':
                    # choose orientation and arm lengths
                    max_arm_h = min(6, width - 6)
                    max_arm_v = min(6, height - 6)
                    if max_arm_h < 2 or max_arm_v < 2:
                        continue
                    arm_h = random.randint(2, max_arm_h)
                    arm_v = random.randint(2, max_arm_v)
                    orient = random.choice(['rd', 'ru', 'ld', 'lu'])
                    if orient == 'rd':
                        r0 = random.randint(2, height - arm_v - 3)
                        c0 = random.randint(2, width - arm_h - 3)
                        coords = [(r0, c0 + i) for i in range(arm_h)] + [(r0 + i, c0) for i in range(arm_v)]
                    elif orient == 'ru':
                        r0 = random.randint(arm_v + 2, height - 3)
                        c0 = random.randint(2, width - arm_h - 3)
                        coords = [(r0, c0 + i) for i in range(arm_h)] + [(r0 - i, c0) for i in range(arm_v)]
                    elif orient == 'ld':
                        r0 = random.randint(2, height - arm_v - 3)
                        c0 = random.randint(arm_h + 2, width - 3)
                        coords = [(r0, c0 - i) for i in range(arm_h)] + [(r0 + i, c0) for i in range(arm_v)]
                    else:  # lu
                        r0 = random.randint(arm_v + 2, height - 3)
                        c0 = random.randint(arm_h + 2, width - 3)
                        coords = [(r0, c0 - i) for i in range(arm_h)] + [(r0 - i, c0) for i in range(arm_v)]

                # Normalize coords (remove duplicates) and ensure within bounds
                coords = list(dict.fromkeys(coords))
                if not coords:
                    continue
                minr = min(r for r, c in coords)
                maxr = max(r for r, c in coords)
                minc = min(c for r, c in coords)
                maxc = max(c for r, c in coords)
                pad_minr, pad_minc = minr - 2, minc - 2
                pad_maxr, pad_maxc = maxr + 2, maxc + 2
                if pad_minr < 0 or pad_minc < 0 or pad_maxr >= height or pad_maxc >= width:
                    continue
                # check padding overlap
                bad = False
                for (bminr, bmaxr, bminc, bmaxc) in used_padded:
                    if not (pad_maxr < bminr or pad_minr > bmaxr or pad_maxc < bminc or pad_minc > bmaxc):
                        bad = True
                        break
                if bad:
                    continue
                # check that base cells are free
                blocked = False
                for (r, c) in coords:
                    if grid_in[r][c] != 0:
                        blocked = True
                        break
                if blocked:
                    continue
                # place shape
                for (r, c) in coords:
                    grid_in[r][c] = color
                used_padded.append((pad_minr, pad_maxr, pad_minc, pad_maxc))
                placed = True
                placed_any = True
                break
            # end attempts for this color
        # end color loop

        if not placed_any:
            continue

        outgrid = [row[:] for row in grid_in]
        regions = find_regions(grid_in)
        for (col, region_coords) in regions:
            expand_region(grid_in, outgrid, region_coords, col)

        if outgrid != grid_in:
            return {'input': grid_in, 'output': outgrid}

    # fallback guaranteed simple example if random attempts fail
    width, height = 9, 9
    grid_in = [[0 for _ in range(width)] for _ in range(height)]
    # simple horizontal in center
    grid_in[4][3] = 1
    grid_in[4][4] = 1
    grid_in[4][5] = 1
    outgrid = [row[:] for row in grid_in]
    expand_region(grid_in, outgrid, [(4, 3), (4, 4), (4, 5)], 1)
    return {'input': grid_in, 'output': outgrid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert tuple-of-tuples to modifiable list of lists
    grid_in = [list(row) for row in input_grid]
    h = len(grid_in)
    w = len(grid_in[0])

    # Find connected regions of non-zero color
    def find_regions(grid):
        visited = [[False] * w for _ in range(h)]
        regions = []
        for r in range(h):
            for c in range(w):
                col = grid[r][c]
                if col == 0 or visited[r][c]:
                    continue
                stack = [(r, c)]
                visited[r][c] = True
                region = []
                while stack:
                    cr, cc = stack.pop()
                    region.append((cr, cc))
                    for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] == col:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                regions.append((col, region))
        return regions

    # Expand a region into outgrid following the same rules as the generator
    def expand_region(grid_in, outgrid, region_coords, color):
        region_set = set(region_coords)
        min_r = min(r for r, c in region_coords)
        max_r = max(r for r, c in region_coords)
        min_c = min(c for r, c in region_coords)
        max_c = max(c for r, c in region_coords)

        shape = None
        corner = None
        h_range = None
        v_range = None

        if min_r == max_r:
            shape = 'horizontal'
        elif min_c == max_c:
            shape = 'vertical'
        else:
            size_r = max_r - min_r + 1
            size_c = max_c - min_c + 1
            if size_r == size_c and len(region_coords) == size_r * size_c and size_r >= 2:
                shape = 'square'
            else:
                found = False
                for (r0, c0) in region_coords:
                    left = c0
                    while (r0, left - 1) in region_set:
                        left -= 1
                    right = c0
                    while (r0, right + 1) in region_set:
                        right += 1
                    horiz = set((r0, cc) for cc in range(left, right + 1))
                    up = r0
                    while (up - 1, c0) in region_set:
                        up -= 1
                    down = r0
                    while (down + 1, c0) in region_set:
                        down += 1
                    vert = set((rr, c0) for rr in range(up, down + 1))
                    union = horiz.union(vert)
                    if union == region_set and len(horiz) >= 2 and len(vert) >= 2:
                        found = True
                        shape = 'L'
                        corner = (r0, c0)
                        h_range = (left, right)
                        v_range = (up, down)
                        break
                if not found:
                    shape = 'block'

        def try_fill(targets):
            for (rr, cc) in targets:
                if rr < 0 or rr >= h or cc < 0 or cc >= w:
                    return False
                if outgrid[rr][cc] != 0:
                    return False
            for (rr, cc) in targets:
                outgrid[rr][cc] = color
            return True

        if shape == 'horizontal':
            # left
            for step in (1, 2):
                targets = {(r, c - step) for (r, c) in region_set}
                if not try_fill(targets):
                    break
            # right
            for step in (1, 2):
                targets = {(r, c + step) for (r, c) in region_set}
                if not try_fill(targets):
                    break

        elif shape == 'vertical':
            # up
            for step in (1, 2):
                targets = {(r - step, c) for (r, c) in region_set}
                if not try_fill(targets):
                    break
            # down
            for step in (1, 2):
                targets = {(r + step, c) for (r, c) in region_set}
                if not try_fill(targets):
                    break

        elif shape == 'square' or shape == 'block':
            rows = range(min_r, max_r + 1)
            cols = range(min_c, max_c + 1)
            # left
            for step in (1, 2):
                targets = {(r, min_c - step) for r in rows}
                if not try_fill(targets):
                    break
            # right
            for step in (1, 2):
                targets = {(r, max_c + step) for r in rows}
                if not try_fill(targets):
                    break
            # up
            for step in (1, 2):
                targets = {(min_r - step, c) for c in cols}
                if not try_fill(targets):
                    break
            # down
            for step in (1, 2):
                targets = {(max_r + step, c) for c in cols}
                if not try_fill(targets):
                    break

        elif shape == 'L':
            r0, c0 = corner
            left, right = h_range
            up, down = v_range
            if left == c0:
                h_end_col = right
                h_dir = 1
            elif right == c0:
                h_end_col = left
                h_dir = -1
            else:
                if (right - c0) >= (c0 - left):
                    h_end_col = right
                    h_dir = 1
                else:
                    h_end_col = left
                    h_dir = -1
            if up == r0:
                v_end_row = down
                v_dir = 1
            elif down == r0:
                v_end_row = up
                v_dir = -1
            else:
                if (down - r0) >= (r0 - up):
                    v_end_row = down
                    v_dir = 1
                else:
                    v_end_row = up
                    v_dir = -1

            for step in (1, 2):
                targets = {(r0, h_end_col + step * h_dir)}
                if not try_fill(targets):
                    break
            for step in (1, 2):
                targets = {(v_end_row + step * v_dir, c0)}
                if not try_fill(targets):
                    break

    outgrid = [row[:] for row in grid_in]
    regions = find_regions(grid_in)
    for (col, region_coords) in regions:
        expand_region(grid_in, outgrid, region_coords, col)

    return outgrid

