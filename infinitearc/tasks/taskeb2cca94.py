# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: eb2cca94
Difficulty: very hard

=== Tags ===
- Local to global rule inference
- Color space mapping
- Seal gaps inside shape
- Duplicate row pattern

=== Description ===
Input grids are 20×20 with a single background color (0) and a complex, non-
convex main shape drawn in a single dominant color (A, e.g., red). The main
shape encloses multiple disconnected internal background gaps, each forming a
contiguous region fully surrounded by the main shape. The bottom row (row 19)
contains a repeating color pattern of three distinct colors (B, C, D), none of
which appear in the main shape, arranged in a sequence such as [B, C, D, B, C,
D, ...].   The output grid transforms the input by:   1. **Sealing all internal
gaps** within the main shape, filling each gap with a color from the bottom
row's pattern sequence.   2. **Applying color space mapping**: The pattern
sequence [B, C, D] is interpreted as a cyclic color palette, where B, C, D
correspond to fixed visual roles (e.g., B = "primary," C = "secondary," D =
"tertiary") rather than numerical values.   3. **Duplicate row pattern**: The
pattern sequence is cycled through to fill gaps in **row-major order** (top to
bottom, left to right), with the first gap filled with B, the second with C, the
third with D, the fourth with B, and so on.   4. **Global rule inference**: The
pattern's role as a cyclic palette is not immediately obvious from local gaps
(e.g., gaps of similar size may be filled with different colors), requiring the
solver to infer the global sequence from the bottom row.   5. **Non-
overwriting**: The main shape and bottom row remain unchanged; gaps are filled
only within the main shape's interior, never overlapping the shape's boundary.
The task demands identifying the pattern's cyclic nature, recognizing its global
application, and applying it to seal gaps in a sequence that requires both local
gap analysis and global pattern inference. The complexity arises from the non-
rectangular shape, variable gap sizes, and the need to distinguish the pattern’s
role from its numerical representation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = 20
    height = 20

    # Choose main shape color A and three distinct bottom-row palette colors B,C,D
    A = random.randint(1, 9)
    palette_choices = [c for c in range(1, 10) if c != A]
    B, C, D = random.sample(palette_choices, 3)
    pattern = [B, C, D]

    # Helper to compute internal zero components (holes) for a given mask
    def internal_components(mask):
        # mask[r][c] == True means shape pixel (A), False means background (0)
        from collections import deque
        visited_out = [[False] * width for _ in range(height)]
        q = deque()
        # start from boundary background pixels
        for r in range(height):
            for c in range(width):
                if r in (0, height - 1) or c in (0, width - 1):
                    if not mask[r][c]:
                        visited_out[r][c] = True
                        q.append((r, c))
        while q:
            r, c = q.popleft()
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and not visited_out[nr][nc] and not mask[nr][nc]:
                    visited_out[nr][nc] = True
                    q.append((nr, nc))
        # collect internal zero cells (not visited_out and not mask)
        internal_cells = []
        for r in range(height):
            for c in range(width):
                if not mask[r][c] and not visited_out[r][c]:
                    internal_cells.append((r, c))
        # build connected components among internal cells
        comps = []
        visited_comp = set()
        internal_set = set(internal_cells)
        for (r0, c0) in internal_cells:
            if (r0, c0) in visited_comp:
                continue
            # BFS for this component
            comp = []
            dq = deque([(r0, c0)])
            visited_comp.add((r0, c0))
            while dq:
                r, c = dq.popleft()
                comp.append((r, c))
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = r + dr, c + dc
                    if (nr, nc) in internal_set and (nr, nc) not in visited_comp:
                        visited_comp.add((nr, nc))
                        dq.append((nr, nc))
            comps.append(comp)
        return comps

    # Attempt to create a large central rectangle and carve several small interior holes
    outer_attempts = 0
    while True:
        outer_attempts += 1
        if outer_attempts > 200:
            # fallback: deterministic simple configuration
            r0, r1, c0, c1 = 2, 17, 2, 17
        else:
            # keep some variability in rectangle placement and size, but keep margin from edges
            r0 = random.randint(1, 3)
            r1 = random.randint(14, 17)
            c0 = random.randint(1, 3)
            c1 = random.randint(14, 17)
            # enforce minimum size
            if r1 - r0 < 8 or c1 - c0 < 8:
                continue

        # initialize shape mask (True = part of main shape)
        mask = [[False] * width for _ in range(height)]
        for r in range(r0, r1 + 1):
            for c in range(c0, c1 + 1):
                mask[r][c] = True

        # Choose target number of holes (ensure at least 3)
        target_holes = random.randint(3, 6)

        # possible centers for holes (leave at least one-pixel thick border inside)
        possible_centers = [(r, c) for r in range(r0 + 2, r1 - 1) for c in range(c0 + 2, c1 - 1)]
        if len(possible_centers) < target_holes:
            continue

        # Try to pick non-overlapping small rectangles as holes
        hole_candidates = []
        attempts = 0
        max_attempts = 200
        while len(hole_candidates) < target_holes and attempts < max_attempts and possible_centers:
            attempts += 1
            center = random.choice(possible_centers)
            cr, cc = center
            h = random.randint(1, 3)
            w = random.randint(1, 3)
            top = cr - (h // 2)
            left = cc - (w // 2)
            # ensure rect fully inside the inner safe area
            if top < r0 + 1 or left < c0 + 1 or top + h - 1 > r1 - 1 or left + w - 1 > c1 - 1:
                # can't place here
                continue
            cells = set((rr, cc2) for rr in range(top, top + h) for cc2 in range(left, left + w))
            # no overlap with existing holes
            overlap = False
            for hc in hole_candidates:
                if hc & cells:
                    overlap = True
                    break
            if overlap:
                continue
            # accept this candidate
            hole_candidates.append(cells)
            # remove nearby centers to help keep separation
            possible_centers = [p for p in possible_centers if abs(p[0] - cr) > 2 or abs(p[1] - cc) > 2]

        if len(hole_candidates) < target_holes:
            # try again
            continue

        # carve holes into mask
        for cells in hole_candidates:
            for (rr, cc) in cells:
                mask[rr][cc] = False

        # compute internal components
        comps = internal_components(mask)
        if len(comps) >= target_holes:
            # success - keep the first target_holes components (there may be accidental extra tiny components)
            # but ensure we have exactly the connected components we'll fill later
            break
        # otherwise retry generating shape/hole layout

    # Build input grid
    grid_in = [[0 for _ in range(width)] for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if mask[r][c]:
                grid_in[r][c] = A

    # bottom row pattern starting at leftmost cell
    for c in range(width):
        grid_in[height - 1][c] = pattern[c % 3]

    # Build output grid by filling internal components with palette colors in row-major order
    grid_out = [row[:] for row in grid_in]
    comps = internal_components(mask)
    # sort components by their top-left-most pixel (row-major)
    comps.sort(key=lambda comp: (min(p[0] for p in comp), min(p[1] for p in comp)))

    for idx, comp in enumerate(comps):
        color = pattern[idx % 3]
        for (r, c) in comp:
            grid_out[r][c] = color

    return {"input": grid_in, "output": grid_out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Identify the bottom-row cyclic palette of three colors B,C,D in left-to-right order
    bottom = grid[height - 1]
    palette = []
    for val in bottom:
        if val not in palette:
            palette.append(val)
            if len(palette) == 3:
                break
    # as a fallback, if fewer than 3 unique colors found, gather all unique non-zero colors in bottom row
    if len(palette) < 3:
        seen = []
        for val in bottom:
            if val != 0 and val not in seen:
                seen.append(val)
        palette = seen

    # determine main shape color A (the non-background color that is not in the palette)
    color_counts = {}
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if v == 0: continue
            if v in palette: continue
            color_counts[v] = color_counts.get(v, 0) + 1
    A = None
    if color_counts:
        # choose the most frequent non-palette color
        A = max(color_counts, key=lambda k: color_counts[k])

    # Mark outside background reachable from the external boundary
    from collections import deque
    visited_out = [[False] * width for _ in range(height)]
    q = deque()
    for r in range(height):
        for c in range(width):
            if r in (0, height - 1) or c in (0, width - 1):
                if grid[r][c] == 0:
                    visited_out[r][c] = True
                    q.append((r, c))
    while q:
        r, c = q.popleft()
        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited_out[nr][nc] and grid[nr][nc] == 0:
                visited_out[nr][nc] = True
                q.append((nr, nc))

    # Collect internal zero cells (holes) and their connected components
    internal_cells = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == 0 and not visited_out[r][c]]
    internal_set = set(internal_cells)
    comps = []
    visited_comp = set()
    for (r0, c0) in internal_cells:
        if (r0, c0) in visited_comp:
            continue
        comp = []
        dq = deque([(r0, c0)])
        visited_comp.add((r0, c0))
        while dq:
            r, c = dq.popleft()
            comp.append((r, c))
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = r + dr, c + dc
                if (nr, nc) in internal_set and (nr, nc) not in visited_comp:
                    visited_comp.add((nr, nc))
                    dq.append((nr, nc))
        comps.append(comp)

    # Sort components by top-left-most pixel (row-major order)
    comps.sort(key=lambda comp: (min(p[0] for p in comp), min(p[1] for p in comp)))

    # Fill each component with the cyclic palette
    for idx, comp in enumerate(comps):
        color = palette[idx % len(palette)]
        for (r, c) in comp:
            grid[r][c] = color

    return grid

