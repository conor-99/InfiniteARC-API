# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 02039217
Difficulty: very hard

=== Tags ===
- Pattern rotation
- Signal to structure
- Stripe detection

=== Description ===
Input grids are large (20Ã—20 or larger) with a uniform background color.
Overlaid on the background are horizontal and vertical stripes of distinct
colors, each stripe being a continuous line spanning the grid's width
(horizontal) or height (vertical). The stripes intersect to form a lattice, with
each cell between stripes filled with the background color. All horizontal
stripes have unique colors not shared with any vertical stripe, and vice versa.
The stripes form a non-trivial pattern where horizontal and vertical lines may
vary in thickness but maintain consistent color continuity without interruption.
The output grid is generated by first detecting all horizontal stripe colors in
top-to-bottom order and rotating this sequence by one position (last color moves
to the front), then detecting all vertical stripe colors in left-to-right order
and rotating this sequence by one position (first color moves to the end). The
rotated horizontal sequence becomes the new vertical stripe colors (left-to-
right), and the rotated vertical sequence becomes the new horizontal stripe
colors (top-to-bottom). The lattice structure is rotated 90 degrees such that
the new vertical stripes align with the original horizontal stripe positions and
new horizontal stripes align with original vertical stripe positions, preserving
the background cell structure. The transformation requires precise stripe
detection, sequence rotation, and spatial reassignment, with no overlapping or
color overwriting between stripes and background.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def place_stripes(size,count,max_thickness=3,min_gap=1,tries=300):
    for _ in range(tries):
        occupied = [False]*size
        starts=[]
        thicknesses=[]
        success=True
        for i in range(count):
            t = random.randint(1,max_thickness)
            possible=[]
            for s in range(0,size - t +1):
                ok=True
                for k in range(s,s+t):
                    if occupied[k]:
                        ok=False; break
                if not ok: continue
                # ensure gap (no adjacent stripes)
                if s>0 and occupied[s-1]: ok=False
                if s+t < size and occupied[s+t]: ok=False
                if not ok: continue
                possible.append(s)
            if not possible:
                success=False
                break
            s = random.choice(possible)
            starts.append(s)
            thicknesses.append(t)
            for k in range(s,s+t):
                occupied[k]=True
        if not success:
            continue
        combined = sorted(zip(starts,thicknesses), key=lambda x: x[0])
        return combined
    # fallback deterministic placement
    res=[]
    base = max(1, (size - (count -1))//count)
    rem = max(0, (size - (count -1))%count)
    s=0
    for i in range(count):
        t = max(1, base + (1 if i < rem else 0))
        if s + t > size:
            s = max(0, size - t)
        res.append((s,t))
        s += t+1
    return res


def generate():
    # Try until we get a pattern where background remains the most common color
    for attempt in range(200):
        size = random.randint(20,30)
        background = random.randint(0,9)
        h_count = random.randint(2,4)
        v_count = random.randint(2,4)
        avail_colors = [c for c in range(10) if c != background]
        total_needed = h_count + v_count
        if total_needed > len(avail_colors):
            v_count = max(2, len(avail_colors) - h_count)
            total_needed = h_count + v_count
        chosen = random.sample(avail_colors, total_needed)
        H_colors = chosen[:h_count]
        V_colors = chosen[h_count:]
        h_groups = place_stripes(size, h_count, max_thickness=3)
        v_groups = place_stripes(size, v_count, max_thickness=3)
        # compute coverage to ensure background majority
        total_v_cols = sum(th for (_,th) in v_groups)
        total_h_rows = sum(th for (_,th) in h_groups)
        # non-background cells = vertical columns across all rows + horizontal rows in non-vertical columns
        non_bg = total_v_cols * size + sum(th * (size - total_v_cols) for (_,th) in h_groups)
        if non_bg * 2 >= size * size:
            # too much colored area; retry
            continue
        # build input
        inp = [[background for _ in range(size)] for _ in range(size)]
        for idx, (r_start, thickness) in enumerate(h_groups):
            color = H_colors[idx]
            for r in range(r_start, r_start + thickness):
                for c in range(size):
                    inp[r][c] = color
        for idx, (c_start, thickness) in enumerate(v_groups):
            color = V_colors[idx]
            for c in range(c_start, c_start + thickness):
                for r in range(size):
                    inp[r][c] = color
        # build output
        rotated_H = H_colors[-1:] + H_colors[:-1]
        rotated_V = V_colors[1:] + V_colors[:1]
        out = [[background for _ in range(size)] for _ in range(size)]
        for j, (r_start, thickness) in enumerate(v_groups):
            color = rotated_V[j]
            for r in range(r_start, r_start + thickness):
                for c in range(size):
                    out[r][c] = color
        for i, (c_start, thickness) in enumerate(h_groups):
            color = rotated_H[i]
            for c in range(c_start, c_start + thickness):
                for r in range(size):
                    out[r][c] = color
        if inp == out:
            continue
        return {'input': inp, 'output': out}
    # fallback deterministic simple pattern
    size = 20
    background = 0
    H_colors = [1,2]
    V_colors = [3,4]
    h_groups = [(3,2),(10,2)]
    v_groups = [(5,1),(15,1)]
    inp = [[background for _ in range(size)] for _ in range(size)]
    for idx, (r_start, thickness) in enumerate(h_groups):
        color = H_colors[idx]
        for r in range(r_start, r_start + thickness):
            for c in range(size):
                inp[r][c] = color
    for idx, (c_start, thickness) in enumerate(v_groups):
        color = V_colors[idx]
        for c in range(c_start, c_start + thickness):
            for r in range(size):
                inp[r][c] = color
    rotated_H = H_colors[-1:] + H_colors[:-1]
    rotated_V = V_colors[1:] + V_colors[:1]
    out = [[background for _ in range(size)] for _ in range(size)]
    for j, (r_start, thickness) in enumerate(v_groups):
        color = rotated_V[j]
        for r in range(r_start, r_start + thickness):
            for c in range(size):
                out[r][c] = color
    for i, (c_start, thickness) in enumerate(h_groups):
        color = rotated_H[i]
        for c in range(c_start, c_start + thickness):
            for r in range(size):
                out[r][c] = color
    return {'input': inp, 'output': out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    from collections import Counter
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    vals = [cell for row in grid for cell in row]
    background = Counter(vals).most_common(1)[0][0]
    # detect vertical stripe columns
    col_all_non_bg = [all(grid[r][c] != background for r in range(height)) for c in range(width)]
    vertical_cols = [c for c,all_non in enumerate(col_all_non_bg) if all_non]
    # group contiguous vertical columns
    v_groups = []
    if vertical_cols:
        start = prev = vertical_cols[0]
        for c in vertical_cols[1:]:
            if c == prev + 1:
                prev = c
            else:
                v_groups.append((start, prev - start + 1))
                start = prev = c
        v_groups.append((start, prev - start + 1))
    # detect horizontal stripe rows
    row_all_non_bg = [all(grid[r][c] != background for c in range(width)) for r in range(height)]
    horizontal_rows = [r for r,all_non in enumerate(row_all_non_bg) if all_non]
    h_groups = []
    if horizontal_rows:
        start = prev = horizontal_rows[0]
        for r in horizontal_rows[1:]:
            if r == prev + 1:
                prev = r
            else:
                h_groups.append((start, prev - start + 1))
                start = prev = r
        h_groups.append((start, prev - start + 1))
    # determine colors
    H_colors = []
    non_vertical_set = set(vertical_cols)
    for (r_start, thickness) in h_groups:
        colors = []
        for r in range(r_start, r_start + thickness):
            for c in range(width):
                if c in non_vertical_set: continue
                val = grid[r][c]
                if val != background:
                    colors.append(val)
        if colors:
            color = Counter(colors).most_common(1)[0][0]
        else:
            colors2 = [grid[r][c] for r in range(r_start, r_start + thickness) for c in range(width) if grid[r][c] != background]
            color = Counter(colors2).most_common(1)[0][0] if colors2 else background
        H_colors.append(color)
    V_colors = []
    for (c_start, thickness) in v_groups:
        colors = []
        for c in range(c_start, c_start + thickness):
            for r in range(height):
                val = grid[r][c]
                if val != background:
                    colors.append(val)
        color = Counter(colors).most_common(1)[0][0] if colors else background
        V_colors.append(color)
    # rotate
    rotated_H = H_colors[-1:] + H_colors[:-1] if H_colors else []
    rotated_V = V_colors[1:] + V_colors[:1] if V_colors else []
    # build output
    out = [[background for _ in range(width)] for _ in range(height)]
    for j, (r_start, thickness) in enumerate(v_groups):
        if j < len(rotated_V):
            color = rotated_V[j]
            for r in range(r_start, r_start + thickness):
                for c in range(width):
                    out[r][c] = color
    for i, (c_start, thickness) in enumerate(h_groups):
        if i < len(rotated_H):
            color = rotated_H[i]
            for c in range(c_start, c_start + thickness):
                for r in range(height):
                    out[r][c] = color
    return out

