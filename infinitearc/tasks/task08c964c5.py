# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 08c964c5
Difficulty: very hard

=== Tags ===
- Color particle emission
- Elastic wave
- Mapping by size relation

=== Description ===
# Elastic Particle Cascade  Input grids are large (20×20 minimum) with a uniform
background color. Overlaid are multiple distinct emitter regions (each a
contiguous block of color, size 1–3 cells) and obstacle regions (orthogonal
walls of color, 1 cell thick, either horizontal or vertical). Emitters and
obstacles are separated by at least one background cell.  In the output grid: -
Emitters and obstacles remain visible unchanged. - Each emitter of size S emits
S particles in directions determined by S (S=1: northeast; S=2: northeast,
northwest; S=3: northeast, northwest, southwest). - Particles move diagonally
one cell per step until hitting an obstacle, at which point:   - Their color
changes to match the obstacle's color   - Their direction reflects according to
the obstacle's orientation (vertical walls reflect horizontally, horizontal
walls reflect vertically) - Each subsequent reflection continues the path with
the new color, creating a cascading color trail - Particles exit the grid after
a finite number of reflections, leaving only their colored paths on background
cells - The number of reflections a particle undergoes before exiting correlates
with the emitter's size, creating size-dependent wave patterns - Paths never
overlap or overwrite emitters, obstacles, or other paths - All paths eventually
exit the grid with no remaining particles  The transformation requires
simultaneously tracking multiple particle paths, color changes upon each
obstacle interaction, reflection direction changes based on obstacle
orientation, and ensuring all paths exit the grid, making it a complex multi-
step simulation requiring precise geometric and color reasoning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = random.randint(20, 30)
    height = random.randint(20, 30)
    bg = random.randint(0, 9)
    input_grid = common.grid(width, height, bg)
    output_grid = common.grid(width, height, bg)
    
    # Place emitters
    emitter_pixels_list = []
    emitter_colors = []
    for _ in range(random.randint(1, 3)):
        S = random.randint(1, 3)
        emitter_pixels = common.continuous_creature(S, width, height)
        emitter_pixels = [(r, c) for r, c in emitter_pixels if 2 <= r < height-2 and 2 <= c < width-2]
        if not emitter_pixels:
            continue
        color = random.randint(1, 9)
        while color == bg or color in emitter_colors:
            color = random.randint(1, 9)
        emitter_pixels_list.append(emitter_pixels)
        emitter_colors.append(color)
        for r, c in emitter_pixels:
            input_grid[r][c] = color
    
    # Place obstacles (length 4-5 to distinguish from emitters)
    for _ in range(random.randint(2, 5)):
        orientation = random.choice(['horizontal', 'vertical'])
        length = random.randint(4, 5)
        placed = False
        while not placed:
            if orientation == 'horizontal':
                r = random.randint(2, height-5)
                c_start = random.randint(2, width-5 - length + 1)
                obstacle_pixels = [(r, c) for c in range(c_start, c_start + length)]
            else:
                c = random.randint(2, width-5)
                r_start = random.randint(2, height-5 - length + 1)
                obstacle_pixels = [(r, c) for r in range(r_start, r_start + length)]
            if all(input_grid[r][c] == bg for r, c in obstacle_pixels):
                placed = True
                color = random.randint(1, 9)
                while color == bg or color in emitter_colors:
                    color = random.randint(1, 9)
                for r, c in obstacle_pixels:
                    input_grid[r][c] = color
    
    # Simulate particle paths
    def get_direction_delta(d):
        if d == 'NE': return (-1, 1)
        if d == 'NW': return (-1, -1)
        if d == 'SW': return (1, -1)
        if d == 'SE': return (1, 1)
        return (0, 0)

    def reflect_vertically(d):
        if d == 'NE': return 'SE'
        if d == 'SE': return 'NE'
        if d == 'NW': return 'SW'
        if d == 'SW': return 'NW'
        return d

    def reflect_horizontally(d):
        if d == 'NE': return 'NW'
        if d == 'NW': return 'NE'
        if d == 'SE': return 'SW'
        if d == 'SW': return 'SE'
        return d

    def is_horizontal_obstacle(r, c):
        if c > 0 and input_grid[r][c-1] != bg:
            return True
        if c < width-1 and input_grid[r][c+1] != bg:
            return True
        return False

    def is_vertical_obstacle(r, c):
        if r > 0 and input_grid[r-1][c] != bg:
            return True
        if r < height-1 and input_grid[r+1][c] != bg:
            return True
        return False

    for i, (pixels, color) in enumerate(zip(emitter_pixels_list, emitter_colors)):
        S = len(pixels)
        directions = {
            1: ['NE'],
            2: ['NE', 'NW'],
            3: ['NE', 'NW', 'SW']
        }[S]
        sorted_pixels = sorted(pixels, key=lambda x: (x[0], x[1]))
        for idx, (r, c) in enumerate(sorted_pixels):
            if idx >= len(directions):
                break
            current_r, current_c = r, c
            current_dir = directions[idx]
            current_color = color
            while True:
                dr, dc = get_direction_delta(current_dir)
                next_r, next_c = current_r + dr, current_c + dc
                if next_r < 0 or next_r >= height or next_c < 0 or next_c >= width:
                    break
                if input_grid[next_r][next_c] == bg:
                    output_grid[next_r][next_c] = current_color
                    current_r, current_c = next_r, next_c
                else:
                    if is_horizontal_obstacle(next_r, next_c):
                        current_dir = reflect_vertically(current_dir)
                    else:
                        current_dir = reflect_horizontally(current_dir)
                    current_color = input_grid[next_r][next_c]
                    current_r, current_c = next_r, next_c
    
    if input_grid == output_grid:
        return generate()
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
import random

def p(input_grid):
    if not input_grid:
        return input_grid
    width = len(input_grid[0])
    height = len(input_grid)
    bg = input_grid[0][0]
    output_grid = common.grid(width, height, bg)
    
    def get_contiguous_blocks(grid):
        visited = [[False] * len(grid[0]) for _ in range(len(grid))]
        blocks = []
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                if not visited[r][c] and grid[r][c] != bg:
                    block = []
                    stack = [(r, c)]
                    visited[r][c] = True
                    while stack:
                        cr, cc = stack.pop()
                        block.append((cr, cc))
                        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and not visited[nr][nc] and grid[nr][nc] == grid[r][c]:
                                visited[nr][nc] = True
                                stack.append((nr, nc))
                    blocks.append(block)
        return blocks

    blocks = get_contiguous_blocks(input_grid)
    emitter_blocks = [block for block in blocks if 1 <= len(block) <= 3]
    emitter_colors = [input_grid[block[0][0]][block[0][1]] for block in emitter_blocks]
    
    def get_direction_delta(d):
        if d == 'NE': return (-1, 1)
        if d == 'NW': return (-1, -1)
        if d == 'SW': return (1, -1)
        if d == 'SE': return (1, 1)
        return (0, 0)

    def reflect_vertically(d):
        if d == 'NE': return 'SE'
        if d == 'SE': return 'NE'
        if d == 'NW': return 'SW'
        if d == 'SW': return 'NW'
        return d

    def reflect_horizontally(d):
        if d == 'NE': return 'NW'
        if d == 'NW': return 'NE'
        if d == 'SE': return 'SW'
        if d == 'SW': return 'SE'
        return d

    def is_horizontal_obstacle(r, c):
        if c > 0 and input_grid[r][c-1] != bg:
            return True
        if c < width-1 and input_grid[r][c+1] != bg:
            return True
        return False

    def is_vertical_obstacle(r, c):
        if r > 0 and input_grid[r-1][c] != bg:
            return True
        if r < height-1 and input_grid[r+1][c] != bg:
            return True
        return False

    for i, (block, color) in enumerate(zip(emitter_blocks, emitter_colors)):
        S = len(block)
        directions = {
            1: ['NE'],
            2: ['NE', 'NW'],
            3: ['NE', 'NW', 'SW']
        }[S]
        sorted_pixels = sorted(block, key=lambda x: (x[0], x[1]))
        for idx, (r, c) in enumerate(sorted_pixels):
            if idx >= len(directions):
                break
            current_r, current_c = r, c
            current_dir = directions[idx]
            current_color = color
            while True:
                dr, dc = get_direction_delta(current_dir)
                next_r, next_c = current_r + dr, current_c + dc
                if next_r < 0 or next_r >= height or next_c < 0 or next_c >= width:
                    break
                if input_grid[next_r][next_c] == bg:
                    output_grid[next_r][next_c] = current_color
                    current_r, current_c = next_r, next_c
                else:
                    if is_horizontal_obstacle(next_r, next_c):
                        current_dir = reflect_vertically(current_dir)
                    else:
                        current_dir = reflect_horizontally(current_dir)
                    current_color = input_grid[next_r][next_c]
                    current_r, current_c = next_r, next_c
    
    return output_grid
