# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: d8b27c68
Difficulty: very hard

=== Tags ===
- Binary rule overlay
- If then color switch
- Mirror bounce
- Intersecting currents
- Threshold by area

=== Description ===
Binary Currents Mirror Bounce  Input grids feature a 10×10 to 30×30 canvas with
four distinct elements: background (color 0), walls (solid horizontal/vertical
lines of color 2 with lengths 1–3 cells), lasers (L-shaped clusters of color 3
with uncolored corners as origins), and a binary mask (non-rectangular pattern
of color 1 cells scattered across the grid). Walls never touch each other or
other elements, and lasers are always fully surrounded by background.  The
transformation applies these deterministic rules in sequence: 1. **Beam
Emission**: Each laser emits a diagonal beam from its origin, moving in the
direction the L faces (e.g., northeast for an L pointing up-right). 2. **Mirror
Bounce**: When a beam hits a wall (color 2), it reflects with mirror symmetry
(e.g., horizontal wall reverses vertical direction) and adopts the wall's color
(2). 3. **Binary Mask Constraint**: Beams can only traverse color 1 cells. If a
beam would move into a non-color 1 cell (excluding walls), it stops at the
previous cell. 4. **Intersecting Currents**: When two beams occupy the same cell
(not a wall), their current colors swap immediately, and beams continue moving
in their original directions. 5. **Threshold Switch**: After all beams are
processed, if the number of cells covered by beams exceeds 50% of the grid area,
all beams switch to color 4.  The output grid preserves walls (color 2) and
lasers (color 3) unchanged. Beams are drawn on valid color 1 cells (or their
last valid position) with their final colors, while all other cells revert to
background (color 0) or retain their binary mask (color 1) status. The
transformation requires tracking multiple beam paths, color swaps at
intersections, wall reflections, and global threshold effects—creating a complex
interplay of spatial and color-based rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Generator for ARC task: Binary Currents Mirror Bounce
# Produces input and output grids following the specification.

def generate():
    size = random.randint(10, 30)
    ingrid = grid(size, size, 0)

    # Helper: check 8-neighborhood for any non-zero cells (excluding an allowed set)
    def any_nonzero_neighbors(r, c, allowed=set()):
        for dr in (-1, 0, 1):
            for dc in (-1, 0, 1):
                nr, nc = r + dr, c + dc
                if nr < 0 or nr >= size or nc < 0 or nc >= size:
                    continue
                if (nr, nc) in allowed:
                    continue
                if ingrid[nr][nc] != 0:
                    return True
        return False

    # Place walls (color 2). They don't touch each other or other elements.
    n_walls = random.randint(3, 5)
    placed = 0
    attempts = 0
    while placed < n_walls and attempts < 1000:
        attempts += 1
        horiz = random.choice([True, False])
        length = random.randint(1, 3)
        if horiz:
            r = random.randint(0, size - 1)
            c = random.randint(0, size - length)
            coords = [(r, c + i) for i in range(length)]
        else:
            r = random.randint(0, size - length)
            c = random.randint(0, size - 1)
            coords = [(r + i, c) for i in range(length)]
        # cells must be free and no neighbor (8-neigh) may be occupied
        ok = True
        for (rr, cc) in coords:
            if ingrid[rr][cc] != 0:
                ok = False
                break
            # no other element adjacent (to avoid touching)
            if any_nonzero_neighbors(rr, cc, allowed=set(coords)):
                ok = False
                break
        if not ok:
            continue
        for (rr, cc) in coords:
            ingrid[rr][cc] = 2
        placed += 1

    # Place lasers (color 3) as L-shaped clusters of three 3's around an empty origin.
    # Laser orientation directions (dr, dc) indicate beam emission direction.
    directions = [(-1, 1), (1, 1), (1, -1), (-1, -1)]
    lasers = []  # list of tuples: (origin_tuple, (dr,dc))
    n_lasers = random.randint(2, 4)
    attempts = 0
    while len(lasers) < n_lasers and attempts < 2000:
        attempts += 1
        dr, dc = random.choice(directions)
        # choose an origin not on the boundary so that the three 3-cells fit
        r = random.randint(1, size - 2)
        c = random.randint(1, size - 2)
        origin = (r, c)
        # three cells lie "behind" the origin relative to beam direction
        cells = [(r - dr, c), (r, c - dc), (r - dr, c - dc)]
        ok = True
        for (rr, cc) in cells:
            if rr < 0 or rr >= size or cc < 0 or cc >= size:
                ok = False
                break
            if ingrid[rr][cc] != 0:
                ok = False
                break
        if not ok:
            continue
        if ingrid[r][c] != 0:
            continue
        # ensure the 3-cells are surrounded by background (no other non-zero in their 8-neighborhood
        # except each other).
        for (rr, cc) in cells:
            for drn in (-1, 0, 1):
                for dcn in (-1, 0, 1):
                    nr, nc = rr + drn, cc + dcn
                    if nr < 0 or nr >= size or nc < 0 or nc >= size:
                        continue
                    if (nr, nc) in cells:
                        continue
                    if ingrid[nr][nc] != 0:
                        ok = False
                        break
                if not ok:
                    break
            if not ok:
                break
        if not ok:
            continue
        # commit laser (three 3's)
        for (rr, cc) in cells:
            ingrid[rr][cc] = 3
        lasers.append((origin, (dr, dc)))

    # Place binary mask (color 1) scattered across the grid.
    # Mask cells should not touch walls or lasers (to keep lasers fully surrounded by background).
    p = random.uniform(0.22, 0.38)
    for r in range(size):
        for c in range(size):
            if ingrid[r][c] != 0:
                continue
            # if this cell is adjacent to a wall or laser, skip
            adjacent_to_wall_or_laser = False
            for drn in (-1, 0, 1):
                for dcn in (-1, 0, 1):
                    nr, nc = r + drn, c + dcn
                    if nr < 0 or nr >= size or nc < 0 or nc >= size:
                        continue
                    if ingrid[nr][nc] in (2, 3):
                        adjacent_to_wall_or_laser = True
                        break
                if adjacent_to_wall_or_laser:
                    break
            if adjacent_to_wall_or_laser:
                continue
            if random.random() < p:
                ingrid[r][c] = 1

    # Guarantee at least one beam will actually move by forcing the first step of one laser
    # into a mask cell if none already can move.
    can_move = False
    for origin, (dr, dc) in lasers:
        r, c = origin
        nr, nc = r + dr, c + dc
        if 0 <= nr < size and 0 <= nc < size and ingrid[nr][nc] == 1:
            can_move = True
            break
    if not can_move and lasers:
        # attempt to force one laser's first-step cell to be 1 (if it's safe)
        random.shuffle(lasers)
        for origin, (dr, dc) in lasers:
            r, c = origin
            nr, nc = r + dr, c + dc
            if not (0 <= nr < size and 0 <= nc < size):
                continue
            # ensure this modification doesn't place a 1 adjacent to a laser or wall
            safe = True
            for drn in (-1, 0, 1):
                for dcn in (-1, 0, 1):
                    rr, cc = nr + drn, nc + dcn
                    if rr < 0 or rr >= size or cc < 0 or cc >= size:
                        continue
                    if ingrid[rr][cc] in (2, 3):
                        safe = False
                        break
                if not safe:
                    break
            if safe:
                ingrid[nr][nc] = 1
                can_move = True
                break

    # Simulation shared by generator and solver: returns an output grid computed from input.
    def simulate(grid_in):
        # find lasers (origins) again deterministically and set up beams
        beams = []
        size_local = len(grid_in)
        for r in range(size_local):
            for c in range(size_local):
                if grid_in[r][c] != 0:
                    continue
                # check for the 3-cells behind this origin
                for (dr, dc) in directions:
                    cells = [(r - dr, c), (r, c - dc), (r - dr, c - dc)]
                    ok = True
                    for (rr, cc) in cells:
                        if rr < 0 or rr >= size_local or cc < 0 or cc >= size_local or grid_in[rr][cc] != 3:
                            ok = False
                            break
                    if ok:
                        beams.append({
                            'id': len(beams),
                            'origin': (r, c),
                            'pos': (r, c),
                            'dir': (dr, dc),
                            'color': 3,
                            'active': True,
                            'visited': []
                        })
                        break
        # time-stepped synchronous beam simulation
        visited_map = {}  # (r,c) -> (time, beam_id)
        time = 0
        max_steps = size_local * size_local * 4
        active_count = sum(1 for b in beams if b['active'])
        while active_count > 0 and time < max_steps:
            time += 1
            tentative = {}      # beam_id -> (nr,nc,new_dr,new_dc,new_color)
            cell_to_beams = {}  # (nr,nc) -> [beam_id,...]
            # propose moves
            for b in beams:
                if not b['active']:
                    continue
                r, c = b['pos']
                dr, dc = b['dir']
                nr, nc = r + dr, c + dc
                # out of bounds -> stop
                if not (0 <= nr < size_local and 0 <= nc < size_local):
                    b['active'] = False
                    active_count -= 1
                    continue
                # reflect if hitting wall(s)
                attempts_reflect = 0
                new_dr, new_dc = dr, dc
                new_color = b['color']
                # while candidate is a wall at nr,nc reflect accordingly
                while 0 <= nr < size_local and 0 <= nc < size_local and grid_in[nr][nc] == 2 and attempts_reflect < 4:
                    # detect wall orientation at the cell we would enter
                    horiz = False
                    vert = False
                    if nc - 1 >= 0 and grid_in[nr][nc - 1] == 2:
                        horiz = True
                    if nc + 1 < size_local and grid_in[nr][nc + 1] == 2:
                        horiz = True
                    if nr - 1 >= 0 and grid_in[nr - 1][nc] == 2:
                        vert = True
                    if nr + 1 < size_local and grid_in[nr + 1][nc] == 2:
                        vert = True
                    if horiz and not vert:
                        # horizontal wall: reverse vertical component
                        new_dr = -new_dr
                    elif vert and not horiz:
                        # vertical wall: reverse horizontal component
                        new_dc = -new_dc
                    else:
                        # isolated or corner: reverse both
                        new_dr = -new_dr
                        new_dc = -new_dc
                    new_color = 2
                    nr, nc = r + new_dr, c + new_dc
                    attempts_reflect += 1
                    if not (0 <= nr < size_local and 0 <= nc < size_local):
                        break
                if not (0 <= nr < size_local and 0 <= nc < size_local):
                    b['active'] = False
                    active_count -= 1
                    b['dir'] = (new_dr, new_dc)
                    b['color'] = new_color
                    continue
                # if next cell is mask (1) then move there
                if grid_in[nr][nc] == 1:
                    tentative[b['id']] = (nr, nc, new_dr, new_dc, new_color)
                    cell_to_beams.setdefault((nr, nc), []).append(b['id'])
                else:
                    # stop if next is background or laser (3) or other non-1 (excluding walls)
                    b['active'] = False
                    active_count -= 1
                    b['dir'] = (new_dr, new_dc)
                    b['color'] = new_color
                    continue
            # apply reflections/colors and handle intersections (swap colors among beams that land on same cell)
            # first assign tentative direction/color
            for bid, (nr, nc, ndx, ndy, ncolor) in tentative.items():
                beams[bid]['dir'] = (ndx, ndy)
                beams[bid]['color'] = ncolor
            # swap among beams that land on same cell
            for pos, bids in cell_to_beams.items():
                if len(bids) > 1:
                    # record colors then rotate them to swap
                    cols = [beams[bid]['color'] for bid in bids]
                    # rotate by one to the right to swap deterministically
                    cols = [cols[-1]] + cols[:-1]
                    for i, bid in enumerate(bids):
                        beams[bid]['color'] = cols[i]
            # finalize moves and record visitation time
            for bid, (nr, nc, ndx, ndy, ncolor) in tentative.items():
                beams[bid]['pos'] = (nr, nc)
                # record last-visit time and beam id for tie-breaking
                visited_map[(nr, nc)] = (time, bid)
                beams[bid]['visited'].append((time, nr, nc))
        # Gather visited cells per beam (if a beam never visited any mask cell, its last valid position is its origin)
        per_beam_cells = {}
        covered = set()
        for b in beams:
            if b['visited']:
                coords = [(r, c) for (_t, r, c) in b['visited']]
                per_beam_cells[b['id']] = coords
                covered.update(coords)
            else:
                # put origin as last valid position
                per_beam_cells[b['id']] = [b['origin']]
                covered.add(b['origin'])
        total_cells = size_local * size_local
        # Threshold switch
        if len(covered) > total_cells * 0.5:
            for b in beams:
                b['color'] = 4
        # Build output (preserve walls=2 and lasers=3; keep mask=1 except where beams paint)
        out = [[0 for _ in range(size_local)] for _ in range(size_local)]
        for r in range(size_local):
            for c in range(size_local):
                if grid_in[r][c] == 2:
                    out[r][c] = 2
                elif grid_in[r][c] == 3:
                    out[r][c] = 3
                elif grid_in[r][c] == 1:
                    out[r][c] = 1
                else:
                    out[r][c] = 0
        # Apply beam colors using per_beam_cells. If multiple beams touched a cell at different times, visited_map contains
        # the last visitor (time, beam_id), so we pick that beam's final color. For cells only in per_beam_cells for beams that
        # never visited mask cells (origins), those origins will be colored with that beam's final color.
        # First compute final color per beam (after possible threshold override above).
        final_color = {b['id']: b['color'] for b in beams}
        # For each cell that was visited, choose the beam responsible by last-visit tie-breaker
        # visited_map holds (time, beam_id) for mask-cell visits; for origin-only beams, per_beam_cells includes origin.
        for b in beams:
            bid = b['id']
            for (r, c) in per_beam_cells[bid]:
                # prefer last-visit info if present
                if (r, c) in visited_map:
                    # only color the cell if this beam is the last visitor in visited_map
                    _t, last_bid = visited_map[(r, c)]
                    if last_bid != bid:
                        # another beam visited later; skip coloring here
                        continue
                # do not overwrite lasers or walls
                if out[r][c] in (2, 3):
                    continue
                out[r][c] = final_color[bid]
        return out

    out = simulate(ingrid)

    # If output is identical to input (very unlikely), try a few times to force some mask changes so the beams will alter the grid.
    retries = 0
    while out == ingrid and retries < 5:
        retries += 1
        # force a mask cell near a random laser
        if lasers:
            origin, (dr, dc) = random.choice(lasers)
            r, c = origin
            nr, nc = r + dr, c + dc
            if 0 <= nr < size and 0 <= nc < size and ingrid[nr][nc] == 0:
                ingrid[nr][nc] = 1
        out = simulate(ingrid)

    return {"input": ingrid, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert tuple-of-tuples input to a mutable list-of-lists
    grid_in = [list(row) for row in input_grid]
    size = len(grid_in)

    # Directions used to detect lasers
    directions = [(-1, 1), (1, 1), (1, -1), (-1, -1)]

    # Locate lasers and set up beams
    beams = []
    for r in range(size):
        for c in range(size):
            if grid_in[r][c] != 0:
                continue
            for (dr, dc) in directions:
                cells = [(r - dr, c), (r, c - dc), (r - dr, c - dc)]
                ok = True
                for (rr, cc) in cells:
                    if rr < 0 or rr >= size or cc < 0 or cc >= size or grid_in[rr][cc] != 3:
                        ok = False
                        break
                if ok:
                    beams.append({
                        'id': len(beams),
                        'origin': (r, c),
                        'pos': (r, c),
                        'dir': (dr, dc),
                        'color': 3,
                        'active': True,
                        'visited': []
                    })
                    break

    # Time-stepped synchronous simulation (same logic as generator)
    visited_map = {}
    time = 0
    max_steps = size * size * 4
    active_count = sum(1 for b in beams if b['active'])
    while active_count > 0 and time < max_steps:
        time += 1
        tentative = {}
        cell_to_beams = {}
        for b in beams:
            if not b['active']:
                continue
            r, c = b['pos']
            dr, dc = b['dir']
            nr, nc = r + dr, c + dc
            if not (0 <= nr < size and 0 <= nc < size):
                b['active'] = False
                active_count -= 1
                continue
            attempts_reflect = 0
            new_dr, new_dc = dr, dc
            new_color = b['color']
            while 0 <= nr < size and 0 <= nc < size and grid_in[nr][nc] == 2 and attempts_reflect < 4:
                horiz = False
                vert = False
                if nc - 1 >= 0 and grid_in[nr][nc - 1] == 2:
                    horiz = True
                if nc + 1 < size and grid_in[nr][nc + 1] == 2:
                    horiz = True
                if nr - 1 >= 0 and grid_in[nr - 1][nc] == 2:
                    vert = True
                if nr + 1 < size and grid_in[nr + 1][nc] == 2:
                    vert = True
                if horiz and not vert:
                    new_dr = -new_dr
                elif vert and not horiz:
                    new_dc = -new_dc
                else:
                    new_dr = -new_dr
                    new_dc = -new_dc
                new_color = 2
                nr, nc = r + new_dr, c + new_dc
                attempts_reflect += 1
                if not (0 <= nr < size and 0 <= nc < size):
                    break
            if not (0 <= nr < size and 0 <= nc < size):
                b['active'] = False
                active_count -= 1
                b['dir'] = (new_dr, new_dc)
                b['color'] = new_color
                continue
            if grid_in[nr][nc] == 1:
                tentative[b['id']] = (nr, nc, new_dr, new_dc, new_color)
                cell_to_beams.setdefault((nr, nc), []).append(b['id'])
            else:
                b['active'] = False
                active_count -= 1
                b['dir'] = (new_dr, new_dc)
                b['color'] = new_color
                continue
        for bid, (nr, nc, ndx, ndy, ncolor) in tentative.items():
            beams[bid]['dir'] = (ndx, ndy)
            beams[bid]['color'] = ncolor
        for pos, bids in cell_to_beams.items():
            if len(bids) > 1:
                cols = [beams[bid]['color'] for bid in bids]
                cols = [cols[-1]] + cols[:-1]
                for i, bid in enumerate(bids):
                    beams[bid]['color'] = cols[i]
        for bid, (nr, nc, ndx, ndy, ncolor) in tentative.items():
            beams[bid]['pos'] = (nr, nc)
            visited_map[(nr, nc)] = (time, bid)
            beams[bid]['visited'].append((time, nr, nc))

    # after simulation gather per-beam visited cells
    per_beam_cells = {}
    covered = set()
    for b in beams:
        if b['visited']:
            coords = [(r, c) for (_t, r, c) in b['visited']]
            per_beam_cells[b['id']] = coords
            covered.update(coords)
        else:
            per_beam_cells[b['id']] = [b['origin']]
            covered.add(b['origin'])
    total_cells = size * size
    if len(covered) > total_cells * 0.5:
        for b in beams:
            b['color'] = 4
    final_color = {b['id']: b['color'] for b in beams}

    # Build output grid: preserve walls and lasers; keep mask cells unless painted by beams
    out = [[0 for _ in range(size)] for _ in range(size)]
    for r in range(size):
        for c in range(size):
            if grid_in[r][c] == 2:
                out[r][c] = 2
            elif grid_in[r][c] == 3:
                out[r][c] = 3
            elif grid_in[r][c] == 1:
                out[r][c] = 1
            else:
                out[r][c] = 0
    # Apply beam painting, using visited_map tie-breaking where applicable
    for b in beams:
        bid = b['id']
        for (r, c) in per_beam_cells[bid]:
            if (r, c) in visited_map:
                _t, last_bid = visited_map[(r, c)]
                if last_bid != bid:
                    continue
            if out[r][c] in (2, 3):
                continue
            out[r][c] = final_color[bid]

    return out

