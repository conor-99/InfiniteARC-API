# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 71ea86ea
Difficulty: very hard

=== Tags ===
- Gravity with barriers

=== Description ===
Input grids consist of a 2D canvas with a uniform background color, continuous
barrier structures formed by a single distinct color (visually distinct from
background), and multiple mobile elements represented by other colors. Barriers
form irregular walls of varying orientationsâ€”some vertical (running top-to-
bottom), some horizontal (left-to-right), and some diagonal segments. Mobile
elements are subject to downward gravity (southward movement) but interact with
barriers according to their local geometry: upon collision with a barrier, an
element bounces in the direction perpendicular to the barrier's orientation at
the point of contact. Vertical barriers cause horizontal bounces (left/right),
horizontal barriers cause vertical bounces (up/down), and diagonal barriers
cause directional bounces aligned with the diagonal's slope. The output grid
displays the complete, continuous paths of all mobile elements as they traverse
the grid, bouncing off barriers according to these rules, while preserving the
original barrier structures and background. Paths are drawn using the mobile
elements' original colors without overwriting barriers or background. The task
requires simultaneous analysis of barrier geometry, directional change logic,
and path tracing across multiple elements, with no loops or self-intersections
in the final paths.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(15, 30)
    height = random.randint(15, 30)
    input_grid = grid(width, height, 0)
    
    # Add vertical barriers
    for _ in range(random.randint(2, 4)):
        col = random.randint(0, width-1)
        start = random.randint(0, height-3)
        for r in range(start, start+random.randint(1, 3)):
            input_grid[r][col] = 1
    
    # Add horizontal barriers
    for _ in range(random.randint(2, 4)):
        row = random.randint(0, height-1)
        start = random.randint(0, width-3)
        for c in range(start, start+random.randint(1, 3)):
            input_grid[row][c] = 1
    
    # Add diagonal barriers (/ and \)
    for _ in range(random.randint(1, 2)):
        r = random.randint(0, height-3)
        c = random.randint(0, width-3)
        for i in range(3):
            if 0 <= r+i < height and 0 <= c+i < width:
                input_grid[r+i][c+i] = 1
    for _ in range(random.randint(1, 2)):
        r = random.randint(0, height-3)
        c = random.randint(2, width-1)
        for i in range(3):
            if 0 <= r+i < height and 0 <= c-i < width:
                input_grid[r+i][c-i] = 1
    
    # Place mobile elements (colors 2-9) at top
    mobile_colors = [2, 3, 4]
    mobile_positions = []
    for color in mobile_colors:
        for c in range(width):
            if input_grid[0][c] == 0 and (height > 1 and input_grid[1][c] == 0):
                input_grid[0][c] = color
                mobile_positions.append((0, c, color))
                break
    
    # Create output grid as copy of input
    output_grid = [row[:] for row in input_grid]
    
    # Simulate paths for each mobile
    for r, c, color in mobile_positions:
        path = []
        cr, cc = r, c
        direction = (1, 0)  # down
        steps = 0
        max_steps = 1000
        while 0 <= cr < height and 0 <= cc < width and steps < max_steps:
            steps += 1
            path.append((cr, cc))
            nr, nc = cr + direction[0], cc + direction[1]
            if not (0 <= nr < height and 0 <= nc < width):
                break
            if input_grid[nr][nc] == 1:
                # Determine barrier orientation
                vertical = (cr > 0 and input_grid[cr-1][cc] == 1) and (cr < height-1 and input_grid[cr+1][cc] == 1)
                horizontal = (cc > 0 and input_grid[cr][cc-1] == 1) and (cc < width-1 and input_grid[cr][cc+1] == 1)
                slash = (cr > 0 and cc > 0 and input_grid[cr-1][cc-1] == 1) and (cr < height-1 and cc < width-1 and input_grid[cr+1][cc+1] == 1)
                backslash = (cr > 0 and cc < width-1 and input_grid[cr-1][cc+1] == 1) and (cr < height-1 and cc > 0 and input_grid[cr+1][cc-1] == 1)
                
                if vertical:
                    direction = (0, -1)
                elif horizontal:
                    direction = (-1, 0)
                elif slash:
                    direction = (0, 1)
                elif backslash:
                    direction = (0, -1)
                else:
                    direction = (0, -1)
                
                nr, nc = cr + direction[0], cc + direction[1]
            else:
                cr, cc = nr, nc
        
        # Draw path
        for pr, pc in path:
            if input_grid[pr][pc] != 1:
                output_grid[pr][pc] = color
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    mobiles = []
    
    for r in range(height):
        for c in range(width):
            color = grid[r][c]
            if 2 <= color <= 9:
                mobiles.append((r, c, color))
    
    for r, c, color in mobiles:
        path = []
        cr, cc = r, c
        direction = (1, 0)
        steps = 0
        max_steps = 1000
        
        while 0 <= cr < height and 0 <= cc < width and steps < max_steps:
            steps += 1
            path.append((cr, cc))
            nr, nc = cr + direction[0], cc + direction[1]
            if not (0 <= nr < height and 0 <= nc < width):
                break
            
            if grid[nr][nc] == 1:
                vertical = (cr > 0 and grid[cr-1][cc] == 1) and (cr < height-1 and grid[cr+1][cc] == 1)
                horizontal = (cc > 0 and grid[cr][cc-1] == 1) and (cc < width-1 and grid[cr][cc+1] == 1)
                slash = (cr > 0 and cc > 0 and grid[cr-1][cc-1] == 1) and (cr < height-1 and cc < width-1 and grid[cr+1][cc+1] == 1)
                backslash = (cr > 0 and cc < width-1 and grid[cr-1][cc+1] == 1) and (cr < height-1 and cc > 0 and grid[cr+1][cc-1] == 1)
                
                if vertical:
                    direction = (0, -1)
                elif horizontal:
                    direction = (-1, 0)
                elif slash:
                    direction = (0, 1)
                elif backslash:
                    direction = (0, -1)
                else:
                    direction = (0, -1)
                
                nr, nc = cr + direction[0], cc + direction[1]
            else:
                cr, cc = nr, nc
        
        for pr, pc in path:
            if grid[pr][pc] != 1:
                grid[pr][pc] = color
    
    return grid
