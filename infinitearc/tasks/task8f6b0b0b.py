# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 8f6b0b0b
Difficulty: hard

=== Tags ===
- Momentum transfer
- Follow color path to destination
- Snap objects to gridlines
- Associate color to bools

=== Description ===
**Momentum-Driven Path Tracing**    Input grids feature a 2D grid of colors
(0–9) arranged in a maze-like structure. Each color is associated with a boolean
state: odd-numbered colors (1, 3, 5, 7, 9) represent *True* (active path
segments), while even-numbered colors (2, 4, 6, 8) represent *False* (inactive
or blocked segments). The grid contains a single starting cell (color 1, *True*)
and a destination cell (color 9, *True*), both located within a contiguous
*True* path.    The transformation involves tracing a continuous orthogonal path
from start to destination, following *only* active segments (*True* colors).
Each active cell's color encodes a direction:   - **Color 1** → *Right*   -
**Color 3** → *Up*   - **Color 5** → *Left*   - **Color 7** → *Down*   - **Color
9** → *Destination (no movement)*    The path "snaps" to gridlines, meaning
movement occurs only horizontally or vertically between adjacent cells. The
direction of movement is determined *exclusively* by the current cell's color,
with no diagonal motion. The path must avoid *False* segments (even colors) and
continue sequentially until reaching the destination.    The output grid
highlights the traced path with a new color (e.g., **color 8**), while all other
cells retain their input values. The transformation requires:   1. Identifying
the *True* path starting from color 1.   2. Following direction-encoded
movements step-by-step.   3. Ensuring the path aligns strictly with gridlines
(no diagonal steps).   4. Ending precisely at the destination (color 9).    This
task demands combinatorial reasoning to resolve ambiguous paths, directional
consistency, and strict adherence to grid-aligned movement, making it
challenging for hard-difficulty ARC tasks.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    # Choose a moderate random grid size to keep generation fast but varied
    width = common.randint(3, 12)
    height = common.randint(3, 12)

    # Prepare an empty grid filled with a default even (False) color
    evens = [0, 2, 4, 6]
    grid_input = common.grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            grid_input[r][c] = common.choice(evens)

    # Pick a start position such that there is space to move right for the required color-1 start
    sr = common.randint(0, height - 1)
    sc = common.randint(0, width - 2)  # ensure c+1 exists for the initial right move
    start = (sr, sc)
    second = (sr, sc + 1)

    path = [start, second]
    visited = {start, second}

    # After the mandatory initial right move, allow only up, down, left (no further right moves)
    moves = [(-1, 0), (1, 0), (0, -1)]

    # Decide a target length for the path (at least 2 cells). Cap length to avoid very long walks.
    max_target = min(width * height, 20)
    target_len = common.randint(2, max_target)

    # Grow a self-avoiding walk without right moves beyond the first step
    current = second
    for _ in range(target_len - 2):
        r, c = current
        neighbors = []
        for dr, dc in moves:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in visited:
                neighbors.append((nr, nc))
        if not neighbors:
            break
        nxt = common.choice(neighbors)
        path.append(nxt)
        visited.add(nxt)
        current = nxt

    # Optionally extend a little more for variety
    extra = common.randint(0, 4)
    for _ in range(extra):
        r, c = current
        neighbors = []
        for dr, dc in moves:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in visited:
                neighbors.append((nr, nc))
        if not neighbors:
            break
        nxt = common.choice(neighbors)
        path.append(nxt)
        visited.add(nxt)
        current = nxt

    # Ensure there is at least a start and a destination
    if len(path) < 2:
        # Fallback: make a trivial two-cell horizontal path
        start = (0, 0)
        second = (0, 1)
        path = [start, second]
        visited = {start, second}

    # Assign colors to path cells according to the direction encoding
    # 1 -> Right, 3 -> Up, 5 -> Left, 7 -> Down, 9 -> Destination
    for i in range(len(path) - 1):
        r, c = path[i]
        nr, nc = path[i + 1]
        dr, dc = nr - r, nc - c
        if (dr, dc) == (0, 1):
            color = 1
        elif (dr, dc) == (-1, 0):
            color = 3
        elif (dr, dc) == (0, -1):
            color = 5
        elif (dr, dc) == (1, 0):
            color = 7
        else:
            color = 1
        grid_input[r][c] = color

    # Destination cell
    dr, dc = path[-1]
    grid_input[dr][dc] = 9

    # Make sure no other cell accidentally has color 1 or 9 from our even fill
    # (we used only evens for background so this is already satisfied)

    # Create output: highlight the traced path with color 8, leave others unchanged
    grid_output = [row[:] for row in grid_input]
    for (r, c) in path:
        grid_output[r][c] = 8

    return {"input": grid_input, "output": grid_output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input (tuple-of-tuples) to a mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # Collect all 'True' (odd) cells
    nodes = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] in (1, 3, 5, 7, 9):
                nodes.append((r, c))

    if not nodes:
        return [row[:] for row in grid]

    # Direction map for odd colors (except 9)
    dir_map = {1: (0, 1), 3: (-1, 0), 5: (0, -1), 7: (1, 0)}

    # Build successor mapping for each odd cell
    succ = {}
    for (r, c) in nodes:
        color = grid[r][c]
        if color == 9:
            succ[(r, c)] = None
        else:
            dr, dc = dir_map.get(color, (0, 0))
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width:
                succ[(r, c)] = (nr, nc)
            else:
                succ[(r, c)] = None

    # Compute in-degrees among odd nodes
    indeg = {n: 0 for n in nodes}
    for a, b in succ.items():
        if b in indeg:
            indeg[b] += 1

    # The start should be the odd cell with in-degree 0 (and not the destination)
    start = None
    for n in nodes:
        if indeg.get(n, 0) == 0 and grid[n[0]][n[1]] != 9:
            start = n
            break

    # Fallback: look explicitly for color 1 if no in-degree-zero node found
    if start is None:
        for r in range(height):
            for c in range(width):
                if grid[r][c] == 1:
                    start = (r, c)
                    break
            if start:
                break

    if start is None:
        # nothing to do
        return [row[:] for row in grid]

    # Walk the path following successors until we reach the destination (9) or a loop
    path = []
    cur = start
    visited = set()
    while cur is not None and cur not in visited:
        visited.add(cur)
        path.append(cur)
        r, c = cur
        if grid[r][c] == 9:
            break
        cur = succ.get(cur, None)

    # Mark the traced path with color 8
    output = [row[:] for row in grid]
    for (r, c) in path:
        output[r][c] = 8

    return output

