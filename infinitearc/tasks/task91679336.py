# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 91679336
Difficulty: insane

=== Tags ===
- Shape extrusion
- Loopless path
- Implicit topology
- Variable binding by color
- Hole punch pattern

=== Description ===
Input grids feature a background of 0 surrounded by multiple disconnected,
contiguous colored regions (each region a single color from 1–8, representing
eight distinct directional vectors: 1=up, 2=right, 3=down, 4=left, 5=up-right,
6=down-right, 7=down-left, 8=up-left). Each color defines both a direction and
an extrusion length equal to its numeric value. The extrusion begins from the
outermost edge of a shape aligned with its direction (e.g., a shape with color 3
(down) extrudes downward from its bottommost row). Extrusions are drawn as
straight lines of the same color, extending precisely the assigned length over
background cells only—stopping immediately if they encounter non-background
cells (including other shapes or extrusions). After all extrusions are placed,
any cell where two or more extruded paths from different colors intersect is
converted to background (0), creating a "hole punch" pattern. The transformation
requires recognizing color-direction bindings, calculating directional extrusion
paths without overlap, and identifying topological intersections to generate the
output. The complexity arises from the need to simultaneously track multiple
extrusion paths across a dense grid, resolve overlapping directions, and apply
implicit topological rules to produce the hole pattern.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def _make_region(base, occupied, height, width, color, size, max_attempts=50):
    # Try to place a contiguous region of given size on free cells
    attempts = 0
    while attempts < max_attempts:
        attempts += 1
        # choose a random free seed
        free_cells = [(r, c) for r in range(height) for c in range(width) if not occupied[r][c]]
        if not free_cells:
            return None
        seed = random.choice(free_cells)
        pixels = [seed]
        occupied[seed[0]][seed[1]] = True
        # Grow region by adding adjacent free neighbors until size reached or stuck
        for _ in range(size - 1):
            candidates = []
            for (r, c) in pixels:
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = r + dr, c + dc
                    if nr < 0 or nr >= height or nc < 0 or nc >= width:
                        continue
                    if occupied[nr][nc]:
                        continue
                    if (nr, nc) in candidates:
                        continue
                    candidates.append((nr, nc))
            if not candidates:
                break
            newp = random.choice(candidates)
            pixels.append(newp)
            occupied[newp[0]][newp[1]] = True
        # Accept region if at least one cell (always true) -- return the region
        return pixels
    return None


def generate():
    # Generate until a non-trivial extrusion is possible
    for _ in range(200):
        width = random.randint(6, 20)
        height = random.randint(6, 20)
        base = grid(width, height, 0)
        occupied = [[False] * width for _ in range(height)]

        num_regions = random.randint(2, min(6, 8))
        colors = random.sample(list(range(1, 9)), num_regions)
        placed = []
        for color in colors:
            size = random.randint(2, 7)
            pixels = _make_region(base, occupied, height, width, color, size)
            if not pixels:
                continue
            # paint region
            for (r, c) in pixels:
                base[r][c] = color
            placed.append((color, pixels))

        # If we didn't place at least two regions, restart
        if len(placed) < 2:
            continue

        # Compute connected components in the final base grid (scanning order)
        visited = [[False] * width for _ in range(height)]
        regions = []
        for r in range(height):
            for c in range(width):
                if not visited[r][c] and 1 <= base[r][c] <= 8:
                    color = base[r][c]
                    stack = [(r, c)]
                    visited[r][c] = True
                    pixels = []
                    while stack:
                        cr, cc = stack.pop()
                        pixels.append((cr, cc))
                        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and base[nr][nc] == color:
                                visited[nr][nc] = True
                                stack.append((nr, nc))
                    regions.append((color, pixels))

        # Prepare extrusion tracking
        extruded = [[0] * width for _ in range(height)]
        collision = [[False] * width for _ in range(height)]

        # direction mapping: color -> (dr, dc)
        dir_map = {
            1: (-1, 0),  # up
            2: (0, 1),   # right
            3: (1, 0),   # down
            4: (0, -1),  # left
            5: (-1, 1),  # up-right
            6: (1, 1),   # down-right
            7: (1, -1),  # down-left
            8: (-1, -1), # up-left
        }

        # Process regions in scanning order (regions list built by scanning)
        for color, pixels in regions:
            dr, dc = dir_map[color]
            # compute projection value for each pixel and pick the outermost ones
            proj = [r * dr + c * dc for (r, c) in pixels]
            maxproj = max(proj)
            starting = [(r, c) for (r, c), p in zip(pixels, proj) if p == maxproj]

            # From each starting cell, extrude up to length == color
            length = color
            for (sr, sc) in starting:
                for step in range(1, length + 1):
                    nr, nc = sr + dr * step, sc + dc * step
                    if nr < 0 or nr >= height or nc < 0 or nc >= width:
                        break
                    # stop if hit any non-background cell in the base grid
                    if base[nr][nc] != 0:
                        break
                    if extruded[nr][nc] == 0:
                        extruded[nr][nc] = color
                    else:
                        # already extruded by some earlier region
                        if extruded[nr][nc] != color:
                            collision[nr][nc] = True
                        # encountering an extruded path stops further extrusion
                        break

        # Build output: start from base, overlay extrusions, then punch holes at collisions
        output = [row[:] for row in base]
        for r in range(height):
            for c in range(width):
                if collision[r][c]:
                    output[r][c] = 0
                elif extruded[r][c] != 0:
                    output[r][c] = extruded[r][c]

        # Ensure non-trivial transformation (input != output)
        if output != base:
            return {'input': base, 'output': output}

    # Fallback: should almost never happen
    raise RuntimeError('Failed to generate a valid example')



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable grid
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Find connected components (4-neighborhood) in scanning order
    visited = [[False] * width for _ in range(height)]
    regions = []
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and 1 <= grid[r][c] <= 8:
                color = grid[r][c]
                stack = [(r, c)]
                visited[r][c] = True
                pixels = []
                while stack:
                    cr, cc = stack.pop()
                    pixels.append((cr, cc))
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                regions.append((color, pixels))

    # Prepare extrusion tracking
    extruded = [[0] * width for _ in range(height)]
    collision = [[False] * width for _ in range(height)]

    dir_map = {
        1: (-1, 0),  # up
        2: (0, 1),   # right
        3: (1, 0),   # down
        4: (0, -1),  # left
        5: (-1, 1),  # up-right
        6: (1, 1),   # down-right
        7: (1, -1),  # down-left
        8: (-1, -1), # up-left
    }

    # Process each region in scanning order and extrude
    for color, pixels in regions:
        dr, dc = dir_map[color]
        proj = [r * dr + c * dc for (r, c) in pixels]
        maxproj = max(proj)
        starting = [(r, c) for (r, c), p in zip(pixels, proj) if p == maxproj]
        length = color
        for (sr, sc) in starting:
            for step in range(1, length + 1):
                nr, nc = sr + dr * step, sc + dc * step
                if nr < 0 or nr >= height or nc < 0 or nc >= width:
                    break
                if grid[nr][nc] != 0:
                    break
                if extruded[nr][nc] == 0:
                    extruded[nr][nc] = color
                else:
                    if extruded[nr][nc] != color:
                        collision[nr][nc] = True
                    break

    # Build the output grid
    output = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if collision[r][c]:
                output[r][c] = 0
            elif extruded[r][c] != 0:
                output[r][c] = extruded[r][c]

    return tuple(tuple(row) for row in output)

