# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 22738fa0
Difficulty: medium–hard

=== Tags ===
- State machine grid
- Phase transition path
- Shape morphing
- Draw line from border
- Associate patterns to patterns

=== Description ===
Input grids feature a continuous, winding path of distinct colored regions (each
region is a contiguous block of a single color) that begins at the left edge and
traverses the grid in a non-straight path. The path is composed of multiple
segments, each adjacent to the next, forming a connected sequence. A pattern
strip, positioned horizontally at the top of the grid, contains 2×2 color blocks
separated by single background cells, representing a repeating phase transition
sequence (e.g., [red, blue, green]). The background color is uniform and
distinct from all path colors.   The output grid is generated by applying the
phase transition sequence cyclically to each segment of the path, starting from
the segment closest to the left edge. The first segment changes to the first
color in the pattern strip, the second segment to the second color, and so on,
cycling back to the start of the sequence after the strip ends. The path itself
remains visually intact (no new lines are drawn), but each segment’s color is
updated to reflect its position in the phase cycle. The pattern strip,
background, and all non-path regions remain unchanged. The transformation
requires identifying the path's direction, the cyclic phase sequence from the
strip, and applying the phase transitions sequentially to each path segment
without altering the grid's structural layout.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import random_color


def generate():
    """
    Generate a grid with:
      - a 2-row pattern strip across the top consisting of K 2x2 colored blocks separated by one background column
      - a winding, non-self-intersecting path that starts at the left edge (column 0) at row >= 2
        and is composed of S contiguous segments (each segment is a run of cells with a single color)
      - segment colors are distinct from each other, from the background, and from the pattern colors

    The output grid is the same but with each segment recolored according to the pattern strip colors
    applied cyclically starting at the segment closest to the left edge.
    """
    # Retry building until a valid non-colliding path with the requested number of segments is created
    for attempt in range(400):
        # Choose pattern length
        K = random.randint(2, 4)  # number of 2x2 blocks in the top strip
        min_width = 3 * K - 1
        width = random.randint(max(10, min_width), 20)
        height = random.randint(8, 20)

        bg = 0
        grid = [[bg for _ in range(width)] for _ in range(height)]

        # Build pattern strip (2x2 blocks separated by one background column)
        used_colors = {bg}
        pattern_colors = []
        try:
            for _ in range(K):
                col = random_color(exclude=list(used_colors))
                pattern_colors.append(col)
                used_colors.add(col)
        except Exception:
            # If random_color fails for some reason, skip this attempt
            continue

        # Paint 2x2 blocks in rows 0 and 1 at columns 0-1, 3-4, 6-7, ...
        for i, col in enumerate(pattern_colors):
            sc = i * 3
            if sc + 1 >= width:
                break
            grid[0][sc] = col
            grid[0][sc + 1] = col
            grid[1][sc] = col
            grid[1][sc + 1] = col

        # Compute max number of distinct segment colors we can select (colors 1..9 available)
        max_segments_allowed = 9 - len(pattern_colors)
        if max_segments_allowed < 3:
            # if there aren't enough colors left for a reasonable number of segments, retry
            continue

        S = random.randint(3, min(7, max_segments_allowed))

        # Path generation parameters
        min_seg_len = 1  # cells per segment (first segment includes start cell)
        max_seg_len = 6

        # Helper directions
        DIRS = [(0, 1), (1, 0), (-1, 0), (0, -1)]  # right, down, up, left

        # Start point: left edge, below the pattern (rows >= 2)
        start_row = random.randint(2, height - 1)
        start = (start_row, 0)

        # Build segments as lists of coordinates (disjoint, concatenated form the full path)
        segments = []
        visited = {start}
        cur = start
        prev_dir = None
        failed = False

        # Helper to check if a candidate cell would be adjacent to any visited cell other than the parent
        def would_touch_visited(cell, parent, visited_set):
            r, c = cell
            for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                nr, nc = r + dr, c + dc
                if (nr, nc) == parent:
                    continue
                if (nr, nc) in visited_set:
                    return True
            return False

        for seg_i in range(S):
            # try to pick a direction and length for this segment
            seg_built = False
            for try_dir_attempt in range(80):
                # choose a direction (first segment should go right to enter the grid)
                if seg_i == 0:
                    cand_dirs = [(0, 1)]  # force initial direction to the right
                else:
                    cand_dirs = DIRS[:]
                    random.shuffle(cand_dirs)
                    if prev_dir is not None:
                        # avoid immediate reversal
                        rev = (-prev_dir[0], -prev_dir[1])
                        cand_dirs = [d for d in cand_dirs if d != rev]

                random.shuffle(cand_dirs)
                for d in cand_dirs:
                    # simulate how many free cells we can move in direction d without touching visited cells
                    r0, c0 = cur
                    visited_temp = set(visited)
                    steps_possible = 0
                    step_positions = []
                    while True:
                        nr = r0 + d[0]
                        nc = c0 + d[1]
                        # must remain inside grid and not step into top two pattern rows
                        if nc < 0 or nc >= width or nr < 2 or nr >= height:
                            break
                        if (nr, nc) in visited_temp:
                            break
                        # ensure the new cell wouldn't touch any already visited cell except the cell we come from
                        if would_touch_visited((nr, nc), (r0, c0), visited_temp):
                            break
                        # accept this simulated step
                        step_positions.append((nr, nc))
                        visited_temp.add((nr, nc))
                        steps_possible += 1
                        r0, c0 = nr, nc

                    # Determine how many cells this segment should contain
                    # For the first segment we include the start cell so we need steps_needed = seg_len - 1
                    seg_len = random.randint(min_seg_len, max_seg_len)
                    steps_needed = seg_len - 1 if seg_i == 0 else seg_len

                    if steps_possible >= steps_needed and seg_len >= 1:
                        # commit the moves using the first steps_needed positions
                        new_segment = []
                        if seg_i == 0:
                            # include the current cell as first cell of the first segment
                            new_segment.append(cur)
                            to_take = seg_len - 1
                            chosen_positions = step_positions[:to_take]
                        else:
                            to_take = seg_len
                            chosen_positions = step_positions[:to_take]

                        if len(chosen_positions) != to_take:
                            # not enough steps available (shouldn't happen because of the check), try another direction
                            continue

                        ok = True
                        # final validation to be safe
                        parent = cur
                        for pos in chosen_positions:
                            if pos in visited:
                                ok = False
                                break
                            if would_touch_visited(pos, parent, visited):
                                ok = False
                                break
                            parent = pos

                        if not ok:
                            continue

                        # register visited cells and update current position
                        for cell in chosen_positions:
                            visited.add(cell)
                            new_segment.append(cell)

                        if seg_i == 0 and len(new_segment) == 1:
                            # if first segment only had the start cell, that's acceptable
                            pass

                        if not new_segment:
                            continue

                        cur = new_segment[-1]
                        segments.append(new_segment)
                        prev_dir = d
                        seg_built = True
                        break
                if seg_built:
                    break
            if not seg_built:
                failed = True
                break

        if failed:
            continue

        # Ensure we actually built exactly S segments
        if len(segments) != S:
            continue

        # Choose segment colors distinct from pattern and background and from each other
        seg_colors = []
        used = set(pattern_colors)
        used.add(bg)
        try:
            for _ in range(S):
                col = random_color(exclude=list(used))
                seg_colors.append(col)
                used.add(col)
        except Exception:
            # not enough colors, retry
            continue

        # Paint the path on the grid using segment colors
        for i, seg in enumerate(segments):
            color = seg_colors[i]
            for (r, c) in seg:
                grid[r][c] = color

        # Make output by recoloring segments according to the pattern (cyclic)
        output = [row[:] for row in grid]
        for i, seg in enumerate(segments):
            pat_color = pattern_colors[i % len(pattern_colors)]
            for (r, c) in seg:
                output[r][c] = pat_color

        # Final checks: input != output and sizes ok
        if grid == output:
            # shouldn't happen because we excluded pattern colors from segment colors
            continue

        return {"input": grid, "output": output}

    # If we couldn't make a valid instance after many tries, raise
    raise RuntimeError("Failed to generate a valid task instance")



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # Determine background color as the most frequent color in the grid
    counts = {}
    for r in range(height):
        for c in range(width):
            counts[grid[r][c]] = counts.get(grid[r][c], 0) + 1
    bg = max(counts.keys(), key=lambda k: counts[k])

    # Detect pattern colors by scanning 2x2 uniform blocks in the top two rows (exclude background)
    pattern_colors = []
    for c in range(0, width - 1):
        if grid[0][c] == grid[0][c + 1] == grid[1][c] == grid[1][c + 1] and grid[0][c] != bg:
            col = grid[0][c]
            if len(pattern_colors) == 0 or pattern_colors[-1] != col:
                pattern_colors.append(col)

    # If no pattern found (defensive), fall back to some default but this should not be needed
    if not pattern_colors:
        # take any non-bg colors from top two rows left-to-right
        seen = set()
        for r in (0, 1):
            for c in range(width):
                v = grid[r][c]
                if v != bg and v not in seen:
                    seen.add(v)
                    pattern_colors.append(v)
        if not pattern_colors:
            pattern_colors = [1, 2, 3]

    # Collect all non-background cells in rows >= 2 and get the connected component(s)
    path_cells = set()
    for r in range(2, height):
        for c in range(width):
            if grid[r][c] != bg:
                path_cells.add((r, c))

    if not path_cells:
        return tuple(tuple(row) for row in grid)

    # If there are multiple components (unlikely), pick the largest
    from collections import deque
    unvisited = set(path_cells)
    components = []
    while unvisited:
        start_cell = next(iter(unvisited))
        q = deque([start_cell])
        comp = {start_cell}
        unvisited.remove(start_cell)
        while q:
            r, c = q.popleft()
            for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                nr, nc = r + dr, c + dc
                if (nr, nc) in unvisited:
                    unvisited.remove((nr, nc))
                    comp.add((nr, nc))
                    q.append((nr, nc))
        components.append(comp)
    comp = max(components, key=lambda s: len(s))

    # Find endpoints (degree == 1 within the component)
    endpoints = []
    for (r, c) in comp:
        neigh = 0
        for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):
            if (r + dr, c + dc) in comp:
                neigh += 1
        if neigh == 1:
            endpoints.append((r, c))

    # Choose the endpoint closest to the left edge (smallest column). Tie-break by smallest row.
    if endpoints:
        start = min(endpoints, key=lambda x: (x[1], x[0]))
    else:
        # fallback: pick any cell on left edge if present otherwise any cell
        left_edge_cells = [p for p in comp if p[1] == 0]
        start = left_edge_cells[0] if left_edge_cells else next(iter(comp))

    # Walk the (non-branching) path from the chosen start to produce an ordered list of cells
    path = []
    visited_walk = set()
    cur = start
    prev = None
    while True:
        path.append(cur)
        visited_walk.add(cur)
        r, c = cur
        neighbors = []
        for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):
            nr, nc = r + dr, c + dc
            if (nr, nc) in comp:
                neighbors.append((nr, nc))
        # next neighbor that's not the previous cell
        next_cell = None
        for n in neighbors:
            if n != prev:
                next_cell = n
                break
        if next_cell is None or next_cell in visited_walk:
            break
        prev = cur
        cur = next_cell

    # Group path into segments by contiguous runs of the same color
    segments = []
    if path:
        cur_seg = [path[0]]
        for pos in path[1:]:
            r, c = pos
            pr, pc = cur_seg[-1]
            if grid[r][c] == grid[pr][pc]:
                cur_seg.append(pos)
            else:
                segments.append(cur_seg)
                cur_seg = [pos]
        segments.append(cur_seg)

    # Apply the pattern colors cyclically to segments starting from the leftmost segment
    out = [row[:] for row in grid]
    for i, seg in enumerate(segments):
        pat_color = pattern_colors[i % len(pattern_colors)]
        for (r, c) in seg:
            out[r][c] = pat_color

    return tuple(tuple(row) for row in out)

