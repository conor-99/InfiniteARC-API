# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: ce13abab
Difficulty: medium

=== Tags ===
- Associate images to images
- Cluster by color
- Reorder blocks by size
- Bridges

=== Description ===
The input grid consists of multiple contiguous clusters of different colors,
where each cluster represents a connected region of identical color values. The
transformation first merges all separate clusters of the same color into a
single contiguous region (e.g., merging two disconnected red clusters into one
larger red cluster). Next, all merged color clusters are sorted by their total
size (number of cells) in descending order. Finally, the output grid is
constructed by arranging these sorted clusters in sequence, maintaining their
original shapes while ordering them from largest to smallest, typically placed
side-by-side horizontally or stacked vertically. This process ensures that the
output grid reflects the merged color clusters reordered by size, with no input
grid matching its output. The "Bridges" tag refers to the connectivity formed
during the merging of same-color clusters, creating seamless transitions between
previously separated regions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_pixels, connected

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = grid(width, height, 0)
    
    target_color = random.randint(1, 9)
    
    while True:
        cluster1 = random_pixels(width, height, prob=0.2)
        cluster2 = random_pixels(width, height, prob=0.2)
        if not cluster1 or not cluster2:
            continue
        if not connected(cluster1 + cluster2):
            break
    
    for r, c in cluster1:
        input_grid[r][c] = target_color
    for r, c in cluster2:
        input_grid[r][c] = target_color
    
    other_colors = [c for c in range(1, 10) if c != target_color]
    for color in other_colors:
        cluster = random_pixels(width, height, prob=0.1)
        for r, c in cluster:
            input_grid[r][c] = color
    
    color_counts = {}
    for r in range(height):
        for c in range(width):
            color = input_grid[r][c]
            if color != 0:
                color_counts[color] = color_counts.get(color, 0) + 1
    
    sorted_colors = sorted(color_counts.keys(), key=lambda x: color_counts[x], reverse=True)
    
    output_grid = grid(30, 30, 0)
    idx = 0
    for color in sorted_colors:
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == color:
                    if idx < 900:
                        output_grid[idx // 30][idx % 30] = color
                        idx += 1
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    color_counts = {}
    for row in input_grid:
        for cell in row:
            if cell != 0:
                color_counts[cell] = color_counts.get(cell, 0) + 1
    
    sorted_colors = sorted(color_counts.keys(), key=lambda x: color_counts[x], reverse=True)
    
    output_grid = [[0] * 30 for _ in range(30)]
    idx = 0
    for color in sorted_colors:
        for r in range(len(input_grid)):
            for c in range(len(input_grid[0])):
                if input_grid[r][c] == color:
                    if idx < 900:
                        output_grid[idx // 30][idx % 30] = color
                        idx += 1
    
    return output_grid
