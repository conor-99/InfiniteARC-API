# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: a1ef568a
Difficulty: hard

=== Tags ===
- Diagonals
- Unfold paper crease pattern
- Connect the dots
- Infer hidden grid

=== Description ===
The input grid displays a folded paper with two intersecting diagonal creases
(represented by distinct colors, e.g., color 5 for one crease and color 6 for
the other) forming a cross at the grid's center. The visible pattern is confined
to the top-left quadrant of the grid, while the other three quadrants are hidden
due to folding. The creases divide the grid into four regions, and the visible
pattern in the top-left quadrant must be mirrored across both creases to
reconstruct the full, unfolded grid. The transformation requires identifying the
crease directions (diagonals), determining the visible region, and applying two
sequential reflections: first across the primary diagonal crease (e.g., main
diagonal), then across the secondary diagonal crease (e.g., anti-diagonal), to
fill in the hidden quadrants. The output grid reveals the complete pattern by
reflecting the visible fragment across both creases, resulting in a symmetric
grid where all four quadrants are consistent with the original unfolded design.
This task demands complex spatial reasoning to infer the reflection axes and
correctly apply multiple transformations in sequence, making it challenging to
solve without recognizing the crease-based symmetry.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    N = random.choice([3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29])
    input_grid = [[0] * N for _ in range(N)]
    for i in range(N):
        input_grid[i][i] = 5
    for i in range(N):
        input_grid[i][N-1-i] = 6
    center = N // 2
    pattern_colors = [1, 2, 3, 4, 7, 8, 9]
    placed = False
    for r in range(center):
        for c in range(center):
            if r == c:
                continue
            if random.random() > 0.3:
                input_grid[r][c] = random.choice(pattern_colors)
                placed = True
    if not placed:
        r, c = 0, 1
        if r < center and c < center and r != c:
            input_grid[r][c] = random.choice(pattern_colors)
    output_grid = [[0] * N for _ in range(N)]
    for i in range(N):
        output_grid[i][i] = 5
    for i in range(N):
        output_grid[i][N-1-i] = 6
    for r in range(center):
        for c in range(center):
            if r == c:
                continue
            if input_grid[r][c] != 0 and input_grid[r][c] not in (5, 6):
                color = input_grid[r][c]
                output_grid[r][c] = color
                output_grid[c][r] = color
                output_grid[N-1 - c][N-1 - r] = color
                output_grid[N-1 - r][N-1 - c] = color
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    N = len(input_grid)
    output_grid = [[0] * N for _ in range(N)]
    for i in range(N):
        output_grid[i][i] = 5
    for i in range(N):
        output_grid[i][N-1-i] = 6
    center = N // 2
    for r in range(center):
        for c in range(center):
            if r == c:
                continue
            if input_grid[r][c] != 0 and input_grid[r][c] not in (5, 6):
                color = input_grid[r][c]
                output_grid[r][c] = color
                output_grid[c][r] = color
                output_grid[N-1 - c][N-1 - r] = color
                output_grid[N-1 - r][N-1 - c] = color
    return output_grid
