# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 0b8df42f
Difficulty: hard

=== Tags ===
- Portal momentum pathing
- Pattern cycle
- Cave escape
- Pattern expansion
- Enlarge image

=== Description ===
The task features input grids representing a cave-like environment with walls
(background color), a starting cell (distinct color), an exit cell (another
distinct color), and portal markers (unique colors). The cave structure consists
of interconnected paths with dead ends, but only one path leads to the exit when
following the transformation rules.  In the output grid, the correct escape path
is visually rendered as a continuous line from the starting cell to the exit.
The transformation follows these deterministic rules:   1. The path begins at
the starting cell moving right.   2. Each time the path encounters a portal
cell, the direction cycles through [right → down → left → up] (repeating in
sequence).   3. The path continues in the new direction until it reaches the
exit cell, traversing all intermediate cells along the way.   4. Walls, portals,
and exit cells remain unchanged in color, while the path is drawn using a
consistent line color (e.g., the starting cell's color).    The "portal
momentum" refers to the direction change upon hitting a portal, while the
"pattern cycle" describes the fixed directional sequence. "Cave escape"
signifies the path must reach the exit without looping. "Pattern expansion"
manifests as the complete path being drawn across all traversed cells, and
"enlarge image" is reflected in the output's detailed visualization of the path
within the same grid dimensions. The input grids are complex, with multiple
portals and ambiguous paths, requiring the solver to apply the directional cycle
sequence in parallel with path tracing to identify the single valid escape
route.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Colors
    WALL = 9
    START = 1
    EXIT = 2
    FLOOR = 0
    PORTAL_POOL = [3,4,5,6,7,8]

    # Grid size
    width = random.randint(12, 22)
    height = random.randint(12, 22)

    # Direction order: right, down, left, up
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    # Try to build a non-overlapping snake-like path that stays inside margins
    for attempt in range(200):
        num_portals = random.randint(2, 5)
        # segment lengths for portals and final segment
        seg_lengths = [random.randint(2, 4) for _ in range(num_portals)]
        final_len = random.randint(2, 4)
        all_lengths = seg_lengths + [final_len]

        # try to find a start position that allows the entire path to fit
        for start_try in range(400):
            start_r = random.randint(1, height - 2)
            start_c = random.randint(1, width - 2)
            r, c = start_r, start_c
            visited = set()
            visited.add((r, c))
            ok = True
            dir_idx = 0
            positions = [(r, c)]  # sequence of positions visited (includes start)
            portal_positions = []

            for i, L in enumerate(all_lengths):
                dr, dc = directions[dir_idx]
                # step by step to ensure no overlap and stay inside margins (keep 1-cell border)
                for step in range(1, L + 1):
                    nr = r + dr * step
                    nc = c + dc * step
                    if nr < 1 or nr >= height - 1 or nc < 1 or nc >= width - 1:
                        ok = False
                        break
                    if (nr, nc) in visited:
                        ok = False
                        break
                if not ok:
                    break
                # commit steps
                for step in range(1, L + 1):
                    rr = r + dr * step
                    cc = c + dc * step
                    positions.append((rr, cc))
                    visited.add((rr, cc))
                # update r,c to end of this segment
                r += dr * L
                c += dc * L
                if i < num_portals:
                    portal_positions.append((r, c))
                    dir_idx = (dir_idx + 1) % 4
            if not ok:
                continue
            # ensure start and exit are not the same
            exit_pos = positions[-1]
            if exit_pos == (start_r, start_c):
                continue
            # Found a valid configuration
            start = (start_r, start_c)
            portals = portal_positions
            path_positions = positions
            break
        else:
            # try a different segments configuration
            continue
        break
    else:
        # fallback simple path if greedy failed
        width = max(9, width)
        height = max(9, height)
        g = grid(width, height, WALL)
        start = (height // 2, max(2, width // 4))
        # carve a simple straight path to the right and place an exit
        positions = [start]
        r, c = start
        for i in range(1, 5):
            if c + 1 < width - 1:
                c += 1
                positions.append((r, c))
        portals = []
        path_positions = positions

    # Build input grid filled with walls
    input_grid = grid(width, height, WALL)

    # carve floor along path and place portals and start/exit
    # choose portal colors
    num_portals = len(portals)
    portal_colors = random.sample(PORTAL_POOL, num_portals)

    for (r, c) in path_positions:
        # default floor
        input_grid[r][c] = FLOOR

    # place portals
    for pos, color in zip(portals, portal_colors):
        pr, pc = pos
        input_grid[pr][pc] = color

    # place start (1) and exit (2)
    sr, sc = start
    input_grid[sr][sc] = START
    er, ec = path_positions[-1]
    input_grid[er][ec] = EXIT

    # Optionally add a few decoy portal markers somewhere else (not on the main path)
    decoy_count = random.randint(0, 3)
    free_cells = [(r, c) for r in range(1, height - 1) for c in range(1, width - 1) if input_grid[r][c] == WALL]
    random.shuffle(free_cells)
    for i in range(min(decoy_count, len(free_cells))):
        r, c = free_cells[i]
        input_grid[r][c] = random.choice(PORTAL_POOL)

    # Build output grid by tracing the path from start using the portal momentum rule
    output_grid = [row[:] for row in input_grid]
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    cur_r, cur_c = sr, sc
    dir_idx = 0
    # ensure start cell is colored as START in output
    output_grid[cur_r][cur_c] = START

    # Continue until we reach exit
    while (cur_r, cur_c) != (er, ec):
        dr, dc = directions[dir_idx]
        nr = cur_r + dr
        nc = cur_c + dc
        progressed = False
        # move step by step until we hit a portal, exit, or wall
        while 0 <= nr < height and 0 <= nc < width:
            val = input_grid[nr][nc]
            if val == WALL:
                break
            if val >= 3 and val != WALL:
                # step onto the portal but do not recolor it
                cur_r, cur_c = nr, nc
                dir_idx = (dir_idx + 1) % 4
                progressed = True
                break
            if val == EXIT:
                # reached exit, do not recolor exit
                cur_r, cur_c = nr, nc
                progressed = True
                break
            # floor cell: color it with START color in the output
            output_grid[nr][nc] = START
            cur_r, cur_c = nr, nc
            nr += dr
            nc += dc
            progressed = True
        if not progressed:
            # If we couldn't move forward (shouldn't happen for valid path), abort to avoid infinite loop
            break

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid_in = [list(row) for row in input_grid]
    h = len(grid_in)
    w = len(grid_in[0]) if h > 0 else 0

    # Find colors and special cells
    start = None
    exit_pos = None
    counts = {}
    for r in range(h):
        for c in range(w):
            v = grid_in[r][c]
            counts[v] = counts.get(v, 0) + 1
            if v == 1:
                start = (r, c)
            elif v == 2:
                exit_pos = (r, c)

    if start is None or exit_pos is None:
        return grid_in

    # Heuristic: infer wall color as the most common color
    wall_color = max(counts, key=lambda k: counts[k])

    # Directions: right, down, left, up
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    dir_idx = 0

    out = [row[:] for row in grid_in]
    r, c = start
    # Ensure start remains its color
    out[r][c] = 1

    # Trace path following portals: when stepping onto a portal (color >=3 and not wall), rotate direction
    # Continue until we reach the exit
    steps_safety = 0
    while (r, c) != exit_pos and steps_safety < (h * w * 4):
        steps_safety += 1
        dr, dc = directions[dir_idx]
        nr = r + dr
        nc = c + dc
        moved = False
        # Move forward until encountering portal, exit, or wall
        while 0 <= nr < h and 0 <= nc < w:
            val = grid_in[nr][nc]
            if val == wall_color:
                break
            # portal detection: any color >=3 that isn't the wall
            if val >= 3 and val != wall_color:
                # step onto portal but don't recolor it
                r, c = nr, nc
                dir_idx = (dir_idx + 1) % 4
                moved = True
                break
            if val == 2:
                # reached exit; do not recolor the exit cell
                r, c = nr, nc
                moved = True
                break
            # floor or other non-special cell: color it as the path color (1)
            out[nr][nc] = 1
            r, c = nr, nc
            nr += dr
            nc += dc
            moved = True
        if not moved:
            # no progress possible -> stop to avoid infinite loop
            break

    return out

