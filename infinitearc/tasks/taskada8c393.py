# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: ada8c393
Difficulty: medium–hard

=== Tags ===
- Pattern to sequence mapping
- Local physics rule
- Gravity
- Pattern reflection
- Follow color path to destination

=== Description ===
The input grid features a continuous path of colored cells (1-9) traversing from
a designated start position to a destination, embedded within a uniform
background color (0). Each color along the path (excluding the start and
destination) encodes a "local gravity" vector: red (2) → downward, blue (3) →
leftward, green (4) → upward, yellow (5) → rightward. The path in the input grid
is drawn as a straight line through these gravity cells, ignoring their
directional influence. The transformation applies the gravity vectors
sequentially: at each gravity cell, the path's immediate next step is redirected
according to the vector, altering the path's trajectory. The output grid redraws
the path to follow these directional changes, resulting in a bent or reflected
path that adheres to the gravity rules. Additionally, the path's direction at
each gravity cell is reflected over an axis determined by the color (e.g., red
gravity reflects horizontally, blue vertically), creating a cascading sequence
of directional shifts. The destination remains unchanged, and all non-path
background cells retain their original colors. The task requires identifying the
gravity-color mapping, applying the directional redirection, and reflecting the
path geometry at each step to produce the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Keep a set of seen input-output signatures so we produce 100 unique pairs
SEEN = set()

# Mapping: color -> (dr, dc)
DIR_BY_COLOR = {2: (1, 0), 3: (0, -1), 4: (-1, 0), 5: (0, 1)}


def sign(x):
    if x > 0:
        return 1
    if x < 0:
        return -1
    return 0


def stringify_pair(inp, out):
    return (tuple(tuple(row) for row in inp), tuple(tuple(row) for row in out))


def generate():
    """
    Generate an input-output pair where the input contains a straight colored path
    (start color 1, destination color 9) and intermediate cells are gravity colors
    2..5. The output redraws the path by following the gravity vectors in order
    (at each gravity cell the next step direction becomes the gravity vector).
    """
    tries = 0
    while True:
        tries += 1
        if tries > 2000:
            # Fallback: clear seen and try again (shouldn't normally happen)
            SEEN.clear()
            tries = 0
        width = random.randint(6, 12)
        height = random.randint(6, 12)

        # Build empty grid
        inp = grid(width, height, 0)

        horiz = random.choice([True, False])

        # Choose start/destination along a straight line with at least one intermediate cell
        if horiz:
            r = random.randint(0, height - 1)
            left = random.randint(0, width - 3)
            right = random.randint(left + 2, width - 1)
            left_col, right_col = left, right
            # Randomize direction (left->right or right->left)
            if random.random() < 0.5:
                start = (r, left_col)
                dest = (r, right_col)
                initial_dir = (0, 1)
                initial_dir_color = 5
            else:
                start = (r, right_col)
                dest = (r, left_col)
                initial_dir = (0, -1)
                initial_dir_color = 3

            # Fill the straight line on the input with gravity colors
            for c in range(left_col, right_col + 1):
                if (r, c) == start:
                    inp[r][c] = 1
                elif (r, c) == dest:
                    inp[r][c] = 9
                else:
                    inp[r][c] = random.choice([2, 3, 4, 5])

            # Ensure at least one intermediate cell forces a turn (not equal to initial direction color)
            intermediate = [(r, c) for c in range(left_col + 1, right_col) if (r, c) != start and (r, c) != dest]
            if not intermediate:
                continue
            if all(inp[r][c] == initial_dir_color for (r, c) in intermediate):
                # pick one intermediate and change its color
                rr, cc = random.choice(intermediate)
                choices = [2, 3, 4, 5]
                choices.remove(initial_dir_color)
                inp[rr][cc] = random.choice(choices)

        else:
            c = random.randint(0, width - 1)
            top = random.randint(0, height - 3)
            bottom = random.randint(top + 2, height - 1)
            top_row, bottom_row = top, bottom
            if random.random() < 0.5:
                start = (top_row, c)
                dest = (bottom_row, c)
                initial_dir = (1, 0)
                initial_dir_color = 2
            else:
                start = (bottom_row, c)
                dest = (top_row, c)
                initial_dir = (-1, 0)
                initial_dir_color = 4

            for r0 in range(top_row, bottom_row + 1):
                if (r0, c) == start:
                    inp[r0][c] = 1
                elif (r0, c) == dest:
                    inp[r0][c] = 9
                else:
                    inp[r0][c] = random.choice([2, 3, 4, 5])

            intermediate = [(r0, c) for r0 in range(top_row + 1, bottom_row) if (r0, c) != start and (r0, c) != dest]
            if not intermediate:
                continue
            if all(inp[r0][c] == initial_dir_color for (r0, c) in intermediate):
                rr, cc = random.choice(intermediate)
                choices = [2, 3, 4, 5]
                choices.remove(initial_dir_color)
                inp[rr][cc] = random.choice(choices)

        # Now simulate the redirected path to build the output grid
        out = [row[:] for row in inp]

        # Build the original straight-line path (ordered from start to dest)
        path_line = [start]
        r0, c0 = start
        dr = sign(dest[0] - start[0])
        dc = sign(dest[1] - start[1])
        while (r0, c0) != dest:
            r0 += dr
            c0 += dc
            path_line.append((r0, c0))

        # Walk along the original line and apply gravity at each intermediate cell
        current = start
        direction = initial_dir
        valid = True
        # Iterate over intermediate cells (exclude start and dest)
        for (r1, c1) in path_line[1:-1]:
            color = inp[r1][c1]
            # color should be one of gravity colors
            if color not in DIR_BY_COLOR:
                valid = False
                break
            direction = DIR_BY_COLOR[color]
            current = (current[0] + direction[0], current[1] + direction[1])
            # out of bounds check
            if current[0] < 0 or current[0] >= height or current[1] < 0 or current[1] >= width:
                valid = False
                break
            # Do not overwrite destination
            if current == dest:
                # keep destination color 9
                continue
            out[current[0]][current[1]] = 1

        if not valid:
            # Try a new random example
            continue

        # Ensure the destination remains 9
        out[dest[0]][dest[1]] = 9

        # Avoid producing pairs that are identical to input
        if out == inp:
            continue

        sig = stringify_pair(inp, out)
        if sig in SEEN:
            # produce a different example
            continue
        SEEN.add(sig)
        return { 'input': inp, 'output': out }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height else 0

    # Find start (1) and destination (9)
    start = None
    dest = None
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 1:
                start = (r, c)
            elif grid[r][c] == 9:
                dest = (r, c)
    if start is None or dest is None:
        return grid

    def sign(x):
        if x > 0:
            return 1
        if x < 0:
            return -1
        return 0

    DIR_BY_COLOR = {2: (1, 0), 3: (0, -1), 4: (-1, 0), 5: (0, 1)}

    # Build the original straight-line path from start to dest
    path_line = [start]
    r0, c0 = start
    dr = sign(dest[0] - start[0])
    dc = sign(dest[1] - start[1])
    while (r0, c0) != dest:
        r0 += dr
        c0 += dc
        path_line.append((r0, c0))

    output = [row[:] for row in grid]

    # Simulate the redirected path
    current = start
    direction = (dr, dc)
    for (r1, c1) in path_line[1:-1]:
        color = grid[r1][c1]
        if color not in DIR_BY_COLOR:
            # If a non-gravity cell appears, stop applying redirections
            break
        direction = DIR_BY_COLOR[color]
        current = (current[0] + direction[0], current[1] + direction[1])
        # Safety check
        if not (0 <= current[0] < height and 0 <= current[1] < width):
            break
        # Do not overwrite the destination
        if current == dest:
            continue
        output[current[0]][current[1]] = 1

    # Ensure destination remains 9
    output[dest[0]][dest[1]] = 9
    return output

