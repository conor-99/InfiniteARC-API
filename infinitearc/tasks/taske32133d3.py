# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: e32133d3
Difficulty: very hard

=== Tags ===
- Source target routing
- Pairwise rule matching
- Color by distance to a single point

=== Description ===
Input grids contain a background color (0), multiple source cells (color 1),
target cells (color 2), and a single reference cell (color 3) that uniquely
identifies a specific grid location. Sources and targets are arranged such that
each source has a distinct corresponding target, with pairings determined by a
geometric rule: sources and targets are paired based on their relative positions
to the reference point, forming symmetric pairs along radial lines extending
from the reference (e.g., a source at (r+1, c) pairs with a target at (r-1, c)
when the reference is at (r, c)).   The output grid retains the background and
reference cell but replaces all cells along the shortest path (using 4-direction
movement) between each source-target pair with colors determined by the
Manhattan distance from the reference point. For any cell at distance *d* from
the reference, the output color is calculated as *color = (d mod 5) + 4* (e.g.,
distance 0 → color 4, distance 1 → color 5, distance 2 → color 6, distance 3 →
color 7, distance 4 → color 8, distance 5 → color 4, etc.). The original source
and target cells are included in their respective paths and adopt the distance-
based color. Paths are drawn without overlapping or overwriting non-background
elements, and the reference cell remains unchanged. This task requires inferring
the pairing rule from the reference's geometric relationship to sources/targets,
computing shortest paths, and applying a distance-dependent color
transformation—all while navigating complex spatial relationships in a grid with
multiple intersecting paths.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common
from collections import deque

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    grid = common.grid(width, height, 0)
    
    r = random.randint(2, height - 3)
    c = random.randint(2, width - 3)
    grid[r][c] = 3
    
    directions = [(1, 0), (0, 1), (-1, 0), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)]
    random.shuffle(directions)
    
    for dx, dy in directions:
        sr, sc = r + dx, c + dy
        tr, tc = r - dx, c - dy
        if 0 <= sr < height and 0 <= sc < width and 0 <= tr < height and 0 <= tc < width:
            if grid[sr][sc] == 0 and grid[tr][tc] == 0:
                grid[sr][sc] = 1
                grid[tr][tc] = 2
                if sum(1 for row in grid for val in row if val in [1, 2]) >= 4:
                    break
    
    if sum(1 for row in grid for val in row if val in [1, 2]) < 2:
        grid[r+1][c] = 1
        grid[r-1][c] = 2
    
    output = [row[:] for row in grid]
    ref_r, ref_c = r, c
    
    sources = []
    targets = []
    for i in range(height):
        for j in range(width):
            if grid[i][j] == 1:
                sources.append((i, j))
            elif grid[i][j] == 2:
                targets.append((i, j))
    
    pairs = []
    targets_used = []
    for s in sources:
        for t in targets:
            if (s[0] + t[0]) // 2 == ref_r and (s[1] + t[1]) // 2 == ref_c:
                pairs.append((s, t))
                targets_used.append(t)
                break
    
    for (s, t) in pairs:
        queue = deque()
        queue.append((s[0], s[1], []))
        visited = set()
        visited.add(s)
        path_found = None
        while queue:
            r, c, path = queue.popleft()
            if (r, c) == t:
                path_found = path + [(r, c)]
                break
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in visited and grid[nr][nc] != 3:
                    visited.add((nr, nc))
                    queue.append((nr, nc, path + [(r, c)]))
        if path_found:
            for (pr, pc) in path_found:
                d = abs(pr - ref_r) + abs(pc - ref_c)
                color = (d % 5) + 4
                output[pr][pc] = color
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    ref_pos = None
    for i in range(height):
        for j in range(width):
            if grid[i][j] == 3:
                ref_pos = (i, j)
                break
        if ref_pos:
            break
    if not ref_pos:
        return input_grid
    
    ref_r, ref_c = ref_pos
    
    sources = []
    targets = []
    for i in range(height):
        for j in range(width):
            if grid[i][j] == 1:
                sources.append((i, j))
            elif grid[i][j] == 2:
                targets.append((i, j))
    
    pairs = []
    targets_used = []
    for s in sources:
        for t in targets:
            if (s[0] + t[0]) // 2 == ref_r and (s[1] + t[1]) // 2 == ref_c:
                pairs.append((s, t))
                targets_used.append(t)
                break
    
    for (s, t) in pairs:
        queue = deque()
        queue.append((s[0], s[1], []))
        visited = set()
        visited.add(s)
        path_found = None
        while queue:
            r, c, path = queue.popleft()
            if (r, c) == t:
                path_found = path + [(r, c)]
                break
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in visited and grid[nr][nc] != 3:
                    visited.add((nr, nc))
                    queue.append((nr, nc, path + [(r, c)]))
        if path_found:
            for (pr, pc) in path_found:
                d = abs(pr - ref_r) + abs(pc - ref_c)
                color = (d % 5) + 4
                grid[pr][pc] = color
    
    return tuple(tuple(row) for row in grid)
