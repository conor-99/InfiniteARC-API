# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: ce9ee384
Difficulty: medium

=== Tags ===
- Propagate label
- Pattern differences
- Reorder blocks by size
- Reflect by color

=== Description ===
The task involves transforming an input grid into an output grid through a
sequence of operations based on the colors of connected blocks. First, each
connected region (block) of non-zero color is reflected horizontally if the
color is even (0, 2, 4, 6, 8) or vertically if the color is odd (1, 3, 5, 7, 9).
After reflection, all blocks are sorted by their size (number of cells they
contain) in ascending order. The output grid is then constructed by placing the
sorted blocks in row-major order (top-left to bottom-right), filling the grid
sequentially with each reflected block, while background cells (0) fill any
remaining positions. This process creates a new pattern where the arrangement of
blocks depends on their original color-driven reflection and subsequent size-
based ordering.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, all_pixels

def get_connected_components(grid):
    visited = set()
    components = []
    height = len(grid)
    width = len(grid[0])
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and (r, c) not in visited:
                component = []
                queue = [(r, c)]
                visited.add((r, c))
                color = grid[r][c]
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == color and (nr, nc) not in visited:
                            visited.add((nr, nc))
                            queue.append((nr, nc))
                components.append((color, component))
    return components

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    input_grid = grid(width, height, 0)
    
    # Create 2-3 random non-overlapping connected regions
    num_regions = random.randint(2, 3)
    colors = [2, 3, 4, 5]  # Even and odd colors
    region_sizes = [random.randint(2, 5) for _ in range(num_regions)]
    
    for i in range(num_regions):
        color = random.choice(colors)
        size = region_sizes[i]
        # Place region in a random position
        r_start = random.randint(0, height - 1)
        c_start = random.randint(0, width - 1)
        
        # Create a simple shape (e.g., horizontal line)
        for j in range(size):
            r = r_start
            c = c_start + j
            if 0 <= r < height and 0 <= c < width:
                input_grid[r][c] = color

    # Get components and process
    components = get_connected_components(input_grid)
    reflected_components = []
    for color, region in components:
        if color % 2 == 0:
            new_region = [(r, width - 1 - c) for r, c in region]
        else:
            new_region = [(height - 1 - r, c) for r, c in region]
        reflected_components.append((color, new_region))
    
    # Sort by size
    reflected_components.sort(key=lambda x: len(x[1]))
    
    # Create output grid
    output_grid = grid(width, height, 0)
    current_col = 0
    current_row = 0
    for color, region in reflected_components:
        min_r = min(r for r, c in region)
        min_c = min(c for r, c in region)
        shifted_region = [(r - min_r, c - min_c) for r, c in region]
        
        # Place in output grid
        for r, c in shifted_region:
            if current_row + r < height and current_col + c < width:
                output_grid[current_row + r][current_col + c] = color
        
        # Update position
        max_r = max(r for r, c in shifted_region) if shifted_region else 0
        max_c = max(c for r, c in shifted_region) if shifted_region else 0
        current_col += max_c + 1
        if current_col >= width:
            current_col = 0
            current_row += max_r + 1
            
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid


def get_connected_components(grid):
    visited = set()
    components = []
    height = len(grid)
    width = len(grid[0])
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and (r, c) not in visited:
                component = []
                queue = [(r, c)]
                visited.add((r, c))
                color = grid[r][c]
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == color and (nr, nc) not in visited:
                            visited.add((nr, nc))
                            queue.append((nr, nc))
                components.append((color, component))
    return components

def p(input_grid):
    if not input_grid:
        return []
    height = len(input_grid)
    width = len(input_grid[0])
    
    # Get components and process
    components = get_connected_components(input_grid)
    reflected_components = []
    for color, region in components:
        if color % 2 == 0:
            new_region = [(r, width - 1 - c) for r, c in region]
        else:
            new_region = [(height - 1 - r, c) for r, c in region]
        reflected_components.append((color, new_region))
    
    # Sort by size
    reflected_components.sort(key=lambda x: len(x[1]))
    
    # Create output grid
    output_grid = grid(width, height, 0)
    current_col = 0
    current_row = 0
    for color, region in reflected_components:
        min_r = min(r for r, c in region)
        min_c = min(c for r, c in region)
        shifted_region = [(r - min_r, c - min_c) for r, c in region]
        
        # Place in output grid
        for r, c in shifted_region:
            if current_row + r < height and current_col + c < width:
                output_grid[current_row + r][current_col + c] = color
        
        # Update position
        max_r = max(r for r, c in shifted_region) if shifted_region else 0
        max_c = max(c for r, c in shifted_region) if shifted_region else 0
        current_col += max_c + 1
        if current_col >= width:
            current_col = 0
            current_row += max_r + 1
            
    return output_grid
