# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 6f237fb6
Difficulty: hard

=== Tags ===
- Diagonal weaving
- Contour thickening
- Separate images

=== Description ===
Input grids contain multiple distinct, non-overlapping shapes (each shape is a
connected region of a single non-background color) positioned with at least one
background cell separating them. Shapes are complex and varied in form, with no
two shapes touching or overlapping. The background color is uniform (e.g., 0).
To generate the output grid: 1. **Contour thickening:** For each shape, thicken
its boundary by adding diagonal lines outside the shape along all edges. The
diagonal direction depends on the edge orientation:    - Top edges: Add a
diagonal line (/) above the top boundary, extending from the top-left to top-
right of the shape.    - Bottom edges: Add a diagonal line (\) below the bottom
boundary, extending from the bottom-left to bottom-right.    - Left edges: Add a
diagonal line (/) to the left of the left boundary, extending from the top-left
to bottom-left.    - Right edges: Add a diagonal line (\) to the right of the
right boundary, extending from the top-right to bottom-right.  2. **Diagonal
weaving:** Where two shapes are positioned horizontally adjacent (with
background cells between them), the right edge diagonal of the left shape (a \
line) intersects with the left edge diagonal of the right shape (a / line). At
the intersection point, the diagonals cross without overlapping, creating a
woven pattern where the lines interlace like a fabric weave.  3. **Separate
image processing:** Each shape's contour thickening is computed independently.
Diagonal lines are added only to background cells, never overwriting existing
shapes, other diagonals, or the background. The weaving interaction occurs only
at the boundary between two shapes' diagonals; diagonals from non-adjacent
shapes do not interact.  The output grid retains all original shapes but
displays their contours as thickened diagonal patterns that weave with adjacent
shapes' contours, creating a complex visual tapestry of crossing diagonals
across the grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, rand_sprite

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    input_grid = grid(width, height, 0)
    colors = list(range(1, 10))
    
    shapes = []
    for _ in range(3):
        if not colors:
            break
        color = colors.pop(random.randint(0, len(colors)-1))
        sprite = rand_sprite('el', width, height)
        shift_r = random.randint(0, height // 2)
        shift_c = random.randint(0, width // 2)
        shifted_sprite = [(r + shift_r, c + shift_c) for (r, c) in sprite]
        shifted_sprite = [(r, c) for (r, c) in shifted_sprite if 0 <= r < height and 0 <= c < width]
        if not shifted_sprite:
            continue
        overlap = False
        for (existing_sprite, _) in shapes:
            if set(shifted_sprite) & set(existing_sprite):
                overlap = True
                break
        if not overlap:
            shapes.append((shifted_sprite, color))
    
    for (sprite, color) in shapes:
        for (r, c) in sprite:
            input_grid[r][c] = color
    
    output_grid = [row[:] for row in input_grid]
    
    for (sprite, color) in shapes:
        rows, cols = zip(*sprite)
        min_row, max_row = min(rows), max(rows)
        min_col, max_col = min(cols), max(cols)
        
        # Top edge: / diagonal above
        for k in range(0, max_col - min_col + 1):
            r = min_row - 1 - k
            c = min_col + k
            if 0 <= r < height and 0 <= c < width and input_grid[r][c] == 0:
                output_grid[r][c] = 5
        
        # Bottom edge: \ diagonal below
        for k in range(0, max_col - min_col + 1):
            r = max_row + 1 + k
            c = min_col + k
            if 0 <= r < height and 0 <= c < width and input_grid[r][c] == 0:
                output_grid[r][c] = 5
        
        # Left edge: / diagonal to the left
        for k in range(0, max_row - min_row + 1):
            r = min_row + k
            c = min_col - 1 - k
            if 0 <= r < height and 0 <= c < width and input_grid[r][c] == 0:
                output_grid[r][c] = 5
        
        # Right edge: \ diagonal to the right
        for k in range(0, max_row - min_row + 1):
            r = min_row + k
            c = max_col + 1 + k
            if 0 <= r < height and 0 <= c < width and input_grid[r][c] == 0:
                output_grid[r][c] = 5
    
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    
    visited = [[False] * width for _ in range(height)]
    shapes = []
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and input_grid[r][c] != 0:
                color = input_grid[r][c]
                queue = [(r, c)]
                region = []
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    region.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                shapes.append(region)
    
    output_grid = [row[:] for row in input_grid]
    
    for region in shapes:
        if not region:
            continue
        rows, cols = zip(*region)
        min_row, max_row = min(rows), max(rows)
        min_col, max_col = min(cols), max(cols)
        
        # Top edge
        for k in range(0, max_col - min_col + 1):
            r = min_row - 1 - k
            c = min_col + k
            if 0 <= r < height and 0 <= c < width and input_grid[r][c] == 0:
                output_grid[r][c] = 5
        
        # Bottom edge
        for k in range(0, max_col - min_col + 1):
            r = max_row + 1 + k
            c = min_col + k
            if 0 <= r < height and 0 <= c < width and input_grid[r][c] == 0:
                output_grid[r][c] = 5
        
        # Left edge
        for k in range(0, max_row - min_row + 1):
            r = min_row + k
            c = min_col - 1 - k
            if 0 <= r < height and 0 <= c < width and input_grid[r][c] == 0:
                output_grid[r][c] = 5
        
        # Right edge
        for k in range(0, max_row - min_row + 1):
            r = min_row + k
            c = max_col + 1 + k
            if 0 <= r < height and 0 <= c < width and input_grid[r][c] == 0:
                output_grid[r][c] = 5
    
    return output_grid
