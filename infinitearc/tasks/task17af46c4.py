# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 17af46c4
Difficulty: hard

=== Tags ===
- Color permutation

=== Description ===
The task involves a grid with multiple non-zero color regions, each forming a
single connected component (using 4-directional adjacency). The transformation
permutes the colors based on the size of their connected components.
Specifically, the non-zero colors are sorted in ascending order by the number of
cells in their connected components. The smallest component is mapped to color
1, the next smallest to color 2, and so on, with all instances of each original
color replaced by its new assigned color. The background color (0) remains
unchanged throughout the transformation. This requires the solver to identify
all connected components, compute their sizes, sort the colors by size, and
apply the permutation across the entire grid. The complexity arises from the
need to process multiple layers of structural information (component
identification, size comparison, and mapping) without relying on numerical
properties or pixel-level patterns.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    while True:
        width = random.randint(5, 20)
        height = random.randint(5, 20)
        input_grid = common.grid(width, height, 0)
        n_colors = random.randint(2, 4)
        max_size = (width // 2) * (height // 2)
        sizes = []
        for _ in range(n_colors):
            s = random.randint(2, max_size)
            while s in sizes:
                s = random.randint(2, max_size)
            sizes.append(s)
        
        colors = common.random_colors(n_colors, exclude=[0])
        quadrants = [
            (0, 0, width // 2, height // 2),
            (0, width // 2, width // 2, height // 2),
            (height // 2, 0, width // 2, height // 2),
            (height // 2, width // 2, width // 2, height // 2)
        ]
        random.shuffle(quadrants)
        
        for i in range(n_colors):
            color = colors[i]
            size = sizes[i]
            y_start, x_start, q_w, q_h = quadrants[i]
            shape_pixels = common.continuous_creature(size, q_w, q_h)
            for r, c in shape_pixels:
                main_r = y_start + r
                main_c = x_start + c
                if main_r < height and main_c < width:
                    input_grid[main_r][main_c] = color
        
        visited = [[False] * width for _ in range(height)]
        component_sizes = {}
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] > 0 and not visited[r][c]:
                    color = input_grid[r][c]
                    stack = [(r, c)]
                    visited[r][c] = True
                    comp_pixels = []
                    while stack:
                        cr, cc = stack.pop()
                        comp_pixels.append((cr, cc))
                        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == color and not visited[nr][nc]:
                                visited[nr][nc] = True
                                stack.append((nr, nc))
                    size = len(comp_pixels)
                    component_sizes[color] = size
        
        sorted_colors = sorted(component_sizes.keys(), key=lambda c: component_sizes[c])
        color_map = {}
        for new_color, color in enumerate(sorted_colors, 1):
            color_map[color] = new_color
        
        output_grid = [[0] * width for _ in range(height)]
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] > 0:
                    output_grid[r][c] = color_map[input_grid[r][c]]
        
        if input_grid != output_grid:
            return {
                "input": input_grid,
                "output": output_grid
            }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    visited = [[False] * width for _ in range(height)]
    component_sizes = {}
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] > 0 and not visited[r][c]:
                color = input_grid[r][c]
                stack = [(r, c)]
                visited[r][c] = True
                comp_pixels = []
                while stack:
                    cr, cc = stack.pop()
                    comp_pixels.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == color and not visited[nr][nc]:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                size = len(comp_pixels)
                component_sizes[color] = size
    
    sorted_colors = sorted(component_sizes.keys(), key=lambda c: component_sizes[c])
    color_map = {}
    for idx, color in enumerate(sorted_colors, 1):
        color_map[color] = idx
    
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] > 0:
                output_grid[r][c] = color_map[input_grid[r][c]]
    
    return output_grid
