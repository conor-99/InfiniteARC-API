# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 08af4b57
Difficulty: medium–hard

=== Tags ===
- Sequential path painting
- Coordinate system translation
- Holes
- Fit to bounding box

=== Description ===
Input grids are 2D grids of size 1×1 to 30×30, featuring a single background
color (0), obstacles (non-zero colors), and a distinct source cell (color 1)
positioned on the left edge. The obstacles form a maze-like structure where
connected background cells (holes) create a continuous, non-branching path from
the source to the right edge. This path is composed of horizontally and
vertically adjacent background cells separated from obstacles by at least one
cell.   To generate the output grid, the path is traced starting from the
source. The path moves rightward until it encounters an obstacle; upon
collision, it turns upward and continues through background cells, alternating
direction (right/up) with each obstacle collision. Each cell along the path
(excluding the source) is repainted with colors from a fixed cyclic sequence
(e.g., 2 → 3 → 4 → 2 → 3 → 4...), cycling through the sequence with each step.
The source cell remains color 1, obstacle cells retain their original colors,
and background cells not part of the path remain unchanged.   The output grid is
then cropped to the minimal bounding box containing all painted path cells. This
bounding box is aligned such that the path's starting point (source) is
positioned at the top-left corner, preserving the path's right/up directional
flow within the cropped grid. The coordinate system translation ensures the
output grid's dimensions reflect only the path's extent, eliminating all empty
rows and columns outside the path's boundaries. The transformation requires
sequential path tracing, cyclic color application, and spatial repositioning to
fit the path into its minimal bounding box.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    """
    Generates an input/output pair where the input is a grid filled with a single obstacle color
    (non-zero), a source cell (color 1) on the left edge, and a single non-branching background path
    (color 0) that snakes right and down (alternating) until it reaches the right edge. The output is the
    cropped minimal bounding box (including the source and all painted cells) where the path cells
    (excluding the source) are painted with a cyclic sequence [2,3,4].
    """
    # grid dimensions
    width = random.randint(4, 30)
    height = random.randint(4, 30)

    # choose a source row (left edge)
    source_row = random.randint(0, height - 1)

    # number of vertical turns (downward) we allow (v). Limit to keep path inside grid
    v_max = min(3, height - 1 - source_row, max(0, width - 2))
    if v_max < 0:
        v_max = 0
    v = random.randint(0, v_max)

    # number of horizontal segments is v + 1
    n_h = v + 1

    # total horizontal steps to reach right edge from column 0
    total_h = width - 1
    # partition total_h into n_h positive integers (each >=1)
    h_parts = [1] * n_h
    rem = total_h - n_h
    for _ in range(rem):
        idx = random.randrange(n_h)
        h_parts[idx] += 1

    # partition vertical steps (downward). sum of vertical steps must be <= available space below source
    if v == 0:
        v_parts = []
    else:
        min_v_sum = v
        max_v_sum = height - 1 - source_row
        s_v = random.randint(min_v_sum, max_v_sum)
        v_parts = [1] * v
        remv = s_v - v
        for _ in range(remv):
            idx = random.randrange(v)
            v_parts[idx] += 1

    # choose an obstacle color that doesn't conflict with source(1) or paint cycle (2,3,4)
    obstacle_color = random.choice([5, 6, 7, 8, 9])

    # create input grid filled with obstacle_color
    grid_in = grid(width, height, obstacle_color)

    # place the source cell on the left edge
    grid_in[source_row][0] = 1

    # carve the path (background cells = 0)
    r = source_row
    c = 0
    path = []  # list of (r,c) cells after the source
    for seg_idx in range(n_h):
        # move right h_parts[seg_idx] steps
        for _ in range(h_parts[seg_idx]):
            c += 1
            # safety clamp
            if c >= width:
                c = width - 1
            path.append((r, c))
        # if there is a vertical segment after this horizontal one, move down
        if seg_idx < v:
            for _ in range(v_parts[seg_idx]):
                r += 1
                if r >= height:
                    r = height - 1
                path.append((r, c))

    # ensure we end at the right edge; if not, extend horizontally (safety)
    if not path or path[-1][1] < width - 1:
        last_r = path[-1][0] if path else source_row
        last_c = path[-1][1] if path else 0
        while last_c < width - 1:
            last_c += 1
            path.append((last_r, last_c))

    # carve zeros for path cells in the input (do not overwrite the source)
    for (pr, pc) in path:
        if pr == source_row and pc == 0:
            continue
        grid_in[pr][pc] = 0

    # build output: copy input and paint path excluding the source using cycle [2,3,4]
    grid_out = [row[:] for row in grid_in]
    cycle = [2, 3, 4]
    for idx, (pr, pc) in enumerate(path):
        grid_out[pr][pc] = cycle[idx % len(cycle)]

    # compute minimal bounding box that includes the source and all painted cells
    rows = [source_row] + [pr for pr, pc in path]
    cols = [0] + [pc for pr, pc in path]
    min_row = min(rows)
    max_row = max(rows)
    min_col = min(cols)
    max_col = max(cols)

    # crop the output to that bounding box
    cropped_out = [grid_out[r][min_col:max_col + 1] for r in range(min_row, max_row + 1)]

    return {
        "input": grid_in,
        "output": cropped_out
    }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # convert to mutable list of lists
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0]) if height > 0 else 0

    # find the source cell (color 1) on the left edge
    source_row = None
    for r in range(height):
        if grid_in[r][0] == 1:
            source_row = r
            break
    if source_row is None:
        # no source found: return the original input as-is
        return [list(row) for row in input_grid]

    # collect coordinates of background cells (zeros)
    zeros = set()
    for r in range(height):
        for c in range(width):
            if grid_in[r][c] == 0:
                zeros.add((r, c))

    # determine the first path cell: prefer the right neighbor of the source
    start = None
    if width > 1 and grid_in[source_row][1] == 0:
        start = (source_row, 1)
    else:
        # fallback: any zero neighbor of the source (shouldn't happen for generator)
        for dr, dc in [(0, 1), (1, 0), (-1, 0)]:
            nr, nc = source_row + dr, 0 + dc
            if 0 <= nr < height and 0 <= nc < width and grid_in[nr][nc] == 0:
                start = (nr, nc)
                break
    if start is None:
        # no path cells; return a cropped grid containing only the source
        return [[1]]

    # traverse the non-branching path in order starting from the source
    path = []
    prev = (source_row, 0)
    curr = start
    path.append(curr)
    while True:
        r, c = curr
        # stop early if we've reached the right edge
        if c == width - 1:
            break
        # find zero neighbors of curr excluding the previous cell
        next_cells = []
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if (nr, nc) == prev:
                continue
            if (nr, nc) in zeros:
                next_cells.append((nr, nc))
        if not next_cells:
            break
        # non-branching path => pick the single next cell
        next_cell = next_cells[0]
        prev, curr = curr, next_cell
        path.append(curr)

    # paint the path (excluding the source) with the cycle [2,3,4]
    grid_out = [row[:] for row in grid_in]
    cycle = [2, 3, 4]
    for idx, (r, c) in enumerate(path):
        grid_out[r][c] = cycle[idx % len(cycle)]

    # compute minimal bounding box including the source and all painted cells
    rows = [source_row] + [r for r, c in path]
    cols = [0] + [c for r, c in path]
    min_row = min(rows)
    max_row = max(rows)
    min_col = min(cols)
    max_col = max(cols)

    # crop and return
    cropped = [grid_out[r][min_col:max_col + 1] for r in range(min_row, max_row + 1)]
    return cropped

