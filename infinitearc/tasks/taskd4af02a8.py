# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: d4af02a8
Difficulty: very hard

=== Tags ===
- Binary rule overlay
- Split and merge
- Substitution rule discovery
- Relay chain
- Remove thin noise

=== Description ===
Input grids contain a dense, intricate arrangement of colored regions (0-9) with
thin noise elements—single cells or 1-cell-thick lines that are not part of any
contiguous region of size ≥2 (4-directional adjacency). The transformation
requires:  1. **Thin Noise Removal**: All cells with fewer than two same-colored
neighbors (in 4 directions) are eliminated, leaving only robust, connected
regions. This removes all isolated pixels and 1-cell-wide "noise" lines.  2.
**Binary Rule Overlay**: The grid is split into two regions using a spatially
derived binary rule (e.g., "split along the vertical axis where color 7
dominates the top half"). The rule is not explicitly stated but must be inferred
from input-output pairs (e.g., the split position correlates with the
distribution of a specific color).  3. **Split and Merge**: Each split region
undergoes independent processing. The left region merges adjacent regions of the
same color into larger contiguous blocks, while the right region applies a
substitution rule based on a *relay chain*.  4. **Relay Chain Substitution**:
The substitution follows a sequence determined by a *relay chain*—a hidden
sequence of color mappings (e.g., color A → B → C → D). The starting color in
the top-left quadrant dictates the first substitution, and each subsequent
substitution depends on the output of the prior step. The solver must discover
the chain through analysis of multiple examples, as the mappings are not
directly visible.  5. **Final Merged Output**: The processed left and right
regions are recombined into a single grid. The output retains the noise-removed
structure, reflects the inferred binary split, and applies the relay chain
substitutions consistently across the grid, ensuring all substitutions are
visually coherent and non-contradictory.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, randint, choice

def generate():
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    grid = [[0] * width for _ in range(height)]
    colors = list(range(1, 10))
    num_regions = random.randint(3, 4)
    for _ in range(num_regions):
        color = random.choice(colors)
        pixels = []
        for r in range(height):
            for c in range(width):
                if random.random() > 0.5 and (r < 2 or c < 2):
                    pixels.append((r, c))
        for r, c in pixels:
            if 0 <= r < height and 0 <= c < width:
                grid[r][c] = color
    noise_count = width * height // 20
    for _ in range(noise_count):
        r, c = random.randint(0, height-1), random.randint(0, width-1)
        if grid[r][c] == 0:
            grid[r][c] = random.choice(colors)
    input_grid = grid
    clean_grid = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                continue
            count = 0
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r+dr, c+dc
                if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == input_grid[r][c]:
                    count += 1
            if count < 2:
                clean_grid[r][c] = 0
    top_left_colors = []
    for r in range(min(5, height)):
        for c in range(min(5, width)):
            if clean_grid[r][c] != 0:
                top_left_colors.append(clean_grid[r][c])
    dominant_color = max(set(top_left_colors), key=top_left_colors.count) if top_left_colors else 7
    color_counts = [0] * width
    for c in range(width):
        for r in range(height):
            if clean_grid[r][c] == dominant_color:
                color_counts[c] += 1
    total = sum(color_counts)
    split_col = width // 2
    if total > 0:
        cumulative = 0
        for c in range(width):
            cumulative += color_counts[c]
            if cumulative >= total / 2:
                split_col = c
                break
    left_grid = [row[:split_col] for row in clean_grid]
    right_grid = [row[split_col:] for row in clean_grid]
    top_left_colors = []
    for r in range(min(5, height)):
        for c in range(min(5, width)):
            if clean_grid[r][c] != 0:
                top_left_colors.append(clean_grid[r][c])
    start_color = max(set(top_left_colors), key=top_left_colors.count) if top_left_colors else 1
    chain = [start_color]
    for i in range(1, 4):
        next_color = (start_color - 1 + i) % 9 + 1
        chain.append(next_color)
    output_right = [row[:] for row in right_grid]
    for r in range(len(output_right)):
        for c in range(len(output_right[0])):
            if output_right[r][c] == chain[0]:
                output_right[r][c] = chain[1]
            elif output_right[r][c] == chain[1]:
                output_right[r][c] = chain[2]
            elif output_right[r][c] == chain[2]:
                output_right[r][c] = chain[3]
    output_grid = [left_grid[i] + output_right[i] for i in range(height)]
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random
from common import grid, randint, choice

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    clean_grid = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                continue
            count = 0
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r+dr, c+dc
                if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == input_grid[r][c]:
                    count += 1
            if count < 2:
                clean_grid[r][c] = 0
    top_left_colors = []
    for r in range(min(5, height)):
        for c in range(min(5, width)):
            if clean_grid[r][c] != 0:
                top_left_colors.append(clean_grid[r][c])
    dominant_color = max(set(top_left_colors), key=top_left_colors.count) if top_left_colors else 7
    color_counts = [0] * width
    for c in range(width):
        for r in range(height):
            if clean_grid[r][c] == dominant_color:
                color_counts[c] += 1
    total = sum(color_counts)
    split_col = width // 2
    if total > 0:
        cumulative = 0
        for c in range(width):
            cumulative += color_counts[c]
            if cumulative >= total / 2:
                split_col = c
                break
    left_grid = [row[:split_col] for row in clean_grid]
    right_grid = [row[split_col:] for row in clean_grid]
    top_left_colors = []
    for r in range(min(5, height)):
        for c in range(min(5, width)):
            if clean_grid[r][c] != 0:
                top_left_colors.append(clean_grid[r][c])
    start_color = max(set(top_left_colors), key=top_left_colors.count) if top_left_colors else 1
    chain = [start_color]
    for i in range(1, 4):
        next_color = (start_color - 1 + i) % 9 + 1
        chain.append(next_color)
    for r in range(len(right_grid)):
        for c in range(len(right_grid[0])):
            if right_grid[r][c] == chain[0]:
                right_grid[r][c] = chain[1]
            elif right_grid[r][c] == chain[1]:
                right_grid[r][c] = chain[2]
            elif right_grid[r][c] == chain[2]:
                right_grid[r][c] = chain[3]
    output_grid = [left_grid[i] + right_grid[i] for i in range(height)]
    return output_grid
