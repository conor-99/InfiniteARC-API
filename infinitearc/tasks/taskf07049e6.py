# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: f07049e6
Difficulty: medium–hard

=== Tags ===
- Pattern rotation
- Phase transition path
- State transfer chain
- Recoloring
- Duplicate row pattern

=== Description ===
**Task Name: Dynamic Pattern Propagation**    **Tags:** Pattern rotation, Phase
transition path, State transfer chain, Recoloring, Duplicate row pattern
**Description:**    Input grids feature a central vertical *phase path* composed
of distinct-colored cells (e.g., colors 1, 2, 3) arranged in a column. Each cell
in this path corresponds to a *state* in a cyclic sequence (e.g., 1 → 2 → 3 →
1...). To the left and right of the path, the grid contains multiple *row
patterns*—each row is a horizontal sequence of colored cells forming a distinct
visual motif. The phase path spans vertically from top to bottom, with each cell
aligned with a specific row pattern in the main grid.    The transformation
rules are as follows:    1. **State Transfer Chain**: For each row pattern, its
alignment with the phase path determines the transformation. The color of the
phase path cell directly above the row (or the closest matching cell) defines
the *current state*. Each state triggers a specific *rotation direction* for the
row pattern:      - *State 1*: Rotate pattern left (shift elements left by 1
position)      - *State 2*: Rotate pattern right (shift elements right by 1
position)      - *State 3*: Rotate pattern 180° (reverse the order)    2.
**Recoloring**: After rotation, recolor all elements in the row pattern to the
*next state* in the sequence. For example, if the current state is 1 (next state
2), all cells in the rotated row become color 2. Background (color 0) remains
unchanged.    3. **Duplicate Row Pattern**: For each transformed row, create a
duplicate *below* the original row, using the recolored and rotated pattern. The
duplicate rows are placed immediately adjacent to the original, maintaining
horizontal alignment.    The output grid preserves all original row patterns
(untransformed) above the first transformed row. Rows below the original
position are replaced with the transformed and duplicated rows. The phase path
remains unchanged.    **Example Input-Output Insight:**   - A row with pattern
`[1, 2, 3]` (colors 1, 2, 3) aligned with *state 1* becomes `[2, 3, 1]` (rotated
left) and recolored to state 2 (`[2, 2, 2]`), then duplicated below.   - A row
with pattern `[4, 5, 6]` aligned with *state 3* becomes `[6, 5, 4]` (rotated
180°) and recolored to state 1 (`[1, 1, 1]`), then duplicated.    **Complexity
Notes:**   - The phase path must be recognized as the vertical sequence of
unique colors, not just any column.   - Rotation direction is tied to the state
color, not numerical values (e.g., color 1 always means left shift).   -
Recoloring follows the cyclic state transition chain, requiring understanding of
the sequence.   - Duplicates are placed *after* all original rows, creating a
new section in the grid.   - The task requires sequential application of
multiple rules (rotation → recoloring → duplication), with no overlapping or
ambiguous mappings.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    rows = random.choice([4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30])
    cols = random.randint(5, 30)
    input_grid = grid(cols, rows, 0)
    phase_col = cols // 2
    
    for i in range(rows):
        input_grid[i][phase_col] = (i % 3) + 1
        for j in range(phase_col):
            input_grid[i][j] = random.randint(1, 9)
    
    output_grid = [row[:] for row in input_grid]
    
    for idx in range(rows // 2):
        i = 2 * idx
        state = input_grid[idx][phase_col]
        next_state = (state % 3) + 1
        for j in range(phase_col):
            output_grid[i][j] = next_state
            output_grid[i+1][j] = next_state
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    rows = len(input_list)
    cols = len(input_list[0])
    
    phase_col = None
    for j in range(cols):
        valid = True
        for i in range(rows):
            if input_list[i][j] != (i % 3) + 1:
                valid = False
                break
        if valid:
            phase_col = j
            break
    
    if phase_col is None:
        phase_col = cols // 2
    
    output = [row[:] for row in input_list]
    
    for idx in range(rows // 2):
        i = 2 * idx
        state = input_list[idx][phase_col]
        next_state = (state % 3) + 1
        for j in range(phase_col):
            output[i][j] = next_state
            output[i+1][j] = next_state
    
    return tuple(tuple(row) for row in output)
