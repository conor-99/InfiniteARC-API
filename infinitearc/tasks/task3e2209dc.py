# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 3e2209dc
Difficulty: very hard

=== Tags ===
- Heat map draw
- Pattern bounce

=== Description ===
# Heat Map Bounce Sequence  Input grids are large (25×25) with a single
background color (0). Overlaid on this background are multiple distinct heat
sources (colors 1–4), each emitting a radial heat intensity that decreases with
distance. Heat sources are placed at least two cells apart and never adjacent to
walls. Walls form irregular, enclosed obstacles (color 9) that do not touch the
grid boundaries, creating a navigable cave-like structure with at least one
clear path from the left edge to the top/right edges.   A pattern strip occupies
the top-left corner as a horizontal sequence of 2×2 color blocks (2–4 blocks
total), where each block’s color corresponds to a fixed directional mapping:
color 1 = right, color 2 = up, color 3 = left, color 4 = down. The leftmost
block color matches the color of a single "source cell" located on the left edge
(background cells, not heat sources), positioned in the first open background
space adjacent to the grid boundary. The source cell is never adjacent to walls.
The output grid retains the input’s walls and pattern strip unchanged. The
background is transformed into a heat map: each cell’s color is determined by
its Manhattan distance to the nearest heat source, with closer proximity
represented by higher-intensity colors (e.g., distance 0 = color 9, distance 1 =
color 8, ..., distance 10 = color 1). A bouncing path is drawn starting from the
source cell, moving initially in the direction corresponding to the pattern
strip’s first color. The path follows the grid’s background cells only,
alternating direction each time it collides with a wall (color 9) by cycling
through the pattern strip’s color sequence. The path’s color at each step
matches the current pattern strip color in the sequence, repeating cyclically.
The path terminates when it exits the grid boundary, never overlapping walls,
heat sources, or the pattern strip, and never crossing itself. The heat map
background is drawn beneath the path, with path cells overriding the heat map
color.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import continuous_creature


def generate():
    """
    Generate a 25x25 ARC task instance according to the Heat Map Bounce Sequence specification.
    The function will attempt multiple times to build a grid where the bouncing path exits the grid
    (so the example is valid). The generator avoids placing walls on the very boundary and keeps the
    top-left 2x2 pattern area clear.
    """
    grid_size = 25

    # Direction mapping for convenience (color -> (dr, dc))
    dir_map = {1: (0, 1), 2: (-1, 0), 3: (0, -1), 4: (1, 0)}

    # Try several times to build a valid instance
    for attempt in range(500):
        # Start with blank background
        input_grid = [[0 for _ in range(grid_size)] for _ in range(grid_size)]

        # 1) Build the pattern strip in the top-left as horizontal 2x2 blocks (2-4 blocks)
        pattern_len = random.randint(2, 4)
        # Avoid trivial immediate-exit by not placing a left-facing (3) as the first color
        first_color = random.choice([1, 2, 4])
        pattern_colors = [first_color]
        for _ in range(pattern_len - 1):
            pattern_colors.append(random.choice([1, 2, 3, 4]))

        pattern_width = 2 * pattern_len
        for idx, color in enumerate(pattern_colors):
            base_c = 2 * idx
            for dr in (0, 1):
                for dc in (0, 1):
                    input_grid[dr][base_c + dc] = color

        # 2) Generate an interior connected wall blob that does not touch the outer border.
        # Use continuous_creature into a 19x19 interior and offset it so walls sit in rows/cols 3..21.
        wall_w, wall_h = 19, 19
        wall_size = random.randint(40, 140)
        wall_pixels = continuous_creature(size=wall_size, width=wall_w, height=wall_h)
        offset = 3
        for (wr, wc) in wall_pixels:
            input_grid[wr + offset][wc + offset] = 9

        # 3) Place 2-4 distinct heat sources (colors 1..4) not adjacent to walls and at least
        #    Manhattan distance >=2 from each other. Restrict placement away from the top two rows
        #    and leftmost column to avoid overlapping the pattern and source cell area.
        heat_count = random.randint(2, 4)
        all_heat_colors = [1, 2, 3, 4]
        heat_colors = random.sample(all_heat_colors, heat_count)
        heat_sources = []
        ok_heat = True
        for color in heat_colors:
            placed = False
            for _ in range(500):
                r = random.randint(2, grid_size - 3)
                c = random.randint(2, grid_size - 3)
                if input_grid[r][c] != 0:
                    continue
                # Not adjacent to walls
                if any(input_grid[r + dr][c + dc] == 9 for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]):
                    continue
                # Not too close to other heat sources (Manhattan distance >=2)
                if any(abs(r - hr) + abs(c - hc) < 2 for (hr, hc) in heat_sources):
                    continue
                input_grid[r][c] = color
                heat_sources.append((r, c))
                placed = True
                break
            if not placed:
                ok_heat = False
                break
        if not ok_heat:
            # Failed to place heat sources cleanly; retry whole grid
            continue

        # 4) Place the source cell on the left edge: the first open background cell at column 0
        #    starting from row 2 (so it isn't in the 2x2 pattern area). Ensure it's not adjacent to walls.
        source_r = None
        for r in range(2, grid_size):
            if input_grid[r][0] != 0:
                continue
            if any(input_grid[r + dr][0 + dc] == 9 for dr, dc in [(1, 0), (-1, 0), (0, 1)]):
                continue
            source_r = r
            input_grid[r][0] = pattern_colors[0]
            break
        if source_r is None:
            # Unlikely but regenerate if no placement found
            continue

        # 5) Simulate the bouncing path. It must follow background cells only and never step into
        #    walls (9), heat sources, or the pattern strip. On collision with an obstacle it cycles
        #    to the next pattern color/direction. The path must exit the grid boundary.
        path_cells = [(source_r, 0)]
        path_cell_colors = [pattern_colors[0]]
        visited = set(path_cells)

        cur_r, cur_c = source_r, 0
        path_color_index = 0
        curr_dir = dir_map[pattern_colors[path_color_index]]

        max_steps = 2000
        success = False
        steps = 0
        while steps < max_steps:
            steps += 1
            nr = cur_r + curr_dir[0]
            nc = cur_c + curr_dir[1]
            # Check exit
            if nr < 0 or nr >= grid_size or nc < 0 or nc >= grid_size:
                success = True
                break

            # Determine obstacles
            in_pattern = (nr in (0, 1) and nc < pattern_width)
            is_wall = input_grid[nr][nc] == 9
            is_heat = (nr, nc) in heat_sources
            is_visited = (nr, nc) in visited

            if is_wall or in_pattern or is_heat or is_visited:
                # Try cycling through the pattern colors until a move is possible or we've tried all
                moved = False
                for _ in range(len(pattern_colors)):
                    path_color_index = (path_color_index + 1) % len(pattern_colors)
                    curr_dir = dir_map[pattern_colors[path_color_index]]
                    nr = cur_r + curr_dir[0]
                    nc = cur_c + curr_dir[1]
                    if nr < 0 or nr >= grid_size or nc < 0 or nc >= grid_size:
                        success = True
                        moved = False
                        break
                    in_pattern = (nr in (0, 1) and nc < pattern_width)
                    is_wall = input_grid[nr][nc] == 9
                    is_heat = (nr, nc) in heat_sources
                    is_visited = (nr, nc) in visited
                    if not (is_wall or in_pattern or is_heat or is_visited):
                        # Make the move
                        cur_r, cur_c = nr, nc
                        path_cells.append((cur_r, cur_c))
                        path_cell_colors.append(pattern_colors[path_color_index])
                        visited.add((cur_r, cur_c))
                        moved = True
                        break
                if success:
                    break
                if not moved:
                    # All directions blocked -> this placement fails; regenerate
                    success = False
                    break
            else:
                # Move forward under current direction and color
                cur_r, cur_c = nr, nc
                path_cells.append((cur_r, cur_c))
                path_cell_colors.append(pattern_colors[path_color_index])
                visited.add((cur_r, cur_c))

        if not success:
            # Path didn't exit or was stuck; try a new grid
            continue

        # 6) Build the output grid: walls (9) and the pattern strip remain unchanged. The rest
        #    of the background is overwritten with the heat map based on Manhattan distance
        #    to the nearest heat source (clamped to [1,9], with 0 replaced by 9 at distance 0).
        output_grid = [[0 for _ in range(grid_size)] for _ in range(grid_size)]
        for r in range(grid_size):
            for c in range(grid_size):
                if input_grid[r][c] == 9:
                    output_grid[r][c] = 9
                    continue
                if r in (0, 1) and c < pattern_width:
                    output_grid[r][c] = input_grid[r][c]
                    continue
                # Compute Manhattan distance to nearest heat source
                min_dist = min(abs(r - hr) + abs(c - hc) for (hr, hc) in heat_sources)
                output_grid[r][c] = max(1, 9 - min_dist)

        # 7) Overlay the path (it overrides the heat map). The path cells were recorded in path_cells
        #    with their associated path_cell_colors.
        for (coord, color) in zip(path_cells, path_cell_colors):
            r, c = coord
            output_grid[r][c] = color

        # Sanity checks: ensure input != output and the path did not overlap walls/heat/pattern
        if input_grid == output_grid:
            continue
        # All constraints satisfied for this attempt
        return {"input": input_grid, "output": output_grid}

    # If generation fails after many attempts, raise error
    raise RuntimeError("Failed to generate a valid grid after many attempts")



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable list-of-lists
    grid_size = len(input_grid)
    ing = [list(row) for row in input_grid]

    # 1) Identify the pattern strip in the top-left corner by scanning row 0 in 2-step blocks
    pattern_colors = []
    c = 0
    while c < grid_size and ing[0][c] != 0:
        pattern_colors.append(ing[0][c])
        c += 2
    pattern_len = len(pattern_colors)
    pattern_width = 2 * pattern_len

    # Build a set of pattern coordinates
    pattern_cells = set()
    for r in (0, 1):
        for cc in range(pattern_width):
            pattern_cells.add((r, cc))

    # 2) Find the source cell on the left edge (first open background space at col 0 starting at row 2)
    source_color = pattern_colors[0]
    source_r = None
    for r in range(2, grid_size):
        if ing[r][0] == source_color:
            source_r = r
            break
    if source_r is None:
        # Fallback: try to find any cell on col 0 with that color
        for r in range(grid_size):
            if ing[r][0] == source_color:
                source_r = r
                break
    # 3) Identify heat sources: cells with colors 1..4 outside the pattern area and not the source cell
    heat_sources = []
    for r in range(grid_size):
        for c in range(grid_size):
            val = ing[r][c]
            if 1 <= val <= 4 and (r, c) not in pattern_cells and not (r == source_r and c == 0):
                heat_sources.append((r, c))

    # 4) Prepare the baseline heat map output, keeping walls (9) and pattern cells unchanged
    output_grid = [[0 for _ in range(grid_size)] for _ in range(grid_size)]
    for r in range(grid_size):
        for c in range(grid_size):
            if ing[r][c] == 9:
                output_grid[r][c] = 9
            elif (r, c) in pattern_cells:
                output_grid[r][c] = ing[r][c]
            else:
                # Manhattan distance to nearest heat source
                if heat_sources:
                    min_dist = min(abs(r - hr) + abs(c - hc) for (hr, hc) in heat_sources)
                else:
                    min_dist = grid_size * 2
                output_grid[r][c] = max(1, 9 - min_dist)

    # 5) Simulate the bouncing path using the same rules as the generator
    dir_map = {1: (0, 1), 2: (-1, 0), 3: (0, -1), 4: (1, 0)}

    path_cells = [(source_r, 0)]
    path_cell_colors = [pattern_colors[0]]
    visited = set(path_cells)

    cur_r, cur_c = source_r, 0
    path_color_index = 0
    curr_dir = dir_map[pattern_colors[path_color_index]]

    max_steps = 2000
    steps = 0
    success = False
    while steps < max_steps:
        steps += 1
        nr = cur_r + curr_dir[0]
        nc = cur_c + curr_dir[1]
        # Exit condition
        if nr < 0 or nr >= grid_size or nc < 0 or nc >= grid_size:
            success = True
            break

        in_pattern = (nr in (0, 1) and nc < pattern_width)
        is_wall = ing[nr][nc] == 9
        is_heat = (nr, nc) in heat_sources
        is_visited = (nr, nc) in visited

        if is_wall or in_pattern or is_heat or is_visited:
            moved = False
            for _ in range(len(pattern_colors)):
                path_color_index = (path_color_index + 1) % len(pattern_colors)
                curr_dir = dir_map[pattern_colors[path_color_index]]
                nr = cur_r + curr_dir[0]
                nc = cur_c + curr_dir[1]
                if nr < 0 or nr >= grid_size or nc < 0 or nc >= grid_size:
                    success = True
                    moved = False
                    break
                in_pattern = (nr in (0, 1) and nc < pattern_width)
                is_wall = ing[nr][nc] == 9
                is_heat = (nr, nc) in heat_sources
                is_visited = (nr, nc) in visited
                if not (is_wall or in_pattern or is_heat or is_visited):
                    cur_r, cur_c = nr, nc
                    path_cells.append((cur_r, cur_c))
                    path_cell_colors.append(pattern_colors[path_color_index])
                    visited.add((cur_r, cur_c))
                    moved = True
                    break
            if success:
                break
            if not moved:
                # Stuck: give up (generator should avoid producing such cases)
                break
        else:
            cur_r, cur_c = nr, nc
            path_cells.append((cur_r, cur_c))
            path_cell_colors.append(pattern_colors[path_color_index])
            visited.add((cur_r, cur_c))

    # 6) Overlay the path on top of the heat map
    for (coord, color) in zip(path_cells, path_cell_colors):
        r, c = coord
        output_grid[r][c] = color

    return output_grid

