# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: b1646752
Difficulty: very hard

=== Tags ===
- Deterministic update
- Phase transition path
- Sand simulation
- Project shadow

=== Description ===
# Sandflow Phase Shadows  Input grids are 20×20 or larger with a uniform
background color (0). Overlaid on this background are three distinct elements:
1. **Sand clusters (color 1):** Connected 4-neighbor groups (size 1–5)
positioned exclusively in the top half of the grid (rows 0–9 for 20×20 grids).
Each cluster is isolated from obstacles and other clusters.  2. **Obstacles
(color 2):** Horizontal or vertical line segments of 1–3 cells, placed such that
they do not touch sand clusters or other obstacles. Obstacles may span multiple
rows or columns but never form closed shapes.  3. **No other elements** are
present in the input grid.  The transformation follows these deterministic
rules:  1. **Sand Movement:** Each sand cell moves south (down) until blocked by
an obstacle or grid boundary. If blocked south, it attempts to move west (left)
if the cell is background (0). If west is blocked, it moves east (right) if
possible. Movement stops when no valid direction remains. All sand cells in a
cluster move simultaneously following this rule.  2. **Phase Transition Path:**
The path taken by each sand cluster (excluding the final position) is replaced
with **shadow colors**. The shadow color sequence cycles through {4, 5, 6, 7} in
strict order based on the step count:    - First movement step → color 4    -
Second movement step → color 5    - Third movement step → color 6    - Fourth
movement step → color 7    - Fifth step → color 4 (cycle repeats)  3. **Shadow
Projection:** The shadow path must never overlap obstacles or other shadow
paths. If a movement would cause a conflict, the sand moves in the next valid
direction (west → east) without changing the shadow sequence. Final sand
positions retain color 1.  4. **Deterministic Update:** The movement order
(south → west → east) and shadow color cycling are fixed for all grids. No
external parameters influence the transformation.  Output grids contain: - Final
sand positions (color 1) - Movement paths replaced with sequential shadow colors
(4–7) - Obstacles unchanged (color 2) - Background unchanged (color 0)  This
task requires complex path prediction, direction prioritization, and sequential
color mapping across multiple sand clusters, making it very hard due to the
interplay of movement rules, shadow sequencing, and obstacle navigation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from typing import List, Tuple, Dict


def generate() -> Dict[str, List[List[int]]]:
    """
    Generate a 20x20 grid with sand clusters (color 1) in the top half and obstacles (color 2)
    in the bottom half. Sand clusters are vertical contiguous groups of size 1..5 located
    in rows 0..9, and obstacles are segments of length 1..3 placed in rows 10..19.

    The output grid is produced by simulating deterministic cluster-by-cluster movement
    with the rules described in the task. Shadows (4..7) are recorded for the intermediate
    cells visited by each cluster on each movement step (step->color: 1->4, 2->5, ...).
    Final sand positions are color 1 and overwrite any shadows at those cells.
    """
    size = 20
    # Initialize empty grid
    grid = [[0 for _ in range(size)] for _ in range(size)]

    # Helper sets for fast membership checks
    obstacle_cells = set()

    # Place obstacles in bottom half (rows 10..size-1). Ensure obstacles do not touch each other (4-neighbor).
    obstacle_segments = random.randint(6, 12)
    tries = 0
    while len(obstacle_cells) < obstacle_segments and tries < 2000:
        tries += 1
        horiz = random.choice([True, False])
        length = random.randint(1, 3)
        if horiz:
            row = random.randint(size // 2, size - 1)
            col_start = random.randint(0, size - length)
            segment = [(row, c) for c in range(col_start, col_start + length)]
        else:
            col = random.randint(0, size - 1)
            row_start = random.randint(size // 2, size - length)
            segment = [(r, col) for r in range(row_start, row_start + length)]
        # Check not adjacent (4-neighbor) to existing obstacles
        ok = True
        for (r, c) in segment:
            if grid[r][c] != 0:
                ok = False
                break
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < size and 0 <= nc < size and (nr, nc) in obstacle_cells:
                    ok = False
                    break
            if not ok:
                break
        if not ok:
            continue
        # Place the segment
        for (r, c) in segment:
            grid[r][c] = 2
            obstacle_cells.add((r, c))

    # Place vertical sand clusters in top half (rows 0..9). Clusters are vertical contiguous groups size 1..5
    sand_clusters: List[List[Tuple[int, int]]] = []
    sand_cells = set()
    num_clusters = random.randint(4, 8)
    tries = 0

    while len(sand_clusters) < num_clusters and tries < 2000:
        tries += 1
        c = random.randint(0, size - 1)
        cluster_size = random.randint(1, 5)
        # top row such that bottom of cluster <= 9 (top half)
        max_top = (size // 2) - cluster_size
        if max_top < 0:
            continue
        r0 = random.randint(0, max_top)
        coords = [(r0 + i, c) for i in range(cluster_size)]
        # Ensure cells are free and do not touch other sand clusters (4-neighbor) or obstacles
        ok = True
        for (r, col) in coords:
            if grid[r][col] != 0:
                ok = False
                break
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, col + dc
                if 0 <= nr < size and 0 <= nc < size:
                    if (nr, nc) in sand_cells or (nr, nc) in obstacle_cells:
                        ok = False
                        break
            if not ok:
                break
        if not ok:
            continue
        # Ensure immediate below bottom cell is free so the cluster can move at least one step
        bottom_r = coords[-1][0]
        below_r = bottom_r + 1
        if below_r >= size:
            # if bottom of grid, cluster cannot move; reject placement
            continue
        if grid[below_r][c] != 0:
            # blocked immediately by obstacle; try different place
            continue
        # Also ensure clusters do not sit in adjacent columns to other clusters to reduce inter-cluster interference
        too_close = False
        for other in sand_clusters:
            other_cols = {col for (_, col) in other}
            if any(abs(c - oc) <= 1 for oc in other_cols):
                too_close = True
                break
        if too_close:
            continue
        # Place cluster
        for (r, col) in coords:
            grid[r][col] = 1
            sand_cells.add((r, col))
        sand_clusters.append(coords)

    # If we failed to create any cluster (extremely unlikely), fall back to a simple single-cell cluster
    if len(sand_clusters) == 0:
        r, c = 0, 0
        grid[r][c] = 1
        sand_clusters.append([(r, c)])
        sand_cells.add((r, c))

    # Prepare to simulate movement and create the output grid
    output = [row[:] for row in grid]

    # Keep track of positions that have become final sand (processed clusters)
    final_sand_positions = set()
    # Keep track of shadowed positions (to block movement into them)
    shadows: Dict[Tuple[int, int], int] = {}

    # For determinism process clusters sorted by their leftmost column then top row
    def cluster_key(cluster):
        cols = [c for (_, c) in cluster]
        rows = [r for (r, _) in cluster]
        return (min(cols), min(rows))

    sand_initial_positions = set(sand_cells)
    sand_clusters_sorted = sorted(sand_clusters, key=cluster_key)

    for cluster in sand_clusters_sorted:
        curr = set(cluster)
        step = 0
        while True:
            step += 1
            # blocked cells are obstacles, already-shadowed cells, already-finalized sand, and initial sand of other clusters
            other_initial_sand = sand_initial_positions - curr
            blocked = set(obstacle_cells) | set(shadows.keys()) | final_sand_positions | other_initial_sand
            # Determine target for each cell in the cluster (simultaneous decision)
            proposed = {}
            for (r, c) in curr:
                # try south
                moved = False
                for dr, dc in [(1, 0), (0, -1), (0, 1)]:  # south, west, east
                    nr, nc = r + dr, c + dc
                    if not (0 <= nr < size and 0 <= nc < size):
                        continue
                    if (nr, nc) in blocked:
                        continue
                    # It's allowed even if (nr,nc) is currently occupied by another cell of the same cluster
                    proposed[(r, c)] = (nr, nc)
                    moved = True
                    break
                if not moved:
                    proposed[(r, c)] = (r, c)
            # Resolve collisions where two or more cells propose the same target (and that target is not one of their original positions)
            inv = {}
            for src, tgt in proposed.items():
                inv.setdefault(tgt, []).append(src)
            collisions = [tgt for tgt, srcs in inv.items() if len(srcs) > 1 and any(tgt != s for s in srcs)]
            if collisions:
                for tgt in collisions:
                    for src in inv[tgt]:
                        # make conflicting sources stay put
                        proposed[src] = src
            new_positions = set(proposed.values())
            if new_positions == curr:
                # no movement this step -> cluster is final
                break
            # Assign shadows for these newly occupied cells for this step
            color = 4 + ((step - 1) % 4)
            for pos in new_positions:
                # Do not overwrite obstacle or final sand; blocked check above should have prevented this
                if pos in final_sand_positions:
                    continue
                shadows[pos] = color
                output[pos[0]][pos[1]] = color
            # Update current cluster positions and continue
            curr = new_positions
        # Mark final positions as sand (color 1), overwrite any shadows there
        for (r, c) in curr:
            output[r][c] = 1
            final_sand_positions.add((r, c))
            if (r, c) in shadows:
                del shadows[(r, c)]

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from typing import List, Tuple, Dict


def p(input_grid: Tuple[Tuple[int, ...], ...]) -> List[List[int]]:
    """
    Reconstruct the output by simulating sand cluster movement according to the task rules.

    This implementation mirrors the generator's deterministic rules:
    - Identify sand clusters (4-neighbor connected components of color 1).
    - Process clusters in order (leftmost column then top row).
    - At each step, each cell attempts to move south, then west, then east (if the target is not
      an obstacle, not already shadowed, and not occupied by final sand or other clusters' initial sand).
    - Assign shadow colors 4..7 for the intermediate positions visited at each step (cycling every 4 steps).
    - Final positions are color 1.
    """
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    size = len(grid)
    output = [row[:] for row in grid]

    # Identify obstacle and sand positions
    obstacle_cells = set()
    sand_initial_positions = set()
    for r in range(size):
        for c in range(size):
            if grid[r][c] == 2:
                obstacle_cells.add((r, c))
            elif grid[r][c] == 1:
                sand_initial_positions.add((r, c))

    # Find connected sand clusters (4-neighbor)
    clusters = []
    remaining = set(sand_initial_positions)
    while remaining:
        start = next(iter(remaining))
        stack = [start]
        comp = set()
        while stack:
            v = stack.pop()
            if v in comp:
                continue
            comp.add(v)
            r, c = v
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if (nr, nc) in remaining and (nr, nc) not in comp:
                    stack.append((nr, nc))
        clusters.append(sorted(list(comp)))
        remaining -= comp

    # Process clusters in deterministic order: leftmost column then top row
    def cluster_key(cluster):
        cols = [c for (_, c) in cluster]
        rows = [r for (r, _) in cluster]
        return (min(cols), min(rows))

    clusters_sorted = sorted(clusters, key=cluster_key)

    shadows: Dict[Tuple[int, int], int] = {}
    final_sand_positions = set()

    for cluster in clusters_sorted:
        curr = set(cluster)
        step = 0
        while True:
            step += 1
            other_initial = sand_initial_positions - curr
            blocked = set(obstacle_cells) | set(shadows.keys()) | final_sand_positions | other_initial
            proposed: Dict[Tuple[int, int], Tuple[int, int]] = {}
            for (r, c) in curr:
                moved = False
                # south, west, east
                for dr, dc in [(1, 0), (0, -1), (0, 1)]:
                    nr, nc = r + dr, c + dc
                    if not (0 <= nr < size and 0 <= nc < size):
                        continue
                    if (nr, nc) in blocked:
                        continue
                    proposed[(r, c)] = (nr, nc)
                    moved = True
                    break
                if not moved:
                    proposed[(r, c)] = (r, c)
            # Resolve collisions
            inv: Dict[Tuple[int, int], List[Tuple[int, int]]] = {}
            for src, tgt in proposed.items():
                inv.setdefault(tgt, []).append(src)
            collisions = [tgt for tgt, srcs in inv.items() if len(srcs) > 1 and any(tgt != s for s in srcs)]
            if collisions:
                for tgt in collisions:
                    for src in inv[tgt]:
                        proposed[src] = src
            new_positions = set(proposed.values())
            if new_positions == curr:
                break
            color = 4 + ((step - 1) % 4)
            for pos in new_positions:
                # do not overwrite obstacles or already-final sand
                if pos in final_sand_positions:
                    continue
                shadows[pos] = color
                output[pos[0]][pos[1]] = color
            curr = new_positions
        # finalize cluster
        for pos in curr:
            output[pos[0]][pos[1]] = 1
            final_sand_positions.add(pos)
            if pos in shadows:
                del shadows[pos]

    return output

