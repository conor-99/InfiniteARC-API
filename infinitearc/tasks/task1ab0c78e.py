# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 1ab0c78e
Difficulty: hard

=== Tags ===
- Cyclic painting
- Pattern alignment
- Alternating direction
- Oscillating rule

=== Description ===
Input grids consist of a 2D array of colored cells, where each row contains a
distinct pattern of colors. The transformation requires applying a cyclic shift
to each row based on its index parity. Specifically, for even-indexed rows (0,
2, 4, ...), the row elements undergo a left cyclic shift (each element moves one
position left, with the first element wrapping to the end). For odd-indexed rows
(1, 3, 5, ...), the row elements undergo a right cyclic shift (each element
moves one position right, with the last element wrapping to the front). The
output grid is formed by applying these alternating shifts to all rows of the
input grid. The key insight is recognizing the alternating direction pattern
(left/right) tied to row index parity, which creates a visually coherent
alignment of the color patterns across the grid. This task demands both pattern
recognition of the alternating shift direction and precise application of the
cyclic transformation rules to every row.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    while True:
        width = random.randint(1, 30)
        height = random.randint(1, 30)
        input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
        output_grid = []
        for i in range(height):
            if i % 2 == 0:
                output_grid.append(input_grid[i][1:] + [input_grid[i][0]])
            else:
                output_grid.append([input_grid[i][-1]] + input_grid[i][:-1])
        if input_grid == output_grid:
            continue
        return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    output_list = []
    for i, row in enumerate(input_list):
        if i % 2 == 0:
            output_list.append(row[1:] + [row[0]])
        else:
            output_list.append([row[-1]] + row[:-1])
    return output_list
