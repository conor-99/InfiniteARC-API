# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: f28137f0
Difficulty: hard

=== Tags ===
- Pattern guided construction
- Detect symmetry

=== Description ===
Input grids feature a large grid (typically 20×20 or larger) containing two key
components: a pattern strip and scattered isolated cells. The pattern strip is
located in the top-left corner and consists of a horizontal sequence of 2×2
uniform-colored blocks (e.g., all red, all blue) arranged in a repeating cyclic
color pattern (e.g., red → blue → green → red → blue → green...). The isolated
cells are single-colored cells (each a unique color not present in the pattern
strip) scattered throughout the grid, surrounded by background (color 0), and
not connected to any larger structure.   The output grid must extend the input
by reflecting each isolated cell across a symmetry axis determined by the *first
color* in the pattern strip. The axis type is visually indicated by this color:
red implies vertical reflection (left-right mirroring), blue implies horizontal
reflection (top-bottom mirroring), and green implies diagonal reflection
(mirroring across the top-left to bottom-right diagonal). Each reflection must
adopt the *next color* in the pattern strip's cycle (advancing sequentially,
cycling through the sequence), and the reflected cell must not overlap with any
existing element (pattern strip, original isolated cells, or other reflections).
The pattern strip remains unchanged, and background cells remain color 0.   This
task requires detecting the symmetry axis from the visual cue of the pattern
strip's first color, tracking the cyclic color progression for each reflection,
and ensuring precise geometric reflection without overlap. The complexity arises
from the need to simultaneously apply multiple spatial transformations
(reflection type) and color sequence logic across all isolated cells, with the
symmetry axis being visually determined rather than numerically encoded.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # square grid, typical size 20..25
    size = random.randint(20, 25)
    grid = [[0 for _ in range(size)] for _ in range(size)]

    # Axis-determining colors: red=2 (vertical), blue=1 (horizontal), green=3 (diagonal)
    axis_colors = [2, 1, 3]
    C = random.choice(axis_colors)

    # Build a 3-color cycle starting with C
    remaining = [c for c in range(1, 10) if c != C]
    C1 = random.choice(remaining)
    remaining2 = [c for c in remaining if c != C1]
    C2 = random.choice(remaining2)
    cycle = [C, C1, C2]

    # Decide how many 2x2 blocks to place (must fit horizontally)
    max_blocks = size // 2
    block_count = random.randint(3, min(6, max_blocks))

    # Place the horizontal sequence of 2x2 uniform-colored blocks in the top-left corner
    for i in range(block_count):
        color = cycle[i % len(cycle)]
        for r in (0, 1):
            for c in (2 * i, 2 * i + 1):
                grid[r][c] = color

    # Reserve cells that are occupied by the pattern so we don't place isolated cells there
    reserved = set()
    for r in range(2):
        for c in range(2 * block_count):
            reserved.add((r, c))

    # Place a random number of isolated single cells (each a unique color not in the cycle)
    iso_count = random.randint(2, 6)
    isolated_cells = []

    # We'll also reserve the reflection targets so reflections do not overlap
    reserved_reflections = set()

    tries = 0
    max_tries = 2000
    while len(isolated_cells) < iso_count and tries < max_tries:
        tries += 1
        r = random.randint(0, size - 1)
        c = random.randint(0, size - 1)

        # Avoid pattern area and already reserved cells
        if (r, c) in reserved or (r, c) in reserved_reflections:
            continue

        # Ensure the chosen position and its 4-neighbors are background (0) and not reserved
        ok = True
        for dr, dc in [(0, 0), (1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < size and 0 <= nc < size:
                if (nr, nc) in reserved or (nr, nc) in reserved_reflections:
                    ok = False
                    break
                if grid[nr][nc] != 0:
                    ok = False
                    break
        if not ok:
            continue

        # Compute reflection target based on C
        if C == 2:            # red -> vertical reflection (left-right mirror)
            r_ref, c_ref = r, size - 1 - c
        elif C == 1:          # blue -> horizontal reflection (top-bottom mirror)
            r_ref, c_ref = size - 1 - r, c
        else:                 # C == 3 -> green -> diagonal reflection across main diagonal
            r_ref, c_ref = c, r

        if not (0 <= r_ref < size and 0 <= c_ref < size):
            continue

        # Reflection must not coincide with the original cell
        if (r_ref, c_ref) == (r, c):
            continue

        # Reflection must be free (not part of pattern or previously reserved)
        if (r_ref, c_ref) in reserved or (r_ref, c_ref) in reserved_reflections:
            continue
        if grid[r_ref][c_ref] != 0:
            continue

        # Choose a color for the isolated cell that is not in the cycle and not used yet
        possible_colors = [col for col in range(1, 10) if col not in cycle and col not in [x[2] for x in isolated_cells]]
        if not possible_colors:
            break
        D = random.choice(possible_colors)

        # Reserve original and reflected targets
        reserved_reflections.add((r_ref, c_ref))
        reserved.add((r, c))
        isolated_cells.append((r, c, D))

    # Sort isolated cells in reading order so the mapping to the cycle is deterministic
    isolated_cells.sort(key=lambda x: (x[0], x[1]))

    # Build input grid by placing isolated cells
    input_grid = [row[:] for row in grid]
    for (r, c, D) in isolated_cells:
        input_grid[r][c] = D

    # Build output grid by placing reflections using the next color in the cycle
    output_grid = [row[:] for row in input_grid]
    for idx, (r, c, D) in enumerate(isolated_cells):
        if C == 2:
            r_ref, c_ref = r, size - 1 - c
        elif C == 1:
            r_ref, c_ref = size - 1 - r, c
        else:
            r_ref, c_ref = c, r
        next_color = cycle[(idx + 1) % len(cycle)]
        output_grid[r_ref][c_ref] = next_color

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0]) if h > 0 else 0

    # Detect 2x2 blocks in the top-left corner to recover the cycle
    block_colors = []
    c = 0
    while c + 1 < w and h >= 2:
        col0 = c
        col1 = c + 1
        # Check whether positions (0,col0),(0,col1),(1,col0),(1,col1) form a uniform, non-zero 2x2 block
        val = grid[0][col0]
        if val == 0:
            break
        if grid[0][col1] != val or grid[1][col0] != val or grid[1][col1] != val:
            break
        block_colors.append(val)
        c += 2

    # Find minimal repeating cycle in block_colors
    def minimal_cycle(seq):
        n = len(seq)
        if n == 0:
            return []
        for p in range(1, n + 1):
            ok = True
            for i in range(n):
                if seq[i] != seq[i % p]:
                    ok = False
                    break
            if ok:
                return seq[:p]
        return seq

    cycle = minimal_cycle(block_colors)

    # Determine axis from the first color in the cycle
    C = cycle[0] if len(cycle) > 0 else None

    # Collect isolated single cells (single non-zero cells whose 4-neighbors are zero)
    isolated = []
    for r in range(h):
        for c in range(w):
            val = grid[r][c]
            if val == 0:
                continue
            # Skip pattern area (2x2 blocks in top-left) because those are not isolated
            if r < 2 and c < 2 * len(block_colors):
                continue
            # Check 4-neighbors for being background (0) or out-of-bounds
            neighbors_ok = True
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < h and 0 <= nc < w:
                    if grid[nr][nc] != 0:
                        neighbors_ok = False
                        break
            if neighbors_ok:
                isolated.append((r, c, val))

    # Ensure isolated cells are in reading order
    isolated.sort(key=lambda x: (x[0], x[1]))

    # Create output grid and place reflections
    out = [row[:] for row in grid]
    for idx, (r, c, val) in enumerate(isolated):
        if C == 2:            # red -> vertical
            r_ref, c_ref = r, w - 1 - c
        elif C == 1:          # blue -> horizontal
            r_ref, c_ref = h - 1 - r, c
        else:                 # green(3) -> diagonal
            r_ref, c_ref = c, r
        # Determine next color in cycle
        if len(cycle) == 0:
            continue
        next_color = cycle[(idx + 1) % len(cycle)]
        # Place the reflected color
        out[r_ref][c_ref] = next_color

    return out

