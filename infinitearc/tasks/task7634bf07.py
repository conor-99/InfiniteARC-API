# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 7634bf07
Difficulty: insane

=== Tags ===
- Rule gate simulation
- Exclusive or coloring
- Path following
- Expand to square canvas
- Image repetition

=== Description ===
Input grids are rectangular (height H < width W) with a continuous path
traversing from top-left to bottom-right, composed of non-background cells
(color 0) that change color at rule gate locations. Rule gates are uniquely
colored cells (e.g., red, blue) positioned along the path, each applying an XOR
operation between the current path color and the gate's color to determine the
next color. The grid also contains a repeating 2x2 image pattern (e.g., a
sequence of four distinct colors) spaced evenly across the grid, visible in both
path and background regions.   The output grid is a square canvas of size W×W
(expanding height to match width). The top H rows replicate the input grid
exactly. The bottom (W−H) rows contain a transformed repetition of the input's
entire pattern: every cell's color is XORed with a fixed "repetition key" color
(e.g., orange=7), while preserving the relative positions of the path and 2x2
image pattern. The path continues from its endpoint in the input, maintaining
its movement direction (e.g., rightward), and applies XOR rules at rule gates
encountered in the repeated section. The repeating image pattern's colors are
also XORed with the repetition key in the output, ensuring consistent structural
repetition with color transformation. The task requires simultaneously tracking
path direction, applying sequential XOR operations at gates, and correctly
transforming all grid elements in the repeated section while maintaining visual
consistency.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    H = random.randint(3, 10)
    W = random.randint(H + 1, 20)
    colors = random.sample(range(1, 8), 4)
    pattern = [[colors[0], colors[1]], [colors[2], colors[3]]]
    input_grid = grid(W, H, 0)
    for i in range(H):
        for j in range(W):
            input_grid[i][j] = pattern[i % 2][j % 2]
    
    for j in range(W - 1):
        i = 0
        current = input_grid[i][j]
        next_val = input_grid[i][j + 1]
        if current != next_val:
            input_grid[i][j] = current ^ next_val
    
    for i in range(H - 1):
        j = W - 1
        current = input_grid[i][j]
        next_val = input_grid[i + 1][j]
        if current != next_val:
            input_grid[i][j] = current ^ next_val
    
    key = 7
    output_grid = grid(W, W, 0)
    for i in range(H):
        output_grid[i] = input_grid[i][:]
    for i in range(H, W):
        for j in range(W):
            output_grid[i][j] = input_grid[i % H][j] ^ key
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    H = len(input_list)
    W = len(input_list[0])
    key = 7
    output = [[0] * W for _ in range(W)]
    
    for i in range(H):
        for j in range(W):
            output[i][j] = input_list[i][j]
    
    for i in range(H, W):
        for j in range(W):
            output[i][j] = input_list[i % H][j] ^ key
    
    return tuple(tuple(row) for row in output)
