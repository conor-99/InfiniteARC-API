# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: c0f9c0b8
Difficulty: hard

=== Tags ===
- Spring chain
- Reflective maze
- Multi condition recolor
- Meta rule learning
- Color palette

=== Description ===
Reflective Spring Maze is a hard ARC task where input grids depict a maze-like
structure on a background (color 0), featuring colored tiles (1-9) that act as
reflective springs. Each spring color corresponds to a unique directional
reflection rule, but the exact rule is not directly stated and must be deduced
through meta rule learning from the input-output examples. The maze includes a
start point (typically a single cell with a distinct marker color) and an
endpoint. The path begins at the start, moving in a fixed initial direction
(e.g., right), and reflects off spring tiles according to their color-specific
rules. When a spring is hit, the path direction changes based on the spring's
color and the current movement direction, with the reflection behavior requiring
the solver to infer a hidden mapping (e.g., color 1 reflects 90° clockwise,
color 2 reflects 90° counterclockwise, but this must be learned from the
examples). The output grid retains all spring tiles and the background but draws
the path as a continuous line with each segment colored according to the last
spring color encountered during reflection. Path segments do not overwrite
spring tiles or their embedded colors. The maze geometry is complex, with non-
linear paths, multiple overlapping reflection points, and a unique solution path
that adheres to all spring reflection rules without loop formation. The task
demands recognition of the color-direction mapping through abstract reasoning,
making it challenging due to the need for meta rule extraction rather than
direct pattern matching.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, randint, sample

START_COLOR = 9
END_COLOR = 8
MARKER_COLOR = 7
SPRING_POOL = list(range(1, 7))  # allowed spring colors: 1..6
LEGEND_WIDTH = 5


def generate():
    """Generate an ARC-style input/output pair for the Reflective Spring Maze task.

    The generator places a small legend in the top-left that maps spring colors
    to reflection deltas. Start (9) and end (8) are placed away from the
    legend. The path is simulated from the start heading right. Springs are
    placed dynamically during the simulation so that when a moving agent hits a
    spring its direction changes by that spring's mapped delta. The output
    draws the traversed path: non-spring cells are colored with the most
    recently encountered spring color. Springs, legend, start and end are
    preserved in the output.
    """
    attempts = 0
    # Limit attempts to avoid infinite loops in pathological cases.
    while attempts < 400:
        attempts += 1
        width = randint(10, 25)
        height = randint(10, 25)
        # Number of distinct spring colors used in this instance
        k = randint(2, min(4, len(SPRING_POOL)))
        spring_colors = sample(SPRING_POOL, k)

        # Create a random mapping from spring color -> delta, ensuring both left and right turns
        deltas_list = [-1, 0, 1, 2]
        mapping = {c: random.choice(deltas_list) for c in spring_colors}
        # Guarantee at least one left (-1) and one right (+1) exist so 90-degree turns are possible.
        if not any(v == 1 for v in mapping.values()):
            mapping[random.choice(spring_colors)] = 1
        if not any(v == -1 for v in mapping.values()):
            mapping[random.choice(spring_colors)] = -1

        # Build blank grid and place the legend (top-left). Legend rows: [spring_color, marker columns...]
        ingrid = grid(width, height, 0)
        pos_map = {-1: 0, 0: 1, 1: 2, 2: 3}
        for r, c in enumerate(spring_colors):
            if r >= height:  # extremely unlikely when height small
                break
            ingrid[r][0] = c
            pos = pos_map[mapping[c]]
            # Place marker 7 in columns 1..4 (so legend width is 5)
            ingrid[r][1 + pos] = MARKER_COLOR

        # Ensure there is room below the legend to place the start/end and a path
        min_row = k + 2
        if min_row >= height - 2 or LEGEND_WIDTH >= width - 2:
            continue

        # Choose start and end positions away from the legend area
        sx = randint(min_row, height - 3)
        sy = randint(LEGEND_WIDTH + 1, width - 3)
        ex = randint(min_row, height - 3)
        ey = randint(LEGEND_WIDTH + 1, width - 3)
        if (sx, sy) == (ex, ey):
            continue

        # Simulate the path dynamically using the reflection rules
        dx = [0, 1, 0, -1]  # right, down, left, up
        dy = [1, 0, -1, 0]
        current = (sx, sy)
        direction = 0  # start heading right (fixed as per task description)
        path = [current]
        visited = set([current])
        springs_pos = {}  # maps (r,c) -> color placed there

        max_steps = width * height * 2
        step_count = 0
        success = False

        for _ in range(max_steps):
            # Compute how many cells we can move forward in current direction before hitting boundary/visited/legend
            Lmax = 0
            tx, ty = current
            while True:
                nx = tx + dx[direction]
                ny = ty + dy[direction]
                if not (0 <= nx < height and 0 <= ny < width):
                    break
                if (nx, ny) in visited:
                    break
                # do not walk into the legend area
                if nx < k and ny < LEGEND_WIDTH:
                    break
                tx, ty = nx, ny
                Lmax += 1

            # If we cannot move forward at all, we must place a spring here (unless it's the start)
            if Lmax == 0:
                if current == (sx, sy):
                    # start is stuck; try a different instance
                    break
                # compute candidate new directions produced by available spring colors
                dir_options = {}
                for c in spring_colors:
                    nd = (direction + mapping[c]) % 4
                    dir_options.setdefault(nd, []).append(c)
                # choose any new direction that has at least one free step
                viable = []
                for nd, cols in dir_options.items():
                    nx = current[0] + dx[nd]
                    ny = current[1] + dy[nd]
                    if 0 <= nx < height and 0 <= ny < width and (nx, ny) not in visited and not (nx < k and ny < LEGEND_WIDTH):
                        viable.append((nd, cols))
                if not viable:
                    break
                nd, cols = random.choice(viable)
                chosen_color = random.choice(cols)
                springs_pos[current] = chosen_color
                direction = nd
                continue

            # Choose how many steps to take (but prefer short segments to create turns)
            L = randint(1, min(4, Lmax))

            # If the end lies directly ahead and is within Lmax, move exactly to end
            if direction == 0 and ex == current[0] and ey > current[1]:
                dist = ey - current[1]
                if dist <= Lmax:
                    L = dist
            if direction == 2 and ex == current[0] and ey < current[1]:
                dist = current[1] - ey
                if dist <= Lmax:
                    L = dist
            if direction == 1 and ey == current[1] and ex > current[0]:
                dist = ex - current[0]
                if dist <= Lmax:
                    L = dist
            if direction == 3 and ey == current[1] and ex < current[0]:
                dist = current[0] - ex
                if dist <= Lmax:
                    L = dist

            # Step forward L cells
            for i in range(L):
                nx = current[0] + dx[direction]
                ny = current[1] + dy[direction]
                current = (nx, ny)
                path.append(current)
                visited.add(current)
                step_count += 1
                if current == (ex, ey):
                    success = True
                    break
            if success:
                break

            # Place a spring at the current cell to change direction
            dir_options = {}
            for c in spring_colors:
                nd = (direction + mapping[c]) % 4
                dir_options.setdefault(nd, []).append(c)

            # Prefer a direction that moves closer to the end
            def manh(p):
                return abs(p[0] - ex) + abs(p[1] - ey)

            better = []
            for nd, cols in dir_options.items():
                nx = current[0] + dx[nd]
                ny = current[1] + dy[nd]
                if not (0 <= nx < height and 0 <= ny < width):
                    continue
                if (nx, ny) in visited:
                    continue
                if nx < k and ny < LEGEND_WIDTH:
                    continue
                if manh((nx, ny)) < manh(current):
                    better.append((nd, cols))

            if better:
                nd, cols = random.choice(better)
            else:
                viable = []
                for nd, cols in dir_options.items():
                    nx = current[0] + dx[nd]
                    ny = current[1] + dy[nd]
                    if 0 <= nx < height and 0 <= ny < width and (nx, ny) not in visited and not (nx < k and ny < LEGEND_WIDTH):
                        viable.append((nd, cols))
                if not viable:
                    break
                nd, cols = random.choice(viable)

            chosen_color = random.choice(cols)
            # Do not place a spring on start or end
            if current == (sx, sy) or current == (ex, ey):
                break
            springs_pos[current] = chosen_color
            direction = nd

        if not success:
            continue

        # Stamp springs, start and end into the input grid, validating positions
        invalid = False
        for (rpos, cpos), color in list(springs_pos.items()):
            if rpos < k and cpos < LEGEND_WIDTH:
                invalid = True
                break
            if (rpos, cpos) == (sx, sy) or (rpos, cpos) == (ex, ey):
                invalid = True
                break
            ingrid[rpos][cpos] = color
        if invalid:
            continue

        ingrid[sx][sy] = START_COLOR
        ingrid[ex][ey] = END_COLOR

        # Build the output by coloring path segments with the most recent spring color seen
        output = [row[:] for row in ingrid]
        last = None
        # Skip the very first cell (start). Color subsequent path cells unless they are springs / special.
        for pos in path[1:]:
            if pos in springs_pos:
                last = springs_pos[pos]
                continue
            r, c = pos
            if (r, c) == (ex, ey):
                break
            # Do not overwrite legend or start/end or springs; only color empty path cells
            if output[r][c] == 0 and last is not None:
                output[r][c] = last

        # Ensure the input and output differ and that at least one path cell was colored
        if output == ingrid:
            continue

        return {"input": ingrid, "output": output}

    # Fallback deterministic small instance (should rarely be used)
    ingrid = grid(10, 10, 0)
    ingrid[2][2] = 1
    out = [row[:] for row in ingrid]
    out[2][3] = 1
    return {"input": ingrid, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Decode legend: top-left region rows with a spring color in column 0 and a marker (7) in columns 1..4
    mapping = {}
    max_legend_rows = min(6, height)
    for r in range(max_legend_rows):
        val = grid[r][0]
        if val >= 1 and val <= 6:
            found = False
            for poscol in range(1, 5):
                if grid[r][poscol] == 7:
                    pos_index = poscol - 1
                    if pos_index == 0:
                        delta = -1
                    elif pos_index == 1:
                        delta = 0
                    elif pos_index == 2:
                        delta = 1
                    else:
                        delta = 2
                    mapping[val] = delta
                    found = True
                    break
            if not found:
                # Not a legend row despite a color in column 0; stop reading legend
                break
        else:
            # blank or other content; continue scanning in case legend rows are not contiguous
            continue

    # Find start (9) and end (8)
    start = None
    end = None
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 9:
                start = (r, c)
            elif grid[r][c] == 8:
                end = (r, c)
    if start is None or end is None:
        return [row[:] for row in grid]

    # Movement vectors: 0=right,1=down,2=left,3=up
    dx = [0, 1, 0, -1]
    dy = [1, 0, -1, 0]

    # Simulate the path starting heading right
    x, y = start
    direction = 0
    out = [row[:] for row in grid]
    last_spring = None

    steps = 0
    max_steps = height * width * 5
    while (x, y) != end and steps < max_steps:
        nx = x + dx[direction]
        ny = y + dy[direction]
        if not (0 <= nx < height and 0 <= ny < width):
            # If the path would leave the grid then something is wrong; stop to avoid infinite loop
            break
        val = grid[nx][ny]
        # If this cell is a spring, change direction and remember its color
        if val in mapping:
            last_spring = val
            direction = (direction + mapping[val]) % 4
        else:
            # Color path cells using the last seen spring color (do not overwrite special tiles)
            if (nx, ny) != start and (nx, ny) != end and out[nx][ny] == 0 and last_spring is not None:
                out[nx][ny] = last_spring
        x, y = nx, ny
        steps += 1

    return out

