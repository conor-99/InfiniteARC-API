# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: aad933e6
Difficulty: insane

=== Tags ===
- Inference from demonstration
- State transfer chain
- Paint outer ring
- Reorder blocks by size

=== Description ===
Input grids feature multiple disconnected, solid-colored regions (blocks) on a
uniform background. Each region is a contiguous block of a single color, with no
two blocks touching or overlapping. The output grid requires two sequential
transformations: first, reorder all blocks by size (smallest to largest) and
arrange them in row-major order (left to right, top to bottom) starting from the
top-left corner, preserving their original shapes and colors while maintaining
background separation; second, paint the outermost perimeter (border) of the
grid with the color of the smallest block (the first block in the sorted order),
overwriting only background cells along the border while preserving existing
block colors. This transformation necessitates inferring both the size-based
reordering logic and the color dependency for the border from input-output
examples, with the border color directly determined by the reordering step. Grid
dimensions remain unchanged, and no blocks overlap in the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    """Generate an ARC-style input/output pair.

    The input contains multiple disconnected, solid-colored contiguous blocks on a
    zero background. Blocks do not touch or overlap (no 4-neighbour adjacency).

    The output first reorders all blocks by size (ascending) and lays them out
    in row-major order (left-to-right, top-to-bottom) starting at the top-left
    corner, preserving each block's shape and color and keeping a one-cell
    background separation between blocks. After placing the blocks, the outer
    border (perimeter) of the grid is painted with the color of the smallest
    block, but only background border cells are overwritten (existing block
    cells are preserved).
    """

    # Attempt generation until a valid configuration is produced.
    # Loop limit protects against pathological random draws.
    for attempt in range(2000):
        width = random.randint(10, 20)
        height = random.randint(10, 20)
        num_blocks = random.randint(3, 6)

        # Generate block shapes (contiguous pixel sets) and colors.
        blocks = []  # each block: dict with keys coords(set of (r,c)), w,h,size,color
        used_colors = [0]
        ok = True
        for _ in range(num_blocks):
            placed_shape = False
            for _try in range(60):
                # Choose a small bounding box for the creature so shapes vary
                bbox_w = random.randint(1, 5)
                bbox_h = random.randint(1, 5)
                max_cells = bbox_w * bbox_h
                size = random.randint(1, max_cells)
                # continuous_creature(size, width, height) returns coords (r,c)
                coords = common.continuous_creature(size, width=bbox_w, height=bbox_h)
                if len(coords) != size:
                    continue
                min_r = min(r for r, c in coords)
                min_c = min(c for r, c in coords)
                norm = [(r - min_r, c - min_c) for r, c in coords]
                max_r = max(r for r, c in norm)
                max_c = max(c for r, c in norm)
                block_h = max_r + 1
                block_w = max_c + 1
                # pick a unique non-zero color
                color = common.random_color(exclude=used_colors)
                used_colors.append(color)
                blocks.append({
                    'coords': set(norm),
                    'w': block_w,
                    'h': block_h,
                    'size': size,
                    'color': color
                })
                placed_shape = True
                break
            if not placed_shape:
                ok = False
                break
        if not ok:
            continue

        # Determine the layout for sorted-by-size blocks (spacing=1 to keep background separation)
        sorted_blocks = sorted(blocks, key=lambda b: (b['size'], b['color']))
        spacing = 1
        cur_x = 0
        cur_y = 0
        row_h = 0
        layout_positions = []
        fits = True
        for b in sorted_blocks:
            bw = b['w']
            bh = b['h']
            if cur_x + bw > width:
                cur_x = 0
                cur_y += row_h + spacing
                row_h = 0
            if cur_y + bh > height:
                fits = False
                break
            layout_positions.append((cur_x, cur_y))
            cur_x += bw + spacing
            row_h = max(row_h, bh)
        if not fits:
            # layout doesn't fit in chosen grid, try again
            continue

        # Place blocks randomly in the input grid, ensuring no overlap and no 4-neighbour touching
        input_grid = [[0 for _ in range(width)] for _ in range(height)]
        # We'll place blocks in random order to avoid the input already looking ordered.
        order = list(range(len(blocks)))
        random.shuffle(order)
        place_ok = True
        for idx in order:
            b = blocks[idx]
            bw, bh, coords, color = b['w'], b['h'], b['coords'], b['color']
            placed = False
            for _ in range(500):
                x = random.randint(0, width - bw)
                y = random.randint(0, height - bh)
                conflict = False
                for (dr, dc) in coords:
                    rr = y + dr
                    cc = x + dc
                    if input_grid[rr][cc] != 0:
                        conflict = True
                        break
                    # check 4-neighbor adjacency to existing blocks
                    for nr, nc in ((rr-1, cc), (rr+1, cc), (rr, cc-1), (rr, cc+1)):
                        if 0 <= nr < height and 0 <= nc < width:
                            if input_grid[nr][nc] != 0:
                                conflict = True
                                break
                    if conflict:
                        break
                if conflict:
                    continue
                # place the block
                for (dr, dc) in coords:
                    input_grid[y + dr][x + dc] = color
                placed = True
                break
            if not placed:
                place_ok = False
                break
        if not place_ok:
            # failed to place all blocks without touching, try again
            continue

        # Build the output grid by laying out sorted blocks at the computed positions
        output_grid = [[0 for _ in range(width)] for _ in range(height)]
        for b, (x, y) in zip(sorted_blocks, layout_positions):
            for (dr, dc) in b['coords']:
                # coordinates are (r,c) => y + dr is row, x + dc is col
                output_grid[y + dr][x + dc] = b['color']

        # Paint the outer perimeter with the color of the smallest block (only background cells)
        smallest_color = sorted_blocks[0]['color']
        for r in range(height):
            for c in range(width):
                if r == 0 or r == height - 1 or c == 0 or c == width - 1:
                    if output_grid[r][c] == 0:
                        output_grid[r][c] = smallest_color

        # Ensure input and output are not identical
        if input_grid == output_grid:
            continue

        return {
            'input': input_grid,
            'output': output_grid
        }

    raise RuntimeError('Could not generate a valid grid after many attempts')



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    visited = [[False] * width for _ in range(height)]
    blocks = []

    # Find contiguous non-zero blocks (4-neighbour connectivity)
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 or visited[r][c]:
                continue
            color = grid[r][c]
            queue = [(r, c)]
            visited[r][c] = True
            cells = []
            while queue:
                cr, cc = queue.pop(0)
                cells.append((cr, cc))
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                        visited[nr][nc] = True
                        queue.append((nr, nc))

            min_r = min(r0 for r0, c0 in cells)
            min_c = min(c0 for r0, c0 in cells)
            norm = [(r0 - min_r, c0 - min_c) for r0, c0 in cells]
            block_h = max(r0 for r0, c0 in norm) + 1
            block_w = max(c0 for r0, c0 in norm) + 1
            blocks.append({
                'coords': set(norm),
                'h': block_h,
                'w': block_w,
                'size': len(cells),
                'color': color
            })

    # Sort by size then by color to break ties (matches generator ordering)
    sorted_blocks = sorted(blocks, key=lambda b: (b['size'], b['color']))

    # Pack blocks into the output grid row-major with a one-cell spacing between blocks
    spacing = 1
    out = [[0 for _ in range(width)] for _ in range(height)]
    cur_x = 0
    cur_y = 0
    row_h = 0
    for b in sorted_blocks:
        bw = b['w']
        bh = b['h']
        if cur_x + bw > width:
            cur_x = 0
            cur_y += row_h + spacing
            row_h = 0
        # Place block (generator guarantees it fits)
        for (dr, dc) in b['coords']:
            rr = cur_y + dr
            cc = cur_x + dc
            if 0 <= rr < height and 0 <= cc < width:
                out[rr][cc] = b['color']
        cur_x += bw + spacing
        if bh > row_h:
            row_h = bh

    # Paint the border with the smallest block's color (only background pixels)
    if sorted_blocks:
        smallest_color = sorted_blocks[0]['color']
        for r in range(height):
            for c in range(width):
                if r == 0 or r == height - 1 or c == 0 or c == width - 1:
                    if out[r][c] == 0:
                        out[r][c] = smallest_color

    return tuple(tuple(row) for row in out)

