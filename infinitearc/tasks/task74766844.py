# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 74766844
Difficulty: hard

=== Tags ===
- Split and merge
- Trace perimeter
- Proximity guessing

=== Description ===
Task Description:    Input grids display multiple distinct colored regions (each
color representing a unique, contiguous object) on a uniform background (color
0). Each region is surrounded by background or other regions, with no
overlapping colors. The transformation to the output grid follows these precise
steps:    1. **Perimeter Tracing**: For each region, trace its outer boundary by
identifying all cells adjacent to background or other regions. This creates a
one-cell-thick outline along the region's edge, visible in the output as a new
line of the region's original color.    2. **Proximity Guessing**: Calculate the
minimum distance between every pair of perimeters. If two perimeters are
separated by â‰¤ 1 cell (i.e., they touch or nearly touch), they are marked as
"proximal."    3. **Splitting**: For regions with proximal perimeters, split the
region into two sub-regions along the line connecting the closest points between
the proximal perimeters. The split line is orthogonal to the direction of
proximity (e.g., horizontal split for vertical proximity).    4. **Merging**:
Each sub-region is merged with the nearest proximal region (based on the closest
proximity point). The merged region adopts the color of the target region. The
split line is removed, and the merged area retains the target region's color.
Regions not involved in proximity remain unchanged.    The output grid reflects
all splits and merges, with background preserved. No new colors are introduced,
and all transformations are strictly based on visual spatial relationships
(perimeter alignment, proximity, and orthogonal splitting). The task requires
recognizing multiple overlapping rules simultaneously, making it challenging to
deduce from minimal examples.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random
from typing import List

def generate():
    width = random.randint(4, 30)
    height = random.randint(4, 30)
    color_A = random.randint(1, 9)
    color_B = random.randint(1, 9)
    while color_B == color_A:
        color_B = random.randint(1, 9)
    
    grid = common.grid(width, height, 0)
    
    for r in range(2):
        for c in range(2):
            grid[r][c] = color_A
    
    for r in range(2, 4):
        for c in range(2):
            grid[r][c] = color_B
    
    output_grid = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] == color_A:
                output_grid[r][c] = color_B
    
    return {"input": grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    visited = [[False] * width for _ in range(height)]
    regions = {}
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and grid[r][c] != 0:
                color = grid[r][c]
                region = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    region.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                regions[color] = region
    
    perimeters = {}
    for color, region in regions.items():
        perimeter_cells = set()
        for (r, c) in region:
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if not (0 <= nr < height and 0 <= nc < width) or grid[nr][nc] != color:
                    perimeter_cells.add((r, c))
                    break
        perimeters[color] = perimeter_cells
    
    proximal_pairs = []
    colors = list(regions.keys())
    for i in range(len(colors)):
        for j in range(i + 1, len(colors)):
            color1, color2 = colors[i], colors[j]
            min_dist = float('inf')
            for (r1, c1) in perimeters[color1]:
                for (r2, c2) in perimeters[color2]:
                    dist = abs(r1 - r2) + abs(c1 - c2)
                    if dist < min_dist:
                        min_dist = dist
            if min_dist <= 1:
                proximal_pairs.append((color1, color2))
    
    for color1, color2 in proximal_pairs:
        for r in range(height):
            for c in range(width):
                if grid[r][c] == color1:
                    grid[r][c] = color2
    return grid
