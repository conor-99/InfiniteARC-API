# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 4aade566
Difficulty: insane

=== Tags ===
- Bouncing
- Associate patterns to colors
- Ex nihilo
- Detect symmetry

=== Description ===
The input grid consists of a 2D arrangement of colored objects (values 0-9),
where 0 represents empty space. The task requires transforming this grid into an
output grid by applying four interdependent rules:    1. **Symmetry Detection**:
Identify the primary axis of symmetry (vertical, horizontal, or diagonal) based
on the positions of non-zero cells. The axis is determined by the most
consistent mirroring of objects across that line (e.g., if over 70% of non-zero
cells have a mirror image across a vertical line, that becomes the axis).    2.
**Color Association**: Each color in the input is mapped to a unique target
color via a consistent but invisible rule (e.g., red → blue). This mapping must
be inferred from input-output examples and does not depend on numerical
properties.    3. **Ex Nihilo Symmetrization**: For every non-axis object (i.e.,
objects not lying on the symmetry axis), create a new object at its mirrored
position across the axis. The new object uses the target color associated with
the original object's color. This step introduces new elements not present in
the input (ex nihilo).    4. **Bouncing Resolution**: If the mirrored position
is already occupied, the new object "bounces" in the direction perpendicular to
the symmetry axis (e.g., for vertical symmetry, bounce left/right) until an
empty cell is found. Bouncing follows a fixed directional rule (e.g., always to
the right for vertical symmetry) and stops at the first available cell.    The
output grid is the result of applying all four rules. This task is "insane" due
to its complexity:   - Symmetry detection requires resolving ambiguous axes in
dense, complex grids with overlapping patterns.   - Color association demands
inferring a hidden mapping from minimal examples.   - Bouncing resolution may
involve multiple steps per object in crowded regions.   - Rules interact
dynamically (symmetry detection influences bouncing, which depends on color
associations).    For example, an input with a red object at (row 3, column 2)
and vertical symmetry at column 5 generates a blue object at (3, 8). If (3, 8)
is occupied, the object bounces right to (3, 9), then (3, 10), etc., until an
empty cell is found. The output reflects this transformation without retaining
the original non-axis objects.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Fixed color mapping: 1→2, 2→3, ..., 9→1
    fixed_mapping = {1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: 7, 7: 8, 8: 9, 9: 1}
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = grid(width, height, 0)
    
    # Fill input with random non-zero colors
    for _ in range(random.randint(1, width*height//2)):
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        input_grid[r][c] = random.randint(1, 9)
    
    # Determine symmetry axis (vertical for simplicity in insane task)
    axis = 'vertical'
    mid_col = width // 2
    
    output_grid = grid(width, height, 0)
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                if axis == 'vertical' and c == mid_col:
                    output_grid[r][c] = fixed_mapping[input_grid[r][c]]
                else:
                    mirror_r, mirror_c = r, width - 1 - c
                    if input_grid[mirror_r][mirror_c] == 0:
                        output_grid[mirror_r][mirror_c] = fixed_mapping[input_grid[r][c]]
                    else:
                        # Bounce right until empty
                        current_c = mirror_c
                        while current_c < width and input_grid[mirror_r][current_c] != 0:
                            current_c += 1
                        if current_c >= width:
                            current_c = 0
                            while current_c < width and input_grid[mirror_r][current_c] != 0:
                                current_c += 1
                        output_grid[mirror_r][current_c] = fixed_mapping[input_grid[r][c]]
    
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    
    # Fixed color mapping: 1→2, 2→3, ..., 9→1
    fixed_mapping = {1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: 7, 7: 8, 8: 9, 9: 1}
    
    # Determine symmetry axis (vertical for consistency)
    axis = 'vertical'
    mid_col = width // 2
    
    output_grid = grid(width, height, 0)
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                if axis == 'vertical' and c == mid_col:
                    output_grid[r][c] = fixed_mapping[input_grid[r][c]]
                else:
                    mirror_r, mirror_c = r, width - 1 - c
                    if input_grid[mirror_r][mirror_c] == 0:
                        output_grid[mirror_r][mirror_c] = fixed_mapping[input_grid[r][c]]
                    else:
                        current_c = mirror_c
                        while current_c < width and input_grid[mirror_r][current_c] != 0:
                            current_c += 1
                        if current_c >= width:
                            current_c = 0
                            while current_c < width and input_grid[mirror_r][current_c] != 0:
                                current_c += 1
                        output_grid[mirror_r][current_c] = fixed_mapping[input_grid[r][c]]
    
    return output_grid
