# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 1af50dcf
Difficulty: hard

=== Tags ===
- Size guessing
- Color palette
- Take minimum

=== Description ===
The input grid consists of a 2D arrangement of colored cells (0â€“9), where each
contiguous region of the same color (using 4-connectivity) forms a distinct
object. The task requires identifying the smallest connected region (by cell
count) across all colors in the input. For the output grid, every cell belonging
to a region with this minimum size is set to 9, while all other cells are set to
0. The smallest region size may be 1 (a single isolated cell) or a larger value,
and its detection requires careful analysis of region sizes without relying on
numerical sums or color values. The complexity arises from grids containing
numerous regions of varying sizes, where the minimum-sized region is visually
subtle and requires distinguishing isolated cells or small clusters from larger
objects. The color palette (0 and 9 in the output) is used intentionally to
highlight the minimum-sized regions, making the transformation visually distinct
while adhering to the constraints of the task.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid_input = [[0] * width for _ in range(height)]
    
    r, c = random.randint(1, height-2), random.randint(1, width-2)
    while grid_input[r-1][c] != 0 or grid_input[r+1][c] != 0 or grid_input[r][c-1] != 0 or grid_input[r][c+1] != 0:
        r, c = random.randint(1, height-2), random.randint(1, width-2)
    grid_input[r][c] = 1
    
    r2, c2 = random.randint(1, height-2), random.randint(1, width-2)
    grid_input[r2][c2] = 2
    dr, dc = random.choice([(1,0), (-1,0), (0,1), (0,-1)])
    r2b, c2b = r2 + dr, c2 + dc
    if 0 <= r2b < height and 0 <= c2b < width:
        grid_input[r2b][c2b] = 2
    
    r3, c3 = random.randint(1, height-2), random.randint(1, width-3)
    grid_input[r3][c3] = 3
    grid_input[r3][c3+1] = 3
    grid_input[r3][c3+2] = 3
    
    r4, c4 = random.randint(1, height-2), random.randint(1, width-2)
    grid_input[r4][c4] = 4
    grid_input[r4][c4+1] = 4
    grid_input[r4+1][c4] = 4
    grid_input[r4+1][c4+1] = 4
    
    output = compute_output(grid_input)
    
    return {
        "input": grid_input,
        "output": output
    }

def compute_output(grid):
    height = len(grid)
    width = len(grid[0])
    visited = [[False] * width for _ in range(height)]
    regions = []
    for r in range(height):
        for c in range(width):
            if not visited[r][c]:
                color = grid[r][c]
                stack = [(r, c)]
                visited[r][c] = True
                component = []
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                regions.append((color, len(component), component))
    
    min_size = min(size for _, size, _ in regions)
    output = [[0] * width for _ in range(height)]
    for _, _, cells in regions:
        if len(cells) == min_size:
            for (r, c) in cells:
                output[r][c] = 9
    return output


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    visited = [[False] * width for _ in range(height)]
    regions = []
    for r in range(height):
        for c in range(width):
            if not visited[r][c]:
                color = input_grid[r][c]
                stack = [(r, c)]
                visited[r][c] = True
                component = []
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                regions.append((color, len(component), component))
    
    min_size = min(size for _, size, _ in regions)
    output = [[0] * width for _ in range(height)]
    for _, _, cells in regions:
        if len(cells) == min_size:
            for (r, c) in cells:
                output[r][c] = 9
    return output
