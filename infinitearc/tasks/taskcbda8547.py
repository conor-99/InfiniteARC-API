# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: cbda8547
Difficulty: easy

=== Tags ===
- Separate shapes
- Associate images to bools

=== Description ===
The task involves transforming an input grid into an output grid where each cell
contains a 1 if it is part of a single isolated shape (a connected region of
exactly one cell with no adjacent non-zero cells in any of the four cardinal
directions), and 0 otherwise. The input grid consists of a 2D array of integers
between 0 and 9, representing colors or symbols. The output grid preserves the
same dimensions as the input but replaces all non-zero values with binary values
based on whether their cell is part of a single-cell shape. This rule separates
individual shapes (single-cell regions) from larger connected regions,
associating each cell with a boolean value (1 for isolated cells, 0 for all
other cells). The transformation is deterministic, requires no memorization, and
can be inferred from examining a few input-output examples.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    input_grid = [[0] * width for _ in range(height)]
    pixels = common.random_pixels(width, height, prob=0.3)
    for r, c in pixels:
        input_grid[r][c] = random.randint(1, 9)
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                neighbors = [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]
                isolated = True
                for nr, nc in neighbors:
                    if 0 <= nr < height and 0 <= nc < width:
                        if input_grid[nr][nc] != 0:
                            isolated = False
                            break
                output_grid[r][c] = 1 if isolated else 0
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                neighbors = [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]
                isolated = True
                for nr, nc in neighbors:
                    if 0 <= nr < height and 0 <= nc < width:
                        if input_grid[nr][nc] != 0:
                            isolated = False
                            break
                output_grid[r][c] = 1 if isolated else 0
            else:
                output_grid[r][c] = 0
    return output_grid
