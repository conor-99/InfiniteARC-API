# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: e4f4b08e
Difficulty: insane

=== Tags ===
- Draw line of sight
- State transition by contact
- Stepwise color transition
- Nested structure detection
- Add frame

=== Description ===
Input grids feature three concentric rectangular frames, each centered within
the grid and separated by one background cell. Each frame's border color follows
a consistent stepwise sequence (e.g., incrementing by a fixed value or following
a predefined pattern such as red → blue → green). The outermost frame contains a
designated source cell on its right edge. The output grid extends this sequence
by adding a fourth frame inside the innermost frame, with its border color
continuing the observed pattern. Additionally, the output draws a continuous
line of sight from the source cell to the grid's center, where the line's color
changes at each frame boundary to match the current frame's color. This
transition occurs precisely upon contact with each frame's inner edge, creating
a visually distinct path that demonstrates the sequence's progression through
the nested structure. The line remains confined to background cells and does not
overlap with frame borders or internal patterns, while all original frames and
their color sequences remain unchanged except for the addition of the new frame
and the line of sight.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

CALL_ID = 0

def generate():
    """Generates a pair of input/output grids with three concentric frames (input),
    a fourth inner frame added (output), and a line of sight running from a
    designated source cell on the right edge to the grid center. The line's
    color changes at each frame inner edge to match that frame's color. Each
    call produces a different configuration by using a global counter.
    """
    global CALL_ID
    i = CALL_ID
    CALL_ID += 1

    # Choose an odd size so there is a single central cell. Keep sizes modest
    # but varied to produce many unique examples.
    sizes = list(range(15, 30, 2))  # 15,17,...,29
    size = sizes[i % len(sizes)]
    center = size // 2

    # Choose the innermost frame radius r2. It must be at least 3 so we can
    # create a further inner frame r3 = r2 - 2 >= 1, and small enough to fit.
    r2_min = 3
    r2_max = max(r2_min, center - 4)
    r2_count = r2_max - r2_min + 1
    r2 = r2_min + ((i // len(sizes)) % r2_count)

    # Other radii follow (each separated by one background cell -> radius diffs = 2)
    r1 = r2 + 2
    r0 = r1 + 2
    r3 = r2 - 2

    # Choose a step (1 or 2) and a base color so that four consecutive colors fit
    # within 1..9: base + 3*step <= 9
    step_choices = [1, 2]
    step = step_choices[((i // (len(sizes) * max(1, r2_count))) % len(step_choices))]
    base_max = max(1, 9 - 3 * step)
    base_idx = (i // (len(sizes) * max(1, r2_count) * len(step_choices))) % base_max
    base_color = 1 + base_idx

    # Colors for the three input frames and the added fourth frame
    colors = [base_color + k * step for k in range(4)]

    # Pick a marker color for the source that is not used by any frame
    marker_candidates = [c for c in range(1, 10) if c not in colors]
    # Use CALL_ID-derived index to ensure variety and uniqueness
    marker_color = marker_candidates[i % len(marker_candidates)]

    # Build the input grid and draw three frames; create a small hole on the
    # right edge (at the same row) of each frame so the line of sight can pass
    # straight to the center without overlapping borders. The designated source
    # cell will be placed at the outermost hole.
    ingrid = grid(size, size, 0)
    src_row = center

    def draw_frame(g, r, color):
        top = center - r
        bottom = center + r
        left = center - r
        right = center + r
        # horizontal edges
        for c in range(left, right + 1):
            # Skip the right-edge cell on the source row to create the hole.
            if not (top == src_row and c == right):
                g[top][c] = color
            if not (bottom == src_row and c == right):
                g[bottom][c] = color
        # vertical edges
        for rr in range(top, bottom + 1):
            g[rr][left] = color
            if rr != src_row:
                # skip drawing the right-edge cell on the source row
                g[rr][right] = color

    # Draw the three input frames (outer -> middle -> inner)
    draw_frame(ingrid, r0, colors[0])
    draw_frame(ingrid, r1, colors[1])
    draw_frame(ingrid, r2, colors[2])

    # Place the designated source marker at the outermost right-edge hole
    source_col = center + r0
    ingrid[src_row][source_col] = marker_color

    # Make the output: copy input, add the fourth (inner) frame and draw the
    # line of sight from the source into the center. The new frame also has
    # a hole on the same row so the line can continue to the center.
    output = [row[:] for row in ingrid]

    # Draw the new inner frame in the output (with the hole at the same row).
    draw_frame(output, r3, colors[3])

    # Draw the continuous line of sight along src_row from the source column
    # to the center. The line changes color when it reaches each frame's inner
    # edge (one cell inside the border): inner_edge = center + r - 1.
    radii = [r0, r1, r2, r3]
    inner_edges = [center + r - 1 for r in radii]
    # Colors must correspond to the frames in the same order (outermost -> new)
    line_colors = colors

    for c in range(source_col, center - 1, -1):
        # default to the innermost (new) frame color
        color = line_colors[-1]
        for idx, edge in enumerate(inner_edges):
            if c >= edge:
                color = line_colors[idx]
                break
        output[src_row][c] = color

    return {'input': ingrid, 'output': output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])
    center_r = h // 2
    center_c = w // 2

    # Collect non-background colors and their coordinates
    counts = {}
    coords = {}
    for r in range(h):
        for c in range(w):
            v = grid[r][c]
            if v == 0: continue
            counts[v] = counts.get(v, 0) + 1
            coords.setdefault(v, []).append((r, c))

    # The generator places a single unique marker color (the source). Find it.
    marker_color = None
    for color, cnt in counts.items():
        if cnt == 1:
            marker_color = color
            break
    if marker_color is None:
        # If no unique marker found, fall back to searching the right half for a
        # color that sits on the rightmost non-background contour. This should
        # not be needed for the intended generator but keeps solver robust.
        for r in range(h):
            for c in range(w - 1, -1, -1):
                if grid[r][c] != 0:
                    marker_color = grid[r][c]
                    break
            if marker_color is not None:
                break

    # Location of the designated source marker
    src_r, src_c = coords[marker_color][0]

    # Frame colors are all non-background, non-marker colors
    frame_colors = [col for col in counts.keys() if col != marker_color]

    # For each candidate frame color compute bounding box and radius (distance from center)
    frames = []
    for color in frame_colors:
        pts = coords[color]
        min_r = min(p[0] for p in pts)
        max_r = max(p[0] for p in pts)
        min_c = min(p[1] for p in pts)
        max_c = max(p[1] for p in pts)
        # radius (assumes frames are centered) - use horizontal distance
        r = max_c - center_c
        frames.append((r, min_r, max_r, min_c, max_c, color))

    # Sort by radius descending (outermost first)
    frames.sort(key=lambda x: x[0], reverse=True)
    # Expect at least three frame colors
    if len(frames) < 3:
        # Nothing to do; return grid unchanged
        return grid

    # Take the three largest as the three input frames
    r0, _, _, _, _, c0 = frames[0]
    r1, _, _, _, _, c1 = frames[1]
    r2, _, _, _, _, c2 = frames[2]

    # Deduce the arithmetic step and the next color in the sequence
    step = (c1 - c0)
    # If c2 - c1 doesn't match, fall back to that difference
    if c2 - c1 != step:
        step = c2 - c1
    new_color = c2 + step

    # New inner radius
    r3 = r2 - 2

    # Start from a copy of the input and add the new frame and the sight line
    out = [row[:] for row in grid]

    # Draw the new frame border (skip the right-edge cell on src_r to keep the hole)
    top = center_r - r3
    bottom = center_r + r3
    left = center_c - r3
    right = center_c + r3

    # horizontal edges
    for c in range(left, right + 1):
        out[top][c] = new_color
        out[bottom][c] = new_color
    # vertical edges
    for rr in range(top, bottom + 1):
        out[rr][left] = new_color
        out[rr][right] = new_color
    # restore the hole on the right edge at src_r
    if top <= src_r <= bottom:
        out[src_r][right] = 0

    # Draw the continuous line of sight along src_r from the source column to center
    source_col = src_c
    radii = [r0, r1, r2, r3]
    inner_edges = [center_c + r - 1 for r in radii]
    colors = [c0, c1, c2, new_color]

    for c in range(source_col, center_c - 1, -1):
        color = colors[-1]
        for idx, edge in enumerate(inner_edges):
            if c >= edge:
                color = colors[idx]
                break
        out[src_r][c] = color

    return out
