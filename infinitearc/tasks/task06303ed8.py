# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 06303ed8
Difficulty: hard

=== Tags ===
- Count different colors
- Rule switch on context

=== Description ===
The input grids are square (e.g., 5×5, 7×7) containing multiple distinct colors
(0–9), including background colors. The output grid is determined by the parity
of the count of distinct colors in the entire input grid. If the count is even,
the output is the input rotated 90 degrees clockwise; if odd, the output is the
input flipped horizontally. The input grids are designed with complex
arrangements of colors (e.g., overlapping regions, multiple foreground objects)
to make the count of distinct colors non-trivial to identify visually. The
transformation must always produce a grid different from the input, ensuring the
input is not symmetric under the applied operation. The challenge requires
precise visual counting of all unique colors (including 0) and correctly
applying the rotation or flip rule based on the count's parity, demanding
careful attention to color diversity across the grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def rotate_90(grid):
    transposed = list(zip(*grid))
    return [list(reversed(row)) for row in transposed]

def generate():
    while True:
        width = random.randint(2, 30)
        height = random.randint(2, 30)
        input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
        colors = set()
        for row in input_grid:
            for c in row:
                colors.add(c)
        num_colors = len(colors)
        if num_colors % 2 == 0:
            output_grid = rotate_90(input_grid)
        else:
            output_grid = common.flip_horiz(input_grid)
        if output_grid != input_grid:
            return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    colors = set()
    for row in input_grid:
        for c in row:
            colors.add(c)
    num_colors = len(colors)
    if num_colors % 2 == 0:
        transposed = list(zip(*input_grid))
        return [list(reversed(row)) for row in transposed]
    else:
        return common.flip_horiz(input_grid)
