# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: ab6e149d
Difficulty: insane

=== Tags ===
- Implicit topology
- Collision marking
- Gas expansion
- Simple tile repeat
- Lattice completion

=== Description ===
Input grids feature gas sources (color 1), walls (color 2), and background
(color 0). Gas expands from each source in four cardinal directions (up, down,
left, right), filling all reachable background cells with color 3. When gas from
two distinct sources converges on the same cell, it is marked with color 4
(collision). The implicit topology forms a lattice structure where gas-filled
cells (color 3) are connected via horizontal and vertical paths. The output grid
completes this lattice by drawing continuous lines (color 5) along these paths,
ignoring diagonal connections. Additionally, the lattice is extended using a
simple tile repeat pattern (e.g., 2x2 repeating blocks), filling gaps to ensure
the lattice forms a regular grid. Walls (color 2) remain unchanged, and
background cells not reached by gas or part of the lattice remain color 0.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    input_grid = [[0] * width for _ in range(height)]
    
    wall_count = random.randint(1, 3)
    for _ in range(wall_count):
        length = random.randint(1, 3)
        direction = random.choice(['horizontal', 'vertical'])
        if direction == 'horizontal':
            max_length = width
            length = min(length, max_length)
            r = random.randint(0, height - 1)
            c = random.randint(0, width - length)
            for dc in range(length):
                input_grid[r][c + dc] = 2
        else:
            max_length = height
            length = min(length, max_length)
            c = random.randint(0, width - 1)
            r = random.randint(0, height - length)
            for dr in range(length):
                input_grid[r + dr][c] = 2
    
    sources = []
    source_count = random.randint(1, 3)
    for _ in range(source_count):
        r = random.randint(0, height - 1)
        c = random.randint(0, width - 1)
        while input_grid[r][c] != 0:
            r = random.randint(0, height - 1)
            c = random.randint(0, width - 1)
        input_grid[r][c] = 1
        sources.append((r, c))
    
    reached = [[0] * width for _ in range(height)]
    for (r, c) in sources:
        visited = [[False] * width for _ in range(height)]
        queue = deque()
        queue.append((r, c))
        visited[r][c] = True
        while queue:
            r, c = queue.popleft()
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == 0:
                    visited[nr][nc] = True
                    reached[nr][nc] += 1
                    queue.append((nr, nc))
    
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 2:
                output_grid[r][c] = 2
            elif reached[r][c] > 0:
                output_grid[r][c] = 5
            else:
                output_grid[r][c] = 0
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque
def p(input_grid):
    input_list = [list(row) for row in input_grid]
    width = len(input_list[0])
    height = len(input_list)
    sources = []
    for r in range(height):
        for c in range(width):
            if input_list[r][c] == 1:
                sources.append((r, c))
    reached = [[0] * width for _ in range(height)]
    for (r, c) in sources:
        visited = [[False] * width for _ in range(height)]
        queue = deque([(r, c)])
        visited[r][c] = True
        while queue:
            r, c = queue.popleft()
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_list[nr][nc] == 0:
                    visited[nr][nc] = True
                    reached[nr][nc] += 1
                    queue.append((nr, nc))
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_list[r][c] == 2:
                output_grid[r][c] = 2
            elif reached[r][c] > 0:
                output_grid[r][c] = 5
            else:
                output_grid[r][c] = 0
    return output_grid
