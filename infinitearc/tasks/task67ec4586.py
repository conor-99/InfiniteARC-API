# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 67ec4586
Difficulty: medium

=== Tags ===
- Associate colors to bools
- Reflect by color
- Infer step size
- Reorder blocks by size

=== Description ===
The task involves transforming an input grid into an output grid through four
consistent steps. First, colors are associated with boolean values (e.g., color
1 = True, color 2 = False), creating a binary mask. Second, the grid is
reflected vertically if any "True" color (e.g., color 1) is present, or
horizontally if any "False" color (e.g., color 2) is present (prioritizing
vertical reflection when both exist). Third, the step size is inferred as the
number of connected blocks of "True" colors (e.g., 3 blocks â†’ step size = 3),
which determines the spacing or segmentation for subsequent steps. Fourth, all
connected blocks (ignoring background color 0) are identified, sorted by size
(largest to smallest), and reassembled into the output grid in this order,
maintaining their reflected shapes and relative positions. The transformation is
deterministic, relies on abstract reasoning, and avoids pixel-level matching.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(3, 25)
    height = random.randint(3, 25)
    input_grid = grid(width, height, 0)
    
    num_1 = random.randint(1, 5)
    for _ in range(num_1):
        r, c = random.randint(0, height-1), random.randint(0, width-1)
        input_grid[r][c] = 1
    
    num_2 = random.randint(0, 3)
    for _ in range(num_2):
        r, c = random.randint(0, height-1), random.randint(0, width-1)
        input_grid[r][c] = 2
    
    # Fill remaining cells with random colors 3-9
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                input_grid[r][c] = random.randint(3, 9)
    
    has_1 = any(1 in row for row in input_grid)
    has_2 = any(2 in row for row in input_grid)
    
    if has_1:
        reflected = [row[::-1] for row in input_grid]
    elif has_2:
        reflected = input_grid[::-1]
    else:
        reflected = input_grid
    
    def get_components(grid, color):
        visited = set()
        components = []
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                if grid[r][c] == color and (r, c) not in visited:
                    stack = [(r, c)]
                    visited.add((r, c))
                    comp = []
                    while stack:
                        cr, cc = stack.pop()
                        comp.append((cr, cc))
                        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == color and (nr, nc) not in visited:
                                visited.add((nr, nc))
                                stack.append((nr, nc))
                    components.append(comp)
        return components
    
    step_size = len(get_components(reflected, 1))
    
    def get_all_components(grid):
        visited = set()
        components = []
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                if grid[r][c] != 0 and (r, c) not in visited:
                    stack = [(r, c)]
                    visited.add((r, c))
                    comp = []
                    while stack:
                        cr, cc = stack.pop()
                        comp.append((cr, cc))
                        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] != 0 and (nr, nc) not in visited:
                                visited.add((nr, nc))
                                stack.append((nr, nc))
                    components.append(comp)
        return components
    
    all_components = get_all_components(reflected)
    all_components.sort(key=lambda x: len(x), reverse=True)
    
    max_height = 0
    for comp in all_components:
        if comp:
            comp_height = max(r for r, c in comp) - min(r for r, c in comp) + 1
            if comp_height > max_height:
                max_height = comp_height
    output_height = max_height
    output_width = 0
    for comp in all_components:
        if comp:
            comp_width = max(c for r, c in comp) - min(c for r, c in comp) + 1
            output_width += comp_width + step_size
        else:
            output_width += 1 + step_size
    output_width = max(1, min(output_width - step_size, 30))
    output_height = max(1, min(output_height, 30))
    
    output_grid = grid(output_width, output_height, 0)
    
    x = 0
    for comp in all_components:
        if not comp:
            continue
        comp_min_r = min(r for r, c in comp)
        comp_min_c = min(c for r, c in comp)
        for r, c in comp:
            rel_r = r - comp_min_r
            rel_c = c - comp_min_c
            if rel_r < output_height and x + rel_c < output_width:
                output_grid[rel_r][x + rel_c] = reflected[r][c]
        x += (max(c for r, c in comp) - min(c for r, c in comp) + 1) + step_size
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    
    has_1 = any(1 in row for row in input_grid)
    has_2 = any(2 in row for row in input_grid)
    
    if has_1:
        reflected = [row[::-1] for row in input_grid]
    elif has_2:
        reflected = input_grid[::-1]
    else:
        reflected = input_grid
    
    def get_components(grid, color):
        visited = set()
        components = []
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                if grid[r][c] == color and (r, c) not in visited:
                    stack = [(r, c)]
                    visited.add((r, c))
                    comp = []
                    while stack:
                        cr, cc = stack.pop()
                        comp.append((cr, cc))
                        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == color and (nr, nc) not in visited:
                                visited.add((nr, nc))
                                stack.append((nr, nc))
                    components.append(comp)
        return components
    
    step_size = len(get_components(reflected, 1))
    
    def get_all_components(grid):
        visited = set()
        components = []
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                if grid[r][c] != 0 and (r, c) not in visited:
                    stack = [(r, c)]
                    visited.add((r, c))
                    comp = []
                    while stack:
                        cr, cc = stack.pop()
                        comp.append((cr, cc))
                        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] != 0 and (nr, nc) not in visited:
                                visited.add((nr, nc))
                                stack.append((nr, nc))
                    components.append(comp)
        return components
    
    all_components = get_all_components(reflected)
    all_components.sort(key=lambda x: len(x), reverse=True)
    
    max_height = 0
    for comp in all_components:
        if comp:
            comp_height = max(r for r, c in comp) - min(r for r, c in comp) + 1
            if comp_height > max_height:
                max_height = comp_height
    output_height = max_height
    output_width = 0
    for comp in all_components:
        if comp:
            comp_width = max(c for r, c in comp) - min(c for r, c in comp) + 1
            output_width += comp_width + step_size
        else:
            output_width += 1 + step_size
    output_width = max(1, min(output_width - step_size, 30))
    output_height = max(1, min(output_height, 30))
    
    output_grid = grid(output_width, output_height, 0)
    
    x = 0
    for comp in all_components:
        if not comp:
            continue
        comp_min_r = min(r for r, c in comp)
        comp_min_c = min(c for r, c in comp)
        for r, c in comp:
            rel_r = r - comp_min_r
            rel_c = c - comp_min_c
            if rel_r < output_height and x + rel_c < output_width:
                output_grid[rel_r][x + rel_c] = reflected[r][c]
        x += (max(c for r, c in comp) - min(c for r, c in comp) + 1) + step_size
    
    return output_grid
