# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 55037e7d
Difficulty: hard

=== Tags ===
- Associate images to colors
- Detect connectedness
- Inside out

=== Description ===
The task involves transforming an input grid by inverting the inside and outside
of enclosed shapes. Input grids contain regions of non-background colors (1-9)
forming connected components. The transformation requires identifying all
background regions (color 0) that are completely enclosed by a single non-
background color (i.e., surrounded on all sides by pixels of the same color
without connecting to the grid boundary). For each such enclosed background
region (hole), the hole is filled with the surrounding color, and the
surrounding region is replaced with the background color. This effectively swaps
the interior (previously background) and exterior (previously the surrounding
color) of each enclosed shape. The process demands detecting connected
components (using 4-connectivity), verifying enclosure via boundary checks, and
applying the color swap only to regions with a consistent surrounding color. The
task is hard due to the need for precise connectivity analysis and handling
nested or complex enclosed structures without assuming fixed grid dimensions or
color patterns.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    color = random.randint(1, 9)
    input_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if r == 0 or r == height-1 or c == 0 or c == width-1:
                input_grid[r][c] = color
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if r == 0 or r == height-1 or c == 0 or c == width-1:
                output_grid[r][c] = 0
            else:
                output_grid[r][c] = color
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid:
        return input_grid
    height = len(input_grid)
    width = len(input_grid[0])
    grid = [list(row) for row in input_grid]
    visited = [[False] * width for _ in range(height)]
    directions = [(1,0), (-1,0), (0,1), (0,-1)]
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 and not visited[r][c]:
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in directions:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == 0:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                
                enclosed = True
                for (cr, cc) in component:
                    if cr == 0 or cr == height-1 or cc == 0 or cc == width-1:
                        enclosed = False
                        break
                if not enclosed:
                    continue
                
                surrounding_colors = set()
                for (cr, cc) in component:
                    for dr, dc in directions:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                            surrounding_colors.add(grid[nr][nc])
                
                if len(surrounding_colors) == 1:
                    color = next(iter(surrounding_colors))
                    # Find all C cells adjacent to component
                    adjacent_C_cells = []
                    for (cr, cc) in component:
                        for dr, dc in directions:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == color:
                                adjacent_C_cells.append((nr, nc))
                    
                    # Find connected component of C
                    visited_C = [[False] * width for _ in range(height)]
                    C_component = []
                    queue = adjacent_C_cells[:]
                    for (r, c) in adjacent_C_cells:
                        visited_C[r][c] = True
                        C_component.append((r, c))
                    while queue:
                        cr, cc = queue.pop(0)
                        for dr, dc in directions:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < height and 0 <= nc < width and not visited_C[nr][nc] and grid[nr][nc] == color:
                                visited_C[nr][nc] = True
                                queue.append((nr, nc))
                                C_component.append((nr, nc))
                    
                    # Set all C_component to 0
                    for (r, c) in C_component:
                        grid[r][c] = 0
                    
                    # Fill the component with color
                    for (cr, cc) in component:
                        grid[cr][cc] = color
    return grid
