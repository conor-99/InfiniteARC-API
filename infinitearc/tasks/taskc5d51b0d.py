# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: c5d51b0d
Difficulty: hard

=== Tags ===
- Temporal wave step
- Analogical mapping between pairs
- Echo trail
- Bridges
- Periodic tiling

=== Description ===
Input grids feature a background color (0) overlaid with a periodic tiling of
colored bridge structures. Each bridge consists of a contiguous path of
identical color (e.g., color 1) connecting two endpoints, arranged in a
repeating grid pattern (e.g., horizontal bridges spaced 4 cells apart
vertically, vertical bridges spaced 4 cells apart horizontally). The grid also
contains a single wave marker (a cell of a distinct color, e.g., color 2)
positioned at the edge of the grid, typically aligned with a bridge path.   The
output grid transforms the input by simulating a temporal wave propagation along
the bridge structures. Starting from the wave marker's position, the wave moves
one cell at a time in a consistent direction (e.g., rightward for horizontal
bridges, downward for vertical bridges) along the bridge paths. At each step,
the wave leaves an echo trail in a color that cycles through a predefined
sequence (e.g., colors 3 → 4 → 5 → 3 → ...), with the trail drawn only on bridge
cells (preserving the original bridge color beneath). The wave continues moving
in its current direction until it exits the grid boundaries, encountering a
bridge junction (where multiple bridges meet), or reaching the end of a bridge
segment. At junctions, the wave continues straight without turning. The echo
trail sequence must cycle consistently, and the output grid displays the
original bridge structure, the wave's starting position (now obscured by the
first trail), and the accumulated echo trails along the wave's path. The
transformation requires recognizing the periodic bridge tiling pattern, tracking
the wave's directional movement through junctions, and applying the color cycle
for the trails, with the complexity arising from the need to navigate multiple
bridge segments while maintaining the trail sequence.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    grid = [[0] * width for _ in range(height)]
    
    bridge_color = random.choice([1, 6, 7, 8, 9])
    wave_color = 2
    trail_colors = [3, 4, 5]
    
    for r in range(2, height - 2, 4):
        for c in range(1, width - 1):
            grid[r][c] = bridge_color
    
    for c in range(2, width - 2, 4):
        for r in range(1, height - 1):
            grid[r][c] = bridge_color
    
    horiz_rows = [r for r in range(2, height - 2, 4) if grid[r][1] == bridge_color]
    if not horiz_rows:
        horiz_rows = [height // 2]
    r = random.choice(horiz_rows)
    grid[r][0] = wave_color
    
    output = [row[:] for row in grid]
    x, y = 0, r
    output[y][x] = trail_colors[0]
    color_index = 1
    x += 1
    while x < width and grid[y][x] == bridge_color:
        output[y][x] = trail_colors[color_index % 3]
        color_index += 1
        x += 1
    
    return {'input': grid, 'output': output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    
    wave_pos = None
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 2:
                wave_pos = (r, c)
                break
        if wave_pos:
            break
    if not wave_pos:
        return input_grid
    
    r, c = wave_pos
    if c == 0:
        dr, dc = 0, 1
    elif c == width - 1:
        dr, dc = 0, -1
    elif r == 0:
        dr, dc = 1, 0
    elif r == height - 1:
        dr, dc = -1, 0
    else:
        return input_grid
    
    adj_r, adj_c = r + dr, c + dc
    if not (0 <= adj_r < height and 0 <= adj_c < width):
        return input_grid
    bridge_color = input_grid[adj_r][adj_c]
    if bridge_color == 0 or bridge_color == 2:
        return input_grid
    
    output = [list(row) for row in input_grid]
    trail_colors = [3, 4, 5]
    color_index = 0
    
    output[r][c] = trail_colors[color_index]
    color_index = (color_index + 1) % 3
    
    cr, cc = r + dr, c + dc
    while 0 <= cr < height and 0 <= cc < width:
        if input_grid[cr][cc] != bridge_color:
            break
        output[cr][cc] = trail_colors[color_index]
        color_index = (color_index + 1) % 3
        cr += dr
        cc += dc
    
    return output
