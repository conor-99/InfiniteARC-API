# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: c1c457dc
Difficulty: medium

=== Tags ===
- Take complement
- Gravity
- Carve negative space
- Detect closed curves

=== Description ===
The input grids consist of 2D arrangements where non-zero values represent
foreground shapes against a zero background. The output grid is generated
through three steps: first, the grid is inverted (zero values become non-zero,
non-zero become zero), then a downward gravity effect is applied (rows are
reversed to simulate elements falling to the bottom), and finally, all closed
loops (boundaries forming enclosed regions) in the transformed grid are detected
and preserved as non-zero, with all other pixels set to zero. This process
carves out the negative space (enclosed regions) by highlighting their
boundaries, resulting in an output that only shows the detected closed curves.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    
    input_grid = common.grid(width, height, 0)
    
    r1 = random.randint(0, height-3)
    r2 = random.randint(r1+2, height-1)
    c1 = random.randint(0, width-3)
    c2 = random.randint(c1+2, width-1)
    
    for r in range(r1, r2+1):
        input_grid[r][c1] = 1
        input_grid[r][c2] = 1
    for c in range(c1, c2+1):
        input_grid[r1][c] = 1
        input_grid[r2][c] = 1
    
    comp = [[1 if input_grid[r][c] == 0 else 0 for c in range(width)] for r in range(height)]
    gravity_grid = comp[::-1]
    
    output_grid = common.grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            if gravity_grid[r][c] == 1:
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and gravity_grid[nr][nc] == 0:
                        output_grid[r][c] = 1
                        break
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    
    comp = [[1 if input_grid[r][c] == 0 else 0 for c in range(width)] for r in range(height)]
    gravity_grid = comp[::-1]
    
    output_grid = common.grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            if gravity_grid[r][c] == 1:
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and gravity_grid[nr][nc] == 0:
                        output_grid[r][c] = 1
                        break
    return output_grid
