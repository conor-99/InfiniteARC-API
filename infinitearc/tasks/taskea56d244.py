# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: ea56d244
Difficulty: medium

=== Tags ===
- Remove intruder
- Flood fill region
- Compare image
- Draw rectangle

=== Description ===
The input grid contains a single connected region of a uniform color (e.g.,
color 2) surrounded by a background (color 0), with exactly one intruder pixel
(color 3) located within the region. The output grid must first remove the
intruder by changing its color to match the region's uniform color. Next, a
rectangular border (color 1) is drawn around the entire region, using the
region's bounding box (min/max row and column indices) to define the rectangle's
corners. The flood fill operation ensures the region is fully connected and
uniform after intruder removal, while the rectangle drawing step adds a new
visual boundary. The transformation requires identifying the region, locating
and correcting the intruder, and computing the bounding box for the rectangle.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    from common import continuous_creature, grid
    
    width = random.randint(5, 20)
    height = random.randint(5, 20)
    region_color = random.randint(2, 9)
    region_size = random.randint(5, 20)
    region_pixels = continuous_creature(region_size, width, height)
    
    input_grid = grid(width, height, 0)
    for r, c in region_pixels:
        input_grid[r][c] = region_color
    
    intruder = random.choice(region_pixels)
    input_grid[intruder[0]][intruder[1]] = 3
    
    output_grid = [row[:] for row in input_grid]
    output_grid[intruder[0]][intruder[1]] = region_color
    
    region_pixels = [(r, c) for r in range(height) for c in range(width) if output_grid[r][c] == region_color]
    if not region_pixels:
        return {"input": input_grid, "output": input_grid}
    
    min_r = min(r for r, c in region_pixels)
    max_r = max(r for r, c in region_pixels)
    min_c = min(c for r, c in region_pixels)
    max_c = max(c for r, c in region_pixels)
    
    for r in range(min_r, max_r + 1):
        output_grid[r][min_c] = 1
        output_grid[r][max_c] = 1
    for c in range(min_c, max_c + 1):
        output_grid[min_r][c] = 1
        output_grid[max_r][c] = 1
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    h = len(input_grid)
    w = len(input_grid[0])
    
    non_zero = []
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] != 0:
                non_zero.append(input_grid[r][c])
    
    if not non_zero:
        return input_grid
    
    region_color = max(set(non_zero), key=non_zero.count)
    
    intruder = None
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] != region_color and input_grid[r][c] != 0:
                intruder = (r, c)
                break
        if intruder:
            break
    
    output = [row[:] for row in input_grid]
    if intruder:
        output[intruder[0]][intruder[1]] = region_color
    
    region_pixels = []
    for r in range(h):
        for c in range(w):
            if output[r][c] == region_color:
                region_pixels.append((r, c))
    
    if not region_pixels:
        return output
    
    min_r = min(r for r, c in region_pixels)
    max_r = max(r for r, c in region_pixels)
    min_c = min(c for r, c in region_pixels)
    max_c = max(c for r, c in region_pixels)
    
    for r in range(min_r, max_r + 1):
        output[r][min_c] = 1
        output[r][max_c] = 1
    for c in range(min_c, max_c + 1):
        output[min_r][c] = 1
        output[max_r][c] = 1
    
    return output
