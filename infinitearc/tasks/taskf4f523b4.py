# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: f4f523b4
Difficulty: insane

=== Tags ===
- Associate patterns to patterns
- Proximity guessing
- Associate patterns to colors

=== Description ===
The task involves transforming input grids containing multiple connected
components (patterns) of non-zero colors (0 is background) into output grids
where each cell's color is determined by the color of the nearest distinct
connected component. For each cell in the input, the output color is the color
of the closest other component (measured by Manhattan distance between any two
cells of the components), with ties broken by selecting the smallest color
value. Background cells (0) remain unchanged. The transformation requires
identifying all distinct connected components, calculating inter-component
distances, and applying the proximity-based color association rule. This rule
demands precise spatial reasoning and distance computation across multiple
patterns, making it challenging to discern through limited examples.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, randint, random_colors
import collections

def generate():
    width = randint(5, 30)
    height = randint(5, 30)
    colors = random_colors(3, exclude=[0])
    input_grid = grid(width, height, 0)
    input_grid[0][0] = colors[0]
    input_grid[0][width-1] = colors[1]
    input_grid[height-1][0] = colors[2]
    output_grid = compute_output(input_grid)
    return {
        "input": input_grid,
        "output": output_grid
    }

def compute_output(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    colors = list(range(1, 10))
    dists = {color: [[-1] * width for _ in range(height)] for color in colors}
    
    for color in colors:
        queue = collections.deque()
        for i in range(height):
            for j in range(width):
                if input_grid[i][j] == color:
                    dists[color][i][j] = 0
                    queue.append((i, j))
        while queue:
            i, j = queue.popleft()
            for di, dj in [(1,0), (-1,0), (0,1), (0,-1)]:
                ni, nj = i + di, j + dj
                if 0 <= ni < height and 0 <= nj < width and dists[color][ni][nj] == -1:
                    dists[color][ni][nj] = dists[color][i][j] + 1
                    queue.append((ni, nj))
    
    output = [[0] * width for _ in range(height)]
    for i in range(height):
        for j in range(width):
            if input_grid[i][j] == 0:
                output[i][j] = 0
                continue
            current_color = input_grid[i][j]
            min_dist = float('inf')
            closest_color = None
            for color in colors:
                if color == current_color:
                    continue
                dist = dists[color][i][j]
                if dist == -1:
                    continue
                if dist < min_dist:
                    min_dist = dist
                    closest_color = color
                elif dist == min_dist and color < closest_color:
                    closest_color = color
            output[i][j] = closest_color
    return output


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import collections

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    colors = list(range(1, 10))
    dists = {color: [[-1] * width for _ in range(height)] for color in colors}
    
    for color in colors:
        queue = collections.deque()
        for i in range(height):
            for j in range(width):
                if input_grid[i][j] == color:
                    dists[color][i][j] = 0
                    queue.append((i, j))
        while queue:
            i, j = queue.popleft()
            for di, dj in [(1,0), (-1,0), (0,1), (0,-1)]:
                ni, nj = i + di, j + dj
                if 0 <= ni < height and 0 <= nj < width and dists[color][ni][nj] == -1:
                    dists[color][ni][nj] = dists[color][i][j] + 1
                    queue.append((ni, nj))
    
    output = [[0] * width for _ in range(height)]
    for i in range(height):
        for j in range(width):
            if input_grid[i][j] == 0:
                output[i][j] = 0
                continue
            current_color = input_grid[i][j]
            min_dist = float('inf')
            closest_color = None
            for color in colors:
                if color == current_color:
                    continue
                dist = dists[color][i][j]
                if dist == -1:
                    continue
                if dist < min_dist:
                    min_dist = dist
                    closest_color = color
                elif dist == min_dist and color < closest_color:
                    closest_color = color
            output[i][j] = closest_color
    return output
