# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: fada09ca
Difficulty: medium

=== Tags ===
- Detect hor lines
- Detect rotational symmetry
- Reflect by color
- Connect nearest components

=== Description ===
The input grid consists of a 2D array of colors (0-9) with distinct horizontal
line segments (sequences of two or more adjacent cells of the same color in a
row). The output grid is generated by applying three consistent visual
transformations:    1. **Detect horizontal lines**: Identify all horizontal
sequences of length â‰¥2 (e.g., a row with `[0, 3, 3, 3, 0]` contains a horizontal
line of color `3`).   2. **Reflect by color**: For each detected horizontal
line, reflect all cells of that color across the vertical midline of the grid.
For example, a horizontal line at columns `2-4` in a 7-column grid becomes
columns `2-4` (mirrored to `2-4` in a symmetric grid) or `3-5` in an asymmetric
grid.   3. **Connect nearest components**: After reflection, identify the
closest endpoints between the original and reflected horizontal lines (e.g., the
rightmost cell of the original line and the leftmost cell of the reflected
line). Connect these endpoints with a vertical line of color `5` spanning the
shortest vertical distance between them.    The transformation ensures the
output grid maintains all original horizontal lines while adding reflected
counterparts and connecting their nearest points with a distinct color. The
rules are visual, rely on spatial relationships (not numerical values), and
require minimal induction from example pairs.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    w = random.randint(2, 30)
    h = random.randint(1, 30)
    input_grid = [[0] * w for _ in range(h)]
    while True:
        r = random.randint(0, h-1)
        c_start = random.randint(0, w-2)
        color = random.randint(1, 9)
        input_grid[r][c_start] = color
        input_grid[r][c_start + 1] = color
        found = False
        for r2 in range(h):
            for c2 in range(w-1):
                if input_grid[r2][c2] > 0 and input_grid[r2][c2] == input_grid[r2][c2+1]:
                    found = True
                    break
            if found:
                break
        if found:
            break
    output_grid = [row[:] for row in input_grid]
    colors_with_lines = set()
    for r in range(h):
        c = 0
        while c < w:
            if input_grid[r][c] == 0:
                c += 1
                continue
            color = input_grid[r][c]
            c_end = c
            while c_end < w and input_grid[r][c_end] == color:
                c_end += 1
            if c_end - c >= 2:
                colors_with_lines.add(color)
            c = c_end
    for color in colors_with_lines:
        for r in range(h):
            for c in range(w):
                if input_grid[r][c] == color:
                    new_c = w - 1 - c
                    output_grid[r][new_c] = color
    for r in range(h):
        c = 0
        while c < w:
            if input_grid[r][c] == 0:
                c += 1
                continue
            color = input_grid[r][c]
            c_end = c
            while c_end < w and input_grid[r][c_end] == color:
                c_end += 1
            if c_end - c >= 2:
                c2 = c_end - 1
                start_col = c2 + 1
                end_col = w - 1 - c2 - 1
                if start_col <= end_col:
                    for col in range(start_col, end_col + 1):
                        output_grid[r][col] = 5
            c = c_end
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to list of lists if it's a tuple
    input_grid = [list(row) for row in input_grid]
    h = len(input_grid)
    w = len(input_grid[0])
    output_grid = [row[:] for row in input_grid]
    colors_with_lines = set()
    for r in range(h):
        c = 0
        while c < w:
            if input_grid[r][c] == 0:
                c += 1
                continue
            color = input_grid[r][c]
            c_end = c
            while c_end < w and input_grid[r][c_end] == color:
                c_end += 1
            if c_end - c >= 2:
                colors_with_lines.add(color)
            c = c_end
    for color in colors_with_lines:
        for r in range(h):
            for c in range(w):
                if input_grid[r][c] == color:
                    new_c = w - 1 - c
                    output_grid[r][new_c] = color
    for r in range(h):
        c = 0
        while c < w:
            if input_grid[r][c] == 0:
                c += 1
                continue
            color = input_grid[r][c]
            c_end = c
            while c_end < w and input_grid[r][c_end] == color:
                c_end += 1
            if c_end - c >= 2:
                c2 = c_end - 1
                start_col = c2 + 1
                end_col = w - 1 - c2 - 1
                if start_col <= end_col:
                    for col in range(start_col, end_col + 1):
                        output_grid[r][col] = 5
            c = c_end
    return output_grid
