# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: d1c71377
Difficulty: insane

=== Tags ===
- State transition by contact
- Blockwise rule application

=== Description ===
Block Fusion  Input grids consist of multiple contiguous regions (blocks) of
distinct non-zero colors on a background of color 0. Each block is a maximal
4-connected region of identical color, separated from other blocks by background
or edge. Blocks may vary in size and shape, with no two blocks of the same color
touching. Adjacent blocks share at least one edge (not diagonal).  The
transformation rule is a state transition triggered by contact between blocks.
When a block of color A contacts a block of color B, both blocks transition to a
new color C determined by a consistent, deterministic rule based solely on the
visual relationship between A and B. The transition applies simultaneously to
all adjacent block pairs in the input grid. The background color (0) remains
unchanged throughout.  The output grid replaces each block with its new color
according to the transition rule. Blocks not in contact with any other block
retain their original color. The transition rule must be deduced from the input-
output examples through visual pattern recognition rather than numerical
computation, as the color values (0-9) are arbitrary and do not correspond to
inherent properties like hue or intensity.  For "insane" difficulty, the grid
contains numerous blocks with complex adjacency patterns, including chains of
multiple transitions (e.g., A-B-C where A contacts B and B contacts C), and the
transition rule requires identifying non-obvious visual relationships across
multiple examples. The rule may involve color sequences where transitions follow
a cyclic pattern (e.g., 1→2→3→1), or relationships based on color proximity in a
custom mapping (e.g., even-numbered colors transition to the next even number,
odd to next odd). Each input-output example must uniquely determine the
transition mapping without ambiguity, requiring the solver to recognize
overlapping patterns across the entire grid to resolve conflicts.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    """Generates an input/output pair for the "Block Fusion" task.

    The generator places a number of paired rectangular blocks that share at least one
    edge (they touch). Each pair uses two distinct non-zero colors and is placed so
    it does not touch any other block. Optionally one isolated block is placed.

    The fusion rule (deterministic and symmetric) is computed from the two colors
    of a touching pair and produces a color different from either original color.
    The generator applies this rule simultaneously to both blocks in each pair to
    produce the output grid.
    """
    # Allow a few attempts to produce a valid layout; this keeps placement simple
    # but robust against random collisions.
    for attempt in range(50):
        width = random.randint(10, 15)
        height = random.randint(10, 15)
        occupancy = [[0 for _ in range(width)] for _ in range(height)]

        num_pairs = random.randint(2, 4)
        add_isolated = random.choice([0, 1])
        total_blocks = 2 * num_pairs + add_isolated
        # choose unique colors for blocks (1..9)
        colors = random.sample(list(range(1, 10)), total_blocks)
        color_idx = 0

        pairs_info = []  # will store tuples (color1,color2,S1,S2)
        ok = True

        # helper: try placing a touching pair of rectangles
        for p in range(num_pairs):
            color_a = colors[color_idx]; color_b = colors[color_idx + 1]
            color_idx += 2
            placed = False

            # try many random candidate placements
            for _ in range(250):
                w1 = random.randint(1, 4); h1 = random.randint(1, 4)
                w2 = random.randint(1, 4); h2 = random.randint(1, 4)
                orient = random.choice(['h', 'v'])

                if orient == 'h':
                    # horizontal adjacency: left block width w1, right block width w2
                    if w1 + w2 > width:
                        continue
                    c1 = random.randint(0, width - (w1 + w2))
                    c2 = c1 + w1
                    r1 = random.randint(0, height - h1)
                    # r2 must overlap vertically with r1..r1+h1-1 by at least 1 row
                    r2_min = max(0, r1 - h2 + 1)
                    r2_max = min(r1 + h1 - 1, height - h2)
                    if r2_min > r2_max:
                        continue
                    r2 = random.randint(r2_min, r2_max)
                else:
                    # vertical adjacency: top block height h1, bottom block height h2
                    if h1 + h2 > height:
                        continue
                    r1 = random.randint(0, height - (h1 + h2))
                    r2 = r1 + h1
                    c1 = random.randint(0, width - w1)
                    # c2 must overlap horizontally with c1..c1+w1-1 by at least 1 col
                    c2_min = max(0, c1 - w2 + 1)
                    c2_max = min(c1 + w1 - 1, width - w2)
                    if c2_min > c2_max:
                        continue
                    c2 = random.randint(c2_min, c2_max)

                # compute coordinate sets for both rectangles
                S1 = set((r1 + dr, c1 + dc) for dr in range(h1) for dc in range(w1))
                S2 = set((r2 + dr, c2 + dc) for dr in range(h2) for dc in range(w2))

                # must not overlap
                if S1 & S2:
                    continue

                # must be free (no overlap with already placed blocks)
                collision = False
                for (rr, cc) in (S1 | S2):
                    if occupancy[rr][cc] != 0:
                        collision = True
                        break
                if collision:
                    continue

                # ensure there's at least one 4-neighbor contact between S1 and S2
                adjacent = False
                for (rr, cc) in S1:
                    if adjacent: break
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        if (rr + dr, cc + dc) in S2:
                            adjacent = True
                            break
                if not adjacent:
                    continue

                # ensure S1 and S2 do not touch any previously placed block
                touches_other = False
                for (rr, cc) in (S1 | S2):
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = rr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width:
                            if (nr, nc) not in S1 and (nr, nc) not in S2 and occupancy[nr][nc] != 0:
                                touches_other = True
                                break
                    if touches_other:
                        break
                if touches_other:
                    continue

                # place the pair
                for (rr, cc) in S1:
                    occupancy[rr][cc] = color_a
                for (rr, cc) in S2:
                    occupancy[rr][cc] = color_b
                pairs_info.append((color_a, color_b, S1, S2))
                placed = True
                break

            if not placed:
                ok = False
                break

        if not ok:
            continue

        # optionally add one isolated block (not touching any other block)
        isolated_info = []
        for _ in range(add_isolated):
            isolated_color = colors[color_idx]
            color_idx += 1
            placed = False
            for _ in range(200):
                w = random.randint(1, 4); h = random.randint(1, 4)
                r = random.randint(0, height - h)
                cc = random.randint(0, width - w)
                S = set((r + dr, cc + dc) for dr in range(h) for dc in range(w))
                # area free
                occupied = any(occupancy[rr][cc2] != 0 for (rr, cc2) in S)
                if occupied:
                    continue
                # must not touch any existing block
                touches = False
                for (rr, cc2) in S:
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = rr + dr, cc2 + dc
                        if 0 <= nr < height and 0 <= nc < width:
                            if occupancy[nr][nc] != 0:
                                touches = True
                                break
                    if touches:
                        break
                if touches:
                    continue
                for (rr, cc2) in S:
                    occupancy[rr][cc2] = isolated_color
                isolated_info.append((isolated_color, S))
                placed = True
                break
            if not placed:
                ok = False
                break

        if not ok:
            continue

        # build input grid
        input_grid = [row[:] for row in occupancy]

        # deterministic, symmetric fusion rule (depends only on the two colors)
        def fusion_color(a, b):
            x, y = (a, b) if a <= b else (b, a)
            base = (x * 3 + y * 5) % 9 + 1
            # ensure result differs from both inputs
            if base == a or base == b:
                base = (base % 9) + 1
                if base == a or base == b:
                    base = (base % 9) + 1
            return base

        # apply fusion simultaneously for all pairs
        output_grid = [row[:] for row in input_grid]
        for (ca, cb, S1, S2) in pairs_info:
            nc = fusion_color(ca, cb)
            for (rr, cc) in S1:
                output_grid[rr][cc] = nc
            for (rr, cc) in S2:
                output_grid[rr][cc] = nc

        # ensure at least one change
        if input_grid == output_grid:
            # try a new layout
            continue

        return {"input": input_grid, "output": output_grid}

    # if many attempts failed, return a simple fallback example (should be rare)
    width = 10; height = 10
    g = [[0 for _ in range(width)] for _ in range(height)]
    g[1][1] = 1
    g[1][2] = 2
    out = [row[:] for row in g]
    out[1][1] = 3; out[1][2] = 3
    return {"input": g, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # find connected non-zero blocks (4-connected)
    visited = [[False] * width for _ in range(height)]
    blocks = []  # list of (color, set_of_positions)
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and not visited[r][c]:
                color = grid[r][c]
                stack = [(r, c)]
                visited[r][c] = True
                comp = set()
                while stack:
                    rr, cc = stack.pop()
                    comp.add((rr, cc))
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = rr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width:
                            if not visited[nr][nc] and grid[nr][nc] == color:
                                visited[nr][nc] = True
                                stack.append((nr, nc))
                blocks.append((color, comp))

    # map coordinates to block index for quick adjacency detection
    coord2idx = {}
    for idx, (_col, comp) in enumerate(blocks):
        for pos in comp:
            coord2idx[pos] = idx

    # collect unique adjacency pairs (unordered)
    adj_pairs = set()
    for idx, (_col, comp) in enumerate(blocks):
        for (rr, cc) in comp:
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = rr + dr, cc + dc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                    j = coord2idx.get((nr, nc))
                    if j is not None and j != idx:
                        a, b = (idx, j) if idx <= j else (j, idx)
                        adj_pairs.add((a, b))

    # fusion rule (must match generator)
    def fusion_color(a, b):
        x, y = (a, b) if a <= b else (b, a)
        base = (x * 3 + y * 5) % 9 + 1
        if base == a or base == b:
            base = (base % 9) + 1
            if base == a or base == b:
                base = (base % 9) + 1
        return base

    # produce output grid by applying fusion to each adjacent block pair
    output = [row[:] for row in grid]
    for (i, j) in adj_pairs:
        color_i = blocks[i][0]
        color_j = blocks[j][0]
        nc = fusion_color(color_i, color_j)
        for (rr, cc) in blocks[i][1]:
            output[rr][cc] = nc
        for (rr, cc) in blocks[j][1]:
            output[rr][cc] = nc

    return output

