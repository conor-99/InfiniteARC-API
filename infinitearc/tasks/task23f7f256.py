# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 23f7f256
Difficulty: insane

=== Tags ===
- Run turing machine on tape
- Homeomorphism
- Fractal repetition

=== Description ===
The input grids are large, complex fractal patterns (e.g., Sierpinski triangle
structures) composed of colors 1–9, where each "cell" in the fractal is a self-
similar subgrid. Embedded within the fractal is a horizontal "tape" row
containing a Turing machine head (represented by color 8) moving along a
sequence of symbols (colors 1–7). The tape is not immediately obvious, requiring
identification of the linear structure within the fractal's recursive layers.
The transformation rule consists of two sequential steps: (1) Apply one step of
the Turing machine (based on predefined rules: if the head is over color 1,
write 2 and move right; over color 2, write 3 and move left, etc.), updating the
symbol under the head and shifting the head's position; (2) Apply a horizontal
homeomorphism (reflection) to the entire grid, preserving the fractal's
recursive structure while mirroring its orientation. The fractal repetition is
inherent in the input's self-similar design, and the output maintains this
pattern through the reflection, with the Turing machine step localized to the
embedded tape. The task demands recognizing the fractal's nested structure,
identifying the tape, inferring the Turing transition rules from the input-
output pairs, and applying the reflection—combining topological, computational,
and recursive reasoning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def turing_step(s):
    transitions = {
        1: (2, 1),
        2: (3, -1),
        3: (4, 1),
        4: (5, -1),
        5: (6, 1),
        6: (7, -1),
        7: (1, 1)
    }
    return transitions[s]

_input_set = set()

def generate():
    global _input_set
    size = 16
    while True:
        input_grid = grid(size, size, 5)
        tape_row = random.randint(5, size - 6)
        head_col = random.randint(1, size - 2)
        s = random.randint(1, 7)
        input_grid[tape_row][head_col - 1] = s
        input_grid[tape_row][head_col] = 8
        
        new_symbol, direction = turing_step(s)
        new_col = head_col + direction
        if new_col < 0:
            new_col = 0
        elif new_col >= size:
            new_col = size - 1
        
        input_tuple = tuple(tuple(row) for row in input_grid)
        if input_tuple not in _input_set:
            _input_set.add(input_tuple)
            break
    
    output_temp = [row[:] for row in input_grid]
    output_temp[tape_row][head_col] = new_symbol
    output_temp[tape_row][new_col] = 8
    output_grid = [row[::-1] for row in output_temp]
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def turing_step(s):
    transitions = {
        1: (2, 1),
        2: (3, -1),
        3: (4, 1),
        4: (5, -1),
        5: (6, 1),
        6: (7, -1),
        7: (1, 1)
    }
    return transitions[s]

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    head_pos = None
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] == 8:
                head_pos = (r, c)
                break
        if head_pos:
            break
    if not head_pos:
        return input_grid
    r, c = head_pos
    s = input_grid[r][c-1]
    new_symbol, direction = turing_step(s)
    new_col = c + direction
    if new_col < 0:
        new_col = 0
    elif new_col >= len(input_grid[0]):
        new_col = len(input_grid[0]) - 1
    output_temp = [row[:] for row in input_grid]
    output_temp[r][c] = new_symbol
    output_temp[r][new_col] = 8
    output_grid = [row[::-1] for row in output_temp]
    return output_grid
