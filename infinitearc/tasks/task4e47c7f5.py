# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 4e47c7f5
Difficulty: hard

=== Tags ===
- Hierarchical repetition
- Measure length
- Associate images to colors

=== Description ===
The input grid contains hierarchical structures, such as nested squares or lines
repeated at multiple scales (e.g., a larger square containing a smaller square,
or a line segment within a longer line). Each structure's length is measured:
for straight lines, the length is the number of consecutive cells in the line;
for squares, the length is the side length (number of cells per side). The
output grid replaces every cell within each structure with a color directly
corresponding to its measured length (e.g., a line of 3 cells becomes color 3, a
square of side length 5 becomes color 5). Hierarchical repetition ensures that
structures at all levels (e.g., outer and inner shapes) are individually
measured and colored according to their own length, without combining or
averaging lengths across levels.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    size = common.randint(9, 30)
    grid = common.grid(size, size, 0)
    levels = common.randint(2, 4)
    sides = []
    current_side = 9
    for _ in range(levels):
        if current_side == 1:
            sides.append(1)
        else:
            side = common.randint(1, current_side - 1)
            sides.append(side)
            current_side = side
    colors = []
    used_colors = set()
    for side in sides:
        available = [c for c in range(1, 10) if c != side and c not in used_colors]
        if not available:
            available = [c for c in range(1, 10) if c != side]
        color = common.random.choice(available)
        colors.append(color)
        used_colors.add(color)
    for i in range(levels):
        side = sides[i]
        start = (size - side) // 2
        for r in range(start, start + side):
            for c in range(start, start + side):
                grid[r][c] = colors[i]
    color_to_side = {colors[i]: sides[i] for i in range(levels)}
    output = common.grid(size, size, 0)
    for r in range(size):
        for c in range(size):
            if grid[r][c] != 0:
                output[r][c] = color_to_side[grid[r][c]]
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    if not input_grid or not input_grid[0]:
        return input_grid
    rows, cols = len(input_grid), len(input_grid[0])
    visited = [[False] * cols for _ in range(rows)]
    output = [[0] * cols for _ in range(rows)]
    
    for r in range(rows):
        for c in range(cols):
            if not visited[r][c] and input_grid[r][c] != 0:
                color = input_grid[r][c]
                region = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    region.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                min_r = min(cr for cr, cc in region)
                max_r = max(cr for cr, cc in region)
                min_c = min(cc for cr, cc in region)
                max_c = max(cc for cr, cc in region)
                width = max_c - min_c + 1
                height = max_r - min_r + 1
                length = width if height == 1 else height if width == 1 else width
                for cr, cc in region:
                    output[cr][cc] = length
    return output
