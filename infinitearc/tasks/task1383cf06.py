# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 1383cf06
Difficulty: medium–hard

=== Tags ===
- Analogical goal mapping
- Bridge gaps

=== Description ===
Input grids feature a background color (0) with multiple disjoint, rectangular
regions (each a contiguous area of a single color from 1-9) scattered across the
grid. Regions are separated by horizontal or vertical gaps of background cells
(minimum width/height of 2 cells). The output grid must fill each gap with a
bridge connecting the closest points of the two regions. The bridge consists of
a straight horizontal or vertical line with thickness equal to the smaller
dimension (width or height) of the two regions. The bridge's color is determined
by a fixed analogical mapping: for regions of color A and color B, the bridge
uses a specific third color C (e.g., red [2] + blue [1] → yellow [4]), where C
is consistent across all region pairs in the grid. Bridges occupy only
background cells and do not overlap with regions or existing structures. The
mapping is visual (e.g., color combinations like red+blue=yellow are inferred
from the input-output examples), avoiding numerical operations. The task
requires identifying region pairs, determining gap direction, calculating bridge
thickness, and applying the color mapping rule.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Grid size
    size = random.randint(15, 25)
    input_grid = grid(size, size, 0)

    # Choose three distinct colors: two region colors (A, B) and one bridge color (C)
    A, B, C = random.sample(range(1, 10), 3)

    # Place a small legend in the top row so the solver can infer the analogical mapping A + B -> C
    # Reserve row 0 for the legend (three adjacent cells)
    input_grid[0][0] = A
    input_grid[0][1] = B
    input_grid[0][2] = C

    regions = []        # list of all regions (r, c, w, h, color)
    bands = []          # bands of regions (each band is a horizontal row of rectangles)

    # Number of regions and bands
    region_count = random.randint(4, 6)
    band_count = random.randint(1, min(3, region_count))

    remaining = region_count
    cur_row = 2  # reserve row 0 for legend and row 1 as buffer

    for b in range(band_count):
        bands_left = band_count - b
        # Make sure at least one band (the first) has >=2 regions so we create at least one bridge
        if b == 0:
            min_k = 2 if (remaining - (bands_left - 1)) >= 2 else 1
        else:
            min_k = 1
        max_k = min(remaining - (bands_left - 1), 4)
        if max_k < min_k:
            k = min_k
        else:
            k = random.randint(min_k, max_k)

        # Choose uniform band height for all rectangles in this band
        band_h = random.randint(2, 4)
        if cur_row + band_h > size:
            band_h = max(2, size - cur_row)
            if cur_row + band_h > size:
                break

        # Start with minimal widths and then expand randomly
        widths = [random.randint(2, 4) for _ in range(k)]

        # Reduce widths if the total (with minimum gaps) doesn't fit
        while True:
            total_width_needed = sum(widths) + 2 * max(0, k - 1)
            if total_width_needed <= size:
                break
            # reduce the largest width if possible
            idx_max = max(range(len(widths)), key=lambda i: widths[i])
            if widths[idx_max] > 2:
                widths[idx_max] -= 1
            else:
                # remove one rectangle from this band (push to later bands)
                widths.pop()
                k -= 1
                if k == 0:
                    break
        if k == 0:
            break

        # Gaps between rectangles (base 2 cells), then distribute leftover space
        gaps = [2] * max(0, k - 1)
        total_needed = sum(widths) + sum(gaps)
        leftover = max(0, size - total_needed)

        # Random left margin
        left_margin = random.randint(0, leftover)
        leftover -= left_margin

        # Distribute remaining leftover into gaps to vary spacing
        for _ in range(leftover):
            if gaps:
                gi = random.randrange(len(gaps))
                gaps[gi] += 1
            else:
                left_margin += 1

        # Place rectangles in this band left-to-right
        col = left_margin
        band_regions = []
        for i in range(k):
            w = widths[i]
            h = band_h
            color = random.choice([A, B])
            # Paint the rectangle
            for rr in range(cur_row, cur_row + h):
                for cc in range(col, col + w):
                    input_grid[rr][cc] = color
            region = (cur_row, col, w, h, color)
            regions.append(region)
            band_regions.append(region)
            col += w
            if i < len(gaps):
                col += gaps[i]

        bands.append(band_regions)
        remaining -= k

        # Advance the row for the next band (vertical gap between bands)
        vertical_gap = random.randint(2, 4)
        cur_row += band_h + vertical_gap
        if remaining <= 0:
            break

    # Make a copy of the input to become the output, then add bridges
    output_grid = [row[:] for row in input_grid]

    # For each band, connect adjacent rectangles (left -> right) with a horizontal bridge
    for band_regions in bands:
        for i in range(len(band_regions) - 1):
            left = band_regions[i]
            right = band_regions[i + 1]
            left_r, left_c, left_w, left_h, left_col = left
            right_r, right_c, right_w, right_h, right_col = right

            # Columns that form the gap
            start_col = left_c + left_w
            end_col = right_c - 1
            # Ensure the gap is at least 2 cells wide
            if end_col - start_col + 1 < 2:
                continue

            # Bridge thickness is the smaller height of the two regions
            thickness = min(left_h, right_h)

            # Compute overlapping vertical interval (should be equal for same-band regions)
            overlap_top = max(left_r, right_r)
            overlap_bottom = min(left_r + left_h - 1, right_r + right_h - 1)

            if overlap_top > overlap_bottom:
                # No vertical overlap (unlikely for our banded placement) -- center the bridge
                center = (left_r + right_r) // 2
                start_row = max(0, min(size - thickness, center - thickness // 2))
            else:
                start_row = overlap_top
            end_row = start_row + thickness - 1

            # Paint the bridge color C into background cells only
            for rr in range(start_row, end_row + 1):
                for cc in range(start_col, end_col + 1):
                    if output_grid[rr][cc] == 0:
                        output_grid[rr][cc] = C

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])

    # Find the legend: first occurrence of three adjacent non-zero cells in a row
    legend_row = None
    legend_col = None
    A = B = C = None
    for r in range(height):
        for c in range(width - 2):
            if grid_in[r][c] != 0 and grid_in[r][c + 1] != 0 and grid_in[r][c + 2] != 0:
                A = grid_in[r][c]
                B = grid_in[r][c + 1]
                C = grid_in[r][c + 2]
                legend_row = r
                legend_col = c
                break
        if legend_row is not None:
            break

    # Fallback: if no clear legend found, try to collect first three distinct non-zero colors
    if A is None:
        found = []
        for r in range(height):
            for c in range(width):
                v = grid_in[r][c]
                if v != 0 and v not in found:
                    found.append(v)
                if len(found) >= 3:
                    break
            if len(found) >= 3:
                break
        if len(found) >= 3:
            A, B, C = found[:3]
        else:
            # As a last resort if only two colors are present, pick one as bridge color that is not 0
            A = found[0] if found else 1
            B = found[1] if len(found) > 1 else A
            C = 9 if 9 not in (A, B) else (8 if 8 not in (A, B) else 7)
        legend_row = 0

    # Prepare output as a copy of the input
    output = [row[:] for row in grid_in]

    # Find rectangular regions (connected components of the same non-zero color), skipping the legend row
    visited = [[False] * width for _ in range(height)]
    regions = []  # list of (r, c, w, h, color)

    for r in range(height):
        if r == legend_row:
            continue
        for c in range(width):
            if grid_in[r][c] == 0 or visited[r][c]:
                continue
            color = grid_in[r][c]
            # Flood fill for this color
            stack = [(r, c)]
            visited[r][c] = True
            min_r = r
            max_r = r
            min_c = c
            max_c = c
            while stack:
                rr, cc = stack.pop()
                for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid_in[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
                        if nr < min_r: min_r = nr
                        if nr > max_r: max_r = nr
                        if nc < min_c: min_c = nc
                        if nc > max_c: max_c = nc
            regions.append((min_r, min_c, max_c - min_c + 1, max_r - min_r + 1, color))

    # Group regions by their top row (bands)
    bands = {}
    for reg in regions:
        r0 = reg[0]
        bands.setdefault(r0, []).append(reg)

    # For each band, sort by column and connect adjacent rectangles with bridges
    for r0, regs in bands.items():
        regs_sorted = sorted(regs, key=lambda x: x[1])
        for i in range(len(regs_sorted) - 1):
            left = regs_sorted[i]
            right = regs_sorted[i + 1]
            left_r, left_c, left_w, left_h, left_col = left
            right_r, right_c, right_w, right_h, right_col = right

            start_col = left_c + left_w
            end_col = right_c - 1
            gap_width = end_col - start_col + 1
            if gap_width < 2:
                continue

            thickness = min(left_h, right_h)
            overlap_top = max(left_r, right_r)
            overlap_bottom = min(left_r + left_h - 1, right_r + right_h - 1)

            if overlap_top > overlap_bottom:
                # Center the bridge vertically if no overlap
                center = (left_r + right_r) // 2
                start_row = max(0, min(height - thickness, center - thickness // 2))
            else:
                start_row = overlap_top

            for rr in range(start_row, start_row + thickness):
                for cc in range(start_col, end_col + 1):
                    if output[rr][cc] == 0:
                        output[rr][cc] = C

    return output

