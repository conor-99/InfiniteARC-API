# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: bfa69387
Difficulty: hard

=== Tags ===
- Mirrored attribute binding
- Circuit reflection
- Threshold by touch count
- Associate colors to images

=== Description ===
**Task Name: Symmetric Circuit Mapping**    **Input Grids**: Large grids (15×15
to 30×30) with a single background color (0). Overlaid on the background are
multiple disjoint, non-overlapping circuits (connected paths of non-zero
colors), each forming a closed loop, open path, or branching structure. Circuits
are defined by contiguous cells of a single color (1–9), with no two circuits
sharing adjacent cells. Each circuit has a unique color, and the grid contains
at least 3 distinct circuit colors.    **Transformation Rules**:   1. **Mirrored
Attribute Binding**: For each circuit, determine its dominant axis (vertical if
width > height, horizontal if height > width). If the circuit’s length (number
of cells) exceeds 8, create a mirrored copy along the dominant axis. The
mirrored copy occupies the symmetric position relative to the grid’s center. The
mirrored circuit retains its original color but is not recolored by later steps.
2. **Circuit Reflection**: The mirrored copy is a geometric reflection (not
rotation), flipping the circuit’s shape across the axis. For example, a
rightward curve becomes a leftward curve. Mirrored circuits must not overlap
with original circuits or other mirrored circuits.    3. **Threshold by Touch
Count**: For every background cell (color 0), count orthogonal neighbors
belonging to circuits of *color 2*. If this count is ≥3, change the background
cell to color 7.    4. **Associate Colors to Images**: Classify each *original*
circuit (not mirrored) by its topological shape:      - **Loop**: Closed circuit
(each cell has ≥2 orthogonal neighbors within the circuit) → recolor to **3**.
- **Line**: Open path with exactly two endpoints (e.g., straight or curved) →
recolor to **5**.      - **Branch**: Circuit with ≥3 endpoints (e.g., Y-shaped)
→ recolor to **9**.      Mirrored circuits retain their original color and are
*not* recolored.    **Output Grid**:   - Original circuits are recolored based
on shape classification (Loop→3, Line→5, Branch→9).   - Mirrored circuits (if
length >8) are added symmetrically.   - Background cells with ≥3 color-2 circuit
neighbors become color 7.   - All circuits remain disjoint, and mirrored copies
do not overwrite original circuits.    **Complexity**:   - Requires identifying
circuits, classifying shapes via topological analysis (not pixel count), and
applying geometric mirroring.   - Rules interact: threshold count depends on
*specific* circuit color (2), while recoloring depends on *shape*, not color.
- Mirrored circuits are excluded from recoloring, adding a layer of dependency.
- Multiple transformations (reflection, threshold, recoloring) must be applied
in sequence without overlap.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common
from typing import List, Tuple, Dict

# Generator for ARC task: Symmetric Circuit Mapping

def generate() -> Dict[str, List[List[int]]]:
    # Grid size
    width = random.randint(15, 30)
    height = random.randint(15, 30)
    input_grid = common.grid(width, height, 0)

    # Helper to get orthogonal neighbors
    def neighbors(r, c):
        for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
            yield r+dr, c+dc

    # Check that a candidate shape (set of cells) does not overlap or touch existing occupied cells
    def shape_is_valid(cells, occupied):
        for (r, c) in cells:
            if not (0 <= r < height and 0 <= c < width):
                return False
            if (r, c) in occupied:
                return False
            # Forbidden to be orthogonally adjacent to any previously placed cell
            for nr, nc in neighbors(r, c):
                if (nr, nc) in occupied and (nr, nc) not in cells:
                    return False
        return True

    occupied = set()
    circuits = []  # list of tuples (color, path_cells)

    num_circuits = random.randint(3, 5)

    # Ensure we include at least one of each shape when possible
    base_shapes = ['loop', 'line', 'branch']
    shapes = []
    if num_circuits >= 3:
        shapes = base_shapes.copy()
        while len(shapes) < num_circuits:
            shapes.append(random.choice(base_shapes))
        random.shuffle(shapes)
    else:
        shapes = [random.choice(base_shapes) for _ in range(num_circuits)]

    # Choose distinct colors for circuits and ensure color 2 appears at least once
    colors = common.random_colors(num_circuits)
    if 2 not in colors:
        # Force one circuit to be color 2 to make threshold meaningful
        idx = random.randrange(len(colors))
        colors[idx] = 2

    # Guarantee at least one long circuit (>8 cells) so mirroring can occur
    long_index = random.randrange(num_circuits)

    for i in range(num_circuits):
        shape = shapes[i]
        color = colors[i]
        path = None
        attempts = 0
        # Try multiple placements
        while attempts < 400:
            attempts += 1
            if shape == 'line':
                # Prefer straight lines for reliability
                orientation = random.choice(['h', 'v'])
                max_len = min(20, width if orientation == 'h' else height)
                min_len = 9 if i == long_index else 5
                if min_len > max_len:
                    # cannot place this long; reduce to max_len
                    min_len = 3
                length = random.randint(min_len, max_len)
                if orientation == 'h':
                    r = random.randint(0, height - 1)
                    if width - length < 0:
                        continue
                    c0 = random.randint(0, width - length)
                    cells = [(r, c0 + j) for j in range(length)]
                else:
                    c = random.randint(0, width - 1)
                    if height - length < 0:
                        continue
                    r0 = random.randint(0, height - length)
                    cells = [(r0 + j, c) for j in range(length)]
                if shape_is_valid(cells, occupied):
                    path = cells
                    break

            elif shape == 'loop':
                # Rectangle perimeter (closed loop)
                # Make rectangle sizes moderate so perimeter yields enough cells
                max_h = min(12, height - 2)
                max_w = min(12, width - 2)
                if max_h < 3 or max_w < 3:
                    continue
                h = random.randint(3, max_h)
                w = random.randint(3, max_w)
                # Prefer larger rectangle if this is the long circuit
                if i == long_index:
                    h = random.randint(min(4, max_h), max_h)
                    w = random.randint(min(4, max_w), max_w)
                r0 = random.randint(0, height - h)
                c0 = random.randint(0, width - w)
                cells = []
                # top and bottom rows
                for c in range(c0, c0 + w):
                    cells.append((r0, c))
                    cells.append((r0 + h - 1, c))
                # side columns without corners
                for r in range(r0 + 1, r0 + h - 1):
                    cells.append((r, c0))
                    cells.append((r, c0 + w - 1))
                # remove duplicates just in case
                cells = list(dict.fromkeys(cells))
                if shape_is_valid(cells, occupied):
                    path = cells
                    break

            elif shape == 'branch':
                # Central hub with 3 or 4 arms
                arms = random.choice([3, 4])
                center_r = random.randint(0, height - 1)
                center_c = random.randint(0, width - 1)
                dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]
                chosen_dirs = random.sample(dirs, arms)
                cells = [(center_r, center_c)]
                for d in chosen_dirs:
                    # choose arm length but try to bias one long arm if this is the long circuit
                    max_arm = 6
                    min_arm = 2 if i == long_index else 1
                    L = random.randint(min_arm, max_arm)
                    arm_cells = []
                    for k in range(1, L + 1):
                        rr = center_r + d[0] * k
                        cc = center_c + d[1] * k
                        arm_cells.append((rr, cc))
                    cells.extend(arm_cells)
                # Deduplicate
                cells = list(dict.fromkeys(cells))
                if shape_is_valid(cells, occupied):
                    path = cells
                    break

        # If we failed to place the requested shape after attempts, fallback to a small free line
        if path is None:
            # Try to place at least a short line somewhere safe
            placed = False
            for r in range(height):
                for c in range(width):
                    # try horizontal
                    for length in range(5, 2, -1):
                        if c + length <= width:
                            cells = [(r, c + j) for j in range(length)]
                            if shape_is_valid(cells, occupied):
                                path = cells
                                placed = True
                                break
                        if placed:
                            break
                    if placed:
                        break
                if placed:
                    break
            if path is None:
                # As a last resort choose any single free cell (should be rare)
                for r in range(height):
                    for c in range(width):
                        if (r, c) not in occupied:
                            path = [(r, c)]
                            placed = True
                            break
                    if placed:
                        break

        # Paint the circuit onto the input grid and mark occupied
        for (r, c) in path:
            input_grid[r][c] = color
            occupied.add((r, c))
        circuits.append((color, path))

    # Now create mirrored copies (deterministically) for circuits longer than 8
    # Mirrored circuits are reflections across the dominant axis
    dominant_axis = 'vertical' if width > height else 'horizontal'
    original_cells = {cell for _, path in circuits for cell in path}

    mirrored_cells_by_color = {}  # color -> set of cells
    all_mirrored = set()

    for color, path in circuits:
        if len(path) <= 8:
            continue
        mirrored = []
        if dominant_axis == 'vertical':
            # reflect columns
            mirrored = [(r, width - 1 - c) for (r, c) in path]
        else:
            # reflect rows
            mirrored = [(height - 1 - r, c) for (r, c) in path]
        mirrored_set = set(mirrored)
        # Validate mirrored cells: must be inside grid and must not overlap or touch originals or previous mirrored
        ok = True
        for (mr, mc) in mirrored_set:
            if not (0 <= mr < height and 0 <= mc < width):
                ok = False
                break
            if (mr, mc) in original_cells:
                ok = False
                break
            if (mr, mc) in all_mirrored:
                ok = False
                break
            # also ensure mirrored cell is not orthogonally adjacent to any original or previously mirrored cell
            for nr, nc in neighbors(mr, mc):
                if (nr, nc) in original_cells and (nr, nc) not in mirrored_set:
                    ok = False
                    break
                if (nr, nc) in all_mirrored and (nr, nc) not in mirrored_set:
                    ok = False
                    break
            if not ok:
                break
        if ok:
            mirrored_cells_by_color[color] = mirrored_set
            all_mirrored |= mirrored_set

    # Build pre-output grid that includes mirrored circuits (they retain original color)
    pre_output = [row[:] for row in input_grid]
    for color, mset in mirrored_cells_by_color.items():
        for (r, c) in mset:
            pre_output[r][c] = color

    # Apply threshold by touch count: background cells with >=3 orth neighbors of color 2 -> change to 7
    output_grid = [row[:] for row in pre_output]
    for r in range(height):
        for c in range(width):
            if pre_output[r][c] != 0:
                continue
            count = 0
            for nr, nc in neighbors(r, c):
                if 0 <= nr < height and 0 <= nc < width and pre_output[nr][nc] == 2:
                    count += 1
            if count >= 3:
                output_grid[r][c] = 7

    # Recolor original circuits by topology (only original circuits are recolored)
    def classify(cells):
        cellset = set(cells)
        counts = {}
        for (r, c) in cells:
            ct = 0
            for nr, nc in neighbors(r, c):
                if (nr, nc) in cellset:
                    ct += 1
            counts[(r, c)] = ct
        endpoints = sum(1 for v in counts.values() if v == 1)
        if all(v >= 2 for v in counts.values()):
            return 'loop'
        elif endpoints == 2:
            return 'line'
        else:
            return 'branch'

    for color, path in circuits:
        shape = classify(path)
        new_color = 3 if shape == 'loop' else 5 if shape == 'line' else 9
        for (r, c) in path:
            output_grid[r][c] = new_color

    return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
from typing import List, Tuple, Dict

# Solver that mirrors the generator's deterministic transformation

def p(input_grid: Tuple[Tuple[int, ...], ...]) -> List[List[int]]:
    # Convert to mutable grid
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    def neighbors(r, c):
        for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
            yield r+dr, c+dc

    # Find connected components (original circuits) using DFS
    visited = [[False] * width for _ in range(height)]
    components = []  # list of tuples (color, list_of_cells)

    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 or visited[r][c]:
                continue
            color = grid[r][c]
            stack = [(r, c)]
            comp = []
            while stack:
                cr, cc = stack.pop()
                if not (0 <= cr < height and 0 <= cc < width):
                    continue
                if visited[cr][cc] or grid[cr][cc] != color:
                    continue
                visited[cr][cc] = True
                comp.append((cr, cc))
                for nr, nc in neighbors(cr, cc):
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                        stack.append((nr, nc))
            components.append((color, comp))

    # Helper to validate mirrored placement (must mirror across dominant axis and not overlap/or be adjacent)
    dominant_axis = 'vertical' if width > height else 'horizontal'
    original_cells = {cell for _, path in components for cell in path}

    def valid_mirrored_set(mset, all_mirrored):
        for (mr, mc) in mset:
            if not (0 <= mr < height and 0 <= mc < width):
                return False
            if (mr, mc) in original_cells:
                return False
            if (mr, mc) in all_mirrored:
                return False
            # check adjacency to original or already mirrored cells
            for nr, nc in neighbors(mr, mc):
                if (nr, nc) in original_cells and (nr, nc) not in mset:
                    return False
                if (nr, nc) in all_mirrored and (nr, nc) not in mset:
                    return False
        return True

    # Create mirrored circuits for components longer than 8
    mirrored_cells_by_color = {}
    all_mirrored = set()
    for color, path in components:
        if len(path) <= 8:
            continue
        if dominant_axis == 'vertical':
            mset = {(r, width - 1 - c) for (r, c) in path}
        else:
            mset = {(height - 1 - r, c) for (r, c) in path}
        if valid_mirrored_set(mset, all_mirrored):
            mirrored_cells_by_color[color] = mset
            all_mirrored |= mset

    # Build pre-output grid that includes mirrored circuits (they retain original color)
    pre_output = [row[:] for row in grid]
    for color, mset in mirrored_cells_by_color.items():
        for (r, c) in mset:
            pre_output[r][c] = color

    # Apply threshold by touch count: background cells with >=3 orth neighbors of color 2 -> change to 7
    output = [row[:] for row in pre_output]
    for r in range(height):
        for c in range(width):
            if pre_output[r][c] != 0:
                continue
            count = 0
            for nr, nc in neighbors(r, c):
                if 0 <= nr < height and 0 <= nc < width and pre_output[nr][nc] == 2:
                    count += 1
            if count >= 3:
                output[r][c] = 7

    # Recolor original circuits by topology (only original circuits are recolored)
    def classify(cells):
        cellset = set(cells)
        counts = {}
        for (r, c) in cells:
            ct = 0
            for nr, nc in neighbors(r, c):
                if (nr, nc) in cellset:
                    ct += 1
            counts[(r, c)] = ct
        endpoints = sum(1 for v in counts.values() if v == 1)
        if all(v >= 2 for v in counts.values()):
            return 'loop'
        elif endpoints == 2:
            return 'line'
        else:
            return 'branch'

    for color, path in components:
        shape = classify(path)
        new_color = 3 if shape == 'loop' else 5 if shape == 'line' else 9
        for (r, c) in path:
            output[r][c] = new_color

    return output

