# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 8e42ea80
Difficulty: mediumâ€“hard

=== Tags ===
- Maze wave
- Local rule cascade
- Contextual rule switch

=== Description ===
Input grids feature a maze-like structure composed of walls (non-zero colors)
and traversable paths (background color 0), with multiple wave sources (cells of
color 1) positioned along grid edges. Scattered throughout the maze are guide
cells (colors 2-9) embedded within path regions, each encoding directional rules
that depend on contextual relationships with neighboring cells. The wave
propagates from each source through path cells (0), with directionality
determined by the guide cell's color combined with the direction of entry (e.g.,
entering a guide cell from the left triggers a right turn if the guide color is
2, but an upward turn if the guide color is 3). This contextual rule switch
creates a cascade of directional changes as the wave traverses the maze,
adapting its path based on local cell interactions rather than fixed movement
patterns. The output grid preserves all walls and guide cells while replacing
the traversed path (excluding walls and guide cells) with a new color (color 5),
forming continuous, non-overlapping wave paths that terminate at grid
boundaries. The transformation requires recognizing the contextual dependency
between guide cell colors and entry directions to correctly trace the wave's
trajectory through the maze's dynamic rule system.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    grid = [[0] * width for _ in range(height)]
    
    wall_count = random.randint(width * height // 5, width * height // 3)
    for _ in range(wall_count):
        r, c = random.randint(0, height-1), random.randint(0, width-1)
        if grid[r][c] == 0:
            grid[r][c] = 2
    
    sources = []
    for c in range(width):
        if grid[0][c] == 0 and (height > 1 and grid[1][c] == 0):
            sources.append((0, c))
        if grid[height-1][c] == 0 and (height > 1 and grid[height-2][c] == 0):
            sources.append((height-1, c))
    for r in range(height):
        if grid[r][0] == 0 and (width > 1 and grid[r][1] == 0):
            sources.append((r, 0))
        if grid[r][width-1] == 0 and (width > 1 and grid[r][width-2] == 0):
            sources.append((r, width-1))
    
    if not sources:
        # Fallback: place source where next cell is path
        for c in range(width):
            if grid[0][c] == 0 and (height > 1 and grid[1][c] == 0):
                sources.append((0, c))
                break
        for c in range(width):
            if grid[height-1][c] == 0 and (height > 1 and grid[height-2][c] == 0):
                sources.append((height-1, c))
                break
        for r in range(height):
            if grid[r][0] == 0 and (width > 1 and grid[r][1] == 0):
                sources.append((r, 0))
                break
        for r in range(height):
            if grid[r][width-1] == 0 and (width > 1 and grid[r][width-2] == 0):
                sources.append((r, width-1))
                break
        if not sources:
            r, c = random.randint(0, height-1), random.randint(0, width-1)
            grid[r][c] = 1
            return {'input': grid, 'output': grid}
    
    r, c = random.choice(sources)
    grid[r][c] = 1
    
    path_cells = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0:
                path_cells.append((r, c))
    guide_count = random.randint(len(path_cells) // 8, len(path_cells) // 4)
    for _ in range(guide_count):
        r, c = random.choice(path_cells)
        if (r, c) != (sources[0][0], sources[0][1]):
            grid[r][c] = random.choice(range(3, 10))
    
    directions = {
        0: (0, 1),
        1: (-1, 0),
        2: (0, -1),
        3: (1, 0)
    }
    
    def get_direction_index(dr, dc):
        for idx, (d_dr, d_dc) in directions.items():
            if dr == d_dr and dc == d_dc:
                return idx
        return None
    
    traversed = set()
    for r, c in sources:
        if grid[r][c] != 1:
            continue
        if r == 0:
            current_dir = (1, 0)
        elif r == height - 1:
            current_dir = (-1, 0)
        elif c == 0:
            current_dir = (0, 1)
        else:
            current_dir = (0, -1)
        
        current_r, current_c = r, c
        while True:
            next_r = current_r + current_dir[0]
            next_c = current_c + current_dir[1]
            if next_r < 0 or next_r >= height or next_c < 0 or next_c >= width:
                break
            if grid[next_r][next_c] == 2:
                break
            if 3 <= grid[next_r][next_c] <= 9:
                guide_color = grid[next_r][next_c]
                curr_dir_idx = get_direction_index(current_dir[0], current_dir[1])
                if curr_dir_idx is None:
                    break
                turn = (guide_color - 3) % 4
                new_dir_idx = (curr_dir_idx + turn) % 4
                current_dir = directions[new_dir_idx]
                current_r, current_c = next_r, next_c
                continue
            else:
                traversed.add((next_r, next_c))
                current_r, current_c = next_r, next_c
                continue
    
    output = [[grid[r][c] for c in range(width)] for r in range(height)]
    for r, c in traversed:
        output[r][c] = 5
    
    return {'input': grid, 'output': output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    
    directions = {
        0: (0, 1),
        1: (-1, 0),
        2: (0, -1),
        3: (1, 0)
    }
    
    def get_direction_index(dr, dc):
        for idx, (d_dr, d_dc) in directions.items():
            if dr == d_dr and dc == d_dc:
                return idx
        return None
    
    traversed = set()
    sources = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 1:
                sources.append((r, c))
    
    for r, c in sources:
        if r == 0:
            current_dir = (1, 0)
        elif r == height - 1:
            current_dir = (-1, 0)
        elif c == 0:
            current_dir = (0, 1)
        else:
            current_dir = (0, -1)
        
        current_r, current_c = r, c
        while True:
            next_r = current_r + current_dir[0]
            next_c = current_c + current_dir[1]
            if next_r < 0 or next_r >= height or next_c < 0 or next_c >= width:
                break
            if grid[next_r][next_c] == 2:
                break
            if 3 <= grid[next_r][next_c] <= 9:
                guide_color = grid[next_r][next_c]
                curr_dir_idx = get_direction_index(current_dir[0], current_dir[1])
                if curr_dir_idx is None:
                    break
                turn = (guide_color - 3) % 4
                new_dir_idx = (curr_dir_idx + turn) % 4
                current_dir = directions[new_dir_idx]
                current_r, current_c = next_r, next_c
                continue
            else:
                traversed.add((next_r, next_c))
                current_r, current_c = next_r, next_c
                continue
    
    output = [[grid[r][c] for c in range(width)] for r in range(height)]
    for r, c in traversed:
        output[r][c] = 5
    
    return output
