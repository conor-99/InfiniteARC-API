# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 3fe0bec7
Difficulty: mediumâ€“hard

=== Tags ===
- Hollow core detection
- Directional routing
- Inference from demonstration
- Pattern translation
- Associate images to bools

=== Description ===
Hollow Path Routing  Input grids feature multiple nested rectangular frames,
each forming a hollow core (a rectangular boundary with a smaller rectangle
removed from its center, creating a frame-like structure). Within each hollow
core, a single marker pixel of a distinct color is positioned at one of the four
cardinal directions relative to the core's geometric center (top, bottom, left,
right). The marker's placement visually indicates the directional path that must
be followed through that core.  The output grid must generate a continuous path
starting from the outer edge of the outermost frame, navigating through each
hollow core in sequence according to the marker's direction within each core.
The path is drawn using color value 1 (while background remains color 0), moving
through the hollow regions without intersecting frame boundaries or other
elements. The path direction through each core is determined by the marker's
position relative to the core's center (e.g., a marker positioned above the
center implies an upward path through that core). The path transitions
seamlessly between consecutive frames, maintaining continuity until it exits the
grid through the innermost frame's boundary.  This task requires the solver to
simultaneously identify all hollow cores, interpret the directional meaning from
each marker's visual position, and synthesize a path that adheres to these
constraints across multiple nested structures. The complexity arises from the
need to correctly map spatial marker positions to directional movement while
ensuring path continuity through all hierarchical layers.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Try to build a variety of concentric rectangular frames with markers
    # Grid size and center are chosen so that the requested number of nested frames fit.
    for outer_attempt in range(200):
        width = random.randint(12, 25)
        height = random.randint(12, 25)
        num_frames = random.randint(2, 4)
        # minimal outer radius so that innermost radius is at least 2 (so marker can be placed)
        r0_min = 2 * num_frames

        # Try to find a center and an outer radius that fit inside the grid with a 1-cell margin
        found = False
        for attempt in range(200):
            cr = random.randint(0, height - 1)
            cc = random.randint(0, width - 1)
            r0_max = min(cr, height - 1 - cr, cc, width - 1 - cc)
            if r0_max >= r0_min:
                r0 = random.randint(r0_min, r0_max)
                top0 = cr - r0
                left0 = cc - r0
                bottom0 = cr + r0 + 1
                right0 = cc + r0 + 1
                # Keep at least one cell between outermost frame and grid edge so there is an "outside" region
                if top0 >= 1 and left0 >= 1 and bottom0 <= height - 1 and right0 <= width - 1:
                    found = True
                    break
        if found:
            break
    else:
        # fallback deterministic configuration (should rarely happen)
        width, height = 15, 15
        num_frames = 3
        cr, cc = height // 2, width // 2
        r0 = 2 * num_frames

    # Radii for frames (concentric, spaced by 2 pixels)
    radii = [r0 - 2 * i for i in range(num_frames)]
    frames = []
    for r in radii:
        top = cr - r
        left = cc - r
        bottom = cr + r + 1
        right = cc + r + 1
        frames.append((top, left, bottom, right))

    # Create initial grid (background 0)
    grid = [[0 for _ in range(width)] for _ in range(height)]

    # Choose distinct colors for frames (avoid 0 and 1). Reserve 9 for markers.
    available_colors = [2, 3, 4, 5, 6, 7, 8]
    random.shuffle(available_colors)
    frame_colors = available_colors[:num_frames]

    # Draw each rectangular frame (single-pixel border)
    for (top, left, bottom, right), color in zip(frames, frame_colors):
        # top and bottom rows
        for c in range(left, right):
            grid[top][c] = color
            grid[bottom - 1][c] = color
        # left and right columns
        for r in range(top, bottom):
            grid[r][left] = color
            grid[r][right - 1] = color

    # Place one marker inside the hollow ring of each frame (not inside any smaller inner frame)
    directions = ['top', 'bottom', 'left', 'right']
    frame_dirs = []
    marker_color = 9

    for i, (top, left, bottom, right) in enumerate(frames):
        inner = frames[i + 1] if i + 1 < len(frames) else None
        d = random.choice(directions)
        frame_dirs.append(d)
        placed = False

        # We scan from the center toward the side indicated by d and pick the first available cell
        if d == 'top':
            for r in range(cr - 1, top, -1):
                c = cc
                if not (top + 1 <= r <= bottom - 2 and left + 1 <= c <= right - 2):
                    continue
                if inner is not None:
                    itop, ileft, ibottom, iright = inner
                    if (itop + 1 <= r <= ibottom - 2) and (ileft + 1 <= c <= iright - 2):
                        continue
                if grid[r][c] == 0:
                    grid[r][c] = marker_color
                    placed = True
                    break
        elif d == 'bottom':
            for r in range(cr + 1, bottom - 1):
                c = cc
                if not (top + 1 <= r <= bottom - 2 and left + 1 <= c <= right - 2):
                    continue
                if inner is not None:
                    itop, ileft, ibottom, iright = inner
                    if (itop + 1 <= r <= ibottom - 2) and (ileft + 1 <= c <= iright - 2):
                        continue
                if grid[r][c] == 0:
                    grid[r][c] = marker_color
                    placed = True
                    break
        elif d == 'left':
            for c in range(cc - 1, left, -1):
                r = cr
                if not (top + 1 <= r <= bottom - 2 and left + 1 <= c <= right - 2):
                    continue
                if inner is not None:
                    itop, ileft, ibottom, iright = inner
                    if (itop + 1 <= r <= ibottom - 2) and (ileft + 1 <= c <= iright - 2):
                        continue
                if grid[r][c] == 0:
                    grid[r][c] = marker_color
                    placed = True
                    break
        else:  # right
            for c in range(cc + 1, right - 1):
                r = cr
                if not (top + 1 <= r <= bottom - 2 and left + 1 <= c <= right - 2):
                    continue
                if inner is not None:
                    itop, ileft, ibottom, iright = inner
                    if (itop + 1 <= r <= ibottom - 2) and (ileft + 1 <= c <= iright - 2):
                        continue
                if grid[r][c] == 0:
                    grid[r][c] = marker_color
                    placed = True
                    break

        # Fallback: if we couldn't place according to the rule above, choose any available interior cell in the ring
        if not placed:
            found = False
            for r in range(top + 1, bottom - 1):
                for c in range(left + 1, right - 1):
                    if inner is not None:
                        itop, ileft, ibottom, iright = inner
                        if (itop + 1 <= r <= ibottom - 2) and (ileft + 1 <= c <= iright - 2):
                            continue
                    if grid[r][c] == 0:
                        grid[r][c] = marker_color
                        found = True
                        break
                if found:
                    break
            if not found:
                # last resort: mark the center if it is free
                if grid[cr][cc] == 0:
                    grid[cr][cc] = marker_color
                else:
                    # or any zero cell in the frame interior
                    for r in range(max(0, top + 1), min(height, bottom - 1)):
                        for c in range(max(0, left + 1), min(width, right - 1)):
                            if grid[r][c] == 0:
                                grid[r][c] = marker_color
                                found = True
                                break
                        if found:
                            break

    # Build the output grid: draw path color 1 inside each frame's hollow interior following its direction
    output = [row[:] for row in grid]

    # Draw a center-aligned segment for each frame: vertical for top/bottom, horizontal for left/right
    for (top, left, bottom, right), d in zip(frames, frame_dirs):
        if d in ('top', 'bottom'):
            for r in range(top + 1, bottom - 1):
                if output[r][cc] == 0:
                    output[r][cc] = 1
        else:
            for c in range(left + 1, right - 1):
                if output[cr][c] == 0:
                    output[cr][c] = 1

    # Make sure the path starts from the outer edge toward the outermost frame according to the outermost marker
    top0, left0, bottom0, right0 = frames[0]
    d0 = frame_dirs[0]
    if d0 == 'top':
        for r in range(0, top0):
            if output[r][cc] == 0:
                output[r][cc] = 1
    elif d0 == 'bottom':
        for r in range(bottom0, height):
            if output[r][cc] == 0:
                output[r][cc] = 1
    elif d0 == 'left':
        for c in range(0, left0):
            if output[cr][c] == 0:
                output[cr][c] = 1
    else:  # right
        for c in range(right0, width):
            if output[cr][c] == 0:
                output[cr][c] = 1

    # Ensure the center cell is part of the path for connectivity if it is empty
    if output[cr][cc] == 0:
        output[cr][cc] = 1

    return {'input': grid, 'output': output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(grid):
    grid = [list(row) for row in grid]
    height = len(grid)
    width = len(grid[0]) if height else 0

    # Locate markers by color 9 (generator always uses 9 for markers)
    markers = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == 9]

    # Find frame components: non-zero pixels excluding markers (value 9)
    visited = [[False] * width for _ in range(height)]
    frames = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and grid[r][c] != 9 and not visited[r][c]:
                # BFS
                stack = [(r, c)]
                visited[r][c] = True
                comp = []
                while stack:
                    rr, cc = stack.pop()
                    comp.append((rr, cc))
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = rr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] != 0 and grid[nr][nc] != 9:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                rs = [p[0] for p in comp]
                cs = [p[1] for p in comp]
                top, left = min(rs), min(cs)
                bottom, right = max(rs) + 1, max(cs) + 1
                frames.append((top, left, bottom, right))

    if not frames:
        return [[0] * width for _ in range(height)]

    # Sort frames by radius descending (outermost first)
    def radius(box):
        top, left, bottom, right = box
        return ((bottom - top) - 1) // 2

    frames.sort(key=radius, reverse=True)

    # Geometric center from outermost
    top0, left0, bottom0, right0 = frames[0]
    cr = (top0 + bottom0 - 1) // 2
    cc = (left0 + right0 - 1) // 2

    # Associate markers to frames and determine directions
    frame_dirs = [None] * len(frames)
    for mr, mc in markers:
        for i in range(len(frames)):
            top, left, bottom, right = frames[i]
            if not (top + 1 <= mr <= bottom - 2 and left + 1 <= mc <= right - 2):
                continue
            if i + 1 < len(frames):
                itop, ileft, ibottom, iright = frames[i + 1]
                if (itop + 1 <= mr <= ibottom - 2) and (ileft + 1 <= mc <= iright - 2):
                    continue
            if mr < cr:
                frame_dirs[i] = 'top'
            elif mr > cr:
                frame_dirs[i] = 'bottom'
            elif mc < cc:
                frame_dirs[i] = 'left'
            else:
                frame_dirs[i] = 'right'
            break

    for i in range(len(frame_dirs)):
        if frame_dirs[i] is None:
            frame_dirs[i] = 'top'

    # Recreate output following the generator's rule
    output = [row[:] for row in grid]
    for (top, left, bottom, right), d in zip(frames, frame_dirs):
        if d in ('top', 'bottom'):
            for r in range(top + 1, bottom - 1):
                if output[r][cc] == 0:
                    output[r][cc] = 1
        else:
            for c in range(left + 1, right - 1):
                if output[cr][c] == 0:
                    output[cr][c] = 1

    outer_dir = frame_dirs[0]
    if outer_dir == 'top':
        for r in range(0, top0):
            if output[r][cc] == 0:
                output[r][cc] = 1
    elif outer_dir == 'bottom':
        for r in range(bottom0, height):
            if output[r][cc] == 0:
                output[r][cc] = 1
    elif outer_dir == 'left':
        for c in range(0, left0):
            if output[cr][c] == 0:
                output[cr][c] = 1
    else:
        for c in range(right0, width):
            if output[cr][c] == 0:
                output[cr][c] = 1

    if output[cr][cc] == 0:
        output[cr][cc] = 1

    return output

