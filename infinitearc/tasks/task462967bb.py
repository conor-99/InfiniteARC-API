# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 462967bb
Difficulty: hard

=== Tags ===
- Symmetry axis completion
- Local symmetry matching
- Color clock
- Local convolution rule

=== Description ===
Input grids feature a vertical symmetry axis with the left half populated by
colored cells (0-9) and the right half empty (background color 0). A 2x2 color
sequence in the top-left corner defines a cyclic color order (e.g., [2,5,7,3] →
cycle: 2→5→7→3→2...). The output grid completes the right half by mirroring the
left, but each cell's color is shifted forward in the defined cycle. Crucially,
cells forming a 2x2 symmetric block (where all four cells mirror exactly across
the axis) retain their original color (no shift), while cells adjacent to the
symmetry axis remain unchanged. The transformation requires identifying the
axis, extracting the cycle from the top-left sequence, and applying color shifts
selectively based on local symmetry conditions. This combines global symmetry
completion with local pattern-based color manipulation, demanding multi-step
reasoning to distinguish between standard shifts and exceptions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    m = random.randint(1, 15)
    w = 2 * m
    h = random.randint(2, 30)
    
    input_grid = [[0] * w for _ in range(h)]
    cycle = random.sample(range(1, 10), 4)
    
    for r in range(2):
        for c in range(2):
            input_grid[r][c] = cycle[r*2 + c]
    
    mono_color = random.choice(cycle)
    for r in range(2, 4):
        for c in range(2):
            if r < h and c < m:
                input_grid[r][c] = mono_color
    
    for r in range(h):
        for c in range(m):
            if input_grid[r][c] == 0:
                input_grid[r][c] = random.choice(cycle)
    
    output_grid = [row[:] for row in input_grid]
    for r in range(h):
        for c in range(m):
            mirror_c = w - 1 - c
            if c == m - 1:
                output_grid[r][mirror_c] = input_grid[r][c]
            else:
                if r + 1 < h and c + 1 < m:
                    if input_grid[r][c] == input_grid[r][c+1] == input_grid[r+1][c] == input_grid[r+1][c+1]:
                        output_grid[r][mirror_c] = input_grid[r][c]
                    else:
                        idx = cycle.index(input_grid[r][c])
                        next_idx = (idx + 1) % 4
                        output_grid[r][mirror_c] = cycle[next_idx]
                else:
                    idx = cycle.index(input_grid[r][c])
                    next_idx = (idx + 1) % 4
                    output_grid[r][mirror_c] = cycle[next_idx]
    
    assert input_grid != output_grid
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    w = len(input_list[0])
    h = len(input_list)
    m = w // 2
    
    a, b = input_list[0][0], input_list[0][1]
    c, d = input_list[1][0], input_list[1][1]
    cycle = [a, b, c, d]
    
    output_grid = [row[:] for row in input_list]
    for r in range(h):
        for c in range(m):
            mirror_c = w - 1 - c
            if c == m - 1:
                output_grid[r][mirror_c] = input_list[r][c]
            else:
                if r + 1 < h and c + 1 < m:
                    if input_list[r][c] == input_list[r][c+1] == input_list[r+1][c] == input_list[r+1][c+1]:
                        output_grid[r][mirror_c] = input_list[r][c]
                    else:
                        idx = cycle.index(input_list[r][c])
                        next_idx = (idx + 1) % 4
                        output_grid[r][mirror_c] = cycle[next_idx]
                else:
                    idx = cycle.index(input_list[r][c])
                    next_idx = (idx + 1) % 4
                    output_grid[r][mirror_c] = cycle[next_idx]
    
    return tuple(tuple(row) for row in output_grid)
