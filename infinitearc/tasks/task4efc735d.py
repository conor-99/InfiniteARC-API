# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 4efc735d
Difficulty: very hard

=== Tags ===
- State transition by contact
- Line collision
- Measure area

=== Description ===
Dynamic Wall Resonance  Input grids feature a background color (0), solid
rectangular walls (each a contiguous block of a single non-background color),
and particles (color 9) positioned such that each moves horizontally rightward
toward an adjacent wall. Output grids update the color of each wall contacted by
a particle to (area mod 9) + 1, where area is the wall's cell count (width Ã—
height). Walls not contacted retain their original color. Particles are removed
from the output grid. The transformation requires identifying rectangular walls,
measuring their area, applying the modular color mapping, and determining
contact via particle movement direction. Walls must be axis-aligned rectangles
with no holes or gaps to qualify for area measurement.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Choose a grid size that leaves room for walls and left-side particles
    width = random.randint(3, 20)
    height = random.randint(3, 20)

    # Create empty grid
    grid = [[0 for _ in range(width)] for _ in range(height)]
    walls = []  # each entry: dict with keys top,left,w,h,color

    # Decide how many walls to try to place
    max_walls = random.randint(1, min(6, (width * height) // 6 if (width * height) // 6 >= 1 else 1))

    # Helper to check that a rectangle and its immediate neighbors are free (prevents orthogonal adjacency/merging)
    def area_and_margin_free(top, left, w, h):
        r0 = max(0, top - 1)
        r1 = min(height - 1, top + h)
        c0 = max(0, left - 1)
        c1 = min(width - 1, left + w)
        for rr in range(r0, r1 + 1):
            for cc in range(c0, c1 + 1):
                if grid[rr][cc] != 0:
                    return False
        return True

    # Try to place walls randomly without overlap
    attempts = 0
    while len(walls) < max_walls and attempts < 500:
        attempts += 1
        # For the first wall, prefer placing it with left > 0 so we can place a particle to its left
        if len(walls) == 0 and width > 1:
            w = random.randint(1, min(6, width - 1))
            left = random.randint(1, width - w)
        else:
            w = random.randint(1, min(6, width))
            left = random.randint(0, width - w)
        h = random.randint(1, min(6, height))
        top = random.randint(0, height - h)
        # Check overlap and immediate margin
        if not area_and_margin_free(top, left, w, h):
            continue
        color = random.randint(1, 8)  # walls use colors 1..8, reserve 9 for particles
        for r in range(top, top + h):
            for c in range(left, left + w):
                grid[r][c] = color
        walls.append({"top": top, "left": left, "w": w, "h": h, "color": color})

    # If no walls were placed (very unlikely), place one explicitly
    if not walls:
        w = min(2, width - 1) if width > 1 else 1
        h = min(2, height)
        top = 0
        left = 1 if width > 1 else 0
        color = random.randint(1, 8)
        for r in range(top, top + h):
            for c in range(left, left + w):
                grid[r][c] = color
        walls.append({"top": top, "left": left, "w": w, "h": h, "color": color})

    # Find walls that can be contacted from the left (left > 0 and left-of-column is free)
    candidates = []
    for i, winfo in enumerate(walls):
        left = winfo["left"]
        top = winfo["top"]
        h = winfo["h"]
        if left <= 0:
            continue
        free = True
        for r in range(top, top + h):
            if grid[r][left - 1] != 0:
                free = False
                break
        if free:
            candidates.append(i)

    # If no candidate walls (extremely unlikely because first wall was placed with left>0), try to add one
    if not candidates:
        for _ in range(200):
            if width > 1:
                w = random.randint(1, min(6, width - 1))
                left = random.randint(1, width - w)
            else:
                w = 1
                left = 0
            h = random.randint(1, min(6, height))
            top = random.randint(0, height - h)
            # Check overlap + margin
            if not area_and_margin_free(top, left, w, h):
                continue
            # ensure left-of-wall column is free
            free = True
            for r in range(top, top + h):
                if grid[r][left - 1] != 0:
                    free = False
                    break
            if not free:
                continue
            color = random.randint(1, 8)
            for r in range(top, top + h):
                for c in range(left, left + w):
                    grid[r][c] = color
            walls.append({"top": top, "left": left, "w": w, "h": h, "color": color})
            candidates.append(len(walls) - 1)
            break

    # Choose at least one contacted wall from candidates
    if candidates:
        num_contact = random.randint(1, max(1, len(candidates)))
        contact_indices = random.sample(candidates, num_contact)
    else:
        # As a safe fallback (should not happen with the above logic), pick a wall that has left>0 if any
        contact_indices = [i for i, w in enumerate(walls) if w["left"] > 0]
        if not contact_indices:
            contact_indices = [0]

    # Ensure contacted walls will change color (original color != (area%9)+1)
    for idx in contact_indices:
        winfo = walls[idx]
        area = winfo["w"] * winfo["h"]
        new_color = (area % 9) + 1
        if winfo["color"] == new_color:
            # pick a different initial color (1..8 excluding new_color)
            choices = [c for c in range(1, 9) if c != new_color]
            new_initial = random.choice(choices) if choices else (new_color % 8) + 1
            winfo["color"] = new_initial
            for r in range(winfo["top"], winfo["top"] + winfo["h"]):
                for c in range(winfo["left"], winfo["left"] + winfo["w"]):
                    grid[r][c] = new_initial

    # Place one particle (color 9) per contacted wall at the vertical center, immediately to the left
    particle_positions = []
    for idx in contact_indices:
        winfo = walls[idx]
        r = winfo["top"] + (winfo["h"] - 1) // 2
        c = winfo["left"] - 1
        if c >= 0 and grid[r][c] == 0:
            grid[r][c] = 9
            particle_positions.append((r, c))

    # Build output grid: copy input and then change colors of contacted walls, and remove particles
    output = [row[:] for row in grid]
    for idx in contact_indices:
        winfo = walls[idx]
        area = winfo["w"] * winfo["h"]
        new_color = (area % 9) + 1
        for r in range(winfo["top"], winfo["top"] + winfo["h"]):
            for c in range(winfo["left"], winfo["left"] + winfo["w"]):
                output[r][c] = new_color
    # Remove particles from output only (set those positions to background)
    for (r, c) in particle_positions:
        if 0 <= r < height and 0 <= c < width:
            output[r][c] = 0

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0]) if h > 0 else 0

    # Record initial particle positions (color 9) so we only remove those at the end
    particle_positions = set()
    for r in range(h):
        for c in range(w):
            if grid[r][c] == 9:
                particle_positions.add((r, c))

    visited = [[False] * w for _ in range(h)]
    walls = []  # list of (top,left,width,height,color)

    for r in range(h):
        for c in range(w):
            if grid[r][c] == 0 or grid[r][c] == 9 or visited[r][c]:
                continue
            color = grid[r][c]
            # BFS to collect connected component of this color
            q = deque()
            q.append((r, c))
            visited[r][c] = True
            component = []
            while q:
                cr, cc = q.popleft()
                component.append((cr, cc))
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] == color:
                        visited[nr][nc] = True
                        q.append((nr, nc))
            # Bounding box
            min_r = min(p[0] for p in component)
            max_r = max(p[0] for p in component)
            min_c = min(p[1] for p in component)
            max_c = max(p[1] for p in component)
            # Verify component fills the bounding rectangle entirely with the same color
            is_rect = True
            for rr in range(min_r, max_r + 1):
                for cc in range(min_c, max_c + 1):
                    if grid[rr][cc] != color:
                        is_rect = False
                        break
                if not is_rect:
                    break
            if is_rect:
                walls.append((min_r, min_c, max_c - min_c + 1, max_r - min_r + 1, color))

    # For each wall, check whether there's at least one particle immediately to its left in the same row
    for top, left, width_w, height_h, color in walls:
        hit = False
        check_col = left - 1
        if check_col >= 0:
            for rr in range(top, top + height_h):
                if grid[rr][check_col] == 9:
                    hit = True
                    break
        if hit:
            area = width_w * height_h
            new_color = (area % 9) + 1
            for rr in range(top, top + height_h):
                for cc in range(left, left + width_w):
                    grid[rr][cc] = new_color

    # Remove only the original particles (do not clear newly painted walls that happen to use color 9)
    for (r, c) in particle_positions:
        if 0 <= r < h and 0 <= c < w:
            grid[r][c] = 0

    return tuple(tuple(row) for row in grid)

