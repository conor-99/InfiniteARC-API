# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 6d342246
Difficulty: hard

=== Tags ===
- Extrapolate image from grid
- Take maximum

=== Description ===
The task involves transforming an input grid into an output grid where each
pixel of the input is expanded into a block of size determined by the maximum
color value present in the entire input grid. The input grid contains multiple
connected regions of distinct colors (0-9), with at least one non-zero color.
The maximum color value (e.g., 7) in the input is identified, and the output
grid is constructed by replacing each input pixel with a block of size
(max_color × max_color) filled with the pixel's original color. For example, if
the input is a 3×3 grid with a maximum color of 4, the output becomes a 12×12
grid where each input cell is replaced by a 4×4 block of its color. This
transformation extrapolates the input image by uniformly scaling it based on the
highest color value, creating a larger grid that visually extends the input
pattern. The rule requires recognizing the global maximum color across all
pixels (not per region) and applying consistent scaling to all elements, making
it challenging due to the need to identify the global maximum in complex, multi-
colored grids and apply a uniform scaling factor rather than per-region
operations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    M = random.randint(2, 9)
    max_size = 30 // M
    H = random.randint(1, max_size)
    W = random.randint(1, max_size)
    grid = [[random.randint(0, M) for _ in range(W)] for _ in range(H)]
    if M not in [cell for row in grid for cell in row]:
        i, j = random.randint(0, H-1), random.randint(0, W-1)
        grid[i][j] = M
    output = []
    for i in range(H):
        for _ in range(M):
            row = []
            for j in range(W):
                row.extend([grid[i][j]] * M)
            output.append(row)
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid or not input_grid[0]:
        return input_grid
    M = max(max(row) for row in input_grid)
    H, W = len(input_grid), len(input_grid[0])
    output = []
    for i in range(H):
        for _ in range(M):
            row = []
            for j in range(W):
                row.extend([input_grid[i][j]] * M)
            output.append(row)
    return output
