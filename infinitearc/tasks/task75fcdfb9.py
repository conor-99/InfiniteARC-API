# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 75fcdfb9
Difficulty: insane

=== Tags ===
- Emergent behavior
- Source target routing
- Pathfinding with state
- Laser diffusion
- Pattern completion

=== Description ===
Input grids feature a 25×25 grid with a uniform background color (0), multiple
colored laser sources (1–9) positioned along the bottom edge, and matching
colored targets (1–9) positioned along the top edge. Scattered throughout the
grid are obstacles of distinct colors (5–9), each dictating a specific
reflection rule: obstacle color 5 reflects beams 90° left, color 6 reflects 90°
right, color 7 reflects 180° (reversing direction), and color 8 reflects 45°
diagonally. Each beam starts with the source’s color and cycles through a fixed
sequence (e.g., 1→2→3→1...) with every reflection. Beams travel upward from
sources through background cells until hitting an obstacle, then reflect
according to the obstacle’s color. When beams cross, their colors combine via a
fixed lookup (e.g., red + blue = purple) to form emergent colors, completing a
hidden pattern. Targets must be reached by beams matching their color; upon
contact, targets fill with their designated color. The output grid renders all
beam paths with their current color at each step, shows combined colors at
crossings, and fills targets, forming a symmetrical, multi-layered pattern
(e.g., a spiral or wave) that completes the visual sequence implied by the
input’s partial path elements. The transformation requires tracking beam states
(direction, color), resolving reflection rules, and recognizing how interactions
create the final pattern without relying on numerical properties.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = 25
    height = 25
    input_grid = common.grid(width, height, 0)
    
    # Place sources on bottom row (row 24)
    num_sources = random.randint(3, 5)
    source_cols = random.sample(range(width), num_sources)
    source_colors = [random.randint(1, 9) for _ in range(num_sources)]
    
    for c, color in zip(source_cols, source_colors):
        input_grid[height-1][c] = color
        input_grid[0][c] = color  # target

    # Place obstacles (5-9)
    obstacle_colors = [5, 6, 7, 8]
    num_obstacles = random.randint(10, 20)
    for _ in range(num_obstacles):
        r = random.randint(1, height-2)
        c = random.randint(0, width-1)
        if (r == height-1 or r == 0) or (c in source_cols):
            continue
        input_grid[r][c] = random.choice(obstacle_colors)

    output_grid = [row[:] for row in input_grid]
    
    def get_new_direction(current_dir, obstacle_color):
        dr, dc = current_dir
        if obstacle_color == 5:
            return (-dc, dr)
        elif obstacle_color == 6:
            return (dc, -dr)
        elif obstacle_color == 7:
            return (-dr, -dc)
        elif obstacle_color == 8:
            if dr == -1 and dc == 0:
                return (-1, 1)
            elif dr == 0 and dc == 1:
                return (1, 1)
            elif dr == 1 and dc == 0:
                return (1, -1)
            elif dr == 0 and dc == -1:
                return (-1, -1)
            else:
                return (dr, dc)
        return (dr, dc)

    for c, color in zip(source_cols, source_colors):
        r = height - 1
        current_dir = (-1, 0)
        current_color = color
        cur_r, cur_c = r, c
        while True:
            next_r = cur_r + current_dir[0]
            next_c = cur_c + current_dir[1]
            if next_r < 0 or next_r >= height or next_c < 0 or next_c >= width:
                break
            if next_r == 0 and input_grid[next_r][next_c] == current_color:
                break
            obstacle_color = input_grid[next_r][next_c]
            if 5 <= obstacle_color <= 8:
                current_dir = get_new_direction(current_dir, obstacle_color)
                current_color = (current_color % 9) + 1
                cur_r, cur_c = next_r, next_c
                continue
            if output_grid[next_r][next_c] == 0:
                output_grid[next_r][next_c] = current_color
            else:
                combined = (current_color + output_grid[next_r][next_c] - 1) % 9 + 1
                output_grid[next_r][next_c] = combined
            cur_r, cur_c = next_r, next_c

    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    output = [row[:] for row in grid]
    
    def get_new_direction(current_dir, obstacle_color):
        dr, dc = current_dir
        if obstacle_color == 5:
            return (-dc, dr)
        elif obstacle_color == 6:
            return (dc, -dr)
        elif obstacle_color == 7:
            return (-dr, -dc)
        elif obstacle_color == 8:
            if dr == -1 and dc == 0:
                return (-1, 1)
            elif dr == 0 and dc == 1:
                return (1, 1)
            elif dr == 1 and dc == 0:
                return (1, -1)
            elif dr == 0 and dc == -1:
                return (-1, -1)
            else:
                return (dr, dc)
        return (dr, dc)
    
    for c in range(width):
        if grid[height-1][c] > 0 and grid[height-1][c] <= 9:
            color = grid[height-1][c]
            cur_r, cur_c = height-1, c
            current_dir = (-1, 0)
            current_color = color
            while True:
                next_r = cur_r + current_dir[0]
                next_c = cur_c + current_dir[1]
                if next_r < 0 or next_r >= height or next_c < 0 or next_c >= width:
                    break
                if next_r == 0 and grid[next_r][next_c] == current_color:
                    break
                obstacle_color = grid[next_r][next_c]
                if 5 <= obstacle_color <= 8:
                    current_dir = get_new_direction(current_dir, obstacle_color)
                    current_color = (current_color % 9) + 1
                    cur_r, cur_c = next_r, next_c
                    continue
                if output[next_r][next_c] == 0:
                    output[next_r][next_c] = current_color
                else:
                    combined = (current_color + output[next_r][next_c] - 1) % 9 + 1
                    output[next_r][next_c] = combined
                cur_r, cur_c = next_r, next_c
    return output
