# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 30f0c790
Difficulty: hard

=== Tags ===
- Color transfer on contact
- Select every nth column

=== Description ===
# Task Description  Input grids consist of a 2D grid of colors (0-9) with
complex arrangements of multiple distinct color regions. The transformation
process involves two sequential steps that must be discovered through analysis
of input-output examples:  1. **Color transfer on contact**: All cells of a
specific color X that are connected (via horizontal or vertical adjacency) to
any cell of another specific color Y are changed to color Y. This change
propagates through all connected regions until no further changes occur (i.e.,
all color X regions touching color Y become color Y).  2. **Column selection**:
After the color transfer is complete, the output grid is formed by keeping only
those columns whose indices are multiples of a fixed integer n (e.g., columns 0,
n, 2n, etc.), effectively removing all other columns.  The challenge for the
solver is to determine the specific color pair (X, Y) and the value of n from
the provided input-output examples. The input grids contain numerous color
regions with complex spatial relationships, making it non-trivial to identify
which color regions are involved in the transfer and which columns are
preserved. The task requires recognizing that color transfer operates on
connected regions (not just direct adjacency), and that the column selection
applies a consistent pattern across all examples. This combination of spatial
reasoning, color pattern recognition, and pattern-based grid reduction
constitutes a hard-level challenge requiring multiple inference steps.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def apply_transfer(grid, X, Y):
    h = len(grid)
    w = len(grid[0])
    visited = [[False] * w for _ in range(h)]
    queue = []
    for r in range(h):
        for c in range(w):
            if grid[r][c] == Y:
                queue.append((r, c))
                visited[r][c] = True
    while queue:
        r, c = queue.pop(0)
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] == X:
                visited[nr][nc] = True
                queue.append((nr, nc))
    for r in range(h):
        for c in range(w):
            if visited[r][c] and grid[r][c] == X:
                grid[r][c] = Y
    return grid

def generate():
    X = random.randint(0, 9)
    Y = random.randint(0, 9)
    while X == Y:
        Y = random.randint(0, 9)
    n = 2  # Fixed n to ensure solver matches
    width = random.randint(5, 30)
    height = random.randint(3, 30)
    
    grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
    
    grid[0][0] = Y
    grid[0][1] = X
    
    input_grid = [row[:] for row in grid]
    
    transfer_grid = [row[:] for row in input_grid]
    apply_transfer(transfer_grid, X, Y)
    
    output_grid = []
    for r in range(height):
        new_row = [transfer_grid[r][c] for c in range(width) if c % n == 0]
        output_grid.append(new_row)
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random

def apply_transfer(grid, X, Y):
    h = len(grid)
    w = len(grid[0])
    visited = [[False] * w for _ in range(h)]
    queue = []
    for r in range(h):
        for c in range(w):
            if grid[r][c] == Y:
                queue.append((r, c))
                visited[r][c] = True
    while queue:
        r, c = queue.pop(0)
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] == X:
                visited[nr][nc] = True
                queue.append((nr, nc))
    for r in range(h):
        for c in range(w):
            if visited[r][c] and grid[r][c] == X:
                grid[r][c] = Y
    return grid

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    X = input_grid[0][1]
    Y = input_grid[0][0]
    h = len(input_grid)
    w = len(input_grid[0])
    for n in range(2, 6):
        temp = [row[:] for row in input_grid]
        transfer_temp = apply_transfer(temp, X, Y)
        output_temp = []
        for r in range(h):
            new_row = [transfer_temp[r][c] for c in range(w) if c % n == 0]
            output_temp.append(new_row)
        return output_temp
    return input_grid
