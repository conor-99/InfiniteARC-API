# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 1e6c1fb7
Difficulty: very hard

=== Tags ===
- Pattern to sequence mapping
- Task rule selection
- Cascade fountain
- Create grid
- Diagonals

=== Description ===
Input grids are large (minimum 15×15) with a single background color (0). Over
this background, multiple disjoint colored regions (1-9) form a complex, non-
overlapping arrangement where each region is a connected cluster of cells. A
critical visual feature is a "pattern sequence" embedded as a vertical line
along the leftmost column (column 0), where rows 1 through height-1 contain a
unique, non-background color sequence with no repetitions. The topmost cell of
this pattern sequence (row 1, column 0) shares its color with the "source
region" — a single cell or small cluster positioned in the top row (row 0) at
some column. The source region is always isolated from other regions and never
overlaps with the pattern sequence.  The output grid transforms the input by
generating a diagonal "cascade fountain" originating from the source region. The
cascade flows diagonally downward-right (southeast) from the source, with each
subsequent cell in the path colored using the pattern sequence cyclically. The
cascade occupies only background cells, avoiding all input regions. The sequence
begins with the color at (row 1, column 0), then (row 2, column 0), and so on,
repeating the sequence as the cascade extends. The cascade stops when it reaches
the grid's bottom or right edge. The direction (southeast) is fixed, but the
sequence mapping is derived strictly from the pattern sequence's visual order.
The output retains all input regions and the pattern sequence unchanged, with
the cascade drawn exclusively on background cells. The complexity arises from
the need to identify the source region, extract the pattern sequence, and apply
it precisely along the diagonal path without overlapping existing structures.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    h = random.randint(2, 10)
    w = random.randint(15, 30)
    grid = [[0] * w for _ in range(h)]
    
    pattern = random.sample(range(1, 10), h-1)
    for r in range(1, h):
        grid[r][0] = pattern[r-1]
    
    c = random.randint(1, w - h)
    grid[0][c] = pattern[0]
    
    for r in range(1, h):
        assert grid[r][c + r] == 0
    
    forbidden = set()
    for r in range(1, h):
        forbidden.add((r, 0))
        forbidden.add((r, c + r))
    forbidden.add((0, c))
    
    for _ in range(random.randint(1, 5)):
        color = random.randint(1, 9)
        # Avoid using source color in row 0
        if color == pattern[0]:
            color = random.choice([x for x in range(1, 10) if x != pattern[0]])
        pixels = []
        while len(pixels) < random.randint(1, 10):
            r = random.randint(0, h-1)
            c_pos = random.randint(0, w-1)
            if (r, c_pos) in forbidden or grid[r][c_pos] != 0:
                continue
            pixels.append((r, c_pos))
            grid[r][c_pos] = color
    
    output = [row[:] for row in grid]
    for r in range(1, h):
        col = c + r
        if col >= w:
            break
        output[r][col] = pattern[r-1]
    
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])
    
    pattern = []
    for r in range(1, h):
        if grid[r][0] != 0:
            pattern.append(grid[r][0])
    
    source_color = pattern[0]
    c = None
    for col in range(w):
        if grid[0][col] == source_color:
            c = col
            break
    if c is None:
        for col in range(w):
            if grid[0][col] != 0:
                c = col
                break
    
    for r in range(1, h):
        col = c + r
        if col >= w:
            break
        if grid[r][col] == 0:
            grid[r][col] = pattern[r-1]
    
    return tuple(tuple(row) for row in grid)
