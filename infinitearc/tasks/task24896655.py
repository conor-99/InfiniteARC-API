# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 24896655
Difficulty: easy

=== Tags ===
- Background filling
- Color guessing
- Image juxtaposition

=== Description ===
The task requires transforming an input grid into an output grid by filling all
background cells (value 0) with the most frequently occurring non-zero color in
the input. If multiple colors tie for the highest frequency, the smallest color
is chosen. The input grid must contain at least one non-zero cell and at least
one background cell (0), ensuring the output differs from the input. This rule
combines background filling (replacing 0s), color guessing (determining the
target color via frequency analysis), and image juxtaposition (the filled
background visually contrasts with the non-zero image elements).
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    w = random.randint(1, 30)
    h = random.randint(1, 30)
    while w * h < 2:
        w = random.randint(1, 30)
        h = random.randint(1, 30)
    input_grid = common.grid(w, h, 0)
    total_cells = w * h
    num_nonzero = random.randint(1, total_cells - 1)
    all_pixels = [(r, c) for r in range(h) for c in range(w)]
    random.shuffle(all_pixels)
    for i in range(num_nonzero):
        r, c = all_pixels[i]
        input_grid[r][c] = common.random_color(exclude=[0])
    colors = [input_grid[r][c] for r in range(h) for c in range(w) if input_grid[r][c] != 0]
    if not colors:
        target_color = 1
    else:
        color_count = {}
        for color in colors:
            color_count[color] = color_count.get(color, 0) + 1
        max_count = max(color_count.values())
        candidates = [color for color, count in color_count.items() if count == max_count]
        target_color = min(candidates)
    output_grid = [[target_color if cell == 0 else cell for cell in row] for row in input_grid]
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    h = len(input_grid)
    w = len(input_grid[0])
    colors = []
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] != 0:
                colors.append(input_grid[r][c])
    if not colors:
        target_color = 1
    else:
        color_count = {}
        for color in colors:
            color_count[color] = color_count.get(color, 0) + 1
        max_count = max(color_count.values())
        candidates = [color for color, count in color_count.items() if count == max_count]
        target_color = min(candidates)
    output_grid = [[target_color if cell == 0 else cell for cell in row] for row in input_grid]
    return output_grid
