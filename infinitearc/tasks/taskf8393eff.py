# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: f8393eff
Difficulty: easy

=== Tags ===
- Pattern moving

=== Description ===
The input grid contains a connected pattern of non-zero values (representing a
single color) positioned such that shifting it one column to the right remains
within the grid boundaries. The output grid is formed by moving each non-zero
cell of the pattern one column to the right, with the original positions set to
zero. All other cells remain zero. For example, a pattern occupying cells (0,0)
and (1,0) in the input will occupy cells (0,1) and (1,1) in the output, while
the original positions (0,0) and (1,0) become zero. The transformation is
consistent across all non-zero cells, with no wraparound or edge effects, as the
input pattern is always placed at least one column away from the right edge.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = random.randint(2, 30)
    height = random.randint(1, 30)
    if width == 2:
        s = 0
        l = 1
    else:
        s = random.randint(0, width - 3)
        l = random.randint(1, width - 2 - s)
    r = random.randint(0, height - 1)
    pixels = [(r, c) for c in range(s, s + l)]
    color = common.random_color()
    input_grid = common.grid(width, height, 0)
    for (row, col) in pixels:
        input_grid[row][col] = color
    output_grid = common.grid(width, height, 0)
    for (row, col) in pixels:
        output_grid[row][col + 1] = color
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    h = len(input_grid)
    w = len(input_grid[0])
    output = common.grid(w, h, 0)
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] != 0:
                output[r][c+1] = input_grid[r][c]
    return output
