# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 226c1211
Difficulty: medium–hard

=== Tags ===
- Dynamic environment
- Loopless path
- Pattern expansion
- Pathfinding with state
- Fractal repetition

=== Description ===
Input grids feature a background color (e.g., gray) overlaid with a single,
continuous red path starting at the top-left corner and winding through the
grid. Along this path, embedded markers—small squares of distinct colors (e.g.,
green, blue, yellow)—are placed at regular intervals. Each marker color encodes
a directional transformation rule: green signifies a 90° right turn, blue a 90°
left turn, and yellow indicates continuation in the current direction. The path
must be followed sequentially from start to finish, processing each marker in
order.  Output grids display the path transformed via recursive fractal
expansion. Starting from the initial path, each marker triggers a local
expansion: the segment following the marker is replaced by a scaled-down,
rotated copy of the entire path’s directional sequence (e.g., a green marker
causes the next segment to branch into a right-turning sub-path mirroring the
original sequence). This expansion repeats recursively at each marker, reducing
scale and rotating direction per the marker’s rule, until the path reaches the
grid boundary or all markers are processed. The transformed path is drawn in a
new color (e.g., cyan), while the original path and markers remain visible but
unchanged. The output maintains a strictly loopless path with no overlapping
segments, and the fractal repetition ensures self-similar pattern scaling at
each recursive level.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from typing import List, Dict, Tuple
from common import grid

# Generator for ARC task 489 (serpentine base path with recursive fractal expansions)

def round_div(x: int, s: int) -> int:
    """Round x/s to nearest integer using integer arithmetic, symmetric for negatives."""
    if s == 1:
        return x
    half = s // 2
    if x >= 0:
        return (x + half) // s
    else:
        return -(((-x) + half) // s)


def rotate_by(rot: int, r: int, c: int) -> Tuple[int, int]:
    """Rotate (r,c) by rot*90 degrees clockwise around the origin.

    Coordinates are (row, col) where row increases downward and col increases rightward.
    Rotation mapping used consistently in generator and solver:
      rot=0 -> (r, c)
      rot=1 -> clockwise 90 -> (-c, r)
      rot=2 -> 180 -> (-r, -c)
      rot=3 -> counterclockwise 90 -> (c, -r)
    """
    rot = rot % 4
    if rot == 0:
        return (r, c)
    if rot == 1:
        return (-c, r)
    if rot == 2:
        return (-r, -c)
    return (c, -r)


def generate() -> Dict[str, List[List[int]]]:
    """Generate a single input/output pair.

    - Constructs a compact serpentine path starting at (0,0) in the top-left.
    - Places markers at regular intervals along that path (colors 3,1,4).
    - Produces an output where each marker triggers a scaled, rotated copy of the
      entire base path (drawn in color 8) anchored at the marker. The copies
      are generated recursively at the positions corresponding to the original
      markers inside each scaled copy.
    """
    # Grid size
    width = random.randint(12, 20)
    height = random.randint(12, 20)

    bg = 5  # background (gray)
    path_color = 2  # original path (red)
    cyan = 8  # expanded fractal color
    marker_palette = [3, 1, 4]  # green=3 (right), blue=1 (left), yellow=4 (straight)

    # Build a compact serpentine base path in the top-left corner.
    max_base_rows = min(8, height - 4)
    max_base_cols = min(8, width - 4)
    base_rows = random.randint(4, max_base_rows)
    base_cols = random.randint(4, max_base_cols)

    base_path = []
    for r in range(base_rows):
        if r % 2 == 0:
            for c in range(base_cols):
                base_path.append((r, c))
        else:
            for c in range(base_cols - 1, -1, -1):
                base_path.append((r, c))

    # Ensure the path starts at (0,0)
    origin = base_path[0]

    # Create input grid and draw the base path in path_color
    input_grid = grid(width, height, bg)
    for (r, c) in base_path:
        input_grid[r][c] = path_color

    # Place markers at a regular interval (but not on the start)
    spacing = random.randint(3, max(3, len(base_path) // 4))
    start_index = 2 if len(base_path) < 10 else 3
    marker_indices = list(range(start_index, len(base_path), spacing))
    # At least one marker
    if len(marker_indices) == 0 and len(base_path) > 5:
        marker_indices = [min(3, len(base_path) - 1)]

    # Assign marker colors randomly among the three choices
    markers = []  # list of (index, color)
    for mi in marker_indices:
        color = random.choice(marker_palette)
        markers.append((mi, color))
        r, c = base_path[mi]
        input_grid[r][c] = color

    # Prepare output grid (copy of input) and perform recursive expansions
    output_grid = [row[:] for row in input_grid]

    # Fixed integer scale factor for the fractal reduction (kept constant so solver
    # can reconstruct exactly). Using 2 makes nested copies visible but small.
    scale_factor = 2
    max_depth = 4  # limit recursion depth to avoid huge copies

    visited = set()  # to avoid re-expanding same anchor/rotation/scale

    def expand_at(anchor_r: int, anchor_c: int, rot: int, depth: int):
        key = (anchor_r, anchor_c, rot, depth)
        if key in visited:
            return
        visited.add(key)

        # Current scale is scale_factor ** depth
        scale = scale_factor ** depth

        # Map base path points, rotating then scaling relative to anchor
        mapped = []
        for (pr, pc) in base_path:
            rr, rc = rotate_by(rot, pr - origin[0], pc - origin[1])
            mr = anchor_r + round_div(rr, scale)
            mc = anchor_c + round_div(rc, scale)
            mapped.append((mr, mc))

        # Remove consecutive duplicates to avoid stuttering
        dedup = []
        for p in mapped:
            if len(dedup) == 0 or p != dedup[-1]:
                dedup.append(p)
        if not dedup:
            return

        # Draw a 4-connected polyline between successive mapped points.
        r0, c0 = dedup[0]
        # draw the starting pixel if it's on background only
        if 0 <= r0 < height and 0 <= c0 < width and output_grid[r0][c0] == bg:
            output_grid[r0][c0] = cyan
        for (r1, c1) in dedup[1:]:
            # move in row then column (deterministic) to connect points
            while r0 != r1:
                r0 += 1 if r1 > r0 else -1
                if 0 <= r0 < height and 0 <= c0 < width and output_grid[r0][c0] == bg:
                    output_grid[r0][c0] = cyan
            while c0 != c1:
                c0 += 1 if c1 > c0 else -1
                if 0 <= r0 < height and 0 <= c0 < width and output_grid[r0][c0] == bg:
                    output_grid[r0][c0] = cyan
        # Recurse at the positions corresponding to the original markers (if depth limit not reached)
        if depth >= max_depth:
            return
        for (midx, mcolor) in markers:
            pr, pc = base_path[midx]
            rr, rc = rotate_by(rot, pr - origin[0], pc - origin[1])
            mr = anchor_r + round_div(rr, scale)
            mc = anchor_c + round_div(rc, scale)
            if not (0 <= mr < height and 0 <= mc < width):
                continue
            # Map marker color to rotation increment: green (3)=+1 cw, blue (1)= -1 -> +3, yellow (4)=0
            color_to_rot = {3: 1, 1: 3, 4: 0}
            inc = color_to_rot.get(mcolor, 0)
            new_rot = (rot + inc) % 4
            expand_at(mr, mc, new_rot, depth + 1)

    # Trigger expansions for the original markers on the base path
    for (midx, mcolor) in markers:
        r_anchor, c_anchor = base_path[midx]
        color_to_rot = {3: 1, 1: 3, 4: 0}
        initial_rot = color_to_rot.get(mcolor, 0)
        expand_at(r_anchor, c_anchor, initial_rot, 1)

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from typing import List, Tuple


def round_div(x: int, s: int) -> int:
    if s == 1:
        return x
    half = s // 2
    if x >= 0:
        return (x + half) // s
    else:
        return -(((-x) + half) // s)


def rotate_by(rot: int, r: int, c: int) -> Tuple[int, int]:
    rot = rot % 4
    if rot == 0:
        return (r, c)
    if rot == 1:
        return (-c, r)
    if rot == 2:
        return (-r, -c)
    return (c, -r)


def p(input_grid):
    # Convert to a mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Use the known generator background color (kept constant)
    bg = 5

    # Colors used
    path_colors = {2, 3, 1, 4}  # 2 is red path, other values are markers placed on path

    # Collect all path coordinates (including markers)
    path_cells = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] in path_colors:
                path_cells.append((r, c))

    if not path_cells:
        return grid

    # Bounding box of the base serpentine rectangle (generator places the base path in top-left)
    min_r = min(r for r, c in path_cells)
    max_r = max(r for r, c in path_cells)
    min_c = min(c for r, c in path_cells)
    max_c = max(c for r, c in path_cells)

    # Reconstruct the base_path as a serpentine filling of the bounding box.
    base_rows = max_r - min_r + 1
    base_cols = max_c - min_c + 1
    base_path = []
    for rr in range(base_rows):
        if rr % 2 == 0:
            for cc in range(base_cols):
                base_path.append((min_r + rr, min_c + cc))
        else:
            for cc in range(base_cols - 1, -1, -1):
                base_path.append((min_r + rr, min_c + cc))

    # Map coordinates to indices
    coord_to_index = {coord: i for i, coord in enumerate(base_path)}

    # Collect markers as (index, color) using base_path indexing
    markers = []
    for coord, i in coord_to_index.items():
        r, c = coord
        if grid[r][c] in [3, 1, 4]:
            markers.append((i, grid[r][c]))

    # Prepare output grid (copy of input)
    out = [row[:] for row in grid]

    # Use same fixed parameters as generator
    scale_factor = 2
    max_depth = 4

    visited_expansions = set()

    def expand_at(anchor_r: int, anchor_c: int, rot: int, depth: int):
        key = (anchor_r, anchor_c, rot, depth)
        if key in visited_expansions:
            return
        visited_expansions.add(key)
        scale = scale_factor ** depth

        # Map the base_path by rotation and scaling about the anchor
        origin = base_path[0]
        mapped = []
        for (pr, pc) in base_path:
            rr, rc = rotate_by(rot, pr - origin[0], pc - origin[1])
            mr = anchor_r + round_div(rr, scale)
            mc = anchor_c + round_div(rc, scale)
            mapped.append((mr, mc))

        # Deduplicate consecutive duplicates
        dedup = []
        for p in mapped:
            if not dedup or p != dedup[-1]:
                dedup.append(p)
        if not dedup:
            return

        # Draw 4-connected polyline, writing cyan only on background cells
        cyan = 8
        r0, c0 = dedup[0]
        if 0 <= r0 < height and 0 <= c0 < width and out[r0][c0] == bg:
            out[r0][c0] = cyan
        for (r1, c1) in dedup[1:]:
            while r0 != r1:
                r0 += 1 if r1 > r0 else -1
                if 0 <= r0 < height and 0 <= c0 < width and out[r0][c0] == bg:
                    out[r0][c0] = cyan
            while c0 != c1:
                c0 += 1 if c1 > c0 else -1
                if 0 <= r0 < height and 0 <= c0 < width and out[r0][c0] == bg:
                    out[r0][c0] = cyan

        # Recurse at mapped marker positions
        if depth >= max_depth:
            return
        color_to_rot = {3: 1, 1: 3, 4: 0}
        for (midx, mcolor) in markers:
            pr, pc = base_path[midx]
            rr, rc = rotate_by(rot, pr - origin[0], pc - origin[1])
            mr = anchor_r + round_div(rr, scale)
            mc = anchor_c + round_div(rc, scale)
            if not (0 <= mr < height and 0 <= mc < width):
                continue
            inc = color_to_rot.get(mcolor, 0)
            new_rot = (rot + inc) % 4
            expand_at(mr, mc, new_rot, depth + 1)

    # Trigger expansions for the original markers using their base_path indices
    color_to_rot = {3: 1, 1: 3, 4: 0}
    for (midx, mcolor) in markers:
        r_anchor, c_anchor = base_path[midx]
        initial_rot = color_to_rot.get(mcolor, 0)
        expand_at(r_anchor, c_anchor, initial_rot, 1)

    return out

