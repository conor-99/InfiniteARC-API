# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: dfbbbec7
Difficulty: easy

=== Tags ===
- Pattern juxtaposition
- Pattern rotation
- Isolate largest component
- Image within image

=== Description ===
The input grid contains multiple distinct connected regions (components) of the
same color, forming shapes within the grid. The task requires identifying the
largest connected component (by pixel count, using 4-connectivity) and isolating
it. The largest component is then rotated 90 degrees clockwise to form the
output grid. The output grid contains only the rotated component, with all other
pixels set to 0, and its dimensions match the rotated dimensions of the original
component (e.g., a 2×3 component becomes 3×2 after rotation). This task combines
pattern rotation (applying a 90-degree rotation to the largest shape) and
isolating the largest component, while the "image within image" aspect refers to
the largest shape being a contained sub-image within the input grid that is
transformed into the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
from collections import deque

def generate():
    width = common.randint(5, 15)
    height = common.randint(5, 15)
    input_grid = [[0] * width for _ in range(height)]
    main_color = common.randint(1, 9)
    main_size = common.randint(9, 25)
    main_pixels = common.continuous_creature(main_size, width, height)
    for (r, c) in main_pixels:
        input_grid[r][c] = main_color
    num_small_components = common.randint(1, 3)
    for _ in range(num_small_components):
        small_size = common.randint(1, 2)
        small_color = common.randint(1, 9)
        if small_color == main_color:
            small_color = (small_color % 9) + 1
        while True:
            r = common.randint(0, height - 1)
            c = common.randint(0, width - 1)
            if input_grid[r][c] == 0:
                if small_size == 1:
                    input_grid[r][c] = small_color
                else:
                    if c + 1 < width and input_grid[r][c+1] == 0:
                        input_grid[r][c] = small_color
                        input_grid[r][c+1] = small_color
                    else:
                        continue
                break
    visited = [[False] * width for _ in range(height)]
    components = []
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and input_grid[r][c] != 0:
                component = []
                queue = deque([(r, c)])
                visited[r][c] = True
                color = input_grid[r][c]
                while queue:
                    cr, cc = queue.popleft()
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                components.append(component)
    largest_comp = max(components, key=len)
    min_r = min(r for r, c in largest_comp)
    max_r = max(r for r, c in largest_comp)
    min_c = min(c for r, c in largest_comp)
    max_c = max(c for r, c in largest_comp)
    comp_width = max_c - min_c + 1
    comp_height = max_r - min_r + 1
    subgrid = [[0] * comp_width for _ in range(comp_height)]
    for r, c in largest_comp:
        subgrid[r - min_r][c - min_c] = input_grid[r][c]
    subgrid_reversed = subgrid[::-1]
    rotated_subgrid = [list(row) for row in zip(*subgrid_reversed)]
    return {"input": input_grid, "output": rotated_subgrid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
from collections import deque

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    visited = [[False] * width for _ in range(height)]
    components = []
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and input_grid[r][c] != 0:
                component = []
                queue = deque([(r, c)])
                visited[r][c] = True
                color = input_grid[r][c]
                while queue:
                    cr, cc = queue.popleft()
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                components.append(component)
    largest_comp = max(components, key=len)
    min_r = min(r for r, c in largest_comp)
    max_r = max(r for r, c in largest_comp)
    min_c = min(c for r, c in largest_comp)
    max_c = max(c for r, c in largest_comp)
    comp_width = max_c - min_c + 1
    comp_height = max_r - min_r + 1
    subgrid = [[0] * comp_width for _ in range(comp_height)]
    for r, c in largest_comp:
        subgrid[r - min_r][c - min_c] = input_grid[r][c]
    subgrid_reversed = subgrid[::-1]
    rotated_subgrid = [list(row) for row in zip(*subgrid_reversed)]
    return rotated_subgrid
