# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: f18c1c3f
Difficulty: medium

=== Tags ===
- Cylindrical
- Bring patterns close
- Associate images to colors
- Count shapes

=== Description ===
The input grid is a cylindrical grid where the left and right edges are
connected (horizontal wrap-around). Each non-zero cell belongs to a connected
component (shape), defined by 4-directional adjacency (up, down, left, right).
The task requires two sequential transformations:    1. **Bring patterns
close**: For each row, shift non-zero cells horizontally (with wrap-around) to
form a contiguous block starting from the leftmost position. This minimizes
horizontal gaps between patterns within the row, leveraging the cylindrical
property to wrap patterns around the grid’s edges if necessary.    2.
**Associate images to colors**: Replace all non-zero cells with the color equal
to the total count of connected components (shapes) in the input grid. For
example, if the input contains 4 distinct shapes, all non-zero cells in the
output become color 4.    The output grid preserves the background (0) and
ensures no input grid matches its output (due to the color transformation and
spatial rearrangement). The rules are visual, relying on connectivity, spatial
arrangement, and component counting—without numerical operations or pixel-level
matching.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_color, random_pixels

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    pixels = random_pixels(width, height, prob=0.5)
    if not pixels:
        pixels = [(0, 0)]
    input_grid = grid(width, height, 0)
    for (r, c) in pixels:
        input_grid[r][c] = random_color(exclude=[0])
    
    visited = [[False] * width for _ in range(height)]
    N = 0
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                N += 1
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
    
    output_grid = grid(width, height, 0)
    for r in range(height):
        non_zeros = [input_grid[r][c] for c in range(width) if input_grid[r][c] != 0]
        new_row = non_zeros + [0] * (width - len(non_zeros))
        for c in range(width):
            if new_row[c] != 0:
                new_row[c] = N
        output_grid[r] = new_row
    
    while input_grid == output_grid or N > 9:
        width = random.randint(1, 30)
        height = random.randint(1, 30)
        pixels = random_pixels(width, height, prob=0.5)
        if not pixels:
            pixels = [(0, 0)]
        input_grid = grid(width, height, 0)
        for (r, c) in pixels:
            input_grid[r][c] = random_color(exclude=[0])
        
        visited = [[False] * width for _ in range(height)]
        N = 0
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] != 0 and not visited[r][c]:
                    N += 1
                    queue = [(r, c)]
                    visited[r][c] = True
                    while queue:
                        cr, cc = queue.pop(0)
                        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0 and not visited[nr][nc]:
                                visited[nr][nc] = True
                                queue.append((nr, nc))
        
        output_grid = grid(width, height, 0)
        for r in range(height):
            non_zeros = [input_grid[r][c] for c in range(width) if input_grid[r][c] != 0]
            new_row = non_zeros + [0] * (width - len(non_zeros))
            for c in range(width):
                if new_row[c] != 0:
                    new_row[c] = N
            output_grid[r] = new_row
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    visited = [[False] * width for _ in range(height)]
    N = 0
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                N += 1
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
    output_grid = grid(width, height, 0)
    for r in range(height):
        non_zeros = [input_grid[r][c] for c in range(width) if input_grid[r][c] != 0]
        new_row = non_zeros + [0] * (width - len(non_zeros))
        for c in range(width):
            if new_row[c] != 0:
                new_row[c] = N
        output_grid[r] = new_row
    return output_grid
