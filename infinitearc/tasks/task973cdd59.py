# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 973cdd59
Difficulty: hard

=== Tags ===
- Associate colors to colors
- Detect repetition

=== Description ===
The task involves transforming an input grid into an output grid by replacing
each color based on its frequency rank. The frequency rank is determined by
sorting colors from highest to lowest frequency; in case of ties, colors are
sorted numerically in ascending order. The highest frequency color maps to 1,
the next highest to 2, and so on. The output grid uses these rank values as
colors, ensuring all values are within 0â€“9. The input grid must contain at least
two distinct colors to guarantee the output differs from the input, as a single-
color input would produce identical grids (violating task constraints). Solvers
must detect frequency patterns, resolve ties via numerical sorting, and apply
the rank-based mapping, requiring multi-step reasoning to distinguish from
simpler color substitution tasks.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    while True:
        width = random.randint(1, 30)
        height = random.randint(1, 30)
        if width * height >= 2:
            break
    k = random.randint(2, 9)
    colors = random.sample(range(0, 10), k)
    grid = [[random.choice(colors) for _ in range(width)] for _ in range(height)]
    all_colors = set()
    for row in grid:
        all_colors.update(row)
    missing = set(colors) - all_colors
    while missing:
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        color_to_add = missing.pop()
        grid[r][c] = color_to_add
    color_count = {}
    for r in range(height):
        for c in range(width):
            color = grid[r][c]
            color_count[color] = color_count.get(color, 0) + 1
    sorted_colors = sorted(color_count.keys(), key=lambda x: (-color_count[x], x))
    color_to_rank = {color: i+1 for i, color in enumerate(sorted_colors)}
    output_grid = [[color_to_rank[grid[r][c]] for c in range(width)] for r in range(height)]
    if grid == output_grid:
        return generate()
    return {"input": grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    color_count = {}
    for row in input_grid:
        for color in row:
            color_count[color] = color_count.get(color, 0) + 1
    sorted_colors = sorted(color_count.keys(), key=lambda x: (-color_count[x], x))
    color_to_rank = {color: i+1 for i, color in enumerate(sorted_colors)}
    output_grid = [[color_to_rank[color] for color in row] for row in input_grid]
    return output_grid
