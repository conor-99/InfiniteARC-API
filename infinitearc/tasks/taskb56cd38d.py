# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: b56cd38d
Difficulty: insane

=== Tags ===
- Compositional reflection
- Shape morphing
- Rotate each quadrant
- Proximity guessing

=== Description ===
Input grids are divided into four quadrants (top-left, top-right, bottom-left,
bottom-right), each containing a unique arrangement of colored shapes (e.g.,
squares, circles, triangles) on a uniform background. The output grid is
generated through the following sequence:    1. **Quadrant Rotation**: Each
quadrant is rotated 90° clockwise if it contains at least one shape of color 2
(red), otherwise counterclockwise. Rotation is applied independently to each
quadrant.   2. **Shape Morphing**: After rotation, any two shapes of the same
color that are horizontally or vertically adjacent merge into a single composite
shape (e.g., two squares merge into a larger square, a square and circle merge
into a shape combining both features).   3. **Compositional Reflection**: The
entire grid is reflected over the vertical axis (left-right flip), but only for
shapes that were involved in a morphing operation during step 2. All other
shapes retain their positions post-rotation.   4. **Proximity Validation**:
Morphing occurs only when shapes are directly adjacent (no gaps), requiring
solvers to infer the adjacency rule from examples (proximity guessing).    The
task demands recognizing quadrant-specific rotation cues, tracking shape
interactions post-rotation, and applying reflection selectively based on morphed
elements—all while avoiding numerical or positional heuristics. Input grids
feature complex arrangements with multiple overlapping shapes and color
variations, necessitating multi-step reasoning to deduce the interplay of
rotation, morphing, and reflection.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import *

def rotate_90_clockwise(grid):
    return [list(x)[::-1] for x in zip(*grid)]

def rotate_90_counterclockwise(grid):
    return [list(x) for x in zip(*grid)][::-1]

def generate():
    width = random.randint(4, 30)
    if width % 2 != 0:
        width += 1
    height = width  # Ensure square grid
    grid = [[0] * width for _ in range(height)]
    half_w = width // 2
    half_h = height // 2
    quadrants = [
        (0, 0, half_h, half_w),
        (0, half_w, half_h, width - half_w),
        (half_h, 0, height - half_h, half_w),
        (half_h, half_w, height - half_h, width - half_w)
    ]
    has_color2 = False
    for (start_r, start_c, h, w) in quadrants:
        for r in range(start_r, start_r + h):
            for c in range(start_c, start_c + w):
                if random.random() < 0.3:
                    color = random_color(exclude=[0])
                    grid[r][c] = color
                    if color == 2:
                        has_color2 = True
    if not has_color2:
        q_idx = random.randint(0, 3)
        start_r, start_c, h, w = quadrants[q_idx]
        r = random.randint(start_r, start_r + h - 1)
        c = random.randint(start_c, start_c + w - 1)
        grid[r][c] = 2
    top_left = [row[0:half_w] for row in grid[0:half_h]]
    top_right = [row[half_w:width] for row in grid[0:half_h]]
    bottom_left = [row[0:half_w] for row in grid[half_h:height]]
    bottom_right = [row[half_w:width] for row in grid[half_h:height]]
    def has_color2_in_quadrant(q):
        for row in q:
            if 2 in row:
                return True
        return False
    if has_color2_in_quadrant(top_left):
        top_left = rotate_90_clockwise(top_left)
    else:
        top_left = rotate_90_counterclockwise(top_left)
    if has_color2_in_quadrant(top_right):
        top_right = rotate_90_clockwise(top_right)
    else:
        top_right = rotate_90_counterclockwise(top_right)
    if has_color2_in_quadrant(bottom_left):
        bottom_left = rotate_90_clockwise(bottom_left)
    else:
        bottom_left = rotate_90_counterclockwise(bottom_left)
    if has_color2_in_quadrant(bottom_right):
        bottom_right = rotate_90_clockwise(bottom_right)
    else:
        bottom_right = rotate_90_counterclockwise(bottom_right)
    rotated_grid = []
    for i in range(half_h):
        rotated_grid.append(top_left[i] + top_right[i])
    for i in range(height - half_h):
        rotated_grid.append(bottom_left[i] + bottom_right[i])
    visited = [[False] * width for _ in range(height)]
    morphed_pixels = set()
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and rotated_grid[r][c] != 0:
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                color = rotated_grid[r][c]
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and rotated_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                if len(component) >= 2:
                    for (cr, cc) in component:
                        morphed_pixels.add((cr, cc))
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if (r, c) in morphed_pixels:
                new_c = width - 1 - c
                output_grid[r][new_c] = rotated_grid[r][c]
            else:
                output_grid[r][c] = rotated_grid[r][c]
    if grid == output_grid:
        return generate()
    return {"input": grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random
from common import *

def rotate_90_clockwise(grid):
    return [list(x)[::-1] for x in zip(*grid)]

def rotate_90_counterclockwise(grid):
    return [list(x) for x in zip(*grid)][::-1]

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    half_w = width // 2
    half_h = height // 2
    top_left = [row[0:half_w] for row in grid[0:half_h]]
    top_right = [row[half_w:width] for row in grid[0:half_h]]
    bottom_left = [row[0:half_w] for row in grid[half_h:height]]
    bottom_right = [row[half_w:width] for row in grid[half_h:height]]
    def has_color2(q):
        for row in q:
            if 2 in row:
                return True
        return False
    if has_color2(top_left):
        top_left = rotate_90_clockwise(top_left)
    else:
        top_left = rotate_90_counterclockwise(top_left)
    if has_color2(top_right):
        top_right = rotate_90_clockwise(top_right)
    else:
        top_right = rotate_90_counterclockwise(top_right)
    if has_color2(bottom_left):
        bottom_left = rotate_90_clockwise(bottom_left)
    else:
        bottom_left = rotate_90_counterclockwise(bottom_left)
    if has_color2(bottom_right):
        bottom_right = rotate_90_clockwise(bottom_right)
    else:
        bottom_right = rotate_90_counterclockwise(bottom_right)
    rotated_grid = []
    for i in range(half_h):
        rotated_grid.append(top_left[i] + top_right[i])
    for i in range(height - half_h):
        rotated_grid.append(bottom_left[i] + bottom_right[i])
    visited = [[False] * width for _ in range(height)]
    morphed_pixels = set()
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and rotated_grid[r][c] != 0:
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                color = rotated_grid[r][c]
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and rotated_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                if len(component) >= 2:
                    for (cr, cc) in component:
                        morphed_pixels.add((cr, cc))
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if (r, c) in morphed_pixels:
                new_c = width - 1 - c
                output_grid[r][new_c] = rotated_grid[r][c]
            else:
                output_grid[r][c] = rotated_grid[r][c]
    return output_grid
