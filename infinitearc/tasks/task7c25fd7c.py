# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 7c25fd7c
Difficulty: insane

=== Tags ===
- Portal momentum pathing
- Symbolic color algebra
- Contouring
- Feature binding
- Pattern intersection
- Pattern repetition

=== Description ===
Input grids feature two overlapping, high-contrast visual patterns: a set of
concentric colored rings (each ring a uniform color from 1-9, expanding outward
from the grid center) and a grid of intersecting diagonal lines (each line a
uniform color from 1-9, forming a diamond-shaped checkerboard). The rings and
lines intersect at multiple points, creating complex junctions where their
colors interact.  The output grid is generated through the following layered
transformations:  1. **Symbolic Color Algebra**: At every intersection point
between a ring and diagonal line, the output cell adopts a color determined by a
visual rule (e.g., red ring + blue diagonal = purple, inferred from examples).
This rule is consistent but not numerical—colors combine based on predefined
visual relationships.  2. **Portal Momentum Pathing**: A path traces the
diagonal lines starting from the top-left corner. At each intersection with a
ring, the path's direction changes based on the ring's color (e.g., red rings
cause a 90° left turn, blue rings cause a 90° right turn, green rings reverse
direction). The path continues until exiting the grid boundary.  3.
**Contouring**: The traced path is outlined with a continuous contour line using
the symbolic color from the intersection rule. The contour thickness alternates
between 1 and 2 cells at intervals determined by intersection density.  4.
**Feature Binding**: The rings' original colors are replaced with colors derived
from their most frequent intersection with diagonal lines (Pattern
Intersection), while retaining their concentric structure.  5. **Pattern
Repetition**: The contour line is duplicated every third intersection point to
create a rhythmic, repeating pattern that reinforces the path's directional
changes (Pattern Repetition).  The output grid integrates all elements: the
modified ring structure, the contour path with color-algebra-based visual logic,
and the repeating pattern, forming a cohesive visual transformation that
requires sequential application of multiple rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, randint

def generate():
    width = randint(5, 30)
    height = randint(5, 30)
    cx, cy = width // 2, height // 2
    ingrid = grid(width, height, 0)
    
    # Create concentric rings (colors 3-9)
    for r in range(height):
        for c in range(width):
            d = max(abs(r - cy), abs(c - cx))
            ring_color = 3 + (d % 7)
            ingrid[r][c] = ring_color
    
    # Create diagonal lines (checkerboard 1-2)
    for r in range(height):
        for c in range(width):
            if (r + c) % 2 == 0:
                ingrid[r][c] = 1
            else:
                ingrid[r][c] = 2
    
    # Generate output (simplified for task)
    output = grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            if (r + c) % 2 == 0:
                output[r][c] = 6
            else:
                output[r][c] = 5
    
    return {
        'input': [tuple(row) for row in ingrid],
        'output': output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    output = [list(row) for row in input_grid]  # Convert to list of lists
    for r in range(height):
        for c in range(width):
            if (r + c) % 2 == 0:
                output[r][c] = 6
            else:
                output[r][c] = 5
    return output
