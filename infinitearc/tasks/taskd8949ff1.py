# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: d8949ff1
Difficulty: hard

=== Tags ===
- Bidirectional mapping
- Stepwise color transition

=== Description ===
Input grids consist of multiple contiguous regions of colors 1-9 separated by
background color 0. Each region may contain a single marker cell of color 9. The
output grid is generated by transforming each region's color according to its
marker presence: regions containing a color 9 marker transition to the next
color in the cyclic sequence (1→2→3→4→5→6→7→8→9→1), while regions without
markers transition to the previous color (1→9→8→7→6→5→4→3→2→1). The marker cell
(color 9) is replaced by the new region color, and background cells remain color
0. This transformation requires identifying connected regions, detecting marker
presence, and applying bidirectional color transitions based on contextual
rules, creating a complex interplay between spatial structure and sequential
color logic.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

# Generator for ARC task: regions colored 1-8, optional single marker cell 9 inside some regions.
# Each region is a 4-connected blob; different regions are separated by background color 0 (no orthogonal adjacency).


def generate():
    # Grid size: choose a modest range to keep generation fast but varied
    width = random.randint(3, 12)
    height = random.randint(3, 12)

    max_cells = width * height

    # Decide how many components to try placing
    max_components = min(6, max(1, max_cells // 6))
    n_components = random.randint(1, max_components)

    occupied = set()  # cells already taken by placed components
    components = []

    # helper to find orthogonal neighbors
    def neighbors(cell):
        r, c = cell
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            yield (r + dr, c + dc)

    all_cells = [(r, c) for r in range(height) for c in range(width)]

    for comp_index in range(n_components):
        # pick a seed cell that is not occupied and not adjacent to existing components
        free_cells = [cell for cell in all_cells if cell not in occupied]
        random.shuffle(free_cells)
        seed = None
        for cand in free_cells:
            ok = True
            for nb in neighbors(cand):
                if nb in occupied:
                    ok = False
                    break
            if ok:
                seed = cand
                break
        if seed is None:
            # cannot place more separated components, stop placing
            break

        # decide target size for this component
        remaining_space = max_cells - len(occupied)
        # ensure room for at least one cell for remaining components
        min_size = 1
        max_size = min(8, remaining_space - (n_components - comp_index - 1))
        if max_size < 1:
            break
        target_size = random.randint(min_size, max_size)

        comp_cells = set([seed])
        frontier = [seed]

        # grow a 4-connected blob
        attempts = 0
        while len(comp_cells) < target_size and frontier and attempts < target_size * 10:
            attempts += 1
            cur = random.choice(frontier)
            # try neighbors of cur in random order
            neighs = list(neighbors(cur))
            random.shuffle(neighs)
            added = False
            for nb in neighs:
                nr, nc = nb
                if nr < 0 or nr >= height or nc < 0 or nc >= width:
                    continue
                if nb in comp_cells or nb in occupied:
                    continue
                # ensure nb does not orthogonally touch other components (occupied)
                conflict = False
                for nn in neighbors(nb):
                    if nn in occupied and nn not in comp_cells:
                        conflict = True
                        break
                if conflict:
                    continue
                comp_cells.add(nb)
                frontier.append(nb)
                added = True
                break
            if not added:
                # this frontier cell can't expand further
                try:
                    frontier.remove(cur)
                except ValueError:
                    pass

        # finalize component
        components.append(list(comp_cells))
        for cell in comp_cells:
            occupied.add(cell)

    # guarantee at least one component (fallback)
    if not components:
        r0, c0 = height // 2, width // 2
        components = [[(r0, c0)]]
        occupied.add((r0, c0))

    # assign base colors (1..8) and optional marker (9) only for components of size>1
    comps_info = []  # list of (component_cells, base_color, has_marker)
    for comp in components:
        base_color = random.randint(1, 8)
        if len(comp) > 1:
            has_marker = random.choice([True, False])
        else:
            # avoid ambiguous single-cell marker-only components
            has_marker = False
        comps_info.append((comp, base_color, has_marker))

    # Build input and output grids
    inp = [[0 for _ in range(width)] for _ in range(height)]
    out = [[0 for _ in range(width)] for _ in range(height)]

    for comp, base_color, has_marker in comps_info:
        marker_cell = None
        if has_marker:
            marker_cell = random.choice(comp)
        for (r, c) in comp:
            if has_marker and (r, c) == marker_cell:
                inp[r][c] = 9
            else:
                inp[r][c] = base_color

        # compute new color: next if marker present, previous if not
        if has_marker:
            new_color = (base_color % 9) + 1
        else:
            new_color = (base_color - 2) % 9 + 1

        for (r, c) in comp:
            out[r][c] = new_color

    # Ensure input and output differ (should always, but be safe)
    if inp == out:
        return generate()

    return {"input": inp, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    rows = len(grid)
    cols = len(grid[0]) if rows > 0 else 0

    visited = [[False] * cols for _ in range(rows)]
    output = [[0] * cols for _ in range(rows)]

    # Helper to get 4-neighbors
    def neighbors(r, c):
        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
            yield r + dr, c + dc

    for r in range(rows):
        for c in range(cols):
            if visited[r][c] or grid[r][c] == 0:
                continue
            # BFS to collect a connected component of non-background cells
            queue = [(r, c)]
            visited[r][c] = True
            comp = []
            while queue:
                rr, cc = queue.pop(0)
                comp.append((rr, cc))
                for nr, nc in neighbors(rr, cc):
                    if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and grid[nr][nc] != 0:
                        visited[nr][nc] = True
                        queue.append((nr, nc))

            # detect marker and base color
            has_marker = False
            colors = []
            for (rr, cc) in comp:
                val = grid[rr][cc]
                if val == 9:
                    has_marker = True
                else:
                    colors.append(val)

            if colors:
                # choose the most common non-marker color (robust if generator ever had mixed colors)
                base_color = max(set(colors), key=colors.count)
            else:
                # fallback (shouldn't happen under generator rules)
                base_color = 1

            if has_marker:
                new_color = (base_color % 9) + 1
            else:
                new_color = (base_color - 2) % 9 + 1

            for (rr, cc) in comp:
                output[rr][cc] = new_color

    return output

