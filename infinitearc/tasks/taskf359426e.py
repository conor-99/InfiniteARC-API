# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: f359426e
Difficulty: medium

=== Tags ===
- Expand repeating unit
- Normalize orientation
- Contouring
- Count hor lines

=== Description ===
The task involves transforming an input grid into an output grid through a
sequence of visual operations. First, the input grid is normalized to align its
repeating pattern horizontally (e.g., rotating or flipping to ensure the
pattern's primary axis matches row orientation). Next, the smallest repeating
unit (a tile that can be tiled to recreate the input) is identified. The number
of horizontal lines—rows containing a continuous segment of a specific color
(e.g., color 5)—is counted as K. The repeating unit is then expanded by a factor
of K in both dimensions (e.g., a 2×2 unit becomes 2K×2K). Finally, a single-
layer contour (a border of a distinct color, e.g., color 6) is added around the
entire expanded grid. The output grid reflects this expansion and contouring,
differing in size and structure from the input.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

from common import grid

def generate():
    if not hasattr(generate, 'combinations'):
        generate.combinations = []
        for K in range(2, 5):
            for c1 in range(1, 10):
                if c1 == 5:
                    continue
                for c2 in range(1, 10):
                    if c2 == 5:
                        continue
                    generate.combinations.append((K, c1, c2))
        generate.idx = 0
    K, c1, c2 = generate.combinations[generate.idx % len(generate.combinations)]
    generate.idx += 1
    unit = [[5, 5], [c1, c2]]
    input_grid = []
    for _ in range(K):
        input_grid.append([5, 5])
        input_grid.append([c1, c2])
    size = 2 * K + 2
    output_grid = grid(size, size, 6)
    for i in range(2 * K):
        for j in range(2 * K):
            unit_row = i % 2
            unit_col = j % 2
            output_grid[i+1][j+1] = unit[unit_row][unit_col]
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    K = sum(1 for row in input_grid if all(x == 5 for x in row))
    unit = [input_grid[0], input_grid[1]]
    size = 2 * K + 2
    output_grid = grid(size, size, 6)
    for i in range(2 * K):
        for j in range(2 * K):
            output_grid[i+1][j+1] = unit[i % 2][j % 2]
    return output_grid
