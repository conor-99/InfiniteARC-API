# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: dfc6e53b
Difficulty: hard

=== Tags ===
- Multi stage rule chain
- Topological invariance
- Color matching

=== Description ===
# Topological Color Harmony  Input grids contain multiple distinct colored
regions (each a connected component of a non-zero color, with background color
0), where each region is either simply connected (no enclosed background areas)
or contains exactly one hole (a single enclosed background region completely
surrounded by the region's color). Grid dimensions range from 1×1 to 30×30, with
regions varying in size and complexity.  The transformation to the output grid
follows a multi-stage rule chain requiring sequential application of topological
analysis, color matching, and shape transformation:  1. **Topological
Classification**: For each region, determine whether it is simply connected (S)
or contains a single hole (H). This classification depends solely on the
region's topological structure, not its position or orientation.  2. **Color
Matching**:     - For every H region, replace its color with the color of the
earliest H region in the grid (determined by the top-left corner of the region's
minimal bounding box, with ties broken by smaller row then column).    - For
every S region, replace its color with the color of the earliest S region in the
grid (using the same earliest position determination).    - If no H regions
exist, all H classifications remain unchanged (though none would exist), and
similarly for S regions.  3. **Shape Transformation**: For each region (now with
its new color), replace the entire region with a solid rectangle of the new
color that exactly matches the minimal bounding box of the original region (the
smallest rectangle containing all cells of the original region).  The output
grid preserves the original grid dimensions. Each transformed region occupies
exactly the bounding box of its original region, with all cells within the
bounding box filled with the new color. The transformation is deterministic and
invariant to spatial rearrangement of regions, as it depends only on topological
properties and relative positions for classification, not absolute coordinates.
The task requires recognizing multiple topological features across the grid,
applying color relationships based on structural classification, and executing a
precise spatial transformation—all while maintaining the grid's original
dimensions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common
from common import grid

# Generator for ARC task 434: Topological Color Harmony

def generate():
    # Try to create a configuration with multiple non-overlapping regions,
    # at least one H (one-hole region) and at least one S (simply connected).
    for attempt in range(100):
        width = random.randint(7, 20)
        height = random.randint(7, 20)
        input_grid = grid(width, height, 0)
        occupied = [[False] * width for _ in range(height)]
        regions = []

        num_regions = random.randint(2, 5)
        # ensure at least one H and one S for variety and to guarantee output != input
        num_h = random.randint(1, num_regions - 1)
        num_s = num_regions - num_h

        colors_used = []

        def pick_unique_color():
            # pick a color not used yet (there are always enough colors because num_regions <= 5)
            c = common.random_color(exclude=[0] + colors_used)
            colors_used.append(c)
            return c

        success = True

        # Helper to check bounding-box free
        def bbox_free(top, left, bh, bw):
            for rr in range(top, top + bh):
                for cc in range(left, left + bw):
                    if occupied[rr][cc]:
                        return False
            return True

        # Place H regions: hollow rectangular frames (guaranteed single hole)
        for _ in range(num_h):
            placed = False
            for t in range(200):
                # bounding box must be at least 3x3 and must be at least one cell away from the global border
                max_bw = min(8, width - 2)
                max_bh = min(8, height - 2)
                if max_bw < 3 or max_bh < 3:
                    break
                bh = random.randint(3, max_bh)
                bw = random.randint(3, max_bw)
                top_max = height - bh - 1
                left_max = width - bw - 1
                if top_max < 1 or left_max < 1:
                    continue
                top = random.randint(1, top_max)
                left = random.randint(1, left_max)
                if not bbox_free(top, left, bh, bw):
                    continue
                # place a frame (hollow rectangle)
                color = pick_unique_color()
                pixels = []
                for rr in range(top, top + bh):
                    for cc in range(left, left + bw):
                        if rr == top or rr == top + bh - 1 or cc == left or cc == left + bw - 1:
                            input_grid[rr][cc] = color
                            pixels.append((rr, cc))
                        # reserve bounding box so no other region intrudes into the hole
                        occupied[rr][cc] = True
                regions.append({'type': 'H', 'color': color, 'pixels': pixels, 'bbox': (top, top + bh - 1, left, left + bw - 1)})
                placed = True
                break
            if not placed:
                success = False
                break

        if not success:
            continue

        # Place S regions: filled rectangles (simply connected)
        for _ in range(num_s):
            placed = False
            for t in range(200):
                bw = random.randint(1, min(6, width))
                bh = random.randint(1, min(6, height))
                top = random.randint(0, height - bh)
                left = random.randint(0, width - bw)
                if not bbox_free(top, left, bh, bw):
                    continue
                color = pick_unique_color()
                pixels = []
                for rr in range(top, top + bh):
                    for cc in range(left, left + bw):
                        input_grid[rr][cc] = color
                        occupied[rr][cc] = True
                        pixels.append((rr, cc))
                regions.append({'type': 'S', 'color': color, 'pixels': pixels, 'bbox': (top, top + bh - 1, left, left + bw - 1)})
                placed = True
                break
            if not placed:
                success = False
                break

        if not success:
            continue

        # Now produce the output according to the rules
        # Find earliest H and earliest S by top-left corner of bounding box
        earliest_h = None
        earliest_s = None
        for reg in regions:
            min_r = reg['bbox'][0]
            min_c = reg['bbox'][2]
            if reg['type'] == 'H':
                if earliest_h is None or (min_r < earliest_h[0]) or (min_r == earliest_h[0] and min_c < earliest_h[1]):
                    earliest_h = (min_r, min_c, reg['color'])
            else:
                if earliest_s is None or (min_r < earliest_s[0]) or (min_r == earliest_s[0] and min_c < earliest_s[1]):
                    earliest_s = (min_r, min_c, reg['color'])

        output_grid = grid(width, height, 0)
        for reg in regions:
            top, bottom, left, right = reg['bbox']
            if reg['type'] == 'H':
                new_color = earliest_h[2] if earliest_h else reg['color']
            else:
                new_color = earliest_s[2] if earliest_s else reg['color']
            for rr in range(top, bottom + 1):
                for cc in range(left, right + 1):
                    output_grid[rr][cc] = new_color

        # Ensure input != output (filling hole interiors guarantees this), but double-check
        if input_grid != output_grid:
            return {'input': input_grid, 'output': output_grid}

    # If everything failed (extremely unlikely), fallback to a minimal handcrafted example
    w, h = 7, 7
    input_grid = grid(w, h, 0)
    # H region: 5x5 frame at (1,1)
    color_h = 2
    for r in range(1, 6):
        for c in range(1, 6):
            if r in (1, 5) or c in (1, 5):
                input_grid[r][c] = color_h
    # S region: 2x2 filled at bottom-right
    color_s = 3
    for r in range(5, 7):
        for c in range(5, 7):
            input_grid[r][c] = color_s
    output_grid = grid(w, h, 0)
    # earliest H is color_h, earliest S is color_s
    for r in range(1, 6):
        for c in range(1, 6):
            output_grid[r][c] = color_h
    for r in range(5, 7):
        for c in range(5, 7):
            output_grid[r][c] = color_s
    return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------


from collections import deque

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    visited = [[False] * width for _ in range(height)]
    regions = []  # each region: dict with keys color, pixels(list), bbox, type

    # Find connected components of non-zero colors (4-connected)
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 or visited[r][c]:
                continue
            color = grid[r][c]
            q = deque()
            q.append((r, c))
            visited[r][c] = True
            pixels = []
            while q:
                cr, cc = q.popleft()
                pixels.append((cr, cc))
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                        visited[nr][nc] = True
                        q.append((nr, nc))
            min_r = min(p[0] for p in pixels)
            max_r = max(p[0] for p in pixels)
            min_c = min(p[1] for p in pixels)
            max_c = max(p[1] for p in pixels)
            regions.append({'color': color, 'pixels': pixels, 'bbox': (min_r, max_r, min_c, max_c)})

    # Determine topological type (H if contains at least one enclosed background component, else S)
    def count_enclosed_holes(bbox):
        min_r, max_r, min_c, max_c = bbox
        visited_zero = [[False] * (max_c - min_c + 1) for _ in range(max_r - min_r + 1)]
        holes = 0
        for rr in range(min_r, max_r + 1):
            for cc in range(min_c, max_c + 1):
                if grid[rr][cc] != 0:
                    continue
                if visited_zero[rr - min_r][cc - min_c]:
                    continue
                # BFS for this zero-component (within bbox)
                q = deque()
                q.append((rr, cc))
                visited_zero[rr - min_r][cc - min_c] = True
                touches_bbox_edge = False
                while q:
                    zr, zc = q.popleft()
                    # if this zero cell touches the bounding-box border, it cannot be an enclosed hole
                    if zr == min_r or zr == max_r or zc == min_c or zc == max_c:
                        touches_bbox_edge = True
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = zr + dr, zc + dc
                        if nr < min_r or nr > max_r or nc < min_c or nc > max_c:
                            continue
                        if grid[nr][nc] != 0:
                            continue
                        if not visited_zero[nr - min_r][nc - min_c]:
                            visited_zero[nr - min_r][nc - min_c] = True
                            q.append((nr, nc))
                if not touches_bbox_edge:
                    holes += 1
        return holes

    # classify and record earliest positions
    earliest_h = None
    earliest_s = None
    for reg in regions:
        bbox = reg['bbox']
        holes = count_enclosed_holes(bbox)
        reg_type = 'H' if holes >= 1 else 'S'
        reg['type'] = reg_type
        min_r = bbox[0]
        min_c = bbox[2]
        if reg_type == 'H':
            if earliest_h is None or (min_r < earliest_h[0]) or (min_r == earliest_h[0] and min_c < earliest_h[1]):
                earliest_h = (min_r, min_c, reg['color'])
        else:
            if earliest_s is None or (min_r < earliest_s[0]) or (min_r == earliest_s[0] and min_c < earliest_s[1]):
                earliest_s = (min_r, min_c, reg['color'])

    # Build output grid: each region replaced by its bounding-box filled with the earliest color of its type
    out = [[0] * width for _ in range(height)]
    for reg in regions:
        min_r, max_r, min_c, max_c = reg['bbox']
        if reg['type'] == 'H':
            new_color = earliest_h[2] if earliest_h is not None else reg['color']
        else:
            new_color = earliest_s[2] if earliest_s is not None else reg['color']
        for rr in range(min_r, max_r + 1):
            for cc in range(min_c, max_c + 1):
                out[rr][cc] = new_color

    return out

