# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 8a6dca6a
Difficulty: very hard

=== Tags ===
- Contouring
- Example condition induction
- Exclusive or coloring
- Staircase construction
- Bring patterns close

=== Description ===
Task: Contour Staircase Confluence  Input grids contain a background (color 0)
and multiple disconnected colored regions (each region is a connected component
of a single non-zero color, 1-9), scattered across the grid. Regions vary in
size and shape, with no two regions sharing color. The grid may include
distractor regions that cannot be part of the solution.  The output grid
transforms the input by: 1. Identifying a sequence of regions that form a valid
staircase structure based on color compatibility: adjacent steps must use colors
that satisfy an "exclusive" relationship (no two adjacent steps share the same
color, and certain color pairs are forbidden based on example patterns). 2.
Rearranging these selected regions into a right-angled staircase pattern where
each step increases in height by one cell, positioned such that the staircase's
outer contour aligns with the natural edges of the regions' original shapes. 3.
Moving all selected regions closer together to form the staircase without
overlapping, while leaving distractor regions untouched in their original
positions. 4. Ensuring the staircase starts from the bottom-left corner and
extends upward-right, with the contour of the staircase matching the combined
outline of the rearranged regions.  The solution requires inductive reasoning to
infer the color compatibility rules from example pairs (e.g., observing that
red-blue is valid but red-red is invalid) and recognizing which regions'
contours can seamlessly form the staircase structure. The process involves
multiple layers of constraint satisfaction: color exclusion, spatial alignment,
and contour matching, with the staircase construction demanding precise
placement of regions relative to one another.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Global call counter to ensure diversity across repeated calls
CALL_COUNT = 0


def _place_shape(inp, occupancy, shape_cells, r0, c0, width, height, reserved_cols, reserved_rows):
    # Check bounds and reserved area and occupancy
    for (dr, dc) in shape_cells:
        r = r0 + dr
        c = c0 + dc
        if r < 0 or r >= height or c < 0 or c >= width:
            return False
        if c in reserved_cols and r in reserved_rows:
            return False
        if occupancy[r][c]:
            return False
    # Place
    for (dr, dc) in shape_cells:
        r = r0 + dr
        c = c0 + dc
        inp[r][c] = shape_color_global  # will be set by caller
        occupancy[r][c] = True
    return True


def generate():
    """
    Generate an ARC-style pair where a set of single-column vertical regions
    (the steps) are scattered in the input and in the output they are packed
    into a bottom-left staircase with heights 1..n (left-to-right). Other
    distractor regions are left untouched.
    """
    global CALL_COUNT, shape_color_global
    CALL_COUNT += 1
    rng = random.Random(CALL_COUNT + random.getrandbits(20))

    # Choose grid size with room for the staircase and some distractors
    width = rng.randint(10, 18)
    height = rng.randint(10, 18)

    # Max possible steps (we need at least n+1 columns to have some space to scatter)
    max_steps = min(6, width - 4, height - 4)
    if max_steps < 2:
        max_steps = 2
    n = rng.randint(2, max_steps)

    # Ensure final area will fit
    if width < n + 3:
        width = n + 3
    if height < n + 3:
        height = n + 3

    # Select unique colors for steps and distractors
    all_colors = list(range(1, 10))
    rng.shuffle(all_colors)
    step_colors = all_colors[:n]
    remaining_colors = all_colors[n:]

    # Create output grid: staircase in bottom-left, columns 0..n-1, heights 1..n
    output = grid(width, height, 0)
    for i, color in enumerate(step_colors):
        h = i + 1
        for dr in range(h):
            r = height - 1 - dr
            c = i
            output[r][c] = color

    # Create input grid and occupancy map
    input_grid = grid(width, height, 0)
    occupancy = [[False for _ in range(width)] for _ in range(height)]

    # Reserve the bottom-left rectangle where the staircase will be placed
    reserved_cols = set(range(0, n))
    reserved_rows = set(range(height - n, height))

    # Helper to try placing a shape many times
    def try_place(shape_cells, color, max_attempts=500):
        nonlocal input_grid, occupancy
        # Save the color in a global used by _place_shape helper
        # (slightly hacky to avoid passing color all the time into _place_shape)
        global shape_color_global
        shape_color_global = color
        for _ in range(max_attempts):
            # Try to place anywhere outside the reserved rectangle
            min_r = 0
            max_r = height - 1 - max((dr for dr,dc in shape_cells))
            min_c = 0
            max_c = width - 1 - max((dc for dr,dc in shape_cells))
            if max_r < min_r or max_c < min_c:
                return False
            r0 = rng.randint(min_r, max_r)
            c0 = rng.randint(min_c, max_c)
            # quick rejection if overlaps reserved rectangle in any cell
            bad = False
            for (dr, dc) in shape_cells:
                r = r0 + dr
                c = c0 + dc
                if c in reserved_cols and r in reserved_rows:
                    bad = True
                    break
                if occupancy[r][c]:
                    bad = True
                    break
            if bad:
                continue
            # place
            for (dr, dc) in shape_cells:
                r = r0 + dr
                c = c0 + dc
                input_grid[r][c] = color
                occupancy[r][c] = True
            return True
        return False

    # Create distractor regions: shapes that are not single-column vertical bars
    distractor_count = rng.randint(2, min(5, len(remaining_colors)))
    distractor_colors = remaining_colors[:distractor_count]

    # Predefined shape templates (each as list of (dr, dc) offsets)
    templates = []
    # 2x2 block
    templates.append([(0,0),(0,1),(1,0),(1,1)])
    # horizontal bar length 3
    templates.append([(0,0),(0,1),(0,2)])
    # horizontal bar length 4
    templates.append([(0,0),(0,1),(0,2),(0,3)])
    # L-shape (3 cells)
    templates.append([(0,0),(1,0),(1,1)])
    # 3-cell small block (2x2 minus one)
    templates.append([(0,0),(0,1),(1,0)])
    # plus shape (5 cells)
    templates.append([(0,1),(1,0),(1,1),(1,2),(2,1)])

    rng.shuffle(templates)

    for color in distractor_colors:
        placed = False
        # pick a random template each time
        for attempt in range(20):
            template = rng.choice(templates)
            if try_place(template, color, max_attempts=200):
                placed = True
                break
        # If we failed to place the chosen template, fall back to a 2x2 block
        if not placed:
            try_place([(0,0),(0,1),(1,0),(1,1)], color, max_attempts=200)

    # Place the staircase components (single-column vertical bars) scattered
    # Ensure they're placed outside reserved area and not overlapping distractors.
    for i, color in enumerate(step_colors):
        h = i + 1
        shape_cells = [(dr, 0) for dr in range(h)]
        # To ensure variety across calls, bias the column by CALL_COUNT
        # pick a candidate column >= n (to avoid reserved area)
        min_col = n
        max_col = width - 1
        # if there's too little horizontal space, allow placement to the rightmost column only
        if min_col > max_col:
            min_col = max_col
        # Try deterministic-ish positions first derived from CALL_COUNT then random
        placed = False
        # deterministic attempt
        det_c0 = min_col + ((CALL_COUNT + i) % max(1, (width - n))) if width - n > 0 else min_col
        for r0 in range(0, max(1, height - h + 1)):
            # try few rows near top and middle
            c0 = det_c0
            bad = False
            for (dr, dc) in shape_cells:
                r = r0 + dr
                c = c0 + dc
                if r < 0 or r >= height or c < 0 or c >= width:
                    bad = True
                    break
                if c in reserved_cols and r in reserved_rows:
                    bad = True
                    break
                if occupancy[r][c]:
                    bad = True
                    break
            if not bad:
                for (dr, dc) in shape_cells:
                    r = r0 + dr
                    c = c0 + dc
                    input_grid[r][c] = color
                    occupancy[r][c] = True
                placed = True
                break
        if placed:
            continue
        # fallback: try random placement
        success = try_place(shape_cells, color, max_attempts=1000)
        if not success:
            # as a last resort, expand grid (very unlikely given starting sizes)
            raise RuntimeError("Could not place step shape; grid too small")

    # Copy distractors into the output as they should remain untouched
    for r in range(height):
        for c in range(width):
            v = input_grid[r][c]
            if v != 0 and v in distractor_colors:
                output[r][c] = v

    return {"input": input_grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Gather pixels by color
    comps = {}
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if v == 0:
                continue
            comps.setdefault(v, []).append((r, c))

    # Identify single-column contiguous components (these are the staircase steps)
    step_info = []  # list of (color, size)
    for color, cells in comps.items():
        rs = [p[0] for p in cells]
        cs = [p[1] for p in cells]
        minr, maxr = min(rs), max(rs)
        minc, maxc = min(cs), max(cs)
        # must occupy exactly one column and be contiguous vertically
        if minc == maxc and len(cells) == (maxr - minr + 1):
            # verify all positions in column are that color
            good = True
            for r in range(minr, maxr + 1):
                if grid[r][minc] != color:
                    good = False
                    break
            if good:
                step_info.append((color, len(cells)))

    # Sort steps by height (size) ascending to become left-to-right
    step_info.sort(key=lambda t: t[1])
    step_colors = [c for c, s in step_info]

    # Build output: start with background
    output = [[0 for _ in range(width)] for _ in range(height)]

    # Copy distractors (colors that are not part of steps) in-place
    step_set = set(step_colors)
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if v != 0 and v not in step_set:
                output[r][c] = v

    # Place staircase at bottom-left with columns 0..k-1 and heights equal to sizes
    for idx, (color, size) in enumerate(step_info):
        col = idx
        for dr in range(size):
            r = height - 1 - dr
            output[r][col] = color

    return output

