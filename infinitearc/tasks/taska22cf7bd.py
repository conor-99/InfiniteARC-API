# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: a22cf7bd
Difficulty: easy

=== Tags ===
- Holes

=== Description ===
The task involves input grids containing shapes formed by non-zero color values
with enclosed empty regions represented by the value 0. The output grid is
created by filling every enclosed empty region (a single 0 cell completely
surrounded by non-zero values in all four orthogonal directionsâ€”top, bottom,
left, right) with the color 1. The rule is visual and deterministic: identify
all isolated 0 cells that are fully enclosed by non-zero neighbors and replace
them with 1, leaving all other grid values unchanged. The input grid must
contain at least one such enclosed 0 to ensure the output differs from the
input.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    bg_color = random.randint(1, 9)
    input_grid = [[bg_color] * width for _ in range(height)]
    r = random.randint(1, height - 2)
    c = random.randint(1, width - 2)
    input_grid[r][c] = 0
    output_grid = [row[:] for row in input_grid]
    output_grid[r][c] = 1
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    output_grid = [row[:] for row in input_grid]
    rows = len(input_grid)
    cols = len(input_grid[0])
    for r in range(rows):
        for c in range(cols):
            if input_grid[r][c] == 0:
                if (r > 0 and input_grid[r-1][c] > 0 and
                    r < rows - 1 and input_grid[r+1][c] > 0 and
                    c > 0 and input_grid[r][c-1] > 0 and
                    c < cols - 1 and input_grid[r][c+1] > 0):
                    output_grid[r][c] = 1
    return output_grid
