# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: b0fdbce8
Difficulty: medium

=== Tags ===
- Image expansion
- Image expasion
- Rotate each quadrant

=== Description ===
The task requires transforming an input grid by dividing it into four quadrants
(top-left, top-right, bottom-left, bottom-right), then rotating each quadrant 90
degrees clockwise in place. The output grid is formed by placing each rotated
quadrant back into its original position within the grid. This transformation
rearranges the colors within each quadrant while preserving the overall grid
dimensions. For example, a 4x4 input grid will have each 2x2 quadrant rotated,
resulting in a visually distinct output where the arrangement of colors within
each quadrant changes according to the rotation. The transformation is
consistent for grids of even dimensions (e.g., 4x4, 6x6, 8x8, etc.), ensuring
the input and output grids are always different.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    while True:
        size = random.choice(range(2, 31, 2))
        width = size
        height = size
        input_grid = grid(width, height, 0)
        for r in range(height):
            for c in range(width):
                input_grid[r][c] = random.randint(0, 9)
        
        half = size // 2
        output_grid = grid(width, height, 0)
        
        def rotate_90(g):
            return [list(x)[::-1] for x in zip(*g)]
        
        # Top-left
        tl = [row[:half] for row in input_grid[:half]]
        tl_rot = rotate_90(tl)
        for r in range(half):
            for c in range(half):
                output_grid[r][c] = tl_rot[r][c]
        
        # Top-right
        tr = [row[half:] for row in input_grid[:half]]
        tr_rot = rotate_90(tr)
        for r in range(half):
            for c in range(half):
                output_grid[r][c + half] = tr_rot[r][c]
        
        # Bottom-left
        bl = [row[:half] for row in input_grid[half:]]
        bl_rot = rotate_90(bl)
        for r in range(half):
            for c in range(half):
                output_grid[r + half][c] = bl_rot[r][c]
        
        # Bottom-right
        br = [row[half:] for row in input_grid[half:]]
        br_rot = rotate_90(br)
        for r in range(half):
            for c in range(half):
                output_grid[r + half][c + half] = br_rot[r][c]
        
        if input_grid != output_grid:
            return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    half = width // 2
    
    def rotate_90(g):
        return [list(x)[::-1] for x in zip(*g)]
    
    output_grid = [[0] * width for _ in range(height)]
    
    # Top-left
    tl = [row[:half] for row in input_grid[:half]]
    tl_rot = rotate_90(tl)
    for r in range(half):
        for c in range(half):
            output_grid[r][c] = tl_rot[r][c]
    
    # Top-right
    tr = [row[half:] for row in input_grid[:half]]
    tr_rot = rotate_90(tr)
    for r in range(half):
        for c in range(half):
            output_grid[r][c + half] = tr_rot[r][c]
    
    # Bottom-left
    bl = [row[:half] for row in input_grid[half:]]
    bl_rot = rotate_90(bl)
    for r in range(half):
        for c in range(half):
            output_grid[r + half][c] = bl_rot[r][c]
    
    # Bottom-right
    br = [row[half:] for row in input_grid[half:]]
    br_rot = rotate_90(br)
    for r in range(half):
        for c in range(half):
            output_grid[r + half][c + half] = br_rot[r][c]
    
    return output_grid
