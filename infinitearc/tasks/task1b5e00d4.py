# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 1b5e00d4
Difficulty: insane

=== Tags ===
- Maze
- Symbolic circuit
- Context sensitive recolor
- Oscillating rule
- Move object to nearest corner
- Algebra

=== Description ===
Input grids are 20×20 grids containing a complex maze structure with walls
(color 1) and open paths (color 0). Embedded within the maze are symbolic
circuits—each a 2×2 block with two diagonal path cells and four colored corners
(colors 2–9). A single token (color 2) is placed at a random position within the
maze, not on a circuit. The output grid reveals the token’s complete path to the
nearest corner (determined by Manhattan distance to the four grid corners), with
the following transformations applied: (1) As the token enters a circuit cell,
its color changes via a context-sensitive mapping (e.g., circuit color 3 → token
color 4, circuit color 5 → token color 9), where the mapping is fixed by the
circuit’s corner color; (2) Each circuit flips its color to an alternate state
(e.g., red ↔ blue, green ↔ yellow) upon traversal, implementing an oscillating
rule; (3) The path is drawn using the token’s current color at each step, with
the final position at the nearest corner. The "algebra" aspect refers to the
cyclic, deterministic sequence governing circuit color oscillation (e.g.,
circuit color state follows a predefined cyclic group), requiring the solver to
track state changes across multiple circuit traversals. The task demands
recognizing maze topology, identifying circuits, applying context-dependent
color mappings, and resolving oscillating state transitions—combinatorial
reasoning across spatial and temporal dimensions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

mapping = {
    2: 3,
    3: 4,
    4: 5,
    5: 6,
    6: 7,
    7: 8,
    8: 9,
    9: 2
}

def generate():
    size = 20
    input_grid = grid(size, size, 0)
    
    # Add random vertical walls
    for _ in range(3):
        col = random.randint(5, 14)
        for r in range(5, 15):
            input_grid[r][col] = 1
    
    # Add random horizontal walls
    for _ in range(3):
        row = random.randint(5, 14)
        for c in range(5, 15):
            input_grid[row][c] = 1
    
    # Place token
    token_x, token_y = 1, 1
    while input_grid[token_x][token_y] != 0:
        token_x, token_y = random.randint(0, size-1), random.randint(0, size-1)
    input_grid[token_x][token_y] = 2
    
    # Determine nearest corner
    corners = [(0,0), (0, size-1), (size-1, 0), (size-1, size-1)]
    dists = [abs(token_x - x) + abs(token_y - y) for x, y in corners]
    nearest_corner = corners[dists.index(min(dists))]
    
    # BFS for shortest path
    from collections import deque
    visited = [[False]*size for _ in range(size)]
    parent = [[None]*size for _ in range(size)]
    queue = deque([(token_x, token_y)])
    visited[token_x][token_y] = True
    
    while queue:
        x, y = queue.popleft()
        if (x, y) == nearest_corner:
            break
        for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:
            nx, ny = x+dx, y+dy
            if 0 <= nx < size and 0 <= ny < size and not visited[nx][ny] and input_grid[nx][ny] == 0:
                visited[nx][ny] = True
                parent[nx][ny] = (x, y)
                queue.append((nx, ny))
    
    # Reconstruct path
    path = []
    x, y = nearest_corner
    while (x, y) != (token_x, token_y):
        path.append((x, y))
        x, y = parent[x][y]
    path.append((token_x, token_y))
    path.reverse()
    
    # Place circuits along path
    circuits = []
    for i in range(1, len(path)-1, 3):
        x, y = path[i]
        if x > 0 and y > 0 and x < size-1 and y < size-1:
            if all(input_grid[x-1][y-1] == 0 and input_grid[x-1][y] == 0 and input_grid[x][y-1] == 0 and input_grid[x][y] == 0):
                circuit_color = random.randint(2, 9)
                input_grid[x-1][y-1] = circuit_color
                input_grid[x-1][y] = circuit_color
                input_grid[x][y-1] = circuit_color
                input_grid[x][y] = circuit_color
                circuits.append((x-1, y-1, circuit_color))
    
    # Generate output
    output_grid = [row[:] for row in input_grid]
    circuit_state = {}
    for (cx, cy, c) in circuits:
        circuit_state[(cx, cy)] = c
    token_color = 2
    for (x, y) in path:
        circuit_key = None
        for (cx, cy) in circuit_state.keys():
            if cx <= x < cx+2 and cy <= y < cy+2:
                circuit_key = (cx, cy)
                break
        if circuit_key:
            current_color = circuit_state[circuit_key]
            token_color = mapping[current_color]
            circuit_state[circuit_key] = token_color
        output_grid[x][y] = token_color
    
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random
from common import grid
from collections import deque

def p(input_grid):
    size = len(input_grid)
    
    # Find token position (color 2)
    token_pos = None
    for i in range(size):
        for j in range(size):
            if input_grid[i][j] == 2:
                token_pos = (i, j)
    if token_pos is None:
        return input_grid
    
    # Determine nearest corner
    corners = [(0,0), (0, size-1), (size-1, 0), (size-1, size-1)]
    token_x, token_y = token_pos
    dists = [abs(token_x - x) + abs(token_y - y) for x, y in corners]
    nearest_corner = corners[dists.index(min(dists))]
    
    # Identify circuits (2x2 blocks with all cells >=2)
    circuits = []
    circuit_state = {}
    for i in range(size-1):
        for j in range(size-1):
            if input_grid[i][j] >= 2 and input_grid[i][j+1] >= 2 and input_grid[i+1][j] >= 2 and input_grid[i+1][j+1] >= 2:
                circuits.append((i, j))
                circuit_state[(i, j)] = input_grid[i][j]
    
    # BFS for shortest path
    visited = [[False]*size for _ in range(size)]
    parent = [[None]*size for _ in range(size)]
    queue = deque([token_pos])
    visited[token_pos[0]][token_pos[1]] = True
    
    while queue:
        x, y = queue.popleft()
        if (x, y) == nearest_corner:
            break
        for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:
            nx, ny = x+dx, y+dy
            if 0 <= nx < size and 0 <= ny < size and not visited[nx][ny] and input_grid[nx][ny] == 0:
                visited[nx][ny] = True
                parent[nx][ny] = (x, y)
                queue.append((nx, ny))
    
    # Reconstruct path
    path = []
    x, y = nearest_corner
    while (x, y) != token_pos:
        path.append((x, y))
        x, y = parent[x][y]
    path.append(token_pos)
    path.reverse()
    
    # Apply color mapping
    output_grid = [list(row) for row in input_grid]
    token_color = 2
    mapping = {2:3, 3:4, 4:5, 5:6, 6:7, 7:8, 8:9, 9:2}
    for (x, y) in path:
        circuit_key = None
        for (cx, cy) in circuit_state.keys():
            if cx <= x < cx+2 and cy <= y < cy+2:
                circuit_key = (cx, cy)
                break
        if circuit_key:
            current_color = circuit_state[circuit_key]
            token_color = mapping[current_color]
            circuit_state[circuit_key] = token_color
        output_grid[x][y] = token_color
    
    return output_grid
