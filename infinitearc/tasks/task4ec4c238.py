# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 4ec4c238
Difficulty: very hard

=== Tags ===
- Refraction simulation
- Local to global rule inference
- Normalize orientation

=== Description ===
Input grids are large (≥20×20) with a single background color. Overlaid are
multiple contiguous regions of distinct colors, each forming a unique, compact
shape (e.g., a 2×2 block, a 3-cell line, or an 'L' shape). A ray originates from
the left edge, moving horizontally right. When traversing a colored region, the
ray refracts based on the region's shape: regions shaped like a 'V' pointing
left induce a 90-degree upward turn, while 'V' shapes pointing right induce a
downward turn. The refraction rule is consistent but must be inferred from the
input-output pairs. The output grid maintains all regions and background
unchanged but modifies the ray's path to reflect the inferred refraction. The
path is then normalized such that all segments are aligned with the grid's axes
(horizontal or vertical), eliminating diagonal segments by adjusting the path to
follow grid lines. The ray path uses the region's color, occupies only
background cells, and never overlaps with regions or other elements. The task
requires solving through local shape-based rule inference (identifying how
region shapes dictate refraction) and global path reconstruction with
orientation normalization.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    """Generates a large grid (20-30) with a single-row ray start at the left edge and several small 'V' shaped regions centered on the ray row.

    Design constraints to make the task robust and solvable by local shape inference:
    - Background color = 0
    - Ray start color = 9 (single pixel in leftmost column)
    - Each region is a compact 3-pixel 'V' that occupies two adjacent columns and three adjacent rows centered on ray_row.
      A 'right' V uses pixels: (mid,left), (top,right), (bottom,right) -> two pixels on the right column.
      A 'left' V mirrors that -> two pixels on the left column.
    - We reserve an empty corridor two rows above and two rows below the ray_row so the ray can route around any region either upward or downward.
    - When the ray moving to the right encounters a region, it detours: it climbs/descends to the corridor row just outside the region, crosses the region horizontally in that corridor, and returns to the ray_row after the region. This produces axis-aligned segments only.

    The generator returns a dict {"input": grid, "output": grid_with_path}.
    """
    # Dimensions
    width = random.randint(20, 30)
    height = random.randint(20, 30)

    bg = 0
    ray_color = 9

    # create empty grid
    grid = [[bg for _ in range(width)] for __ in range(height)]

    # choose a ray row so there is room for two rows above and below (corridors)
    min_ray = 2
    max_ray = height - 3
    if min_ray > max_ray:
        ray_row = min_ray
    else:
        ray_row = random.randint(min_ray, max_ray)

    # reserve the corridor rows (we will keep them background)
    up_corridor = ray_row - 2
    down_corridor = ray_row + 2

    # number of V shapes
    num_v = random.randint(1, 4)

    used_colors = set()
    # possible colors for regions: 1..8 (not background 0 and not ray_color 9)
    palette = [c for c in range(1, 10) if c != ray_color]

    shapes = []

    # start placing V shapes from a left margin with spacing
    col = random.randint(3, 5)
    for i in range(num_v):
        # make sure there's room for 2 columns of a V and one column after it (for the corridor to pass)
        if col + 1 >= width - 3:
            break
        orientation = random.choice(["left", "right"])  # which side the two pixels sit on
        # pick a unique color for the shape if possible
        avail = [c for c in palette if c not in used_colors]
        if not avail:
            color = random.choice(palette)
        else:
            color = random.choice(avail)
            used_colors.add(color)

        top = ray_row - 1
        mid = ray_row
        bot = ray_row + 1
        left_col = col
        right_col = col + 1

        if orientation == "right":
            # apex at left column middle, two pixels on the right column
            grid[mid][left_col] = color
            grid[top][right_col] = color
            grid[bot][right_col] = color
        else:
            # apex at right column middle, two pixels on the left column
            grid[top][left_col] = color
            grid[bot][left_col] = color
            grid[mid][right_col] = color

        shapes.append({"left": left_col, "right": right_col, "top": top, "bottom": bot, "color": color, "orientation": orientation})

        # advance column for next shape with random spacing (keep some gap so corridors stay clear)
        col += 4 + random.randint(0, 3)

    # ensure corridors are clean (background)
    if 0 <= up_corridor < height:
        for c in range(width):
            grid[up_corridor][c] = bg
    if 0 <= down_corridor < height:
        for c in range(width):
            grid[down_corridor][c] = bg

    # place ray start at left edge
    grid[ray_row][0] = ray_color

    # make copies for input and output
    input_grid = [row[:] for row in grid]
    output_grid = [row[:] for row in grid]

    # helper to get connected component (4-neighborhood)
    def get_component(sr, sc):
        color = grid[sr][sc]
        if color == bg or color == ray_color:
            return []
        h = height
        w = width
        seen = set()
        stack = [(sr, sc)]
        comp = []
        while stack:
            r, c = stack.pop()
            if (r, c) in seen:
                continue
            if grid[r][c] != color:
                continue
            seen.add((r, c))
            comp.append((r, c))
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                rr, cc = r + dr, c + dc
                if 0 <= rr < h and 0 <= cc < w and (rr, cc) not in seen and grid[rr][cc] == color:
                    stack.append((rr, cc))
        return comp

    # drawing helpers (draw inclusive ranges, safe against reversing ranges)
    def draw_h(row, c1, c2):
        if c1 <= c2:
            rng = range(c1, c2 + 1)
        else:
            rng = range(c1, c2 - 1, -1)
        for c in rng:
            # only draw on background (do not overwrite shapes)
            if output_grid[row][c] == bg:
                output_grid[row][c] = ray_color

    def draw_v(col_idx, r1, r2):
        if r1 <= r2:
            rng = range(r1, r2 + 1)
        else:
            rng = range(r1, r2 - 1, -1)
        for r in rng:
            if output_grid[r][col_idx] == bg:
                output_grid[r][col_idx] = ray_color

    # simulate ray path and draw it in output_grid
    cur_r = ray_row
    cur_c = 0
    # limit loop iterations conservatively
    loops = 0
    while True:
        loops += 1
        if loops > 1000:
            break
        # searching for the next colored pixel (a region) in the current row to the right
        found_col = None
        for c in range(cur_c + 1, width):
            if grid[cur_r][c] != bg and grid[cur_r][c] != ray_color:
                found_col = c
                break
        if found_col is None:
            # nothing ahead: draw to the right edge and finish
            draw_h(cur_r, cur_c, width - 1)
            break

        # get the region component at the found pixel
        comp = get_component(cur_r, found_col)
        if not comp:
            # safety fallback: mark the single pixel and continue
            if output_grid[cur_r][found_col] == bg:
                output_grid[cur_r][found_col] = ray_color
            cur_c = found_col
            continue

        left = min(c for r, c in comp)
        right = max(c for r, c in comp)
        top = min(r for r, c in comp)
        bottom = max(r for r, c in comp)

        # column where we will perform the vertical detour (just to the left of the region)
        detour_col = left - 1
        if detour_col < 0:
            detour_col = cur_c  # should not happen given placement, but safe fallback

        # draw horizontal track from current column to the detour column
        draw_h(cur_r, cur_c, detour_col)

        # decide whether the V points left or right by counting pixels in the bounding columns
        left_count = sum(1 for r, c in comp if c == left)
        right_count = sum(1 for r, c in comp if c == right)

        # V pointing left -> go up; V pointing right -> go down
        if left_count > right_count:
            # go up to the row just above the shape
            detour_row = top - 1
            if detour_row < 0:
                detour_row = 0
        else:
            # go down to the row just below the shape
            detour_row = bottom + 1
            if detour_row >= height:
                detour_row = height - 1

        # vertical to corridor row at detour_col
        draw_v(detour_col, cur_r, detour_row)
        # cross the region horizontally in the corridor (from detour_col+1 to right+1)
        cross_start = detour_col + 1
        cross_end = right + 1
        if cross_end >= width:
            cross_end = width - 1
        draw_h(detour_row, cross_start, cross_end)
        # return vertically back to the original ray row at column cross_end
        draw_v(cross_end, detour_row, ray_row)

        # set new current position to cell right after the region
        cur_r = ray_row
        cur_c = cross_end

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # infer background color as the corner (0,0)
    bg = grid[0][0]

    # find the ray start (a non-background pixel in the leftmost column)
    ray_color = None
    ray_row = None
    for r in range(height):
        val = grid[r][0]
        if val != bg:
            ray_color = val
            ray_row = r
            break
    # if no special left-edge pixel, try to find any unique color used only once (fallback)
    if ray_color is None:
        # try to find a color that appears on the left edge anywhere
        for r in range(height):
            if grid[r][0] != bg:
                ray_color = grid[r][0]
                ray_row = r
                break
    if ray_color is None:
        # nothing to do
        return grid

    # helper: get connected component by 4-neighborhood
    def get_component(sr, sc):
        color = grid[sr][sc]
        if color == bg or color == ray_color:
            return []
        seen = set()
        stack = [(sr, sc)]
        comp = []
        while stack:
            r, c = stack.pop()
            if (r, c) in seen:
                continue
            if grid[r][c] != color:
                continue
            seen.add((r, c))
            comp.append((r, c))
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                rr, cc = r + dr, c + dc
                if 0 <= rr < height and 0 <= cc < width and (rr, cc) not in seen and grid[rr][cc] == color:
                    stack.append((rr, cc))
        return comp

    # prepare output as a copy of input (do not overwrite regions)
    output = [row[:] for row in grid]

    # drawing helpers
    def draw_h(row, c1, c2):
        if c1 <= c2:
            rng = range(c1, c2 + 1)
        else:
            rng = range(c1, c2 - 1, -1)
        for c in rng:
            if output[row][c] == bg:
                output[row][c] = ray_color

    def draw_v(col_idx, r1, r2):
        if r1 <= r2:
            rng = range(r1, r2 + 1)
        else:
            rng = range(r1, r2 - 1, -1)
        for r in rng:
            if output[r][col_idx] == bg:
                output[r][col_idx] = ray_color

    # simulate path same logic as generator
    cur_r = ray_row
    cur_c = 0
    loops = 0
    while True:
        loops += 1
        if loops > 1000:
            break
        # find next non-background, non-ray pixel in the same row to the right
        found = None
        for c in range(cur_c + 1, width):
            v = grid[cur_r][c]
            if v != bg and v != ray_color:
                found = c
                break
        if found is None:
            draw_h(cur_r, cur_c, width - 1)
            break

        comp = get_component(cur_r, found)
        if not comp:
            # fallback: mark the single cell and continue
            if output[cur_r][found] == bg:
                output[cur_r][found] = ray_color
            cur_c = found
            continue

        left = min(c for r, c in comp)
        right = max(c for r, c in comp)
        top = min(r for r, c in comp)
        bottom = max(r for r, c in comp)

        detour_col = left - 1
        if detour_col < 0:
            detour_col = cur_c

        draw_h(cur_r, cur_c, detour_col)

        left_count = sum(1 for r, c in comp if c == left)
        right_count = sum(1 for r, c in comp if c == right)

        if left_count > right_count:
            detour_row = top - 1
            if detour_row < 0:
                detour_row = 0
        else:
            detour_row = bottom + 1
            if detour_row >= height:
                detour_row = height - 1

        draw_v(detour_col, cur_r, detour_row)

        cross_start = detour_col + 1
        cross_end = right + 1
        if cross_end >= width:
            cross_end = width - 1
        draw_h(detour_row, cross_start, cross_end)
        draw_v(cross_end, detour_row, ray_row)

        cur_r = ray_row
        cur_c = cross_end

    return output

