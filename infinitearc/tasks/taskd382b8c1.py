# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: d382b8c1
Difficulty: mediumâ€“hard

=== Tags ===
- Layered path system
- Periodic tiling

=== Description ===
Input grids feature a background color (0) with multiple contiguous paths, each
path composed of cells in a single distinct color (1-9), where different colors
represent distinct layers. Paths may cross but never occupy the same cell in the
input grid, and each path starts and ends at the grid's boundary. The
arrangement forms a layered path system where the color of each path encodes its
transformation rule.  The output grid is generated by applying a periodic shift
to each path based on its layer color. For a path of color k, every cell (r, c)
in the path is shifted to (r + (k mod 3), c + (k mod 5)) within the grid's
dimensions, with positions wrapping around the grid edges (toroidal boundary
conditions). Background cells (0) remain unchanged. This transformation creates
a periodic tiling effect: paths of different colors align such that their
shifted positions form repeating patterns across the grid, with higher-color
paths overriding lower-color paths at overlapping positions. The result is a
visually coherent grid where the layered path system exhibits seamless periodic
repetition through the shift rules encoded in the path colors.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
from common import grid, randint, choice, sample, shuffle

def generate():
    """Generate a layered path system and its shifted, tiled output.

    The input grid contains multiple non-overlapping orthogonal paths (one per color),
    each starting and ending on the grid border. The output is produced by shifting
    every path cell by (k % 3, k % 5) (toroidal wrap) where k is the path color.
    When shifted cells collide, the larger color value wins.
    """
    # Choose dimensions (kept moderate to ensure fast generation & solver speed)
    width = randint(12, 24)
    height = randint(12, 24)

    # Initialize input grid
    input_grid = grid(width, height, 0)

    # Number of distinct colored paths
    num_paths = randint(3, 5)
    colors = sample(list(range(1, 10)), num_paths)

    paths = {}

    # We will attempt to place every path. If placement fails repeatedly we restart
    # with new random parameters to avoid long loops.
    max_restarts = 30
    restart = 0

    while True:
        input_grid = grid(width, height, 0)
        paths.clear()
        ok = True

        for color in colors:
            placed = False
            # Try several times to create a non-overlapping border-to-border path
            for attempt in range(200):
                # Pick a random start on the border
                side = choice(['top', 'bottom', 'left', 'right'])
                if side == 'top':
                    sr = 0; sc = randint(0, width - 1)
                elif side == 'bottom':
                    sr = height - 1; sc = randint(0, width - 1)
                elif side == 'left':
                    sr = randint(0, height - 1); sc = 0
                else:
                    sr = randint(0, height - 1); sc = width - 1

                # Pick an end also on the border; ensure it's not the same cell
                end_side = choice(['top', 'bottom', 'left', 'right'])
                er, ec = sr, sc
                for _ in range(50):
                    if end_side == 'top':
                        er = 0; ec = randint(0, width - 1)
                    elif end_side == 'bottom':
                        er = height - 1; ec = randint(0, width - 1)
                    elif end_side == 'left':
                        er = randint(0, height - 1); ec = 0
                    else:
                        er = randint(0, height - 1); ec = width - 1
                    if (er, ec) != (sr, sc):
                        break
                    end_side = choice(['top', 'bottom', 'left', 'right'])

                if (er, ec) == (sr, sc):
                    # failed to find a distinct end quickly
                    continue

                # Create a Manhattan path (shuffled moves) from start to end.
                dr = er - sr
                dc = ec - sc
                moves = []
                if dr != 0:
                    step_r = 1 if dr > 0 else -1
                    moves += [(step_r, 0)] * abs(dr)
                if dc != 0:
                    step_c = 1 if dc > 0 else -1
                    moves += [(0, step_c)] * abs(dc)

                if not moves:
                    continue

                moves = shuffle(moves)

                path = [(sr, sc)]
                r, c = sr, sc
                valid = True
                for mv in moves:
                    r += mv[0]; c += mv[1]
                    if r < 0 or r >= height or c < 0 or c >= width:
                        valid = False
                        break
                    path.append((r, c))
                if not valid:
                    continue

                # Check for overlap with previously placed paths
                overlap = False
                for (pr, pc) in path:
                    if input_grid[pr][pc] != 0:
                        overlap = True
                        break
                if overlap:
                    continue

                # Place the path
                for (pr, pc) in path:
                    input_grid[pr][pc] = color
                paths[color] = path
                placed = True
                break

            if not placed:
                ok = False
                break

        if ok:
            break

        restart += 1
        if restart >= max_restarts:
            # Change parameters and try again to escape pathological cases
            width = randint(12, 24)
            height = randint(12, 24)
            num_paths = randint(3, 5)
            colors = sample(list(range(1, 10)), num_paths)
            restart = 0

    # Build the output grid by shifting each path and letting higher colors win on collisions
    output_grid = grid(width, height, 0)
    for color, path in paths.items():
        dx = color % 3
        dy = color % 5
        for (r, c) in path:
            nr = (r + dx) % height
            nc = (c + dy) % width
            if color > output_grid[nr][nc]:
                output_grid[nr][nc] = color

    return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    """Shift every nonzero cell by (color % 3, color % 5) with toroidal wrap.

    When multiple shifted cells collide, the larger color wins.
    """
    inp = [list(row) for row in input_grid]
    height = len(inp)
    width = len(inp[0]) if height > 0 else 0
    out = [[0] * width for _ in range(height)]

    for r in range(height):
        for c in range(width):
            color = inp[r][c]
            if color == 0:
                continue
            dx = color % 3
            dy = color % 5
            nr = (r + dx) % height
            nc = (c + dy) % width
            if color > out[nr][nc]:
                out[nr][nc] = color

    return tuple(tuple(row) for row in out)

