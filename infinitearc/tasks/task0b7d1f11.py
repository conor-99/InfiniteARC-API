# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 0b7d1f11
Difficulty: hard

=== Tags ===
- Analogical mapping between pairs
- Occlusion reasoning
- Compare image
- Substitution rule discovery

=== Description ===
The task involves input grids containing multiple colored regions where one
specific color (e.g., 2) acts as an occluder, partially covering regions of
another specific color (e.g., 4). The output grid is generated by replacing all
occurrences of the occluder color (2) that are directly adjacent (horizontally
or vertically) to the occluded color (4) with the occluded color (4). Adjacency
is determined by shared edges between cells, not spatial overlap in the grid
layout. For example, a cell with color 2 next to a cell with color 4 in the
input becomes color 4 in the output, while color 2 cells not adjacent to color 4
remain unchanged. The input grids are complex, featuring intricate arrangements
of colors with multiple overlapping regions, varying shapes, and non-trivial
adjacency patterns. The solver must identify the adjacency relationship between
the two colors and apply the substitution rule consistently across the grid,
requiring careful visual analysis of spatial relationships rather than relying
on color values or numerical properties.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = random.randint(2, 30)
    height = random.randint(2, 30)
    grid = common.grid(width, height, 0)
    r4, c4 = random.randint(0, height-1), random.randint(0, width-1)
    grid[r4][c4] = 4
    directions = [(0,1), (0,-1), (1,0), (-1,0)]
    for _ in range(10):
        dr, dc = random.choice(directions)
        r2, c2 = r4 + dr, c4 + dc
        if 0 <= r2 < height and 0 <= c2 < width:
            grid[r2][c2] = 2
            break
    else:
        r2, c2 = random.randint(0, height-1), random.randint(0, width-1)
        grid[r2][c2] = 2
    for r in range(height):
        for c in range(width):
            if (r, c) != (r4, c4) and (r, c) != (r2, c2):
                grid[r][c] = random.randint(0, 9)
    output = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 2:
                for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 4:
                        output[r][c] = 4
                        break
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    output = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 2:
                for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 4:
                        output[r][c] = 4
                        break
    return output
