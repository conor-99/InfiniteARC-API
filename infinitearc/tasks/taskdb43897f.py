# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: db43897f
Difficulty: medium–hard

=== Tags ===
- Maze wave
- Stateful propagation
- Diagonal weaving
- Find the odd shape out
- Grid coloring

=== Description ===
Input grids feature a maze-like structure with a consistent background color (0)
and walls composed of non-zero colors. A continuous diagonal path of a single
color (S, e.g., 3) originates from the left edge and propagates northeast
through background cells. Along this path, exactly one cell deviates from the
path color, displaying a distinct "odd shape" color (O, e.g., 7), which is
unique within the path and visually stands out. Walls and background remain
unchanged, forming a constrained environment where the path must navigate.   The
output grid transforms the input by: (1) recoloring the odd shape cell to the
path color (S), (2) altering the path's direction at the odd shape
location—switching from northeast to southeast propagation—and (3) continuing
the path with color S in the new direction. This direction change creates a
diagonal weaving pattern where the path bends at the odd shape, weaving through
the maze. Walls, background, and all other elements remain visually unchanged
except for the recolored odd shape and the modified path trajectory. The
transformation requires identifying the odd shape's position, applying stateful
directional propagation, and ensuring the path's diagonal weaving pattern
adheres to the new trajectory without overlapping walls or altering other grid
features.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Grid size
    height = random.randint(10, 18)
    width = random.randint(10, 18)

    # Choose distinct path color S and odd color O
    S = random.randint(1, 9)
    O = random.randint(1, 9)
    while O == S:
        O = random.randint(1, 9)

    # Path length (must fit in grid diagonally)
    max_m = min(width, height) - 1
    if max_m < 4:
        m = max(4, max_m)
    else:
        m = random.randint(4, max_m)

    # Starting row on the left edge so that NE path stays in bounds
    start_row = random.randint(m - 1, height - 1)

    # Position of the odd shape along the path (not first or last)
    k = random.randint(1, m - 2)

    # Initialize empty grid (background 0)
    grid = [[0 for _ in range(width)] for _ in range(height)]

    # Create the original NE path from the left edge
    path = []
    for i in range(m):
        r = start_row - i
        c = i
        path.append((r, c))
        grid[r][c] = O if i == k else S

    # Compute the southeast positions that will become part of the new path in the output
    o_r, o_c = path[k]
    se_positions = []
    t = 1
    while True:
        r = o_r + t
        c = o_c + t
        if r >= height or c >= width:
            break
        se_positions.append((r, c))
        t += 1

    # Also reserve the cells on the same NE diagonal beyond the original path so that
    # the diagonal terminates cleanly (these must be background in the input)
    extra_ne = []
    j = m
    while True:
        r = start_row - j
        c = j
        if r < 0 or c >= width:
            break
        extra_ne.append((r, c))
        j += 1

    # Choose a wall color different from S and O
    colors = list(range(1, 10))
    wall_choices = [c for c in colors if c not in (S, O)]
    wall_color = random.choice(wall_choices)

    # Fill the rest of the grid with walls probabilistically, but preserve:
    # - all path cells, - the reserved SE positions, - the extra NE tail cells,
    # - left edge except the path start (keep column 0 mostly background to make the path identifiable)
    density = random.uniform(0.25, 0.5)
    reserved = set(path) | set(se_positions) | set(extra_ne)
    for r in range(height):
        for c in range(width):
            if (r, c) in reserved:
                continue
            if c == 0:
                # keep left edge background except the path start which is already set
                continue
            if random.random() < density:
                grid[r][c] = wall_color

    # Build the output grid by applying the described transformation:
    # 1) recolor the odd cell to S, 2) erase the original NE tail beyond the odd cell,
    # 3) draw a SE tail from the odd cell until blocked by a wall or the border.
    output = [row[:] for row in grid]

    # Recolor the odd shape to the path color
    output[o_r][o_c] = S

    # Erase the NE tail beyond the odd cell (these were originally S in the input)
    for j in range(k + 1, len(path)):
        r, c = path[j]
        output[r][c] = 0

    # Draw the SE continuation, but stop if we hit a non-background cell in the input
    for r, c in se_positions:
        if grid[r][c] != 0:
            break
        output[r][c] = S

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Find the NE diagonal path that starts on the left edge and has exactly one odd cell
    S = None
    odd_index = None
    path = None
    o_r = o_c = None

    for start_r in range(height):
        if grid[start_r][0] == 0:
            continue
        # Walk NE along non-background cells
        candidate = []
        r, c = start_r, 0
        while 0 <= r < height and 0 <= c < width and grid[r][c] != 0:
            candidate.append((r, c))
            r -= 1
            c += 1

        if len(candidate) < 3:
            continue

        colors = [grid[r][c] for (r, c) in candidate]
        counts = {}
        for col in colors:
            counts[col] = counts.get(col, 0) + 1

        # Mode color should appear exactly len(colors)-1 times (one odd cell)
        mode_color = max(counts, key=lambda k: counts[k])
        if counts[mode_color] == len(colors) - 1:
            S = mode_color
            # locate the odd cell
            for idx, (r, c) in enumerate(candidate):
                if grid[r][c] != S:
                    odd_index = idx
                    o_r, o_c = r, c
                    path = candidate
                    break
            if odd_index is not None:
                break

    # If nothing found, return the input unchanged (safe fallback)
    if S is None or odd_index is None:
        return grid

    # Build output by copying input
    output = [row[:] for row in grid]

    # Recolor odd cell to S
    output[o_r][o_c] = S

    # Erase NE tail beyond the odd cell
    for j in range(odd_index + 1, len(path)):
        r, c = path[j]
        output[r][c] = 0

    # Continue SE from the odd cell while the input has background cells
    t = 1
    while True:
        r_new = o_r + t
        c_new = o_c + t
        if r_new >= height or c_new >= width:
            break
        if grid[r_new][c_new] != 0:
            break
        output[r_new][c_new] = S
        t += 1

    return output

