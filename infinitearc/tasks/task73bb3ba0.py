# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 73bb3ba0
Difficulty: hard

=== Tags ===
- Oscillating rule
- Modular sequence
- Wraparound copy

=== Description ===
Input grids are square (15×15 to 30×30) with a background color (0). Overlaid on
the background are multiple distinct, non-overlapping shapes (e.g., rectangles,
circles, or irregular polygons) each composed of a single solid color (1–9),
with no two shapes sharing the same color. Shapes are positioned such that their
bounding boxes are axis-aligned and separated by at least one background cell.
The grid contains at least 6 distinct shapes, each occupying a contiguous region
of 3–12 cells.  The transformation applies a position-based modular shift to
each cell: - For each cell (r, c) in the output grid, compute the modular index
k = (r + c) mod 3. - If k = 0, the cell is filled with the value from the input
cell at (r, c - 1) (left wraparound). - If k = 1, the cell is filled with the
value from the input cell at (r - 1, c) (up wraparound). - If k = 2, the cell is
filled with the value from the input cell at (r, c + 1) (right wraparound).
This creates an oscillating shift pattern where the direction alternates
cyclically (left → up → right → left...) based on the position's modular index,
with all edges wrapping to the opposite side of the grid. The background color
(0) is preserved in positions where no non-background cells are shifted into
them. The transformation is deterministic, reversible, and requires recognizing
the spatial relationship between cell positions rather than analyzing color
values. The output grid maintains the same dimensions as the input, with all
shapes transformed according to the wraparound shift rule.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import random_color

def generate():
    N = random.randint(15, 30)
    input_grid = [[0] * N for _ in range(N)]
    used_colors = set()
    num_shapes = random.randint(6, 9)
    
    for _ in range(num_shapes):
        color = random_color(exclude=used_colors)
        used_colors.add(color)
        size = random.randint(3, 12)
        start_r = random.randint(0, N-1)
        start_c = random.randint(0, N-1)
        region = [(start_r, start_c)]
        visited = set(region)
        
        while len(region) < size:
            r, c = random.choice(region)
            for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < N and 0 <= nc < N and (nr, nc) not in visited:
                    visited.add((nr, nc))
                    region.append((nr, nc))
                    if len(region) == size:
                        break
            if len(region) >= size:
                break
        
        valid = True
        for r, c in region:
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < N and 0 <= nc < N and input_grid[nr][nc] != 0:
                    valid = False
                    break
            if not valid:
                break
        if not valid:
            continue
        
        for r, c in region:
            input_grid[r][c] = color
    
    output_grid = [[0] * N for _ in range(N)]
    for r in range(N):
        for c in range(N):
            k = (r + c) % 3
            if k == 0:
                c_prev = (c - 1) % N
                output_grid[r][c] = input_grid[r][c_prev]
            elif k == 1:
                r_prev = (r - 1) % N
                output_grid[r][c] = input_grid[r_prev][c]
            else:
                c_next = (c + 1) % N
                output_grid[r][c] = input_grid[r][c_next]
    
    if input_grid == output_grid:
        return generate()
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    N = len(input_grid)
    input_list = [list(row) for row in input_grid]
    output_list = [[0] * N for _ in range(N)]
    
    for r in range(N):
        for c in range(N):
            k = (r + c) % 3
            if k == 0:
                c_prev = (c - 1) % N
                output_list[r][c] = input_list[r][c_prev]
            elif k == 1:
                r_prev = (r - 1) % N
                output_list[r][c] = input_list[r_prev][c]
            else:
                c_next = (c + 1) % N
                output_list[r][c] = input_list[r][c_next]
    
    return output_list
