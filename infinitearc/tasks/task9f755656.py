# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 9f755656
Difficulty: insane

=== Tags ===
- Symmetry axis completion
- Color stream
- Alternating rule composition
- Gravity
- Pattern expansion

=== Description ===
The input grid consists of a large 20x20 grid with a distinct vertical symmetry
axis separating two halves. The left half (columns 0-9) contains a complex,
multi-colored pattern of non-background colors (1-9), while the right half
(columns 10-19) is entirely empty (background color 0). Across the grid, a
continuous "color stream" traverses the central row (row 9), alternating between
two specific non-background colors (e.g., color 2 followed by color 3) as it
moves rightward. The stream begins on the left half and crosses the symmetry
axis, with its color alternation continuing seamlessly across the axis. The grid
also exhibits an implicit downward gravity direction, indicated by the
orientation of the color stream path and the natural alignment of the pattern.
The output grid must perform three sequential transformations: 1. **Symmetry
axis completion**: Mirror the left half's pattern to the right half, preserving
all colors and positions. The mirrored right half must perfectly reflect the
left half across the vertical axis (e.g., column 9 mirrors to column 10, column
8 to column 11, etc.). 2. **Color stream extension**: Extend the color stream
across the symmetry axis, maintaining its alternating color sequence. The stream
must continue its alternation pattern (e.g., if the stream ended with color 3 on
the left side, the first cell on the right side must be color 2). 3. **Gravity
application**: Shift all non-background elements (colors 1-9) downward by one
row, with the bottom row's elements being removed (no wrapping). This includes
the mirrored pattern, the extended color stream, and any other non-background
elements, while background color 0 remains unchanged.  The task requires
recognizing the symmetry axis, maintaining the stream's alternation during
mirroring, and applying gravity to the entire transformed grid. The complexity
arises from the interplay between the symmetry transformation, the stream's
color alternation logic, and the gravity shift, all of which must be applied in
sequence without overlapping or conflicting rules. No elements are allowed to
overlap or overwrite during these transformations, and all background color 0
cells must remain empty in the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid


def generate():
    width = 20
    height = 20
    left_w = width // 2
    central_row = height // 2 - 1  # row 9 for height=20

    # Create empty input grid
    input_grid = grid(width, height, 0)

    # Choose two distinct non-background colors for the alternating stream
    A, B = random.sample(list(range(1, 10)), 2)

    # Fill the left half with a complex multi-colored pattern (non-zero colors)
    for r in range(height):
        for c in range(left_w):
            if r == central_row:
                # The central row (row 9) is a color stream that alternates A, B starting with A at col 0
                input_grid[r][c] = A if (c % 2 == 0) else B
            else:
                # Other left-half cells: random non-background colors (1-9)
                input_grid[r][c] = random.randint(1, 9)

    # Right half remains background (0)

    # Step 1: Start with a copy of the input and mirror the left half into the right half
    output_grid = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(left_w):
            mirror_c = width - 1 - c  # column 9 -> 10, 8 -> 11, etc.
            output_grid[r][mirror_c] = input_grid[r][c]

    # Step 2: Extend the color stream across the symmetry axis, continuing the alternation
    last_color = input_grid[central_row][left_w - 1]
    # other_color is the alternate of last_color among (A,B)
    other_color = A if last_color == B else B
    for c in range(left_w, width):
        d = c - (left_w - 1)  # distance from the last left-half column
        # d==1 -> first cell on right half should be the alternate of last_color
        output_grid[central_row][c] = last_color if (d % 2 == 0) else other_color

    # Step 3: Apply gravity (shift all non-background pixels down by one row)
    gravity_grid = grid(width, height, 0)
    for r in range(height - 1):
        for c in range(width):
            v = output_grid[r][c]
            if v != 0:
                gravity_grid[r + 1][c] = v

    return {"input": input_grid, "output": gravity_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    inp = [list(row) for row in input_grid]
    height = len(inp)
    width = len(inp[0])
    left_w = width // 2
    central_row = height // 2 - 1  # row 9 for height=20

    # Start with a copy of the input
    output = [row[:] for row in inp]

    # Step 1: Mirror left half into right half
    for r in range(height):
        for c in range(left_w):
            mirror_c = width - 1 - c
            output[r][mirror_c] = inp[r][c]

    # Determine the two alternating colors used in the left-half stream (row central_row)
    vals = [v for v in inp[central_row][:left_w] if v != 0]
    unique = []
    for v in vals:
        if v not in unique:
            unique.append(v)
    if len(unique) >= 2:
        A, B = unique[0], unique[1]
    elif len(unique) == 1:
        A = unique[0]
        B = next(x for x in range(1, 10) if x != A)
    else:
        # Fallback (should not happen with a correct generator)
        A, B = 1, 2

    # Step 2: Extend the color stream across the axis, maintaining alternation
    last_color = inp[central_row][left_w - 1]
    other_color = A if last_color == B else B
    for c in range(left_w, width):
        d = c - (left_w - 1)
        output[central_row][c] = last_color if (d % 2 == 0) else other_color

    # Step 3: Apply gravity (shift non-zero pixels down by one row)
    final = [[0 for _ in range(width)] for _ in range(height)]
    for r in range(height - 1):
        for c in range(width):
            if output[r][c] != 0:
                final[r + 1][c] = output[r][c]

    return tuple(tuple(row) for row in final)

