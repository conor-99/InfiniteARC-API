# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: c9efb8dd
Difficulty: medium–hard

=== Tags ===
- Deterministic update
- Temporal wave step
- Local symmetry matching
- Symmetry axis completion

=== Description ===
Input grids feature a background color with multiple distinct, non-overlapping
colored regions. Each region is a connected group of orthogonally adjacent cells
forming a shape with a local symmetry axis (vertical or horizontal), but the
region is incomplete—missing the mirrored counterpart across its axis. The
symmetry axis for each region is determined by the spatial arrangement of
existing cells (e.g., the vertical axis through the center of the region's
bounding box, or horizontal axis for vertically oriented regions).   The
transformation applies a deterministic "temporal wave step" process: regions are
processed sequentially in row-major order (top to bottom, left to right). For
each region, the existing cells are mirrored across their local symmetry axis to
complete the shape, using identical colors. Regions already symmetric remain
unchanged. The wave progression ensures that symmetry completion in earlier
regions does not affect later regions' processing, as all regions are
independent.   Output grids reflect all completed symmetries: mirrored regions
are exact duplicates across their axes, background cells remain unchanged, and
no new regions are created. The task requires identifying each region's unique
axis and applying precise mirroring—no manual alignment or global symmetry is
assumed. Difficulty arises from varying axis orientations across regions, the
need to distinguish incomplete symmetry from complete shapes, and ensuring no
overlap or misalignment during mirroring.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid


def _grow_cluster(seed, size, row0, col0, half_w, bh):
    # Grow a connected cluster within the left/top half area using a simple randomized BFS
    # seed: (r,c) absolute coordinates
    # area bounds: rows row0..row0+bh-1, cols col0..col0+half_w-1
    from collections import deque
    cluster = set([seed])
    q = deque([seed])
    attempts = 0
    while len(cluster) < size and q and attempts < size * 10:
        attempts += 1
        r, c = q.popleft()
        neighbors = [(r+1,c),(r-1,c),(r,c+1),(r,c-1)]
        random.shuffle(neighbors)
        for nr, nc in neighbors:
            if nr < row0 or nr >= row0 + bh or nc < col0 or nc >= col0 + half_w:
                continue
            if (nr, nc) in cluster:
                continue
            cluster.add((nr, nc))
            q.append((nr, nc))
            if len(cluster) >= size:
                break
    # If we didn't reach desired size, try to add random nearby cells until size reached
    if len(cluster) < size:
        candidates = []
        for rr in range(row0, row0 + bh):
            for cc in range(col0, col0 + half_w):
                if (rr, cc) not in cluster:
                    candidates.append((rr, cc))
        random.shuffle(candidates)
        for pos in candidates:
            cluster.add(pos)
            if len(cluster) >= size:
                break
    return list(cluster)


def generate():
    # Grid size
    w = random.randint(10, 20)
    h = random.randint(10, 20)
    input_grid = grid(w, h, 0)
    output_grid = grid(w, h, 0)

    # Occupancy mask to keep full bounding boxes free (so regions don't overlap)
    occupied = [[False for _ in range(w)] for _ in range(h)]

    num_regions = random.randint(3, 5)
    colors = random.sample(list(range(1, 10)), num_regions)

    placed = 0
    tries = 0
    max_tries = 1000

    while placed < num_regions and tries < max_tries:
        tries += 1
        color = colors[placed]
        orientation = random.choice(["vertical", "horizontal"])

        if orientation == "vertical":
            # bounding box wide > tall, choose even width so axis lies cleanly between columns
            max_bw = min(12, w)
            possible_bw = [x for x in range(4, max_bw + 1) if x % 2 == 0]
            if not possible_bw:
                continue
            bw = random.choice(possible_bw)
            max_bh = min(bw - 1, h)
            if max_bh < 3:
                continue
            bh = random.randint(3, max_bh)
            row0 = random.randint(0, h - bh)
            col0 = random.randint(0, w - bw)

            # ensure bbox free
            conflict = False
            for rr in range(row0, row0 + bh):
                for cc in range(col0, col0 + bw):
                    if occupied[rr][cc]:
                        conflict = True
                        break
                if conflict:
                    break
            if conflict:
                continue

            # create a connecting horizontal spine that reaches both bbox edges
            mid_row = random.randint(row0, row0 + bh - 1)
            spine = [(mid_row, cc) for cc in range(col0, col0 + bw)]

            # create a cluster anchored to the left half (to make shape asymmetric)
            half_w = bw // 2
            half_area = half_w * bh
            # ensure at least one extra cell beyond the spine in left half
            cluster_size = random.randint(1, max(1, half_area - 1))
            # pick a seed adjacent to the spine but inside the left half
            if mid_row > row0:
                seed_r = mid_row - 1
            elif mid_row < row0 + bh - 1:
                seed_r = mid_row + 1
            else:
                seed_r = mid_row
            seed_c = random.randint(col0, col0 + half_w - 1)
            seed = (seed_r, seed_c)

            cluster = _grow_cluster(seed, cluster_size, row0, col0, half_w, bh)

            # Build the final region pixels as union of spine and cluster (ensure connectedness)
            region_pixels = set(spine) | set(cluster)

            # paint input and output; output will additionally get mirrored pixels
            min_c = col0
            max_c = col0 + bw - 1
            for (r, c) in region_pixels:
                input_grid[r][c] = color
                output_grid[r][c] = color
            for (r, c) in list(region_pixels):
                mirror_c = min_c + max_c - c
                output_grid[r][mirror_c] = color

            # mark bbox occupied
            for rr in range(row0, row0 + bh):
                for cc in range(col0, col0 + bw):
                    occupied[rr][cc] = True

            placed += 1

        else:
            # horizontal orientation: tall > wide, choose even height so axis lies between rows
            max_bh = min(12, h)
            possible_bh = [y for y in range(4, max_bh + 1) if y % 2 == 0]
            if not possible_bh:
                continue
            bh = random.choice(possible_bh)
            max_bw = min(bh - 1, w)
            if max_bw < 3:
                continue
            bw = random.randint(3, max_bw)
            row0 = random.randint(0, h - bh)
            col0 = random.randint(0, w - bw)

            # ensure bbox free
            conflict = False
            for rr in range(row0, row0 + bh):
                for cc in range(col0, col0 + bw):
                    if occupied[rr][cc]:
                        conflict = True
                        break
                if conflict:
                    break
            if conflict:
                continue

            # create a vertical spine that connects top and bottom of bbox
            mid_col = random.randint(col0, col0 + bw - 1)
            spine = [(rr, mid_col) for rr in range(row0, row0 + bh)]

            # cluster in top half to create asymmetry
            half_h = bh // 2
            half_area = half_h * bw
            cluster_size = random.randint(1, max(1, half_area - 1))
            if mid_col > col0:
                seed_c = mid_col - 1
            elif mid_col < col0 + bw - 1:
                seed_c = mid_col + 1
            else:
                seed_c = mid_col
            seed_r = random.randint(row0, row0 + half_h - 1)
            seed = (seed_r, seed_c)

            # grow cluster within the top half area
            # reusing _grow_cluster by rotating coordinates
            # _grow_cluster requires parameters (seed,size,row0,col0,half_w,bh)
            # here: rows row0..row0+half_h-1, cols col0..col0+bw-1
            cluster = _grow_cluster(seed, cluster_size, row0, col0, bw, half_h)

            region_pixels = set(spine) | set(cluster)

            min_r = row0
            max_r = row0 + bh - 1
            for (r, c) in region_pixels:
                input_grid[r][c] = color
                output_grid[r][c] = color
            for (r, c) in list(region_pixels):
                mirror_r = min_r + max_r - r
                output_grid[mirror_r][c] = color

            # mark bbox occupied
            for rr in range(row0, row0 + bh):
                for cc in range(col0, col0 + bw):
                    occupied[rr][cc] = True

            placed += 1

    # Ensure at least one change (should be true), otherwise force a small vertical region
    if placed == 0:
        color = 1
        bw = min(4, w)
        bh = min(3, h)
        row0 = 0
        col0 = 0
        mid_row = row0 + bh // 2
        spine = [(mid_row, cc) for cc in range(col0, col0 + bw)]
        half_w = bw // 2
        seed = (mid_row - 1 if mid_row > 0 else mid_row + 1, col0)
        cluster = _grow_cluster(seed, 1, row0, col0, half_w, bh)
        region_pixels = set(spine) | set(cluster)
        min_c = col0
        max_c = col0 + bw - 1
        for (r, c) in region_pixels:
            input_grid[r][c] = color
            output_grid[r][c] = color
        for (r, c) in list(region_pixels):
            mirror_c = min_c + max_c - c
            output_grid[r][mirror_c] = color

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])

    visited = [[False] * w for _ in range(h)]
    regions = []  # list of tuples (min_r, min_c, max_r, max_c, pixels_list, color)

    # Find connected regions (4-connected) and record original pixels
    for r in range(h):
        for c in range(w):
            if grid[r][c] > 0 and not visited[r][c]:
                color = grid[r][c]
                queue = [(r, c)]
                visited[r][c] = True
                pixels = []
                min_r = max_r = r
                min_c = max_c = c
                while queue:
                    pr, pc = queue.pop(0)
                    pixels.append((pr, pc))
                    if pr < min_r: min_r = pr
                    if pr > max_r: max_r = pr
                    if pc < min_c: min_c = pc
                    if pc > max_c: max_c = pc
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = pr + dr, pc + dc
                        if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                regions.append((min_r, min_c, max_r, max_c, pixels, color))

    # Process regions in row-major order of their bounding box top-left
    regions.sort(key=lambda x: (x[0], x[1]))

    output = [row[:] for row in grid]

    for (min_r, min_c, max_r, max_c, pixels, color) in regions:
        width = max_c - min_c + 1
        height = max_r - min_r + 1
        if width > height:
            # Vertical axis: mirror columns across the bounding box center
            for (r, c) in pixels:
                mirror_c = min_c + max_c - c
                if 0 <= mirror_c < w and output[r][mirror_c] == 0:
                    output[r][mirror_c] = color
        else:
            # Horizontal axis: mirror rows across the bounding box center
            for (r, c) in pixels:
                mirror_r = min_r + max_r - r
                if 0 <= mirror_r < h and output[mirror_r][c] == 0:
                    output[mirror_r][c] = color

    return tuple(tuple(row) for row in output)

