# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 0eaa924d
Difficulty: hard

=== Tags ===
- Remove intruder

=== Description ===
The task involves identifying and removing the smallest connected component
(intruder) from the input grid. The input grid contains a main structure formed
by a large connected group of cells (color 1–9) and a single distinct intruder
component that is visually isolated and smaller than all other connected groups.
The intruder may consist of 1–3 cells and is positioned such that it does not
connect to the main structure through adjacent (top/bottom/left/right) cells.
The output grid is formed by replacing all cells of this intruder component with
the background color (0), while preserving the main structure and all other
visual features. The intruder is uniquely identifiable by its size and
isolation, requiring the solver to analyze connectivity and relative component
sizes rather than relying on color dominance or simple positional patterns.
Complex grids may include overlapping shapes or multiple small clusters, but the
intruder is always the single smallest component with no ties.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    S = random.randint(4, 15)
    M = random.randint(1, 3)
    
    main_pixels = common.continuous_creature(S, width, height)
    main_rows = [p[0] for p in main_pixels]
    main_cols = [p[1] for p in main_pixels]
    main_set = set(zip(main_rows, main_cols))
    
    safe_cells = []
    for r in range(height):
        for c in range(width):
            if (r, c) in main_set:
                continue
            adjacent = False
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if (nr, nc) in main_set:
                    adjacent = True
                    break
            if not adjacent:
                safe_cells.append((r, c))
    
    if len(safe_cells) < M:
        M = 1
    
    if M == 1:
        intruder_rows = [safe_cells[0][0]]
        intruder_cols = [safe_cells[0][1]]
    elif M == 2:
        intruder_rows = []
        intruder_cols = []
        for r, c in safe_cells:
            for dr, dc in [(1,0), (0,1)]:
                nr, nc = r + dr, c + dc
                if (nr, nc) in safe_cells:
                    intruder_rows = [r, nr]
                    intruder_cols = [c, nc]
                    break
            if intruder_rows:
                break
        if not intruder_rows:
            intruder_rows = [safe_cells[0][0], safe_cells[1][0]]
            intruder_cols = [safe_cells[0][1], safe_cells[1][1]]
    else:  # M == 3
        intruder_rows = []
        intruder_cols = []
        for r, c in safe_cells:
            neighbors = []
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if (nr, nc) in safe_cells:
                    neighbors.append((nr, nc))
            if len(neighbors) >= 2:
                intruder_rows = [r, neighbors[0][0], neighbors[1][0]]
                intruder_cols = [c, neighbors[0][1], neighbors[1][1]]
                break
        if not intruder_rows:
            intruder_rows = [safe_cells[0][0], safe_cells[1][0], safe_cells[2][0]]
            intruder_cols = [safe_cells[0][1], safe_cells[1][1], safe_cells[2][1]]
    
    input_grid = [[0] * width for _ in range(height)]
    color_main = random.randint(1, 9)
    color_intruder = random.randint(1, 9)
    while color_intruder == color_main:
        color_intruder = random.randint(1, 9)
    
    for r, c in zip(main_rows, main_cols):
        input_grid[r][c] = color_main
    for r, c in zip(intruder_rows, intruder_cols):
        input_grid[r][c] = color_intruder
    
    output_grid = [row[:] for row in input_grid]
    for r, c in zip(intruder_rows, intruder_cols):
        output_grid[r][c] = 0
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    rows = len(input_grid)
    cols = len(input_grid[0])
    visited = [[False] * cols for _ in range(rows)]
    components = []
    
    for r in range(rows):
        for c in range(cols):
            if not visited[r][c] and input_grid[r][c] != 0:
                component = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and input_grid[nr][nc] != 0:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append(component)
    
    smallest_comp = min(components, key=len)
    output_grid = [row[:] for row in input_grid]
    for (r, c) in smallest_comp:
        output_grid[r][c] = 0
    return output_grid
