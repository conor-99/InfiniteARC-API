# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 2670e314
Difficulty: hard

=== Tags ===
- Obstacles

=== Description ===
Obstacle-Avoiding Replication: Input grids feature a small contiguous colored
region (the stencil), a two-cell arrow glyph indicating a specific direction
(e.g., horizontal or vertical), and obstacle cells marked by a distinct color
(e.g., 5). The output grid replicates the stencil in the direction of the arrow,
shifting the entire stencil by one cell per replication step. Each copy is
placed only on background cells (value 0), halting replication if the next copy
would overlap with an obstacle or extend beyond grid boundaries. The original
stencil and arrow remain unchanged in the output, with all replicated stencils
visible as contiguous copies aligned with the arrow's direction. Obstacles block
replication paths, requiring users to identify the stencil, arrow orientation,
and obstacle positions to determine the exact number and placement of copies.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    # Try multiple times to create a valid scene
    for attempt in range(500):
        width = common.randint(5, 20)
        height = common.randint(5, 20)
        grid = common.grid(width, height, 0)
        # pick direction
        directions = [(0,1),(0,-1),(1,0),(-1,0)]
        dr, dc = common.choice(directions)
        # choose sprite box dims
        max_box_w = min(4, width)
        max_box_h = min(4, height)
        sprite_box_w = common.randint(1, max_box_w)
        sprite_box_h = common.randint(1, max_box_h)
        max_stencil_size = min(6, sprite_box_w * sprite_box_h)
        stencil_size = common.randint(2 if max_stencil_size>=2 else 1, max_stencil_size)
        rel_pixels = common.continuous_creature(stencil_size, sprite_box_w, sprite_box_h)
        # Determine anchors where original and first shifted stencil will fit
        anchors = []
        for ar in range(0, height - sprite_box_h + 1):
            for ac in range(0, width - sprite_box_w + 1):
                ok = True
                for rr, cc in rel_pixels:
                    r = ar + rr
                    c = ac + cc
                    if not (0 <= r < height and 0 <= c < width):
                        ok = False
                        break
                    r2 = r + dr
                    c2 = c + dc
                    if not (0 <= r2 < height and 0 <= c2 < width):
                        ok = False
                        break
                if ok:
                    anchors.append((ar, ac))
        if not anchors:
            continue
        anchor = common.choice(anchors)
        stencil_pixels = [(anchor[0] + rr, anchor[1] + cc) for rr, cc in rel_pixels]
        # pick stencil color distinct from background(0), obstacles(5) and arrow colors (6,7)
        stencil_color = common.random_color(exclude=[0,5,6,7])
        # place stencil
        for r,c in stencil_pixels:
            grid[r][c] = stencil_color
        # reserve first shifted position (we must keep them empty so at least one replication)
        first_next = [(r + dr, c + dc) for r, c in stencil_pixels]
        reserved = set(stencil_pixels) | set(first_next)
        # choose arrow tail/head positions such that head = tail + (dr,dc)
        arrow_candidates = []
        for r in range(height):
            for c in range(width):
                head_r = r + dr
                head_c = c + dc
                if not (0 <= head_r < height and 0 <= head_c < width):
                    continue
                if (r, c) in reserved or (head_r, head_c) in reserved:
                    continue
                if grid[r][c] != 0 or grid[head_r][head_c] != 0:
                    continue
                arrow_candidates.append((r, c))
        if not arrow_candidates:
            # try different placement by continuing attempts
            continue
        tail_r, tail_c = common.choice(arrow_candidates)
        head_r, head_c = tail_r + dr, tail_c + dc
        # place arrow with tail color 6 and head color 7 to encode direction unambiguously
        grid[tail_r][tail_c] = 6
        grid[head_r][head_c] = 7
        # place obstacles avoiding reserved cells and arrow cells
        avoid = set(stencil_pixels) | set(first_next) | {(tail_r, tail_c), (head_r, head_c)}
        free_cells = [(r, c) for r in range(height) for c in range(width) if (r, c) not in avoid and grid[r][c] == 0]
        # ensure at least one obstacle to match the "Obstacles" tag
        max_obs = min(12, len(free_cells))
        if max_obs <= 0:
            # unlucky placement; try again
            continue
        num_obs = common.randint(1, max_obs)
        obs_positions = common.sample(free_cells, num_obs)
        for r,c in obs_positions:
            grid[r][c] = 5
        # compute output by replicating the stencil along (dr,dc) while landing only on background cells (0)
        output = [row[:] for row in grid]
        current = stencil_pixels
        while True:
            next_pixels = [(r + dr, c + dc) for r, c in current]
            valid = True
            for nr, nc in next_pixels:
                if not (0 <= nr < height and 0 <= nc < width) or output[nr][nc] != 0:
                    valid = False
                    break
            if not valid:
                break
            for nr, nc in next_pixels:
                output[nr][nc] = stencil_color
            current = next_pixels
        # ensure at least one replication occurred
        if grid != output:
            return {"input": grid, "output": output}
    # Fallback -- unlikely
    # Build a minimal example where stencil is a single pixel that can replicate once
    width, height = 5, 5
    grid = common.grid(width, height, 0)
    stencil_color = common.random_color(exclude=[0,5,6,7])
    grid[2][1] = stencil_color
    grid[2][3] = 6
    grid[2][4] = 7
    grid[0][0] = 5
    output = [row[:] for row in grid]
    output[2][2] = stencil_color
    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0
    # find stencil color (color not in {0,5,6,7}) by frequency
    counts = {}
    for r in range(height):
        for c in range(width):
            val = grid[r][c]
            if val not in (0,5,6,7):
                counts[val] = counts.get(val, 0) + 1
    if not counts:
        # nothing to do
        return tuple(tuple(row) for row in grid)
    stencil_color = max(counts.keys(), key=lambda k: counts[k])
    # find stencil pixels
    stencil_pixels = [(r,c) for r in range(height) for c in range(width) if grid[r][c] == stencil_color]
    # find arrow: prefer explicit head color 7 and tail color 6
    dr = dc = 0
    found = False
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 7:
                # head found; find the tail (6) adjacent to it
                for drn, dcn in [(0,1),(0,-1),(1,0),(-1,0)]:
                    nr, nc = r + drn, c + dcn
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 6:
                        # tail is (nr,nc) and head is (r,c)
                        dr = r - nr
                        dc = c - nc
                        found = True
                        break
                if found:
                    break
        if found:
            break
    # fallback: if no 7 head found, find any adjacent pair of 6s and use the order encountered
    if not found:
        arrow_pos = None
        for r in range(height):
            for c in range(width):
                if grid[r][c] == 6:
                    for drn, dcn in [(0,1),(0,-1),(1,0),(-1,0)]:
                        nr, nc = r + drn, c + dcn
                        if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 6:
                            arrow_pos = (r, c, nr, nc)
                            break
                    if arrow_pos:
                        break
            if arrow_pos:
                break
        if arrow_pos:
            r1, c1, r2, c2 = arrow_pos
            dr = r2 - r1
            dc = c2 - c1
        else:
            # default to right
            dr, dc = 0, 1
    # replicate stencil
    output = [row[:] for row in grid]
    current = stencil_pixels
    while True:
        next_pixels = [(r + dr, c + dc) for r,c in current]
        valid = True
        for nr, nc in next_pixels:
            if not (0 <= nr < height and 0 <= nc < width) or output[nr][nc] != 0:
                valid = False
                break
        if not valid:
            break
        for nr, nc in next_pixels:
            output[nr][nc] = stencil_color
        current = next_pixels
    return tuple(tuple(row) for row in output)

