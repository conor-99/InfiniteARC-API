# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 37e5e8d2
Difficulty: medium

=== Tags ===
- Periodic tiling
- Image repetition
- Detect rotational symmetry
- Compare image

=== Description ===
The input grid contains a single, rotationally symmetric rectangular pattern
(180-degree symmetry) embedded within a larger grid of background color (0). The
pattern is defined by a minimal bounding box that contains all non-zero pixels,
and the pattern's arrangement satisfies 180-degree rotational symmetry (i.e.,
rotating the pattern 180 degrees around its center results in an identical
arrangement). The output grid is generated by tiling this detected pattern
across the entire grid, repeating the pattern horizontally and vertically to
fill the grid dimensions exactly. The tiling process ensures that the output
grid matches the input grid's dimensions, with each tile being an exact copy of
the symmetric pattern. The solver must first identify the bounding box of the
non-zero region, verify its rotational symmetry, and then replicate the pattern
to construct the output grid. This requires recognizing symmetry properties and
applying a periodic repetition rule to generate the transformed grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    w = random.randint(1, 15)
    h = random.randint(1, 15)
    pattern = [[0] * h for _ in range(w)]
    for i in range((w + 1) // 2):
        for j in range((h + 1) // 2):
            color = random.randint(1, 9)
            pattern[i][j] = color
            pattern[w-1-i][h-1-j] = color
    k = random.randint(1, 30 // h)
    m = random.randint(1, 30 // w)
    while k == 1 and m == 1:
        k = random.randint(1, 30 // h)
        m = random.randint(1, 30 // w)
    W = k * h
    H = m * w
    input_grid = [[0] * W for _ in range(H)]
    for i in range(w):
        for j in range(h):
            input_grid[i][j] = pattern[i][j]
    output_grid = [[0] * W for _ in range(H)]
    for i in range(H):
        for j in range(W):
            output_grid[i][j] = pattern[i % w][j % h]
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random

def p(input_grid):
    rows, cols = [], []
    for i in range(len(input_grid)):
        for j in range(len(input_grid[0])):
            if input_grid[i][j] != 0:
                rows.append(i)
                cols.append(j)
    if not rows:
        return input_grid
    min_row, max_row = min(rows), max(rows)
    min_col, max_col = min(cols), max(cols)
    w = max_row - min_row + 1
    h = max_col - min_col + 1
    pattern = []
    for i in range(min_row, max_row + 1):
        pattern.append(input_grid[i][min_col:max_col + 1])
    output = [[0] * len(input_grid[0]) for _ in range(len(input_grid))]
    for i in range(len(input_grid)):
        for j in range(len(input_grid[0])):
            output[i][j] = pattern[i % w][j % h]
    return output
