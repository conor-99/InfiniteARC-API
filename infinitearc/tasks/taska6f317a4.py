# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: a6f317a4
Difficulty: medium–hard

=== Tags ===
- Color transfer on contact
- Local rule cascade
- Field based motion
- Create image from info

=== Description ===
Chromatic Cascade  Input grids feature a background color (0) with multiple
contiguous regions of distinct foreground colors (1–9), each region separated by
background cells except where adjacent regions of different colors touch. The
transformation follows a deterministic color interaction hierarchy: when a
region of color A is adjacent (horizontally or vertically) to a region of color
B, both regions transform into a new color C based on a fixed color-mixing rule
(e.g., red (2) + blue (1) → green (3)). This transformation occurs
simultaneously across all adjacent pairs in the grid, creating a cascade effect
where newly formed regions may interact with other regions in the same step. The
output grid displays the final configuration after all possible interactions,
with the background unchanged. The rules prioritize interactions based on a
predefined sequence (e.g., primary color interactions resolve before secondary),
ensuring no ambiguous overlaps. Regions formed by interactions remain
contiguous, and the transformation strictly avoids numerical operations, relying
solely on visual color relationships.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    a = random.randint(1, 9)
    b = random.randint(1, 9)
    while b == a:
        b = random.randint(1, 9)
    input_grid = [[0] * width for _ in range(height)]
    mid = width // 2
    for r in range(height):
        for c in range(mid):
            input_grid[r][c] = a
        for c in range(mid, width):
            input_grid[r][c] = b
    mixing_map = {
        (1, 2): 3, (1, 3): 4, (1, 4): 5, (1, 5): 6, (1, 6): 7, (1, 7): 8, (1, 8): 9, (1, 9): 1,
        (2, 3): 4, (2, 4): 5, (2, 5): 6, (2, 6): 7, (2, 7): 8, (2, 8): 9, (2, 9): 2,
        (3, 4): 5, (3, 5): 6, (3, 6): 7, (3, 7): 8, (3, 8): 9, (3, 9): 3,
        (4, 5): 6, (4, 6): 7, (4, 7): 8, (4, 8): 9, (4, 9): 4,
        (5, 6): 7, (5, 7): 8, (5, 8): 9, (5, 9): 5,
        (6, 7): 8, (6, 8): 9, (6, 9): 6,
        (7, 8): 9, (7, 9): 7,
        (8, 9): 8
    }
    c = mixing_map.get((min(a, b), max(a, b)), a)
    output_grid = [[c] * width for _ in range(height)]
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    mixing_map = {
        (1, 2): 3, (1, 3): 4, (1, 4): 5, (1, 5): 6, (1, 6): 7, (1, 7): 8, (1, 8): 9, (1, 9): 1,
        (2, 3): 4, (2, 4): 5, (2, 5): 6, (2, 6): 7, (2, 7): 8, (2, 8): 9, (2, 9): 2,
        (3, 4): 5, (3, 5): 6, (3, 6): 7, (3, 7): 8, (3, 8): 9, (3, 9): 3,
        (4, 5): 6, (4, 6): 7, (4, 7): 8, (4, 8): 9, (4, 9): 4,
        (5, 6): 7, (5, 7): 8, (5, 8): 9, (5, 9): 5,
        (6, 7): 8, (6, 8): 9, (6, 9): 6,
        (7, 8): 9, (7, 9): 7,
        (8, 9): 8
    }
    colors = set()
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                colors.add(grid[r][c])
    if len(colors) <= 1:
        return grid
    colors = sorted(colors)
    a, b = colors[0], colors[1]
    c = mixing_map.get((a, b), a)
    output_grid = [[c] * width for _ in range(height)]
    return output_grid
