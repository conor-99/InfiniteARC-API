# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 6923ed87
Difficulty: medium–hard

=== Tags ===
- Example condition induction
- Remove thin noise

=== Description ===
Input grids feature a primary structure formed by the largest connected
component (by pixel count) alongside smaller, disconnected components. The
output grid preserves the primary structure while removing all smaller
components that form straight horizontal or vertical lines of length 1 or 2.
Components that are diagonal, curved, part of larger structures (length ≥ 3), or
non-linear remain unchanged. The transformation requires identifying the
dominant structure and applying a context-dependent rule: only isolated thin
linear segments are considered "noise" and removed, while all other
configurations—regardless of size—are retained. This task demands multi-step
reasoning to distinguish between functional structural elements and extraneous
linear noise through visual pattern recognition rather than numerical analysis.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import continuous_creature


def generate():
    """Generate an input/output pair for the task.

    The generator builds a grid with a large primary contiguous structure (created
    with continuous_creature) and several small disconnected components. It then
    removes only those small components that are straight horizontal or vertical
    lines of length 1 or 2 (using 8-connectedness to determine components).
    """
    # Keep trying until we produce a valid pair (should succeed quickly)
    for _ in range(1000):
        width = random.randint(10, 20)
        height = random.randint(10, 20)
        grid = [[0 for _ in range(width)] for _ in range(height)]

        # Choose a primary size that is clearly larger than the small bits we'll add
        max_primary = min(60, width * height - 6)
        min_primary = max(8, (width * height) // 10)
        if min_primary > max_primary:
            min_primary = max(3, max_primary // 2)
        primary_size = random.randint(min_primary, max_primary)

        # Create a contiguous primary creature and randomly shift it inside the grid
        prim_pixels = continuous_creature(primary_size, width, height)
        max_r = max(p[0] for p in prim_pixels)
        max_c = max(p[1] for p in prim_pixels)
        row_off = random.randint(0, height - 1 - max_r)
        col_off = random.randint(0, width - 1 - max_c)
        primary_pixels = [(r + row_off, c + col_off) for r, c in prim_pixels]

        primary_color = random.randint(1, 9)
        for r, c in primary_pixels:
            grid[r][c] = primary_color

        occupied = set(primary_pixels)

        # helper: yield 8-neighbors of a cell
        def neigh8(cell):
            rr, cc = cell
            for dr in (-1, 0, 1):
                for dc in (-1, 0, 1):
                    if dr == 0 and dc == 0:
                        continue
                    yield (rr + dr, cc + dc)

        # Choose a mix of small components. Ensure at least one removable (single/h2/v2).
        comp_types = []
        comp_types.append(random.choice(["single", "h2", "v2"]))
        more = random.randint(2, 4)
        choices = ["single", "h2", "v2", "diag2", "L3", "line3"]
        for _ in range(more):
            comp_types.append(random.choice(choices))
        random.shuffle(comp_types)

        placed = []
        # Try to place each small component without touching the primary (8-neighbor) or other components
        for typ in comp_types:
            placed_ok = False
            for _try in range(400):
                if typ == "single":
                    r = random.randint(0, height - 1)
                    c = random.randint(0, width - 1)
                    cells = [(r, c)]
                elif typ == "h2":
                    r = random.randint(0, height - 1)
                    c = random.randint(0, width - 2)
                    cells = [(r, c), (r, c + 1)]
                elif typ == "v2":
                    r = random.randint(0, height - 2)
                    c = random.randint(0, width - 1)
                    cells = [(r, c), (r + 1, c)]
                elif typ == "diag2":
                    r = random.randint(0, height - 2)
                    c = random.randint(0, width - 2)
                    cells = [(r, c), (r + 1, c + 1)]
                elif typ == "L3":
                    r = random.randint(0, height - 2)
                    c = random.randint(0, width - 2)
                    cells = [(r, c), (r + 1, c), (r + 1, c + 1)]
                elif typ == "line3":
                    if random.random() < 0.5:
                        r = random.randint(0, height - 1)
                        c = random.randint(0, width - 3)
                        cells = [(r, c), (r, c + 1), (r, c + 2)]
                    else:
                        r = random.randint(0, height - 3)
                        c = random.randint(0, width - 1)
                        cells = [(r, c), (r + 1, c), (r + 2, c)]
                else:
                    cells = [(0, 0)]

                # Validate cells: in bounds, not already occupied, and not 8-adjacent to occupied
                ok = True
                for (cr, cc) in cells:
                    if not (0 <= cr < height and 0 <= cc < width):
                        ok = False
                        break
                    if (cr, cc) in occupied:
                        ok = False
                        break
                    for nr, nc in neigh8((cr, cc)):
                        if 0 <= nr < height and 0 <= nc < width and (nr, nc) in occupied:
                            ok = False
                            break
                    if not ok:
                        break
                if not ok:
                    continue

                # Place the component with a color different from the primary for clarity
                color = random.randint(1, 9)
                if color == primary_color:
                    color = (color % 9) + 1
                for (cr, cc) in cells:
                    grid[cr][cc] = color
                    occupied.add((cr, cc))
                placed.append((cells, color, typ))
                placed_ok = True
                break
            # done tries for this component

        # Ensure we actually placed at least one removable component
        if not any(typ in ("single", "h2", "v2") for (_, _, typ) in placed):
            continue

        # Find 8-connected components
        def find_components(g):
            h = len(g)
            w = len(g[0])
            visited = [[False] * w for _ in range(h)]
            comps = []
            for rr in range(h):
                for cc in range(w):
                    if g[rr][cc] != 0 and not visited[rr][cc]:
                        stack = [(rr, cc)]
                        visited[rr][cc] = True
                        comp = []
                        while stack:
                            pr, pc = stack.pop()
                            comp.append((pr, pc))
                            for dr in (-1, 0, 1):
                                for dc in (-1, 0, 1):
                                    if dr == 0 and dc == 0:
                                        continue
                                    nr, nc = pr + dr, pc + dc
                                    if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and g[nr][nc] != 0:
                                        visited[nr][nc] = True
                                        stack.append((nr, nc))
                        comps.append(comp)
            return comps

        comps = find_components(grid)
        if not comps:
            continue

        primary_comp = max(comps, key=len)

        # Build the output by removing only small straight horizontal/vertical components (length 1 or 2)
        output = [row[:] for row in grid]
        for comp in comps:
            if comp is primary_comp:
                continue
            L = len(comp)
            if L == 1:
                for (rr, cc) in comp:
                    output[rr][cc] = 0
            elif L == 2:
                (r1, c1) = comp[0]
                (r2, c2) = comp[1]
                if r1 == r2 and abs(c1 - c2) == 1:
                    for (rr, cc) in comp:
                        output[rr][cc] = 0
                elif c1 == c2 and abs(r1 - r2) == 1:
                    for (rr, cc) in comp:
                        output[rr][cc] = 0

        if output != grid:
            return {"input": grid, "output": output}

    # Fallback (very unlikely)
    return {"input": grid, "output": grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    """Solver for the task.

    Finds 8-connected components, identifies the largest (primary) component, and
    removes any other component that is a straight horizontal or vertical line of
    length 1 or 2.
    """
    grid = [list(row) for row in input_grid]
    height = len(grid)
    if height == 0:
        return grid
    width = len(grid[0])

    visited = [[False] * width for _ in range(height)]
    components = []

    # Collect 8-connected components
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and not visited[r][c]:
                stack = [(r, c)]
                visited[r][c] = True
                comp = []
                while stack:
                    pr, pc = stack.pop()
                    comp.append((pr, pc))
                    for dr in (-1, 0, 1):
                        for dc in (-1, 0, 1):
                            if dr == 0 and dc == 0:
                                continue
                            nr, nc = pr + dr, pc + dc
                            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] != 0:
                                visited[nr][nc] = True
                                stack.append((nr, nc))
                components.append(comp)

    if not components:
        return grid

    primary = max(components, key=len)

    output = [row[:] for row in grid]

    # Remove small straight horizontal/vertical components (length 1 or 2) that are not primary
    for comp in components:
        if comp is primary:
            continue
        L = len(comp)
        if L == 1:
            (rr, cc) = comp[0]
            output[rr][cc] = 0
        elif L == 2:
            (r1, c1) = comp[0]
            (r2, c2) = comp[1]
            if (r1 == r2 and abs(c1 - c2) == 1) or (c1 == c2 and abs(r1 - r2) == 1):
                for (rr, cc) in comp:
                    output[rr][cc] = 0

    return output

