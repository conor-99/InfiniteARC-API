# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: a433109e
Difficulty: hard

=== Tags ===
- Non rectangular tiling

=== Description ===
The input grids contain connected regions of various colors (0-9), where each
region is non-rectangular (e.g., irregular shapes, not axis-aligned rectangles).
The output grid replaces each such region with its minimal axis-aligned bounding
box filled with the region's color. For each color present, all connected
components are processed individually: the minimal rectangle enclosing all
pixels of the component is identified, and all pixels within this rectangle are
set to the component's color, overriding any other colors within the bounding
box. This transformation requires identifying connected components, computing
their bounding boxes, and filling the boxes, which is challenging due to the
need to handle multiple colors and overlapping bounding boxes consistently.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import continuous_creature

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = [[0] * width for _ in range(height)]
    
    colors = list(range(1, 10))
    random.shuffle(colors)
    
    for color in colors[:5]:
        size = random.randint(5, 10)
        while True:
            shape = continuous_creature(size, width, height)
            if is_non_rectangular(shape):
                break
        placed = False
        for _ in range(100):
            start_r = random.randint(0, height - 1)
            start_c = random.randint(0, width - 1)
            can_place = True
            for (r, c) in shape:
                nr = start_r + r
                nc = start_c + c
                if nr < 0 or nr >= height or nc < 0 or nc >= width or grid[nr][nc] != 0:
                    can_place = False
                    break
            if can_place:
                for (r, c) in shape:
                    nr = start_r + r
                    nc = start_c + c
                    grid[nr][nc] = color
                placed = True
                break
        if not placed:
            continue
    
    output = [[0] * width for _ in range(height)]
    visited = [[False] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and grid[r][c] != 0:
                color_val = grid[r][c]
                component = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color_val:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                min_r = min(p[0] for p in component)
                max_r = max(p[0] for p in component)
                min_c = min(p[1] for p in component)
                max_c = max(p[1] for p in component)
                for nr in range(min_r, max_r + 1):
                    for nc in range(min_c, max_c + 1):
                        output[nr][nc] = color_val
    return {"input": grid, "output": output}

def is_non_rectangular(component):
    if not component:
        return False
    min_r = min(p[0] for p in component)
    max_r = max(p[0] for p in component)
    min_c = min(p[1] for p in component)
    max_c = max(p[1] for p in component)
    bounding_box_size = (max_r - min_r + 1) * (max_c - min_c + 1)
    return bounding_box_size > len(component)


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output = [[0] * width for _ in range(height)]
    visited = [[False] * width for _ in range(height)]
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and input_grid[r][c] != 0:
                color_val = input_grid[r][c]
                component = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color_val:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                min_r = min(p[0] for p in component)
                max_r = max(p[0] for p in component)
                min_c = min(p[1] for p in component)
                max_c = max(p[1] for p in component)
                for nr in range(min_r, max_r + 1):
                    for nc in range(min_c, max_c + 1):
                        output[nr][nc] = color_val
    return output
