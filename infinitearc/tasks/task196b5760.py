# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 196b5760
Difficulty: hard

=== Tags ===
- Concentric
- Inside out
- Direction guesingcrop

=== Description ===
This task involves transforming input grids composed of concentric square layers
into output grids by reversing the order of these layers. The input grid
features multiple concentric square rings (layers) surrounding the center, where
each layer is uniformly colored. The layers are ordered from the outermost ring
(first layer) to the innermost layer (last layer) in the input. The output grid
reverses this order: the innermost layer of the input becomes the outermost
layer of the output, and vice versa, while maintaining the same color
assignments for each layer position. For example, if the input has an outer
layer of color A, middle layer of color B, and inner center of color C, the
output will have an outer layer of color C, middle layer of color B, and inner
center of color A. The transformation requires identifying the concentric
structure, determining the layer order, and reversing itâ€”challenging the model
to reason about spatial layering and directionality (from outer to inner versus
inner to outer) without relying on pixel-level patterns or memorization. The
task is designed to be hard due to the need to abstract the layering pattern
across varying grid sizes and color sequences while ensuring the reversal is
consistently applied.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    N = random.choice([3, 5, 7, 9, 11, 13, 15, 17, 19])
    k = (N + 1) // 2
    colors = random.sample(range(0, 10), k)
    input_grid = [[0] * N for _ in range(N)]
    for r in range(N):
        for c in range(N):
            m = min(r, c, N-1-r, N-1-c)
            input_grid[r][c] = colors[m]
    output_grid = [[0] * N for _ in range(N)]
    for r in range(N):
        for c in range(N):
            m = min(r, c, N-1-r, N-1-c)
            output_grid[r][c] = colors[k-1 - m]
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    n = len(input_grid)
    k = (n + 1) // 2
    output = [[0] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            m = min(i, j, n-1-i, n-1-j)
            output[i][j] = input_grid[k-1 - m][k-1 - m]
    return output
