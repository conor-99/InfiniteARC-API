# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: ae4eb3af
Difficulty: medium–hard

=== Tags ===
- Spring chain
- Rule switch on context
- Elastic reflection
- Multi exit routes
- Rectangle guessing
- Expand repeating unit

=== Description ===
The input grid features a background color (0) and multiple distinct colored
rectangles (each formed by a contiguous block of a single color, e.g., 1-9),
each surrounded by a one-cell boundary of a unique color (e.g., 4). Adjacent to
each rectangle is a directional indicator (color 5) pointing in one of four
cardinal directions (up, down, left, right). The output grid transforms the
input by expanding each rectangle outward in its designated primary direction,
one cell per step, while maintaining its color. If expansion would overlap
another rectangle (any color except background) or reach a grid boundary, the
expansion direction rotates clockwise (e.g., right → down → left → up → right).
This reflection process continues iteratively until all possible expansion
directions are blocked. The final grid displays all expanded rectangles in their
original colors, with directional indicators preserved and background cells
unchanged. The transformation incorporates "Rule switch on context" (direction
changes triggered by collisions), "Elastic reflection" (direction rotation upon
collision), "Multi exit routes" (multiple expansion paths before stabilization),
"Rectangle guessing" (determining final bounding dimensions through iterative
expansion), and "Expand repeating unit" (systematic enlargement of the base
rectangle pattern).
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Create a random grid with multiple colored rectangles, a one-cell boundary (color 4)
    # around each rectangle and a directional indicator (color 5) placed two cells away
    # in the chosen direction so it is preserved during expansion into the boundary.
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    grid = [[0 for _ in range(width)] for _ in range(height)]

    num_rects = random.randint(2, 3)
    # colors reserved for rectangles (exclude 4 and 5 which are for boundary and indicator)
    available_colors = [c for c in range(1, 10) if c not in (4, 5)]
    random.shuffle(available_colors)
    rect_colors = available_colors[:num_rects]

    placed_rects = []  # will store dicts with rectangle info
    occupied = set()  # cells that are already used (rectangle, ring, indicator)

    attempts = 0
    # We'll try to place rectangles until we have enough or run out of attempts
    while len(placed_rects) < num_rects and attempts < 1000:
        attempts += 1
        w = random.randint(2, 4)
        h = random.randint(2, 4)
        # Choose top-left so there is at least a margin of 2 cells on each side
        # This guarantees space for the one-cell ring and the indicator placed two cells away.
        if height < h + 4 or width < w + 4:
            # grid too small for this size; skip
            continue
        r = random.randint(2, height - h - 3)
        c = random.randint(2, width - w - 3)

        # Check that the placement (including a 2-cell margin) doesn't overlap existing rectangles
        collision = False
        for rr in range(r - 2, r + h + 2):
            for cc in range(c - 2, c + w + 2):
                if (rr, cc) in occupied:
                    collision = True
                    break
            if collision:
                break
        if collision:
            continue

        color = rect_colors[len(placed_rects)]
        # place rectangle
        for rr in range(r, r + h):
            for cc in range(c, c + w):
                grid[rr][cc] = color
                occupied.add((rr, cc))

        # place one-cell ring (color 4) around rectangle (including corners)
        for rr in range(r - 1, r + h + 1):
            for cc in range(c - 1, c + w + 1):
                # only set ring where currently background (do not overwrite other rectangles)
                if 0 <= rr < height and 0 <= cc < width and grid[rr][cc] == 0:
                    grid[rr][cc] = 4
                    occupied.add((rr, cc))

        # choose a direction and place the indicator (color 5) two cells away from the rectangle
        direction = random.choice(['right', 'left', 'up', 'down'])
        if direction == 'right':
            ir = r + h // 2
            ic = c + w + 1
        elif direction == 'left':
            ir = r + h // 2
            ic = c - 2
        elif direction == 'up':
            ir = r - 2
            ic = c + w // 2
        else:  # down
            ir = r + h + 1
            ic = c + w // 2

        # If the chosen indicator cell somehow collides, try small adjustments (prefer nearby free cells)
        if not (0 <= ir < height and 0 <= ic < width) or (ir, ic) in occupied:
            found = False
            for dr in range(-1, 2):
                for dc in range(-1, 2):
                    nri, nci = ir + dr, ic + dc
                    if 0 <= nri < height and 0 <= nci < width and (nri, nci) not in occupied:
                        ir, ic = nri, nci
                        found = True
                        break
                if found:
                    break
            if not found:
                # cannot place indicator; undo this rectangle and try another placement
                for rr in range(r, r + h):
                    for cc in range(c, c + w):
                        grid[rr][cc] = 0
                        occupied.discard((rr, cc))
                for rr in range(r - 1, r + h + 1):
                    for cc in range(c - 1, c + w + 1):
                        if 0 <= rr < height and 0 <= cc < width and (rr, cc) in occupied and grid[rr][cc] == 4:
                            grid[rr][cc] = 0
                            occupied.discard((rr, cc))
                continue

        grid[ir][ic] = 5
        occupied.add((ir, ic))

        placed_rects.append({'r': r, 'c': c, 'h': h, 'w': w, 'color': color, 'dir': direction, 'ir': ir, 'ic': ic})

    # If we failed to place enough rectangles, try again by regenerating (rare)
    if len(placed_rects) < num_rects:
        return generate()

    # Create output by expanding each rectangle in a deterministic order (top-left first)
    output = [row[:] for row in grid]

    def expand_rectangle(min_r, max_r, min_c, max_c, color):
        # Expand according to rules: permitted to overwrite background (0) and ring (4),
        # but not indicators (5) or other rectangles (colors != 0 and != 4 and != 5).
        # Start in the current_dir already determined outside.
        return None

    # Sort rectangles by their top-left corner to have deterministic order
    placed_rects_sorted = sorted(placed_rects, key=lambda x: (x['r'], x['c']))

    # Build a quick helper to check expansion viability and to perform expansion
    def can_fill_cell(val):
        # allowed to write over background or ring color only
        return val == 0 or val == 4

    directions_clockwise = ['right', 'down', 'left', 'up']

    for rect in placed_rects_sorted:
        # determine current bounding box in the (possibly already expanded) output grid
        # We look for cells equal to the rectangle color (connected component may have changed if earlier rects expanded nearby),
        # so recompute bounding box for this color's connected component that contains the original top-left.
        color = rect['color']
        # find all cells of this color and take bounding box of the connected component that contains the original anchor
        # We'll do a flood fill starting at any original rectangle cell to get the current component.
        start_r, start_c = rect['r'], rect['c']
        if output[start_r][start_c] != color:
            # try to find any cell of that color (shouldn't happen but be robust)
            found = False
            for rr in range(height):
                for cc in range(width):
                    if output[rr][cc] == color:
                        start_r, start_c = rr, cc
                        found = True
                        break
                if found:
                    break
            if not found:
                continue

        # flood-fill component
        stack = [(start_r, start_c)]
        seen = set([(start_r, start_c)])
        comp_cells = []
        while stack:
            cr, cc = stack.pop()
            comp_cells.append((cr, cc))
            for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):
                nr, nc = cr + dr, cc + dc
                if 0 <= nr < height and 0 <= nc < width and (nr,nc) not in seen and output[nr][nc] == color:
                    seen.add((nr,nc))
                    stack.append((nr,nc))
        min_r = min(r for r,c in comp_cells)
        max_r = max(r for r,c in comp_cells)
        min_c = min(c for r,c in comp_cells)
        max_c = max(c for r,c in comp_cells)

        # locate the indicator (color 5) near this bounding box (search a 2-cell margin)
        indicator = None
        for rr in range(min_r - 2, max_r + 3):
            for cc in range(min_c - 2, max_c + 3):
                if 0 <= rr < height and 0 <= cc < width and grid[rr][cc] == 5:
                    indicator = (rr, cc)
                    break
            if indicator:
                break
        if not indicator:
            # no indicator found; skip expansion for this rectangle
            continue

        # deduce initial direction from indicator position
        ir, ic = indicator
        if ir < min_r:
            current_dir = 'up'
        elif ir > max_r:
            current_dir = 'down'
        elif ic < min_c:
            current_dir = 'left'
        else:
            current_dir = 'right'

        # perform iterative expansion until blocked in all 4 directions
        blocked_in_a_row = 0
        # safety cap to avoid infinite loop
        safety = 0
        while blocked_in_a_row < 4 and safety < 1000:
            safety += 1
            if current_dir == 'right':
                target_c = max_c + 1
                # check bounds
                if target_c >= width:
                    # rotate clockwise
                    idx = directions_clockwise.index(current_dir)
                    current_dir = directions_clockwise[(idx + 1) % 4]
                    blocked_in_a_row += 1
                    continue
                # check all rows in the vertical span
                can_expand = True
                for rr in range(min_r, max_r + 1):
                    val = output[rr][target_c]
                    if val == 5 or (val != 0 and val != 4):
                        can_expand = False
                        break
                if can_expand:
                    # write the new column
                    for rr in range(min_r, max_r + 1):
                        output[rr][target_c] = color
                    max_c = target_c
                    blocked_in_a_row = 0
                    # keep same direction
                    continue
                else:
                    # rotate
                    idx = directions_clockwise.index(current_dir)
                    current_dir = directions_clockwise[(idx + 1) % 4]
                    blocked_in_a_row += 1
            elif current_dir == 'down':
                target_r = max_r + 1
                if target_r >= height:
                    idx = directions_clockwise.index(current_dir)
                    current_dir = directions_clockwise[(idx + 1) % 4]
                    blocked_in_a_row += 1
                    continue
                can_expand = True
                for cc in range(min_c, max_c + 1):
                    val = output[target_r][cc]
                    if val == 5 or (val != 0 and val != 4):
                        can_expand = False
                        break
                if can_expand:
                    for cc in range(min_c, max_c + 1):
                        output[target_r][cc] = color
                    max_r = target_r
                    blocked_in_a_row = 0
                    continue
                else:
                    idx = directions_clockwise.index(current_dir)
                    current_dir = directions_clockwise[(idx + 1) % 4]
                    blocked_in_a_row += 1
            elif current_dir == 'left':
                target_c = min_c - 1
                if target_c < 0:
                    idx = directions_clockwise.index(current_dir)
                    current_dir = directions_clockwise[(idx + 1) % 4]
                    blocked_in_a_row += 1
                    continue
                can_expand = True
                for rr in range(min_r, max_r + 1):
                    val = output[rr][target_c]
                    if val == 5 or (val != 0 and val != 4):
                        can_expand = False
                        break
                if can_expand:
                    for rr in range(min_r, max_r + 1):
                        output[rr][target_c] = color
                    min_c = target_c
                    blocked_in_a_row = 0
                    continue
                else:
                    idx = directions_clockwise.index(current_dir)
                    current_dir = directions_clockwise[(idx + 1) % 4]
                    blocked_in_a_row += 1
            else:  # up
                target_r = min_r - 1
                if target_r < 0:
                    idx = directions_clockwise.index(current_dir)
                    current_dir = directions_clockwise[(idx + 1) % 4]
                    blocked_in_a_row += 1
                    continue
                can_expand = True
                for cc in range(min_c, max_c + 1):
                    val = output[target_r][cc]
                    if val == 5 or (val != 0 and val != 4):
                        can_expand = False
                        break
                if can_expand:
                    for cc in range(min_c, max_c + 1):
                        output[target_r][cc] = color
                    min_r = target_r
                    blocked_in_a_row = 0
                    continue
                else:
                    idx = directions_clockwise.index(current_dir)
                    current_dir = directions_clockwise[(idx + 1) % 4]
                    blocked_in_a_row += 1

        # after finishing expansion for this rectangle, leave indicators (5) intact

    # Ensure output is different from input (at least one expansion happened). If not, retry.
    if output == grid:
        # Very rare; regenerate to ensure a nontrivial task
        return generate()

    return {'input': grid, 'output': output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable grid
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    output = [row[:] for row in grid]

    # Find connected rectangles (colors that are not 0,4,5)
    visited = [[False] * width for _ in range(height)]
    rects = []
    for r in range(height):
        for c in range(width):
            val = grid[r][c]
            if val != 0 and val != 4 and val != 5 and not visited[r][c]:
                color = val
                # flood fill to get the connected component
                stack = [(r, c)]
                visited[r][c] = True
                comp = []
                while stack:
                    cr, cc = stack.pop()
                    comp.append((cr, cc))
                    for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                min_r = min(p[0] for p in comp)
                max_r = max(p[0] for p in comp)
                min_c = min(p[1] for p in comp)
                max_c = max(p[1] for p in comp)
                rects.append({'min_r': min_r, 'max_r': max_r, 'min_c': min_c, 'max_c': max_c, 'color': color})

    # sort deterministic order (top-left first)
    rects = sorted(rects, key=lambda x: (x['min_r'], x['min_c']))

    directions_clockwise = ['right', 'down', 'left', 'up']

    for rect in rects:
        min_r = rect['min_r']
        max_r = rect['max_r']
        min_c = rect['min_c']
        max_c = rect['max_c']
        color = rect['color']

        # find indicator (5) near the rectangle (within a 2-cell margin)
        indicator = None
        for rr in range(min_r - 2, max_r + 3):
            for cc in range(min_c - 2, max_c + 3):
                if 0 <= rr < height and 0 <= cc < width and grid[rr][cc] == 5:
                    indicator = (rr, cc)
                    break
            if indicator:
                break
        if not indicator:
            continue

        ir, ic = indicator
        if ir < min_r:
            current_dir = 'up'
        elif ir > max_r:
            current_dir = 'down'
        elif ic < min_c:
            current_dir = 'left'
        else:
            current_dir = 'right'

        # expand iteratively; we are allowed to overwrite 0 and 4 but not 5 or other rectangle colors
        blocked_in_a_row = 0
        safety = 0
        while blocked_in_a_row < 4 and safety < 1000:
            safety += 1
            if current_dir == 'right':
                target_c = max_c + 1
                if target_c >= width:
                    idx = directions_clockwise.index(current_dir)
                    current_dir = directions_clockwise[(idx + 1) % 4]
                    blocked_in_a_row += 1
                    continue
                can_expand = True
                for rr in range(min_r, max_r + 1):
                    val = output[rr][target_c]
                    # cannot overwrite indicators nor other rectangles
                    if val == 5 or (val != 0 and val != 4):
                        can_expand = False
                        break
                if can_expand:
                    for rr in range(min_r, max_r + 1):
                        output[rr][target_c] = color
                    max_c = target_c
                    blocked_in_a_row = 0
                    continue
                else:
                    idx = directions_clockwise.index(current_dir)
                    current_dir = directions_clockwise[(idx + 1) % 4]
                    blocked_in_a_row += 1
            elif current_dir == 'down':
                target_r = max_r + 1
                if target_r >= height:
                    idx = directions_clockwise.index(current_dir)
                    current_dir = directions_clockwise[(idx + 1) % 4]
                    blocked_in_a_row += 1
                    continue
                can_expand = True
                for cc in range(min_c, max_c + 1):
                    val = output[target_r][cc]
                    if val == 5 or (val != 0 and val != 4):
                        can_expand = False
                        break
                if can_expand:
                    for cc in range(min_c, max_c + 1):
                        output[target_r][cc] = color
                    max_r = target_r
                    blocked_in_a_row = 0
                    continue
                else:
                    idx = directions_clockwise.index(current_dir)
                    current_dir = directions_clockwise[(idx + 1) % 4]
                    blocked_in_a_row += 1
            elif current_dir == 'left':
                target_c = min_c - 1
                if target_c < 0:
                    idx = directions_clockwise.index(current_dir)
                    current_dir = directions_clockwise[(idx + 1) % 4]
                    blocked_in_a_row += 1
                    continue
                can_expand = True
                for rr in range(min_r, max_r + 1):
                    val = output[rr][target_c]
                    if val == 5 or (val != 0 and val != 4):
                        can_expand = False
                        break
                if can_expand:
                    for rr in range(min_r, max_r + 1):
                        output[rr][target_c] = color
                    min_c = target_c
                    blocked_in_a_row = 0
                    continue
                else:
                    idx = directions_clockwise.index(current_dir)
                    current_dir = directions_clockwise[(idx + 1) % 4]
                    blocked_in_a_row += 1
            else:  # up
                target_r = min_r - 1
                if target_r < 0:
                    idx = directions_clockwise.index(current_dir)
                    current_dir = directions_clockwise[(idx + 1) % 4]
                    blocked_in_a_row += 1
                    continue
                can_expand = True
                for cc in range(min_c, max_c + 1):
                    val = output[target_r][cc]
                    if val == 5 or (val != 0 and val != 4):
                        can_expand = False
                        break
                if can_expand:
                    for cc in range(min_c, max_c + 1):
                        output[target_r][cc] = color
                    min_r = target_r
                    blocked_in_a_row = 0
                    continue
                else:
                    idx = directions_clockwise.index(current_dir)
                    current_dir = directions_clockwise[(idx + 1) % 4]
                    blocked_in_a_row += 1

    return output

