# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: cc81d7d4
Difficulty: insane

=== Tags ===
- Self referential pattern

=== Description ===
The task involves input grids containing multiple connected color regions, with
one dominant region significantly larger than others. The output grid is derived
by transforming the input based on the dominant region's aspect ratio.
Specifically, if the dominant region spans more columns than rows (wider than
tall), the input grid is mirrored horizontally; if it spans more rows than
columns (taller than wide), the grid is mirrored vertically; if the dominant
region is square (equal width and height), the grid is rotated 90 degrees
clockwise. The transformation applies to the entire grid, preserving all colors
and regional structures. This rule is visually detectable through comparison of
the dominant region's shape relative to the grid, without requiring numerical
computation or color value manipulation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import continuous_creature, random_color
def generate():
    max_retries = 10
    for _ in range(max_retries):
        width = random.randint(3, 30)
        height = random.randint(3, 30)
        total = width * height
        dominant_size = max(3, int(0.6 * total))
        pixels = continuous_creature(dominant_size, width, height)
        grid_input = [[0] * width for _ in range(height)]
        for (r, c) in pixels:
            grid_input[r][c] = 1
        for r in range(height):
            for c in range(width):
                if grid_input[r][c] == 0:
                    grid_input[r][c] = random_color(exclude=[1])
        min_r, max_r = height, 0
        min_c, max_c = width, 0
        for r in range(height):
            for c in range(width):
                if grid_input[r][c] == 1:
                    min_r = min(min_r, r)
                    max_r = max(max_r, r)
                    min_c = min(min_c, c)
                    max_c = max(max_c, c)
        width_dom = max_c - min_c + 1
        height_dom = max_r - min_r + 1
        if width_dom > height_dom:
            grid_output = [row[::-1] for row in grid_input]
        elif height_dom > width_dom:
            grid_output = grid_input[::-1]
        else:
            grid_output = [list(x)[::-1] for x in zip(*grid_input)]
        if all(grid_input[i][j] == grid_output[i][j] for i in range(height) for j in range(width)):
            continue
        return {"input": grid_input, "output": grid_output}
    return {"input": grid_input, "output": grid_output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    visited = [[False] * width for _ in range(height)]
    largest_component = []
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and input_grid[r][c] != 0:
                color = input_grid[r][c]
                queue = [(r, c)]
                visited[r][c] = True
                component = []
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                if len(component) > len(largest_component):
                    largest_component = component
    if not largest_component:
        return input_grid
    min_r = min(r for r, c in largest_component)
    max_r = max(r for r, c in largest_component)
    min_c = min(c for r, c in largest_component)
    max_c = max(c for r, c in largest_component)
    width_dom = max_c - min_c + 1
    height_dom = max_r - min_r + 1
    if width_dom > height_dom:
        return [row[::-1] for row in input_grid]
    elif height_dom > width_dom:
        return input_grid[::-1]
    else:
        return [list(x)[::-1] for x in zip(*input_grid)]
