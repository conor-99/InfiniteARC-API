# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 14583e23
Difficulty: hard

=== Tags ===
- Field interference pattern
- Draw rectangle
- Take complement

=== Description ===
Input grids consist of multiple axis-aligned rectangles, each filled with a
distinct color from 1 to 8, arranged on a background of color 0. The "field
interference pattern" refers to the spatial arrangement of these rectangles,
where their positions and relative placements form a structured visual pattern.
The output grid is generated through two sequential operations: first, taking
the complement of all non-background colors (replacing color c with 9 - c), and
second, drawing a rectangle border around the minimal bounding box that encloses
all non-background cells. The bounding box is defined as the smallest rectangle
that contains every cell with a non-zero color, and its border (the perimeter of
this box) is drawn using color 9, overriding any existing colors within the
border. This requires recognizing the spatial structure of the input's
interference pattern, applying a deterministic color transformation, and
performing geometric reasoning to identify and outline the bounding box.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = common.randint(5, 30)
    height = common.randint(5, 30)
    grid = [[0] * width for _ in range(height)]
    num_rects = common.randint(2, 5)
    colors = common.random_colors(num_rects, exclude=[0])
    rectangles = []
    for color in colors:
        placed = False
        for _ in range(100):
            r1 = common.randint(0, height-2)
            c1 = common.randint(0, width-2)
            r2 = common.randint(r1+1, height-1)
            c2 = common.randint(c1+1, width-1)
            overlap = False
            for (r1_old, c1_old, r2_old, c2_old, _) in rectangles:
                if max(r1, r1_old) < min(r2, r2_old) and max(c1, c1_old) < min(c2, c2_old):
                    overlap = True
                    break
            if not overlap:
                for r in range(r1, r2):
                    for c in range(c1, c2):
                        grid[r][c] = color
                rectangles.append((r1, c1, r2, c2, color))
                placed = True
                break
        if not placed:
            # Fallback: place a minimal rectangle
            r1, c1 = 0, 0
            r2, c2 = 2, 2
            for r in range(r1, r2):
                for c in range(c1, c2):
                    grid[r][c] = color
            rectangles.append((r1, c1, r2, c2, color))
    
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                output_grid[r][c] = 9 - grid[r][c]
    
    non_zero = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                non_zero.append((r, c))
    min_row = min(r for r, c in non_zero)
    max_row = max(r for r, c in non_zero)
    min_col = min(c for r, c in non_zero)
    max_col = max(c for r, c in non_zero)
    
    for r in range(min_row, max_row + 1):
        for c in range(min_col, max_col + 1):
            if r == min_row or r == max_row or c == min_col or c == max_col:
                output_grid[r][c] = 9
    
    return {
        "input": grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    height = len(input_list)
    width = len(input_list[0])
    non_zero = []
    for r in range(height):
        for c in range(width):
            if input_list[r][c] != 0:
                non_zero.append((r, c))
    if not non_zero:
        return input_list
    min_row = min(r for r, c in non_zero)
    max_row = max(r for r, c in non_zero)
    min_col = min(c for r, c in non_zero)
    max_col = max(c for r, c in non_zero)
    
    output = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_list[r][c] != 0:
                output[r][c] = 9 - input_list[r][c]
    
    for r in range(min_row, max_row + 1):
        for c in range(min_col, max_col + 1):
            if r == min_row or r == max_row or c == min_col or c == max_col:
                output[r][c] = 9
    
    return output
