# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 5e4797e3
Difficulty: hard

=== Tags ===
- Detect enclosure
- Relay chain
- Diagonal weaving
- Spacing

=== Description ===
Input grids feature a background color with two orthogonal sets of diagonal
lines (e.g., top-left to bottom-right and top-right to bottom-left) forming a
consistent weaving pattern. The lines create diamond-shaped enclosures at their
intersections, with consistent spacing between consecutive lines (e.g., exactly
two background cells between adjacent diagonals). Each enclosure contains a
distinct non-background color at its center, forming a relay chain that follows
a diagonal path from top-left to bottom-right. The relay chain sequence is
determined by the order of enclosures along this path, where each subsequent
enclosure's color follows a predefined cyclic pattern (e.g., red → green → blue
→ yellow → red...).   The output grid must extend this relay chain by adding new
enclosures along the diagonal path while maintaining the original spacing. Each
new enclosure is formed by adding diagonal lines at the next consistent
interval, and its central color continues the relay chain sequence. Existing
enclosures and their colors remain unchanged. The transformation requires
detecting valid enclosures (not false positives formed by non-intersecting
diagonals), identifying the correct diagonal path for the relay chain, and
precisely extending the weaving pattern without altering background or existing
diagonal lines. The spacing consistency is critical, as deviations would disrupt
the enclosure structure and chain sequence.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    n = random.randint(3, 5)
    min_size = 3 * (n + 1) + 1
    width = random.randint(max(min_size, 10), 30)
    height = random.randint(max(min_size, 10), 30)
    line_color = 1
    relay_colors = [2, 3, 4, 5]
    input_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if (c - r) % 3 == 0 or (r + c) % 3 == 0:
                input_grid[r][c] = line_color
    for i in range(1, n + 1):
        r, c = 3 * i, 3 * i
        input_grid[r][c] = relay_colors[(i - 1) % len(relay_colors)]
    output_grid = [row[:] for row in input_grid]
    next_r, next_c = 3 * (n + 1), 3 * (n + 1)
    output_grid[next_r][next_c] = relay_colors[n % len(relay_colors)]
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    relay_colors = [2, 3, 4, 5]
    centers = []
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            if grid[r][c] in relay_colors:
                centers.append((r, c))
    if not centers:
        return grid
    centers.sort()
    last_r, last_c = centers[-1]
    next_r, next_c = last_r + 3, last_c + 3
    last_color = grid[last_r][last_c]
    idx = relay_colors.index(last_color)
    next_color = relay_colors[(idx + 1) % len(relay_colors)]
    grid[next_r][next_c] = next_color
    return grid
