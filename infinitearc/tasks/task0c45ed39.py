# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 0c45ed39
Difficulty: insane

=== Tags ===
- Measure length
- Associate colors to ranks
- Remove noise

=== Description ===
The task requires identifying the largest connected component (measured by cell
count) in the input grid, where connectivity is defined by 4-directional
adjacency (up/down/left/right) for non-zero colors. Each connected component
consists of contiguous cells of the same non-zero color. The largest component
is determined by its size, and all other components (smaller structures) are
considered "noise" and removed. The output grid retains only the cells of the
largest component in their original colors, with all other cells set to 0. This
process involves measuring the length (size) of each component, associating the
component's color with its rank (1 for the largest, 2 for the next, etc.), and
removing all components except the top-ranked one (rank 1), which constitutes
the signal to preserve. The transformation ensures the output grid differs from
the input by eliminating all smaller, disconnected regions while preserving the
dominant structural element.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, continuous_creature
def generate():
    width = random.randint(5, 10)
    height = random.randint(5, 10)
    input_grid = grid(width, height, 0)
    output_grid = grid(width, height, 0)

    main_size = random.randint(10, 15)
    main_pixels = continuous_creature(main_size, width, height)
    main_color = 1
    for (r, c) in main_pixels:
        input_grid[r][c] = main_color
        output_grid[r][c] = main_color

    noise_colors = [2, 3, 4, 5]
    for _ in range(random.randint(5, 10)):
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        if input_grid[r][c] == 0:
            input_grid[r][c] = random.choice(noise_colors)

    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid
def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    visited = [[False] * width for _ in range(height)]
    largest_size = 0
    largest_component = []

    for r in range(height):
        for c in range(width):
            if not visited[r][c] and input_grid[r][c] > 0:
                color = input_grid[r][c]
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                if len(component) > largest_size:
                    largest_size = len(component)
                    largest_component = component

    output_grid = grid(width, height, 0)
    for (r, c) in largest_component:
        output_grid[r][c] = input_grid[r][c]
    return output_grid
