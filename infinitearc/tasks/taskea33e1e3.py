# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: ea33e1e3
Difficulty: hard

=== Tags ===
- Image within image

=== Description ===
The task involves transforming an input grid by identifying and rotating the
largest connected component of a single non-zero color (the "inner image")
within a background of color 0. The transformation requires multiple steps:
first, detecting the connected component (ensuring it is contiguous and
surrounded by background), then determining its bounding box, and finally
rotating the component 90 degrees clockwise within that bounding box. The output
grid consists solely of the rotated component, cropped to the bounding box
dimensions. This process demands visual pattern recognition, spatial reasoning,
and precise coordinate transformation, making it challenging due to the need to
isolate the inner image from potential noise and correctly apply the rotation
without relying on numerical properties.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = random.randint(8, 20)
    height = random.randint(8, 20)
    input_grid = common.grid(width, height, 0)
    
    main_color = common.random_color(exclude=[0])
    main_size = random.randint(15, 25)
    main_pixels = common.continuous_creature(main_size, width, height)
    for r, c in main_pixels:
        input_grid[r][c] = main_color
    
    for _ in range(2):
        color = common.random_color(exclude=[0, main_color])
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        if input_grid[r][c] == 0:
            input_grid[r][c] = color
    
    non_zero = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                non_zero.append((r, c))
    
    visited = set()
    components = []
    for pos in non_zero:
        if pos not in visited:
            comp = []
            queue = [pos]
            visited.add(pos)
            while queue:
                r, c = queue.pop(0)
                comp.append((r, c))
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r+dr, c+dc
                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0 and (nr, nc) not in visited:
                        visited.add((nr, nc))
                        queue.append((nr, nc))
            components.append(comp)
    
    largest_component = max(components, key=len)
    rows = [p[0] for p in largest_component]
    cols = [p[1] for p in largest_component]
    min_row, max_row = min(rows), max(rows)
    min_col, max_col = min(cols), max(cols)
    
    subgrid = []
    for r in range(min_row, max_row+1):
        subgrid.append(input_grid[r][min_col:max_col+1])
    
    rotated = [list(x)[::-1] for x in zip(*subgrid)]
    
    return {
        "input": input_grid,
        "output": rotated
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    
    non_zero = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                non_zero.append((r, c))
    
    visited = set()
    components = []
    for pos in non_zero:
        if pos not in visited:
            comp = []
            queue = [pos]
            visited.add(pos)
            while queue:
                r, c = queue.pop(0)
                comp.append((r, c))
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r+dr, c+dc
                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0 and (nr, nc) not in visited:
                        visited.add((nr, nc))
                        queue.append((nr, nc))
            components.append(comp)
    
    largest_component = max(components, key=len)
    rows = [p[0] for p in largest_component]
    cols = [p[1] for p in largest_component]
    min_row, max_row = min(rows), max(rows)
    min_col, max_col = min(cols), max(cols)
    
    subgrid = []
    for r in range(min_row, max_row+1):
        subgrid.append(input_grid[r][min_col:max_col+1])
    
    rotated = [list(x)[::-1] for x in zip(*subgrid)]
    
    return rotated
