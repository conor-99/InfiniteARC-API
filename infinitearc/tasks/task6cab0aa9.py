# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 6cab0aa9
Difficulty: very hard

=== Tags ===
- Pattern modification
- Cut and unfold
- Stepwise color transition
- Wraparound copy

=== Description ===
**Task Name**: Spiral Unfolding with Color Cascade    **Description**:    Input
grids feature a central spiral pattern composed of concentric rings, each ring
colored with a unique hue from a fixed cyclic sequence (e.g., red → green → blue
→ yellow → red). The spiral is embedded within a uniform background color, with
a distinct "cut line" (marked by a fixed color, e.g., gray) running diagonally
from the top-left to bottom-right corner, dividing the grid into two triangular
regions. Additionally, a "transition marker" (a single cell of a unique color)
is placed in the bottom-left corner, indicating the starting point of the color
sequence.    The transformation process follows four sequential, deterministic
steps:    1. **Cut and Unfold**: The grid is cut along the gray cut line. The
triangular region above the cut is reflected across the line to align with the
region below, effectively "unfolding" the grid into a rectangle. This reflection
reverses the order of rows or columns depending on the cut orientation,
eliminating the diagonal division.    2. **Pattern Modification**: Each
concentric ring of the spiral undergoes a color shift in the cyclic sequence.
For example, if the sequence is [red, green, blue], a ring originally red
becomes green, green becomes blue, and blue wraps to red. The background and cut
line are unaffected.    3. **Stepwise Color Transition**: The color transition
propagates outward from the center of the spiral. Each cell in the spiral
updates to the next color in the sequence, with the transition applied
incrementally across rings. This creates a smooth gradient where colors change
progressively as you move away from the center.    4. **Wraparound Copy**: The
modified spiral pattern is copied to the grid’s opposite side (e.g., right side
for a left-aligned pattern) with wraparound behavior. If the copy exceeds grid
boundaries, it wraps to the opposite edge (e.g., copying a row from column 0 to
3 in a 5-column grid results in columns 0–3 being copied to columns 2–5, with
column 5 wrapping to column 0). The copy preserves the stepwise transition and
color shifts but does not overwrite the background or transition marker.    The
output grid must reflect all transformations: the cut line is removed, the
spiral’s colors are shifted and transitioned, and the pattern is copied with
wraparound. The background remains unchanged, and all rules are applied
consistently without memorization. The complexity arises from the interplay of
geometric unfolding, cyclic color shifts, and non-trivial wraparound copying,
requiring multi-step reasoning to disentangle the sequence.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

CALL = 0

def generate():
    global CALL
    call = CALL
    CALL += 1

    # Choose odd sizes between 13 and 29 (inclusive) to ensure enough rings
    size_options = [13, 15, 17, 19, 21, 23, 25, 27, 29]
    num_sizes = len(size_options)
    size_idx = call % num_sizes
    n = size_options[size_idx]

    # Number of rings
    rings = (n + 1) // 2

    # Choose cycle length from 3..6 but ensure it's strictly less than number of rings
    L_choices = [3, 4, 5, 6]
    L = L_choices[(call // num_sizes) % len(L_choices)]
    if L >= rings:
        L = max(2, rings - 1)

    # Create a deterministic rotation offset so each call yields a different cycle/order
    base_colors = [2, 3, 4, 7, 8, 9]  # avoid 0 (background), 5 (cut), 6 (marker)
    offset = (call // (num_sizes * len(L_choices))) % len(base_colors)
    cycle = [base_colors[(offset + i) % len(base_colors)] for i in range(L)]

    # Build input grid: concentric square rings colored according to cycle
    grid_input = [[0 for _ in range(n)] for _ in range(n)]
    for k in range(rings):
        color = cycle[k % len(cycle)]
        top, left = k, k
        bottom, right = n - 1 - k, n - 1 - k
        if top == bottom:
            grid_input[top][left] = color
        else:
            for c in range(left, right + 1):
                grid_input[top][c] = color
            for r in range(top + 1, bottom + 1):
                grid_input[r][right] = color
            for c in range(right - 1, left - 1, -1):
                grid_input[bottom][c] = color
            for r in range(bottom - 1, top, -1):
                grid_input[r][left] = color

    # Cut line along the main diagonal (top-left to bottom-right)
    CUT = 5
    for i in range(n):
        grid_input[i][i] = CUT

    # Transition marker in the bottom-left corner
    MARKER = 6
    grid_input[n - 1][0] = MARKER

    # Create the output by applying the four transformations described
    grid_output = [row[:] for row in grid_input]

    # 1) Cut and unfold: reflect upper triangle across the diagonal (transpose)
    for i in range(n):
        for j in range(i + 1, n):
            grid_output[i][j], grid_output[j][i] = grid_output[j][i], grid_output[i][j]

    # Remove the cut line
    for i in range(n):
        grid_output[i][i] = 0

    # 2 & 3) Pattern modification + stepwise outward color transition
    for k in range(rings):
        current_color = cycle[k % len(cycle)]
        new_color = cycle[(k + 1) % len(cycle)]
        top, left = k, k
        bottom, right = n - 1 - k, n - 1 - k
        if top == bottom:
            if grid_output[top][left] == current_color:
                grid_output[top][left] = new_color
        else:
            for c in range(left, right + 1):
                if grid_output[top][c] == current_color:
                    grid_output[top][c] = new_color
            for r in range(top + 1, bottom + 1):
                if grid_output[r][right] == current_color:
                    grid_output[r][right] = new_color
            for c in range(right - 1, left - 1, -1):
                if grid_output[bottom][c] == current_color:
                    grid_output[bottom][c] = new_color
            for r in range(bottom - 1, top, -1):
                if grid_output[r][left] == current_color:
                    grid_output[r][left] = new_color

    # 4) Wraparound copy to the opposite side (horizontal shift by offset)
    offset_cols = n // 2
    for i in range(n):
        for j in range(n):
            val = grid_output[i][j]
            if val != 0 and val != MARKER:
                new_j = (j + offset_cols) % n
                if grid_output[i][new_j] == 0:
                    grid_output[i][new_j] = val

    # Ensure marker preserved
    grid_output[n - 1][0] = MARKER

    return {"input": grid_input, "output": grid_output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid_in = [list(row) for row in input_grid]
    n = len(grid_in)
    rings = (n + 1) // 2

    # Helper to collect a representative color for a ring (ignoring background, cut, marker)
    EXCLUDE = {0, 5, 6}
    ring_colors = []
    for k in range(rings):
        top, left = k, k
        bottom, right = n - 1 - k, n - 1 - k
        found = None
        if top == bottom:
            v = grid_in[top][left]
            if v not in EXCLUDE:
                found = v
        else:
            # check top row
            for c in range(left, right + 1):
                v = grid_in[top][c]
                if v not in EXCLUDE:
                    found = v
                    break
            # right col
            if found is None:
                for r in range(top + 1, bottom + 1):
                    v = grid_in[r][right]
                    if v not in EXCLUDE:
                        found = v
                        break
            # bottom row
            if found is None:
                for c in range(right - 1, left - 1, -1):
                    v = grid_in[bottom][c]
                    if v not in EXCLUDE:
                        found = v
                        break
            # left col
            if found is None:
                for r in range(bottom - 1, top, -1):
                    v = grid_in[r][left]
                    if v not in EXCLUDE:
                        found = v
                        break
        ring_colors.append(found)

    # Recover the cycle length by finding the minimal period consistent with observed colors
    max_L = min(6, rings - 1) if rings > 1 else 1
    cycle_len = None
    for L in range(1, max_L + 1):
        ok = True
        for i in range(rings):
            for j in range(i + 1, rings):
                if i % L == j % L:
                    a = ring_colors[i]
                    b = ring_colors[j]
                    if a is not None and b is not None and a != b:
                        ok = False
                        break
            if not ok:
                break
        if ok:
            cycle_len = L
            break
    if cycle_len is None:
        cycle_len = max_L if max_L >= 1 else 1

    # Build the cycle by taking the first available color in each residue class
    cycle = []
    for p in range(cycle_len):
        cval = None
        for i in range(p, rings, cycle_len):
            if ring_colors[i] is not None:
                cval = ring_colors[i]
                break
        if cval is None:
            # fallback (shouldn't happen with the generator guarantees)
            cval = 2
        cycle.append(cval)

    # Apply the four transformation steps to reproduce the generator's output
    grid = [row[:] for row in grid_in]

    # 1) Cut and unfold: transpose by swapping upper/lower triangles
    for i in range(n):
        for j in range(i + 1, n):
            grid[i][j], grid[j][i] = grid[j][i], grid[i][j]

    # Remove cut line
    for i in range(n):
        grid[i][i] = 0

    # 2 & 3) Shift colors ring-by-ring outward
    for k in range(rings):
        cur = cycle[k % len(cycle)]
        nxt = cycle[(k + 1) % len(cycle)]
        top, left = k, k
        bottom, right = n - 1 - k, n - 1 - k
        if top == bottom:
            if grid[top][left] == cur:
                grid[top][left] = nxt
        else:
            for c in range(left, right + 1):
                if grid[top][c] == cur:
                    grid[top][c] = nxt
            for r in range(top + 1, bottom + 1):
                if grid[r][right] == cur:
                    grid[r][right] = nxt
            for c in range(right - 1, left - 1, -1):
                if grid[bottom][c] == cur:
                    grid[bottom][c] = nxt
            for r in range(bottom - 1, top, -1):
                if grid[r][left] == cur:
                    grid[r][left] = nxt

    # 4) Wraparound copy (horizontal shift by n//2) without overwriting marker/background
    MARKER = 6
    offset = n // 2
    for i in range(n):
        for j in range(n):
            val = grid[i][j]
            if val != 0 and val != MARKER:
                new_j = (j + offset) % n
                if grid[i][new_j] == 0:
                    grid[i][new_j] = val

    # Ensure marker preserved
    grid[n - 1][0] = MARKER

    return grid
