# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 6a394060
Difficulty: very hard

=== Tags ===
- Grid overlay blending
- Agent memory trace
- Non overwriting draw

=== Description ===
Input grids feature a large canvas (20Ã—20 or larger) with a uniform background
color. Overlaid on this background are multiple disconnected colored objects
(each a contiguous region of a single color between 1 and 9), all surrounded by
the background. A designated start cell (located at the top-left corner of the
grid, adjacent to the grid edge and containing the background color) marks the
agent's initial position.    The agent traverses the grid by moving through
background cells, following a deterministic path based on a memory of its
current direction and the color of the nearest object encountered during
collisions. Movement begins by moving right. Upon encountering a non-background
cell (an object), the agent turns 90 degrees: the direction of the turn (left or
right) is determined by the color of the object at the point of collision. For
example, collisions with red objects result in a left turn, while collisions
with green objects result in a right turn (the specific color-to-turn mapping
must be inferred from the input-output pairs).    The agent continues moving and
turning until it exits the grid. The memory trace of the agent's path is then
overlaid onto the background cells of the input grid, replacing the background
color with a new, distinct color (e.g., orange) that does not appear in the
input. The output grid remains identical to the input grid except for this path,
which is drawn only on background cells (no overwriting of objects or other
elements). The path must be continuous and consistent with the inferred turn
rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, rand_sprite

def generate():
    size = random.randint(20, 30)
    bg_color = random.randint(0, 9)
    ingrid = grid(size, size, bg_color)
    
    # Generate 3-5 objects
    num_objects = random.randint(3, 5)
    object_colors = []
    for _ in range(num_objects):
        color = random.randint(1, 9)
        while color == bg_color:
            color = random.randint(1, 9)
        object_colors.append(color)
        
        # Create object shape with limited size
        base_size = min(size, 15)
        name = random.choice(['el', 'aitch', 'you'])
        pixels = rand_sprite(name, base_size, base_size)
        
        # Place object with 1-cell border
        min_r = min(p[0] for p in pixels)
        max_r = max(p[0] for p in pixels)
        min_c = min(p[1] for p in pixels)
        max_c = max(p[1] for p in pixels)
        obj_height = max_r - min_r + 1
        obj_width = max_c - min_c + 1
        
        # Calculate valid placement range
        max_r_start = size - obj_height - 1
        max_c_start = size - obj_width - 1
        r_start = random.randint(1, max(1, max_r_start))
        c_start = random.randint(1, max(1, max_c_start))
        
        for r, c in pixels:
            ingrid[r_start + r][c_start + c] = color

    # Simulate agent path
    path = []
    current = (0, 0)
    direction = (0, 1)  # right
    
    while True:
        path.append(current)
        next_r = current[0] + direction[0]
        next_c = current[1] + direction[1]
        
        if next_r < 0 or next_r >= size or next_c < 0 or next_c >= size:
            break
        
        if ingrid[next_r][next_c] == bg_color:
            current = (next_r, next_c)
            continue
        
        # Turn based on object color
        obj_color = ingrid[next_r][next_c]
        if obj_color % 2 == 0:
            # Right turn
            if direction == (0, 1):
                direction = (1, 0)
            elif direction == (1, 0):
                direction = (0, -1)
            elif direction == (0, -1):
                direction = (-1, 0)
            else:
                direction = (0, 1)
        else:
            # Left turn
            if direction == (0, 1):
                direction = (-1, 0)
            elif direction == (1, 0):
                direction = (0, 1)
            elif direction == (0, -1):
                direction = (1, 0)
            else:
                direction = (0, -1)

    # Determine path color
    all_colors = set()
    for row in ingrid:
        all_colors.update(row)
    path_color = 0
    while path_color in all_colors:
        path_color += 1
        if path_color > 9:
            path_color = 0

    # Create output grid
    outgrid = [row[:] for row in ingrid]
    for r, c in path:
        outgrid[r][c] = path_color
    
    return {
        'input': ingrid,
        'output': outgrid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    size = len(grid)
    
    # Find background color
    from collections import Counter
    all_colors = [color for row in grid for color in row]
    bg_color = Counter(all_colors).most_common(1)[0][0]
    
    # Determine path color
    colors_present = set(all_colors)
    path_color = 0
    while path_color in colors_present:
        path_color += 1
        if path_color > 9:
            path_color = 0
    
    # Simulate agent path
    path = []
    current = (0, 0)
    direction = (0, 1)  # right
    
    while True:
        path.append(current)
        next_r = current[0] + direction[0]
        next_c = current[1] + direction[1]
        
        if next_r < 0 or next_r >= size or next_c < 0 or next_c >= size:
            break
        
        if grid[next_r][next_c] == bg_color:
            current = (next_r, next_c)
            continue
        
        # Turn based on object color (same rule as generator)
        obj_color = grid[next_r][next_c]
        if obj_color % 2 == 0:
            if direction == (0, 1):
                direction = (1, 0)
            elif direction == (1, 0):
                direction = (0, -1)
            elif direction == (0, -1):
                direction = (-1, 0)
            else:
                direction = (0, 1)
        else:
            if direction == (0, 1):
                direction = (-1, 0)
            elif direction == (1, 0):
                direction = (0, 1)
            elif direction == (0, -1):
                direction = (1, 0)
            else:
                direction = (0, -1)

    # Draw path
    for r, c in path:
        grid[r][c] = path_color
    
    return tuple(tuple(row) for row in grid)
