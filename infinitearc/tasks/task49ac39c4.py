# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 49ac39c4
Difficulty: very hard

=== Tags ===
- Bidirectional escape
- Repaint border
- Rotate each quadrant

=== Description ===
**Task Description: Quadrant Escape Path**  Input grids are 2D color grids (0-9)
with even dimensions (width and height ≥ 4), containing distinct internal
patterns and a visible border. The grid features a central region with unique
color markers that dictate the transformation rules.  **Transformation Rules:**
1. **Quadrant Rotation**: Divide the grid into four equal quadrants (top-left,
top-right, bottom-left, bottom-right). Rotate the top-left and bottom-right
quadrants 90° clockwise. Rotate the top-right and bottom-left quadrants 90°
counterclockwise. This creates a reoriented internal structure where quadrant
boundaries align with the new grid orientation.  2. **Border Repainting**: After
rotation, the outer border (perimeter) is repainted based on the dominant color
in the *innermost layer* of each quadrant that now occupies the border.
Specifically:    - The top border uses the most frequent color from the top-left
and top-right quadrants' inner layers (excluding the rotated border pixels).
- The bottom border uses the most frequent color from the bottom-left and
bottom-right quadrants' inner layers.    - The left border uses the most
frequent color from the top-left and bottom-left quadrants' inner layers.    -
The right border uses the most frequent color from the top-right and bottom-
right quadrants' inner layers.  3. **Bidirectional Escape**: The repainted
border must visually indicate bidirectional escape paths. If the central 2×2
region of the *original grid* contains a unique color (appearing exactly once in
the center), the top and bottom borders are repainted with one color (e.g.,
cyan), while the left and right borders are repainted with a distinct color
(e.g., magenta). If the central 2×2 region has no unique color, the assignments
reverse (top/bottom use magenta, left/right use cyan). This creates a clear
visual distinction between horizontal (left-right) and vertical (top-bottom)
escape directions in the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    from collections import Counter
    N = random.choice(range(6, 31, 2))
    input_grid = [[random.randint(0, 9) for _ in range(N)] for _ in range(N)]
    mid = N // 2
    central = [input_grid[mid-1][mid-1], input_grid[mid-1][mid], input_grid[mid][mid-1], input_grid[mid][mid]]
    count = Counter(central)
    unique_colors = [color for color, cnt in count.items() if cnt == 1]
    top_bottom = 8 if unique_colors else 6
    left_right = 6 if unique_colors else 8

    S = N // 2
    tl = [row[:S] for row in input_grid[:S]]
    tr = [row[S:] for row in input_grid[:S]]
    bl = [row[:S] for row in input_grid[S:]]
    br = [row[S:] for row in input_grid[S:]]

    tl_rot = [list(x)[::-1] for x in zip(*tl)]
    br_rot = [list(x)[::-1] for x in zip(*br)]
    tr_rot = [list(x) for x in zip(*tr)][::-1]
    bl_rot = [list(x) for x in zip(*bl)][::-1]

    output_grid = [[0] * N for _ in range(N)]
    for r in range(S):
        for c in range(S):
            output_grid[r][c] = tl_rot[r][c]
            output_grid[r][S + c] = tr_rot[r][c]
            output_grid[S + r][c] = bl_rot[r][c]
            output_grid[S + r][S + c] = br_rot[r][c]

    for c in range(N):
        output_grid[0][c] = top_bottom
        output_grid[N-1][c] = top_bottom
    for r in range(1, N-1):
        output_grid[r][0] = left_right
        output_grid[r][N-1] = left_right

    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    N = len(input_list)
    S = N // 2

    tl = [row[:S] for row in input_list[:S]]
    tr = [row[S:] for row in input_list[:S]]
    bl = [row[:S] for row in input_list[S:]]
    br = [row[S:] for row in input_list[S:]]

    tl_rot = [list(x)[::-1] for x in zip(*tl)]
    br_rot = [list(x)[::-1] for x in zip(*br)]
    tr_rot = [list(x) for x in zip(*tr)][::-1]
    bl_rot = [list(x) for x in zip(*bl)][::-1]

    output_grid = [[0] * N for _ in range(N)]
    for r in range(S):
        for c in range(S):
            output_grid[r][c] = tl_rot[r][c]
            output_grid[r][S + c] = tr_rot[r][c]
            output_grid[S + r][c] = bl_rot[r][c]
            output_grid[S + r][S + c] = br_rot[r][c]

    mid = N // 2
    central = [input_list[mid-1][mid-1], input_list[mid-1][mid], input_list[mid][mid-1], input_list[mid][mid]]
    from collections import Counter
    count = Counter(central)
    unique_colors = [color for color, cnt in count.items() if cnt == 1]
    top_bottom = 8 if unique_colors else 6
    left_right = 6 if unique_colors else 8

    for c in range(N):
        output_grid[0][c] = top_bottom
        output_grid[N-1][c] = top_bottom
    for r in range(1, N-1):
        output_grid[r][0] = left_right
        output_grid[r][N-1] = left_right

    return output_grid
