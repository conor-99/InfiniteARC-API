# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: bcbaf203
Difficulty: hard

=== Tags ===
- Minimal path fill
- Rotational matching
- Gravity
- One yes one no

=== Description ===
The task involves transforming an input grid into an output grid through a
sequence of operations. The input grid contains multiple regions of distinct
colors, with one region designated as the "yes" region (e.g., color 3) and
another as the "no" region (e.g., color 7).   First, gravity is applied to the
grid, causing all non-zero elements to fall downward to the lowest possible
positions. This results in the "yes" and "no" regions being positioned at the
bottom of the grid.  Next, rotational matching is applied to the "yes" region.
The region is rotated 90 degrees clockwise to align with the grid's structure,
altering its orientation and positioning relative to the grid. This rotation
ensures the region's endpoints align with vertical or horizontal axes for the
minimal path fill.  The minimal path fill operation identifies the start and end
points of the rotated "yes" region (e.g., the topmost and bottommost points).
The shortest path between these points is calculated, traversing through empty
(zero) cells, and filled with a new color (e.g., color 4). The "no" region is
ignored for this operation, remaining unchanged except for the gravity effect.
The final output grid reflects these transformations: the "yes" region is
rotated, its minimal path filled, and all regions are positioned under gravity,
while the "no" region remains as it was after gravity application. This task
requires recognizing the "yes" and "no" regions, applying gravity correctly,
performing the rotation, and identifying the minimal path through the grid's
structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, connected

def apply_gravity_to_grid(grid):
    height = len(grid)
    width = len(grid[0])
    new_grid = [[0] * width for _ in range(height)]
    for c in range(width):
        col = [grid[r][c] for r in range(height)]
        non_zero = [val for val in col if val != 0]
        new_col = [0] * (height - len(non_zero)) + non_zero
        for r in range(height):
            new_grid[r][c] = new_col[r]
    return new_grid

def generate_connected_region(width, height, exclude=None):
    pixels = []
    if exclude is None:
        exclude = []
    while not pixels:
        pixels = [(0, 0)]
        for _ in range(random.randint(1, 10)):
            r, c = random.choice(pixels)
            neighbors = [(r+1, c), (r-1, c), (r, c+1), (r, c-1)]
            valid_neighbors = [(nr, nc) for nr, nc in neighbors if 0 <= nr < height and 0 <= nc < width]
            if not valid_neighbors:
                break
            new_pixel = random.choice(valid_neighbors)
            if new_pixel not in pixels and new_pixel not in exclude:
                pixels.append(new_pixel)
        if not connected(pixels):
            pixels = []
    return pixels

def find_shortest_path(grid, start, end):
    from collections import deque
    height = len(grid)
    width = len(grid[0])
    visited = [[False] * width for _ in range(height)]
    parent = {}
    queue = deque([start])
    visited[start[0]][start[1]] = True
    while queue:
        r, c = queue.popleft()
        if (r, c) == end:
            break
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == 0:
                visited[nr][nc] = True
                parent[(nr, nc)] = (r, c)
                queue.append((nr, nc))
    path = []
    node = end
    while node != start:
        path.append(node)
        node = parent.get(node, None)
        if node is None:
            return []
    path.append(start)
    return path[::-1]

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    input_grid = [[0] * width for _ in range(height)]
    
    # Generate connected 'yes' region (color 3)
    yes_pixels = generate_connected_region(width, height)
    for r, c in yes_pixels:
        input_grid[r][c] = 3
    
    # Generate connected 'no' region (color 7) avoiding 'yes' region
    no_pixels = generate_connected_region(width, height, exclude=yes_pixels)
    for r, c in no_pixels:
        input_grid[r][c] = 7
    
    # Apply gravity to input grid
    gravity_grid = apply_gravity_to_grid(input_grid)
    
    # Create output grid from gravity_grid
    output_grid = [row[:] for row in gravity_grid]
    
    # Rotate 'yes' region (color 3) 90° clockwise
    for r in range(height):
        for c in range(width):
            if gravity_grid[r][c] == 3:
                new_r = c
                new_c = height - 1 - r
                if 0 <= new_r < height and 0 <= new_c < width:
                    output_grid[new_r][new_c] = 3
                    output_grid[r][c] = 0
    
    # Find topmost and bottommost color 3 cells
    color3_positions = []
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] == 3:
                color3_positions.append((r, c))
    
    if not color3_positions:
        return generate()
    
    min_row = min(r for r, c in color3_positions)
    max_row = max(r for r, c in color3_positions)
    start = None
    end = None
    for r, c in color3_positions:
        if r == min_row:
            start = (r, c)
        if r == max_row:
            end = (r, c)
    
    # Find minimal path through empty cells (0)
    path = find_shortest_path(output_grid, start, end)
    for r, c in path:
        output_grid[r][c] = 4
    
    return {
        'input': input_grid,
        'output': output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random
from common import grid, connected

def apply_gravity_to_grid(grid):
    height = len(grid)
    width = len(grid[0])
    new_grid = [[0] * width for _ in range(height)]
    for c in range(width):
        col = [grid[r][c] for r in range(height)]
        non_zero = [val for val in col if val != 0]
        new_col = [0] * (height - len(non_zero)) + non_zero
        for r in range(height):
            new_grid[r][c] = new_col[r]
    return new_grid

def find_shortest_path(grid, start, end):
    from collections import deque
    height = len(grid)
    width = len(grid[0])
    visited = [[False] * width for _ in range(height)]
    parent = {}
    queue = deque([start])
    visited[start[0]][start[1]] = True
    while queue:
        r, c = queue.popleft()
        if (r, c) == end:
            break
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == 0:
                visited[nr][nc] = True
                parent[(nr, nc)] = (r, c)
                queue.append((nr, nc))
    path = []
    node = end
    while node != start:
        path.append(node)
        node = parent.get(node, None)
        if node is None:
            return []
    path.append(start)
    return path[::-1]

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    
    # Apply gravity
    gravity_grid = apply_gravity_to_grid(input_grid)
    output_grid = [row[:] for row in gravity_grid]
    
    # Rotate 'yes' region (color 3) 90° clockwise
    for r in range(height):
        for c in range(width):
            if gravity_grid[r][c] == 3:
                new_r = c
                new_c = height - 1 - r
                if 0 <= new_r < height and 0 <= new_c < width:
                    output_grid[new_r][new_c] = 3
                    output_grid[r][c] = 0
    
    # Find color 3 positions
    color3_positions = []
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] == 3:
                color3_positions.append((r, c))
    
    if not color3_positions:
        return output_grid
    
    min_row = min(r for r, c in color3_positions)
    max_row = max(r for r, c in color3_positions)
    start = None
    end = None
    for r, c in color3_positions:
        if r == min_row:
            start = (r, c)
        if r == max_row:
            end = (r, c)
    
    # Find minimal path
    path = find_shortest_path(output_grid, start, end)
    for r, c in path:
        output_grid[r][c] = 4
    
    return output_grid
