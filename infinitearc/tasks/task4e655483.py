# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 4e655483
Difficulty: insane

=== Tags ===
- Pattern moving
- Direction guessing
- Cylindrical

=== Description ===
The task involves transforming a grid with a distinct horizontal pattern (a
contiguous segment of identical color along a single row) on a cylindrical grid
(where the leftmost and rightmost columns are connected). The pattern must be
shifted left or right by one cell, with the shift direction determined by a
hidden rule based on the input grid's structure. The direction is not explicitly
indicated but must be inferred through abstract reasoning about the grid's
propertiesâ€”such as the parity of the sum of all elements, the color of a
specific reference cell, or the presence of a secondary pattern. The cylindrical
nature ensures that shifting beyond the grid's boundaries wraps the pattern to
the opposite edge. For "insane" difficulty, the rule requires multi-step
deduction from minimal examples, as the relationship between the input's
features and the shift direction is non-obvious and must be discovered through
pattern recognition rather than direct observation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
def generate():
    w = common.randint(2, 30)
    h = common.randint(2, 30)
    C = common.randint(1, 9)
    D = common.randint(0, 9)
    while D == C:
        D = common.randint(0, 9)
    
    r = common.randint(0, h - 1)
    L = common.randint(1, w - 1)
    s = common.randint(0, w - L)
    
    input_grid = common.grid(w, h, D)
    for c in range(s, s + L):
        input_grid[r][c] = C
    
    total_sum = (h * w - L) * D + L * C
    direction = 'right' if total_sum % 2 == 0 else 'left'
    
    if direction == 'right':
        new_s = (s + 1) % w
    else:
        new_s = (s - 1) % w
    
    output_grid = common.grid(w, h, D)
    for i in range(L):
        c = (new_s + i) % w
        output_grid[r][c] = C
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
def p(input_grid):
    w = len(input_grid[0])
    h = len(input_grid)
    
    counts = {}
    for row in input_grid:
        for cell in row:
            counts[cell] = counts.get(cell, 0) + 1
    
    C = min(counts, key=counts.get)
    D = None
    for color in counts:
        if color != C:
            D = color
            break
    
    r = None
    for i in range(h):
        if C in input_grid[i]:
            r = i
            break
    if r is None:
        return input_grid
    
    s = None
    L = 0
    for c in range(w):
        if input_grid[r][c] == C:
            if s is None:
                s = c
            L += 1
        else:
            if s is not None:
                break
    
    total_sum = sum(sum(row) for row in input_grid)
    direction = 'right' if total_sum % 2 == 0 else 'left'
    
    if direction == 'right':
        new_s = (s + 1) % w
    else:
        new_s = (s - 1) % w
    
    output_grid = common.grid(w, h, D)
    for i in range(L):
        c = (new_s + i) % w
        output_grid[r][c] = C
    return output_grid
