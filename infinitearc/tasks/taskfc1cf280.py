# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: fc1cf280
Difficulty: insane

=== Tags ===
- Elastic reflection
- Emergent behavior

=== Description ===
Input grids are large (20×20 or larger) with a uniform background color.
Overlaid are segments of "elastic walls" arranged in horizontal or vertical
lines, each wall segment colored with one of five distinct colors (red, blue,
green, yellow, purple). Each color corresponds to a specific reflection rule:
red walls cause a 90-degree left turn, blue walls a 90-degree right turn, green
walls reverse direction (180 degrees), yellow walls cause a 45-degree diagonal
reflection (changing movement direction to adjacent diagonal cells), and purple
walls absorb the particle, removing it from the grid. Particles are single-cell
markers of a unique color, positioned at the grid's edges (top, bottom, left,
right) adjacent to background cells but not overlapping walls. Each particle
moves inward along the edge until encountering a wall, where the reflection rule
applies.  The output grid depicts the complete path of each particle from its
starting edge to grid exit, drawn as a continuous line. The line's color cycles
through a fixed sequence (red → blue → green → yellow → purple → red...) at each
reflection point, independent of the wall color. Particles absorbed by purple
walls leave no trace. The emergent behavior manifests as the combined paths of
all particles forming a complex, non-repeating fractal-like pattern that depends
on the wall arrangement and initial particle positions, with no two paths
overlapping and all paths exiting the grid within a finite number of
reflections. The pattern exhibits self-similarity at different scales and
symmetry properties that emerge only after all reflection rules are applied
sequentially, requiring the solver to deduce both the reflection mechanics and
the holistic visual structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

# Generator for ARC task 411: elastic reflection with colored walls and particles
# Colors: 0 background, 1 red, 2 blue, 3 green, 4 yellow, 5 purple (absorb), 6 particle marker

# 8-directional moves (clockwise starting with East)
DIRS = [(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1),(-1,0),(-1,1)]
CYCLE = [1,2,3,4,5]


def in_bounds(r,c,size):
    return 0 <= r < size and 0 <= c < size


def simulate(orig, start_r, start_c, dir_idx, blocked):
    """
    Simulate a single particle from (start_r,start_c) with initial direction dir_idx
    against the grid 'orig'. 'blocked' is a set of coordinates reserved by previous
    particles' drawn paths and should be treated as obstacles.

    Returns (segments, status) where segments is a list of lists of coordinates
    (each list is a contiguous segment between reflections) and status is one of:
      - 'exit' : particle exited the grid (segments describes the drawn path)
      - 'absorbed' : particle hit a purple wall and should leave no trace (segments=[])
      - 'collision'/'loop'/'too_long' : invalid/unusable path (generator should skip)
    """
    size = len(orig)
    r, c = start_r, start_c
    dir = dir_idx
    segments = []
    cur_seg = [(r,c)]
    seen = set()
    steps = 0
    max_steps = size * size * 4  # safety limit

    while True:
        state = (r, c, dir)
        if state in seen:
            return None, 'loop'
        seen.add(state)

        dr, dc = DIRS[dir]
        nr, nc = r + dr, c + dc

        # Exit the grid
        if not in_bounds(nr, nc, size):
            if cur_seg:
                segments.append(cur_seg)
            return segments, 'exit'

        # If next cell is blocked by previously drawn path or a particle marker, it's invalid
        if (nr, nc) in blocked or orig[nr][nc] == 6:
            return None, 'collision'

        val = orig[nr][nc]
        if val == 0:
            cur_seg.append((nr, nc))
            r, c = nr, nc
            steps += 1
            if steps > max_steps:
                return None, 'too_long'
            continue

        if val == 5:
            # Purple wall absorbs the particle: leave no trace
            return [], 'absorbed'

        # Hit a colored wall (1..4): finalize current segment, reflect, and continue
        segments.append(cur_seg)
        if val == 1:
            # red: 90-degree left
            dir = (dir - 2) % 8
        elif val == 2:
            # blue: 90-degree right
            dir = (dir + 2) % 8
        elif val == 3:
            # green: reverse
            dir = (dir + 4) % 8
        elif val == 4:
            # yellow: 45-degree diagonal reflection (rotate 45 deg clockwise)
            dir = (dir + 1) % 8
        # start a new segment after the reflection (we don't step onto the wall)
        cur_seg = []


def generate():
    attempts = 0
    while True:
        attempts += 1
        if attempts > 500:
            # Fallback simple deterministic generation to avoid pathological retries
            size = 20
            grid = common.grid(size, size, 0)
            # single horizontal wall
            for c in range(5, size-5):
                grid[size//2][c] = random.randint(1,5)
            # one particle at top
            grid[0][size//2 - 2] = 6
            # Build output using same simulation logic
            out = [row[:] for row in grid]
            res, status = simulate(grid, 0, size//2 - 2, 2, set())
            if status == 'exit' and res:
                color_idx = 0
                for seg in res:
                    color = CYCLE[color_idx % len(CYCLE)]
                    for (rr,cc) in seg:
                        out[rr][cc] = color
                    color_idx += 1
            elif status == 'absorbed':
                out[0][size//2 - 2] = 0
            return {'input': grid, 'output': out}

        size = random.randint(20, 30)
        grid = common.grid(size, size, 0)

        # Place a moderate number of horizontal/vertical wall segments
        num_segments = random.randint(10, 18)
        for _ in range(num_segments):
            wall_color = random.randint(1, 5)  # 1..5 (5 is purple absorber)
            if random.random() < 0.5:
                # horizontal
                r = random.randint(2, size - 3)
                max_len = max(2, size // 4)
                length = random.randint(2, min(max_len, size - 4))
                start_c = random.randint(2, size - length - 2)
                for c in range(start_c, start_c + length):
                    grid[r][c] = wall_color
            else:
                # vertical
                c = random.randint(2, size - 3)
                max_len = max(2, size // 4)
                length = random.randint(2, min(max_len, size - 4))
                start_r = random.randint(2, size - length - 2)
                for r in range(start_r, start_r + length):
                    grid[r][c] = wall_color

        # Choose a random subset of edge positions and place particle markers there
        candidates = []
        for cc in range(1, size - 1):
            if grid[1][cc] == 0:
                candidates.append((0, cc, 2))  # top -> down
            if grid[size - 2][cc] == 0:
                candidates.append((size - 1, cc, 6))  # bottom -> up
        for rr in range(1, size - 1):
            if grid[rr][1] == 0:
                candidates.append((rr, 0, 0))  # left -> right
            if grid[rr][size - 2] == 0:
                candidates.append((rr, size - 1, 4))  # right -> left

        if not candidates:
            continue

        # Try a few random subsets of candidates
        k = random.randint(2, min(5, len(candidates)))
        subset_attempts = 0
        accepted_subset = None
        while subset_attempts < 200 and accepted_subset is None:
            subset_attempts += 1
            subset = random.sample(candidates, k)
            # Place markers for this subset into a fresh copy of the grid
            test_grid = [row[:] for row in grid]
            for (sr, sc, _) in subset:
                test_grid[sr][sc] = 6
            # Process particles in deterministic scanning order (matching solver)
            particles = []
            for c in range(1, size-1):
                if test_grid[0][c] == 6:
                    particles.append((0, c, 2))
                if test_grid[size-1][c] == 6:
                    particles.append((size-1, c, 6))
            for r in range(1, size-1):
                if test_grid[r][0] == 6:
                    particles.append((r, 0, 0))
                if test_grid[r][size-1] == 6:
                    particles.append((r, size-1, 4))

            blocked = set()
            all_results = []
            ok = True
            non_absorbed = 0
            for (sr, sc, sdir) in particles:
                res, status = simulate(test_grid, sr, sc, sdir, blocked)
                if status is None or status in ('collision', 'loop', 'too_long'):
                    ok = False
                    break
                if status == 'absorbed':
                    all_results.append({'pos': (sr, sc), 'absorbed': True})
                    # marker remains placed in input but no reserved cells
                    continue
                # status == 'exit'
                if not res:
                    ok = False
                    break
                path_cells = set((r, c) for seg in res for (r, c) in seg)
                if any(pc in blocked for pc in path_cells):
                    ok = False
                    break
                all_results.append({'pos': (sr, sc), 'absorbed': False, 'segments': res})
                blocked |= path_cells
                non_absorbed += 1
            if ok and non_absorbed > 0:
                accepted_subset = (subset, test_grid, all_results)
                break

        if accepted_subset is None:
            continue

        # Use accepted subset to build final input and output
        subset, final_input, all_results = accepted_subset
        out = [row[:] for row in final_input]
        for info in all_results:
            r0, c0 = info['pos']
            if info['absorbed']:
                out[r0][c0] = 0
                continue
            color_idx = 0
            for seg in info['segments']:
                color = CYCLE[color_idx % len(CYCLE)]
                for (rr, cc) in seg:
                    out[rr][cc] = color
                color_idx += 1

        return {'input': final_input, 'output': out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Solver that reproduces the generator's elastic reflection behavior
    DIRS = [(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1),(-1,0),(-1,1)]
    CYCLE = [1,2,3,4,5]

    def in_bounds(r,c,size):
        return 0 <= r < size and 0 <= c < size

    def simulate(orig, start_r, start_c, dir_idx, blocked):
        size = len(orig)
        r, c = start_r, start_c
        dir = dir_idx
        segments = []
        cur_seg = [(r,c)]
        seen = set()
        steps = 0
        max_steps = size * size * 4
        while True:
            state = (r, c, dir)
            if state in seen:
                return None, 'loop'
            seen.add(state)
            dr, dc = DIRS[dir]
            nr, nc = r + dr, c + dc
            if not in_bounds(nr, nc, size):
                if cur_seg:
                    segments.append(cur_seg)
                return segments, 'exit'
            if (nr, nc) in blocked or orig[nr][nc] == 6:
                return None, 'collision'
            val = orig[nr][nc]
            if val == 0:
                cur_seg.append((nr, nc))
                r, c = nr, nc
                steps += 1
                if steps > max_steps:
                    return None, 'too_long'
                continue
            if val == 5:
                return [], 'absorbed'
            segments.append(cur_seg)
            if val == 1:
                dir = (dir - 2) % 8
            elif val == 2:
                dir = (dir + 2) % 8
            elif val == 3:
                dir = (dir + 4) % 8
            elif val == 4:
                dir = (dir + 1) % 8
            cur_seg = []

    size = len(input_grid)
    orig = [list(row) for row in input_grid]
    out = [row[:] for row in orig]
    blocked = set()

    # Find particle markers (6) on the border and determine their initial directions
    particles = []
    for c in range(1, size-1):
        if orig[0][c] == 6:
            particles.append((0, c, 2))
        if orig[size-1][c] == 6:
            particles.append((size-1, c, 6))
    for r in range(1, size-1):
        if orig[r][0] == 6:
            particles.append((r, 0, 0))
        if orig[r][size-1] == 6:
            particles.append((r, size-1, 4))

    # Process each particle and draw its path
    for (sr, sc, sdir) in particles:
        res, status = simulate(orig, sr, sc, sdir, blocked)
        if status is None or status in ('collision', 'loop', 'too_long'):
            # If generator avoided this particle, leave marker as-is
            continue
        if status == 'absorbed':
            # Particle absorbed: leave no trace in output
            out[sr][sc] = 0
            continue
        # Draw segments with cycling colors
        color_idx = 0
        for seg in res:
            color = CYCLE[color_idx % len(CYCLE)]
            for (rr, cc) in seg:
                out[rr][cc] = color
            color_idx += 1
        # Mark these cells as blocked for subsequent particles
        for seg in res:
            for cell in seg:
                blocked.add(cell)

    return tuple(tuple(row) for row in out)

