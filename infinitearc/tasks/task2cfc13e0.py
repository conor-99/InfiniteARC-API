# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 2cfc13e0
Difficulty: medium–hard

=== Tags ===
- Staircase construction
- Directed cave maze
- Pairwise rule matching
- Area based reconstruction

=== Description ===
**Task: Staircase Maze Reconstruction**    **Input Grids:**   The input grid is
a 2D grid containing a background (value 0), solid walls (non-zero values
representing barriers), and scattered "staircase fragments" (distinct colors,
e.g., 1–4). Each fragment is a single cell or small cluster (up to 3 cells) of
uniform color, positioned to form a staircase path when connected in a specific
sequence. Fragments are not aligned, and walls obstruct potential paths.
**Output Grids:**   The output reconstructs a continuous staircase path by
connecting fragments in order, forming horizontal treads followed by vertical
risers. The path starts at the leftmost, topmost fragment and ascends diagonally
upward to the right. For each consecutive fragment pair:   1. A horizontal
segment (tread) is drawn from the current fragment’s position to align with the
next fragment’s column, using the *current fragment’s color*.   2. A vertical
segment (riser) is drawn upward to the next fragment’s row, using the *current
fragment’s color*.   The path avoids walls (non-background cells), and all
background cells along the path are filled with the fragment’s color. Walls
remain unchanged, and unused fragments are omitted.    **Key Rules:**   -
**Fragment Order:** Fragments are sorted left-to-right (by column), then top-to-
bottom (by row).   - **Path Consistency:** Each segment uses the *starting
fragment’s color* for the entire segment.   - **Maze Constraints:** Walls block
the path, so input grids are designed to allow a valid path through background
cells only.   - **Area Reconstruction:** The output forms a single staircase
sequence from all fragments, with no gaps or overlaps.    **Example Insight:**
Input fragments at (2,1) [color 2] and (1,3) [color 3] are sorted as (2,1) →
(1,3). The output draws a horizontal segment from (2,1) to (2,3) (color 2), then
a vertical segment from (2,3) to (1,3) (color 2), forming a step. Walls between
these cells would invalidate the input, ensuring only valid grids are used.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    input_grid = [[0] * width for _ in range(height)]
    output_grid = [[0] * width for _ in range(height)]
    
    k = random.randint(2, 4)
    fragments = []
    r, c = random.randint(3, height - 3), random.randint(3, width - 3)
    fragments.append((r, c))
    
    for _ in range(1, k):
        r = max(1, min(r - random.randint(2, 5), height - 2))
        c = max(1, min(c + random.randint(2, 5), width - 2))
        fragments.append((r, c))
    
    fragments.sort(key=lambda x: (x[1], x[0]))
    colors = list(range(1, k + 1))
    
    for idx, (r, c) in enumerate(fragments):
        input_grid[r][c] = colors[idx]
        output_grid[r][c] = colors[idx]
    
    path_cells = set()
    for i in range(k - 1):
        r1, c1 = fragments[i]
        r2, c2 = fragments[i + 1]
        for c in range(c1 + 1, c2 + 1):
            path_cells.add((r1, c))
        for r in range(r1 - 1, r2, -1):
            path_cells.add((r, c2))
    
    for r in range(height):
        for c in range(width):
            if (r, c) in fragments or (r, c) in path_cells:
                continue
            input_grid[r][c] = random.choice([5, 6, 7, 8, 9])
            output_grid[r][c] = input_grid[r][c]
    
    for i in range(k - 1):
        r1, c1 = fragments[i]
        r2, c2 = fragments[i + 1]
        color = colors[i]
        for c in range(c1 + 1, c2 + 1):
            output_grid[r1][c] = color
        for r in range(r1 - 1, r2, -1):
            output_grid[r][c2] = color
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    fragments = []
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            val = input_grid[r][c]
            if 1 <= val <= 4:
                fragments.append((r, c, val))
    
    fragments.sort(key=lambda x: (x[1], x[0]))
    
    if len(fragments) < 2:
        return input_grid
    
    output_grid = []
    for row in input_grid:
        output_grid.append(list(row))
    
    for i in range(len(fragments) - 1):
        r1, c1, color = fragments[i]
        r2, c2, _ = fragments[i + 1]
        for c in range(c1 + 1, c2 + 1):
            output_grid[r1][c] = color
        for r in range(r1 - 1, r2, -1):
            output_grid[r][c2] = color
    
    return output_grid
