# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 800ee498
Difficulty: mediumâ€“hard

=== Tags ===
- Detect symmetry
- Terrain erosion
- Pattern mirroring chain
- Carve negative space

=== Description ===
The task involves transforming an input grid containing an asymmetric foreground
terrain (non-zero cells) on a zero background into an output grid where the
negative space (background cells within the foreground's bounding box) is
symmetrically mirrored across the detected primary axis of symmetry.   Input
grids feature a contiguous foreground region composed of non-zero values,
surrounded by a uniform zero background. The foreground exhibits a clear but
asymmetric pattern with respect to a vertical or horizontal axis. The background
within the foreground's bounding box (the smallest rectangle containing all
foreground cells) is initially asymmetric.  To generate the output: 1. **Detect
symmetry**: Identify the primary axis of symmetry (vertical or horizontal) by
finding the axis where the foreground pattern shows the highest degree of
mirroring consistency (e.g., the axis where foreground cells on one side have
matching counterparts on the other side). 2. **Mirror negative space**: For all
background cells (zero) within the foreground's bounding box, mirror their
positions across the detected symmetry axis. This ensures the background pattern
within the foreground area becomes symmetric. 3. **Carve terrain**: The
foreground cells remain unchanged, but the background within the bounding box is
"carved" into a symmetric pattern by aligning all background cells with their
mirrored counterparts. Overlapping foreground cells are preserved, while
background cells are adjusted to maintain symmetry without altering the
foreground.  The output grid preserves all foreground cells and the surrounding
background, but the negative space inside the foreground's bounding box is
symmetrized through mirroring. This requires detecting the symmetry axis,
recognizing the foreground's boundary, and applying spatial mirroring to the
background, resulting in a visually symmetric negative space pattern that
complements the foreground's structure. The transformation relies on spatial
reasoning rather than value-based operations, making it discoverable through
visual inspection of the grid's symmetry properties.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, connected

def generate():
    for attempt in range(300):
        width = random.randint(6, 20)
        height = random.randint(6, 20)
        # rectangle size
        rect_w = random.randint(4, min(12, width))
        rect_h = random.randint(4, min(12, height))
        top = random.randint(0, height - rect_h)
        left = random.randint(0, width - rect_w)
        fcolor = random.randint(1, 9)
        # start with filled rectangle
        input_grid = grid(width, height, 0)
        pixels = []
        for r in range(top, top+rect_h):
            for c in range(left, left+rect_w):
                input_grid[r][c] = fcolor
                pixels.append((r,c))
        # interior candidates for holes (do not touch border so bounding box remains)
        interior = [(r,c) for r in range(top+1, top+rect_h-1) for c in range(left+1, left+rect_w-1)]
        random.shuffle(interior)
        # attempt to remove a few interior pixels while keeping foreground connected
        removals = []
        current_pixels = list(pixels)
        max_remove = max(1, len(interior)//6)
        for (r,c) in interior:
            if len(removals) >= max_remove: break
            if random.random() > 0.6:  # some randomness
                if (r,c) not in current_pixels: continue
                new_pixels = [p for p in current_pixels if p != (r,c)]
                if len(new_pixels) == 0: continue
                if connected(new_pixels):
                    current_pixels = new_pixels
                    removals.append((r,c))
        # we need at least one hole to make a change after mirroring
        if not removals:
            # force one removal that preserves connectivity if possible
            for (r,c) in interior:
                if (r,c) not in current_pixels: continue
                new_pixels = [p for p in current_pixels if p != (r,c)]
                if len(new_pixels) == 0: continue
                if connected(new_pixels):
                    current_pixels = new_pixels
                    removals.append((r,c))
                    break
        if not removals:
            continue
        # build final input grid from current_pixels
        input_grid = grid(width, height, 0)
        for (r,c) in current_pixels:
            input_grid[r][c] = fcolor
        # bounding box
        rows = [r for r,c in current_pixels]
        cols = [c for r,c in current_pixels]
        min_row, max_row = min(rows), max(rows)
        min_col, max_col = min(cols), max(cols)
        # detect symmetry axis
        vertical_match = 0
        for r,c in current_pixels:
            mirror_c = min_col + max_col - c
            if 0 <= mirror_c < width and input_grid[r][mirror_c] != 0:
                vertical_match += 1
        horizontal_match = 0
        for r,c in current_pixels:
            mirror_r = min_row + max_row - r
            if 0 <= mirror_r < height and input_grid[mirror_r][c] != 0:
                horizontal_match += 1
        axis = 'vertical' if vertical_match > horizontal_match else 'horizontal'
        # require that at least one background cell inside the box will cause carving across the chosen axis
        def has_asymmetric_zero(ax):
            if ax == 'vertical':
                for r in range(min_row, max_row+1):
                    for c in range(min_col, max_col+1):
                        mirror_c = min_col + max_col - c
                        if input_grid[r][c] == 0 and input_grid[r][mirror_c] != 0:
                            return True
                        if input_grid[r][mirror_c] == 0 and input_grid[r][c] != 0:
                            return True
            else:
                for r in range(min_row, max_row+1):
                    for c in range(min_col, max_col+1):
                        mirror_r = min_row + max_row - r
                        if input_grid[r][c] == 0 and input_grid[mirror_r][c] != 0:
                            return True
                        if input_grid[mirror_r][c] == 0 and input_grid[r][c] != 0:
                            return True
            return False
        if not has_asymmetric_zero(axis):
            # try another random configuration
            continue
        # create output by mirroring zeros across axis (carving)
        output_grid = [row[:] for row in input_grid]
        if axis == 'vertical':
            for r in range(min_row, max_row+1):
                for c in range(min_col, max_col+1):
                    mirror_c = min_col + max_col - c
                    if c <= mirror_c:
                        if input_grid[r][c] == 0 or input_grid[r][mirror_c] == 0:
                            output_grid[r][c] = 0
                            output_grid[r][mirror_c] = 0
        else:
            for r in range(min_row, max_row+1):
                for c in range(min_col, max_col+1):
                    mirror_r = min_row + max_row - r
                    if r <= mirror_r:
                        if input_grid[r][c] == 0 or input_grid[mirror_r][c] == 0:
                            output_grid[r][c] = 0
                            output_grid[mirror_r][c] = 0
        if input_grid != output_grid:
            return {'input': input_grid, 'output': output_grid}
    # fallback simple case (should not be reached often)
    width, height = 6,6
    input_grid = grid(width,height,0)
    for r in range(1,5):
        for c in range(1,5):
            input_grid[r][c] = 1
    output_grid = [row[:] for row in input_grid]
    output_grid[2][4] = 0
    output_grid[2][1] = 0
    return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0]) if height>0 else 0
    # find foreground pixels
    pixels = [(r,c) for r in range(height) for c in range(width) if input_grid[r][c] != 0]
    if not pixels:
        return input_grid
    rows = [r for r,c in pixels]
    cols = [c for r,c in pixels]
    min_row, max_row = min(rows), max(rows)
    min_col, max_col = min(cols), max(cols)
    # detect axis
    vertical_match = 0
    for r,c in pixels:
        mirror_c = min_col + max_col - c
        if 0 <= mirror_c < width and input_grid[r][mirror_c] != 0:
            vertical_match += 1
    horizontal_match = 0
    for r,c in pixels:
        mirror_r = min_row + max_row - r
        if 0 <= mirror_r < height and input_grid[mirror_r][c] != 0:
            horizontal_match += 1
    axis = 'vertical' if vertical_match > horizontal_match else 'horizontal'
    # create output by mirroring zeros across axis
    output = [row[:] for row in input_grid]
    if axis == 'vertical':
        for r in range(min_row, max_row+1):
            for c in range(min_col, max_col+1):
                mirror_c = min_col + max_col - c
                if c <= mirror_c:
                    if input_grid[r][c] == 0 or input_grid[r][mirror_c] == 0:
                        output[r][c] = 0
                        output[r][mirror_c] = 0
    else:
        for r in range(min_row, max_row+1):
            for c in range(min_col, max_col+1):
                mirror_r = min_row + max_row - r
                if r <= mirror_r:
                    if input_grid[r][c] == 0 or input_grid[mirror_r][c] == 0:
                        output[r][c] = 0
                        output[mirror_r][c] = 0
    return output

