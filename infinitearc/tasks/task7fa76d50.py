# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 7fa76d50
Difficulty: insane

=== Tags ===
- Color transfer on contact
- Friction path
- Task rule selection
- Proximity guessing
- Diagonals

=== Description ===
**Task Name:** Friction Path Transference  **Tags:**   - Color transfer on
contact   - Friction path   - Task rule selection   - Proximity guessing   -
Diagonals    **Description:**   Input grids feature a large (25×25) background
of uniform color, overlaid with three distinct interactive element types:
**sources** (single cells of color S), **targets** (cells of color T), and
**friction nodes** (cells of color F). Sources emit **diagonal friction paths**
that originate at the source and propagate diagonally (NE, NW, SE, SW) based on
**proximity guessing**: the path direction is determined by the relative
position of the nearest source to the path’s starting point (e.g., if the source
is northeast of the starting cell, the path moves NE). The path travels
diagonally through background cells until it contacts a friction node (F),
triggering two critical changes: (1) the friction node’s color updates to match
the path’s current color, and (2) the **color transfer rule** dynamically
switches (e.g., from orthogonal transfer to diagonal transfer upon contact).
Upon contact with a target (T), the path transfers its current color to the
target, which then adopts the path’s color. The path continues its trajectory
with the updated color until it exits the grid. The output grid preserves all
original elements (S, T, F), updates friction nodes and targets per contact
rules, and visualizes the path’s trajectory as a continuous diagonal line of
transferred colors. The solver must infer the initial path direction via
proximity guessing, dynamically select transfer rules at friction nodes, and
resolve cascading color changes across the grid, requiring multi-layered spatial
reasoning and sequential rule application across intersecting path segments.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = 25
    height = 25
    bg = 0
    grid = common.grid(width, height, bg)
    s_color = 1
    t_color = 2
    f_color = 3

    sx, sy = random.randint(1, height-2), random.randint(1, width-2)
    grid[sx][sy] = s_color

    directions = [(-1, 1), (-1, -1), (1, 1), (1, -1)]
    dx, dy = random.choice(directions)
    tx, ty = sx + 3*dx, sy + 3*dy
    tx = max(0, min(tx, height-1))
    ty = max(0, min(ty, width-1))
    grid[tx][ty] = t_color

    fx, fy = sx + dx, sy + dy
    if 0 <= fx < height and 0 <= fy < width:
        grid[fx][fy] = f_color

    output = [row[:] for row in grid]
    dx_path = 1 if tx > sx else -1
    dy_path = 1 if ty > sy else -1
    steps = abs(tx - sx)
    for step in range(1, steps + 1):
        r = sx + step * dx_path
        c = sy + step * dy_path
        if 0 <= r < height and 0 <= c < width:
            output[r][c] = s_color

    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    s_color = 1
    t_color = 2

    sources = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] == s_color:
                sources.append((r, c))

    targets = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] == t_color:
                targets.append((r, c))

    if not sources or not targets:
        return tuple(tuple(row) for row in grid)

    sr, sc = sources[0]
    tr, tc = targets[0]
    dx = 1 if tr > sr else -1
    dy = 1 if tc > sc else -1
    steps = abs(tr - sr)

    for step in range(1, steps + 1):
        r = sr + step * dx
        c = sc + step * dy
        if 0 <= r < height and 0 <= c < width:
            grid[r][c] = s_color

    return tuple(tuple(row) for row in grid)
