# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 59a13b5d
Difficulty: hard

=== Tags ===
- Order numbers
- Extrapolate image from grid
- Count patterns

=== Description ===
The input grid consists of a 2D arrangement of colored cells (0-9), where each
connected region (group of adjacent same-colored cells, ignoring background
color 0) represents a distinct visual pattern. The task requires two primary
operations: **counting patterns** and **extrapolating the image**. First, for
each non-background color, count the number of disconnected connected regions it
forms (e.g., color 5 appearing in two separate islands counts as 2). Next,
**order the colors** by their region counts in ascending order, with ties broken
by the color's numerical value (0-9). Finally, **extrapolate** by representing
each color as a solid square in the output grid, where the square's side length
equals the count for that color. These squares are arranged horizontally in the
ordered sequence, forming a single row. The output grid’s width is the sum of
all counts, and its height is the maximum count. This task demands visual
pattern recognition, precise counting of disconnected regions, combinatorial
ordering, and spatial extrapolation—requiring multiple layered transformations
to deduce the correct output from complex inputs.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = [[0] * width for _ in range(height)]
    
    colors_to_use = random.sample(range(1, 10), random.randint(2, 5))
    
    for color in colors_to_use:
        num_regions = random.randint(1, 2)
        for _ in range(num_regions):
            r = random.randint(0, height - 2)
            c = random.randint(0, width - 2)
            size = random.randint(2, 3)
            for dr in range(size):
                for dc in range(size):
                    nr, nc = r + dr, c + dc
                    if nr < height and nc < width:
                        grid[nr][nc] = color
    
    counts = {}
    for color in colors_to_use:
        positions = []
        for r in range(height):
            for c in range(width):
                if grid[r][c] == color:
                    positions.append((r, c))
        if not positions:
            continue
        visited = set()
        comp_count = 0
        for pos in positions:
            if pos not in visited:
                comp_count += 1
                stack = [pos]
                visited.add(pos)
                while stack:
                    r, c = stack.pop()
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in visited and grid[nr][nc] == color:
                            stack.append((nr, nc))
                            visited.add((nr, nc))
        counts[color] = comp_count
    
    sorted_colors = sorted(counts.keys(), key=lambda c: (counts[c], c))
    total_width = sum(counts[c] for c in sorted_colors)
    max_height = max(counts.values()) if sorted_colors else 1
    output = [[0] * total_width for _ in range(max_height)]
    
    current_col = 0
    for color in sorted_colors:
        count_val = counts[color]
        for r in range(count_val):
            for c in range(current_col, current_col + count_val):
                output[r][c] = color
        current_col += count_val
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    colors_present = set()
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] != 0:
                colors_present.add(input_grid[r][c])
    
    counts = {}
    for color in colors_present:
        positions = []
        for r in range(len(input_grid)):
            for c in range(len(input_grid[0])):
                if input_grid[r][c] == color:
                    positions.append((r, c))
        if not positions:
            continue
        visited = set()
        comp_count = 0
        for pos in positions:
            if pos not in visited:
                comp_count += 1
                stack = [pos]
                visited.add(pos)
                while stack:
                    r, c = stack.pop()
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < len(input_grid) and 0 <= nc < len(input_grid[0]) and (nr, nc) not in visited and input_grid[nr][nc] == color:
                            stack.append((nr, nc))
                            visited.add((nr, nc))
        counts[color] = comp_count
    
    sorted_colors = sorted(counts.keys(), key=lambda c: (counts[c], c))
    total_width = sum(counts[c] for c in sorted_colors)
    max_height = max(counts.values()) if sorted_colors else 1
    output = [[0] * total_width for _ in range(max_height)]
    
    current_col = 0
    for color in sorted_colors:
        count_val = counts[color]
        for r in range(count_val):
            for c in range(current_col, current_col + count_val):
                output[r][c] = color
        current_col += count_val
    
    return output
