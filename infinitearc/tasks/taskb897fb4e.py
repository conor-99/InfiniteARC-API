# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: b897fb4e
Difficulty: insane

=== Tags ===
- Perimeter smoothing
- Rule propagation
- State transition by contact
- Pattern expansion

=== Description ===
Perimeter Harmony  Input grids display multiple contiguous regions of distinct
colors (1-4) on a background (0), each with jagged, irregular perimeters. The
regions are separated by background cells, with no overlapping or adjacency
between regions of the same color.   The transformation process involves four
sequential steps applied to the input grid:  1. **State Transition by Contact**:
For every cell on the perimeter (adjacent to background), check its four
orthogonal neighbors. If a perimeter cell of color A is adjacent to a background
cell with a neighbor of color B (where B is a different region color), the
perimeter cell transitions to a new color C. The transition rules are fixed per
color pair (e.g., blue (1) adjacent to green (3) → purple (5), green (3)
adjacent to red (2) → cyan (6)). Transitions occur simultaneously across all
qualifying cells in each wave.  2. **Rule Propagation**: The transition process
repeats in iterative waves. After each wave, newly transitioned cells may form
new perimeter cells adjacent to background, triggering further transitions in
subsequent waves. Propagation continues until no more transitions can occur
(convergence point).  3. **Perimeter Smoothing**: After propagation stabilizes,
all "spike" protrusions are removed. A spike is defined as a single background
cell surrounded by perimeter cells on three sides (i.e., a cell with exactly
three background neighbors). Such spikes are converted to background, and
adjacent perimeter cells are adjusted to create smooth, continuous boundaries
without sharp indentations.  4. **Pattern Expansion**: The regions expand into
the background through the transition process, with the expansion direction
determined by the contact rules. The final grid shows contiguous regions with
smoothed perimeters and expanded areas where transitions occurred, maintaining
all original color relationships while eliminating jagged edges.  The output
grid must reflect all four steps: stabilized transitions, propagated changes,
smoothed perimeters, and expanded regions. No background cells remain isolated,
and all transitions strictly follow the color-contact rules without introducing
new colors beyond the defined transitions. The complexity arises from the need
to track multi-wave propagation, recognize spike patterns for smoothing, and
ensure expansion aligns with the contact rules without overlapping regions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random
from collections import Counter

def generate():
    w = random.randint(15, 30)
    h = random.randint(15, 30)
    input_grid = [[0] * w for _ in range(h)]
    quadrants = [
        (0, 0, h//2, w//2),   # top-left
        (0, w//2, h//2, w),    # top-right
        (h//2, 0, h, w//2),    # bottom-left
        (h//2, w//2, h, w)     # bottom-right
    ]
    for color in range(1, 5):
        start_r, start_c, end_r, end_c = quadrants[color-1]
        size = random.randint(5, 10)
        width = end_c - start_c
        height = end_r - start_r
        if width < 1 or height < 1:
            width = max(1, width)
            height = max(1, height)
        pixels = common.continuous_creature(size, width, height)
        for (r, c) in pixels:
            r_global = start_r + r
            c_global = start_c + c
            if r_global < h and c_global < w:
                input_grid[r_global][c_global] = color
    output_grid = [[input_grid[i][j] for j in range(len(input_grid[0]))] for i in range(len(input_grid))]
    # Apply transformations
    changed = True
    while changed:
        changed = False
        transitions = []
        for r in range(len(output_grid)):
            for c in range(len(output_grid[0])):
                if output_grid[r][c] == 0:
                    continue
                has_background = False
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < len(output_grid) and 0 <= nc < len(output_grid[0]) and output_grid[nr][nc] == 0:
                        has_background = True
                        break
                if not has_background:
                    continue
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < len(output_grid) and 0 <= nc < len(output_grid[0]) and output_grid[nr][nc] == 0:
                        for ddr, ddc in [(1,0), (-1,0), (0,1), (0,-1)]:
                            nnr, nnc = nr + ddr, nc + ddc
                            if 0 <= nnr < len(output_grid) and 0 <= nnc < len(output_grid[0]) and output_grid[nnr][nnc] != 0:
                                B = output_grid[nnr][nnc]
                                A = output_grid[r][c]
                                if A != B:
                                    key = tuple(sorted((A, B)))
                                    if key in [(1,2), (1,3), (1,4), (2,3), (2,4), (3,4)]:
                                        new_color = 5 if key == (1,2) or key == (3,4) else 6 if key == (1,3) else 7 if key == (1,4) else 8 if key == (2,3) else 9
                                        transitions.append((r, c, new_color))
                                        changed = True
                                        break
                        if changed:
                            break
        for (r, c, new_color) in transitions:
            output_grid[r][c] = new_color
    # Perimeter smoothing
    for r in range(len(output_grid)):
        for c in range(len(output_grid[0])):
            if output_grid[r][c] != 0:
                continue
            count = 0
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < len(output_grid) and 0 <= nc < len(output_grid[0]) and output_grid[nr][nc] != 0:
                    count += 1
            if count == 3:
                neighbors = []
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < len(output_grid) and 0 <= nc < len(output_grid[0]) and output_grid[nr][nc] != 0:
                        neighbors.append(output_grid[nr][nc])
                if neighbors:
                    most_common = max(set(neighbors), key=neighbors.count)
                    output_grid[r][c] = most_common
    # Ensure input != output
    if all(input_grid[i][j] == output_grid[i][j] for i in range(len(input_grid)) for j in range(len(input_grid[0]))):
        return generate()
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import Counter

def p(input_grid):
    grid = [list(row) for row in input_grid]
    transition_map = {
        (1, 2): 5,
        (1, 3): 6,
        (1, 4): 7,
        (2, 3): 8,
        (2, 4): 9,
        (3, 4): 5
    }
    changed = True
    while changed:
        changed = False
        transitions = []
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                if grid[r][c] == 0:
                    continue
                has_background = False
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == 0:
                        has_background = True
                        break
                if not has_background:
                    continue
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == 0:
                        for ddr, ddc in [(1,0), (-1,0), (0,1), (0,-1)]:
                            nnr, nnc = nr + ddr, nc + ddc
                            if 0 <= nnr < len(grid) and 0 <= nnc < len(grid[0]) and grid[nnr][nnc] != 0:
                                B = grid[nnr][nnc]
                                A = grid[r][c]
                                if A != B:
                                    key = tuple(sorted((A, B)))
                                    if key in transition_map:
                                        new_color = transition_map[key]
                                        transitions.append((r, c, new_color))
                                        changed = True
                                        break
                        if changed:
                            break
        for (r, c, new_color) in transitions:
            grid[r][c] = new_color
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            if grid[r][c] != 0:
                continue
            count = 0
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] != 0:
                    count += 1
            if count == 3:
                neighbors = []
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] != 0:
                        neighbors.append(grid[nr][nc])
                if neighbors:
                    most_common = max(set(neighbors), key=neighbors.count)
                    grid[r][c] = most_common
    return grid
