# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: f5c60628
Difficulty: very hard

=== Tags ===
- Rule switch on context

=== Description ===
The task involves transforming an input grid into an output grid based on the
structural pattern within a central 3x3 subgrid. Input grids range from 5×5 to
30×30, featuring a background color (0) and non-background colors (1–9) forming
distinct spatial arrangements. The central 3x3 subgrid (centered within the
grid, with tie-breaking for even dimensions) determines the transformation rule
through its inherent pattern structure: a checkerboard pattern (alternating
colors in a chessboard arrangement) triggers a 90-degree clockwise rotation of
the entire grid; a solid color pattern (all cells in the subgrid sharing the
same non-zero color) triggers a horizontal reflection (left-right flip); a
diagonal pattern (non-zero colors only along the main diagonal with background
elsewhere) triggers color inversion (0↔9, 1↔8, ..., 8↔1); and a vertical stripe
pattern (each column within the subgrid uniform in color) triggers a color shift
(each color c becomes (c+1) mod 10). The transformation is applied uniformly to
all cells, including the central subgrid, requiring precise pattern
classification and multi-step reasoning to correctly apply the selected rule.
This task demands abstract pattern recognition beyond pixel-level analysis, as
the specific color values in the central subgrid are irrelevant—only their
structural relationships matter—and the transformations involve non-trivial grid
manipulations, making it very challenging due to the need for contextual rule
switching and accurate execution of complex operations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import random_color

def generate():
    while True:
        width = random.randint(5, 30)
        height = random.randint(5, 30)
        grid_in = [[0] * width for _ in range(height)]
        x = (width - 3) // 2
        y = (height - 3) // 2
        pattern = random.choice(['checkerboard', 'solid', 'diagonal', 'vertical'])
        if pattern == 'checkerboard':
            color1 = random_color(exclude=[0])
            color2 = random_color(exclude=[0, color1])
            for i in range(3):
                for j in range(3):
                    if (i + j) % 2 == 0:
                        grid_in[y+i][x+j] = color1
                    else:
                        grid_in[y+i][x+j] = color2
        elif pattern == 'solid':
            color = random_color(exclude=[0])
            for i in range(3):
                for j in range(3):
                    grid_in[y+i][x+j] = color
        elif pattern == 'diagonal':
            color = random_color(exclude=[0])
            for i in range(3):
                for j in range(3):
                    if i == j:
                        grid_in[y+i][x+j] = color
                    else:
                        grid_in[y+i][x+j] = 0
        elif pattern == 'vertical':
            colors = [random_color(exclude=[0]) for _ in range(3)]
            for j in range(3):
                for i in range(3):
                    grid_in[y+i][x+j] = colors[j]
        for i in range(height):
            for j in range(width):
                if (x <= j < x+3 and y <= i < y+3):
                    continue
                if random.random() > 0.5:
                    grid_in[i][j] = random_color(exclude=[0])
        if pattern == 'checkerboard':
            grid_out = [list(x)[::-1] for x in zip(*grid_in)]
        elif pattern == 'solid':
            grid_out = [row[::-1] for row in grid_in]
        elif pattern == 'diagonal':
            grid_out = [[9 - cell if cell != 0 else 0 for cell in row] for row in grid_in]
        elif pattern == 'vertical':
            grid_out = [[(cell + 1) % 10 for cell in row] for row in grid_in]
        if grid_in == grid_out:
            continue
        return {'input': grid_in, 'output': grid_out}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid_in = [list(row) for row in input_grid]
    width = len(grid_in[0])
    height = len(grid_in)
    x = (width - 3) // 2
    y = (height - 3) // 2
    center = [grid_in[y+i][x:x+3] for i in range(3)]
    all_same = True
    first = center[0][0]
    for i in range(3):
        for j in range(3):
            if center[i][j] != first:
                all_same = False
                break
        if not all_same:
            break
    if all_same and first != 0:
        grid_out = [row[::-1] for row in grid_in]
        return tuple(tuple(row) for row in grid_out)
    diagonal_nonzero = True
    for i in range(3):
        if center[i][i] == 0:
            diagonal_nonzero = False
            break
    for i in range(3):
        for j in range(3):
            if i != j and center[i][j] != 0:
                diagonal_nonzero = False
                break
        if not diagonal_nonzero:
            break
    if diagonal_nonzero:
        grid_out = [[9 - cell if cell != 0 else 0 for cell in row] for row in grid_in]
        return tuple(tuple(row) for row in grid_out)
    vertical = True
    for j in range(3):
        col = [center[i][j] for i in range(3)]
        if not all(c == col[0] for c in col):
            vertical = False
            break
    if vertical:
        grid_out = [[(cell + 1) % 10 for cell in row] for row in grid_in]
        return tuple(tuple(row) for row in grid_out)
    grid_out = [list(x)[::-1] for x in zip(*grid_in)]
    return tuple(tuple(row) for row in grid_out)
