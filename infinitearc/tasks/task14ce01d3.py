# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 14ce01d3
Difficulty: insane

=== Tags ===
- Zigzag path
- Shape to color encoding
- Detect enclosure
- Gravity with barriers
- Flood fill region

=== Description ===
Input grids consist of a background color (0), a barrier color (1), and multiple
enclosed regions surrounded by barriers (color 1), forming disconnected shapes
that do not touch the grid edges. Each enclosed region contains a geometric
shape (square, triangle, hexagon, etc.) defined by its barrier boundary
structure. The shape's visual form (e.g., number of sides, symmetry) determines
its encoded color via a fixed mapping (e.g., square → 4, triangle → 5, hexagon →
7). A zigzag path (color 2) traverses the grid, indicating the gravity
direction: flood fill propagates downward along this path, alternating
left/right movement at each step while avoiding barriers. Enclosed regions are
detected by identifying disconnected components not connected to the grid
perimeter via background. The output replaces each enclosed region with its
shape-encoded color, preserves the zigzag path, and ensures flood fill stops at
barriers without overlapping. Barriers remain unchanged, and all transformations
follow strict visual rules without numerical dependencies.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Try until we produce a valid layout with at least two enclosed shapes
    for attempt in range(20):
        width = random.randint(8, 20)
        height = random.randint(8, 20)
        # create empty background
        ingrid = grid(width, height, 0)

        # Build a zigzag path (color 2) first so shapes avoid it
        # Start column strictly inside (not at edges) so zigzag moves are valid
        start_col = random.randint(1, width - 2)
        cols = [None] * height
        cols[0] = start_col
        for r in range(1, height):
            # Alternate direction each step: right on odd steps, left on even steps
            dir = 1 if (r % 2 == 1) else -1
            cand = cols[r - 1] + dir
            # If candidate is out of the safe inner range, try reversing direction
            if cand < 1 or cand > width - 2:
                cand = cols[r - 1] - dir
                # If still out of range, clamp into the safe inner band
                if cand < 1 or cand > width - 2:
                    cand = max(1, min(width - 2, cols[r - 1]))
            cols[r] = cand

        path_cells = set()
        for r in range(height):
            c = cols[r]
            ingrid[r][c] = 2
            path_cells.add((r, c))

        # Now place several non-overlapping closed barrier shapes (color 1)
        occupancy = set(path_cells)  # anything here must be avoided
        shapes = []
        target_shapes = random.randint(2, 5)
        place_attempts = 0
        while len(shapes) < target_shapes and place_attempts < 500:
            place_attempts += 1
            shape_type = random.choice(['rect', 'notch'])
            if shape_type == 'rect':
                W = random.randint(3, 7)
                H = random.randint(3, 7)
                min_r, max_r = 1, height - H - 1
                min_c, max_c = 1, width - W - 1
                if max_r < min_r or max_c < min_c:
                    continue
                top = random.randint(min_r, max_r)
                left = random.randint(min_c, max_c)
                # compute rectangle border
                border = set()
                for cc in range(left, left + W):
                    border.add((top, cc))
                    border.add((top + H - 1, cc))
                for rr in range(top, top + H):
                    border.add((rr, left))
                    border.add((rr, left + W - 1))
                # avoid collision
                if border & occupancy:
                    continue
                # place border
                for (r, c) in border:
                    ingrid[r][c] = 1
                    occupancy.add((r, c))
                shapes.append({'type': 'rect', 'top': top, 'left': left, 'W': W, 'H': H})
            else:
                # notch shape -- a rectangle with a single notch cut on the top-right area
                W = random.randint(4, 9)
                H = random.randint(4, 9)
                ns = random.randint(1, min(W - 2, H - 2))
                min_r, max_r = 1, height - H - 1
                min_c, max_c = 1, width - W - 1
                if max_r < min_r or max_c < min_c:
                    continue
                top = random.randint(min_r, max_r)
                left = random.randint(min_c, max_c)
                # vertices in order (axis aligned): v0->v1->v2->v3->v4->v5->v0
                v0 = (top, left)
                v1 = (top, left + W - 1)
                v2 = (top + ns, left + W - 1)
                v3 = (top + ns, left + W - 1 - ns)
                v4 = (top + H - 1, left + W - 1 - ns)
                v5 = (top + H - 1, left)
                verts = [v0, v1, v2, v3, v4, v5]
                border = set()
                ok = True
                for i in range(len(verts)):
                    r1, c1 = verts[i]
                    r2, c2 = verts[(i + 1) % len(verts)]
                    if r1 == r2:
                        for cc in range(min(c1, c2), max(c1, c2) + 1):
                            border.add((r1, cc))
                    elif c1 == c2:
                        for rr in range(min(r1, r2), max(r1, r2) + 1):
                            border.add((rr, c1))
                    else:
                        ok = False
                        break
                if not ok:
                    continue
                # avoid collision with path or other shapes
                if border & occupancy:
                    continue
                # ensure there is at least one interior cell that is not reserved by the path
                interior_ok = False
                for rr in range(top + 1, top + H - 1):
                    for cc in range(left + 1, left + W - 1):
                        if (rr, cc) not in border and (rr, cc) not in occupancy:
                            interior_ok = True
                            break
                    if interior_ok:
                        break
                if not interior_ok:
                    continue
                # place border
                for (r, c) in border:
                    ingrid[r][c] = 1
                    occupancy.add((r, c))
                shapes.append({'type': 'notch', 'top': top, 'left': left, 'W': W, 'H': H, 'ns': ns})

        # require at least two shapes; otherwise retry whole generation
        if len(shapes) < 2:
            continue

        # Build output grid by filling each enclosed region with a color derived from its boundary vertex count
        outgrid = [row[:] for row in ingrid]

        # identify outside-connected zeros using BFS from edges
        from collections import deque
        visited = [[False] * width for _ in range(height)]
        q = deque()
        for r in range(height):
            for c in (0, width - 1):
                if ingrid[r][c] == 0 and not visited[r][c]:
                    visited[r][c] = True
                    q.append((r, c))
        for c in range(width):
            for r in (0, height - 1):
                if ingrid[r][c] == 0 and not visited[r][c]:
                    visited[r][c] = True
                    q.append((r, c))
        while q:
            r, c = q.popleft()
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and ingrid[nr][nc] == 0:
                    visited[nr][nc] = True
                    q.append((nr, nc))

        # find enclosed zero regions and compute their boundary vertex counts
        region_id = [[-1] * width for _ in range(height)]
        regions = []
        cur_id = 0
        for r in range(height):
            for c in range(width):
                if ingrid[r][c] == 0 and not visited[r][c] and region_id[r][c] == -1:
                    # collect this region
                    region_cells = []
                    dq = deque([(r, c)])
                    region_id[r][c] = cur_id
                    while dq:
                        rr, cc = dq.popleft()
                        region_cells.append((rr, cc))
                        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                            nr, nc = rr + dr, cc + dc
                            if 0 <= nr < height and 0 <= nc < width and ingrid[nr][nc] == 0 and not visited[nr][nc] and region_id[nr][nc] == -1:
                                region_id[nr][nc] = cur_id
                                dq.append((nr, nc))
                    regions.append(region_cells)
                    cur_id += 1

        # For each region, gather boundary pixels and count corners
        for region in regions:
            boundary = set()
            for (r, c) in region:
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and ingrid[nr][nc] == 1:
                        boundary.add((nr, nc))
            if not boundary:
                continue
            # neighbors mapping for traversal
            neigh = {}
            for (br, bc) in boundary:
                neighs = []
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = br + dr, bc + dc
                    if (nr, nc) in boundary:
                        neighs.append((nr, nc))
                neigh[(br, bc)] = neighs
            start = min(boundary)
            ordered = [start]
            prev = None
            cur = start
            # traverse until we come back to start
            while True:
                candidates = neigh[cur]
                nxt = None
                if prev is None:
                    if candidates:
                        nxt = candidates[0]
                else:
                    for cand in candidates:
                        if cand != prev:
                            nxt = cand
                            break
                if nxt is None:
                    break
                if nxt == start:
                    break
                ordered.append(nxt)
                prev, cur = cur, nxt
                if len(ordered) > len(boundary) + 5:
                    break
            # compute corners by counting direction changes
            if len(ordered) < 2:
                color = 4
            else:
                # close the loop for direction calculation
                loop = ordered + [ordered[0]]
                dirs = []
                for i in range(len(ordered)):
                    r0, c0 = loop[i]
                    r1, c1 = loop[i + 1]
                    dirs.append((r1 - r0, c1 - c0))
                corner_count = 0
                prev_dir = dirs[-1]
                for d in dirs:
                    if d != prev_dir:
                        corner_count += 1
                    prev_dir = d
                color = corner_count if 3 <= corner_count <= 9 else 4
            # fill region in output
            for (r, c) in region:
                outgrid[r][c] = color

        return {'input': ingrid, 'output': outgrid}

    # If all attempts failed (extremely unlikely), produce a minimal safe example
    w, h = 8, 8
    ingrid = grid(w, h, 0)
    # simple rectangle in middle
    for c in range(2, 5):
        ingrid[2][c] = 1
        ingrid[5][c] = 1
    for r in range(2, 6):
        ingrid[r][2] = 1
        ingrid[r][4] = 1
    # zigzag path down middle
    for r in range(h):
        ingrid[r][3 if r % 2 == 0 else 4] = 2
    outgrid = [row[:] for row in ingrid]
    # fill the interior
    outgrid[3][3] = 4
    return {'input': ingrid, 'output': outgrid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    # convert to mutable grid
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # mark outside-connected zeros using BFS from edges
    visited = [[False] * width for _ in range(height)]
    q = deque()
    for r in range(height):
        for c in (0, width - 1):
            if grid[r][c] == 0 and not visited[r][c]:
                visited[r][c] = True
                q.append((r, c))
    for c in range(width):
        for r in (0, height - 1):
            if grid[r][c] == 0 and not visited[r][c]:
                visited[r][c] = True
                q.append((r, c))
    while q:
        r, c = q.popleft()
        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == 0:
                visited[nr][nc] = True
                q.append((nr, nc))

    # find enclosed zero regions
    region_id = [[-1] * width for _ in range(height)]
    regions = []
    cur_id = 0
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 and not visited[r][c] and region_id[r][c] == -1:
                cells = []
                dq = deque([(r, c)])
                region_id[r][c] = cur_id
                while dq:
                    rr, cc = dq.popleft()
                    cells.append((rr, cc))
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = rr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0 and not visited[nr][nc] and region_id[nr][nc] == -1:
                            region_id[nr][nc] = cur_id
                            dq.append((nr, nc))
                regions.append(cells)
                cur_id += 1

    # create output grid copy
    out = [row[:] for row in grid]

    # for each enclosed region compute its boundary and corner count
    for region in regions:
        boundary = set()
        for (r, c) in region:
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 1:
                    boundary.add((nr, nc))
        if not boundary:
            continue
        # adjacency map for boundary pixels
        neigh = {}
        for (br, bc) in boundary:
            nbs = []
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = br + dr, bc + dc
                if (nr, nc) in boundary:
                    nbs.append((nr, nc))
            neigh[(br, bc)] = nbs
        start = min(boundary)
        ordered = [start]
        prev = None
        cur = start
        # traverse boundary loop
        while True:
            candidates = neigh[cur]
            nxt = None
            if prev is None:
                if candidates:
                    nxt = candidates[0]
            else:
                for cand in candidates:
                    if cand != prev:
                        nxt = cand
                        break
            if nxt is None or nxt == start:
                break
            ordered.append(nxt)
            prev, cur = cur, nxt
            if len(ordered) > len(boundary) + 5:
                break
        # compute corner count by counting direction changes
        if len(ordered) < 2:
            color = 4
        else:
            loop = ordered + [ordered[0]]
            dirs = []
            for i in range(len(ordered)):
                r0, c0 = loop[i]
                r1, c1 = loop[i + 1]
                dirs.append((r1 - r0, c1 - c0))
            corner_count = 0
            prev_dir = dirs[-1]
            for d in dirs:
                if d != prev_dir:
                    corner_count += 1
                prev_dir = d
            color = corner_count if 3 <= corner_count <= 9 else 4
        # fill enclosed region
        for (r, c) in region:
            out[r][c] = color

    return out

