# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: edf9705c
Difficulty: insane

=== Tags ===
- Kinetic collision
- Mapping by size relation
- Dynamic channel painting
- Background filling
- Recolor object based on its size

=== Description ===
Input grids feature multiple non-overlapping axis-aligned rectangular blocks of
varying dimensions, each filled with a distinct color, positioned within a
uniform background. Blocks are arranged to form interconnected channels
(background regions) between them, with no two blocks overlapping or touching
diagonally. The grid dimensions range from 15×15 to 30×30, with channels forming
natural pathways through the background.  The output grid transformation
requires three sequential steps: 1. **Recolor blocks based on size relation**:
Each block is recolored according to whether its width exceeds its height
(wide), height exceeds width (tall), or width equals height (square). Wide
blocks become color A, tall blocks color B, square blocks color C. 2. **Dynamic
channel painting**: Every channel is filled with a color determined by the size
relation of its bounding blocks. Channels between a wide block and a tall block
use color D; channels between two blocks of the same size relation (e.g., two
wide blocks) use color E. 3. **Background filling**: Remaining background cells
(not part of channels or blocks) are filled with a color derived from the most
frequent size relation category (wide, tall, or square) across all blocks in the
input.  All transformations are deterministic and rely solely on visual size
comparisons between blocks, with no numerical computations or pixel-level
pattern matching required. The output must maintain the original grid dimensions
while applying these rules consistently across all blocks and channels.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(15, 30)
    height = random.randint(15, 30)
    grid = [[0] * width for _ in range(height)]
    num_blocks = random.randint(3, 5)
    used_colors = []
    blocks = []
    
    for _ in range(num_blocks):
        color = random.randint(1, 9)
        while color in used_colors:
            color = random.randint(1, 9)
        used_colors.append(color)
        
        w = random.randint(2, 5)
        h = random.randint(2, 5)
        placed = False
        for _ in range(100):
            r = random.randint(0, height - h)
            c = random.randint(0, width - w)
            valid = True
            for (br, bh, bc, bw, _) in blocks:
                if not (r + h <= br or r >= br + bh or c + w <= bc or c >= bc + bw):
                    valid = False
                    break
                if (r <= br + bh + 1 and r + h >= br - 1 and
                    c <= bc + bw + 1 and c + w >= bc - 1):
                    valid = False
                    break
            if valid:
                for i in range(r, r + h):
                    for j in range(c, c + w):
                        grid[i][j] = color
                blocks.append((r, h, c, w, color))
                placed = True
                break
        if not placed:
            r, c = 0, 0
            for i in range(r, r + h):
                for j in range(c, c + w):
                    grid[i][j] = color
            blocks.append((r, h, c, w, color))

    block_info = []
    for (r, h, c, w, color) in blocks:
        if w > h:
            block_type = 'wide'
            new_color = 1
        elif h > w:
            block_type = 'tall'
            new_color = 2
        else:
            block_type = 'square'
            new_color = 3
        block_info.append((r, h, c, w, color, block_type, new_color))

    type_count = {'wide': 0, 'tall': 0, 'square': 0}
    for _, _, _, _, _, block_type, _ in block_info:
        type_count[block_type] += 1
    majority_type = max(type_count, key=type_count.get)
    majority_color = 1 if majority_type == 'wide' else 2 if majority_type == 'tall' else 3

    output = [[0] * width for _ in range(height)]
    for (r, h, c, w, _, _, new_color) in block_info:
        for i in range(r, r + h):
            for j in range(c, c + w):
                output[i][j] = new_color

    for i in range(height):
        for j in range(width):
            if output[i][j] != 0:
                continue
            left_block = None
            right_block = None
            for (r, h, c, w, _, block_type, _) in block_info:
                if c + w == j and r <= i <= r + h:
                    left_block = block_type
                if c == j + 1 and r <= i <= r + h:
                    right_block = block_type
            if left_block and right_block:
                output[i][j] = 5 if left_block == right_block else 4
                continue
            
            top_block = None
            bottom_block = None
            for (r, h, c, w, _, block_type, _) in block_info:
                if r + h == i and c <= j <= c + w:
                    top_block = block_type
                if r == i + 1 and c <= j <= c + w:
                    bottom_block = block_type
            if top_block and bottom_block:
                output[i][j] = 5 if top_block == bottom_block else 4
                continue
            
            output[i][j] = majority_color

    return {'input': grid, 'output': output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    colors = set()
    for i in range(height):
        for j in range(width):
            if input_grid[i][j] != 0:
                colors.add(input_grid[i][j])
    
    blocks = []
    for color in colors:
        min_row = height
        max_row = -1
        min_col = width
        max_col = -1
        for i in range(height):
            for j in range(width):
                if input_grid[i][j] == color:
                    min_row = min(min_row, i)
                    max_row = max(max_row, i)
                    min_col = min(min_col, j)
                    max_col = max(max_col, j)
        blocks.append((min_row, max_row, min_col, max_col, color))

    block_info = []
    for (min_row, max_row, min_col, max_col, color) in blocks:
        block_width = max_col - min_col + 1
        block_height = max_row - min_row + 1
        if block_width > block_height:
            block_type = 'wide'
            new_color = 1
        elif block_height > block_width:
            block_type = 'tall'
            new_color = 2
        else:
            block_type = 'square'
            new_color = 3
        block_info.append((min_row, max_row, min_col, max_col, color, block_type, new_color))

    type_count = {'wide': 0, 'tall': 0, 'square': 0}
    for _, _, _, _, _, block_type, _ in block_info:
        type_count[block_type] += 1
    majority_type = max(type_count, key=type_count.get)
    majority_color = 1 if majority_type == 'wide' else 2 if majority_type == 'tall' else 3

    output = [[0] * width for _ in range(height)]
    for (min_row, max_row, min_col, max_col, _, _, new_color) in block_info:
        for i in range(min_row, max_row + 1):
            for j in range(min_col, max_col + 1):
                output[i][j] = new_color

    for i in range(height):
        for j in range(width):
            if output[i][j] != 0:
                continue
            left_block = None
            right_block = None
            for (min_row, max_row, min_col, max_col, _, block_type, _) in block_info:
                if max_col == j - 1 and min_row <= i <= max_row:
                    left_block = block_type
                if min_col == j + 1 and min_row <= i <= max_row:
                    right_block = block_type
            if left_block and right_block:
                output[i][j] = 5 if left_block == right_block else 4
                continue
            
            top_block = None
            bottom_block = None
            for (min_row, max_row, min_col, max_col, _, block_type, _) in block_info:
                if max_row == i - 1 and min_col <= j <= max_col:
                    top_block = block_type
                if min_row == i + 1 and min_col <= j <= max_col:
                    bottom_block = block_type
            if top_block and bottom_block:
                output[i][j] = 5 if top_block == bottom_block else 4
                continue
            
            output[i][j] = majority_color
    
    return output
