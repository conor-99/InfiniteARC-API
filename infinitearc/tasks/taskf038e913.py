# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: f038e913
Difficulty: hard

=== Tags ===
- Path merging
- Local convolution rule

=== Description ===
Input grids are large (20×20 or larger) with a single background color (0).
Overlaid on the background are multiple disjoint paths, each consisting of a
continuous sequence of cells sharing a unique color (1–9). Each path is either
horizontal, vertical, or contains a single gentle bend (≤45°), and paths are
separated by at least one background cell. No two paths share the same color,
and paths do not touch or overlap.  The output grid applies a local convolution
rule to merge paths that are parallel (same orientation) and separated by
exactly two background cells. For each background cell (0) that is horizontally
or vertically flanked by two different path colors (A and B) with exactly one
background cell between them (i.e., positions [i,j-1] = A, [i,j] = 0, [i,j+1] =
B or [i-1,j] = A, [i,j] = 0, [i+1,j] = B), the cell is replaced with a new color
C. The color C is determined by a fixed cyclic mapping: C = (A + B) mod 9 + 1
(e.g., paths of colors 1 and 2 merge to 3, 8 and 9 merge to 1). This rule is
applied to all valid cells in parallel, resulting in merged paths where two
parallel paths are connected through the new color. The merged paths appear as
continuous sequences of the new color, while all other elements (background,
unmapped paths, and original path colors) remain unchanged. The transformation
requires identifying spatial patterns (path separation and orientation) rather
than relying on numerical properties of the colors.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Generator for ARC task 468 (f038e913)
# Places disjoint paths (horizontal, vertical, or L-shaped) on a background and
# explicitly creates a few merge-pairs. The output is produced by applying the
# local convolution rule in parallel (horizontal priority, then vertical).

def generate():
    # Keep trying until we produce at least one merge (should be cheap)
    while True:
        width = random.randint(20, 30)
        height = random.randint(20, 30)
        g = grid(width, height, 0)

        occupied = set()    # set of (r,c) already colored
        used_colors = set() # colors already assigned to paths (1..9)

        def within(r, c):
            return 0 <= r < height and 0 <= c < width

        def neighbors8(r, c):
            for dr in (-1, 0, 1):
                for dc in (-1, 0, 1):
                    if dr == 0 and dc == 0:
                        continue
                    nr, nc = r + dr, c + dc
                    if within(nr, nc):
                        yield (nr, nc)

        def can_place(cells):
            # Cells must be inside, not already occupied, and must not touch existing
            # occupied cells (8-neighborhood), except neighbors that are also in cells.
            for (r, c) in cells:
                if not within(r, c):
                    return False
                if (r, c) in occupied:
                    return False
            for (r, c) in cells:
                for nb in neighbors8(r, c):
                    if nb in occupied and nb not in cells:
                        return False
            return True

        def place(cells, color):
            for (r, c) in cells:
                g[r][c] = color
                occupied.add((r, c))

        def new_color():
            avail = [c for c in range(1, 10) if c not in used_colors]
            if not avail:
                # Shouldn't normally happen because we cap total paths <= 9,
                # but fall back to any color if it does.
                return random.randint(1, 9)
            c = random.choice(avail)
            used_colors.add(c)
            return c

        # 1) Explicitly create a small number of merge pairs (each pair yields two paths)
        merges_to_create = random.randint(1, 3)
        merges_created = 0
        attempts = 0
        while merges_created < merges_to_create and attempts < 1000:
            attempts += 1
            orientation = random.choice(['h', 'v'])
            L1 = random.randint(2, 6)
            L2 = random.randint(2, 6)

            if orientation == 'h':
                # center column m will remain background (0); left segment ends at m-1,
                # right segment starts at m+1
                m_min = L1
                m_max = width - 1 - L2
                if m_min > m_max:
                    continue
                m = random.randint(m_min, m_max)
                r = random.randint(0, height - 1)
                left = [(r, c) for c in range(m - L1, m)]
                right = [(r, c) for c in range(m + 1, m + 1 + L2)]
                # Ensure these two segments can be placed without touching others
                if not can_place(left + right):
                    continue
                # Ensure the center cell is not already adjacent to other colors vertically
                if r - 1 >= 0 and (r - 1, m) in occupied:
                    continue
                if r + 1 < height and (r + 1, m) in occupied:
                    continue

                ca = new_color()
                cb = new_color()
                # defensive: force distinct colors if possible
                if ca == cb:
                    for tryc in range(1, 10):
                        if tryc not in used_colors:
                            cb = tryc
                            used_colors.add(cb)
                            break
                    if ca == cb:
                        # last resort: pick a different color arithmetically
                        cb = (ca % 9) + 1
                        if cb not in used_colors:
                            used_colors.add(cb)

                place(left, ca)
                place(right, cb)
                merges_created += 1

            else:  # orientation == 'v'
                # center row m will remain background (0); top segment ends at m-1,
                # bottom segment starts at m+1
                m_min = L1
                m_max = height - 1 - L2
                if m_min > m_max:
                    continue
                m = random.randint(m_min, m_max)
                c = random.randint(0, width - 1)
                top = [(r, c) for r in range(m - L1, m)]
                bottom = [(r, c) for r in range(m + 1, m + 1 + L2)]
                if not can_place(top + bottom):
                    continue
                # Avoid horizontal interference at the center cell
                if c - 1 >= 0 and (m, c - 1) in occupied:
                    continue
                if c + 1 < width and (m, c + 1) in occupied:
                    continue

                ca = new_color()
                cb = new_color()
                if ca == cb:
                    for tryc in range(1, 10):
                        if tryc not in used_colors:
                            cb = tryc
                            used_colors.add(cb)
                            break
                    if ca == cb:
                        cb = (ca % 9) + 1
                        if cb not in used_colors:
                            used_colors.add(cb)

                place(top, ca)
                place(bottom, cb)
                merges_created += 1

        # 2) Add additional random paths until we reach a modest total number of paths (<=9)
        min_paths = max(4, len(used_colors))
        max_paths = 9
        if min_paths > max_paths:
            min_paths = len(used_colors)
        total_paths = random.randint(min_paths, max_paths)

        path_attempts = 0
        while len(used_colors) < total_paths and path_attempts < 2000:
            path_attempts += 1
            typ = random.choice(['h', 'v', 'l'])
            if typ == 'h':
                L = random.randint(2, 8)
                r = random.randint(0, height - 1)
                if L > width:
                    continue
                c0 = random.randint(0, width - L)
                cells = [(r, c) for c in range(c0, c0 + L)]
                if not can_place(cells):
                    continue
                ccol = new_color()
                place(cells, ccol)

            elif typ == 'v':
                L = random.randint(2, 8)
                c = random.randint(0, width - 1)
                if L > height:
                    continue
                r0 = random.randint(0, height - L)
                cells = [(r, c) for r in range(r0, r0 + L)]
                if not can_place(cells):
                    continue
                ccol = new_color()
                place(cells, ccol)

            else:  # L-shaped
                L1 = random.randint(2, 5)
                L2 = random.randint(2, 5)
                # Choose pivot with margins
                r = random.randint(0, height - 1)
                c = random.randint(0, width - 1)
                # directions for the two arms
                dc = random.choice([-1, 1])
                dr = random.choice([-1, 1])
                arm1 = [(r, c + i * dc) for i in range(0, L1)]
                arm2 = [(r + i * dr, c) for i in range(1, L2)]  # pivot (r,c) shared
                cells = []
                valid = True
                for (rr, cc) in arm1 + arm2:
                    if not within(rr, cc):
                        valid = False
                        break
                    cells.append((rr, cc))
                if not valid:
                    continue
                # ensure uniqueness of cells (pivot duplicated in arm1 and arm2)
                cells = list(dict.fromkeys(cells))
                if not can_place(cells):
                    continue
                ccol = new_color()
                place(cells, ccol)

        # 3) Compute output by applying the local convolution rule in parallel.
        output = [row[:] for row in g]
        # Horizontal priority: apply horizontal merges first (based on input g), then
        # apply vertical merges only where a cell hasn't been changed by horizontal.
        for r in range(height):
            for c in range(1, width - 1):
                if g[r][c] == 0:
                    left = g[r][c - 1]
                    right = g[r][c + 1]
                    if left != 0 and right != 0 and left != right:
                        output[r][c] = (left + right) % 9 + 1
        for r in range(1, height - 1):
            for c in range(width):
                if g[r][c] == 0 and output[r][c] == 0:
                    up = g[r - 1][c]
                    down = g[r + 1][c]
                    if up != 0 and down != 0 and up != down:
                        output[r][c] = (up + down) % 9 + 1

        # Ensure at least one cell changed (i.e., at least one merge happened).
        changed = False
        for r in range(height):
            for c in range(width):
                if g[r][c] != output[r][c]:
                    changed = True
                    break
            if changed:
                break
        if not changed:
            # Try again if no merge occurred (rare but safe)
            continue

        return {
            "input": g,
            "output": output
        }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    g = [list(row) for row in input_grid]
    h = len(g)
    w = len(g[0]) if h > 0 else 0

    # Copy input to output and apply the same parallel local rule as generator.
    out = [row[:] for row in g]

    # Horizontal priority: compute horizontal merges first based on the original input
    for r in range(h):
        for c in range(1, w - 1):
            if g[r][c] == 0:
                left = g[r][c - 1]
                right = g[r][c + 1]
                if left != 0 and right != 0 and left != right:
                    out[r][c] = (left + right) % 9 + 1

    # Then vertical merges only where not already filled by horizontal step
    for r in range(1, h - 1):
        for c in range(w):
            if g[r][c] == 0 and out[r][c] == 0:
                up = g[r - 1][c]
                down = g[r + 1][c]
                if up != 0 and down != 0 and up != down:
                    out[r][c] = (up + down) % 9 + 1

    return out

