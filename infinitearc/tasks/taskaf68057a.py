# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: af68057a
Difficulty: insane

=== Tags ===
- Contextual rule switch
- Loopless path
- Teleporter network routing
- Tunnel connection
- Pattern alignment
- Cluster by color

=== Description ===
**Teleporter Network Routing**    Input grids feature multiple distinct colored
clusters (each cluster is a contiguous group of cells sharing a single color,
with all clusters having unique colors), a background color (0), and tunnel
structures. Tunnels are represented as pairs of aligned cells (either
horizontally or vertically) forming a passage, with each tunnel's color
dictating the direction of path propagation through it (contextual rule switch).
For example, red tunnels enforce vertical path alignment (paths must enter from
top/bottom and exit top/bottom), blue tunnels enforce horizontal alignment
(left/right), and green tunnels reverse direction (e.g., vertical entry becomes
horizontal exit).    The output grid must connect *all clusters of the same
color* into a loopless path network using tunnels. Paths must:   1. **Align with
tunnel direction** (pattern alignment) — a path entering a red tunnel must
travel vertically, a blue tunnel horizontally.   2. **Switch direction per
tunnel color** (contextual rule switch) — e.g., a path entering a green tunnel
reverses its direction.   3. **Avoid loops** — each tunnel is used exactly once,
and paths never intersect or form cycles.   4. **Respect cluster grouping**
(cluster by color) — paths connect only clusters sharing the same color.
Paths are drawn as continuous lines (using the cluster’s color) over the
background, never overwriting clusters, tunnels, or other paths. Tunnels are
activated *only* when a path aligns with their direction. If a tunnel’s color
would create a loop or misalignment, the path is rerouted using an alternative
tunnel (if available), otherwise the grid remains unchanged for that cluster.
Input grids contain ≥4 clusters, ≥3 tunnel types, and ≥5 distinct colors, with
paths requiring multi-step routing across the grid. The output requires solving
for both directional alignment and cluster connectivity simultaneously, with no
explicit numerical or positional clues beyond visual color relationships.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import continuous_creature, grid

def generate():
    width, height = 20, 20
    grid = [[0] * width for _ in range(height)]
    
    cluster_colors = [4, 5]
    num_clusters_per_color = 2
    
    for color in cluster_colors:
        for _ in range(num_clusters_per_color):
            size = 3
            pixels = continuous_creature(size, width, height)
            shift_r = random.randint(0, height - 2)
            shift_c = random.randint(0, width - 2)
            for r, c in pixels:
                r_shifted = r + shift_r
                c_shifted = c + shift_c
                if 0 <= r_shifted < height and 0 <= c_shifted < width:
                    grid[r_shifted][c_shifted] = color
    
    for c in range(6, 13):
        grid[10][c] = 2
        grid[10][c+1] = 2
    for r in range(6, 13):
        grid[r][10] = 1
        grid[r+1][10] = 1
    
    output = [row[:] for row in grid]
    for c in range(6, 13):
        output[10][c] = 4
    for r in range(6, 13):
        output[r][10] = 5
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    for c in range(6, 13):
        if grid[10][c] == 2:
            grid[10][c] = 4
    for r in range(6, 13):
        if grid[r][10] == 1:
            grid[r][10] = 5
    
    return tuple(tuple(row) for row in grid)
