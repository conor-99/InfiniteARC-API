# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 04c077d2
Difficulty: hard

=== Tags ===
- Chain reaction
- Rule embedding
- Meta rule switching
- Mark wall impact
- Create grid

=== Description ===
Input grids feature a complex arrangement of colored walls (1-8) forming
horizontal or vertical barriers, a single starting cell (color 9) positioned
away from walls, and background (color 0). Walls are isolated, non-adjacent, and
never intersect. The transformation initiates at the starting cell, moving east
by default. As the chain reaction propagates:  1. Background cells along the
path are replaced with path color (color 5) in the output. 2. Upon encountering
a wall (color c), the wall's color increments by 1 (mod 9, excluding 0), and the
direction changes based on the *new* wall color (e.g., color 1 → left turn,
color 2 → right turn, color 3 → reverse direction). 3. The direction mapping
(wall color → turn direction) is embedded in the grid structure and must be
inferred from examples. 4. Walls hit during propagation are marked by their
color increment, and the reaction continues until the path exits the grid.
Output grids display the transformed path (color 5) and all impacted walls with
incremented colors. The challenge lies in deducing the direction mapping from
the wall colors through visual pattern recognition, as the rule is not
explicitly stated but embedded in the grid's color relationships. The solution
requires sequential rule application where wall impacts dynamically alter
subsequent movement rules (meta rule switching), creating a cascading
transformation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 10)
    height = random.randint(5, 10)
    grid = [[0] * width for _ in range(height)]
    
    start_r = random.randint(1, height-2)
    start_c = random.randint(1, width-2)
    grid[start_r][start_c] = 9
    
    grid[start_r][start_c + 1] = random.randint(1, 8)
    
    for _ in range(random.randint(2, 5)):
        orientation = random.choice(['horizontal', 'vertical'])
        if orientation == 'horizontal':
            r = random.randint(0, height-1)
            c_start = random.randint(0, width-3)
            length = random.randint(1, 3)
            color = random.randint(1, 8)
            valid = True
            for c in range(c_start, c_start + length):
                for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                        valid = False
                        break
                if not valid:
                    break
            if not valid:
                continue
            for c in range(c_start, c_start + length):
                grid[r][c] = color
        else:
            c = random.randint(0, width-1)
            r_start = random.randint(0, height-3)
            length = random.randint(1, 3)
            color = random.randint(1, 8)
            valid = True
            for r in range(r_start, r_start + length):
                for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                        valid = False
                        break
                if not valid:
                    break
            if not valid:
                continue
            for r in range(r_start, r_start + length):
                grid[r][c] = color
    
    output = [row[:] for row in grid]
    r, c = start_r, start_c
    dr, dc = 0, 1  # east
    direction_map = {
        1: (-1, 0),
        2: (0, 1),
        3: (0, -1),
        4: (-1, 0),
        5: (0, 1),
        6: (0, -1),
        7: (-1, 0),
        8: (0, 1),
        9: (0, -1)
    }
    
    while True:
        nr = r + dr
        nc = c + dc
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        if grid[nr][nc] == 0:
            output[nr][nc] = 5
            r, c = nr, nc
        else:
            wall_color = grid[nr][nc]
            new_color = (wall_color + 1) % 9
            if new_color == 0:
                new_color = 9
            output[nr][nc] = new_color
            dr, dc = direction_map[new_color]
            r, c = nr, nc
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    start_r, start_c = -1, -1
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 9:
                start_r, start_c = r, c
                break
        if start_r != -1:
            break
    
    direction_map = {
        1: (-1, 0),
        2: (0, 1),
        3: (0, -1),
        4: (-1, 0),
        5: (0, 1),
        6: (0, -1),
        7: (-1, 0),
        8: (0, 1),
        9: (0, -1)
    }
    
    dr, dc = 0, 1
    r, c = start_r, start_c
    output = [row[:] for row in grid]
    
    while True:
        nr = r + dr
        nc = c + dc
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        if grid[nr][nc] == 0:
            output[nr][nc] = 5
            r, c = nr, nc
        else:
            wall_color = grid[nr][nc]
            new_color = (wall_color + 1) % 9
            if new_color == 0:
                new_color = 9
            output[nr][nc] = new_color
            dr, dc = direction_map[new_color]
            r, c = nr, nc
    return tuple(tuple(row) for row in output)
