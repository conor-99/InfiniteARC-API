# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 922b2457
Difficulty: insane

=== Tags ===
- Color transfer on contact
- Intersecting currents
- Image resizing
- Detect closed curves

=== Description ===
# Interlocking Currents and Closed Loops  Input grids feature a complex
arrangement of straight-line colored paths ("currents") and closed-loop
structures ("closed curves") on a grid of size 15×15 to 30×30. Each current is a
continuous horizontal or vertical path of uniform color extending across the
grid, while each closed curve forms a perfect loop of uniform color enclosing a
region. Closed curves are defined by cells where every boundary cell has exactly
two adjacent cells of the same color (forming a cycle), with the enclosed
interior region being completely surrounded.  The transformation to output grids
follows four sequential steps:  1. **Closed Curve Detection**: Identify all
closed curves by detecting cyclic patterns of uniform color with no branches or
gaps. For each closed curve, determine its interior region (all cells enclosed
by the loop, excluding the boundary).  2. **Color Transfer on Contact**: For
every current that intersects a closed curve's boundary, transfer the current's
color to every cell within the closed curve's interior. The boundary cells of
the closed curve remain unchanged, but all interior cells adopt the current's
color.  3. **Intersecting Currents**: At cells where two or more currents
intersect (cross at a single cell), combine their colors using a predefined
mapping (e.g., red + blue = purple). If an intersection occurs within a closed
curve's interior (after color transfer), the color becomes the transferred
current's color rather than a combination.  4. **Image Resizing**: Resize the
output grid to the minimal bounding box containing all closed curves and their
interiors after color transfer. This involves cropping the grid to the smallest
rectangle that encompasses all affected cells (interiors and their boundaries),
removing all rows and columns outside this region while preserving relative
positions.  The output grid must maintain all visual relationships: closed curve
boundaries remain visible, color transfers are applied precisely to interiors,
intersecting currents produce combined colors at crossings, and the grid is
precisely cropped to the minimal region containing all transformed features. The
task requires detecting closed loops among cluttered paths, applying layered
color rules, and performing spatial resizing—all while avoiding any loops or
self-intersections in the processing.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import random_color

def generate():
    # Grid size
    width = random.randint(15, 30)
    height = random.randint(15, 30)
    grid = [[0 for _ in range(width)] for _ in range(height)]

    curves = []  # list of tuples (r, c, w, h, color)
    occupied = set()  # cells reserved for curves (perimeter area + padding)

    # Place 2 or 3 non-overlapping rectangular closed curves (perimeters)
    num_curves = random.choice([2, 3])
    attempts = 0
    while len(curves) < num_curves and attempts < 1000:
        attempts += 1
        # choose rectangle size ensuring at least a 1-cell margin from edges
        max_w = max(4, min(12, width - 4))
        max_h = max(4, min(12, height - 4))
        w = random.randint(4, max_w)
        h = random.randint(4, max_h)
        if w >= width - 1: w = max(4, width - 3)
        if h >= height - 1: h = max(4, height - 3)
        r_max = max(1, height - h - 1)
        c_max = max(1, width - w - 1)
        r = random.randint(1, r_max)
        c = random.randint(1, c_max)

        # avoid overlapping (keep a one-cell padding around each rectangle)
        ok = True
        for rr in range(r - 1, r + h + 1):
            for cc in range(c - 1, c + w + 1):
                if 0 <= rr < height and 0 <= cc < width and (rr, cc) in occupied:
                    ok = False
                    break
            if not ok:
                break
        if not ok:
            continue

        color = random_color(exclude=[0] + [cv[4] for cv in curves])
        # draw perimeter
        for col_idx in range(c, c + w):
            grid[r][col_idx] = color
            grid[r + h - 1][col_idx] = color
        for row_idx in range(r + 1, r + h - 1):
            grid[row_idx][c] = color
            grid[row_idx][c + w - 1] = color

        # mark occupied region (with padding)
        for rr in range(r - 1, r + h + 1):
            for cc in range(c - 1, c + w + 1):
                if 0 <= rr < height and 0 <= cc < width:
                    occupied.add((rr, cc))

        curves.append((r, c, w, h, color))

    if not curves:
        # fallback: ensure at least one curve (shouldn't happen with above logic)
        r, c, w, h = 2, 2, 6, 6
        color = random_color(exclude=[0])
        for col_idx in range(c, c + w):
            grid[r][col_idx] = color
            grid[r + h - 1][col_idx] = color
        for row_idx in range(r + 1, r + h - 1):
            grid[row_idx][c] = color
            grid[row_idx][c + w - 1] = color
        curves.append((r, c, w, h, color))

    # Decide a single orientation for currents (avoid producing overlapping intersections to keep logic stable)
    orientation_main = random.choice(['h', 'v'])

    currents = []  # ('h', row, start, end, color) or ('v', col, start, end, color)
    used = set()  # cells used by currents (to avoid overlap)
    # mark curve perimeter as used to avoid drawing currents over boundaries
    for (rr, cc, ww, hh, col) in curves:
        for col_idx in range(cc, cc + ww):
            used.add((rr, col_idx)); used.add((rr + hh - 1, col_idx))
        for row_idx in range(rr + 1, rr + hh - 1):
            used.add((row_idx, cc)); used.add((row_idx, cc + ww - 1))

    # Force at least one current that contacts one of the curves (adjacent contact)
    chosen_curve = random.choice(curves)
    cr, cc, cw, ch, ccolor = chosen_curve
    contact_placed = False

    # Helper: place a horizontal segment at specified row spanning [start,end]
    def place_horizontal(row, start, end, color):
        for col_idx in range(start, end + 1):
            grid[row][col_idx] = color
            used.add((row, col_idx))
        currents.append(('h', row, start, end, color))

    # Helper: place a vertical segment at specified col spanning [start,end]
    def place_vertical(col_idx, start, end, color):
        for row_idx in range(start, end + 1):
            grid[row_idx][col_idx] = color
            used.add((row_idx, col_idx))
        currents.append(('v', col_idx, start, end, color))

    # Try to place a contacting current adjacent to the chosen curve on a side compatible with orientation_main
    sides = []
    if cr - 1 >= 0:
        sides.append(('top', cr - 1))
    if cr + ch < height:
        sides.append(('bottom', cr + ch))
    if cc - 1 >= 0:
        sides.append(('left', cc - 1))
    if cc + cw < width:
        sides.append(('right', cc + cw))

    random.shuffle(sides)
    for side, pos in sides:
        if orientation_main == 'h' and side in ('top', 'bottom'):
            row = pos
            # choose a horizontal segment that overlaps (in column) at least one boundary column to guarantee contact
            length = random.randint(3, min(10, width))
            # attempt to find a start so that segment stays in bounds and doesn't hit used cells
            attempts_seg = 0
            while attempts_seg < 200:
                attempts_seg += 1
                start = random.randint(0, max(0, width - length))
                end = start + length - 1
                # require at least one column in [start,end] to be within curve's columns to ensure adjacency
                overlap = max(start, cc) <= min(end, cc + cw - 1)
                if not overlap:
                    continue
                # ensure all cells free of used
                collision = any((row, col_idx) in used for col_idx in range(start, end + 1))
                if collision:
                    continue
                color = random_color(exclude=[0] + [cv[4] for cv in curves])
                place_horizontal(row, start, end, color)
                contact_placed = True
                break
            if contact_placed:
                break
        if orientation_main == 'v' and side in ('left', 'right'):
            col_idx = pos
            length = random.randint(3, min(10, height))
            attempts_seg = 0
            while attempts_seg < 200:
                attempts_seg += 1
                start = random.randint(0, max(0, height - length))
                end = start + length - 1
                overlap = max(start, cr) <= min(end, cr + ch - 1)
                if not overlap:
                    continue
                collision = any((row_idx, col_idx) in used for row_idx in range(start, end + 1))
                if collision:
                    continue
                color = random_color(exclude=[0] + [cv[4] for cv in curves])
                place_vertical(col_idx, start, end, color)
                contact_placed = True
                break
            if contact_placed:
                break

    # If for some reason no contacting current placed (rare), try a flexible placement (allow other orientation)
    if not contact_placed:
        # try any side with any orientation
        for side, pos in sides:
            if side in ('top', 'bottom'):
                row = pos
                length = random.randint(3, min(10, width))
                attempts_seg = 0
                while attempts_seg < 200:
                    attempts_seg += 1
                    start = random.randint(0, max(0, width - length))
                    end = start + length - 1
                    overlap = max(start, cc) <= min(end, cc + cw - 1)
                    if not overlap:
                        continue
                    collision = any((row, col_idx) in used for col_idx in range(start, end + 1))
                    if collision:
                        continue
                    color = random_color(exclude=[0] + [cv[4] for cv in curves])
                    place_horizontal(row, start, end, color)
                    contact_placed = True
                    break
                if contact_placed:
                    break
            else:
                col_idx = pos
                length = random.randint(3, min(10, height))
                attempts_seg = 0
                while attempts_seg < 200:
                    attempts_seg += 1
                    start = random.randint(0, max(0, height - length))
                    end = start + length - 1
                    overlap = max(start, cr) <= min(end, cr + ch - 1)
                    if not overlap:
                        continue
                    collision = any((row_idx, col_idx) in used for row_idx in range(start, end + 1))
                    if collision:
                        continue
                    color = random_color(exclude=[0] + [cv[4] for cv in curves])
                    place_vertical(col_idx, start, end, color)
                    contact_placed = True
                    break
                if contact_placed:
                    break

    # Now place a handful of other currents (same orientation) ensuring they don't overlap perimeters or existing currents
    total_currents = random.randint(3, 5)
    tries = 0
    while len(currents) < total_currents and tries < 1000:
        tries += 1
        color = random_color(exclude=[0] + [cv[4] for cv in curves])
        if orientation_main == 'h':
            row = random.randint(0, height - 1)
            length = random.randint(3, min(10, width))
            start = random.randint(0, max(0, width - length))
            end = start + length - 1
            # avoid collisions
            if any((row, cc_idx) in used for cc_idx in range(start, end + 1)):
                continue
            place_horizontal(row, start, end, color)
        else:
            col_idx = random.randint(0, width - 1)
            length = random.randint(3, min(10, height))
            start = random.randint(0, max(0, height - length))
            end = start + length - 1
            if any((rr_idx, col_idx) in used for rr_idx in range(start, end + 1)):
                continue
            place_vertical(col_idx, start, end, color)

    # Save the input grid (before interior fills)
    input_grid = [row[:] for row in grid]

    # Function to combine two colors deterministically (used if multiple contacting currents occur)
    def combine(a, b):
        s = (a + b) % 9
        return 9 if s == 0 else s

    # Create output grid by copying and then filling interiors according to contacting currents
    out_grid = [row[:] for row in grid]

    # For each curve, find contacting current colors (adjacent 4-neighbors to any perimeter cell)
    for (r, c, w, h, curve_color) in curves:
        contacting = set()
        # perimeter cells
        perim = []
        for col_idx in range(c, c + w):
            perim.append((r, col_idx))
            perim.append((r + h - 1, col_idx))
        for row_idx in range(r + 1, r + h - 1):
            perim.append((row_idx, c))
            perim.append((row_idx, c + w - 1))
        # check neighbors
        for (pr, pc) in perim:
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nr, nc = pr + dr, pc + dc
                if nr < 0 or nr >= height or nc < 0 or nc >= width:
                    continue
                val = grid[nr][nc]
                if val == 0:
                    continue
                if val == curve_color:
                    continue
                # treat any non-curve color neighbor as a contacting current color
                contacting.add(val)
        if contacting:
            # deterministic combine: sort and combine sequentially
            sorted_colors = sorted(contacting)
            color_val = sorted_colors[0]
            for colv in sorted_colors[1:]:
                color_val = combine(color_val, colv)
            # fill interior (exclude boundary)
            for rr in range(r + 1, r + h - 1):
                for cc_idx in range(c + 1, c + w - 1):
                    out_grid[rr][cc_idx] = color_val
        # ensure boundary cells retain curve color (in case anything overlapped)
        for col_idx in range(c, c + w):
            out_grid[r][col_idx] = curve_color
            out_grid[r + h - 1][col_idx] = curve_color
        for row_idx in range(r + 1, r + h - 1):
            out_grid[row_idx][c] = curve_color
            out_grid[row_idx][c + w - 1] = curve_color

    # Crop output to minimal bounding box that contains all curves (their boundaries and interiors)
    min_r = min(curve[0] for curve in curves)
    max_r = max(curve[0] + curve[3] - 1 for curve in curves)
    min_c = min(curve[1] for curve in curves)
    max_c = max(curve[1] + curve[2] - 1 for curve in curves)

    cropped_output = [row[min_c:max_c + 1] for row in out_grid[min_r:max_r + 1]]

    return {"input": input_grid, "output": cropped_output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height else 0

    # Helper combine mapping (must match generator)
    def combine(a, b):
        s = (a + b) % 9
        return 9 if s == 0 else s

    # Step 1: detect closed rectangular curves
    curves = []  # list of (r, c, w, h, color)
    visited_colors = set()
    colors = set()
    for r in range(height):
        for c in range(width):
            val = grid[r][c]
            if val != 0:
                colors.add(val)
    # Try each color and see if it forms a rectangular perimeter
    for color in sorted(colors):
        # collect positions of this color
        positions = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == color]
        if not positions:
            continue
        min_r = min(p[0] for p in positions)
        max_r = max(p[0] for p in positions)
        min_c = min(p[1] for p in positions)
        max_c = max(p[1] for p in positions)
        w = max_c - min_c + 1
        h = max_r - min_r + 1
        if w < 3 or h < 3:
            continue
        # expected number of perimeter cells
        expected = 2 * (w + h) - 4
        if len(positions) != expected:
            continue
        # check all perimeter cells are this color and interior is not this color
        ok = True
        for cc in range(min_c, max_c + 1):
            if grid[min_r][cc] != color or grid[max_r][cc] != color:
                ok = False
                break
        if not ok:
            continue
        for rr in range(min_r + 1, max_r):
            if grid[rr][min_c] != color or grid[rr][max_c] != color:
                ok = False
                break
        if not ok:
            continue
        # interior must not contain the same color
        interior_ok = True
        for rr in range(min_r + 1, max_r):
            for cc in range(min_c + 1, max_c):
                if grid[rr][cc] == color:
                    interior_ok = False
                    break
            if not interior_ok:
                break
        if not interior_ok:
            continue
        # accept as a closed rectangular curve
        curves.append((min_r, min_c, w, h, color))
        visited_colors.add(color)

    # Step 2: detect currents (horizontal and vertical continuous segments of uniform color)
    currents = []
    curve_colors = set(cur[4] for cur in curves)

    # horizontal
    for r in range(height):
        c = 0
        while c < width:
            if grid[r][c] != 0 and grid[r][c] not in curve_colors:
                start = c
                color = grid[r][start]
                while c < width and grid[r][c] == color:
                    c += 1
                length = c - start
                if length >= 3:
                    currents.append(('h', r, start, c - 1, color))
            else:
                c += 1

    # vertical
    for c in range(width):
        r = 0
        while r < height:
            if grid[r][c] != 0 and grid[r][c] not in curve_colors:
                start = r
                color = grid[start][c]
                while r < height and grid[r][c] == color:
                    r += 1
                length = r - start
                if length >= 3:
                    currents.append(('v', c, start, r - 1, color))
            else:
                r += 1

    # Step 3 and 4: For each curve, find contacting currents (adjacent to any boundary cell)
    out_grid = [row[:] for row in grid]
    for (r, c, w, h, curve_color) in curves:
        contacting = set()
        # perimeter positions
        perim = []
        for cc in range(c, c + w):
            perim.append((r, cc))
            perim.append((r + h - 1, cc))
        for rr in range(r + 1, r + h - 1):
            perim.append((rr, c))
            perim.append((rr, c + w - 1))
        # check neighbors for currents
        for (pr, pc) in perim:
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nr, nc = pr + dr, pc + dc
                if nr < 0 or nr >= height or nc < 0 or nc >= width:
                    continue
                val = grid[nr][nc]
                if val == 0 or val == curve_color:
                    continue
                contacting.add(val)
        if contacting:
            # combine deterministically (sorted order)
            sorted_colors = sorted(contacting)
            color_val = sorted_colors[0]
            for colv in sorted_colors[1:]:
                color_val = combine(color_val, colv)
            # fill interior (preserve boundaries)
            for rr in range(r + 1, r + h - 1):
                for cc in range(c + 1, c + w - 1):
                    out_grid[rr][cc] = color_val
        # restore boundary color to be safe
        for cc in range(c, c + w):
            out_grid[r][cc] = curve_color
            out_grid[r + h - 1][cc] = curve_color
        for rr in range(r + 1, r + h - 1):
            out_grid[rr][c] = curve_color
            out_grid[rr][c + w - 1] = curve_color

    # Crop to minimal bounding box that contains all curves
    if curves:
        min_r = min(cur[0] for cur in curves)
        max_r = max(cur[0] + cur[3] - 1 for cur in curves)
        min_c = min(cur[1] for cur in curves)
        max_c = max(cur[1] + cur[2] - 1 for cur in curves)
    else:
        min_r, max_r, min_c, max_c = 0, height - 1, 0, width - 1

    result = [row[min_c:max_c + 1] for row in out_grid[min_r:max_r + 1]]
    return result

