# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 97263dfc
Difficulty: medium–hard

=== Tags ===
- Pattern alignment
- Path following

=== Description ===
Input grids feature a background color (0), a continuous path of color 1
(composed of connected cells), and a secondary pattern of color 2 forming a grid
of right-pointing arrows (→) spaced periodically across the grid. The arrows
consistently point right, indicating the required alignment direction. The path
may be diagonal, vertical, or horizontal but is not aligned with the right-
pointing direction.  The output grid transforms the path so that it aligns with
the right-pointing direction. Each cell in the path is shifted horizontally to
the right while maintaining its vertical position, resulting in a continuous
horizontal path. The transformation preserves the path's length, with the
starting cell moving right to the first available background cell and subsequent
cells extending horizontally. The arrow pattern remains unchanged, and no path
cells overlap with the pattern or background. The output path is drawn using
color 1, and the alignment direction is strictly enforced through the pattern's
consistent arrow orientation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid_input = [[0] * width for _ in range(height)]
    
    path_length = random.randint(3, 5)
    for i in range(path_length):
        r, c = i, i
        if r < height and c < width:
            grid_input[r][c] = 1
    
    spacing = random.randint(3, 5)
    for r in range(0, height, spacing):
        for c in range(0, width, spacing):
            if grid_input[r][c] == 0:
                grid_input[r][c] = 2
    
    grid_output = [row[:] for row in grid_input]
    path_cells = []
    for r in range(height):
        for c in range(width):
            if grid_input[r][c] == 1:
                path_cells.append((r, c))
    
    if not path_cells:
        return {
            "input": grid_input,
            "output": grid_input
        }
    
    start_r, start_c = min(path_cells, key=lambda x: (x[0], x[1]))
    
    # Clear original path
    for r, c in path_cells:
        grid_output[r][c] = 0
    
    # Draw transformed path
    for r, c in path_cells:
        new_c = c + (r - start_r)
        new_r = start_r
        if new_r < height and new_c < width:
            grid_output[new_r][new_c] = 1
    
    if grid_input == grid_output:
        return generate()
    
    return {
        "input": grid_input,
        "output": grid_output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    path_cells = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 1:
                path_cells.append((r, c))
    
    if not path_cells:
        return grid
    
    start_r, start_c = min(path_cells, key=lambda x: (x[0], x[1]))
    
    output = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if output[r][c] == 1:
                output[r][c] = 0
    
    for r, c in path_cells:
        new_c = c + (r - start_r)
        new_r = start_r
        if 0 <= new_r < height and 0 <= new_c < width:
            output[new_r][new_c] = 1
    
    return output
