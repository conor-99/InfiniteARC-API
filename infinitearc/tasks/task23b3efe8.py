# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 23b3efe8
Difficulty: medium

=== Tags ===
- Associate colors to images
- Extrapolate image from grid

=== Description ===
The task involves transforming an input grid into an output grid where each
cell's color value directly determines the size and appearance of a
corresponding block in the output. Each cell in the input grid contains a color
value between 1 and 9 (inclusive), which represents the side length of a square
block in the output grid. For example, a cell with color `3` is replaced by a
3Ã—3 block of color `3` in the output. The blocks are arranged in the same
spatial order as the input grid, with adjacent blocks placed side by side
horizontally and stacked vertically. The output grid's dimensions are the sum of
the side lengths of all blocks in each direction, forming a contiguous, non-
overlapping grid. This transformation requires associating each color with its
geometric representation (a square block of matching size and color) and
extrapolating the input into a larger grid by expanding each cell according to
this rule. The task avoids numerical properties (e.g., sums, parities) and
relies purely on visual pattern recognition, where the color value visually
dictates the block's dimensions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    while True:
        m = random.randint(1, 30)
        n = random.randint(1, 30)
        input_grid = [[random.randint(1, 9) for _ in range(n)] for _ in range(m)]
        
        if m == 1 and n == 1 and input_grid[0][0] == 1:
            continue
        
        row_sums = [sum(row) for row in input_grid]
        col_sums = [sum(input_grid[r][c] for r in range(m)) for c in range(n)]
        width = max(row_sums)
        height = max(col_sums)
        
        if width > 30 or height > 30:
            continue
        
        output_grid = [[0] * width for _ in range(height)]
        
        for r in range(m):
            for c in range(n):
                k = input_grid[r][c]
                row_start = sum(input_grid[i][c] for i in range(r))
                col_start = sum(input_grid[r][j] for j in range(c))
                for dr in range(k):
                    for dc in range(k):
                        if row_start + dr < height and col_start + dc < width:
                            output_grid[row_start + dr][col_start + dc] = k
        
        if input_grid == output_grid:
            continue
        
        return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    m = len(input_grid)
    n = len(input_grid[0])
    row_sums = [sum(row) for row in input_grid]
    col_sums = [sum(input_grid[r][c] for r in range(m)) for c in range(n)]
    width = max(row_sums)
    height = max(col_sums)
    
    output_grid = [[0] * width for _ in range(height)]
    
    for r in range(m):
        for c in range(n):
            k = input_grid[r][c]
            row_start = sum(input_grid[i][c] for i in range(r))
            col_start = sum(input_grid[r][j] for j in range(c))
            for dr in range(k):
                for dc in range(k):
                    if row_start + dr < height and col_start + dc < width:
                        output_grid[row_start + dr][col_start + dc] = k
    return output_grid
