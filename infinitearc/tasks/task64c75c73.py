# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 64c75c73
Difficulty: insane

=== Tags ===
- Oscillating rule
- Remove intruder
- Spacing

=== Description ===
Input grids consist of a background color (0) with rows containing sequences of
colored symbols (non-zero values) separated by background cells. The spacing
between consecutive symbols in each row alternates between two distinct visual
gap sizes based on the row's index: even-indexed rows (0, 2, 4, ...) maintain a
consistent gap of exactly two background cells between symbols, while odd-
indexed rows (1, 3, 5, ...) maintain a consistent gap of exactly three
background cells between symbols. This alternating pattern creates a visual
oscillation across the grid's rows. However, exactly one symbol in the entire
grid is misplaced, disrupting the spacing pattern in its row by creating an
inconsistent gap (e.g., a two-cell gap in an even row or a three-cell gap in an
odd row where the expected gap size differs). This misplaced symbol is the
"intruder." The output grid is identical to the input except that the intruder
symbol is removed, restoring the alternating spacing pattern for all rows. The
task requires identifying the single intruder symbol that breaks the oscillating
spacing rule while preserving all other symbols and the visual structure of the
grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random


def generate():
    """
    Generates a pair of grids (input, output) following the specification:
    - Each row has symbols placed with a constant spacing: even rows gap=2 (step=3),
      odd rows gap=3 (step=4).
    - Exactly one symbol in the whole grid is an intruder: an extra symbol added
      to one row (without removing any original symbols) by placing it one cell
      left or right of an existing symbol. That extra symbol creates an inconsistent
      gap in that row. The output is the original (correct) grid and the input is
      the grid with the single intruder added.
    """
    background = 0
    colors = list(range(1, 10))

    # Choose width & height while ensuring enough space so a row can contain >=3 symbols
    width = random.randint(9, 30)
    height = random.randint(1, min(12, max(1, width)))

    output_grid = [[background for _ in range(width)] for _ in range(height)]

    # Choose a target row that will be guaranteed to have at least 3 symbols
    r_target = random.randrange(height)

    for r in range(height):
        is_even = (r % 2 == 0)
        step = 3 if is_even else 4

        if r == r_target:
            # Ensure this row will have at least 3 symbols
            max_k_best = (width - 1) // step + 1
            max_k = max(3, min(max_k_best, 7))
            k = random.randint(3, max_k)
            start_max = width - step * (k - 1) - 1
            start = random.randint(0, min(step - 1, max(0, start_max)))
        else:
            start = random.randint(0, step - 1)

        pos = start
        while pos < width:
            output_grid[r][pos] = random.choice(colors)
            pos += step

    # Input starts as a copy of the correct (output) grid; then we add one intruder cell
    input_grid = [row[:] for row in output_grid]

    symbols = [c for c in range(width) if output_grid[r_target][c] != background]
    if len(symbols) < 3:
        # Fallback (shouldn't happen): choose some row with >=3 symbols or create one
        candidates = [r for r in range(height) if sum(1 for c in range(width) if output_grid[r][c] != background) >= 3]
        if candidates:
            r_target = random.choice(candidates)
            symbols = [c for c in range(width) if output_grid[r_target][c] != background]
        else:
            r_target = 0
            step = 3 if (r_target % 2 == 0) else 4
            pos = 0
            output_grid[r_target] = [background] * width
            for _ in range(3):
                output_grid[r_target][pos] = random.choice(colors)
                pos += step
            input_grid = [row[:] for row in output_grid]
            symbols = [c for c in range(width) if output_grid[r_target][c] != background]

    # Choose an anchor symbol (any symbol in the row) and place an intruder to its left or right
    anchor_idx = random.randint(0, len(symbols) - 1)
    c_anchor = symbols[anchor_idx]
    direction = random.choice([-1, 1])
    c_intruder = c_anchor + direction

    # If chosen intruder cell is invalid or occupied, try the opposite side or other anchors
    if not (0 <= c_intruder < width) or input_grid[r_target][c_intruder] != background:
        # try opposite direction
        c_intruder = c_anchor - direction
    if not (0 <= c_intruder < width) or input_grid[r_target][c_intruder] != background:
        # try other anchors
        placed = False
        for idx in range(len(symbols)):
            c_anchor = symbols[idx]
            for d in (-1, 1):
                cand = c_anchor + d
                if 0 <= cand < width and input_grid[r_target][cand] == background:
                    c_intruder = cand
                    placed = True
                    break
            if placed:
                break
        if not placed:
            # Should be extremely unlikely; return unchanged pair
            return {"input": input_grid, "output": output_grid}

    # Place intruder with a color (could be same or different from neighbors)
    intruder_color = random.choice(colors)
    input_grid[r_target][c_intruder] = intruder_color

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    def row_matches(g, r):
        # Check that row r in grid g has consistent spacing
        cols = [c for c in range(width) if g[r][c] != 0]
        if len(cols) < 2:
            return True
        expected_gap = 2 if (r % 2 == 0) else 3
        for i in range(len(cols) - 1):
            if cols[i + 1] - cols[i] - 1 != expected_gap:
                return False
        return True

    def grid_valid(g):
        for r in range(height):
            if not row_matches(g, r):
                return False
        return True

    # If already valid (shouldn't be for the task), return as list-of-lists
    if grid_valid(grid):
        return grid

    # Identify rows that are invalid (should be exactly one)
    mismatched_rows = [r for r in range(height) if not row_matches(grid, r)]

    # Focus on mismatched rows first. There should typically be one.
    for r in mismatched_rows:
        cols = [c for c in range(width) if grid[r][c] != 0]
        expected_gap = 2 if (r % 2 == 0) else 3
        step = expected_gap + 1

        # Group columns by residue modulo step to find the baseline alignment
        residue_groups = {}
        for c in cols:
            residue = c % step
            residue_groups.setdefault(residue, []).append(c)

        # The baseline residue is the one with most members
        base_residue = max(residue_groups.keys(), key=lambda k: len(residue_groups[k]))

        # Intruder candidates are those not matching base_residue
        intruders = [c for c in cols if c % step != base_residue]

        # If there is exactly one intruder by residue, remove it and check global validity
        if len(intruders) == 1:
            new_grid = [row[:] for row in grid]
            new_grid[r][intruders[0]] = 0
            if grid_valid(new_grid):
                return new_grid

        # Otherwise, try brute-force removal within this row
        for c in cols:
            new_grid = [row[:] for row in grid]
            new_grid[r][c] = 0
            if grid_valid(new_grid):
                return new_grid

    # Final fallback: try removing any single non-background cell in the whole grid
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0:
                continue
            new_grid = [row[:] for row in grid]
            new_grid[r][c] = 0
            if grid_valid(new_grid):
                return new_grid

    return grid

