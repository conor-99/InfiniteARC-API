# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: ed9bb903
Difficulty: very hard

=== Tags ===
- Kinetic collision
- Hierarchical logic composition
- Bouncing
- Associate colors to images

=== Description ===
**Task Name:** Hierarchical Collision Pathways  **Tags:** - Kinetic collision -
Hierarchical logic composition - Bouncing - Associate colors to images
**Description:** Input grids feature a background color (0) with colored objects
representing distinct entities, where each color corresponds to a specific
object type with a fixed movement direction: - Color 1 (red): Ball moving right
(→) - Color 2 (blue): Ball moving down (↓) - Color 3 (green): Ball moving
diagonally up-right (↗) - Color 4 (yellow): Fixed wall (does not move)  Moving
objects traverse the grid in their designated direction until encountering a
collision. Collisions occur when two moving objects occupy the same cell or a
moving object collides with a fixed wall. Upon collision: - **Wall collision:**
The moving object bounces off the wall at a 90° angle (e.g., right-moving →
down-moving, down-moving → left-moving). - **Object collision:** Resolved
hierarchically based on object priority (red > blue > green). The higher-
priority object continues in its original direction, while the lower-priority
object reverses direction (e.g., blue (↓) colliding with red (→) results in red
continuing → and blue reversing to ↑).  The output grid depicts all object
trajectories as continuous paths drawn in their respective colors. The path
begins at the object’s starting position and follows its movement direction,
including all bends from collisions. Fixed walls (color 4) remain visible in the
output. Paths terminate when an object exits the grid. The transformation is
deterministic: collisions are resolved in priority order (highest to lowest),
and all paths are drawn without overlapping or gaps.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 20)
    height = random.randint(5, 20)
    grid = [[0] * width for _ in range(height)]
    
    # Place walls
    wall_count = random.randint(3, 8)
    for _ in range(wall_count):
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        if grid[r][c] == 0:
            grid[r][c] = 4
    
    # Place red (color 1) with wall to the right
    valid_red_rows = [r for r in range(height) if grid[r][0] == 0 and (0 < width-1 and grid[r][1] == 4)]
    if valid_red_rows:
        r = random.choice(valid_red_rows)
        grid[r][0] = 1
    else:
        # Fallback placement (should rarely happen)
        r = random.randint(0, height-1)
        grid[r][0] = 1
    
    # Place blue (color 2) with wall below
    valid_blue_cols = [c for c in range(width) if grid[0][c] == 0 and (0 < height-1 and grid[1][c] == 4)]
    if valid_blue_cols:
        c = random.choice(valid_blue_cols)
        grid[0][c] = 2
    else:
        c = random.randint(0, width-1)
        grid[0][c] = 2
    
    # Place green (color 3) with wall up-right
    valid_green = []
    for r in range(height-1, height-1, -1):
        for c in range(0, 1):
            if grid[r][c] == 0 and (r-1 >= 0 and c+1 < width and grid[r-1][c+1] == 4):
                valid_green.append((r, c))
    if valid_green:
        r, c = random.choice(valid_green)
        grid[r][c] = 3
    else:
        # Fallback placement
        r, c = height-1, 0
        grid[r][c] = 3
    
    output_grid = simulate_movement(grid, width, height)
    return {"input": grid, "output": output_grid}

def simulate_movement(grid, width, height):
    output = [row[:] for row in grid]
    objects = []
    for r in range(height):
        for c in range(width):
            color = grid[r][c]
            if color == 1:
                objects.append([1, r, c, 0, 1])
            elif color == 2:
                objects.append([2, r, c, 1, 0])
            elif color == 3:
                objects.append([3, r, c, -1, 1])
    
    max_steps = 1000
    steps = 0
    while objects and steps < max_steps:
        steps += 1
        next_steps = []
        for obj in objects:
            color, r, c, dr, dc = obj
            nr, nc = r + dr, c + dc
            next_steps.append((nr, nc, obj))
        
        updated_objects = []
        for (nr, nc, obj) in next_steps:
            color, r, c, dr, dc = obj
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                continue
            if output[nr][nc] == 4:
                if dr == 0 and dc == 1:
                    dr, dc = 1, 0
                elif dr == 1 and dc == 0:
                    dr, dc = 0, -1
                elif dr == 0 and dc == -1:
                    dr, dc = -1, 0
                elif dr == -1 and dc == 0:
                    dr, dc = 0, 1
                else:
                    dr, dc = 0, 1
                obj[3], obj[4] = dr, dc
                output[nr][nc] = color
                updated_objects.append(obj)
            else:
                output[nr][nc] = color
                obj[3], obj[4] = dr, dc
                updated_objects.append(obj)
        
        objects = updated_objects
    
    return output


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    output = simulate_movement(grid, width, height)
    return tuple(tuple(row) for row in output)

def simulate_movement(grid, width, height):
    output = [row[:] for row in grid]
    objects = []
    for r in range(height):
        for c in range(width):
            color = grid[r][c]
            if color == 1:
                objects.append([1, r, c, 0, 1])
            elif color == 2:
                objects.append([2, r, c, 1, 0])
            elif color == 3:
                objects.append([3, r, c, -1, 1])
    
    max_steps = 1000
    steps = 0
    while objects and steps < max_steps:
        steps += 1
        next_steps = []
        for obj in objects:
            color, r, c, dr, dc = obj
            nr, nc = r + dr, c + dc
            next_steps.append((nr, nc, obj))
        
        updated_objects = []
        for (nr, nc, obj) in next_steps:
            color, r, c, dr, dc = obj
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                continue
            if output[nr][nc] == 4:
                if dr == 0 and dc == 1:
                    dr, dc = 1, 0
                elif dr == 1 and dc == 0:
                    dr, dc = 0, -1
                elif dr == 0 and dc == -1:
                    dr, dc = -1, 0
                elif dr == -1 and dc == 0:
                    dr, dc = 0, 1
                else:
                    dr, dc = 0, 1
                obj[3], obj[4] = dr, dc
                output[nr][nc] = color
                updated_objects.append(obj)
            else:
                output[nr][nc] = color
                obj[3], obj[4] = dr, dc
                updated_objects.append(obj)
        
        objects = updated_objects
    
    return output
