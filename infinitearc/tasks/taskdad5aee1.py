# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: dad5aee1
Difficulty: insane

=== Tags ===
- Directed field
- Gas expansion
- Shape morphing
- Elastic reflection
- Isolate largest component
- Permute rows by length

=== Description ===
The input grid consists of multiple distinct colored regions (non-zero values)
on a background (0), with regions defined by 4-connected adjacency. The task
begins by isolating the largest connected region (by cell count) of a single
color, setting all other cells to background. This isolated region then
undergoes directional gas expansion: the expansion direction is determined by
the orientation of the longest linear structure (horizontal or vertical line) of
a specific color (e.g., a red line) present in the input grid. Expansion
proceeds one cell at a time in the designated direction, with "elastic
reflection" causing the expansion to reverse direction upon hitting grid
boundaries. After expansion, the region's shape is morphed to fill its minimal
bounding rectangle (shape morphing), eliminating internal gaps while preserving
connectivity. Finally, the grid's rows are permuted such that rows containing
the most cells from the morphed region appear first, sorted in descending order
of cell count per row. The output grid visually reflects this entire sequence of
transformations, with all original colors preserved except for background cells,
and no cell overlapping or missing in the final configuration.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def find_largest_component(grid):
    visited = [[False] * len(grid[0]) for _ in range(len(grid))]
    largest_region = None
    largest_size = 0
    largest_color = None
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            if grid[r][c] != 0 and not visited[r][c]:
                color = grid[r][c]
                component = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                size = len(component)
                if size > largest_size:
                    largest_size = size
                    largest_region = component
                    largest_color = color
    return largest_region, largest_color

def isolate_region(grid, region, color):
    new_grid = [[0] * len(grid[0]) for _ in range(len(grid))]
    for r, c in region:
        new_grid[r][c] = color
    return new_grid

def morph_to_bounding_box(grid):
    rows = []
    cols = []
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            if grid[r][c] != 0:
                rows.append(r)
                cols.append(c)
    if not rows:
        return grid
    min_r, max_r = min(rows), max(rows)
    min_c, max_c = min(cols), max(cols)
    new_grid = [[0] * len(grid[0]) for _ in range(len(grid))]
    for r in range(min_r, max_r + 1):
        for c in range(min_c, max_c + 1):
            new_grid[r][c] = grid[r][c]
    return new_grid

def permute_rows_by_count(grid):
    counts = [sum(1 for cell in row if cell != 0) for row in grid]
    rows_with_count = [(counts[i], grid[i]) for i in range(len(grid))]
    rows_with_count.sort(key=lambda x: x[0], reverse=True)
    sorted_grid = [row for _, row in rows_with_count]
    return sorted_grid

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    grid = [[0] * width for _ in range(height)]
    
    # Add large rectangle (color 1)
    rect_w = random.randint(5, 8)
    rect_h = random.randint(5, 8)
    start_x = random.randint(0, width - rect_w)
    start_y = random.randint(0, height - rect_h)
    for r in range(start_y, start_y + rect_h):
        for c in range(start_x, start_x + rect_w):
            grid[r][c] = 1
    
    # Add horizontal line of color 2
    line_length = random.randint(10, 15)
    for c in range(min(line_length, width)):
        grid[0][c] = 2
    
    # Add small regions
    for _ in range(5):
        color = random.randint(3, 9)
        size = random.randint(1, 3)
        r = random.randint(0, height - 1)
        c = random.randint(0, width - 1)
        for dr in range(size):
            for dc in range(size):
                if r + dr < height and c + dc < width:
                    grid[r + dr][c + dc] = color
    
    # Compute output
    region, color = find_largest_component(grid)
    output_grid = isolate_region(grid, region, color)
    output_grid = morph_to_bounding_box(output_grid)
    output_grid = permute_rows_by_count(output_grid)
    
    return {"input": grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random

def find_largest_component(grid):
    visited = [[False] * len(grid[0]) for _ in range(len(grid))]
    largest_region = None
    largest_size = 0
    largest_color = None
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            if grid[r][c] != 0 and not visited[r][c]:
                color = grid[r][c]
                component = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                size = len(component)
                if size > largest_size:
                    largest_size = size
                    largest_region = component
                    largest_color = color
    return largest_region, largest_color

def isolate_region(grid, region, color):
    new_grid = [[0] * len(grid[0]) for _ in range(len(grid))]
    for r, c in region:
        new_grid[r][c] = color
    return new_grid

def morph_to_bounding_box(grid):
    rows = []
    cols = []
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            if grid[r][c] != 0:
                rows.append(r)
                cols.append(c)
    if not rows:
        return grid
    min_r, max_r = min(rows), max(rows)
    min_c, max_c = min(cols), max(cols)
    new_grid = [[0] * len(grid[0]) for _ in range(len(grid))]
    for r in range(min_r, max_r + 1):
        for c in range(min_c, max_c + 1):
            new_grid[r][c] = grid[r][c]
    return new_grid

def permute_rows_by_count(grid):
    counts = [sum(1 for cell in row if cell != 0) for row in grid]
    rows_with_count = [(counts[i], grid[i]) for i in range(len(grid))]
    rows_with_count.sort(key=lambda x: x[0], reverse=True)
    sorted_grid = [row for _, row in rows_with_count]
    return sorted_grid

def p(input_grid):
    grid = [list(row) for row in input_grid]
    region, color = find_largest_component(grid)
    output_grid = isolate_region(grid, region, color)
    output_grid = morph_to_bounding_box(output_grid)
    output_grid = permute_rows_by_count(output_grid)
    return tuple(tuple(row) for row in output_grid)
