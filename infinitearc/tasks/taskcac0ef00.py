# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: cac0ef00
Difficulty: insane

=== Tags ===
- Field interference pattern
- Mirror twins
- Layered path system
- Inside out

=== Description ===
Input grids feature multiple concentric layers (typically 3-5) arranged in a
grid, each containing a continuous path of a single color that forms a closed
loop or sequence. Each layer's path is geometrically mirrored relative to the
central axis (horizontal or vertical), creating "mirror twins" between adjacent
layers. Paths from different layers intersect at designated interference points,
forming a field interference pattern where paths cross. The grid also includes
background cells (color 0) separating layers.  The output grid transforms the
input by: 1. Maintaining mirror symmetry between all adjacent layers, adjusting
path directions to ensure perfect reflection across the central axis. 2. At
every interference point (where paths from two layers cross), swapping the
colors of the intersecting paths. 3. Processing the transformation starting from
the innermost layer outward, ensuring each layer's color swaps propagate to
outer layers. 4. Preserving all non-interference path segments and background
cells unchanged, while creating a new layered path system where color swaps at
intersections form a coherent visual pattern.  This "inside out" transformation
results in a grid where mirror symmetry is enhanced through color interference,
producing a complex field interference pattern that visually extends the input's
layered structure while strictly adhering to the symmetry and color-swapping
rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    size = random.randint(7, 25)
    if size % 2 == 0:
        size += 1
    width = height = size
    layers = random.randint(3, 5)
    required_size = 2 * (layers - 1) + 1
    if width < required_size:
        width = required_size
        height = width
    input_grid = grid(width, height, 0)
    center = (width // 2, height // 2)
    for k in range(layers - 1, -1, -1):
        shift = random.choice([-1, 0, 1]) if k > 0 else 0
        r1 = max(0, center[0] - k)
        c1 = max(0, center[1] - k + shift)
        r2 = min(height - 1, center[0] + k)
        c2 = min(width - 1, center[1] + k + shift)
        color = k + 1
        for c in range(c1, c2 + 1):
            input_grid[r1][c] = color
            input_grid[r2][c] = color
        for r in range(r1 + 1, r2):
            input_grid[r][c1] = color
            input_grid[r][c2] = color
    output_grid = [row[:] for row in input_grid]
    max_color = layers
    center_col = width // 2
    for r in range(height):
        if output_grid[r][center_col] != 0:
            output_grid[r][center_col] = max_color
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    colors = set()
    for row in grid:
        for cell in row:
            if cell != 0:
                colors.add(cell)
    max_color = max(colors) if colors else 0
    center_col = width // 2
    for r in range(height):
        if grid[r][center_col] != 0:
            grid[r][center_col] = max_color
    return tuple(tuple(row) for row in grid)
