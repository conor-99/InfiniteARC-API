# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 52400416
Difficulty: medium

=== Tags ===
- Holes
- Take intersection

=== Description ===
The input grids contain two distinct holes, defined as contiguous regions of
zeros (empty spaces) entirely surrounded by non-zero values. Each hole must be a
single connected component with no direct adjacency to the grid's edges. The
output grid is generated by identifying cells that are adjacent to both holes
(i.e., cells sharing an edge with pixels from both hole boundaries) and setting
those cells to a non-zero value (e.g., color 1), while all other cells are set
to zero. This transformation requires recognizing the spatial relationship
between the two holes and their mutual boundary cells, making it a visual
spatial reasoning task focused on hole adjacency rather than numerical
properties.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    H = random.randint(6, 30)
    W = random.randint(6, 30)
    grid = [[2] * W for _ in range(H)]
    hole1 = set()
    
    # Place first hole (2x2)
    r1 = random.randint(1, H - 3)
    c1 = random.randint(1, W - 3)
    for r in range(r1, r1 + 2):
        for c in range(c1, c1 + 2):
            grid[r][c] = 0
            hole1.add((r, c))
    
    # Calculate valid positions for second hole
    forbidden_r_min = max(1, r1 - 1)
    forbidden_r_max = min(H - 3, r1 + 2)
    forbidden_c_min = max(1, c1 - 1)
    forbidden_c_max = min(W - 3, c1 + 2)
    
    valid_rows = []
    if forbidden_r_min > 1:
        valid_rows.extend(range(1, forbidden_r_min))
    if forbidden_r_max < H - 3:
        valid_rows.extend(range(forbidden_r_max + 1, H - 2))
    
    valid_cols = []
    if forbidden_c_min > 1:
        valid_cols.extend(range(1, forbidden_c_min))
    if forbidden_c_max < W - 3:
        valid_cols.extend(range(forbidden_c_max + 1, W - 2))
    
    # Select valid position
    r2 = random.choice(valid_rows) if valid_rows else random.randint(1, H - 3)
    c2 = random.choice(valid_cols) if valid_cols else random.randint(1, W - 3)
    
    # Place second hole (2x2)
    hole2 = set()
    for r in range(r2, r2 + 2):
        for c in range(c2, c2 + 2):
            grid[r][c] = 0
            hole2.add((r, c))
    
    output = [[0] * W for _ in range(H)]
    for i in range(H):
        for j in range(W):
            if grid[i][j] == 0:
                continue
            adj_hole1 = False
            adj_hole2 = False
            for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                ni, nj = i + di, j + dj
                if 0 <= ni < H and 0 <= nj < W and grid[ni][nj] == 0:
                    if (ni, nj) in hole1:
                        adj_hole1 = True
                    if (ni, nj) in hole2:
                        adj_hole2 = True
            if adj_hole1 and adj_hole2:
                output[i][j] = 1
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    H = len(input_grid)
    W = len(input_grid[0])
    visited = [[False] * W for _ in range(H)]
    holes = []
    
    for i in range(H):
        for j in range(W):
            if input_grid[i][j] == 0 and not visited[i][j]:
                component = []
                queue = [(i, j)]
                visited[i][j] = True
                while queue:
                    r, c = queue.pop(0)
                    component.append((r, c))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < H and 0 <= nc < W and input_grid[nr][nc] == 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                holes.append(component)
    
    hole1 = set(holes[0])
    hole2 = set(holes[1]) if len(holes) > 1 else set(holes[0])
    
    output = [[0] * W for _ in range(H)]
    for i in range(H):
        for j in range(W):
            if input_grid[i][j] == 0:
                continue
            adj_hole1 = False
            adj_hole2 = False
            for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                ni, nj = i + di, j + dj
                if 0 <= ni < H and 0 <= nj < W and input_grid[ni][nj] == 0:
                    if (ni, nj) in hole1:
                        adj_hole1 = True
                    if (ni, nj) in hole2:
                        adj_hole2 = True
            if adj_hole1 and adj_hole2:
                output[i][j] = 1
    return output
