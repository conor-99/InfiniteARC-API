# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 46322d30
Difficulty: mediumâ€“hard

=== Tags ===
- Magnetic path alignment
- Transformation stack
- Coordinate warp
- Swap rows

=== Description ===
Input grids consist of multiple colored paths (connected sequences of cells with
identical color) arranged in a grid, where paths of certain color pairs exhibit
magnetic attraction (e.g., red and blue paths move toward each other) or
repulsion (same color paths move apart). The output grid is formed by:  1.
**Magnetic Path Alignment**: Paths of attracting color pairs are shifted along
their direction vectors until they connect or reach a grid boundary. Repelling
paths are shifted away from each other.  2. **Coordinate Warp**: Each row is
shifted right by an amount equal to its row index modulo 3, causing a diagonal
warping effect across the grid.  3. **Row Swap**: The first and second rows are
swapped, and the third and fourth rows are swapped (if the grid has at least
four rows).  All transformations are applied sequentially to the grid, with path
movements and shifts occurring without overwriting existing paths or background
elements. The background color remains consistent throughout.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid as make_grid

# Helper functions

def find_segments_in_row(row, color):
    """Return a list of (start, end) inclusive indices of contiguous segments of `color` in the row."""
    segs = []
    w = len(row)
    c = 0
    while c < w:
        if row[c] == color:
            start = c
            while c + 1 < w and row[c + 1] == color:
                c += 1
            end = c
            segs.append((start, end))
        c += 1
    return segs


def segment_containing(row, idx):
    """Return (start,end) of the contiguous segment that contains idx."""
    val = row[idx]
    w = len(row)
    start = idx
    while start - 1 >= 0 and row[start - 1] == val:
        start -= 1
    end = idx
    while end + 1 < w and row[end + 1] == val:
        end += 1
    return start, end


def apply_attraction(grid, color_a=1, color_b=2):
    """For each row containing both colors, move the left-hand segment right and the right-hand segment left
    step-by-step until they touch or are blocked. Movements only occur into empty (0) cells."""
    h = len(grid)
    w = len(grid[0])
    for r in range(h):
        row = grid[r]
        has_a = any(cell == color_a for cell in row)
        has_b = any(cell == color_b for cell in row)
        if not (has_a and has_b):
            continue
        # Find the rightmost index of color_a and leftmost index of color_b
        positions_a = [i for i, v in enumerate(row) if v == color_a]
        positions_b = [i for i, v in enumerate(row) if v == color_b]
        if not positions_a or not positions_b:
            continue
        rightmost_a = max(positions_a)
        leftmost_b = min(positions_b)
        # Determine which color is on the left
        if rightmost_a < leftmost_b:
            # a ... b
            seg_a_start, seg_a_end = segment_containing(row, rightmost_a)
            seg_b_start, seg_b_end = segment_containing(row, leftmost_b)
            left_color, right_color = color_a, color_b
        else:
            # b ... a (swap roles)
            rightmost_b = max(positions_b)
            leftmost_a = min(positions_a)
            if rightmost_b < leftmost_a:
                seg_a_start, seg_a_end = segment_containing(row, rightmost_b)
                seg_b_start, seg_b_end = segment_containing(row, leftmost_a)
                # left segment is color_b, right segment is color_a
                left_color, right_color = color_b, color_a
            else:
                # Interleaved or overlapping in a complicated way; skip this row
                continue
        # Now iteratively move them toward each other while both can step into empty cells
        while True:
            gap = seg_b_start - seg_a_end - 1
            if gap <= 0:
                break
            # target cells one step closer
            target_a = seg_a_end + 1
            target_b = seg_b_start - 1
            # Ensure the target cells are empty (cannot overwrite other paths)
            if not (0 <= target_a < w and 0 <= target_b < w):
                break
            if grid[r][target_a] != 0 or grid[r][target_b] != 0:
                break
            # Perform the simultaneous step: clear old positions then write new
            for c in range(seg_a_start, seg_a_end + 1):
                grid[r][c] = 0
            for c in range(seg_b_start, seg_b_end + 1):
                grid[r][c] = 0
            seg_a_start += 1
            seg_a_end += 1
            seg_b_start -= 1
            seg_b_end -= 1
            for c in range(seg_a_start, seg_a_end + 1):
                grid[r][c] = left_color
            for c in range(seg_b_start, seg_b_end + 1):
                grid[r][c] = right_color


def apply_repulsion(grid, color=3):
    """For each row with at least two separate segments of the same color, move the leftmost segment leftwards
    and the rightmost segment rightwards as far as possible into empty cells."""
    h = len(grid)
    w = len(grid[0])
    for r in range(h):
        row = grid[r]
        segs = find_segments_in_row(row, color)
        if len(segs) < 2:
            continue
        left_start, left_end = segs[0]
        right_start, right_end = segs[-1]
        # Move until no more movement possible
        while True:
            moved = False
            # Try to move left segment left by one
            if left_start - 1 >= 0 and grid[r][left_start - 1] == 0:
                # Clear old
                for c in range(left_start, left_end + 1):
                    grid[r][c] = 0
                left_start -= 1
                left_end -= 1
                for c in range(left_start, left_end + 1):
                    grid[r][c] = color
                moved = True
            # Try to move right segment right by one
            if right_end + 1 < w and grid[r][right_end + 1] == 0:
                for c in range(right_start, right_end + 1):
                    grid[r][c] = 0
                right_start += 1
                right_end += 1
                for c in range(right_start, right_end + 1):
                    grid[r][c] = color
                moved = True
            if not moved:
                break


def warp_rows(grid):
    """Shift each row right by row_index % 3, padding with background (0) on the left and truncating the right."""
    h = len(grid)
    w = len(grid[0])
    new = [None] * h
    for i in range(h):
        shift = i % 3
        if shift == 0:
            new[i] = list(grid[i])
        else:
            # pad on the left with zeros and drop the rightmost `shift` cells
            new[i] = [0] * shift + list(grid[i][:w - shift])
    return new


def swap_rows(grid):
    """Swap row 0<->1 and 2<->3 if those rows exist."""
    h = len(grid)
    out = [list(row) for row in grid]
    if h > 1:
        out[0], out[1] = out[1], out[0]
    if h > 3:
        out[2], out[3] = out[3], out[2]
    return out


def generate():
    # Choose a medium-size grid to allow movements and warps
    width = random.randint(8, 14)
    height = random.randint(6, 12)
    input_grid = make_grid(width, height, 0)

    # Place an attracting pair (colors 1 and 2) on a single row
    r1 = random.randrange(height)
    L1 = random.randint(2, 3)
    L2 = random.randint(2, 3)
    gap_min = 2
    # safe placement range for the left segment
    max_left_start = width - (L1 + L2 + gap_min)
    if max_left_start < 0:
        max_left_start = 0
    left_start = random.randint(0, max_left_start)
    # choose a gap (at least gap_min)
    max_gap = width - left_start - L1 - L2
    if max_gap < gap_min:
        gap = gap_min
    else:
        gap = random.randint(gap_min, max_gap)
    right_start = left_start + L1 + gap
    for c in range(left_start, left_start + L1):
        input_grid[r1][c] = 1
    for c in range(right_start, right_start + L2):
        input_grid[r1][c] = 2

    # Place a repelling pair (color 3) on a different row
    r2 = random.randrange(height)
    while r2 == r1:
        r2 = random.randrange(height)
    L3 = random.randint(2, 3)
    L4 = random.randint(2, 3)
    # Put them roughly separated around the middle to give room to move outward
    center = width // 2
    left3_start = max(1, center - L3 - random.randint(1, 2))
    right3_start = min(width - L4 - 2, center + random.randint(1, 2))
    # Ensure they don't overlap
    if right3_start <= left3_start + L3 - 1:
        right3_start = left3_start + L3 + 1
        if right3_start + L4 > width:
            right3_start = max(left3_start + L3 + 1, width - L4 - 1)
    for c in range(left3_start, left3_start + L3):
        input_grid[r2][c] = 3
    for c in range(right3_start, right3_start + L4):
        input_grid[r2][c] = 3

    # Add a small static obstacle in another row to increase variety
    r3 = random.randrange(height)
    while r3 == r1 or r3 == r2:
        r3 = random.randrange(height)
    obs_len = random.randint(2, 3)
    obs_start = random.randint(0, max(0, width - obs_len))
    for c in range(obs_start, obs_start + obs_len):
        # use color 4 for a static obstacle
        input_grid[r3][c] = 4

    # Compute the output by applying the same deterministic transformations
    output_grid = [row[:] for row in input_grid]
    apply_attraction(output_grid, color_a=1, color_b=2)
    apply_repulsion(output_grid, color=3)
    warped = warp_rows(output_grid)
    swapped = swap_rows(warped)

    return {
        "input": input_grid,
        "output": swapped
    }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])

    def find_segments_in_row(row, color):
        segs = []
        c = 0
        while c < len(row):
            if row[c] == color:
                start = c
                while c + 1 < len(row) and row[c + 1] == color:
                    c += 1
                end = c
                segs.append((start, end))
            c += 1
        return segs

    def segment_containing(row, idx):
        val = row[idx]
        start = idx
        while start - 1 >= 0 and row[start - 1] == val:
            start -= 1
        end = idx
        while end + 1 < len(row) and row[end + 1] == val:
            end += 1
        return start, end

    def apply_attraction_local(grid_local, color_a=1, color_b=2):
        for r in range(len(grid_local)):
            row = grid_local[r]
            has_a = any(cell == color_a for cell in row)
            has_b = any(cell == color_b for cell in row)
            if not (has_a and has_b):
                continue
            positions_a = [i for i, v in enumerate(row) if v == color_a]
            positions_b = [i for i, v in enumerate(row) if v == color_b]
            if not positions_a or not positions_b:
                continue
            rightmost_a = max(positions_a)
            leftmost_b = min(positions_b)
            if rightmost_a < leftmost_b:
                seg_a_start, seg_a_end = segment_containing(row, rightmost_a)
                seg_b_start, seg_b_end = segment_containing(row, leftmost_b)
                left_color, right_color = color_a, color_b
            else:
                rightmost_b = max(positions_b)
                leftmost_a = min(positions_a)
                if rightmost_b < leftmost_a:
                    seg_a_start, seg_a_end = segment_containing(row, rightmost_b)
                    seg_b_start, seg_b_end = segment_containing(row, leftmost_a)
                    left_color, right_color = color_b, color_a
                else:
                    continue
            # iterative movement
            while True:
                gap = seg_b_start - seg_a_end - 1
                if gap <= 0:
                    break
                target_a = seg_a_end + 1
                target_b = seg_b_start - 1
                if not (0 <= target_a < w and 0 <= target_b < w):
                    break
                if grid_local[r][target_a] != 0 or grid_local[r][target_b] != 0:
                    break
                for c in range(seg_a_start, seg_a_end + 1):
                    grid_local[r][c] = 0
                for c in range(seg_b_start, seg_b_end + 1):
                    grid_local[r][c] = 0
                seg_a_start += 1
                seg_a_end += 1
                seg_b_start -= 1
                seg_b_end -= 1
                for c in range(seg_a_start, seg_a_end + 1):
                    grid_local[r][c] = left_color
                for c in range(seg_b_start, seg_b_end + 1):
                    grid_local[r][c] = right_color

    def apply_repulsion_local(grid_local, color=3):
        for r in range(len(grid_local)):
            row = grid_local[r]
            segs = find_segments_in_row(row, color)
            if len(segs) < 2:
                continue
            left_start, left_end = segs[0]
            right_start, right_end = segs[-1]
            while True:
                moved = False
                if left_start - 1 >= 0 and grid_local[r][left_start - 1] == 0:
                    for c in range(left_start, left_end + 1):
                        grid_local[r][c] = 0
                    left_start -= 1
                    left_end -= 1
                    for c in range(left_start, left_end + 1):
                        grid_local[r][c] = color
                    moved = True
                if right_end + 1 < w and grid_local[r][right_end + 1] == 0:
                    for c in range(right_start, right_end + 1):
                        grid_local[r][c] = 0
                    right_start += 1
                    right_end += 1
                    for c in range(right_start, right_end + 1):
                        grid_local[r][c] = color
                    moved = True
                if not moved:
                    break

    def warp_rows_local(grid_local):
        new = []
        for i in range(len(grid_local)):
            shift = i % 3
            if shift == 0:
                new.append(list(grid_local[i]))
            else:
                new.append([0] * shift + list(grid_local[i][:w - shift]))
        return new

    def swap_rows_local(grid_local):
        out = [list(row) for row in grid_local]
        if len(out) > 1:
            out[0], out[1] = out[1], out[0]
        if len(out) > 3:
            out[2], out[3] = out[3], out[2]
        return out

    # Apply transformations in the specified order
    apply_attraction_local(grid, color_a=1, color_b=2)
    apply_repulsion_local(grid, color=3)
    warped = warp_rows_local(grid)
    swapped = swap_rows_local(warped)
    return swapped

