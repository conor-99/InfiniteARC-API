# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 7d3e8662
Difficulty: mediumâ€“hard

=== Tags ===
- Spatial signal
- Signal to structure
- Lava flow
- Pattern concatenation
- Detect rotational symmetry

=== Description ===
Input grids feature a continuous lava flow path composed of a single non-
background color (1-9) that forms an incomplete rotational symmetric pattern.
The path appears only in the upper-left quadrant of the grid, with the
corresponding lower-right quadrant remaining background (color 0). The output
grid completes the pattern by mirroring every cell of the input path across the
grid's central axis (180-degree rotation), adding these mirrored cells to the
background while preserving the original path. This transformation requires
detecting the rotational symmetry in the input path's structure and applying it
to generate a fully symmetrical lava flow pattern. The completed path must
maintain connectivity and appear as a seamless continuous structure, with all
background cells unchanged except where the mirrored path is added. The task
demands recognizing that the input path is only half of a symmetrical whole, and
that the missing half must be constructed through precise 180-degree rotation
without overlapping or altering existing path segments.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    H = random.choice(range(4, 31, 2))
    W = random.choice(range(4, 31, 2))
    h = H // 2
    w = W // 2
    size = random.randint(3, min(10, h * w))
    color = common.random_color(exclude=[0])
    pixels = common.continuous_creature(size, width=w, height=h)
    rows = [p[0] for p in pixels]
    cols = [p[1] for p in pixels]
    input_grid = common.grid(W, H, 0)
    for r, c in zip(rows, cols):
        input_grid[r][c] = color
    output_grid = [row[:] for row in input_grid]
    for r, c in zip(rows, cols):
        mr = H - 1 - r
        mc = W - 1 - c
        output_grid[mr][mc] = color
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    H = len(input_grid)
    W = len(input_grid[0])
    color = None
    for r in range(H):
        for c in range(W):
            if input_grid[r][c] != 0:
                color = input_grid[r][c]
                break
        if color is not None:
            break
    if color is None:
        color = 0
    output_grid = [list(row) for row in input_grid]
    for r in range(H):
        for c in range(W):
            if input_grid[r][c] == color:
                mr = H - 1 - r
                mc = W - 1 - c
                output_grid[mr][mc] = color
    return tuple(tuple(row) for row in output_grid)
