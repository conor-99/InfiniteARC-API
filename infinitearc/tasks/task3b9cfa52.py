# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 3b9cfa52
Difficulty: medium

=== Tags ===
- Detect background color

=== Description ===
In this task, the input grid contains a distinct background color that dominates
the perimeter (outermost rows and columns), while the interior may contain
foreground elements of different colors. The background color is determined by
identifying the most frequent color appearing on the grid's perimeter; in cases
of a tie, the smallest color value is chosen. The output grid is generated by
replacing every cell in the input grid with this detected background color,
resulting in a uniform grid of that single color. This transformation requires
analyzing the perimeter to identify the dominant background color, then applying
a global color replacement, making it a medium-difficulty task that tests
pattern recognition and consistent rule application.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(2, 30)
    height = random.randint(2, 30)
    b = random.randint(0, 9)
    grid_input = [[0] * width for _ in range(height)]
    
    for c in range(width):
        grid_input[0][c] = b
        grid_input[height-1][c] = b
    for r in range(1, height-1):
        grid_input[r][0] = b
        grid_input[r][width-1] = b
    
    perimeter_cells = []
    for c in range(width):
        perimeter_cells.append((0, c))
        perimeter_cells.append((height-1, c))
    for r in range(1, height-1):
        perimeter_cells.append((r, 0))
        perimeter_cells.append((r, width-1))
    
    num_changes = random.randint(0, 3)
    for _ in range(num_changes):
        r, c = random.choice(perimeter_cells)
        new_color = random.randint(0, 9)
        while new_color == b:
            new_color = random.randint(0, 9)
        grid_input[r][c] = new_color
    
    grid_output = [[b] * width for _ in range(height)]
    return {"input": grid_input, "output": grid_output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    h = len(input_grid)
    w = len(input_grid[0])
    perimeter = []
    for c in range(w):
        perimeter.append((0, c))
        perimeter.append((h-1, c))
    for r in range(1, h-1):
        perimeter.append((r, 0))
        perimeter.append((r, w-1))
    
    color_count = {}
    for r, c in perimeter:
        col = input_grid[r][c]
        color_count[col] = color_count.get(col, 0) + 1
    
    sorted_colors = sorted(color_count.items(), key=lambda x: (-x[1], x[0]))
    bg_color = sorted_colors[0][0]
    
    return [[bg_color] * w for _ in range(h)]
