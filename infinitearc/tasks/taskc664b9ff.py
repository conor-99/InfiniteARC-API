# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: c664b9ff
Difficulty: very hard

=== Tags ===
- Trail memory
- Cascade fountain
- Refraction simulation
- Diagonal symmetry
- Holes

=== Description ===
Input grids are 2D grids with values from 0 to 9, where 0 represents background,
and non-zero values represent colored elements. The grid contains refractive
diagonal elements (color 1 for top-left to bottom-right diagonals, color 2 for
top-right to bottom-left diagonals) and "holes"—enclosed background regions (0
cells) completely surrounded by non-background elements. The grid also features
a cascade fountain starting from the top edge.  The output grid depicts the
complete cascade path, which follows these rules: Starting from all top-row
background cells (0), the path flows downward (south). Upon encountering a color
1 diagonal element (/), the direction changes 90° clockwise (from south to
east). Upon encountering color 2 (\\), the direction changes 90°
counterclockwise (from south to west). For other directions, the refraction
follows the diagonal mirror's orientation (e.g., moving east and hitting / turns
north). The path avoids entering holes (enclosed background regions) by
navigating around their boundaries. The trail memory is maintained through
sequential direction updates, and the path stops when exiting the grid boundary.
The output marks the path with a distinct color (e.g., color 3), preserving all
refractive elements and holes. The solution requires simulating the cascade's
directional changes across multiple refractions while respecting hole
boundaries, with no loops or self-intersections.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, all_pixels, connected

def generate():
    size = random.randint(15, 30)
    ingrid = grid(size, size, 0)
    
    # Place refractive elements (1 and 2) in path region
    for _ in range(random.randint(10, 30)):
        r, c = random.randint(0, size-1), random.randint(0, size-1)
        if random.choice([True, False]):
            ingrid[r][c] = 1  # top-left to bottom-right
        else:
            ingrid[r][c] = 2  # top-right to bottom-left

    # Create holes (enclosed background regions)
    for _ in range(random.randint(3, 7)):
        hole_width = random.randint(2, 5)
        hole_height = random.randint(2, 5)
        start_r = random.randint(2, size - hole_height - 2)
        start_c = random.randint(2, size - hole_width - 2)
        for r in range(start_r, start_r + hole_height):
            for c in range(start_c, start_c + hole_width):
                if random.random() > 0.7:
                    ingrid[r][c] = 0  # background inside hole
                else:
                    ingrid[r][c] = random.randint(3, 9)

    # Create path from top row
    output = [row[:] for row in ingrid]
    visited = set()
    directions = {'down': (1, 0), 'right': (0, 1), 'up': (-1, 0), 'left': (0, -1)}
    
    for c in range(size):
        if ingrid[0][c] == 0 and (0, c) not in visited:
            r, c_pos = 0, c
            current_dir = 'down'
            while 0 <= r < size and 0 <= c_pos < size:
                if (r, c_pos) in visited:
                    break
                visited.add((r, c_pos))
                output[r][c_pos] = 3  # Mark path
                
                # Check refractive element
                if ingrid[r][c_pos] in [1, 2]:
                    dr, dc = directions[current_dir]
                    if ingrid[r][c_pos] == 1:  # Clockwise
                        current_dir = ['right', 'up', 'left', 'down'][['down', 'right', 'up', 'left'].index(current_dir) + 1]
                    else:  # Counterclockwise
                        current_dir = ['right', 'up', 'left', 'down'][['down', 'right', 'up', 'left'].index(current_dir) - 1]
                
                dr, dc = directions[current_dir]
                r += dr
                c_pos += dc

    return {
        'input': ingrid,
        'output': output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    size = len(input_grid)
    output = [list(row) for row in input_grid]  # Fixed: convert to list of lists
    visited = set()
    directions = {'down': (1, 0), 'right': (0, 1), 'up': (-1, 0), 'left': (0, -1)}
    
    for c in range(size):
        if input_grid[0][c] == 0 and (0, c) not in visited:
            r, c_pos = 0, c
            current_dir = 'down'
            while 0 <= r < size and 0 <= c_pos < size:
                if (r, c_pos) in visited:
                    break
                visited.add((r, c_pos))
                output[r][c_pos] = 3
                
                if input_grid[r][c_pos] in [1, 2]:
                    dr, dc = directions[current_dir]
                    if input_grid[r][c_pos] == 1:
                        current_dir = ['right', 'up', 'left', 'down'][['down', 'right', 'up', 'left'].index(current_dir) + 1]
                    else:
                        current_dir = ['right', 'up', 'left', 'down'][['down', 'right', 'up', 'left'].index(current_dir) - 1]
                
                dr, dc = directions[current_dir]
                r += dr
                c_pos += dc
    
    return output
