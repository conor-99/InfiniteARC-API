# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 619c0a9a
Difficulty: medium–hard

=== Tags ===
- Deterministic update
- Reflective maze
- Color clock
- Nonlocal dependency
- Bouncing

=== Description ===
Reflective Maze Clock  Input grids depict a maze structure where walls are
represented by non-zero colors (1–9) and empty cells (0) contain moving color
tokens (2–9). Each token's movement direction is determined by its current
color: color 1 moves right, 2 moves down, 3 moves left, 4 moves up, repeating
cyclically (5→right, 6→down, etc.). Tokens move one cell per step; if their next
cell is a wall (non-zero) or grid boundary, they reverse direction and move.
After moving, each token's color increments by 1 (mod 9, with 9 wrapping to 1).
The output grid shows the grid after one deterministic update cycle. This
requires recognizing direction from color (color clock), handling bounces
against maze walls (reflective maze), and applying the color cycle
(deterministic update), with the maze structure creating nonlocal dependencies
that dictate bounce points and movement paths.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

DIRECTIONS = [(0,1),(1,0),(0,-1),(-1,0)]

def generate():
    # Random reasonable size for a maze
    width = random.randint(5, 20)
    height = random.randint(5, 20)
    area = width * height

    # Start with empty grid (0 = empty)
    grid = [[0 for _ in range(width)] for _ in range(height)]

    # Draw several short wall segments to create a maze-like structure (walls use color 1)
    segments = random.randint(max(1, area // 12), max(1, area // 6))
    for _ in range(segments):
        orientation = random.choice([0, 1])  # 0 = horizontal, 1 = vertical
        r = random.randint(0, height - 1)
        c = random.randint(0, width - 1)
        # segment length scaled to grid
        length = random.randint(1, max(1, (width if orientation == 0 else height) // 2))
        step = random.choice([-1, 1])
        for i in range(length):
            rr = r + (i * step if orientation == 1 else 0)
            cc = c + (i * step if orientation == 0 else 0)
            if 0 <= rr < height and 0 <= cc < width:
                grid[rr][cc] = 1

    # Sprinkle a few single-cell walls for texture
    extra_walls = random.randint(0, max(1, area // 15))
    for _ in range(extra_walls):
        rr = random.randrange(height)
        cc = random.randrange(width)
        grid[rr][cc] = 1

    # Collect empty cells and shuffle
    empties = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == 0]
    random.shuffle(empties)

    tokens = []            # list of placed tokens as (r, c, color)
    reserved_targets = set()  # targets that are reserved to avoid collisions
    occupied_initial = set()  # initial cells taken by tokens

    max_tokens = max(1, area // 20)

    def is_valid_target(rr, cc):
        if rr < 0 or rr >= height or cc < 0 or cc >= width: return False
        if grid[rr][cc] != 0: return False  # can't move into walls or already-placed token
        if (rr, cc) in reserved_targets: return False
        if (rr, cc) in occupied_initial: return False
        return True

    # Try to place tokens sparsely so their moves are deterministic and collision-free
    for (r, c) in empties:
        if len(tokens) >= max_tokens:
            break
        # Don't place a token into a cell that was reserved as a target by earlier placements
        if (r, c) in reserved_targets:
            continue
        # Random chance to skip so tokens are sparse
        if random.random() > 0.25:
            continue
        if grid[r][c] != 0:
            continue

        # Try a shuffled list of colors until we find one with a valid forward or reverse cell
        colors = list(range(2, 10))
        random.shuffle(colors)
        for v in colors:
            d = (v - 1) % 4
            dr, dc = DIRECTIONS[d]
            fr, fc = r + dr, c + dc
            br, bc = r - dr, c - dc
            if is_valid_target(fr, fc):
                grid[r][c] = v
                tokens.append((r, c, v))
                occupied_initial.add((r, c))
                reserved_targets.add((fr, fc))
                break
            if is_valid_target(br, bc):
                grid[r][c] = v
                tokens.append((r, c, v))
                occupied_initial.add((r, c))
                reserved_targets.add((br, bc))
                break
        # continue scanning empties

    # Guarantee at least one token (choose a safe location if none got placed)
    if not tokens:
        empties = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == 0]
        random.shuffle(empties)
        placed = False
        for (r, c) in empties:
            colors = list(range(2, 10))
            random.shuffle(colors)
            for v in colors:
                d = (v - 1) % 4
                dr, dc = DIRECTIONS[d]
                fr, fc = r + dr, c + dc
                br, bc = r - dr, c - dc
                if 0 <= fr < height and 0 <= fc < width and grid[fr][fc] == 0 and (fr, fc) not in occupied_initial and (fr, fc) not in reserved_targets:
                    grid[r][c] = v
                    tokens.append((r, c, v))
                    reserved_targets.add((fr, fc))
                    occupied_initial.add((r, c))
                    placed = True
                    break
                if 0 <= br < height and 0 <= bc < width and grid[br][bc] == 0 and (br, bc) not in occupied_initial and (br, bc) not in reserved_targets:
                    grid[r][c] = v
                    tokens.append((r, c, v))
                    reserved_targets.add((br, bc))
                    occupied_initial.add((r, c))
                    placed = True
                    break
            if placed:
                break

    # Build the output by computing all moves first (simultaneous update)
    input_grid = [row[:] for row in grid]
    moves = []  # list of (r, c, v, tr, tc)

    # Compute moves by scanning the grid row-major, to match solver's scanning order
    for r in range(height):
        for c in range(width):
            v = input_grid[r][c]
            if not (isinstance(v, int) and 2 <= v <= 9):
                continue
            d = (v - 1) % 4
            dr, dc = DIRECTIONS[d]
            fr, fc = r + dr, c + dc
            br, bc = r - dr, c - dc

            def can_move(rr, cc):
                return 0 <= rr < height and 0 <= cc < width and input_grid[rr][cc] == 0

            if can_move(fr, fc):
                tr, tc = fr, fc
            elif can_move(br, bc):
                tr, tc = br, bc
            else:
                tr, tc = r, c

            moves.append((r, c, v, tr, tc))

    # Apply moves simultaneously
    output = [row[:] for row in input_grid]
    # First clear all original positions
    for (r, c, v, tr, tc) in moves:
        output[r][c] = 0
    # Then write all destinations with new colors
    for (r, c, v, tr, tc) in moves:
        new_color = (v % 9) + 1
        output[tr][tc] = new_color

    return {"input": input_grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert the immutable input to a mutable grid
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    DIRECTIONS = [(0,1),(1,0),(0,-1),(-1,0)]

    # Compute moves by scanning the grid row-major (this matches generator semantics)
    moves = []  # list of (r, c, v, tr, tc)

    def can_move(rr, cc):
        return 0 <= rr < height and 0 <= cc < width and grid[rr][cc] == 0

    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if not (isinstance(v, int) and 2 <= v <= 9):
                continue
            d = (v - 1) % 4
            dr, dc = DIRECTIONS[d]
            fr, fc = r + dr, c + dc
            br, bc = r - dr, c - dc

            if can_move(fr, fc):
                tr, tc = fr, fc
            elif can_move(br, bc):
                tr, tc = br, bc
            else:
                tr, tc = r, c

            moves.append((r, c, v, tr, tc))

    # Apply moves simultaneously
    output = [row[:] for row in grid]
    for (r, c, v, tr, tc) in moves:
        output[r][c] = 0
    for (r, c, v, tr, tc) in moves:
        new_color = (v % 9) + 1
        output[tr][tc] = new_color

    return tuple(tuple(row) for row in output)

