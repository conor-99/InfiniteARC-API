# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: eea407af
Difficulty: easy

=== Tags ===
- Trim trailing background
- Duplicate row pattern
- Fill holes
- Bounce

=== Description ===
The task involves transforming an input grid into an output grid through four
consistent visual operations. First, trailing background pixels (typically
represented as a neutral color like white or empty space) are removed from the
right end of each row, shortening the grid horizontally. Second, any internal
holes—empty spaces completely surrounded by non-background pixels—are filled
with a distinct color to complete the shape. Third, the first row of the
processed grid is duplicated and appended to the bottom, extending the grid
vertically. Finally, the entire grid is reflected horizontally (mirrored),
creating a symmetrical "bounce" effect. These steps ensure the output grid
maintains the structural integrity of the input while applying clear, visual
transformations that are easily recognizable through pattern observation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    width = random.randint(3, 5)
    height = random.randint(3, 5)
    base = [[0]*width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if r == height//2 and c == width//2:
                continue
            else:
                base[r][c] = random.randint(1, 9)
    
    num_trailing = random.randint(0, 2)
    input_grid = [row + [0] * num_trailing for row in base]
    
    def trim_trailing_zeros(grid):
        trimmed = []
        for row in grid:
            while row and row[-1] == 0:
                row = row[:-1]
            trimmed.append(row)
        return trimmed
    
    trimmed = trim_trailing_zeros(input_grid)
    
    def has_hole(grid):
        for r in range(len(grid)):
            for c in range(len(grid[r])):
                if grid[r][c] == 0:
                    if r > 0 and grid[r-1][c] == 0:
                        continue
                    if r < len(grid)-1 and grid[r+1][c] == 0:
                        continue
                    if c > 0 and grid[r][c-1] == 0:
                        continue
                    if c < len(grid[r])-1 and grid[r][c+1] == 0:
                        continue
                    return True
        return False
    
    while not has_hole(trimmed):
        base = [[0]*width for _ in range(height)]
        for r in range(height):
            for c in range(width):
                if r == height//2 and c == width//2:
                    continue
                else:
                    base[r][c] = random.randint(1, 9)
        num_trailing = random.randint(0, 2)
        input_grid = [row + [0] * num_trailing for row in base]
        trimmed = trim_trailing_zeros(input_grid)
    
    def fill_holes(grid):
        grid = [row[:] for row in grid]
        for r in range(len(grid)):
            for c in range(len(grid[r])):
                if grid[r][c] == 0:
                    if r > 0 and grid[r-1][c] != 0 and \
                       r < len(grid)-1 and grid[r+1][c] != 0 and \
                       c > 0 and grid[r][c-1] != 0 and \
                       c < len(grid[r])-1 and grid[r][c+1] != 0:
                        grid[r][c] = 1
        return grid
    
    filled = fill_holes(trimmed)
    filled.append(filled[0][:])
    output = [row[::-1] for row in filled]
    return {"input": input_grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Ensure input is list of lists (convert from tuple if needed)
    input_grid = [list(row) for row in input_grid]
    
    def trim_trailing_zeros(grid):
        trimmed = []
        for row in grid:
            while row and row[-1] == 0:
                row = row[:-1]
            trimmed.append(row)
        return trimmed
    
    def fill_holes(grid):
        grid = [row[:] for row in grid]
        for r in range(len(grid)):
            for c in range(len(grid[r])):
                if grid[r][c] == 0:
                    if r > 0 and grid[r-1][c] != 0 and \
                       r < len(grid)-1 and grid[r+1][c] != 0 and \
                       c > 0 and grid[r][c-1] != 0 and \
                       c < len(grid[r])-1 and grid[r][c+1] != 0:
                        grid[r][c] = 1
        return grid
    
    def duplicate_first_row(grid):
        grid.append(grid[0][:])
        return grid
    
    def mirror_horizontal(grid):
        return [row[::-1] for row in grid]
    
    trimmed = trim_trailing_zeros(input_grid)
    filled = fill_holes(trimmed)
    duplicated = duplicate_first_row(filled)
    output = mirror_horizontal(duplicated)
    return output
