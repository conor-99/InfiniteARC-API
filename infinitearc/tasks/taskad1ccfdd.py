# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: ad1ccfdd
Difficulty: insane

=== Tags ===
- Multi layer projection
- Relational projection
- Signal tracing
- Periodic offset matching
- Image rotation

=== Description ===
Rotational Signal Matrix  Input grids are large (20×20 or larger) with a uniform
background color. Overlaid on the background are multiple 3×3 "tile" regions
arranged in a grid pattern, each containing a simple color pattern rotated by
0°, 90°, 180°, or 270°. The rotation angle for each column of tiles is
determined by a horizontal "rotation signal" sequence along the top edge of the
grid. Each 3-color segment in the signal corresponds to a rotation angle for its
column (color 1 = 90°, color 2 = 180°, color 3 = 270°, color 4 = 0°), cycling
through these values.  The output grid is generated through multi-layer
processing: 1. **Relational Projection**: Each tile is rotated to its original
orientation (reversing the rotation signal) and shifted by a periodic offset
based on its position. The offset for tile at (i,j) is ((i + j) mod 4) cells
right and down. 2. **Signal Tracing**: A path begins at the top-left corner
moving right. When encountering a tile's edge, the path turns according to the
tile's rotation (e.g., 90° rotation causes a 90° turn), tracing the path with
colors cycling through the rotation signal sequence. 3. **Multi-layer
Combination**: The output combines the projected tiles (with offsets) and the
traced path, with path colors overriding tile colors in overlapping cells.  All
rules are visual, relying on color patterns, geometric relationships, and
periodic spatial offsets rather than numerical values. The solver must reverse
rotations, apply position-based offsets, and trace direction-changing paths
through the grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def rotate90(mat):
    # rotate a square matrix 90 degrees clockwise
    return [list(row) for row in zip(*mat[::-1])]


def rotate(mat, times):
    res = [list(row) for row in mat]
    t = times % 4
    for _ in range(t):
        res = rotate90(res)
    return res


def generate():
    # Tile grid dimensions (tiles are 3x3). Keep overall grid between 20 and 30.
    tile_size = 3
    # Choose number of tile columns and rows so that final grid (with margins) is >=20 and <=30
    N = random.randint(7, 8)  # columns
    M = random.randint(7, 8)  # rows

    # reserve up to 3 extra columns/rows for the projection offset space
    extra = 3
    W = 3 * N + extra
    H = 1 + 3 * M + extra  # row 0 is the signal row

    # create empty input grid (background color 0)
    input_grid = [[0 for _ in range(W)] for _ in range(H)]

    # create the horizontal rotation signal along the top row in 3-column segments
    signal_colors = []
    for j in range(N):
        color = random.randint(1, 4)  # 1..4 map to rotations
        signal_colors.append(color)
        for k in range(3):
            input_grid[0][3 * j + k] = color

    # choose a simple 3x3 canonical tile pattern using colors outside 1..4
    palette = [5, 6, 7, 8, 9]
    a = random.choice(palette)
    b = random.choice([x for x in palette if x != a])

    tile_original = [
        [a, 0, 0],
        [a, a, 0],
        [0, 0, b]
    ]

    # mapping from signal color to number of 90-degree clockwise rotations
    rot_times = {1: 1, 2: 2, 3: 3, 4: 0}

    # place rotated tiles into the input grid (tiles occupy rows 1..)
    for i in range(M):
        for j in range(N):
            times = rot_times[signal_colors[j]]
            rotated_tile = rotate(tile_original, times)
            r0 = 1 + 3 * i
            c0 = 3 * j
            for dr in range(3):
                for dc in range(3):
                    val = rotated_tile[dr][dc]
                    if val != 0:
                        input_grid[r0 + dr][c0 + dc] = val

    # Build the output: (1) project each tile back to its canonical orientation and shift
    output_grid = [[0 for _ in range(W)] for _ in range(H)]
    for i in range(M):
        for j in range(N):
            r0 = 1 + 3 * i
            c0 = 3 * j
            # read the tile from the input (rotated form)
            tile_in = [[input_grid[r0 + dr][c0 + dc] for dc in range(3)] for dr in range(3)]
            times = rot_times[signal_colors[j]]
            inv_times = (-times) % 4
            tile_proj = rotate(tile_in, inv_times)
            offset = (i + j) % 4
            pr = r0 + offset
            pc = c0 + offset
            for dr in range(3):
                for dc in range(3):
                    rr = pr + dr
                    cc = pc + dc
                    if 0 <= rr < H and 0 <= cc < W and tile_proj[dr][dc] != 0:
                        output_grid[rr][cc] = tile_proj[dr][dc]

    # (2) trace a path starting at top-left (0,0) moving right; when the next cell is non-zero
    # in the input, turn according to that column's rotation (clockwise). Path colors cycle
    # through the rotation signal sequence. Path colors override projected tiles.
    current = (0, 0)
    direction = (0, 1)
    idx = 0
    max_steps = W * H * 5
    steps = 0
    while steps < max_steps:
        x, y = current
        if x < 0 or x >= H or y < 0 or y >= W:
            break
        # color for this path cell cycles through the signal_colors list
        color = signal_colors[idx % len(signal_colors)]
        output_grid[x][y] = color
        idx += 1

        next_x = x + direction[0]
        next_y = y + direction[1]

        if 0 <= next_x < H and 0 <= next_y < W and input_grid[next_x][next_y] != 0:
            jcol = next_y // 3
            if jcol >= len(signal_colors):
                jcol = len(signal_colors) - 1
            rot = signal_colors[jcol]
            # apply clockwise rotation to the direction
            if rot == 1:
                direction = (direction[1], -direction[0])
            elif rot == 2:
                direction = (-direction[0], -direction[1])
            elif rot == 3:
                direction = (-direction[1], direction[0])
            else:
                # rot == 4 -> 0 degrees, no change
                direction = direction

        current = (next_x, next_y)
        steps += 1

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0])

    # read the top-edge rotation signal in 3-column segments
    signal_colors = []
    j = 0
    while j < W:
        c = grid[0][j]
        if c == 0:
            break
        # normally the signal is written in 3-column groups, but be robust
        if j + 2 < W and grid[0][j] == grid[0][j + 1] == grid[0][j + 2]:
            signal_colors.append(grid[0][j])
            j += 3
        else:
            # fallback (shouldn't normally happen for generated grids)
            signal_colors.append(grid[0][j])
            j += 1

    if len(signal_colors) == 0:
        return [[0] * W for _ in range(H)]

    # detect how many tile rows exist by scanning 3-row blocks starting at row 1
    M = 0
    i = 0
    while True:
        r0 = 1 + 3 * i
        if r0 + 2 >= H:
            break
        found = False
        for rr in range(r0, r0 + 3):
            for cc in range(0, min(3 * len(signal_colors), W)):
                if grid[rr][cc] != 0:
                    found = True
                    break
            if found:
                break
        if not found:
            break
        M += 1
        i += 1

    # helper rotations (clockwise 90-degree steps)
    def rotate90(mat):
        return [list(row) for row in zip(*mat[::-1])]

    def rotate(mat, times):
        res = [list(row) for row in mat]
        t = times % 4
        for _ in range(t):
            res = rotate90(res)
        return res

    rot_times = {1: 1, 2: 2, 3: 3, 4: 0}

    # (1) project tiles: rotate each tile back to canonical orientation and shift by offset
    output = [[0 for _ in range(W)] for _ in range(H)]
    for i in range(M):
        for j in range(len(signal_colors)):
            r0 = 1 + 3 * i
            c0 = 3 * j
            tile_in = [[grid[r0 + dr][c0 + dc] for dc in range(3)] for dr in range(3)]
            times = rot_times[signal_colors[j]]
            inv_times = (-times) % 4
            tile_proj = rotate(tile_in, inv_times)
            offset = (i + j) % 4
            pr = r0 + offset
            pc = c0 + offset
            for dr in range(3):
                for dc in range(3):
                    rr = pr + dr
                    cc = pc + dc
                    if 0 <= rr < H and 0 <= cc < W and tile_proj[dr][dc] != 0:
                        output[rr][cc] = tile_proj[dr][dc]

    # (2) trace the path using the same rules as the generator (colors cycle through signal_colors)
    current = (0, 0)
    direction = (0, 1)
    idx = 0
    max_steps = W * H * 5
    steps = 0
    while steps < max_steps:
        x, y = current
        if x < 0 or x >= H or y < 0 or y >= W:
            break
        color = signal_colors[idx % len(signal_colors)]
        output[x][y] = color
        idx += 1

        next_x = x + direction[0]
        next_y = y + direction[1]

        if 0 <= next_x < H and 0 <= next_y < W and grid[next_x][next_y] != 0:
            jcol = next_y // 3
            if jcol >= len(signal_colors):
                jcol = len(signal_colors) - 1
            rot = signal_colors[jcol]
            if rot == 1:
                direction = (direction[1], -direction[0])
            elif rot == 2:
                direction = (-direction[0], -direction[1])
            elif rot == 3:
                direction = (-direction[1], direction[0])
            else:
                direction = direction

        current = (next_x, next_y)
        steps += 1

    return output

