# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: d919257d
Difficulty: medium–hard

=== Tags ===
- Signal to structure
- X marks the spot

=== Description ===
**Task Name: Crosshatch Grid**    **Description:**   Input grids are medium-
sized (10×10 to 20×20) with a single background color. Scattered across the grid
are **X markers** (represented by color 8), each marking a specific intersection
point in a hidden grid structure. The X markers are placed at regular intervals
along rows and columns (e.g., every 3–4 cells), but not all intersection points
are present.    In the output grid, the same X markers remain unchanged. A
**grid structure** is drawn using color 5 (gray) to connect adjacent X markers:
- **Horizontal lines**: For each row containing X markers, sort the columns of
the Xs. Between every pair of consecutive Xs in that row, draw a horizontal line
(color 5) spanning the empty cells between them.   - **Vertical lines**: For
each column containing X markers, sort the rows of the Xs. Between every pair of
consecutive Xs in that column, draw a vertical line (color 5) spanning the empty
cells between them.    The grid structure is **never drawn over X markers or
background elements**, and all lines are strictly confined to background cells.
The output grid retains the input’s background color, X markers, and the newly
added grid lines, forming a complete, connected grid that visually "connects"
the X spots.    This task requires identifying the sparse X pattern, inferring
the regular grid spacing, and reconstructing the full grid structure through
logical spatial reasoning—making it medium-hard due to the need to process
multiple spatial relationships in parallel.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    bg_color = random.choice([c for c in range(10) if c != 5 and c != 8])
    step_x = random.choice([3, 4])
    step_y = random.choice([3, 4])
    
    input_grid = [[bg_color] * width for _ in range(height)]
    
    for r in range(0, height, step_y):
        for c in range(0, width, step_x):
            if random.random() < 0.8:
                input_grid[r][c] = 8
    
    output_grid = [row[:] for row in input_grid]
    
    for r in range(height):
        cols_with_x = [c for c in range(width) if input_grid[r][c] == 8]
        cols_with_x.sort()
        for i in range(1, len(cols_with_x)):
            c1, c2 = cols_with_x[i-1], cols_with_x[i]
            for c in range(c1 + 1, c2):
                output_grid[r][c] = 5
    
    for c in range(width):
        rows_with_x = [r for r in range(height) if input_grid[r][c] == 8]
        rows_with_x.sort()
        for i in range(1, len(rows_with_x)):
            r1, r2 = rows_with_x[i-1], rows_with_x[i]
            for r in range(r1 + 1, r2):
                output_grid[r][c] = 5
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    
    for r in range(height):
        cols_with_x = [c for c in range(width) if grid[r][c] == 8]
        cols_with_x.sort()
        for i in range(1, len(cols_with_x)):
            c1, c2 = cols_with_x[i-1], cols_with_x[i]
            for c in range(c1 + 1, c2):
                grid[r][c] = 5
    
    for c in range(width):
        rows_with_x = [r for r in range(height) if grid[r][c] == 8]
        rows_with_x.sort()
        for i in range(1, len(rows_with_x)):
            r1, r2 = rows_with_x[i-1], rows_with_x[i]
            for r in range(r1 + 1, r2):
                grid[r][c] = 5
    
    return tuple(tuple(row) for row in grid)
