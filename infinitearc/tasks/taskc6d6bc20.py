# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: c6d6bc20
Difficulty: very hard

=== Tags ===
- Local convolution rule
- Rule gate simulation

=== Description ===
Input grids are 15×15 to 30×30 grids with a background color (0) and multiple
"gate" cells (colors 1-9) distributed throughout. Each gate color encodes a
specific directional rule: 1=up, 2=right, 3=down, 4=left, 5=top-left, 6=top-
right, 7=bottom-left, 8=bottom-right, 9=center. For each non-gate cell, the
output color is determined by the direction associated with the nearest gate
(measured by Manhattan distance). If multiple gates are equidistant, the one
with the smallest color number is selected. The gate cells themselves remain
unchanged in the output. The directional rule specifies which neighbor's color
to adopt: for example, a gate of color 5 (top-left) requires the output cell to
take the color from its top-left neighbor; a gate of color 9 (center) leaves the
cell unchanged (though such gates are rare in inputs). For neighbors outside
grid boundaries, the output cell retains background color (0). The output grid
forms intricate visual patterns where colors propagate diagonally or
orthogonally based on the spatial arrangement of gates, creating cascading
transformations that require multi-step spatial reasoning to decode. The task
demands precise identification of gate influence zones and directional
propagation paths across the entire grid, with no two gates sharing identical
directional rules in a single input.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import randint

def generate():
    w = randint(15, 30)
    h = randint(15, 30)
    grid_input = [[0] * w for _ in range(h)]
    
    k = randint(3, 9)
    colors = random.sample(range(1, 10), k)
    positions = []
    while len(positions) < k:
        r = randint(0, h-1)
        c = randint(0, w-1)
        if (r, c) not in positions:
            positions.append((r, c))
            grid_input[r][c] = colors[len(positions)-1]
    
    grid_output = [[0] * w for _ in range(h)]
    directions = {
        1: (-1, 0),
        2: (0, 1),
        3: (1, 0),
        4: (0, -1),
        5: (-1, -1),
        6: (-1, 1),
        7: (1, -1),
        8: (1, 1),
        9: (0, 0)
    }
    
    for r in range(h):
        for c in range(w):
            if grid_input[r][c] != 0:
                grid_output[r][c] = grid_input[r][c]
            else:
                min_dist = float('inf')
                nearest_gate = None
                for (gr, gc) in positions:
                    dist = abs(r - gr) + abs(c - gc)
                    if dist < min_dist:
                        min_dist = dist
                        nearest_gate = (gr, gc, grid_input[gr][gc])
                    elif dist == min_dist:
                        if grid_input[gr][gc] < nearest_gate[2]:
                            nearest_gate = (gr, gc, grid_input[gr][gc])
                if nearest_gate is None:
                    grid_output[r][c] = 0
                else:
                    dr, dc = directions[nearest_gate[2]]
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < h and 0 <= nc < w:
                        grid_output[r][c] = grid_input[nr][nc]
                    else:
                        grid_output[r][c] = 0
    return {"input": grid_input, "output": grid_output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    grid_input = [list(row) for row in input_grid]
    w = len(grid_input[0])
    h = len(grid_input)
    
    directions = {
        1: (-1, 0),
        2: (0, 1),
        3: (1, 0),
        4: (0, -1),
        5: (-1, -1),
        6: (-1, 1),
        7: (1, -1),
        8: (1, 1),
        9: (0, 0)
    }
    
    gates = []
    for r in range(h):
        for c in range(w):
            if grid_input[r][c] != 0:
                gates.append((r, c, grid_input[r][c]))
    
    grid_output = [[0] * w for _ in range(h)]
    for r in range(h):
        for c in range(w):
            if grid_input[r][c] != 0:
                grid_output[r][c] = grid_input[r][c]
            else:
                min_dist = float('inf')
                nearest_gate = None
                for (gr, gc, color) in gates:
                    dist = abs(r - gr) + abs(c - gc)
                    if dist < min_dist:
                        min_dist = dist
                        nearest_gate = (gr, gc, color)
                    elif dist == min_dist:
                        if color < nearest_gate[2]:
                            nearest_gate = (gr, gc, color)
                if nearest_gate is None:
                    grid_output[r][c] = 0
                else:
                    dr, dc = directions[nearest_gate[2]]
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < h and 0 <= nc < w:
                        grid_output[r][c] = grid_input[nr][nc]
                    else:
                        grid_output[r][c] = 0
    return tuple(tuple(row) for row in grid_output)
