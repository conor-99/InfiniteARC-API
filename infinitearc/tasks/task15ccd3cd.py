# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 15ccd3cd
Difficulty: very hard

=== Tags ===
- Connect components by property
- Color particle fall
- Tunnel connection
- X marks the spot
- Recolor smallest component

=== Description ===
Input grids feature a background color (0) overlaid with multiple connected
components (regions of uniform color 1â€“8) and isolated X markers (color 9). Each
component is a contiguous 4-connected region. The X markers are placed within
background cells and serve as critical reference points for tunnel construction.
The transformation requires three sequential steps:   1. **Tunnel connection**:
For each X marker, identify the unique pair of components aligned horizontally
or vertically with the X lying directly between them. Connect these components
by drawing a straight-line tunnel (using color 1) through the X, traversing only
background cells. Tunnels must not overlap with existing components or X
markers.   2. **Color particle fall**: The tunnel paths represent the "fall"
trajectory of particles (color 1), visually marking the connection between
components.   3. **Recolor smallest component**: After tunnel construction,
identify the smallest component in the grid (by cell count, regardless of
color), and recolor all its cells to color 5.  The output grid preserves all
original components, X markers, and background, while adding tunnels (color 1)
and recoloring the smallest component (color 5). The task demands precise
spatial reasoning to align components with X markers, combinatorial counting to
identify the smallest component, and careful avoidance of overlapping elements
during tunnel construction.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

# Generator for ARC task 473: create grids with multiple rectangular components and X markers
# that lie between horizontally-aligned component pairs. Tunnels (color 1) go through those
# X positions in the output, and the smallest component is recolored to 5.

def generate():
    # Try a few times to generate a valid layout
    for attempt in range(200):
        width = random.randint(12, 25)
        height = random.randint(10, 25)
        grid = common.grid(width, height, 0)

        # Choose a common connector row so horizontal tunnels align easily
        connector_row = random.randint(2, height - 3)

        # Minimal center gap between components (helps ensure room for tunnels)
        min_center_gap = 3

        # Compute a reasonable maximum number of components for this width
        max_possible = (width - 4) // max(1, min_center_gap) + 1
        max_possible = max(3, min(5, max_possible))
        num_components = random.randint(3, max_possible)

        # Choose horizontally-separated centers for components with spacing
        centers = []
        tries_centers = 0
        while len(centers) < num_components and tries_centers < 200:
            cand = random.randint(2, width - 3)
            if all(abs(cand - c) >= min_center_gap for c in centers):
                centers.append(cand)
            tries_centers += 1
        if len(centers) < num_components:
            continue
        centers.sort()

        # Available colors for components: avoid 1 (used for tunnels) and 5 (used for recolor)
        color_pool = [2, 3, 4, 6, 7, 8]
        if len(color_pool) < num_components:
            # As a fallback (shouldn't happen with our ranges), extend with other non-1/5 colors
            color_pool = [c for c in range(2, 9) if c != 5]
        colors = random.sample(color_pool, num_components)

        bboxes = []   # list of (left, right, top, bottom)
        comp_pixels = []
        failed = False

        # Build rectangular components ensuring they contain connector_row
        for i, center in enumerate(centers):
            placed = False
            for tries in range(120):
                comp_w = random.randint(1, min(3, max(1, width - 6)))
                comp_h = random.randint(1, min(5, max(1, height - 4)))

                top_min = max(0, connector_row - comp_h + 1)
                top_max = min(connector_row, height - comp_h)
                if top_min > top_max:
                    continue
                top = random.randint(top_min, top_max)

                left = center - (comp_w // 2)
                # Keep a 1-cell margin from the border so tunnels can be placed
                left = max(1, min(left, width - comp_w - 1))
                right = left + comp_w - 1
                bottom = top + comp_h - 1

                # Ensure horizontal gap from previous component (so a tunnel can exist)
                if bboxes:
                    prev_left, prev_right, prev_top, prev_bottom = bboxes[-1]
                    gap = left - prev_right - 1
                    if gap < 1:
                        # try shifting to the right if possible
                        new_left = prev_right + 2
                        new_right = new_left + comp_w - 1
                        if new_right < width - 1:
                            left, right = new_left, new_right
                        else:
                            continue

                # Check no overlap with any previous component (rectangles should be disjoint)
                overlap = False
                for (pl, pr, pt, pb) in bboxes:
                    if not (right < pl or left > pr or bottom < pt or top > pb):
                        overlap = True
                        break
                if overlap:
                    continue

                # If passed all tests, accept placement
                bboxes.append((left, right, top, bottom))
                pixels = [(r, c) for r in range(top, bottom + 1) for c in range(left, right + 1)]
                comp_pixels.append(pixels)
                placed = True
                break

            if not placed:
                failed = True
                break

        if failed or len(bboxes) != num_components:
            continue

        # Paint components onto the grid
        for color, pixels in zip(colors, comp_pixels):
            for (r, c) in pixels:
                grid[r][c] = color

        # Choose a random subset of adjacent pairs to place X markers between
        adjacent_indices = list(range(num_components - 1))
        if not adjacent_indices:
            continue
        k = random.randint(1, len(adjacent_indices))
        chosen_pairs = random.sample(adjacent_indices, k)

        x_positions = []  # store tuples (r, c, left_index)
        ok_place = True
        for pi in chosen_pairs:
            left_bbox = bboxes[pi]
            right_bbox = bboxes[pi + 1]
            left_right = left_bbox[1]
            right_left = right_bbox[0]
            # There must be at least one column between rectangles
            if right_left - left_right <= 1:
                ok_place = False
                break
            # Pick an X column in the empty corridor
            xcol_candidates = [c for c in range(left_right + 1, right_left) if grid[connector_row][c] == 0]
            if not xcol_candidates:
                ok_place = False
                break
            xcol = random.choice(xcol_candidates)
            grid[connector_row][xcol] = 9
            x_positions.append((connector_row, xcol, pi))

        if not ok_place or not x_positions:
            # Failed to place X markers cleanly; retry generation
            continue

        # Build output: add tunnels (color 1) through the corridor (overwriting X) but not components
        output = [row[:] for row in grid]
        for (xr, xc, left_index) in x_positions:
            left_right = bboxes[left_index][1]
            right_left = bboxes[left_index + 1][0]
            for cc in range(left_right + 1, right_left):
                # Only draw tunnel through background or the X cell
                if grid[xr][cc] == 0 or grid[xr][cc] == 9:
                    output[xr][cc] = 1

        # Recolor the smallest component (by number of cells) to color 5
        sizes = [len(pixels) for pixels in comp_pixels]
        smallest_idx = min(range(len(sizes)), key=lambda i: (sizes[i], bboxes[i][0], bboxes[i][2]))
        for (r, c) in comp_pixels[smallest_idx]:
            output[r][c] = 5

        # Guarantee input != output (there will be at least tunnels and/or recolor)
        if output == grid:
            continue

        return {"input": grid, "output": output}

    # If we fail to generate after many attempts, raise an error
    raise RuntimeError("Failed to generate task after many attempts")



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert tuple-of-tuples to a mutable list-of-lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0]) if h > 0 else 0

    # Prepare output as copy of input
    output = [row[:] for row in grid]

    # Find all X markers (value 9)
    x_positions = [(r, c) for r in range(h) for c in range(w) if grid[r][c] == 9]

    # For each X, try horizontal then vertical connection
    for (r, c) in x_positions:
        # Horizontal scan
        left_col = None
        right_col = None

        cc = c - 1
        while cc >= 0:
            val = grid[r][cc]
            if val == 0 or val == 9:
                cc -= 1
                continue
            if 1 <= val <= 8:
                left_col = cc
            break

        cc = c + 1
        while cc < w:
            val = grid[r][cc]
            if val == 0 or val == 9:
                cc += 1
                continue
            if 1 <= val <= 8:
                right_col = cc
            break

        drawn = False
        if left_col is not None and right_col is not None and left_col < c < right_col:
            # Verify path cells are background or X and do not overwrite components
            ok = True
            for cc in range(left_col + 1, right_col):
                if grid[r][cc] != 0 and grid[r][cc] != 9:
                    ok = False
                    break
            if ok:
                for cc in range(left_col + 1, right_col):
                    output[r][cc] = 1
                drawn = True

        if drawn:
            continue

        # Vertical scan
        up_row = None
        down_row = None

        rr = r - 1
        while rr >= 0:
            val = grid[rr][c]
            if val == 0 or val == 9:
                rr -= 1
                continue
            if 1 <= val <= 8:
                up_row = rr
            break

        rr = r + 1
        while rr < h:
            val = grid[rr][c]
            if val == 0 or val == 9:
                rr += 1
                continue
            if 1 <= val <= 8:
                down_row = rr
            break

        if up_row is not None and down_row is not None and up_row < r < down_row:
            ok = True
            for rr in range(up_row + 1, down_row):
                if grid[rr][c] != 0 and grid[rr][c] != 9:
                    ok = False
                    break
            if ok:
                for rr in range(up_row + 1, down_row):
                    output[rr][c] = 1

    # Now find connected components in the original input grid (colors 1..8)
    visited = [[False] * w for _ in range(h)]
    components = []  # list of lists of (r,c)
    for r in range(h):
        for c in range(w):
            if visited[r][c]:
                continue
            val = grid[r][c]
            if not (1 <= val <= 8):
                continue
            # BFS
            queue = [(r, c)]
            visited[r][c] = True
            pixels = []
            while queue:
                cr, cc = queue.pop(0)
                pixels.append((cr, cc))
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] == val:
                        visited[nr][nc] = True
                        queue.append((nr, nc))
            components.append(pixels)

    if components:
        # Select the smallest component (tie-break deterministically by left then top to match generator)
        def comp_key(pixels):
            size = len(pixels)
            leftmost = min(p[1] for p in pixels)
            topmost = min(p[0] for p in pixels)
            return (size, leftmost, topmost)
        smallest = min(components, key=comp_key)
        for (r, c) in smallest:
            output[r][c] = 5

    return output

