# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: b08f2cbc
Difficulty: mediumâ€“hard

=== Tags ===
- Draw path through ordered checkpoints
- Take complement

=== Description ===
Input grids feature a background color (e.g., black) with obstacle elements
(e.g., gray blocks) forming a maze-like structure. Scattered within the
background are checkpoint markers of distinct colors (e.g., red, green, blue),
where each marker's color corresponds to its position in a sequence (red = 1st,
green = 2nd, blue = 3rd, etc.). The checkpoints are positioned such that a
continuous path through the background (complement of obstacle regions) can
connect them in order without intersecting obstacles.  The output grid requires
drawing a minimal-length path (using a designated path color, e.g., yellow)
between consecutive checkpoints, moving only through background cells in
4-directional steps (no diagonals). The path must avoid all obstacle elements
and follow the shortest possible route between each pair of consecutive
checkpoints. Obstacle elements and checkpoint markers remain unchanged in the
output, while the background is preserved except for the newly drawn path. The
"Take complement" aspect refers to the path being drawn exclusively through the
background region (complement of obstacles), ensuring the path visually emerges
from the empty space between obstacles.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque
import common


def generate():
    """
    Generate an ARC-style input/output pair where:
    - background is 0
    - obstacles are a single obstacle color (not used by checkpoints or path)
    - checkpoints are labeled 1..k (k in [3,5]) placed on background
    - a shortest path (4-dir) through the background is drawn between consecutive
      checkpoints using a fixed path color (9). Obstacle and checkpoint colors
      are preserved in the output.
    """
    # Fixed path color (must not collide with checkpoint colors 1..k)
    PATH_COLOR = 9
    # Obstacle color chosen outside checkpoint colors (we'll pick from this small set)
    POSSIBLE_OBSTACLE_COLORS = [6, 7, 8]

    # Helper: check that all background (0) cells form a single 4-connected component
    def background_connected(g):
        rows = len(g)
        cols = len(g[0])
        total_bg = 0
        start = None
        for r in range(rows):
            for c in range(cols):
                if g[r][c] == 0:
                    total_bg += 1
                    if start is None:
                        start = (r, c)
        if total_bg == 0:
            return False
        # BFS flood from start
        seen = {start}
        dq = deque([start])
        while dq:
            r, c = dq.popleft()
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = r + dr, c + dc
                if 0 <= nr < rows and 0 <= nc < cols and g[nr][nc] == 0 and (nr, nc) not in seen:
                    seen.add((nr, nc))
                    dq.append((nr, nc))
        return len(seen) == total_bg

    # BFS shortest-path that walks only on background cells (0) except it may step into `end`.
    def bfs_on_grid(g, start, end):
        rows = len(g)
        cols = len(g[0])
        visited = [[False] * cols for _ in range(rows)]
        prev = [[None] * cols for _ in range(rows)]
        dq = deque()
        dq.append(start)
        visited[start[0]][start[1]] = True
        while dq:
            r, c = dq.popleft()
            if (r, c) == end:
                break
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = r + dr, c + dc
                if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc]:
                    # We can traverse background cells, and we allow entering the `end` even if it
                    # is not background (it will be a checkpoint color in the input).
                    if g[nr][nc] == 0 or (nr, nc) == end:
                        visited[nr][nc] = True
                        prev[nr][nc] = (r, c)
                        dq.append((nr, nc))
        # If end was never visited, there's no path.
        if not visited[end[0]][end[1]]:
            return None
        # Reconstruct intermediate path (exclude start and end)
        path = []
        cur = end
        while cur != start:
            cur = prev[cur[0]][cur[1]]
            if cur is None:
                return None
            if cur != start:
                path.append(cur)
        path.reverse()
        return path

    # Try several times to build a valid example; avoid infinite recursion.
    for attempt in range(200):
        width = random.randint(10, 20)
        height = random.randint(10, 20)
        grid = common.grid(width, height, 0)

        # Decide how many checkpoints and their colors (always 1..k)
        num_checkpoints = random.randint(3, 5)
        checkpoint_colors = list(range(1, num_checkpoints + 1))

        # Pick obstacle color that doesn't collide with checkpoint colors or PATH_COLOR
        obstacle_color = random.choice(POSSIBLE_OBSTACLE_COLORS)
        if obstacle_color in checkpoint_colors or obstacle_color == PATH_COLOR:
            # pick a safe fallback
            obstacle_color = next(c for c in POSSIBLE_OBSTACLE_COLORS if c not in checkpoint_colors and c != PATH_COLOR)

        # Place a number of rectangular obstacle blocks but only keep those that
        # do not disconnect the background.
        blocks = random.randint(8, 18)
        for _ in range(blocks):
            bw = random.randint(1, max(1, width // 4))
            bh = random.randint(1, max(1, height // 4))
            r0 = random.randint(0, height - bh)
            c0 = random.randint(0, width - bw)
            changed = []
            for rr in range(r0, r0 + bh):
                for cc in range(c0, c0 + bw):
                    if grid[rr][cc] == 0:
                        grid[rr][cc] = obstacle_color
                        changed.append((rr, cc))
            # If this block disconnected the background, revert it.
            if not background_connected(grid):
                for (rr, cc) in changed:
                    grid[rr][cc] = 0
            else:
                # randomly carve a few holes in the block to make maze-like structure
                if changed and random.random() < 0.4:
                    hole_count = random.randint(1, max(1, len(changed) // 5))
                    for _h in range(hole_count):
                        hr, hc = random.choice(changed)
                        grid[hr][hc] = 0

        # Collect background cells
        background_cells = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == 0]
        if len(background_cells) < num_checkpoints:
            continue

        # Choose checkpoint positions so that consecutive ones are not immediately adjacent
        chosen = None
        for _try in range(300):
            cand = random.sample(background_cells, num_checkpoints)
            random.shuffle(cand)
            ok = True
            for i in range(len(cand) - 1):
                (r1, c1), (r2, c2) = cand[i], cand[i + 1]
                if abs(r1 - r2) + abs(c1 - c2) <= 1:
                    ok = False
                    break
            if ok:
                chosen = cand
                break
        if chosen is None:
            # couldn't place non-adjacent checkpoints on this obstacle layout; try again
            continue

        # Place checkpoint colors (1..k) into a fresh input grid copy
        input_grid = [row[:] for row in grid]
        for idx, (r, c) in enumerate(chosen):
            input_grid[r][c] = checkpoint_colors[idx]

        # Build the output by drawing shortest paths between successive checkpoints
        output_grid = [row[:] for row in input_grid]
        valid_paths = True
        for i in range(len(chosen) - 1):
            start = chosen[i]
            end = chosen[i + 1]
            path = bfs_on_grid(input_grid, start, end)
            if path is None or len(path) == 0:
                # Unexpected: no path or no intermediate cell (adjacent);
                # treat this layout as invalid and try again.
                valid_paths = False
                break
            for (r, c) in path:
                # only color background cells in the output
                if output_grid[r][c] == 0:
                    output_grid[r][c] = PATH_COLOR
        if not valid_paths:
            continue

        # Ensure the input and output are not identical
        if input_grid == output_grid:
            continue

        return {
            'input': input_grid,
            'output': output_grid
        }

    # Fallback deterministic small valid example if random generation fails
    # (keeps the generator safe and always returns a valid pair)
    w, h = 10, 10
    base = common.grid(w, h, 0)
    # simple wall with a corridor
    for r in range(h):
        base[r][3] = obstacle_color
    base[2][3] = 0
    base[5][3] = 0
    # three checkpoints
    base[1][1] = 1
    base[8][1] = 2
    base[8][8] = 3
    out = [row[:] for row in base]
    # draw simple paths
    def simple_bfs(g, s, e):
        rows = len(g); cols = len(g[0])
        visited = [[False]*cols for _ in range(rows)]
        prev = [[None]*cols for _ in range(rows)]
        dq = deque([s]); visited[s[0]][s[1]] = True
        while dq:
            r,c = dq.popleft()
            if (r,c) == e: break
            for dr,dc in ((1,0),(-1,0),(0,1),(0,-1)):
                nr,nc = r+dr,c+dc
                if 0<=nr<rows and 0<=nc<cols and not visited[nr][nc] and (g[nr][nc]==0 or (nr,nc)==e):
                    visited[nr][nc] = True
                    prev[nr][nc] = (r,c)
                    dq.append((nr,nc))
        if not visited[e[0]][e[1]]: return []
        p = []
        cur = e
        while cur != s:
            cur = prev[cur[0]][cur[1]]
            if cur != s:
                p.append(cur)
        return p[::-1]

    pairs = [((1,1),(8,1)), ((8,1),(8,8))]
    for s,e in pairs:
        for (r,c) in simple_bfs(base,s,e):
            if out[r][c] == 0:
                out[r][c] = PATH_COLOR
    return {'input': base, 'output': out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    rows = len(grid)
    cols = len(grid[0])

    # Identify checkpoint colors: colors 1..k each appearing exactly once, in order
    color_positions = {}
    for r in range(rows):
        for c in range(cols):
            val = grid[r][c]
            if val == 0:
                continue
            if val not in color_positions:
                color_positions[val] = []
            color_positions[val].append((r, c))

    checkpoints = []
    for color in range(1, 10):
        if color in color_positions and len(color_positions[color]) == 1:
            checkpoints.append(color_positions[color][0])
        else:
            break

    # Nothing to draw if fewer than two checkpoints
    if len(checkpoints) < 2:
        return tuple(tuple(row) for row in grid)

    PATH_COLOR = 9

    # BFS that traverses only background cells (0) but may step into the `end` checkpoint
    def bfs(g, start, end):
        visited = [[False] * cols for _ in range(rows)]
        prev = [[None] * cols for _ in range(rows)]
        dq = deque([start])
        visited[start[0]][start[1]] = True
        while dq:
            r, c = dq.popleft()
            if (r, c) == end:
                break
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = r + dr, c + dc
                if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc]:
                    if g[nr][nc] == 0 or (nr, nc) == end:
                        visited[nr][nc] = True
                        prev[nr][nc] = (r, c)
                        dq.append((nr, nc))
        if not visited[end[0]][end[1]]:
            return None
        path = []
        cur = end
        while cur != start:
            cur = prev[cur[0]][cur[1]]
            if cur is None:
                return None
            if cur != start:
                path.append(cur)
        path.reverse()
        return path

    # Draw shortest paths between consecutive checkpoints (using the original input values for traversal)
    original = [list(row) for row in input_grid]
    for i in range(len(checkpoints) - 1):
        s = checkpoints[i]
        e = checkpoints[i + 1]
        path = bfs(original, s, e)
        if path is None:
            # If solver can't find a path (should not happen for valid inputs), skip
            continue
        for (r, c) in path:
            # Only color background cells
            if grid[r][c] == 0:
                grid[r][c] = PATH_COLOR

    return tuple(tuple(row) for row in grid)

