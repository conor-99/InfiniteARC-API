# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: c3838e1b
Difficulty: very hard

=== Tags ===
- Exclusive or coloring
- Progressive rule shift
- Symbolic spatial binding

=== Description ===
Input grids feature a complex arrangement of nested, concentric colored regions
arranged in a spiral pattern, where each region's color is distinct and forms a
connected component. The transformation requires three interdependent steps that
must be applied in sequence to generate the output grid:  1. **Spatial Binding
Shift**: Each concentric layer (starting from the outermost) is assigned a
binding direction (left, up, right, down) that cycles progressively as layers
move inward. The outermost layer uses "left", the next "up", the next "right",
the next "down", and the cycle repeats for deeper layers. The binding direction
determines which neighboring cell's color interacts with the current cell.  2.
**Exclusive Color Combination**: For each cell, the output color is determined
by combining its current color with the color of the neighboring cell in the
binding direction (e.g., if the binding direction is "right", combine with the
cell to the right). This combination follows a non-additive, rule-based
transformation where specific color pairs produce a third color (e.g., red +
blue → green, yellow + purple → cyan), but the exact mapping is not explicitly
provided and must be inferred from the input-output examples.  3. **Progressive
Layer Application**: The binding direction shift progresses inward through each
layer, and the color combination rule is applied recursively. For cells on the
boundary of a region, the neighbor in the binding direction may be outside the
grid, in which case the background color (0) is used for the combination. The
transformation must be applied uniformly across all layers without overlapping
or iterative updates.  The output grid visually reflects these transformations,
with all nested regions adjusted according to their layer-specific binding
direction and color combination rule. The background (color 0) remains
unchanged, and the final grid must maintain the spiral structure of the original
input while adhering to the exclusive coloring logic. No numerical operations
are involved—solutions must be derived through visual pattern recognition of
color interactions and spatial layer progression.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Choose an odd size between 5 and 13 so we have 3..7 concentric layers
    sizes = [5, 7, 9, 11, 13]
    size = random.choice(sizes)
    layers = (size + 1) // 2

    # Select distinct non-background colors for each layer from 1..8 (keeps combine results within 1..9)
    colors = random.sample(range(1, 9), layers)

    # Build the concentric-layer input grid (each layer is a connected region)
    input_grid = [[0] * size for _ in range(size)]
    for r in range(size):
        for c in range(size):
            i = min(r, c, size - 1 - r, size - 1 - c)
            input_grid[r][c] = colors[i]

    # Binding directions cycle: left, up, right, down
    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]

    # Deterministic combining function producing a value in 1..9 for two non-zero colors.
    # Rules:
    # - background cell (a==0) stays 0
    # - combining with background (b==0) returns the cell's own color (no change at edges)
    # - otherwise produce a deterministic color in 1..9 that is not equal to either input color
    def combine(a, b):
        if a == 0:
            return 0
        if b == 0:
            return a
        code = (a * 7 + b * 3) % 9 + 1
        # Ensure code is not equal to either input color (loop shifts deterministically)
        while code == a or code == b:
            code = (code % 9) + 1
        return code

    # Create the output grid by applying the layer-specific binding direction and combine rule
    output_grid = [[0] * size for _ in range(size)]
    for r in range(size):
        for c in range(size):
            a = input_grid[r][c]
            layer = min(r, c, size - 1 - r, size - 1 - c)
            dr, dc = directions[layer % 4]
            nr, nc = r + dr, c + dc
            neighbor = input_grid[nr][nc] if 0 <= nr < size and 0 <= nc < size else 0
            output_grid[r][c] = combine(a, neighbor)

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    h, w = len(grid), len(grid[0])

    # Directions: left, up, right, down (cycle by layer index)
    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]

    def combine(a, b):
        if a == 0:
            return 0
        if b == 0:
            return a
        code = (a * 7 + b * 3) % 9 + 1
        while code == a or code == b:
            code = (code % 9) + 1
        return code

    # Compute output without modifying the source grid (use original values for all combinations)
    out = [[0] * w for _ in range(h)]
    for r in range(h):
        for c in range(w):
            a = grid[r][c]
            layer = min(r, c, h - 1 - r, w - 1 - c)
            dr, dc = directions[layer % 4]
            nr, nc = r + dr, c + dc
            neighbor = grid[nr][nc] if 0 <= nr < h and 0 <= nc < w else 0
            out[r][c] = combine(a, neighbor)

    # Return as an immutable tuple-of-tuples
    return tuple(tuple(row) for row in out)

