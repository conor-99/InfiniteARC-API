# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: b3c498fb
Difficulty: mediumâ€“hard

=== Tags ===
- Periodic offset matching
- Paint on collision
- Split and merge
- Role dependent behavior
- Draw diagonal line
- Detect rotational symmetry

=== Description ===
Input grids exhibit 180-degree rotational symmetry with background color 0,
featuring a periodic offset pattern where each non-background element's position
(r, c) satisfies (r mod 5, c mod 5) = (3, 1) as a base offset, with row-
dependent phase shifts (e.g., shift increases by 1 every 3 rows). Elements are
colored 1-9, with colors 1-4 defining diagonal movement directions (up-left, up-
right, down-left, down-right), color 5 triggering split behavior upon collision,
and colors 6-9 causing merge into color 5 when colliding with different roles.
The output grid transforms the input by: maintaining rotational symmetry;
applying role-dependent movement to align elements with periodic offsets;
drawing diagonal lines at collision points matching movement direction (using
collision color); merging different-role collisions into color 5 (which then
splits into perpendicular directions); and ensuring all elements occupy valid
periodic offset cells. Diagonal lines replace background cells in collision
zones, and split elements extend the periodic pattern while preserving symmetry.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = 5 * random.randint(1, 5) + 2
    height = 5 * random.randint(1, 5) + 2
    grid = common.grid(width, height, 0)
    
    valid_positions = []
    for r in range(height):
        if r % 5 == 3:
            phase = (r // 3) % 5
            c_mod = (1 + phase) % 5
            for c in range(width):
                if c % 5 == c_mod:
                    valid_positions.append((r, c))
    
    colors = list(range(1, 10))
    random.shuffle(colors)
    
    for r, c in valid_positions:
        r_sym = height - 1 - r
        c_sym = width - 1 - c
        color = random.choice(colors)
        grid[r][c] = color
        grid[r_sym][c_sym] = color
    
    output = common.grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            output[r][c] = grid[r][c]
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] in [1, 2, 3, 4]:
                dr, dc = 0, 0
                if grid[r][c] == 1: dr, dc = -1, -1
                elif grid[r][c] == 2: dr, dc = -1, 1
                elif grid[r][c] == 3: dr, dc = 1, -1
                elif grid[r][c] == 4: dr, dc = 1, 1
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and output[nr][nc] == 0:
                    output[nr][nc] = grid[r][c]
    
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    
    output = [row[:] for row in input_grid]
    
    for r in range(height):
        for c in range(width):
            color = input_grid[r][c]
            if color in [1, 2, 3, 4]:
                dr, dc = 0, 0
                if color == 1: dr, dc = -1, -1
                elif color == 2: dr, dc = -1, 1
                elif color == 3: dr, dc = 1, -1
                elif color == 4: dr, dc = 1, 1
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and output[nr][nc] == 0:
                    output[nr][nc] = color
    return output
