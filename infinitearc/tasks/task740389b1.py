# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 740389b1
Difficulty: medium–hard

=== Tags ===
- Shape to color encoding
- Simulate billiards shot
- Rule embedding
- Connect components by property

=== Description ===
Billiard Path Encoding  Input grids are 15×15 grids with a background color (0).
Overlaid on the background are distinct geometric shapes (triangles, squares,
circles) each filled with a unique non-background color (1-9). Each shape is
positioned such that it does not overlap with others, and the grid includes a
single starting point for a ball: a small square of color 5 located on the left
edge of the grid, facing right. The shapes are arranged to form a non-trivial
path for the ball, with multiple potential collision points.  The transformation
involves simulating a billiard ball's trajectory. The ball moves in its current
direction (initially right) until it encounters a shape (a cell with non-
background color). Upon collision, the ball bounces according to a rule encoded
in the shape's color: each color corresponds to a specific bounce direction
(e.g., color 1 may mean 90° left, color 2 may mean 90° right, color 3 may mean
180° reversal). The exact mapping of colors to bounce directions must be
inferred from the input-output examples. The output grid retains all input
elements but draws the ball's path: the initial segment (from start to first
collision) is colored 5, and each subsequent segment (between collisions) is
colored with the shape's color that caused the bounce. The path is drawn
exclusively on background cells, never overlapping shapes, and terminates when
the ball exits the grid. This requires the solver to connect shape properties
(colors) to path coloring while simulating the physics of billiard collisions
through multiple bounces.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import continuous_creature

def generate():
    width = 15
    height = 15
    grid = [[0] * width for _ in range(height)]
    
    # Place start
    start_row = random.randint(1, 13)
    grid[start_row][0] = 5
    
    # Colors for shapes (1-9 excluding 0,5)
    colors = random.sample([1, 2, 3, 4, 6, 7, 8, 9], 3)
    
    for color in colors:
        size = random.randint(3, 10)
        pixels = continuous_creature(size, width, height)
        # Ensure no overlap
        overlap = False
        for r, c in pixels:
            if grid[r][c] != 0:
                overlap = True
                break
        if overlap:
            continue
        for r, c in pixels:
            grid[r][c] = color
    
    # Simulate path
    current_pos = (start_row, 0)
    direction = 0  # right
    current_color = 5
    output_grid = [row[:] for row in grid]
    
    while True:
        dr, dc = [(0,1), (-1,0), (0,-1), (1,0)][direction]
        next_pos = (current_pos[0] + dr, current_pos[1] + dc)
        if not (0 <= next_pos[0] < height and 0 <= next_pos[1] < width):
            break
        if grid[next_pos[0]][next_pos[1]] != 0:
            hit_color = grid[next_pos[0]][next_pos[1]]
            mod = hit_color % 3
            if mod == 0:
                turn = 'reverse'
            elif mod == 1:
                turn = 'left'
            else:
                turn = 'right'
            if turn == 'left':
                direction = (direction + 1) % 4
            elif turn == 'right':
                direction = (direction - 1) % 4
            else:
                direction = (direction + 2) % 4
            current_color = hit_color
        else:
            output_grid[next_pos[0]][next_pos[1]] = current_color
            current_pos = next_pos
    
    if grid == output_grid:
        return generate()
    
    return {"input": grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    
    # Find start position (color 5 on left edge)
    start_pos = None
    for r in range(height):
        if grid[r][0] == 5:
            start_pos = (r, 0)
            break
    if start_pos is None:
        return input_grid  # Should not happen, but fallback
    
    # Define bounce function based on color % 3
    def get_turn(color):
        mod = color % 3
        if mod == 0:
            return 'reverse'
        elif mod == 1:
            return 'left'
        else:
            return 'right'
    
    current_pos = start_pos
    direction = 0  # right
    current_color = 5
    output_grid = [row[:] for row in grid]
    
    while True:
        dr, dc = [(0, 1), (-1, 0), (0, -1), (1, 0)][direction]
        next_pos = (current_pos[0] + dr, current_pos[1] + dc)
        if not (0 <= next_pos[0] < height and 0 <= next_pos[1] < width):
            break
        if grid[next_pos[0]][next_pos[1]] != 0:
            hit_color = grid[next_pos[0]][next_pos[1]]
            turn = get_turn(hit_color)
            if turn == 'left':
                direction = (direction + 1) % 4
            elif turn == 'right':
                direction = (direction - 1) % 4
            else:
                direction = (direction + 2) % 4
            current_color = hit_color
        else:
            output_grid[next_pos[0]][next_pos[1]] = current_color
            current_pos = next_pos
    
    return output_grid
