# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 18127ed4
Difficulty: hard

=== Tags ===
- Gravity with barriers
- Count touches

=== Description ===
Input grids feature a background color (0), fixed barrier structures (color 2),
and movable blocks (color 1) positioned above barriers. Barriers form irregular,
non-orthogonal structures that block downward movement. Movable blocks fall
vertically until they contact a barrier (i.e., the cell directly below is a
barrier or the grid's bottom edge). In the output grid, each block is relocated
to its final position after gravity application. The block's original color (1)
is replaced by a color equal to the count of adjacent barrier cells (up, down,
left, right) in its new position. Adjacent barriers are cells of color 2
directly adjacent to the block's cell (not diagonally), with counts ranging from
1 to 4. Background cells (0) and barrier structures (2) remain unchanged. The
transformation requires simulating gravity for all blocks followed by neighbor-
based counting to determine output colors.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import hollow_conway, grid

def generate():
    w = random.randint(2, 30)
    h = random.randint(2, 30)
    input_grid = grid(w, h, 0)
    
    barrier_rows, barrier_cols = hollow_conway(w, h, tries=5)
    for r, c in zip(barrier_rows, barrier_cols):
        input_grid[r][c] = 2
    
    blocks = []
    for r, c in zip(barrier_rows, barrier_cols):
        if r >= 2:
            input_grid[r-2][c] = 1
            blocks.append((r-2, c))
    
    if not blocks:
        input_grid[0][0] = 1
        blocks.append((0, 0))
    
    output_grid = [row[:] for row in input_grid]
    
    for r, c in blocks:
        r_final = r
        while r_final + 1 < h and input_grid[r_final + 1][c] == 0:
            r_final += 1
        output_grid[r][c] = 0
        output_grid[r_final][c] = 1
        
        count = 0
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r_final + dr, c + dc
            if 0 <= nr < h and 0 <= nc < w and input_grid[nr][nc] == 2:
                count += 1
        output_grid[r_final][c] = count
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    w = len(input_grid[0])
    h = len(input_grid)
    output_grid = [list(row) for row in input_grid]
    
    blocks = []
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] == 1:
                blocks.append((r, c))
    
    for r, c in blocks:
        r_final = r
        while r_final + 1 < h and input_grid[r_final + 1][c] == 0:
            r_final += 1
        output_grid[r][c] = 0
        output_grid[r_final][c] = 1
    
    for r in range(h):
        for c in range(w):
            if output_grid[r][c] == 1:
                count = 0
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < h and 0 <= nc < w and input_grid[nr][nc] == 2:
                        count += 1
                output_grid[r][c] = count
    
    return output_grid
