# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 27d19b00
Difficulty: medium–hard

=== Tags ===
- Gas expansion
- Pattern expansion
- Non rectangular tiling

=== Description ===
Input grids feature a single background color (e.g., 0) and a small, contiguous,
non-rectangular gas pattern (e.g., a diamond-shaped cluster of 5 cells forming a
cross-like structure) of a unique color (e.g., 1), entirely surrounded by
background cells. The gas pattern must be non-rectangular—meaning it cannot form
a perfect rectangle or square—such as a diamond, triangle, or irregular cluster
that spans multiple rows and columns. The output grid replicates this gas
pattern across the entire grid in a hexagonal tiling pattern, where each
subsequent row of patterns is offset horizontally by one cell to the right
relative to the row above. Replication occurs exclusively in background regions
(cells not containing the original gas pattern or any previously placed copies),
and the original gas pattern remains visible in its initial position. The tiling
continues until no further valid placements exist without overlapping existing
patterns, exceeding grid boundaries, or intersecting non-background elements.
The resulting output displays a seamless, non-rectangular lattice structure
composed of the gas pattern, forming a larger geometric arrangement that follows
the hexagonal offset rule, with no gaps or overlaps in the tiled pattern.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import math
from common import grid, continuous_creature


def generate():
    """
    Generate a grid containing a single small, contiguous, non-rectangular pattern (gas)
    and an output where that pattern is tiled in a hex-like lattice: each subsequent
    row is shifted one cell to the right relative to the row above. Placement only
    occurs on background cells (0) and never overlaps existing non-background cells.
    """
    tries = 0
    while True:
        tries += 1
        # Grid size: keep moderate so we can tile but also have variety
        width = random.randint(7, 20)
        height = random.randint(7, 20)

        # Choose a small bounding box for the pattern
        max_box_w = min(4, width - 4)
        max_box_h = min(4, height - 4)
        if max_box_w < 2 or max_box_h < 2:
            # Grid too small, try again
            continue
        p_bbox_w = random.randint(2, max_box_w)
        p_bbox_h = random.randint(2, max_box_h)

        # Pattern size (number of cells)
        p_size = random.randint(3, min(6, p_bbox_w * p_bbox_h))

        # Create a contiguous creature inside the small bbox
        pixels = continuous_creature(p_size, width=p_bbox_w, height=p_bbox_h)

        # Ensure pattern is non-rectangular (its pixel count < bbox area)
        if len(pixels) == p_bbox_w * p_bbox_h:
            if tries > 200:
                # keep progress (avoid infinite loop) -- try a different bbox
                continue
            else:
                continue

        # Compute relative coordinates anchored at the pattern's top-left
        min_pr = min(r for r, c in pixels)
        min_pc = min(c for r, c in pixels)
        rel_pattern = [(r - min_pr, c - min_pc) for r, c in pixels]
        ph = max(r - min_pr for r, c in pixels) + 1
        pw = max(c - min_pc for r, c in pixels) + 1

        # Choose a placement for the original pattern at least one cell away from edges
        if height - ph - 2 < 1 or width - pw - 2 < 1:
            # not enough interior space, try again
            continue
        r0 = random.randint(1, height - ph - 1)
        c0 = random.randint(1, width - pw - 1)

        # Choose a color for the gas
        color = random.randint(1, 9)

        # Create input grid and place the original pattern
        grid_in = grid(width, height, 0)
        for dr, dc in rel_pattern:
            grid_in[r0 + dr][c0 + dc] = color

        # Now tile the pattern across the grid in a hex-like lattice:
        # vertical step = ph (bounding box height), horizontal step = pw + 1
        vertical_step = ph
        horizontal_step = pw + 1

        grid_out = [row[:] for row in grid_in]

        # compute range of row indices (i) such that r = r0 + i*vertical_step is valid
        i_min = math.ceil(-r0 / vertical_step)
        i_max = math.floor((height - ph - r0) / vertical_step)

        # Try all candidate positions (rows i, columns j) and greedily place patterns
        for i in range(int(i_min), int(i_max) + 1):
            offset = int(i % 2)
            r_start = r0 + i * vertical_step
            # For this row, compute j range so that c_start + pw fits in [0, width]
            j_min = math.ceil(-(c0 + offset) / horizontal_step)
            j_max = math.floor((width - pw - (c0 + offset)) / horizontal_step)
            for j in range(int(j_min), int(j_max) + 1):
                c_start = c0 + offset + j * horizontal_step
                # Check bounds (should be OK by construction)
                if r_start < 0 or c_start < 0 or r_start + ph > height or c_start + pw > width:
                    continue
                # Ensure placement doesn't overlap any non-background cell
                can_place = True
                for dr, dc in rel_pattern:
                    rr = r_start + dr
                    cc = c_start + dc
                    if grid_out[rr][cc] != 0:
                        can_place = False
                        break
                if can_place:
                    for dr, dc in rel_pattern:
                        rr = r_start + dr
                        cc = c_start + dc
                        grid_out[rr][cc] = color

        # Ensure that at least one copy was added (output differs from input)
        if grid_out != grid_in:
            return {"input": grid_in, "output": grid_out}

        # otherwise loop and try a new configuration
        if tries > 1000:
            # As a last resort, build a deterministic small diamond pattern that will tile
            width = max(8, width)
            height = max(8, height)
            grid_in = grid(width, height, 0)
            # a 5-cell cross/diamond pattern
            rel_pattern = [(1, 2), (2, 1), (2, 2), (2, 3), (3, 2)]
            ph = 3
            pw = 3
            r0 = 2
            c0 = 2
            color = random.randint(1, 9)
            for dr, dc in rel_pattern:
                grid_in[r0 + dr][c0 + dc] = color
            grid_out = [row[:] for row in grid_in]
            vertical_step = ph
            horizontal_step = pw + 1
            i_min = math.ceil(-r0 / vertical_step)
            i_max = math.floor((height - ph - r0) / vertical_step)
            for i in range(int(i_min), int(i_max) + 1):
                offset = int(i % 2)
                r_start = r0 + i * vertical_step
                j_min = math.ceil(-(c0 + offset) / horizontal_step)
                j_max = math.floor((width - pw - (c0 + offset)) / horizontal_step)
                for j in range(int(j_min), int(j_max) + 1):
                    c_start = c0 + offset + j * horizontal_step
                    can_place = True
                    for dr, dc in rel_pattern:
                        rr = r_start + dr
                        cc = c_start + dc
                        if rr < 0 or cc < 0 or rr >= height or cc >= width or grid_out[rr][cc] != 0:
                            can_place = False
                            break
                    if can_place:
                        for dr, dc in rel_pattern:
                            rr = r_start + dr
                            cc = c_start + dc
                            grid_out[rr][cc] = color
            if grid_out != grid_in:
                return {"input": grid_in, "output": grid_out}
            # If still fail, continue trying normally
            tries = 0



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import math

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height else 0
    if height == 0 or width == 0:
        return grid

    # Assume background is 0 (per generator). Find the gas color (non-background).
    colors = set()
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                colors.add(grid[r][c])
    if not colors:
        return grid
    # There should be a single gas color; pick it
    color = min(colors)

    # Collect coordinates of the original gas pattern (all cells with this color)
    pattern_pixels = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == color]
    if not pattern_pixels:
        return grid

    # Anchor to top-left of the pattern's bounding box
    min_r = min(r for r, c in pattern_pixels)
    min_c = min(c for r, c in pattern_pixels)
    rel_pattern = [(r - min_r, c - min_c) for r, c in pattern_pixels]
    ph = max(r - min_r for r, c in pattern_pixels) + 1
    pw = max(c - min_c for r, c in pattern_pixels) + 1

    # Tiling parameters must match the generator's logic
    vertical_step = ph
    horizontal_step = pw + 1

    output = [row[:] for row in grid]

    # Compute possible row indices i such that r_start = min_r + i*vertical_step is valid
    i_min = math.ceil(-min_r / vertical_step)
    i_max = math.floor((height - ph - min_r) / vertical_step)

    for i in range(int(i_min), int(i_max) + 1):
        offset = int(i % 2)
        r_start = min_r + i * vertical_step
        j_min = math.ceil(-(min_c + offset) / horizontal_step)
        j_max = math.floor((width - pw - (min_c + offset)) / horizontal_step)
        for j in range(int(j_min), int(j_max) + 1):
            c_start = min_c + offset + j * horizontal_step
            if r_start < 0 or c_start < 0 or r_start + ph > height or c_start + pw > width:
                continue
            # Check overlap
            can_place = True
            for dr, dc in rel_pattern:
                rr = r_start + dr
                cc = c_start + dc
                if output[rr][cc] != 0:
                    can_place = False
                    break
            if can_place:
                for dr, dc in rel_pattern:
                    rr = r_start + dr
                    cc = c_start + dc
                    output[rr][cc] = color

    return output

