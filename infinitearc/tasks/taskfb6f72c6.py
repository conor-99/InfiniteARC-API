# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: fb6f72c6
Difficulty: mediumâ€“hard

=== Tags ===
- Bidirectional mapping
- Hierarchical reasoning
- Deterministic update

=== Description ===
The input grid features multiple nested rectangular regions arranged
hierarchically (levels 1 to 4, with level 1 being the outermost), each defined
by a unique border color and a distinct fill color. The top-left corner contains
a "mapping key" consisting of a horizontal sequence of color pairs (e.g., (3,7),
(5,2)), where each pair corresponds to a specific hierarchy level (first pair
for level 1, second for level 2, etc.). The output grid transforms the fill
color of each rectangle based on the key: for a rectangle at level L, its fill
color is swapped with the corresponding color in the L-th pair (e.g., if the
fill color matches the first element of the pair, it becomes the second element,
and vice versa). Border colors and the structural arrangement of the nested
rectangles remain unchanged. Fill colors not matching either element in their
level's pair are preserved. The transformation is bidirectional (swapping is
mutual), hierarchical (depends on nesting depth), and deterministic (each input
grid has exactly one valid output based on the key's ordering and content).
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

# Global counter to ensure each generated example is unique across repeated calls
_GENERATE_COUNT = 0


def generate():
  global _GENERATE_COUNT
  # increment call counter (used only to make examples unique)
  call_id = _GENERATE_COUNT
  _GENERATE_COUNT += 1

  # number of nesting levels (hierarchy depth)
  N = random.randint(2, 4)

  # ensure there's space for the key (2*N cells), a zero sentinel, and 3-digit unique id
  min_width = max(2 * N + 5, 10)
  min_height = max(2 * N + 3, 10)

  width = random.randint(min_width, min(25, max(min_width, 10)))
  height = random.randint(min_height, min(25, max(min_height, 10)))

  # create empty grid
  grid_input = common.grid(width, height, 0)

  # build mapping key: a sequence of N color pairs (a,b) placed in the top row, left-aligned
  key_pairs = []
  for _ in range(N):
    a = random.randint(1, 9)
    b = random.randint(1, 9)
    while b == a:
      b = random.randint(1, 9)
    key_pairs.append((a, b))

  # flatten key and place in top row starting at column 0
  flat_key = [c for pair in key_pairs for c in pair]
  for i, val in enumerate(flat_key):
    if i < width:
      grid_input[0][i] = val

  # there will be a zero sentinel at column len(flat_key) because grid defaults to 0
  # put a 3-digit call id after the sentinel so each example pair is unique
  id_str = str(call_id).zfill(3)
  base_col = len(flat_key) + 1
  for i, ch in enumerate(id_str):
    col = base_col + i
    if col < width:
      grid_input[0][col] = int(ch)

  # draw nested rectangles. Level L has borders at indices L..(width-L-1) / L..(height-L-1)
  # border colors will be chosen but must not prevent fill color selection
  used_border_colors = set()

  for L in range(1, N + 1):
    top = L
    left = L
    bottom = height - L - 1
    right = width - L - 1

    # ensure rectangle fits (needs at least a 1-pixel border and maybe empty interior)
    if top >= bottom or left >= right:
      break

    # pick a border color distinct from previously used border colors (but can coincide
    # with key colors; that's allowed). If palette exhausted, fallback to any color.
    choices = [c for c in range(1, 10) if c not in used_border_colors]
    border_color = random.choice(choices) if choices else random.randint(1, 9)
    used_border_colors.add(border_color)

    # take the mapping pair for this level
    a, b = key_pairs[L - 1]

    # choose the fill color for this level to be one of the pair elements; ensure it is
    # not identical to the border color (so fills remain visually distinct)
    fill_color = random.choice([a, b])
    if fill_color == border_color:
      fill_color = a if b == border_color else b

    # draw border
    for c in range(left, right + 1):
      grid_input[top][c] = border_color
      grid_input[bottom][c] = border_color
    for r in range(top, bottom + 1):
      grid_input[r][left] = border_color
      grid_input[r][right] = border_color

    # fill interior (exclusive of the border)
    for r in range(top + 1, bottom):
      for c in range(left + 1, right):
        grid_input[r][c] = fill_color

  # produce the output by swapping fill colors inside each level according to the key
  grid_output = [row[:] for row in grid_input]
  for L in range(1, N + 1):
    top = L
    left = L
    bottom = height - L - 1
    right = width - L - 1
    if top >= bottom or left >= right:
      break
    a, b = key_pairs[L - 1]
    for r in range(top + 1, bottom):
      for c in range(left + 1, right):
        cur = grid_input[r][c]
        if cur == a:
          grid_output[r][c] = b
        elif cur == b:
          grid_output[r][c] = a

  return {"input": grid_input, "output": grid_output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
  # Convert to mutable lists
  grid_in = [list(row) for row in input_grid]
  height = len(grid_in)
  width = len(grid_in[0]) if height > 0 else 0

  # Read the mapping key from the top row: read non-zero values from column 0 until a 0 is found
  flat_key = []
  for c in range(width):
    v = grid_in[0][c]
    if v == 0:
      break
    flat_key.append(v)

  # Ensure even length (pairs). If odd, discard the trailing value.
  if len(flat_key) % 2 == 1:
    flat_key = flat_key[:-1]

  N = len(flat_key) // 2
  key_pairs = [(flat_key[2 * i], flat_key[2 * i + 1]) for i in range(N)]

  # Work from a copy of the original so swaps are decided based on the original colors
  orig = [row[:] for row in grid_in]
  out = [row[:] for row in orig]

  for L in range(1, N + 1):
    top = L
    left = L
    bottom = height - L - 1
    right = width - L - 1
    if top >= bottom or left >= right:
      continue
    a, b = key_pairs[L - 1]
    for r in range(top + 1, bottom):
      for c in range(left + 1, right):
        val = orig[r][c]
        if val == a:
          out[r][c] = b
        elif val == b:
          out[r][c] = a
  # return as immutable tuples
  return tuple(tuple(row) for row in out)

