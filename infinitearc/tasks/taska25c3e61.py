# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: a25c3e61
Difficulty: hard

=== Tags ===
- Agent memory trace
- Goal conditioned path
- Jigsaw
- Associate images to images

=== Description ===
Input grids feature a complex maze-like structure with multiple distinct agents
(each represented by a unique color) positioned at various starting points
within open pathways. Each agent has a corresponding goal marker (a different
color) located within the maze, separated by walls (background color 0) and open
corridors. The maze contains interconnected pathways that allow agents to
navigate toward their goals, with walls blocking direct routes. The output grid
must transform the input by applying the following rules:    1. **Agent Memory
Trace**: Each agent follows the shortest path to its goal, moving only through
open cells (non-wall), changing direction only at corners. The path leaves a
continuous *memory trace*—a sequence of cells colored according to a fixed
association between the goal color and trail color (e.g., a blue goal produces a
red trail, determined by a predefined visual mapping).    2. **Goal Conditioned
Path**: The direction of movement is dynamically conditioned by the goal's
relative position. For instance, if the goal lies to the right, the agent
prioritizes rightward movement until blocked by a wall, then adjusts direction.
3. **Jigsaw Path Adjustment**: When two agents’ paths intersect, they merge into
a single path using a *jigsaw principle*—the overlapping segment is replaced by
a new trail color derived from the association rule (e.g., red + blue = purple),
and non-overlapping paths are adjusted to avoid conflicts by taking the shortest
detour around the merged segment.    4. **Associate Images to Images**: The
trail color at every cell must visually correspond to the goal color’s
association (e.g., all goals of color X produce trails of color Y), forming a
consistent mapping across the grid. The output grid retains maze walls and goal
markers but replaces agent starting positions with their trace paths, ensuring
no two paths overlap and all trails adhere to the association rule.    The task
requires synthesizing pathfinding, color association, conflict resolution, and
spatial reasoning to generate the output, with complexity arising from the
interplay of multiple agents, dynamic path adjustments, and strict adherence to
the visual color mapping.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque
import common

WALL = 0
FLOOR = 1

AGENT_COLORS = [2, 3]
GOAL_COLORS = [5, 6]
TRAIL_BY_GOAL = {5: 7, 6: 8}
MERGED_COLOR = 9

def carve_maze(width, height):
    grid = common.grid(width, height, WALL)
    # Start at a random odd cell
    start_r = random.randrange(1, height, 2)
    start_c = random.randrange(1, width, 2)
    grid[start_r][start_c] = FLOOR
    stack = [(start_r, start_c)]
    while stack:
        r, c = stack[-1]
        neighbors = []
        for dr, dc in [(2,0),(-2,0),(0,2),(0,-2)]:
            nr, nc = r + dr, c + dc
            if 0 < nr < height and 0 < nc < width and grid[nr][nc] == WALL:
                neighbors.append((nr, nc, dr, dc))
        if neighbors:
            nr, nc, dr, dc = random.choice(neighbors)
            grid[r + dr//2][c + dc//2] = FLOOR
            grid[nr][nc] = FLOOR
            stack.append((nr, nc))
        else:
            stack.pop()
    return grid

def find_shortest_path(grid, start, goal):
    height = len(grid)
    width = len(grid[0])
    sr, sc = start
    gr, gc = goal
    visited = [[False]*width for _ in range(height)]
    prev = [[None]*width for _ in range(height)]
    q = deque()
    visited[sr][sc] = True
    q.append((sr, sc))
    while q:
        r, c = q.popleft()
        if (r, c) == (gr, gc):
            break
        # Order neighbors by closeness to goal (Manhattan distance)
        neighs = []
        for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] != WALL:
                dist = abs(nr - gr) + abs(nc - gc)
                neighs.append((dist, nr, nc))
        neighs.sort(key=lambda x: x[0])
        for _, nr, nc in neighs:
            visited[nr][nc] = True
            prev[nr][nc] = (r, c)
            q.append((nr, nc))
    if not visited[gr][gc]:
        return None
    path = []
    r, c = gr, gc
    while (r, c) != (sr, sc):
        path.append((r, c))
        r, c = prev[r][c]
    path.append((sr, sc))
    return list(reversed(path))

def assign_agents_to_goals(agent_positions, goal_positions, grid):
    # brute-force search (permutations) for small n (n=2)
    from itertools import permutations
    n = len(agent_positions)
    best = None
    best_perm = None
    for perm in permutations(range(n)):
        total = 0
        ok = True
        for i, gi in enumerate(perm):
            a = agent_positions[i]
            g = goal_positions[gi]
            path = find_shortest_path(grid, a, g)
            if path is None:
                ok = False
                break
            total += len(path)
        if not ok:
            continue
        if best is None or total < best:
            best = total
            best_perm = perm
    if best_perm is None:
        # fallback: identity
        return {i:i for i in range(n)}
    return {i: best_perm[i] for i in range(n)}

def generate():
    # Try multiple times to ensure a valid, interesting grid
    for _ in range(200):
        # choose odd dimensions
        width = random.randint(11, 21)
        height = random.randint(11, 21)
        if width % 2 == 0:
            width = width + 1 if width < 29 else width - 1
        if height % 2 == 0:
            height = height + 1 if height < 29 else height - 1
        base = carve_maze(width, height)
        corridor_cells = [(r, c) for r in range(height) for c in range(width) if base[r][c] == FLOOR]
        if len(corridor_cells) < 8:
            continue
        n_agents = 2
        chosen = random.sample(corridor_cells, n_agents * 2)
        agent_positions = chosen[:n_agents]
        goal_positions = chosen[n_agents:]
        # build input grid: copy base maze
        input_grid = [row[:] for row in base]
        # assign colors to agents and goals
        for i, (r, c) in enumerate(agent_positions):
            input_grid[r][c] = AGENT_COLORS[i]
        for i, (r, c) in enumerate(goal_positions):
            input_grid[r][c] = GOAL_COLORS[i]
        # compute assignment of which agent goes to which goal (by positions)
        assign = assign_agents_to_goals(agent_positions, goal_positions, input_grid)
        # route agents in deterministic order: top-left to bottom-right
        agent_order = sorted(range(n_agents), key=lambda i: (agent_positions[i][0], agent_positions[i][1]))
        occupancy = {}
        ok = True
        for i in agent_order:
            start = agent_positions[i]
            gi = assign[i]
            goal = goal_positions[gi]
            path = find_shortest_path(input_grid, start, goal)
            if path is None:
                ok = False
                break
            # record trail cells except the goal cell (do not overwrite goals)
            for (r, c) in path[:-1]:
                occupancy.setdefault((r, c), set()).add(GOAL_COLORS[gi])
        if not ok:
            continue
        # build output grid
        output_grid = [row[:] for row in input_grid]
        goal_set = set(goal_positions)
        for (r, c), gset in occupancy.items():
            if (r, c) in goal_set:
                continue
            if len(gset) == 1:
                g = next(iter(gset))
                output_grid[r][c] = TRAIL_BY_GOAL[g]
            else:
                output_grid[r][c] = MERGED_COLOR
        if output_grid == input_grid:
            continue
        return {"input": input_grid, "output": output_grid}
    # If failed, as fallback create a trivial grid
    width = 11
    height = 11
    base = [[WALL]*width for _ in range(height)]
    base[1][1] = FLOOR
    input_grid = [row[:] for row in base]
    input_grid[1][1] = AGENT_COLORS[0]
    input_grid[1][3] = GOAL_COLORS[0]
    output_grid = [row[:] for row in input_grid]
    output_grid[1][1] = TRAIL_BY_GOAL[GOAL_COLORS[0]]
    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
from collections import deque

WALL = 0
FLOOR = 1
TRAIL_BY_GOAL = {5: 7, 6: 8}
MERGED_COLOR = 9


def find_shortest_path(grid, start, goal):
    height = len(grid)
    width = len(grid[0])
    sr, sc = start
    gr, gc = goal
    visited = [[False]*width for _ in range(height)]
    prev = [[None]*width for _ in range(height)]
    q = deque()
    visited[sr][sc] = True
    q.append((sr, sc))
    while q:
        r, c = q.popleft()
        if (r, c) == (gr, gc):
            break
        neighs = []
        for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] != WALL:
                dist = abs(nr - gr) + abs(nc - gc)
                neighs.append((dist, nr, nc))
        neighs.sort(key=lambda x: x[0])
        for _, nr, nc in neighs:
            visited[nr][nc] = True
            prev[nr][nc] = (r, c)
            q.append((nr, nc))
    if not visited[gr][gc]:
        return None
    path = []
    r, c = gr, gc
    while (r, c) != (sr, sc):
        path.append((r, c))
        r, c = prev[r][c]
    path.append((sr, sc))
    return list(reversed(path))


def assign_agents_to_goals(agent_positions, goal_positions, grid):
    from itertools import permutations
    n = len(agent_positions)
    best = None
    best_perm = None
    for perm in permutations(range(n)):
        total = 0
        ok = True
        for i, gi in enumerate(perm):
            a = agent_positions[i]
            g = goal_positions[gi]
            path = find_shortest_path(grid, a, g)
            if path is None:
                ok = False
                break
            total += len(path)
        if not ok:
            continue
        if best is None or total < best:
            best = total
            best_perm = perm
    if best_perm is None:
        return {i:i for i in range(n)}
    return {i: best_perm[i] for i in range(n)}


def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    # find non-background colors and their positions
    counts = {}
    positions = {}
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            counts[v] = counts.get(v, 0) + 1
            positions.setdefault(v, []).append((r,c))
    # identify singleton non-wall, non-floor colors (agents and goals)
    singletons = [v for v,count in counts.items() if v not in (WALL, FLOOR) and count == 1]
    if len(singletons) >= 4:
        singletons_sorted = sorted(singletons)
        # assume smaller values are agents, larger are goals
        n_agents = len(singletons_sorted) // 2
        agent_colors = singletons_sorted[:n_agents]
        goal_colors = singletons_sorted[n_agents:n_agents*2]
    else:
        # fallback: detect colors by ranges known from generator
        agent_colors = [2,3]
        goal_colors = [5,6]
    # get positions
    agent_positions = []
    for ac in agent_colors:
        agent_positions.append(positions[ac][0])
    goal_positions = []
    for gc in goal_colors:
        goal_positions.append(positions[gc][0])
    # compute assignment by minimal total path length
    assign = assign_agents_to_goals(agent_positions, goal_positions, grid)
    # route agents in deterministic order (top-left to bottom-right)
    n_agents = len(agent_positions)
    agent_order = sorted(range(n_agents), key=lambda i: (agent_positions[i][0], agent_positions[i][1]))
    occupancy = {}
    for i in agent_order:
        start = agent_positions[i]
        gi = assign[i]
        goal = goal_positions[gi]
        path = find_shortest_path(grid, start, goal)
        if path is None:
            continue
        for (r,c) in path[:-1]:
            occupancy.setdefault((r,c), set()).add(goal_colors[gi])
    # build output
    output = [row[:] for row in grid]
    goal_pos_set = set(goal_positions)
    for (r,c), gset in occupancy.items():
        if (r,c) in goal_pos_set:
            continue
        if len(gset) == 1:
            g = next(iter(gset))
            output[r][c] = TRAIL_BY_GOAL[g]
        else:
            output[r][c] = MERGED_COLOR
    return tuple(tuple(row) for row in output)

