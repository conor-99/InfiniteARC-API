# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: ee0af80a
Difficulty: mediumâ€“hard

=== Tags ===
- Dynamic environment
- Texture transfer
- Path merging
- Portal momentum pathing

=== Description ===
# Portal Momentum Pathways  Input grids feature a dynamic environment composed
of multiple straight-line paths (horizontal or vertical) on a uniform background
(color 0), each path defined by a unique color (1-4). These paths move through
the grid without branching, intersecting only at designated merge points or
through designated portal pairs. Portals consist of paired cells: entrance cells
(color 5) and matching exit cells (color 6), forming one-way connections where
paths entering an entrance exit through the corresponding exit while maintaining
their original direction of travel.  In the output grid, the following
transformations occur: 1. **Portal Momentum:** When a path enters a portal
entrance (color 5), it exits through the corresponding portal exit (color 6)
while preserving its direction of travel (e.g., a path moving right entering a
portal exits moving right from the exit cell). 2. **Texture Transfer:** At non-
portal intersection points (merge points), two paths combine into a single path.
The new path's color is the sum of the original colors modulo 9 (e.g., color 2 +
color 3 = 5). The merged path's direction is determined by the path with the
higher original color (e.g., color 3 > color 2, so the merged path continues in
the direction of the color 3 path). 3. **Path Merging:** Merged paths replace
the original intersecting paths in the output grid, continuing in the merged
direction. All paths must eventually exit the grid boundaries. Background cells
(color 0) remain unchanged, and portal cells (colors 5/6) are removed from the
output (replaced by the merged path or background).  The task requires
identifying portal pairs, tracking path directions, applying modular color
arithmetic, and resolving merge points through multiple concurrent rules. The
output grid must maintain all original path structures while correctly applying
the portal momentum and path merging transformations, with no path overlaps
except at portals and no path directions altered except at merge points.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Ensure sufficient room for paths and portals
    width = random.randint(5, 14)
    height = random.randint(5, 14)
    input_grid = [[0 for _ in range(width)] for _ in range(height)]

    colors = [1, 2, 3, 4]
    random.shuffle(colors)
    num_paths = random.randint(2, 4)

    paths = []  # list of (color, orientation, cells)
    for color in colors[:num_paths]:
        orientation = random.choice(['H', 'V'])
        placed = False
        attempts = 0
        while not placed and attempts < 100:
            attempts += 1
            length = random.randint(3, min(8, width if orientation == 'H' else height))
            if orientation == 'H':
                r = random.randint(0, height - 1)
                if width - length <= 0:
                    start_c = 0
                else:
                    start_c = random.randint(0, width - length)
                cells = [(r, c) for c in range(start_c, start_c + length)]
            else:
                c = random.randint(0, width - 1)
                if height - length <= 0:
                    start_r = 0
                else:
                    start_r = random.randint(0, height - length)
                cells = [(r, c) for r in range(start_r, start_r + length)]
            # Check we don't accidentally make a degenerate single cell
            if len(cells) < 3:
                continue
            # Place, but do not overwrite existing non-zero cells (allow intersections)
            for (r, c) in cells:
                if input_grid[r][c] == 0:
                    input_grid[r][c] = color
            paths.append((color, orientation, cells))
            placed = True

    # Place a single portal pair on one of the paths (entrance=5, exit=6)
    if paths:
        # choose a path with length >=4 if possible so entrance+2 index exists, otherwise pick any
        long_paths = [p for p in paths if len(p[2]) >= 4]
        if long_paths:
            color, orientation, cells = random.choice(long_paths)
        else:
            color, orientation, cells = random.choice(paths)
        if len(cells) >= 4:
            idx = random.randint(1, len(cells) - 3)
            e_r, e_c = cells[idx]
            ex_r, ex_c = cells[idx + 2]
            input_grid[e_r][e_c] = 5
            input_grid[ex_r][ex_c] = 6
        else:
            # fallback: mark an interior cell as entrance and a different interior cell as exit if exists
            if len(cells) >= 3:
                idx = 1
                e_r, e_c = cells[idx]
                input_grid[e_r][e_c] = 5
                # pick another path cell as exit
                other_cells = [p for spec in paths for p in spec[2] if p != (e_r, e_c)]
                if other_cells:
                    ex_r, ex_c = random.choice(other_cells)
                    input_grid[ex_r][ex_c] = 6

    # Build output by simple heuristic: replace portals with neighboring path color, then merge adjacent different colors
    output_grid = [row[:] for row in input_grid]

    # Replace portal cells by neighboring path color (5/6 -> color of adjacent 1-4 if present)
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] in (5, 6):
                found = None
                for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        if output_grid[nr][nc] in (1, 2, 3, 4):
                            found = output_grid[nr][nc]
                            break
                if found is None:
                    found = 1
                output_grid[r][c] = found

    # Merge: any path cell with an adjacent different path color becomes (a+b) mod 9 (map 0->9)
    def map_color(a, b):
        s = (a + b) % 9
        return s if s != 0 else 9

    for r in range(height):
        for c in range(width):
            if output_grid[r][c] in (1, 2, 3, 4):
                colorA = output_grid[r][c]
                merged = False
                for dr, dc in ((-1, 0), (1, 0), (0, -1), (0, 1)):
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        if output_grid[nr][nc] in (1, 2, 3, 4) and output_grid[nr][nc] != colorA:
                            colorB = output_grid[nr][nc]
                            output_grid[r][c] = map_color(colorA, colorB)
                            merged = True
                            break
                if merged:
                    continue

    # Guarantee output != input
    if output_grid == input_grid:
        # change a background cell to color 1
        changed = False
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == 0:
                    output_grid[r][c] = 1
                    changed = True
                    break
            if changed:
                break

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # First, copy input to output
    output = [row[:] for row in grid]

    # Replace portal cells by neighboring path color
    for r in range(height):
        for c in range(width):
            if output[r][c] in (5, 6):
                found = None
                for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        if output[nr][nc] in (1, 2, 3, 4):
                            found = output[nr][nc]
                            break
                if found is None:
                    found = 1
                output[r][c] = found

    # Merge adjacent different path colors: (a+b) mod 9 (map 0->9)
    def map_color(a, b):
        s = (a + b) % 9
        return s if s != 0 else 9

    for r in range(height):
        for c in range(width):
            if output[r][c] in (1, 2, 3, 4):
                colorA = output[r][c]
                for dr, dc in ((-1, 0), (1, 0), (0, -1), (0, 1)):
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        if output[nr][nc] in (1, 2, 3, 4) and output[nr][nc] != colorA:
                            colorB = output[nr][nc]
                            output[r][c] = map_color(colorA, colorB)
                            break

    # Return immutable tuple-of-tuples
    return tuple(tuple(row) for row in output)

