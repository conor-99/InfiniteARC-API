# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: f9a797f4
Difficulty: hard

=== Tags ===
- Pattern intersection
- Temporal wave step
- Take minimum
- Take maximum

=== Description ===
The task involves a grid containing multiple intersecting patterns of distinct
colors, where each pattern forms a continuous path (e.g., horizontal, vertical,
or diagonal lines) of a single color. Intersections occur where two or more
patterns cross, creating junction points. The output grid is generated through a
multi-step temporal wave propagation process: starting from each junction, a
wave propagates outward in all four cardinal directions. At each step, the wave
moves to the neighboring cell with the smallest (for "take minimum") or largest
(for "take maximum") color value among valid adjacent cells (non-background,
non-walled, and not yet visited). The wave's path is drawn in the output using
the color of the originating pattern, while non-path cells retain their original
colors. The propagation continues until all reachable cells are covered, with
the final grid showing a continuous wave path that dynamically selects
directions based on color value minima/maxima. The complexity arises from the
interplay of intersecting patterns, the dependency of wave direction on
numerical color comparisons, and the need to resolve multiple simultaneous
wavefronts without overlap or conflict.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, all_pixels


def generate():
    width = random.randint(15, 30)
    height = random.randint(15, 30)
    bg = 0
    grid_input = grid(width, height, bg)
    
    # Generate 2-3 intersecting color paths
    colors = [1, 2, 3]
    pattern_count = random.randint(2, 3)
    
    # Generate lines that intentionally intersect
    for i in range(pattern_count):
        color = colors[i % len(colors)]
        if i % 2 == 0:  # Horizontal
            row = random.randint(6, height-7)
            col_intersect = random.randint(6, width-7)
            start_col = random.randint(5, col_intersect - 1)
            end_col = random.randint(col_intersect + 1, width - 6)
            for c in range(start_col, end_col + 1):
                grid_input[row][c] = color
        else:  # Vertical
            col = random.randint(6, width-7)
            row_intersect = random.randint(6, height-7)
            start_row = random.randint(5, row_intersect - 1)
            end_row = random.randint(row_intersect + 1, height - 6)
            for r in range(start_row, end_row + 1):
                grid_input[r][col] = color
    
    # Create output by propagating waves from intersections
    grid_output = [row[:] for row in grid_input]
    visited = [[False] * width for _ in range(height)]
    
    # Identify junctions (cells with pattern color and background neighbor)
    junctions = []
    for r in range(height):
        for c in range(width):
            if grid_input[r][c] != bg and (r > 0 and grid_input[r-1][c] == bg or 
                                      r < height-1 and grid_input[r+1][c] == bg or 
                                      c > 0 and grid_input[r][c-1] == bg or 
                                      c < width-1 and grid_input[r][c+1] == bg):
                junctions.append((r, c))
    
    # Propagate wave from each junction
    for r, c in junctions:
        color = grid_input[r][c]
        queue = [(r, c)]
        visited[r][c] = True
        while queue:
            r_cur, c_cur = queue.pop(0)
            grid_output[r_cur][c_cur] = color
            directions = [(-1, 0), (0, -1), (1, 0), (0, 1)]
            for dr, dc in directions:
                nr, nc = r_cur + dr, c_cur + dc
                if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid_input[nr][nc] == bg:
                    visited[nr][nc] = True
                    queue.append((nr, nc))
    
    return {
        "input": grid_input,
        "output": grid_output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    input_grid = [list(row) for row in input_grid]
    bg = 0
    grid_output = [row[:] for row in input_grid]
    visited = [[False] * width for _ in range(height)]
    
    # Identify junctions (cells with pattern color and background neighbor)
    junctions = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != bg and (r > 0 and input_grid[r-1][c] == bg or 
                                      r < height-1 and input_grid[r+1][c] == bg or 
                                      c > 0 and input_grid[r][c-1] == bg or 
                                      c < width-1 and input_grid[r][c+1] == bg):
                junctions.append((r, c))
    
    # Propagate wave from each junction
    for r, c in junctions:
        color = input_grid[r][c]
        queue = [(r, c)]
        visited[r][c] = True
        while queue:
            r_cur, c_cur = queue.pop(0)
            grid_output[r_cur][c_cur] = color
            directions = [(-1, 0), (0, -1), (1, 0), (0, 1)]
            for dr, dc in directions:
                nr, nc = r_cur + dr, c_cur + dc
                if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == bg:
                    visited[nr][nc] = True
                    queue.append((nr, nc))
    
    return grid_output
