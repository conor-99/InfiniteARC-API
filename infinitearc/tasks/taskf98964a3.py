# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: f98964a3
Difficulty: hard

=== Tags ===
- Paint on collision
- Cylindrical
- Image expansion

=== Description ===
Input grids are rectangular with cylindrical boundary conditions (left and right
edges connected), containing particles represented by distinct colors moving in
consistent directions (e.g., rightward, leftward, or mixed). Particles move one
cell per step in their direction, wrapping around the cylindrical boundary. When
two particles of identical color collide (occupy the same cell simultaneously),
they leave a fixed paint mark (color 5) at that location. The output grid
retains all original elements but adds paint marks at every collision point.
"Image expansion" refers to the visual addition of these paint marks, which
expand the grid's content by introducing new elements without altering grid
dimensions. The task requires simulating particle movement with cylindrical
wrap-around, detecting same-color collisions, and marking collision
pointsâ€”demanding careful tracking of movement paths and collision logic across
multiple directions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    input_grid = grid(width, height, 0)
    colors = [c for c in range(1, 10) if c != 5]
    
    # Assign directions: even colors move right, odd move left
    def get_direction(color):
        return 'right' if color % 2 == 0 else 'left'

    # Place particles ensuring at least one collision
    while True:
        # Reset grid
        input_grid = grid(width, height, 0)
        collision_positions = set()
        
        # Place particles
        for _ in range(random.randint(2, 5)):
            color = random.choice(colors)
            r = random.randint(0, height-1)
            c = random.randint(0, width-1)
            input_grid[r][c] = color

        # Simulate movement
        output_grid = grid(width, height, 0)
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] != 0:
                    color = input_grid[r][c]
                    direction = get_direction(color)
                    if direction == 'right':
                        new_c = (c + 1) % width
                    else:
                        new_c = (c - 1) % width
                    output_grid[r][new_c] = color

        # Check for collisions (same color in same cell)
        collision_found = False
        for r in range(height):
            for c in range(width):
                if output_grid[r][c] != 0:
                    color = output_grid[r][c]
                    count = 0
                    for dr in range(height):
                        for dc in range(width):
                            if output_grid[dr][dc] == color:
                                count += 1
                    if count >= 2:
                        collision_found = True
                        output_grid[r][c] = 5
        
        if collision_found:
            return {
                'input': input_grid,
                'output': output_grid
            }

    return {
        'input': input_grid,
        'output': output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = [[0] * width for _ in range(height)]
    
    # Direction mapping: even colors move right, odd move left
    def get_direction(color):
        return 'right' if color % 2 == 0 else 'left'

    # Simulate movement
    for r in range(height):
        for c in range(width):
            color = input_grid[r][c]
            if color == 0 or color == 5:
                continue
            direction = get_direction(color)
            if direction == 'right':
                new_c = (c + 1) % width
            else:
                new_c = (c - 1) % width
            output_grid[r][new_c] = color

    # Mark collisions as color 5
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] != 0:
                color = output_grid[r][c]
                count = 0
                for dr in range(height):
                    for dc in range(width):
                        if output_grid[dr][dc] == color:
                            count += 1
                if count >= 2:
                    output_grid[r][c] = 5
    return output_grid
