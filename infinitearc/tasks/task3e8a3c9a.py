# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 3e8a3c9a
Difficulty: hard

=== Tags ===
- Color stream
- Directed field
- Color by distance to edge
- Associate colors to colors

=== Description ===
The input grid features a background color with a horizontal sequence of
distinct colors (the color stream) positioned along the top row, starting from
the left edge. The output grid transforms each cell's color based on its minimum
Manhattan distance to the nearest grid edge, cycling through the color stream.
For instance, if the stream is [2,5,1], a cell at distance 0 uses 2, distance 1
uses 5, distance 2 uses 1, distance 3 uses 2, and so on. The directed field
(horizontal orientation of the stream) defines the sequence order. All non-
stream colors in the input are irrelevant to the transformation; the output is
determined solely by the stream and edge distances.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    W = random.randint(2, 4)
    H = random.randint(2, 30)
    stream = common.random_colors(W, exclude=[0])
    input_grid = [stream]
    for _ in range(H-1):
        input_grid.append([random.randint(0,9) for _ in range(W)])
    
    output_grid = [[0]*W for _ in range(H)]
    for r in range(H):
        for c in range(W):
            d = min(r, H-1 - r, c, W-1 - c)
            output_grid[r][c] = stream[d % W]
    
    while input_grid == output_grid:
        input_grid = [stream] + [[random.randint(0,9) for _ in range(W)] for _ in range(H-1)]
        output_grid = [[0]*W for _ in range(H)]
        for r in range(H):
            for c in range(W):
                d = min(r, H-1 - r, c, W-1 - c)
                output_grid[r][c] = stream[d % W]
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    H = len(input_grid)
    W = len(input_grid[0])
    stream = input_grid[0]
    output = [[0] * W for _ in range(H)]
    for r in range(H):
        for c in range(W):
            d = min(r, H-1 - r, c, W-1 - c)
            output[r][c] = stream[d % W]
    return output
