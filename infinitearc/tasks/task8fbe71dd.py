# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 8fbe71dd
Difficulty: hard

=== Tags ===
- Periodic boundary conditions
- Pattern repetition
- Symmetry breaking choice

=== Description ===
The input grids consist of 2D grids where each row contains a repeating
horizontal pattern (e.g., sequences like [1,2,3,1,2,3] repeating across
columns). The transformation applies a horizontal shift to all columns of the
grid, with the grid wrapping around at the edges (periodic boundary conditions).
The direction of the shift (left or right) is determined by the parity of the
value in the top-left cell (0,0): if the value is even, columns shift right by
one position (with the rightmost column wrapping to the leftmost position); if
odd, columns shift left by one position (with the leftmost column wrapping to
the rightmost position). This creates a symmetry-breaking choice where the
direction depends on a single cell's value, breaking the symmetry between left
and right shifts. The pattern repetition in the input structure is incidental to
the transformation, which relies solely on the periodic shift and parity-based
direction choice.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    L = random.randint(2, 5)
    k = random.randint(1, 30 // L)
    width = L * k
    height = random.randint(1, 30)
    base = [random.randint(0, 9) for _ in range(L)]
    while all(x == base[0] for x in base):
        base = [random.randint(0, 9) for _ in range(L)]
    input_grid = [base * k for _ in range(height)]
    top_left = input_grid[0][0]
    shift_right = (top_left % 2 == 0)
    output_grid = []
    for row in input_grid:
        if shift_right:
            shifted = [row[-1]] + row[:-1]
        else:
            shifted = row[1:] + [row[0]]
        output_grid.append(shifted)
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    top_left = input_grid[0][0]
    shift_right = (top_left % 2 == 0)
    output_grid = []
    for row in input_grid:
        if isinstance(row, tuple):
            row = list(row)
        if shift_right:
            shifted = [row[-1]] + row[:-1]
        else:
            shifted = row[1:] + [row[0]]
        output_grid.append(shifted)
    return output_grid
