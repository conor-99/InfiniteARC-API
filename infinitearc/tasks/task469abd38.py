# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 469abd38
Difficulty: medium–hard

=== Tags ===
- Maze wave
- Dynamic environment
- Loopless path
- Simple tile repeat
- Pattern reflection

=== Description ===
The input grid represents a maze-like structure with a single continuous,
loopless path that forms a repeating wave pattern. The path alternates between
two orthogonal directions (e.g., right and down) to create a simple tile-based
pattern (e.g., a 2×2 repeating sequence), where each tile moves consistently
along the path. Walls are represented by non-zero colors, while the path itself
occupies background color (0) cells. The wave pattern must maintain consistent
tile repetition without deviation, and the path must traverse the maze without
loops or self-intersections.  The output grid reflects the input path across the
vertical midline of the grid, preserving the loopless property and tile
repetition pattern. The reflection mirrors the direction of movement (e.g.,
right becomes left, while downward movement remains unchanged relative to the
axis), ensuring the reflected pattern seamlessly continues the wave's structure.
Walls remain unchanged, and the reflected path is drawn using a distinct color
(e.g., color 1), while the original path is removed. The transformation ensures
no new loops are introduced, and the reflected tile pattern aligns with the
maze's boundaries.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid
def generate():
    w = random.randint(5, 30)
    h = random.randint(5, 30)
    path = []
    r, c = 0, 0
    path.append((r, c))
    while True:
        if c + 1 < w:
            c += 1
            path.append((r, c))
        else:
            break
        if r + 1 < h:
            r += 1
            path.append((r, c))
        else:
            break
    input_grid = grid(w, h, 0)
    for r in range(h):
        for c in range(w):
            if (r, c) not in path:
                input_grid[r][c] = random.randint(1, 9)
    output_grid = grid(w, h, 0)
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] != 0:
                output_grid[r][c] = input_grid[r][c]
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] == 0:
                reflected_c = w - 1 - c
                output_grid[r][reflected_c] = 1
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    w = len(input_list[0])
    h = len(input_list)
    output_list = [[0] * w for _ in range(h)]
    for r in range(h):
        for c in range(w):
            if input_list[r][c] != 0:
                output_list[r][c] = input_list[r][c]
    for r in range(h):
        for c in range(w):
            if input_list[r][c] == 0:
                reflected_c = w - 1 - c
                output_list[r][reflected_c] = 1
    return tuple(tuple(row) for row in output_list)
