# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: f675f9ea
Difficulty: hard

=== Tags ===
- Color by distance to edge
- Crop

=== Description ===
Input grids are rectangular grids of colors (values 0-9) with dimensions between
1×1 and 30×30. The output grid is generated through two primary steps: first,
counting the number of distinct colors present in the input grid (including all
colors, even background 0); second, cropping the input to retain only cells
whose minimum distance to any edge (top, bottom, left, or right) is greater than
or equal to this count. Each cell in the resulting cropped region is then
recolored to match its original distance value to the edge of the input grid.
For example, a cell 3 units away from the nearest edge in the input becomes
color 3 in the output. The output grid size is strictly smaller than the input,
and colors in the output are determined solely by the input's edge distance
metric, not by the input's original color values. This task requires recognizing
the connection between the count of distinct colors and the crop threshold,
followed by precise distance calculation and recoloring.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    N = random.randint(1, 9)
    H = random.randint(2*N + 1, 30)
    W = random.randint(2*N + 1, 30)
    color_list = [0] + random.sample(range(1, 10), N-1)
    grid_input = [[random.choice(color_list) for _ in range(W)] for _ in range(H)]
    for color in color_list:
        if not any(color in row for row in grid_input):
            i, j = random.randint(0, H-1), random.randint(0, W-1)
            grid_input[i][j] = color
    colors = set()
    for row in grid_input:
        for c in row:
            colors.add(c)
    N_val = len(colors)
    output_grid = []
    for i in range(N_val, H - N_val):
        row = []
        for j in range(N_val, W - N_val):
            dist = min(i, H-1-i, j, W-1-j)
            dist = min(dist, 9)
            row.append(dist)
        output_grid.append(row)
    if grid_input == output_grid:
        return generate()
    return {"input": grid_input, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    H = len(input_grid)
    W = len(input_grid[0])
    colors = set()
    for row in input_grid:
        for color in row:
            colors.add(color)
    N = len(colors)
    output = []
    for i in range(N, H - N):
        row = []
        for j in range(N, W - N):
            dist = min(i, H-1-i, j, W-1-j)
            dist = min(dist, 9)
            row.append(dist)
        output.append(row)
    return output
