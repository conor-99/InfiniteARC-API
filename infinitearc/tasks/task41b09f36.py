# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 41b09f36
Difficulty: very hard

=== Tags ===
- Temporal wave step
- Grid topology inference
- Infer hidden grid
- Pattern cycle
- Fill holes

=== Description ===
Temporal Wave Propagation  Input grids depict a complex maze-like topology where
a temporal wave propagates through a sequence of colored cells (1-9) following a
fixed cyclic pattern (e.g., 1→2→3→4→1...). The wave originates from a single
source cell (color 1) and moves orthogonally through adjacent non-obstacle
cells, incrementing its cycle color at each step. The grid contains a mix of:
(1) colored wave path cells (existing data), (2) background cells (0,
representing holes to fill), and (3) obstacles (fixed non-wave colors, e.g.,
5-9, blocking movement). The wave path forms a continuous sequence where each
cell's color follows the cycle, but the direction of propagation
(left/right/up/down) must be inferred from the spatial arrangement of existing
colors. Critical to the task: the cycle direction is determined by the path of
increasing color values (e.g., a cell with color 2 adjacent to color 1 indicates
movement toward the 2), and obstacles force the wave to navigate around them,
creating turns that must be deduced from color progression.  Output grids fill
all background holes (0s) along the inferred wave path with the correct cycle
color based on: (1) the source's position (color 1), (2) the direction of
propagation (inferred from neighbor color sequences), and (3) the cycle's
current position. For example, if a hole lies immediately after a color 3 in a
1→2→3→1 cycle, it must be filled with color 1. The wave must navigate around
obstacles without crossing them, requiring topological inference to determine
valid path directions. The task demands simultaneous reasoning about: (1) cyclic
color sequence, (2) orthogonal path topology (avoiding obstacles), (3)
directionality from color adjacency, and (4) hole-filling consistency across the
entire inferred path. No two holes share the same inferred cycle position, and
obstacles remain unchanged in the output. The solution requires sequential
pattern recognition across the grid's topology to resolve ambiguous path
directions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    import common

    # Grid size
    width = random.randint(10, 24)
    height = random.randint(10, 24)

    # Obstacle color (choose a non-zero >=5)
    obstacle_colors = [5, 6, 7, 8, 9]
    obstacle_color = random.choice(obstacle_colors)

    # Start with everything as obstacle to force a single carved path
    ingrid = common.grid(width, height, obstacle_color)

    # Cycle definition
    cycle = [1, 2, 3, 4]
    cyc_len = len(cycle)

    # Desired path length (bounded by grid size)
    max_possible = width * height
    # Ensure path length is at least 12 and not congruent to 1 modulo cycle length
    def choose_target():
        for _ in range(200):
            t = random.randint(12, min(40, max_possible - 1))
            if t % cyc_len != 1:
                return t
        # fallback
        t = random.randint(12, min(40, max_possible - 1))
        if t % cyc_len == 1:
            t += 1
            if t >= max_possible:
                t = max(12, min(40, max_possible - 1))
        return t

    target_len = choose_target()

    # Attempt to carve a self-avoiding path of the desired length
    def make_path():
        # Try a randomized depth-first extension with limited backtracking
        for attempt in range(800):
            # Random start
            r = random.randint(0, height - 1)
            c = random.randint(0, width - 1)
            path = [(r, c)]
            visited = { (r, c) }

            # Try to extend greedily with a bias for cells that have more free neighbors
            for _ in range(target_len - 1):
                r, c = path[-1]
                neigh = []
                for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in visited:
                        # check that choosing (nr,nc) won't make it orthogonally adjacent to any other visited cell
                        bad = False
                        for dr2, dc2 in [(1,0),(-1,0),(0,1),(0,-1)]:
                            ar, ac = nr + dr2, nc + dc2
                            if (ar, ac) in visited and (ar, ac) != (r, c):
                                bad = True
                                break
                        if bad:
                            continue
                        # count free neighbors of the candidate to prefer expansions that don't dead-end
                        free = 0
                        for dr2, dc2 in [(1,0),(-1,0),(0,1),(0,-1)]:
                            ar, ac = nr + dr2, nc + dc2
                            if 0 <= ar < height and 0 <= ac < width and (ar, ac) not in visited:
                                free += 1
                        neigh.append(((nr, nc), free))
                if not neigh:
                    break
                # Prefer candidates with higher free count but add randomness
                neigh.sort(key=lambda x: x[1], reverse=True)
                topk = neigh[: max(1, min(3, len(neigh)))]
                chosen = random.choice(topk)[0]
                path.append(chosen)
                visited.add(chosen)
            if len(path) >= target_len:
                return path[:target_len]
        # fallback: build a straight path horizontally or vertically if random attempts fail
        if width >= target_len:
            r = height // 2
            return [(r, c) for c in range(target_len)]
        if height >= target_len:
            c = width // 2
            return [(r, c) for r in range(target_len)]
        # ultimate fallback: snake fill
        path = []
        for r in range(height):
            cols = list(range(width)) if r % 2 == 0 else list(range(width-1, -1, -1))
            for c in cols:
                path.append((r,c))
                if len(path) >= target_len:
                    return path
        return path

    path = make_path()

    # Paint the path with the cycle colors
    for idx, (r, c) in enumerate(path):
        ingrid[r][c] = cycle[idx % cyc_len]

    # Choose holes along the path (exclude the very first cell to preserve source)
    # Ensure at least one hole so input != output
    min_holes = max(1, int(len(path) * 0.18))
    max_holes = max(1, int(len(path) * 0.45))
    holes_count = random.randint(min_holes, max_holes)
    # Exclude path[0] (source) from being a hole
    candidates = path[1:]
    holes = set()
    if candidates:
        holes = set(random.sample(candidates, k=min(len(candidates), holes_count)))

    # Build input grid (with holes set to 0)
    input_grid = [row[:] for row in ingrid]
    for (r, c) in holes:
        input_grid[r][c] = 0

    # Build output grid by filling holes according to the cycle assignment
    output_grid = [row[:] for row in ingrid]
    pos_to_idx = {pos: i for i, pos in enumerate(path)}
    for (r, c) in holes:
        idx = pos_to_idx[(r, c)]
        output_grid[r][c] = cycle[idx % cyc_len]

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0
    cycle = [1, 2, 3, 4]

    # Identify path cells as those that are not obstacles (values 0..4)
    path_positions = set()
    for r in range(height):
        for c in range(width):
            if 0 <= grid[r][c] <= 4:
                path_positions.add((r, c))

    if not path_positions:
        return grid

    # Build adjacency among path cells (orthogonal neighbors)
    adj = {}
    for (r, c) in path_positions:
        neighbors = []
        for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
            nr, nc = r + dr, c + dc
            if (nr, nc) in path_positions:
                neighbors.append((nr, nc))
        adj[(r, c)] = neighbors

    # Find endpoints (degree 1). If none, fall back to any cell with color 1, otherwise any path cell.
    endpoints = [p for p, nb in adj.items() if len(nb) == 1]
    source = None
    if endpoints:
        # Prefer an endpoint that is labeled 1 (the origin)
        ones_at_end = [p for p in endpoints if grid[p[0]][p[1]] == 1]
        if ones_at_end:
            source = ones_at_end[0]
        else:
            # If no endpoint has color 1, pick the endpoint whose neighbor's color indicates direction if possible
            picked = None
            for p in endpoints:
                nb = adj[p][0]
                val_p = grid[p[0]][p[1]]
                val_nb = grid[nb[0]][nb[1]]
                # if neighbor is colored and its color is the next in cycle relative to p, prefer this
                if 1 <= val_p <= 4 and 1 <= val_nb <= 4:
                    if val_nb == cycle[(cycle.index(val_p) + 1) % len(cycle)]:
                        picked = p
                        break
            source = picked if picked is not None else endpoints[0]
    else:
        # No endpoints (a loop). Prefer a cell with color 1 if present
        ones = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == 1]
        source = ones[0] if ones else next(iter(path_positions))

    # Traverse the path from the source, following the unique next neighbor each time
    path = []
    visited = set()
    cur = source
    prev = None
    while True:
        path.append(cur)
        visited.add(cur)
        # next neighbors excluding where we came from
        next_neighbors = [n for n in adj[cur] if n != prev]
        if not next_neighbors:
            break
        # In a proper single path there should be exactly one next neighbor
        nxt = next_neighbors[0]
        prev = cur
        cur = nxt
        if cur in visited:
            break

    # Fill in zeros along the traversed path according to cycle
    for idx, (r, c) in enumerate(path):
        col = cycle[idx % len(cycle)]
        grid[r][c] = col

    return grid

