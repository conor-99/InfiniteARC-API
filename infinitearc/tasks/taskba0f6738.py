# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: ba0f6738
Difficulty: hard

=== Tags ===
- Sand simulation
- Path following
- Directed cave maze
- Size guessing

=== Description ===
Input grids depict a cave maze structure with interconnected corridors formed by
varying path widths. The background is color 0, cave walls are color 1, and
paths are color 2. Sand cells (color 3) are placed at the top of the maze within
a narrow vertical corridor. Path segments are visually categorized by width:
narrow segments (single cell wide) direct sand to flow vertically downward,
while wide segments (spanning two or more cells horizontally) direct sand to
flow horizontally. The horizontal direction (left/right) is determined by the
segment's position within the maze: segments aligned with the left half of the
maze flow left, while those aligned with the right half flow right. The output
grid highlights the complete path taken by the sand from its starting position
to the maze exit using color 3, preserving all walls, path structures, and
directional cues. The "size guessing" challenge requires users to visually
analyze path segment widths and positional alignment to determine the sand's
movement direction, making the task difficult due to the need for precise
spatial reasoning about corridor dimensions and their relationship to flow
direction.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    grid = common.grid(width, height, 0)
    
    # Walls on borders
    for r in range(height):
        grid[r][0] = 1
        grid[r][width-1] = 1
    for c in range(width):
        grid[0][c] = 1
        grid[height-1][c] = 1
    
    start_col = random.randint(2, width-3)
    
    # Vertical path
    for r in range(1, height-1):
        grid[r][start_col] = 2
    grid[0][start_col] = 3  # Sand start
    
    # Horizontal segment
    turn_row = random.randint(3, height-4)
    if start_col < width // 2:
        left_col = start_col - 1
        grid[turn_row][left_col] = 2
        grid[turn_row][start_col] = 2
        for r in range(turn_row+1, height-1):
            grid[r][left_col] = 2
    else:
        right_col = start_col + 1
        grid[turn_row][start_col] = 2
        grid[turn_row][right_col] = 2
        for r in range(turn_row+1, height-1):
            grid[r][right_col] = 2
    
    # Simulate path
    path_cells = []
    r, c = 0, start_col
    path_cells.append((r, c))
    direction = 'down'
    while True:
        if direction == 'down':
            nr, nc = r+1, c
        elif direction == 'left':
            nr, nc = r, c-1
        elif direction == 'right':
            nr, nc = r, c+1
        else:
            break
        
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        if grid[nr][nc] != 2:
            break
        
        r, c = nr, nc
        path_cells.append((r, c))
        
        # Check if horizontal segment
        if (grid[r][c-1] == 2) or (grid[r][c+1] == 2):
            if c < width // 2:
                direction = 'left'
            else:
                direction = 'right'
        else:
            direction = 'down'
    
    # Create output grid
    output = common.grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 1:
                output[r][c] = 1
            elif (r, c) in path_cells:
                output[r][c] = 3
            else:
                output[r][c] = 0
    
    return {
        'input': grid,
        'output': output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    
    # Find sand start
    start = None
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 3:
                start = (r, c)
                break
        if start:
            break
    
    if not start:
        return grid
    
    path_cells = []
    r, c = start
    path_cells.append((r, c))
    direction = 'down'
    
    while True:
        if direction == 'down':
            nr, nc = r+1, c
        elif direction == 'left':
            nr, nc = r, c-1
        elif direction == 'right':
            nr, nc = r, c+1
        else:
            break
        
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        if grid[nr][nc] != 2:
            break
        
        r, c = nr, nc
        path_cells.append((r, c))
        
        # Check horizontal segment
        if (grid[r][c-1] == 2) or (grid[r][c+1] == 2):
            if c < width // 2:
                direction = 'left'
            else:
                direction = 'right'
        else:
            direction = 'down'
    
    # Create output
    output = common.grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 1:
                output[r][c] = 1
            elif (r, c) in path_cells:
                output[r][c] = 3
            else:
                output[r][c] = 0
    return output
