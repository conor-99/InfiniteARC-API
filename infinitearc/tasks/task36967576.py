# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 36967576
Difficulty: very hard

=== Tags ===
- Flow with decay
- Motif extraction
- Guided flow
- Grid overlay blending

=== Description ===
Task Name: Flow with Decay  Description: Input grids feature a background color
(0) with multiple distinct colored motifs (each a contiguous shape of a single
color from 1-9), a single source cell (color 9), and a guide path (color 8) that
forms a contiguous path from the source to a grid boundary. The guide path is a
sequence of adjacent (horizontally/vertically) color 8 cells, starting at the
cell immediately adjacent to the source and ending at a grid edge. All other
motifs (colors 1-7) are placed such that no motif color is repeated across
different motifs.  The output grid replaces the guide path with a decaying color
sequence. The source remains color 9. Each subsequent cell along the guide path
(moving away from the source) is assigned the next color in the sequence 9, 8,
7, 6, 5, 4, 3, 2, 1, skipping any color already used by other motifs (colors
1-7). The guide path is removed (no longer visible as color 8), and the decay
sequence continues until reaching the grid boundary, stopping at the last valid
color before 0. All background cells and non-guide motifs remain unchanged. This
requires identifying the source, tracing the connected guide path to the
boundary, determining unused colors for decay, and applying the sequence while
respecting motif color constraints.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = 10
    height = 10
    grid_input = [[0] * width for _ in range(height)]
    
    k = random.randint(1, 6)  # Fixed to avoid k=7 which causes identical grids
    motif_colors = random.sample(range(1, 8), k)
    
    sequence = [9, 8, 7, 6, 5, 4, 3, 2, 1]
    for color in motif_colors:
        if color in sequence:
            sequence.remove(color)
    path_length = len(sequence)
    
    c_source = width - path_length
    r_source = random.randint(1, height - 2)
    
    grid_input[r_source][c_source] = 9
    for i in range(1, path_length):
        grid_input[r_source][c_source + i] = 8
    
    for color in motif_colors:
        while True:
            r = random.randint(0, height - 1)
            c = random.randint(0, width - 1)
            if grid_input[r][c] == 0:
                if r == r_source and c_source <= c < c_source + path_length:
                    continue
                grid_input[r][c] = color
                break
    
    grid_output = [row[:] for row in grid_input]
    for i in range(path_length):
        r, c = r_source, c_source + i
        grid_output[r][c] = sequence[i]
    
    return {"input": grid_input, "output": grid_output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    source = None
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 9:
                source = (r, c)
                break
        if source:
            break
    if source is None:
        return input_grid
    
    path = [source]
    current = source
    visited = set([source])
    while True:
        found = False
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = current[0] + dr, current[1] + dc
            if 0 <= nr < height and 0 <= nc < width:
                if grid[nr][nc] == 8 and (nr, nc) not in visited:
                    current = (nr, nc)
                    visited.add(current)
                    path.append(current)
                    found = True
                    break
        if not found:
            break
    
    motif_colors = set()
    for r in range(height):
        for c in range(width):
            color = grid[r][c]
            if 1 <= color <= 7:
                motif_colors.add(color)
    
    sequence = [9, 8, 7, 6, 5, 4, 3, 2, 1]
    for color in motif_colors:
        if color in sequence:
            sequence.remove(color)
    
    output_grid = [row[:] for row in grid]
    for idx, (r, c) in enumerate(path):
        output_grid[r][c] = sequence[idx]
    
    return tuple(tuple(row) for row in output_grid)
