# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: b04ae4dd
Difficulty: insane

=== Tags ===
- Color particle emission
- Dynamic channel painting
- Image filling
- Image repetition

=== Description ===
Input grids feature a uniform background (color 0), emitter cells (color 1-4),
and channel paths (color 5-9, each color indicating channel direction:
5=horizontal, 6=vertical, 7=diagonal). Each emitter cell emits particles in all
four cardinal directions. Particles travel through background until encountering
a channel cell, then follow the channel's direction (horizontal: left/right,
vertical: up/down, diagonal: 45Â°). As particles traverse channel cells, they
replace the channel color with the emitter's color, prioritizing the shortest
path for overlapping particles. After all particle movement, any background cell
completely enclosed by painted channels (surrounded by non-background cells
orthogonally) is filled with color 8. Finally, the entire grid (including
painted channels and filled regions) is reflected across both the horizontal and
vertical midlines to produce the output grid, creating a symmetrical pattern
where each quadrant is a mirror of the others.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import copy

def generate():
    # Grid size
    width = random.randint(6, 12)
    height = random.randint(6, 12)
    grid = [[0 for _ in range(width)] for _ in range(height)]

    coords = [(r,c) for r in range(height) for c in range(width)]

    # Place emitters (colors 1..4), ensure not orthogonally adjacent to each other
    num_emit = random.randint(1, 3)
    emit_positions = None
    for _ in range(300):
        picks = random.sample(coords, num_emit)
        ok = True
        for i, a in enumerate(picks):
            for j, b in enumerate(picks):
                if i==j: continue
                if abs(a[0]-b[0]) + abs(a[1]-b[1]) == 1:
                    ok = False
                    break
            if not ok: break
        if ok:
            emit_positions = picks
            break
    if emit_positions is None:
        # fallback greedy
        emit_positions = []
        for p in random.sample(coords, len(coords)):
            if len(emit_positions) >= num_emit:
                break
            if all(abs(p[0]-q[0])+abs(p[1]-q[1]) != 1 for q in emit_positions):
                emit_positions.append(p)
        if not emit_positions:
            emit_positions = [coords[0]]

    emitters = []
    for (r,c) in emit_positions:
        color = random.randint(1,4)
        grid[r][c] = color
        emitters.append((r,c,color))

    # Place channel segments (colors 5=horizontal,6=vertical,7=diagonal)
    segments = []
    num_segments = random.randint(1, 4)
    for _ in range(num_segments):
        placed = False
        for _attempt in range(200):
            ch = random.choice([5,6,7])
            if ch == 5:  # horizontal
                max_len = min(6, width)
                if max_len < 2: continue
                length = random.randint(2, max_len)
                r = random.randint(0, height-1)
                c_start = random.randint(0, width - length)
                candidate = [(r, c_start + i) for i in range(length)]
            elif ch == 6:  # vertical
                max_len = min(6, height)
                if max_len < 2: continue
                length = random.randint(2, max_len)
                c = random.randint(0, width-1)
                r_start = random.randint(0, height - length)
                candidate = [(r_start + i, c) for i in range(length)]
            else:  # diagonal
                max_len = min(6, min(width, height))
                if max_len < 2: continue
                length = random.randint(2, max_len)
                slope = random.choice([1, -1])
                r_start = random.randint(0, height - length)
                if slope == 1:
                    c_start = random.randint(0, width - length)
                    candidate = [(r_start + i, c_start + i) for i in range(length)]
                else:
                    c_start = random.randint(length - 1, width - 1)
                    candidate = [(r_start + i, c_start - i) for i in range(length)]
            # validate candidate: all cells zero and no orth neighbor outside candidate is non-zero
            ok = True
            for (rr, cc) in candidate:
                if grid[rr][cc] != 0:
                    ok = False
                    break
                for dr, dc in ((1,0), (-1,0), (0,1), (0,-1)):
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0 and (nr,nc) not in candidate:
                        ok = False
                        break
                if not ok:
                    break
            if not ok:
                continue
            # place it
            for (rr,cc) in candidate:
                grid[rr][cc] = ch
            segments.append(candidate)
            placed = True
            break
        # continue to next segment (may fail to place some)
    # if no segments placed, create one near a random emitter
    has_channel = any(grid[r][c] >= 5 for r in range(height) for c in range(width))
    if not has_channel:
        # attempt to place small horizontal segment aligned with an emitter
        e = random.choice(emitters)
        er, ec, _ = e
        placed = False
        for _attempt in range(200):
            ch = random.choice([5,6,7])
            if ch == 5:
                # try to place to right
                c_start = ec + 1
                if c_start + 1 < width and grid[er][c_start] == 0 and grid[er][c_start+1] == 0:
                    candidate = [(er,c_start),(er,c_start+1)]
                elif ec - 2 >= 0 and grid[er][ec-1] == 0 and grid[er][ec-2] == 0:
                    candidate = [(er,ec-1),(er,ec-2)]
                else:
                    continue
            elif ch == 6:
                r_start = er + 1
                if r_start + 1 < height and grid[r_start][ec] == 0 and grid[r_start+1][ec] == 0:
                    candidate = [(r_start,ec),(r_start+1,ec)]
                elif er - 2 >= 0 and grid[er-1][ec] == 0 and grid[er-2][ec] == 0:
                    candidate = [(er-1,ec),(er-2,ec)]
                else:
                    continue
            else:
                # diagonal: try down-right
                if er + 2 < height and ec + 2 < width and grid[er+1][ec+1] == 0 and grid[er+2][ec+2] == 0:
                    candidate = [(er+1,ec+1),(er+2,ec+2)]
                elif er + 2 < height and ec - 2 >= 0 and grid[er+1][ec-1] == 0 and grid[er+2][ec-2] == 0:
                    candidate = [(er+1,ec-1),(er+2,ec-2)]
                else:
                    continue
            # place
            for (rr,cc) in candidate:
                grid[rr][cc] = ch
            segments.append(candidate)
            placed = True
            break
        if not placed:
            # fallback: place any two empty adjacent cells
            found = False
            for (r,c) in coords:
                for dr,dc in ((0,1),(1,0),(1,1),(1,-1)):
                    r2, c2 = r+dr, c+dc
                    if 0<=r2<height and 0<=c2<width and grid[r][c]==0 and grid[r2][c2]==0:
                        ch = 5 if dr==0 and dc==1 else 6 if dr==1 and dc==0 else 7
                        grid[r][c] = ch; grid[r2][c2] = ch
                        segments.append([(r,c),(r2,c2)])
                        found = True
                        break
                if found: break

    # Ensure at least one emitter has a clear path to a channel cell; otherwise add one small aligned segment
    def emitter_has_path():
        for (er,ec,_) in emitters:
            for dr,dc in ((-1,0),(1,0),(0,-1),(0,1)):
                r2, c2 = er+dr, ec+dc
                while 0 <= r2 < height and 0 <= c2 < width and grid[r2][c2] == 0:
                    r2 += dr; c2 += dc
                if 0 <= r2 < height and 0 <= c2 < width and grid[r2][c2] >= 5:
                    return True
        return False

    if not emitter_has_path():
        # try to add a small segment aligned to a random emitter
        placed = False
        for _attempt in range(300):
            er, ec, _ = random.choice(emitters)
            dir_choice = random.choice([(0,1),(0,-1),(1,0),(-1,0)])
            dr,dc = dir_choice
            # pick a distance at least 1
            maxd =  max(width, height)
            d = random.randint(1, min(4, max(width, height)-1))
            rq = er + dr * d
            cq = ec + dc * d
            if not (0 <= rq < height and 0 <= cq < width): continue
            if grid[rq][cq] != 0: continue
            # check path cells between emitter and rq,cq are zero
            ok = True
            step_r, step_c = er + dr, ec + dc
            while (step_r, step_c) != (rq, cq):
                if grid[step_r][step_c] != 0:
                    ok = False; break
                step_r += dr; step_c += dc
            if not ok: continue
            # place a short segment including rq,cq and next cell along orientation if possible
            ch = random.choice([5,6,7])
            # attempt to orient the segment so that rq,cq is part of it
            placed_candidate = None
            if ch == 5:
                # try to add one more cell to right if possible
                if cq + 1 < width and grid[rq][cq+1] == 0:
                    placed_candidate = [(rq,cq),(rq,cq+1)]
                elif cq - 1 >= 0 and grid[rq][cq-1] == 0:
                    placed_candidate = [(rq,cq),(rq,cq-1)]
            elif ch == 6:
                if rq + 1 < height and grid[rq+1][cq] == 0:
                    placed_candidate = [(rq,cq),(rq+1,cq)]
                elif rq - 1 >= 0 and grid[rq-1][cq] == 0:
                    placed_candidate = [(rq,cq),(rq-1,cq)]
            else:
                if rq + 1 < height and cq + 1 < width and grid[rq+1][cq+1] == 0:
                    placed_candidate = [(rq,cq),(rq+1,cq+1)]
                elif rq + 1 < height and cq - 1 >= 0 and grid[rq+1][cq-1] == 0:
                    placed_candidate = [(rq,cq),(rq+1,cq-1)]
            if placed_candidate is None:
                continue
            # place
            for (rr,cc) in placed_candidate:
                grid[rr][cc] = ch
            segments.append(placed_candidate)
            placed = True
            break
        # if still not placed, we proceed (unlikely)

    # Save input grid
    input_grid = [row[:] for row in grid]

    # Compute painted channels
    def build_segments(g):
        h = len(g); w = len(g[0])
        visited = set()
        segs = []
        cell_to_seg = {}
        for r in range(h):
            for c in range(w):
                if g[r][c] < 5 or (r,c) in visited:
                    continue
                ch = g[r][c]
                # explore component with allowed adjacency
                stack = [(r,c)]
                comp = []
                while stack:
                    rr, cc = stack.pop()
                    if (rr,cc) in visited: continue
                    if g[rr][cc] != ch: continue
                    visited.add((rr,cc))
                    comp.append((rr,cc))
                    if ch == 5:
                        neighbors = [(rr,cc-1),(rr,cc+1)]
                    elif ch == 6:
                        neighbors = [(rr-1,cc),(rr+1,cc)]
                    else:
                        neighbors = [(rr-1,cc-1),(rr-1,cc+1),(rr+1,cc-1),(rr+1,cc+1)]
                    for nr,nc in neighbors:
                        if 0<=nr<h and 0<=nc<w and g[nr][nc]==ch and (nr,nc) not in visited:
                            stack.append((nr,nc))
                # order comp
                if ch == 5:
                    comp_sorted = sorted(comp, key=lambda x: x[1])  # by col
                elif ch == 6:
                    comp_sorted = sorted(comp, key=lambda x: x[0])  # by row
                else:
                    # diagonal - infer slope
                    comp_sorted = sorted(comp, key=lambda x: (x[0], x[1]))
                    if len(comp_sorted) >= 2:
                        if comp_sorted[1][1] < comp_sorted[0][1]:
                            # slope -1: sort by row asc, col desc
                            comp_sorted = sorted(comp, key=lambda x: (x[0], -x[1]))
                        else:
                            comp_sorted = sorted(comp, key=lambda x: (x[0], x[1]))
                seg_id = len(segs)
                segs.append((ch, comp_sorted))
                for idx, cell in enumerate(comp_sorted):
                    cell_to_seg[cell] = (seg_id, idx)
        return segs, cell_to_seg

    segs, cell_to_seg = build_segments(grid)

    # For each channel cell, collect candidates from emitters hitting that segment
    h = height; w = width
    candidates = {}  # (r,c) -> list of (distance, color)
    for (er,ec,ecolor) in emitters:
        for dr,dc in ((-1,0),(1,0),(0,-1),(0,1)):
            steps = 0
            r2 = er + dr; c2 = ec + dc
            blocked = False
            while 0 <= r2 < h and 0 <= c2 < w and grid[r2][c2] == 0:
                steps += 1
                r2 += dr; c2 += dc
            if not (0 <= r2 < h and 0 <= c2 < w):
                continue
            if grid[r2][c2] < 5:
                continue
            # entry cell r2,c2 and segment
            if (r2,c2) not in cell_to_seg:
                continue
            seg_id, idx_q = cell_to_seg[(r2,c2)]
            ch, comp_sorted = segs[seg_id]
            for idx_p, (pr,pc) in enumerate(comp_sorted):
                d = steps + abs(idx_p - idx_q)
                candidates.setdefault((pr,pc), []).append((d, ecolor))
    # create painted grid
    painted = [row[:] for row in grid]
    for (cell, candlist) in candidates.items():
        candlist.sort(key=lambda x: (x[0], x[1]))
        best_color = candlist[0][1]
        painted[cell[0]][cell[1]] = best_color

    # Fill enclosed background cells (orthogonally surrounded by non-zero)
    filled = [row[:] for row in painted]
    for r in range(h):
        for c in range(w):
            if filled[r][c] == 0:
                up = (r-1 >= 0 and filled[r-1][c] != 0)
                down = (r+1 < h and filled[r+1][c] != 0)
                left = (c-1 >= 0 and filled[r][c-1] != 0)
                right = (c+1 < w and filled[r][c+1] != 0)
                if up and down and left and right:
                    filled[r][c] = 8

    # Reflect across both midlines -> rotate 180 degrees
    output = [[filled[h-1-r][w-1-c] for c in range(w)] for r in range(h)]

    return {'input': input_grid, 'output': output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # convert to list of lists
    grid = [list(row) for row in input_grid]
    h = len(grid); w = len(grid[0])
    # collect emitters
    emitters = []
    for r in range(h):
        for c in range(w):
            if 1 <= grid[r][c] <= 4:
                emitters.append((r,c,grid[r][c]))
    # build segments
    def build_segments(g):
        h = len(g); w = len(g[0])
        visited = set(); segs=[]; cell_to_seg={}
        for r in range(h):
            for c in range(w):
                if g[r][c] < 5 or (r,c) in visited:
                    continue
                ch = g[r][c]
                stack = [(r,c)]
                comp=[]
                while stack:
                    rr,cc = stack.pop()
                    if (rr,cc) in visited: continue
                    if g[rr][cc] != ch: continue
                    visited.add((rr,cc))
                    comp.append((rr,cc))
                    if ch == 5:
                        neighbors = [(rr,cc-1),(rr,cc+1)]
                    elif ch == 6:
                        neighbors = [(rr-1,cc),(rr+1,cc)]
                    else:
                        neighbors = [(rr-1,cc-1),(rr-1,cc+1),(rr+1,cc-1),(rr+1,cc+1)]
                    for nr,nc in neighbors:
                        if 0<=nr<h and 0<=nc<w and g[nr][nc] == ch and (nr,nc) not in visited:
                            stack.append((nr,nc))
                # order comp
                if ch == 5:
                    comp_sorted = sorted(comp, key=lambda x: x[1])
                elif ch == 6:
                    comp_sorted = sorted(comp, key=lambda x: x[0])
                else:
                    comp_sorted = sorted(comp, key=lambda x: (x[0], x[1]))
                    if len(comp_sorted) >= 2:
                        if comp_sorted[1][1] < comp_sorted[0][1]:
                            comp_sorted = sorted(comp, key=lambda x: (x[0], -x[1]))
                        else:
                            comp_sorted = sorted(comp, key=lambda x: (x[0], x[1]))
                seg_id = len(segs)
                segs.append((ch, comp_sorted))
                for idx, cell in enumerate(comp_sorted):
                    cell_to_seg[cell] = (seg_id, idx)
        return segs, cell_to_seg

    segs, cell_to_seg = build_segments(grid)

    # collect candidates: for each emitter, follow 4 dirs until non-zero
    candidates = {}
    for (er,ec,ecolor) in emitters:
        for dr,dc in ((-1,0),(1,0),(0,-1),(0,1)):
            steps = 0
            r2 = er + dr; c2 = ec + dc
            while 0 <= r2 < h and 0 <= c2 < w and grid[r2][c2] == 0:
                steps += 1
                r2 += dr; c2 += dc
            if not (0 <= r2 < h and 0 <= c2 < w):
                continue
            if grid[r2][c2] < 5:
                continue
            if (r2,c2) not in cell_to_seg:
                continue
            seg_id, idx_q = cell_to_seg[(r2,c2)]
            ch, comp_sorted = segs[seg_id]
            for idx_p, (pr,pc) in enumerate(comp_sorted):
                d = steps + abs(idx_p - idx_q)
                candidates.setdefault((pr,pc), []).append((d, ecolor))
    # create painted grid
    painted = [row[:] for row in grid]
    for cell, candlist in candidates.items():
        candlist.sort(key=lambda x: (x[0], x[1]))
        painted[cell[0]][cell[1]] = candlist[0][1]

    # fill enclosed zeros with 8
    filled = [row[:] for row in painted]
    for r in range(h):
        for c in range(w):
            if filled[r][c] == 0:
                up = (r-1 >= 0 and filled[r-1][c] != 0)
                down = (r+1 < h and filled[r+1][c] != 0)
                left = (c-1 >= 0 and filled[r][c-1] != 0)
                right = (c+1 < w and filled[r][c+1] != 0)
                if up and down and left and right:
                    filled[r][c] = 8

    # rotate 180 deg
    output = [[filled[h-1-r][w-1-c] for c in range(w)] for r in range(h)]
    return output

