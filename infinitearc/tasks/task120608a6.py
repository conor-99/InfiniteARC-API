# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 120608a6
Difficulty: hard

=== Tags ===
- Local physics rule
- Paint on collision
- Phase shift
- Pattern rotation
- Diagonal symmetry
- Shape guessing

=== Description ===
Input grids feature multiple distinct, contiguous colored shapes (each shape is
a single color, no overlapping) arranged on a background. Shapes may be
partially mirrored across the main diagonal, with some diagonally adjacent
(corner-sharing) pairs of shapes present. Background cells are color 0.  The
transformation applies three sequential rules:  1. **Diagonal Symmetry
Enforcement**: For every cell (i,j) with i < j, if (i,j) is part of a shape and
(j,i) is background, (j,i) is filled with the shape's color. If both (i,j) and
(j,i) are part of shapes, (i,j) is marked for collision processing.  2. **Phase
Shift**: Each shape's color is shifted forward in a fixed circular sequence
(1→2→3→...→9→1) by an amount equal to its count of diagonal neighbors (cells
sharing a corner with other shapes). The shift is visual and sequence-based, not
numerical.  3. **Paint on Collision**: For any cell (i,j) where both (i,j) and
(j,i) are non-background (indicating a diagonal collision), (i,j) is recolored
to a fixed collision color (9, maroon), overriding the phase-shifted color.
This creates an output grid that enforces diagonal symmetry, applies color
shifts based on local shape interactions, and paints collision points with a
distinct color, requiring simultaneous recognition of shape placement, neighbor
counting, and sequence-based color transformation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = max(3, random.randint(1, 30))
    height = max(3, random.randint(1, 30))
    input_grid = common.grid(width, height, 0)
    colors = common.random_colors(2, exclude=[0])
    c1, c2 = colors[0], colors[1]
    
    # Generate first shape
    size1 = random.randint(3, 5)
    pixels1 = common.continuous_creature(size1, width, height)
    for (r, c) in pixels1:
        input_grid[r][c] = c1
    
    # Generate second shape
    size2 = random.randint(3, 5)
    pixels2 = common.continuous_creature(size2, width, height)
    for (r, c) in pixels2:
        if input_grid[r][c] == 0:
            input_grid[r][c] = c2
        
    # Ensure at least one asymmetric cell
    asymmetric_found = False
    for i in range(height):
        for j in range(width):
            if input_grid[i][j] != 0 and input_grid[j][i] == 0:
                asymmetric_found = True
                break
        if asymmetric_found:
            break
    if not asymmetric_found:
        input_grid[0][1] = c1  # Now safely within bounds
    
    output_grid = [row[:] for row in input_grid]
    
    # Step 1: Diagonal symmetry
    for i in range(height):
        for j in range(width):
            if i < j and output_grid[i][j] != 0 and output_grid[j][i] == 0:
                output_grid[j][i] = output_grid[i][j]
    
    # Step 2: Phase shift
    visited = [[False] * width for _ in range(height)]
    shapes = {}
    for i in range(height):
        for j in range(width):
            if not visited[i][j] and output_grid[i][j] != 0:
                color = output_grid[i][j]
                queue = [(i, j)]
                visited[i][j] = True
                shape_cells = []
                while queue:
                    r, c = queue.pop(0)
                    shape_cells.append((r, c))
                    for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and output_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                shapes[(i, j)] = (color, shape_cells)
    
    for (i, j), (color, cells) in shapes.items():
        count = 0
        for (r, c) in cells:
            for dr in [-1, 0, 1]:
                for dc in [-1, 0, 1]:
                    if dr == 0 or dc == 0:
                        continue
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        if output_grid[nr][nc] != 0 and output_grid[nr][nc] != color:
                            count += 1
                            break
        new_color = (color + count - 1) % 9 + 1
        for (r, c) in cells:
            output_grid[r][c] = new_color
    
    # Step 3: Paint on collision
    for i in range(height):
        for j in range(width):
            if output_grid[i][j] != 0 and output_grid[j][i] != 0:
                output_grid[i][j] = 9
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = [row[:] for row in input_grid]
    
    # Step 1: Enforce diagonal symmetry
    for i in range(height):
        for j in range(width):
            if i < j and output_grid[i][j] != 0 and output_grid[j][i] == 0:
                output_grid[j][i] = output_grid[i][j]
    
    # Step 2: Phase shift
    visited = [[False] * width for _ in range(height)]
    shapes = {}
    for i in range(height):
        for j in range(width):
            if not visited[i][j] and output_grid[i][j] != 0:
                color = output_grid[i][j]
                queue = [(i, j)]
                visited[i][j] = True
                shape_cells = []
                while queue:
                    r, c = queue.pop(0)
                    shape_cells.append((r, c))
                    for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and output_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                shapes[(i, j)] = (color, shape_cells)
    
    for (i, j), (color, cells) in shapes.items():
        count = 0
        for (r, c) in cells:
            for dr in [-1, 0, 1]:
                for dc in [-1, 0, 1]:
                    if dr == 0 or dc == 0:
                        continue
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        if output_grid[nr][nc] != 0 and output_grid[nr][nc] != color:
                            count += 1
                            break
        new_color = (color + count - 1) % 9 + 1
        for (r, c) in cells:
            output_grid[r][c] = new_color
    
    # Step 3: Paint on collision
    for i in range(height):
        for j in range(width):
            if output_grid[i][j] != 0 and output_grid[j][i] != 0:
                output_grid[i][j] = 9
    
    return tuple(tuple(row) for row in output_grid)
