# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 6fda2f2d
Difficulty: hard

=== Tags ===
- Split and merge
- Trace perimeter

=== Description ===
The input grid contains a single connected shape (all cells of a uniform color)
with at least one distinct concave section (an indentation where the shape
curves inward, creating an inner angle greater than 180 degrees). This shape
must be sufficiently large to exhibit a clear indentation (minimum 3x3
dimensions in the indentation area). The transformation process involves three
key steps: first, identifying the endpoints of the indentation (the two inner
corners defining the concavity), then splitting the shape along the straight
line connecting these endpoints, and finally merging the split segments by
translating the detached portion to the opposite side of the shape to eliminate
the indentation, forming a convex shape. The output grid displays only the
traced perimeter of this newly formed convex shape as a continuous line in a
fixed color (e.g., color 1), with all other cells set to background (color 0).
The perimeter is drawn precisely along the outer boundary of the merged convex
shape, creating a closed loop that outlines the transformed structure. This task
requires visual identification of concave features, geometric reasoning for the
split line, precise spatial merging, and accurate perimeter tracingâ€”all without
relying on numerical properties or value-based operations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = [[0] * width for _ in range(height)]
    rect_w = width - 2
    rect_h = height - 2
    for r in range(rect_h):
        for c in range(rect_w):
            grid[r][c] = 1
    dent_start_row = rect_h // 2 - 1
    dent_end_row = dent_start_row + 2
    dent_start_col = rect_w - 2
    dent_end_col = dent_start_col + 2
    for r in range(dent_start_row, dent_end_row + 1):
        for c in range(dent_start_col, dent_end_col + 1):
            if r < rect_h and c < rect_w:
                grid[r][c] = 0
    color_1_cells = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == 1]
    if not color_1_cells:
        output_grid = [[0] * width for _ in range(height)]
    else:
        min_r = min(r for r, c in color_1_cells)
        max_r = max(r for r, c in color_1_cells)
        min_c = min(c for r, c in color_1_cells)
        max_c = max(c for r, c in color_1_cells)
        output_grid = [[0] * width for _ in range(height)]
        for r in range(min_r, max_r + 1):
            output_grid[r][min_c] = 1
            output_grid[r][max_c] = 1
        for c in range(min_c, max_c + 1):
            output_grid[min_r][c] = 1
            output_grid[max_r][c] = 1
    return {"input": grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    color_1_cells = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == 1]
    if not color_1_cells:
        return [[0] * width for _ in range(height)]
    min_r = min(r for r, c in color_1_cells)
    max_r = max(r for r, c in color_1_cells)
    min_c = min(c for r, c in color_1_cells)
    max_c = max(c for r, c in color_1_cells)
    output = [[0] * width for _ in range(height)]
    for r in range(min_r, max_r + 1):
        output[r][min_c] = 1
        output[r][max_c] = 1
    for c in range(min_c, max_c + 1):
        output[min_r][c] = 1
        output[max_r][c] = 1
    return output
