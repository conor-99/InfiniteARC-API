# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 33e0fc45
Difficulty: hard

=== Tags ===
- Count shapes

=== Description ===
The input grid contains multiple distinct shapes, defined as maximally connected
regions of identical color using 4-connectivity (up, down, left, right). Each
shape must be fully enclosed and not share edges with other shapes of the same
color. The output grid is generated by first counting the total number of such
shapes (N). If N is even, the entire grid is mirrored horizontally (left-right
flip); if N is odd, the entire grid is mirrored vertically (top-bottom flip).
This transformation requires accurate identification of connected components
followed by a deterministic geometric operation based on the parity of the
count. The complexity arises from the need to precisely count shapes in visually
dense grids with numerous small, non-overlapping regions, where subtle
connectivity patterns can obscure the count. The output grid must differ from
the input, ensuring no trivial transformations (e.g., symmetric grids) are used.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import continuous_creature
def generate():
    while True:
        width = random.randint(5, 30)
        height = random.randint(5, 30)
        grid = [[0] * width for _ in range(height)]
        n_shapes = random.randint(3, 9)
        colors = random.sample(range(1, 10), n_shapes)
        placed_all = True
        for color in colors:
            size = random.randint(2, 5)
            pixels = continuous_creature(size, 3, 3)
            placed = False
            retries = 0
            while not placed and retries < 100:
                x = random.randint(0, width - 3)
                y = random.randint(0, height - 3)
                overlap = False
                for (r, c) in pixels:
                    if grid[y + r][x + c] != 0:
                        overlap = True
                        break
                if not overlap:
                    for (r, c) in pixels:
                        grid[y + r][x + c] = color
                    placed = True
                retries += 1
            if not placed:
                placed_all = False
                break
        if not placed_all:
            continue
        N = n_shapes
        if N % 2 == 0:
            output = [row[::-1] for row in grid]
        else:
            output = grid[::-1]
        if grid != output:
            return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid or not input_grid[0]:
        return []
    visited = [[False] * len(input_grid[0]) for _ in range(len(input_grid))]
    count = 0
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] != 0 and not visited[r][c]:
                count += 1
                color = input_grid[r][c]
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < len(input_grid) and 0 <= nc < len(input_grid[0]) and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
    if count % 2 == 0:
        return [row[::-1] for row in input_grid]
    else:
        return input_grid[::-1]
