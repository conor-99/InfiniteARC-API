# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 395b3d55
Difficulty: medium

=== Tags ===
- Reflect by color
- Pattern intersection
- Normalize orientation
- Take half

=== Description ===
The task involves transforming an input grid into an output grid through four
consistent steps. First, identify the leftmost vertical line of a single non-
zero color (e.g., color 5) that spans the entire height of the grid; this line
serves as the mirror axis. Second, reflect the grid across this mirror line
(left-right flip), ensuring the mirror line remains fixed. Third, normalize the
grid's orientation by rotating it 90 degrees clockwise if the mirror line was
horizontal, though in this task the mirror line is always vertical. Finally,
"take half" by retaining only the left half of the reflected grid (e.g., for a
6-column grid, output uses columns 0â€“2). The output grid's dimensions are halved
in width (rounded down if odd), while height remains unchanged. The
transformation is deterministic: the mirror line is uniquely determined by the
leftmost full-column non-zero color, reflection is exact, orientation
normalization is applied if needed, and halving is strictly left-aligned.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    W = random.randint(3, 30)
    H = random.randint(1, 30)
    mirror_color = random.randint(1, 9)
    c = random.randint(1, W-2)
    
    input_grid = [[0]*W for _ in range(H)]
    
    for col in range(c):
        input_grid[0][col] = 0
        for row in range(1, H):
            input_grid[row][col] = random.randint(0, 9)
    
    for row in range(H):
        input_grid[row][c] = mirror_color
    
    for col in range(c+1, W):
        for row in range(H):
            input_grid[row][col] = random.randint(0, 9)
    
    reflected = [[0]*W for _ in range(H)]
    for r in range(H):
        for i in range(W):
            j = 2*c - i
            if 0 <= j < W:
                reflected[r][i] = input_grid[r][j]
    
    output_width = W // 2
    output_grid = [row[:output_width] for row in reflected]
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    H = len(input_grid)
    W = len(input_grid[0])
    
    c = None
    for col in range(W):
        color = input_grid[0][col]
        if color == 0:
            continue
        all_same = True
        for row in range(1, H):
            if input_grid[row][col] != color:
                all_same = False
                break
        if all_same:
            c = col
            break
    
    if c is None:
        c = 0
    
    reflected = [[0]*W for _ in range(H)]
    for r in range(H):
        for i in range(W):
            j = 2*c - i
            if 0 <= j < W:
                reflected[r][i] = input_grid[r][j]
    
    output_width = W // 2
    output_grid = [row[:output_width] for row in reflected]
    
    return output_grid
