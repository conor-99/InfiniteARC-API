# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 06de8f7a
Difficulty: insane

=== Tags ===
- Recursive pattern copy
- Truth table visualization
- Momentum transfer
- Grid overlay blending
- Permute rows by length
- Proximity guessing

=== Description ===
The input grid features a central cross with four arms extending in cardinal
directions, each arm containing a repeating sequence of three distinct colors
(e.g., red, blue, green) arranged in a non-overlapping pattern. Surrounding the
cross are three concentric square frames, each frame's pattern being a 90°
clockwise rotation of the frame inside it. The frames contain nested patterns of
colored pixels that visually "bounce" off the cross arms, with their direction
of rotation reversing upon contact (like momentum transfer). The background is a
neutral color (0), with all patterns confined to non-background cells.  The
output grid requires the following transformations applied in sequence:  1.
**Recursive Pattern Copy**: The innermost frame's pattern is transformed by
rotating 90° clockwise relative to the frame outside it. The output adds a new
innermost frame following this pattern, with its colors derived from the
existing innermost frame via a truth table visualization (e.g., adjacent color
pairs in the frame's sequence map to a fixed output color via a predefined
lookup, such as red + blue = purple).  2. **Momentum Transfer**: Where frame
patterns intersect the cross arms, their rotation direction reverses (e.g., a
clockwise spiral becomes counterclockwise upon hitting the cross), and their
color shifts using a fixed blending rule (e.g., overlapping red and blue pixels
become purple).  3. **Grid Overlay Blending**: Overlapping regions between
frames and the cross are blended using a fixed color mapping (e.g., green +
yellow = orange), with the cross's neutral background remaining unchanged.  4.
**Permute Rows by Length**: Rows are sorted based on the length of the longest
contiguous segment of the dominant color in each row (e.g., rows with the
longest red segment appear first), applied after all pattern transformations.
5. **Proximity Guessing**: The new innermost frame's colors are determined by
the two adjacent colors in the existing innermost frame (e.g., if left is red
and right is blue, the new segment uses the predefined purple color from the
truth table).  All outer structures (cross, existing frames, background) remain
unchanged except for the new inner frame and the row permutation. The output
grid maintains visual consistency with the input's color patterns, with no
numerical or pixel-based rules used—only compositional visual transformations
based on spatial relationships and predefined color mappings.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Generator for ARC task 480

def generate():
    size = 15
    input_grid = grid(size, size, 0)
    center = size // 2
    arm_len = 3  # fixed so solver can reconstruct

    # Choose three distinct colors for the cross (non-zero)
    cross_colors = random.sample(list(range(1, 10)), 3)

    # Draw cross with repeating sequence of three colors along both arms
    start = center - arm_len
    end = center + arm_len
    for r in range(start, end + 1):
        input_grid[r][center] = cross_colors[(r - start) % 3]
    for c in range(start, end + 1):
        input_grid[center][c] = cross_colors[(c - start) % 3]

    # Helper: perimeter coords in clockwise order for a square bounding box
    def ring_coords(minc, maxc):
        coords = []
        # Top row
        for c in range(minc, maxc + 1):
            coords.append((minc, c))
        # Right col
        for r in range(minc + 1, maxc + 1):
            coords.append((r, maxc))
        # Bottom row
        if maxc > minc:
            for c in range(maxc - 1, minc - 1, -1):
                coords.append((maxc, c))
        # Left col
        if maxc > minc:
            for r in range(maxc - 1, minc, -1):
                coords.append((r, minc))
        return coords

    # Blending and truth-table mapping functions (fixed and known to solver)
    def blend(a, b):
        # deterministic symmetric blending mapping, avoids 0
        return ((a + b) % 9) + 1

    def truth_map(a, b):
        # deterministic mapping from an ordered pair of adjacent colors to new color
        return ((a * 3 + b * 5) % 9) + 1

    # Choose three colors for the frame sequence (can overlap with cross)
    frame_colors = random.sample(list(range(1, 10)), 3)

    # Place three concentric square frames (layers 1..3)
    for layer in range(1, 4):
        offset = arm_len + layer
        minc = center - offset
        maxc = center + offset
        coords = ring_coords(minc, maxc)
        L = len(coords)
        if L == 0:
            continue
        # Rotation: shift starting index by a quarter of this perimeter per layer
        start_idx = ((L // 4) * (layer - 1)) % L

        # Walk the perimeter, reversing direction where it intersects the cross
        visited = [False] * L
        cur = start_idx
        direction = 1
        seq_idx = 0
        assigned = 0
        while assigned < L:
            if not visited[cur]:
                r, c = coords[cur]
                color = frame_colors[seq_idx % 3]
                # If this perimeter cell intersects the cross (same row or col as center)
                if r == center or c == center:
                    # Use whatever is currently at the cross position (the cross was drawn first)
                    base_cross = input_grid[r][c] if input_grid[r][c] != 0 else 0
                    if base_cross != 0:
                        color = blend(color, base_cross)
                    # Place blended color and reverse direction (momentum transfer)
                    input_grid[r][c] = color
                    visited[cur] = True
                    assigned += 1
                    direction *= -1
                    seq_idx = (seq_idx + direction) % 3
                else:
                    input_grid[r][c] = color
                    visited[cur] = True
                    assigned += 1
                    seq_idx = (seq_idx + direction) % 3
            # Move to next index in current direction, skipping already visited until find an unvisited
            steps = 0
            cur = (cur + direction) % L
            while visited[cur] and steps < L:
                cur = (cur + direction) % L
                steps += 1

    # Build output by copying input and adding a new innermost frame
    output_grid = [row[:] for row in input_grid]

    # Inner frame (layer=1) bounds
    inner_offset = arm_len + 1
    inner_min = center - inner_offset
    inner_max = center + inner_offset
    inner_coords = ring_coords(inner_min, inner_max)
    inner_colors = [input_grid[r][c] for (r, c) in inner_coords]

    # New inner frame will sit one step inside the inner frame
    new_min = inner_min + 1
    new_max = inner_max - 1
    new_coords = ring_coords(new_min, new_max)
    L_new = len(new_coords)

    if L_new > 0 and len(inner_colors) > 0:
        start_new = (L_new // 4) % L_new
        for j in range(L_new):
            pair_idx = j % len(inner_colors)
            a = inner_colors[pair_idx]
            b = inner_colors[(pair_idx + 1) % len(inner_colors)]
            new_color = truth_map(a, b)
            r, c = new_coords[(start_new + j) % L_new]
            # Overlay blending with underlying cell
            if output_grid[r][c] == 0:
                output_grid[r][c] = new_color
            else:
                output_grid[r][c] = blend(new_color, output_grid[r][c])

    # Finally permute rows by length of the longest contiguous segment of the dominant (non-zero) color
    def longest_segment_for_row(row):
        # Find dominant non-zero color (most frequent non-zero value)
        freq = {}
        for val in row:
            if val == 0:
                continue
            freq[val] = freq.get(val, 0) + 1
        if not freq:
            dominant = 0
        else:
            dominant = max(freq, key=lambda k: (freq[k], -row.index(k)))
        maxlen = 0
        cur = 0
        for v in row:
            if v == dominant:
                cur += 1
            else:
                if cur > maxlen:
                    maxlen = cur
                cur = 0
        if cur > maxlen:
            maxlen = cur
        return maxlen

    rows_with_len = [(row, longest_segment_for_row(row)) for row in output_grid]
    # Sort by length descending; stable sort keeps relative ordering for ties
    rows_with_len.sort(key=lambda x: x[1], reverse=True)
    sorted_output = [row for row, _ in rows_with_len]

    return {"input": input_grid, "output": sorted_output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable grid
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0]) if H > 0 else 0

    # Helper: perimeter coords in clockwise order for a square bounding box
    def ring_coords(minc, maxc):
        coords = []
        for c in range(minc, maxc + 1):
            coords.append((minc, c))
        for r in range(minc + 1, maxc + 1):
            coords.append((r, maxc))
        if maxc > minc:
            for c in range(maxc - 1, minc - 1, -1):
                coords.append((maxc, c))
            for r in range(maxc - 1, minc, -1):
                coords.append((r, minc))
        return coords

    def blend(a, b):
        return ((a + b) % 9) + 1

    def truth_map(a, b):
        return ((a * 3 + b * 5) % 9) + 1

    # Use grid center (generator places the main cross at the geometric center)
    center = H // 2

    # The generator uses arm_len = 3
    arm_len = 3

    # Reconstruct the inner frame coordinates and colors from the input
    inner_offset = arm_len + 1
    inner_min = center - inner_offset
    inner_max = center + inner_offset
    inner_coords = ring_coords(inner_min, inner_max)
    inner_colors = [grid[r][c] for (r, c) in inner_coords]

    # Prepare output by copying the input
    output = [row[:] for row in grid]

    # Build new inner frame one step inside the inner frame
    new_min = inner_min + 1
    new_max = inner_max - 1
    new_coords = ring_coords(new_min, new_max)
    L_new = len(new_coords)

    if L_new > 0 and len(inner_colors) > 0:
        start_new = (L_new // 4) % L_new
        for j in range(L_new):
            pair_idx = j % len(inner_colors)
            a = inner_colors[pair_idx]
            b = inner_colors[(pair_idx + 1) % len(inner_colors)]
            new_color = truth_map(a, b)
            r, c = new_coords[(start_new + j) % L_new]
            if output[r][c] == 0:
                output[r][c] = new_color
            else:
                output[r][c] = blend(new_color, output[r][c])

    # Permute rows by length of the longest contiguous segment of the dominant (non-zero) color
    def longest_segment_for_row(row):
        freq = {}
        for val in row:
            if val == 0:
                continue
            freq[val] = freq.get(val, 0) + 1
        if not freq:
            dominant = 0
        else:
            dominant = max(freq, key=lambda k: (freq[k], -row.index(k)))
        maxlen = 0
        cur = 0
        for v in row:
            if v == dominant:
                cur += 1
            else:
                if cur > maxlen:
                    maxlen = cur
                cur = 0
        if cur > maxlen:
            maxlen = cur
        return maxlen

    rows_with_len = [(row, longest_segment_for_row(row)) for row in output]
    rows_with_len.sort(key=lambda x: x[1], reverse=True)
    sorted_output = [row for row, _ in rows_with_len]

    return sorted_output

