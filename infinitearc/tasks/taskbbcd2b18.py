# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: bbcd2b18
Difficulty: mediumâ€“hard

=== Tags ===
- Analogical mapping between pairs
- Sequential path painting
- Connect all dots of same color
- Draw rectangle

=== Description ===
The task involves transforming input grids into output grids by connecting same-
colored dots into rectangular shapes through sequential path painting. Input
grids contain multiple distinct colors (1-9) represented as isolated dots
(single cells) on a background (0). For each color present in the input, the
dots must form the four corners of a rectangle (top-left, top-right, bottom-
left, bottom-right), with no additional dots for that color. The output grid
must connect all dots of the same color by drawing the full perimeter of the
rectangle using that color. This includes filling all cells along the top,
bottom, left, and right edges of the bounding box defined by the corner dots
(excluding the corners themselves, which are already present in the input). The
transformation requires recognizing the rectangular structure implied by the
corner dots, then sequentially painting the top edge, right edge, bottom edge,
and left edge in sequence to complete the rectangle. Background cells remain
unchanged except where paths are drawn. The task demands geometric reasoning to
identify corner positions, verify rectangular alignment, and apply precise path
painting without overlapping or altering existing structures.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random


def generate():
    """Generate a grid with 1-3 colored rectangles specified only by their four corner dots.

    The input contains only the four corner dots for each rectangle (colors 1-9) on a
    background 0. The output connects those corners by painting the rectangle perimeter
    (top, right, bottom, left edges) using the same color. When multiple rectangles
    exist, their perimeters are painted in ascending color order to make the transformation
    deterministic and reproducible by the solver.
    """
    # Size of the grid
    width = random.randint(5, 20)
    height = random.randint(5, 20)

    # Create empty input grid
    input_grid = [[0 for _ in range(width)] for _ in range(height)]

    # Choose between 1 and 3 rectangles/colors
    num_colors = random.randint(1, 3)
    chosen_colors = random.sample(list(range(1, 10)), num_colors)

    # Keep track of rectangles that were successfully placed: color -> (r1, r2, c1, c2)
    rects = {}

    for color in chosen_colors:
        # Try to place a rectangle such that its four corners are empty
        attempts = 0
        while True:
            attempts += 1
            if attempts > 500:
                # Give up on this color if we can't place a non-conflicting corner set
                break
            r1 = random.randint(0, height - 3)
            r2 = random.randint(r1 + 2, height - 1)
            c1 = random.randint(0, width - 3)
            c2 = random.randint(c1 + 2, width - 1)
            corners = [(r1, c1), (r1, c2), (r2, c1), (r2, c2)]
            if all(input_grid[r][c] == 0 for (r, c) in corners):
                # Place corner dots in the input
                for (r, c) in corners:
                    input_grid[r][c] = color
                rects[color] = (r1, r2, c1, c2)
                break

    # Build output by painting perimeters in ascending color order so the result is deterministic
    output_grid = [row[:] for row in input_grid]
    for color in sorted(rects.keys()):
        r1, r2, c1, c2 = rects[color]
        # Paint top and bottom edges (excluding corners)
        for col in range(c1 + 1, c2):
            output_grid[r1][col] = color
            output_grid[r2][col] = color
        # Paint left and right edges (excluding corners)
        for row in range(r1 + 1, r2):
            output_grid[row][c1] = color
            output_grid[row][c2] = color

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    """Solver: Given an input grid that contains only corner dots for each rectangle,
    paint the perimeter of each rectangle so that the output matches the generator.

    The solver reads the set of colors present in the original input (excluding 0),
    identifies the four corner positions for each color (must be exactly four),
    and paints the four edges of the bounding box defined by those corners.

    Important: the solver reads corner positions from the original input snapshot and
    writes into a separate output grid. Perimeters are painted in ascending color order
    to match the generator's deterministic painting order.
    """
    # Convert input (tuple of tuples) to a mutable list-of-lists for reading and writing
    ingrid = [list(row) for row in input_grid]
    height = len(ingrid)
    width = len(ingrid[0]) if height > 0 else 0

    # Output starts as a copy of the input corners
    out = [row[:] for row in ingrid]

    # Determine which colors are present in the original input (exclude background 0)
    colors_present = sorted({ingrid[r][c] for r in range(height) for c in range(width) if ingrid[r][c] != 0})

    for color in colors_present:
        # collect positions of this color from the original input snapshot
        positions = []
        for r in range(height):
            for c in range(width):
                if ingrid[r][c] == color:
                    positions.append((r, c))
        # Must have exactly four corner dots to define a rectangle
        if len(positions) != 4:
            continue
        rows = [p[0] for p in positions]
        cols = [p[1] for p in positions]
        min_r, max_r = min(rows), max(rows)
        min_c, max_c = min(cols), max(cols)

        # verify that the four extreme corners are indeed the ones present
        if not ((min_r, min_c) in positions and (min_r, max_c) in positions and (max_r, min_c) in positions and (max_r, max_c) in positions):
            continue

        # Paint edges (excluding the corners themselves)
        for col in range(min_c + 1, max_c):
            out[min_r][col] = color
            out[max_r][col] = color
        for row in range(min_r + 1, max_r):
            out[row][min_c] = color
            out[row][max_c] = color

    return out

