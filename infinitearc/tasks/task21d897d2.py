# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 21d897d2
Difficulty: mediumâ€“hard

=== Tags ===
- Pattern alignment
- Indexed painting
- Goal conditioned path
- Interleaved streams
- Find the two identical shapes
- Encircle all pixels of one color

=== Description ===
The input grid consists of a 2D arrangement of colored pixels (0-9), where each
connected region of a single color forms a distinct shape. Exactly one color
appears in two separate shapes that are structurally identical (same size,
orientation, and pixel arrangement). The output grid is derived by drawing a
border around all pixels of this specific color. The border is created by
setting all orthogonally adjacent cells (up, down, left, right) of the target
color to a fixed border color (9), while preserving the original target color
and all other grid elements. The two identical shapes must be visually
distinguishable from other shapes in the grid, requiring recognition of exact
structural patterns rather than color or size alone. The border encircles all
instances of the target color, regardless of whether they are connected,
creating a continuous outline around every occurrence of the color.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    width = common.randint(5, 30)
    height = common.randint(5, 30)
    target_color = common.randint(1, 8)
    base_shape = common.continuous_creature(3, width, height)
    min_r = min(r for r, c in base_shape)
    max_r = max(r for r, c in base_shape)
    min_c = min(c for r, c in base_shape)
    max_c = max(c for r, c in base_shape)
    dx = max(max_c - min_c + 2, 1)
    dy = 0
    second_shape = [(r + dy, c + dx) for r, c in base_shape]
    if any(r < 0 or r >= height or c < 0 or c >= width for r, c in second_shape):
        dx = 1
        dy = max(max_r - min_r + 2, 1)
        second_shape = [(r + dy, c + dx) for r, c in base_shape]
    input_grid = common.grid(width, height, 0)
    for r, c in base_shape:
        input_grid[r][c] = target_color
    for r, c in second_shape:
        input_grid[r][c] = target_color
    output_grid = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == target_color:
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        if input_grid[nr][nc] != target_color:
                            output_grid[nr][nc] = 9
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    def find_regions(color):
        visited = [[False] * len(input_grid[0]) for _ in range(len(input_grid))]
        regions = []
        for r in range(len(input_grid)):
            for c in range(len(input_grid[0])):
                if input_grid[r][c] == color and not visited[r][c]:
                    stack = [(r, c)]
                    visited[r][c] = True
                    region = []
                    while stack:
                        cr, cc = stack.pop()
                        region.append((cr, cc))
                        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < len(input_grid) and 0 <= nc < len(input_grid[0]) and input_grid[nr][nc] == color and not visited[nr][nc]:
                                visited[nr][nc] = True
                                stack.append((nr, nc))
                    regions.append(region)
        return regions
    colors = set()
    for row in input_grid:
        for cell in row:
            if cell != 0:
                colors.add(cell)
    target_color = None
    for color in colors:
        regions = find_regions(color)
        if len(regions) == 2:
            target_color = color
            break
    if target_color is None:
        target_color = 1
    output_grid = [row[:] for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == target_color:
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != target_color:
                        output_grid[nr][nc] = 9
    return output_grid
