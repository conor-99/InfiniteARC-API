# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: f62bf27d
Difficulty: very hard

=== Tags ===
- Directed field
- Periodic offset matching
- Select every nth column

=== Description ===
Task Name: Directed Periodic Column Selection  Description: Input grids are
10×10 to 30×30 in size, featuring a complex arrangement of colors against a
distinct background. Superimposed on the grid is a "directed field" composed of
a small, contiguous arrow-shaped pattern (typically 3×2 cells) formed using a
unique color that contrasts with both the background and other grid elements.
The direction of this arrow (right, left, up, or down) determines which row or
column contains a periodic color sequence critical for the transformation.  The
arrow's direction specifies the location of the periodic sequence: a right-
pointing arrow indicates the top row (row 0), a left-pointing arrow indicates
the bottom row (row height-1), an upward-pointing arrow indicates the leftmost
column (column 0), and a downward-pointing arrow indicates the rightmost column
(column width-1). In the specified row or column, a repeating color sequence
appears where the sequence's minimal period (smallest repeating unit) defines
the selection interval n.  The output grid is constructed by selecting every nth
column from the input grid, starting from column 0 (i.e., columns 0, n, 2n,
...), while preserving all rows. For example, if the sequence repeats every 5
columns (n=5), the output includes columns 0, 5, 10, 15, etc. The minimal period
must be identified despite potential visual noise, such as the sequence
overlapping with background elements or containing minor irregularities in the
repeating pattern.  This task demands multi-step visual reasoning: first
identifying the arrow's direction within the grid's clutter, then analyzing the
sequence for its minimal period, and finally applying the column selection rule.
The challenge is heightened by the need to distinguish the periodic sequence
from non-repeating elements, as the sequence may appear in a non-standard
position relative to the arrow, and the minimal period may not be immediately
apparent due to the sequence's length or color complexity. The transformation
requires no additional operations beyond column selection, but the discovery of
the correct period n is non-trivial and requires careful pattern recognition.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Grid size
    width = random.randint(10, 30)
    height = random.randint(10, 30)

    # Background color
    bg = random.randint(0, 9)

    # Initialize grid with background
    grid = [[bg for _ in range(width)] for _ in range(height)]

    # Pool of non-background colors for sequences and arrow
    non_bg_colors = [c for c in range(1, 10) if c != bg]
    max_n = min(6, len(non_bg_colors))
    n = random.randint(2, max_n)

    # Create a base repeating pattern of distinct colors to ensure minimal period = n
    base = random.sample(non_bg_colors, n)

    # Choose an arrow color distinct from bg and base
    arrow_pool = [c for c in range(1, 10) if c != bg and c not in base]
    if not arrow_pool:
        # Fallback (should be extremely rare given constraints)
        arrow_color = random.choice([c for c in range(1, 10) if c != bg])
        if arrow_color in base:
            # ensure uniqueness by replacing one base color
            for i in range(len(base)):
                if base[i] != arrow_color:
                    base[i] = arrow_color
                    break
    else:
        arrow_color = random.choice(arrow_pool)

    # Choose direction
    direction = random.choice(['right', 'left', 'up', 'down'])

    # Place the periodic sequence according to direction
    if direction == 'right':
        seq_row = 0
        for c in range(width):
            grid[seq_row][c] = base[c % n]
        seq_col = None
    elif direction == 'left':
        seq_row = height - 1
        for c in range(width):
            grid[seq_row][c] = base[c % n]
        seq_col = None
    elif direction == 'up':
        seq_col = 0
        for r in range(height):
            grid[r][seq_col] = base[r % n]
        seq_row = None
    else:  # down
        seq_col = width - 1
        for r in range(height):
            grid[r][seq_col] = base[r % n]
        seq_row = None

    # Define arrow templates (ones are arrow pixels relative to top-left)
    patterns = {
        'right': {'h': 3, 'w': 2, 'ones': [(0, 1), (1, 0), (1, 1), (2, 1)]},
        'left': {'h': 3, 'w': 2, 'ones': [(0, 0), (1, 0), (1, 1), (2, 0)]},
        'up': {'h': 2, 'w': 3, 'ones': [(0, 1), (1, 0), (1, 1), (1, 2)]},
        'down': {'h': 2, 'w': 3, 'ones': [(0, 0), (0, 1), (0, 2), (1, 1)]}
    }

    pat = patterns[direction]
    h, w = pat['h'], pat['w']

    # Choose a placement for the arrow that does not overlap the sequence row/column
    candidates = []
    for r0 in range(0, height - h + 1):
        for c0 in range(0, width - w + 1):
            # compute coordinates of the pattern
            coords = [(r0 + dr, c0 + dc) for (dr, dc) in pat['ones']]
            overlaps_seq = False
            for (rr, cc) in coords:
                if seq_row is not None and rr == seq_row:
                    overlaps_seq = True
                    break
                if seq_col is not None and cc == seq_col:
                    overlaps_seq = True
                    break
            if overlaps_seq:
                continue
            candidates.append((r0, c0))

    # There should always be at least one candidate because the grid is large
    if not candidates:
        # fallback: allow overlap if no other option (very unlikely)
        for r0 in range(0, height - h + 1):
            for c0 in range(0, width - w + 1):
                candidates.append((r0, c0))

    r0, c0 = random.choice(candidates)

    # Paint the arrow
    arrow_cells = set()
    for dr, dc in pat['ones']:
        rr, cc = r0 + dr, c0 + dc
        grid[rr][cc] = arrow_color
        arrow_cells.add((rr, cc))

    # Fill remaining cells with random colors, avoiding using arrow_color elsewhere
    for r in range(height):
        for c in range(width):
            if (seq_row is not None and r == seq_row) or (seq_col is not None and c == seq_col):
                continue
            if (r, c) in arrow_cells:
                continue
            # allow any color except arrow_color to keep arrow unique
            grid[r][c] = random.choice([col for col in range(0, 10) if col != arrow_color])

    # Build output grid by selecting every n-th column starting at 0
    selected_cols = list(range(0, width, n))
    output = [[grid[r][c] for c in selected_cols] for r in range(height)]

    return {'input': grid, 'output': output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Patterns used by the generator
    shapes = {
        (3, 2): {
            'right': {(0, 1), (1, 0), (1, 1), (2, 1)},
            'left': {(0, 0), (1, 0), (1, 1), (2, 0)}
        },
        (2, 3): {
            'up': {(0, 1), (1, 0), (1, 1), (1, 2)},
            'down': {(0, 0), (0, 1), (0, 2), (1, 1)}
        }
    }

    # Collect positions of each color
    color_positions = {}
    for r in range(height):
        for c in range(width):
            col = grid[r][c]
            color_positions.setdefault(col, []).append((r, c))

    found_direction = None
    # Find the color that forms the arrow by checking for a 4-cell shape matching one of the templates
    for col, positions in color_positions.items():
        if len(positions) != 4:
            continue
        rows = [p[0] for p in positions]
        cols = [p[1] for p in positions]
        minr, maxr = min(rows), max(rows)
        minc, maxc = min(cols), max(cols)
        h = maxr - minr + 1
        w = maxc - minc + 1
        key = (h, w)
        if key not in shapes:
            continue
        # Normalize positions relative to top-left
        rel = {(r - minr, c - minc) for (r, c) in positions}
        for direction, pattern in shapes[key].items():
            if rel == pattern:
                found_direction = direction
                break
        if found_direction:
            break

    if not found_direction:
        raise Exception('Arrow not found')

    # Map direction to periodic sequence location
    if found_direction == 'right':
        seq = grid[0]
    elif found_direction == 'left':
        seq = grid[height - 1]
    elif found_direction == 'up':
        seq = [grid[r][0] for r in range(height)]
    else:  # down
        seq = [grid[r][width - 1] for r in range(height)]

    # Find minimal period of seq
    def minimal_period(sequence):
        L = len(sequence)
        for n in range(1, L + 1):
            ok = True
            for i in range(L - n):
                if sequence[i] != sequence[i + n]:
                    ok = False
                    break
            if ok:
                return n
        return L

    n = minimal_period(seq)

    # Build output by selecting every n-th column starting from 0
    selected_cols = list(range(0, width, n))
    output = [[grid[r][c] for c in selected_cols] for r in range(height)]
    return output

