# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 9e5d3022
Difficulty: medium–hard

=== Tags ===
- Line collision
- Propagation by rule weight
- Pressure release
- Hierarchical logic composition
- Color by distance to a single point

=== Description ===
Input grids feature a single pressure source point (a cell of color 9)
positioned centrally or near the grid's center. Surrounding this source are
multiple straight-line segments (each composed of contiguous cells of a single
color from 1–8) extending from the grid's edges toward the source. These lines
may be horizontal, vertical, or diagonal, but maintain consistent directionality
toward the source. The output grid transforms each line segment by recoloring
its cells based on Manhattan distance to the pressure source, following a fixed
descending sequence: distance 1 → color 8, distance 2 → color 7, distance 3 →
color 6, distance 4 → color 5, and all distances ≥5 → color 4. When multiple
lines occupy cells at identical distances (line collision), the line with the
higher color value (rule weight) overwrites the lower-weight line's color.
"Pressure release" activates at distances ≤2, intensifying colors (e.g.,
distance 1 becomes color 8 instead of color 7) as a visual representation of
cumulative pressure. Hierarchical logic composition ensures distance-based
coloring is applied first, with collision resolution as a secondary rule. The
source cell (color 9) remains unchanged, and all transformations strictly
preserve grid boundaries without overlapping or invalid configurations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random
from typing import List, Dict

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = common.grid(width, height, 0)
    
    sx = height // 2
    sy = width // 2
    grid[sx][sy] = 9
    
    row = sx - 2
    if row < 0:
        row = 0
    color1 = random.randint(1, 8)
    for c in range(0, sy):
        if row < height and c < width:
            grid[row][c] = color1
    
    color2 = random.randint(1, 8)
    for r in range(0, sx):
        c = r
        if c < sy and r < height and c < width:
            grid[r][c] = color2
    
    col = sy - 2
    if col < 0:
        col = 0
    color3 = random.randint(1, 8)
    for r in range(0, sx):
        if r < height and col < width:
            grid[r][col] = color3
    
    output = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 9:
                output[r][c] = 9
            else:
                d = abs(r - sx) + abs(c - sy)
                if d == 1:
                    output[r][c] = 8
                elif d == 2:
                    output[r][c] = 7
                elif d == 3:
                    output[r][c] = 6
                elif d == 4:
                    output[r][c] = 5
                else:
                    output[r][c] = 4
    
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    sx, sy = -1, -1
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 9:
                sx, sy = r, c
                break
        if sx != -1:
            break
    
    if sx == -1 or sy == -1:
        return input_grid
    
    output = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 9:
                output[r][c] = 9
            else:
                d = abs(r - sx) + abs(c - sy)
                if d == 1:
                    output[r][c] = 8
                elif d == 2:
                    output[r][c] = 7
                elif d == 3:
                    output[r][c] = 6
                elif d == 4:
                    output[r][c] = 5
                else:
                    output[r][c] = 4
    return output
