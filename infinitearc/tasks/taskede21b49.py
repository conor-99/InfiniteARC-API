# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: ede21b49
Difficulty: medium

=== Tags ===
- Repeat pattern to fill shape
- Associate images to bools
- Remove noise

=== Description ===
The task involves transforming an input grid into an output grid by first
identifying and isolating a main shape, then filling it with a repeating pattern
based on a boolean indicator. The input grid contains a contiguous main shape
(e.g., a rectangle or irregular form) defined by a specific non-zero color
(e.g., color 2), surrounded by noise (randomly distributed non-zero colors). The
boolean indicator is determined by the top-left pixel (0,0): if it contains
color 5, the pattern repeats horizontally; otherwise, it repeats vertically. The
output grid removes all noise (retaining only the main shape's outline), then
fills the shape with a repeating two-color pattern (colors 3 and 4). For
horizontal repetition, each row alternates between colors 3 and 4 starting with
3; for vertical repetition, each column alternates between colors 3 and 4
starting with 3. The main shape must be a single connected region (4-connected),
and the boolean indicator must be clearly distinguishable from noise to ensure
consistent transformation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    horizontal = random.choice([True, False])
    indicator = 5 if horizontal else random.choice([1, 3, 4, 6, 7, 8, 9])
    
    width = random.randint(2, 30)
    height = random.randint(2, 30)
    
    input_grid = [[0] * width for _ in range(height)]
    input_grid[0][0] = indicator
    
    main_shape = [(0, 1), (1, 1)]
    for r, c in main_shape:
        if r < height and c < width:
            input_grid[r][c] = 2
    
    for r in range(height):
        for c in range(width):
            if (r, c) == (0, 0) or (r, c) in main_shape:
                continue
            input_grid[r][c] = random.choice([1, 3, 4, 5, 6, 7, 8, 9])
    
    output_grid = [[0] * width for _ in range(height)]
    main_cells = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 2:
                main_cells.append((r, c))
    
    if horizontal:
        row_min_cols = {}
        for r, c in main_cells:
            if r not in row_min_cols or c < row_min_cols[r]:
                row_min_cols[r] = c
        for r, c in main_cells:
            offset = c - row_min_cols[r]
            output_grid[r][c] = 3 if offset % 2 == 0 else 4
    else:
        col_min_rows = {}
        for r, c in main_cells:
            if c not in col_min_rows or r < col_min_rows[c]:
                col_min_rows[c] = r
        for r, c in main_cells:
            offset = r - col_min_rows[c]
            output_grid[r][c] = 3 if offset % 2 == 0 else 4
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    main_cells = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 2:
                main_cells.append((r, c))
    
    horizontal = (input_grid[0][0] == 5)
    
    output_grid = [[0] * width for _ in range(height)]
    
    if horizontal:
        row_min_cols = {}
        for r, c in main_cells:
            if r not in row_min_cols or c < row_min_cols[r]:
                row_min_cols[r] = c
        for r, c in main_cells:
            offset = c - row_min_cols[r]
            output_grid[r][c] = 3 if offset % 2 == 0 else 4
    else:
        col_min_rows = {}
        for r, c in main_cells:
            if c not in col_min_rows or r < col_min_rows[c]:
                col_min_rows[c] = r
        for r, c in main_cells:
            offset = r - col_min_rows[c]
            output_grid[r][c] = 3 if offset % 2 == 0 else 4
    
    return output_grid
