# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 634a7bc5
Difficulty: very hard

=== Tags ===
- Color modulated logic
- Maze
- Periodic run length encoding

=== Description ===
Input grids consist of a complex maze structure composed of walls (distinct
color) and a single continuous path from a designated start point to an
endpoint. The path is defined by orthogonally connected cells of varying colors
(0-9), with the background and walls remaining unchanged. The maze contains
multiple "color runs" along the path—consecutive segments where the path cells
share identical colors.   To generate the output grid, the path must first be
traversed from start to end to identify all color runs. For each run at index
*i* (starting from 0), every cell in the run undergoes a color transformation
using the formula: *new_color = (original_color + (i mod 3)) mod 10*. This
periodic modulation (with a fixed period of 3) shifts each run's color based on
its sequential position in the path. The maze structure (walls, path
connectivity, and background) remains entirely unchanged; only the path's cell
colors are modified according to this rule. The transformation requires precise
identification of path segments, correct run indexing, and consistent
application of the periodic color shift—making it challenging to distinguish
from random noise or misinterpretation of path segments.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    """Generate a grid with walls (9) and a single continuous path of colored cells.

    The path starts at (1,1) and is built by a self-avoiding random walk that forbids
    creating orthogonal adjacency to any earlier path cell except the immediate predecessor.
    The path is then partitioned into runs (random lengths 1..4, at least two runs), each run
    receiving a base color in 1..8 (adjacent runs are guaranteed different). The output grid
    applies the transformation new_color = (original_color + (run_index % 3)) % 10.
    """
    # Try multiple times to build a valid path; restart if generation fails constraints.
    for attempt in range(200):
        width = random.randint(10, 28)
        height = random.randint(10, 28)
        if width < 5: width = 5
        if height < 5: height = 5

        base_grid = [[9 for _ in range(width)] for _ in range(height)]

        start = (1, 1)
        path = [start]
        path_set = {start}

        def inside(r, c):
            return 1 <= r < height - 1 and 1 <= c < width - 1

        max_possible = max(6, (width - 2) * (height - 2) // 3)
        target_len = random.randint(6, min(max_possible, 200))

        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]

        while len(path) < target_len:
            r, c = path[-1]
            cand = []
            random.shuffle(directions)
            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                if not inside(nr, nc):
                    continue
                if (nr, nc) in path_set:
                    continue
                ok = True
                for dr2, dc2 in directions:
                    ar, ac = nr + dr2, nc + dc2
                    if (ar, ac) in path_set and (ar, ac) != (r, c):
                        ok = False
                        break
                if ok:
                    cand.append((nr, nc))
            if not cand:
                break
            nxt = random.choice(cand)
            path.append(nxt)
            path_set.add(nxt)

        if len(path) < 6:
            continue

        L = len(path)
        run_lengths = []
        remaining = L
        while remaining > 0:
            max_run = min(4, remaining)
            length = random.randint(1, max_run)
            run_lengths.append(length)
            remaining -= length
        if len(run_lengths) < 2:
            if run_lengths[0] > 1:
                a = run_lengths[0] // 2
                b = run_lengths[0] - a
                run_lengths = [a, b] + run_lengths[1:]
            else:
                continue

        # Assign base colors ensuring adjacent runs have different colors
        base_colors = []
        for i in range(len(run_lengths)):
            forbidden = {base_colors[-1]} if base_colors else set()
            # avoid 0 and 9
            choices = [c for c in range(1, 9) if c not in forbidden]
            color = random.choice(choices)
            base_colors.append(color)

        # Build input grid
        input_grid = [row[:] for row in base_grid]
        idx = 0
        for run_idx, length in enumerate(run_lengths):
            color = base_colors[run_idx]
            for _ in range(length):
                r, c = path[idx]
                input_grid[r][c] = color
                idx += 1

        # Build output grid
        output_grid = [row[:] for row in input_grid]
        idx = 0
        for run_idx, length in enumerate(run_lengths):
            shift = run_idx % 3
            for _ in range(length):
                r, c = path[idx]
                output_grid[r][c] = (input_grid[r][c] + shift) % 10
                idx += 1

        if input_grid != output_grid:
            return {"input": input_grid, "output": output_grid}

    # Fallback example
    width, height = 10, 10
    base_grid = [[9 for _ in range(width)] for _ in range(height)]
    path = [(1, 1), (1, 2), (1, 3), (2, 3), (3, 3), (3, 2)]
    run_lengths = [2, 2, 2]
    base_colors = [2, 4, 6]
    input_grid = [row[:] for row in base_grid]
    idx = 0
    for run_idx, length in enumerate(run_lengths):
        color = base_colors[run_idx]
        for _ in range(length):
            r, c = path[idx]
            input_grid[r][c] = color
            idx += 1
    output_grid = [row[:] for row in input_grid]
    idx = 0
    for run_idx, length in enumerate(run_lengths):
        shift = run_idx % 3
        for _ in range(length):
            r, c = path[idx]
            output_grid[r][c] = (input_grid[r][c] + shift) % 10
            idx += 1
    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Path cells are those that are not background (0) and not walls (9).
    path_cells = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and grid[r][c] != 9:
                path_cells.append((r, c))

    if not path_cells:
        return tuple(tuple(row) for row in grid)

    path_set = set(path_cells)

    # Build adjacency among path cells (4-connected)
    adj = {}
    for (r, c) in path_cells:
        neighbors = []
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if (nr, nc) in path_set:
                neighbors.append((nr, nc))
        adj[(r, c)] = neighbors

    # Find endpoints (degree 1). Choose the lexicographically smallest endpoint as start.
    endpoints = [p for p, neighs in adj.items() if len(neighs) == 1]
    if endpoints:
        start = min(endpoints)
    else:
        # Degenerate case: treat lexicographically smallest path cell as start
        start = min(path_cells)

    # Traverse the path from start to end by always moving to the unvisited neighbor.
    ordered = [start]
    visited = {start}
    current = start
    while True:
        nexts = [n for n in adj[current] if n not in visited]
        if not nexts:
            break
        # deterministic selection (should be a single neighbor in a well-formed path)
        nexts.sort()
        nxt = nexts[0]
        ordered.append(nxt)
        visited.add(nxt)
        current = nxt

    # Group ordered path into color runs (consecutive same-color segments)
    runs = []
    if ordered:
        r0, c0 = ordered[0]
        cur_color = grid[r0][c0]
        cur_run = [(r0, c0)]
        for (r, c) in ordered[1:]:
            col = grid[r][c]
            if col == cur_color:
                cur_run.append((r, c))
            else:
                runs.append((cur_color, cur_run))
                cur_color = col
                cur_run = [(r, c)]
        runs.append((cur_color, cur_run))

    # Apply the periodic modulation: new_color = (original_color + (i mod 3)) mod 10
    for i, (color, cells) in enumerate(runs):
        shift = i % 3
        for (r, c) in cells:
            grid[r][c] = (color + shift) % 10

    return tuple(tuple(row) for row in grid)

