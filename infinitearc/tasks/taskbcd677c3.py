# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: bcd677c3
Difficulty: hard

=== Tags ===
- Projection unto rectangle

=== Description ===
The input grid is a larger grid containing regularly spaced lines (of a single
non-zero color) that partition the grid into uniform blocks. The lines form a
grid structure, with spacing between consecutive lines defined by the parameter
`spacing` (i.e., lines appear at intervals of `spacing + 1` cells). The output
grid is formed by extracting the color of the top-left cell of each block (the
cell immediately following the top and left lines), ignoring the line colors.
The dimensions of the output grid are determined by the number of blocks along
the width and height, calculated as `(input_width - 1) // (spacing + 1)` and
`(input_height - 1) // (spacing + 1)`. The task requires identifying the line
spacing, determining the block structure, and reconstructing the output grid by
sampling the top-left color of each block. This involves abstract reasoning to
detect the regular pattern of lines and map the input structure to the output
rectangle.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

defined_input_grids = set()

def generate():
    while True:
        line_spacing = random.randint(2, 15)
        line_color = random.randint(1, 9)
        W = random.randint(line_spacing + 5, 30)
        H = random.randint(line_spacing + 5, 30)
        input_grid = [[0] * W for _ in range(H)]
        for r in range(H):
            if r % line_spacing == 0:
                for c in range(W):
                    input_grid[r][c] = line_color
        for c in range(W):
            if c % line_spacing == 0:
                for r in range(H):
                    input_grid[r][c] = line_color
        for r in range(H):
            for c in range(W):
                if r % line_spacing != 0 and c % line_spacing != 0:
                    input_grid[r][c] = random.randint(0, 9)
        M = (W - 1) // line_spacing
        N = (H - 1) // line_spacing
        output_grid = [[0] * M for _ in range(N)]
        for i in range(N):
            for j in range(M):
                output_grid[i][j] = input_grid[line_spacing * i + 1][line_spacing * j + 1]
        input_tuple = tuple(tuple(row) for row in input_grid)
        if input_tuple not in defined_input_grids:
            defined_input_grids.add(input_tuple)
            return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    H = len(input_grid)
    W = len(input_grid[0])
    line_rows = []
    for r in range(H):
        if all(x == input_grid[r][0] for x in input_grid[r]) and input_grid[r][0] != 0:
            line_rows.append(r)
    if len(line_rows) >= 2:
        line_rows.sort()
        line_spacing = line_rows[1] - line_rows[0]
    else:
        line_cols = []
        for c in range(W):
            col = [input_grid[r][c] for r in range(H)]
            if all(x == col[0] for x in col) and col[0] != 0:
                line_cols.append(c)
        if len(line_cols) >= 2:
            line_cols.sort()
            line_spacing = line_cols[1] - line_cols[0]
        else:
            line_spacing = 2
    M = (W - 1) // line_spacing
    N = (H - 1) // line_spacing
    output_grid = [[0] * M for _ in range(N)]
    for i in range(N):
        for j in range(M):
            output_grid[i][j] = input_grid[line_spacing * i + 1][line_spacing * j + 1]
    return output_grid
