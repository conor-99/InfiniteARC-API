# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 515084f7
Difficulty: hard

=== Tags ===
- Associate images to patterns
- Size guessing
- Connect dots by order
- Unfold paper crease pattern

=== Description ===
The input grid represents a folded paper with crease lines (color 2) dividing
the grid into regions that have been folded over each other. Dots (color 1) are
placed within the folded regions, visible only in their folded positions. To
generate the output, first unfold the grid by mirroring each folded region
across its crease to reconstruct the original full grid. Next, identify all dots
(color 1) in the unfolded grid and sort their positions in strict row-major
order (top to bottom, left to right). Finally, connect consecutive dots with a
straight path using color 3, following the shortest Manhattan path (moving only
horizontally or vertically between adjacent cells), filling all intermediate
cells with color 3 to form a continuous line. The output grid must retain all
original unfolded elements while adding the path between dots. This task
requires simultaneous application of geometric unfolding logic, spatial
ordering, and path-drawing rules, making it challenging due to the multi-step
reasoning and precision needed to handle overlapping folds and dot ordering.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    import common
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    
    crease_type = random.choice(['vertical', 'horizontal'])
    
    if crease_type == 'vertical':
        while width < 3:
            width = random.randint(1, 30)
        k = random.randint(1, width - 2)
    else:
        while height < 3:
            height = random.randint(1, 30)
        k = random.randint(1, height - 2)
    
    grid = common.grid(width, height, 0)
    
    if crease_type == 'vertical':
        for r in range(height):
            grid[r][k] = 2
        for r in range(height):
            for c in range(k):
                if random.random() < 0.3:
                    grid[r][c] = 1
    else:
        for c in range(width):
            grid[k][c] = 2
        for r in range(k):
            for c in range(width):
                if random.random() < 0.3:
                    grid[r][c] = 1
    
    input_grid = grid
    output_grid = [list(row) for row in grid]
    
    if crease_type == 'vertical':
        for r in range(height):
            for c in range(k):
                if input_grid[r][c] == 1:
                    mirror_c = 2*k - c
                    if 0 <= mirror_c < width:
                        output_grid[r][mirror_c] = 1
    else:
        for c in range(width):
            for r in range(k):
                if input_grid[r][c] == 1:
                    mirror_r = 2*k - r
                    if 0 <= mirror_r < height:
                        output_grid[mirror_r][c] = 1
    
    dots = []
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] == 1:
                dots.append((r, c))
    dots.sort(key=lambda x: (x[0], x[1]))
    
    for i in range(len(dots) - 1):
        r1, c1 = dots[i]
        r2, c2 = dots[i+1]
        for c in range(min(c1, c2) + 1, max(c1, c2)):
            output_grid[r1][c] = 3
        for r in range(min(r1, r2) + 1, max(r1, r2)):
            output_grid[r][c2] = 3
    
    for r, c in dots:
        output_grid[r][c] = 1
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    vertical_creases = []
    horizontal_creases = []
    for c in range(width):
        if all(input_grid[r][c] == 2 for r in range(height)):
            vertical_creases.append(c)
    for r in range(height):
        if all(input_grid[r][c] == 2 for c in range(width)):
            horizontal_creases.append(r)
    
    if vertical_creases:
        k = vertical_creases[0]
        crease_type = 'vertical'
    elif horizontal_creases:
        k = horizontal_creases[0]
        crease_type = 'horizontal'
    else:
        return input_grid
    
    output_grid = [list(row) for row in input_grid]
    
    if crease_type == 'vertical':
        for r in range(height):
            for c in range(k):
                if input_grid[r][c] == 1:
                    mirror_c = 2*k - c
                    if 0 <= mirror_c < width:
                        output_grid[r][mirror_c] = 1
    else:
        for c in range(width):
            for r in range(k):
                if input_grid[r][c] == 1:
                    mirror_r = 2*k - r
                    if 0 <= mirror_r < height:
                        output_grid[mirror_r][c] = 1
    
    dots = []
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] == 1:
                dots.append((r, c))
    dots.sort(key=lambda x: (x[0], x[1]))
    
    for i in range(len(dots) - 1):
        r1, c1 = dots[i]
        r2, c2 = dots[i+1]
        for c in range(min(c1, c2) + 1, max(c1, c2)):
            output_grid[r1][c] = 3
        for r in range(min(r1, r2) + 1, max(r1, r2)):
            output_grid[r][c2] = 3
    
    for r, c in dots:
        output_grid[r][c] = 1
    
    return output_grid
