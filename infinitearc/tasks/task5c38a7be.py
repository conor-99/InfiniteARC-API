# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 5c38a7be
Difficulty: hard

=== Tags ===
- Mirror pairing
- Proximity guessing
- Divide by n
- Pattern deconstruction

=== Description ===
The task involves transforming an input grid by first identifying vertical
mirror pairs across the grid's central axis. For each cell in the left half
(columns < width/2), if its vertically mirrored counterpart (same row, column =
width-1-c) has an identical value, the cell retains its original value. If the
mirror cell's value differs, the cell's value is replaced by the most frequent
non-zero neighbor value from its four adjacent cells (up, down, left, right),
with ties resolved by selecting the smallest value. The output grid is formed by
deconstructing the input into its left half (width/2), effectively dividing the
grid's width by 2 (n=2), while resolving mirror discrepancies through proximity-
based neighbor analysis. This process combines mirror pairing verification,
proximity-based value guessing, grid division by n, and pattern deconstruction
into a single consistent rule.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.choice([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30])
    height = random.randint(1, 30)
    input_grid = grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            input_grid[r][c] = random.randint(0,9)
    output_grid = grid(width//2, height, 0)
    for r in range(height):
        for c in range(width//2):
            mirror_c = width - 1 - c
            if input_grid[r][c] == input_grid[r][mirror_c]:
                output_grid[r][c] = input_grid[r][c]
            else:
                neighbors = []
                for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0:
                        neighbors.append(input_grid[nr][nc])
                if not neighbors:
                    output_grid[r][c] = 0
                else:
                    freq = {}
                    for val in neighbors:
                        freq[val] = freq.get(val, 0) + 1
                    max_count = max(freq.values())
                    candidates = [k for k, v in freq.items() if v == max_count]
                    output_grid[r][c] = min(candidates)
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid
def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = grid(width//2, height, 0)
    for r in range(height):
        for c in range(width//2):
            mirror_c = width - 1 - c
            if input_grid[r][c] == input_grid[r][mirror_c]:
                output_grid[r][c] = input_grid[r][c]
            else:
                neighbors = []
                for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0:
                        neighbors.append(input_grid[nr][nc])
                if not neighbors:
                    output_grid[r][c] = 0
                else:
                    freq = {}
                    for val in neighbors:
                        freq[val] = freq.get(val, 0) + 1
                    max_count = max(freq.values())
                    candidates = [k for k, v in freq.items() if v == max_count]
                    output_grid[r][c] = min(candidates)
    return output_grid
