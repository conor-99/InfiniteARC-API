# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: b383615e
Difficulty: insane

=== Tags ===
- Gravity
- Hollow shape detection
- Energy loss per bounce
- Inverse rule reconstruction
- Count different colors

=== Description ===
Input grids feature multiple irregularly shaped hollow structures (each with a
contiguous border and empty interior) positioned at varying heights across a
grid with background color. Gravity pulls all structures downward until they
contact the grid's bottom or other structures, causing them to stabilize. For
each hollow structure, the border pixels (perimeter cells) are analyzed to count
the number of distinct colors present. This count determines the number of
bounces the structure undergoes upon contact with a fixed obstacle (e.g., grid
boundary or another structure), with each bounce causing an energy loss: the
border color decreases by 1 (modulo 10, wrapping from 0 to 9). The output grid
displays all structures after completing all bounces, with their border colors
adjusted according to the energy loss rule. Hollow shapes must be identified by
detecting contiguous border pixels with empty interiors (no non-background
pixels inside the border), and the transformation requires inverting the
observed color change pattern (e.g., if output color = input color - count, the
solver must reconstruct this inverse rule from the examples). The count of
distinct border colors is critical for determining the bounce count, and the
rules must be applied simultaneously across all structures, with complex shapes
requiring careful border detection. No two structures overlap, and all
background cells remain unchanged except for the border color adjustments of
hollow structures.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random
from typing import List, Tuple, Dict

# Generator for ARC task: hollow ring shapes fall under gravity and lose color energy

def _make_ring(w: int, h: int) -> List[Tuple[int,int]]:
    """Create coordinates of a 1-pixel-thick rectangular ring of size w x h.
    Coordinates are given in local sprite space with top-left (0,0).
    Both w and h must be >= 3.
    """
    coords = []
    for r in range(h):
        for c in range(w):
            if r == 0 or r == h-1 or c == 0 or c == w-1:
                coords.append((r, c))
    return coords


def _simulate_fall(shapes: List[Dict], width: int, height: int):
    """Simulate synchronous gravity for a list of shapes.
    Each shape is a dict with keys: 'cells' -> list of (r,c,color), 'id' -> int.
    The function updates shapes in-place moving them down until stable.
    """
    # build position map: (r,c) -> shape_id
    pos_map = {}
    for s in shapes:
        for (r, c, color) in s['cells']:
            pos_map[(r, c)] = s['id']

    # helper to compute if a shape can move given current pos_map (with recursion)
    from functools import lru_cache

    def can_move_shape(sid, visiting=None):
        if visiting is None:
            visiting = set()
        if sid in visiting:
            return False
        visiting.add(sid)
        s = shapes[sid]
        for (r, c, _) in s['cells']:
            nr = r + 1
            if nr >= height:
                visiting.remove(sid)
                return False
            occupant = pos_map.get((nr, c), None)
            if occupant is None:
                continue
            if occupant == sid:
                continue
            # occupant is another shape; that shape must be able to move as well
            if not can_move_shape(occupant, visiting):
                visiting.remove(sid)
                return False
        visiting.remove(sid)
        return True

    # iterate until no shape can move
    while True:
        movable = [False] * len(shapes)
        memo = {}
        # compute movability with memoization using the recursive helper
        def can_move_cached(sid):
            if sid in memo:
                return memo[sid]
            res = can_move_shape(sid, set())
            memo[sid] = res
            return res

        for s in shapes:
            movable[s['id']] = can_move_cached(s['id'])

        if not any(movable):
            break

        # move all movable shapes down by 1 (simultaneously)
        for s in shapes:
            if movable[s['id']]:
                s['cells'] = [(r+1, c, color) for (r, c, color) in s['cells']]
        # rebuild pos_map
        pos_map = {}
        for s in shapes:
            for (r, c, color) in s['cells']:
                pos_map[(r, c)] = s['id']

    # shapes updated in-place
    return


def generate() -> dict:
    # We'll try multiple times if we accidentally produce identical input/output
    for attempt in range(1000):
        # grid size: keep reasonably large to allow several shapes
        width = random.randint(6, 20)
        height = random.randint(6, 20)
        bg = 0
        input_grid = common.grid(width, height, bg)

        # number of hollow structures
        num_structures = random.randint(1, min(4, max(1, width // 3)))

        shapes = []  # will store dicts with local cells and offsets
        used_columns = set()

        # place shapes left-to-right without horizontal overlap (at least 1 col gap)
        for sid in range(num_structures):
            placed = False
            for _ in range(200):
                sprite_w = random.randint(3, min(8, width - 2))
                sprite_h = random.randint(3, min(8, height - 3))
                # choose column offset ensuring at least one column gap from existing shapes
                c_offset = random.randint(1, max(1, width - sprite_w - 1))

                new_cols = set(range(c_offset, c_offset + sprite_w))
                neighbor_conflict = False
                for col in new_cols:
                    if col in used_columns or (col-1) in used_columns or (col+1) in used_columns:
                        neighbor_conflict = True
                        break
                if neighbor_conflict:
                    continue

                # choose a vertical offset such that shape is somewhere above bottom so it can fall
                max_r_offset = max(0, height - sprite_h - 1)
                r_offset = random.randint(0, max_r_offset)

                # create ring coordinates
                local_coords = _make_ring(sprite_w, sprite_h)
                world_coords = [(r + r_offset, c + c_offset) for (r, c) in local_coords]

                # ensure all world_coords inside grid and do not intersect already placed shapes
                conflict = False
                for (wr, wc) in world_coords:
                    if wr < 0 or wr >= height or wc < 0 or wc >= width:
                        conflict = True
                        break
                    if input_grid[wr][wc] != bg:
                        conflict = True
                        break
                if conflict:
                    continue

                # assign random colors to border pixels; allow duplicates
                colors = [random.randint(1, 9) for _ in world_coords]
                shape = {
                    'id': len(shapes),
                    'cells': [(wr, wc, col) for (wr, wc), col in zip(world_coords, colors)],
                }
                shapes.append(shape)
                for col in new_cols:
                    used_columns.add(col)
                placed = True
                break
            if not placed:
                break

        if len(shapes) == 0:
            continue

        # write shapes into input grid
        for s in shapes:
            for (r, c, color) in s['cells']:
                input_grid[r][c] = color

        # simulate gravity to compute final positions
        sim_shapes = []
        for s in shapes:
            sim_shapes.append({'id': s['id'], 'cells': list(s['cells'])})
        _simulate_fall(sim_shapes, width, height)

        # build output grid: border colors reduced by the number of distinct colors on that shape's border
        output_grid = common.grid(width, height, bg)
        for s in sim_shapes:
            distinct = len(set([color for (_, _, color) in s['cells']]))
            for (r, c, color) in s['cells']:
                new_color = (color - distinct) % 10
                output_grid[r][c] = new_color

        # ensure input != output
        if input_grid == output_grid:
            continue

        return {'input': input_grid, 'output': output_grid}

    # fallback (shouldn't happen)
    raise RuntimeError('Failed to generate a valid example after many attempts')



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    bg = 0

    # find connected components of non-background pixels (4-connected)
    visited = [[False] * width for _ in range(height)]
    components = []  # list of dicts: {'cells': [(r,c,color)], 'id': idx}

    for r in range(height):
        for c in range(width):
            if grid[r][c] != bg and not visited[r][c]:
                # BFS
                q = [(r, c)]
                visited[r][c] = True
                cells = []
                while q:
                    rr, cc = q.pop(0)
                    cells.append((rr, cc, grid[rr][cc]))
                    for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                        nr, nc = rr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] != bg:
                            visited[nr][nc] = True
                            q.append((nr, nc))
                components.append({'id': len(components), 'cells': cells})

    # helper: simulate synchronous gravity (same logic as generator)
    def _simulate_fall(components):
        # build pos map
        pos_map = {}
        for s in components:
            for (r, c, _) in s['cells']:
                pos_map[(r, c)] = s['id']

        from functools import lru_cache

        def can_move_shape(sid, visiting=None):
            if visiting is None:
                visiting = set()
            if sid in visiting:
                return False
            visiting.add(sid)
            s = components[sid]
            for (r, c, _) in s['cells']:
                nr = r + 1
                if nr >= height:
                    visiting.remove(sid)
                    return False
                occupant = pos_map.get((nr, c), None)
                if occupant is None:
                    continue
                if occupant == sid:
                    continue
                if not can_move_shape(occupant, visiting):
                    visiting.remove(sid)
                    return False
            visiting.remove(sid)
            return True

        while True:
            movable = [False] * len(components)
            memo = {}
            def can_move_cached(sid):
                if sid in memo:
                    return memo[sid]
                res = can_move_shape(sid, set())
                memo[sid] = res
                return res
            for s in components:
                movable[s['id']] = can_move_cached(s['id'])
            if not any(movable):
                break
            # move all movable shapes down by 1
            for s in components:
                if movable[s['id']]:
                    s['cells'] = [(r+1, c, color) for (r, c, color) in s['cells']]
            # rebuild pos_map
            pos_map = {}
            for s in components:
                for (r, c, _) in s['cells']:
                    pos_map[(r, c)] = s['id']
        return

    _simulate_fall(components)

    # build output grid and apply color reduction
    output = [[bg for _ in range(width)] for _ in range(height)]
    for s in components:
        distinct = len(set([color for (_, _, color) in s['cells']]))
        for (r, c, color) in s['cells']:
            output[r][c] = (color - distinct) % 10

    return output

