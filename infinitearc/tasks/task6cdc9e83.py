# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 6cdc9e83
Difficulty: hard

=== Tags ===
- Implicit topology
- One yes one no

=== Description ===
Input grids feature a background of color 0 with multiple distinct non-
background colors (1-9) forming connected regions. Each region may enclose one
or more "holes" â€“ background areas completely surrounded by the region, where no
background pixel in the hole is adjacent to the grid's edge. The output grid
retains all original colors except that every hole enclosed by any region is
filled with color 9 (maroon). Regions without holes remain unchanged. This
transformation is determined by the topological property of whether a region
encloses a background hole ("yes" for regions with holes, "no" for regions
without holes), with only enclosed holes being filled. The solution requires
identifying connected components, detecting enclosed background regions through
spatial connectivity checks, and applying the fill transformation exclusively to
those enclosed areas.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    width = common.randint(5, 30)
    height = common.randint(5, 30)
    grid = common.grid(width, height, 0)
    
    frame_w = common.randint(3, min(10, width - 2))
    frame_h = common.randint(3, min(10, height - 2))
    
    r = common.randint(1, height - frame_h - 1)
    c = common.randint(1, width - frame_w - 1)
    
    color_A = common.randint(1, 8)
    for col in range(c, c + frame_w):
        grid[r][col] = color_A
        grid[r + frame_h - 1][col] = color_A
    for row in range(r + 1, r + frame_h - 1):
        grid[row][c] = color_A
        grid[row][c + frame_w - 1] = color_A
    
    color_B = common.randint(1, 8)
    while color_B == color_A:
        color_B = common.randint(1, 8)
    for col in range(width):
        grid[0][col] = color_B
    
    output_grid = [row[:] for row in grid]
    for row in range(r + 1, r + frame_h - 1):
        for col in range(c + 1, c + frame_w - 1):
            output_grid[row][col] = 9
    
    return {
        "input": grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])
    
    visited = [[False] * w for _ in range(h)]
    q = deque()
    
    for i in range(w):
        if grid[0][i] == 0 and not visited[0][i]:
            visited[0][i] = True
            q.append((0, i))
        if grid[h-1][i] == 0 and not visited[h-1][i]:
            visited[h-1][i] = True
            q.append((h-1, i))
    for j in range(h):
        if grid[j][0] == 0 and not visited[j][0]:
            visited[j][0] = True
            q.append((j, 0))
        if grid[j][w-1] == 0 and not visited[j][w-1]:
            visited[j][w-1] = True
            q.append((j, w-1))
    
    while q:
        r, c = q.popleft()
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] == 0:
                visited[nr][nc] = True
                q.append((nr, nc))
    
    for r in range(h):
        for c in range(w):
            if grid[r][c] == 0 and not visited[r][c]:
                grid[r][c] = 9
    
    return tuple(tuple(row) for row in grid)
