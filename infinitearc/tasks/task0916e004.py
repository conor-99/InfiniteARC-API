# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 0916e004
Difficulty: insane

=== Tags ===
- Pattern modification
- Associate colors to colors
- Out of boundary

=== Description ===
Input grids display a primary pattern of colored regions (1-8) on a background
(0), with a secondary "resonance sequence" embedded in the top-right corner as a
2x2 color block. This sequence defines a repeating color cycle (e.g., [2,5,7,9])
that extends infinitely beyond the grid boundaries. Each cell (r,c) in the grid
has a resonance index calculated as (r + c) mod 4 (sequence length), determining
its position in the cycle.  The transformation applies two consistent rules: 1.
**Color Association**: Each color in the input grid maps to a fixed target color
(e.g., 1→4, 2→7, 3→9, 4→2, 5→5, etc.), forming a deterministic substitution
table. 2. **Boundary Resonance Shift**: The associated color is shifted along
the resonance sequence by the resonance index. For example, if a cell's
associated color is 5 and its resonance index points to position 2 in [2,5,7,9],
the new color is the sequence element at (index + associated color index) mod 4
(e.g., 5 corresponds to index 1 in [2,5,7,9], so (1 + 2) mod 4 = 3 → color 9).
The "out of boundary" aspect is inherent in the resonance sequence's infinite
repetition: cells near grid edges use the sequence's cyclic nature to determine
shifts, requiring the solver to recognize the sequence's position relative to
the grid's edges without explicit boundary handling. Output grids maintain all
structural features of the input pattern while modifying colors according to the
dual transformation rules. The task demands identifying the resonance sequence
from a small grid section, applying the color substitution, and resolving the
cyclic shift based on positional resonance.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    substitution_table = {1: 4, 2: 7, 3: 9, 4: 2, 5: 5, 6: 8, 7: 1, 8: 3}
    while True:
        width = random.randint(2, 30)
        height = random.randint(2, 30)
        input_grid = [[0] * width for _ in range(height)]
        seq = [random.randint(1, 9) for _ in range(4)]
        input_grid[0][width-2] = seq[0]
        input_grid[0][width-1] = seq[1]
        input_grid[1][width-2] = seq[2]
        input_grid[1][width-1] = seq[3]
        for r in range(height):
            for c in range(width):
                if (r, c) in [(0, width-2), (0, width-1), (1, width-2), (1, width-1)]:
                    continue
                if random.random() > 0.7:
                    input_grid[r][c] = random.randint(1, 8)
        output_grid = [[0] * width for _ in range(height)]
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == 0:
                    output_grid[r][c] = 0
                else:
                    sub_color = substitution_table.get(input_grid[r][c], input_grid[r][c])
                    try:
                        pos = seq.index(sub_color)
                    except ValueError:
                        pos = 0
                    new_index = ((r + c) % 4 + pos) % 4
                    output_grid[r][c] = seq[new_index]
        if input_grid != output_grid:
            return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    seq = [
        input_grid[0][width-2],
        input_grid[0][width-1],
        input_grid[1][width-2],
        input_grid[1][width-1]
    ]
    substitution_table = {1: 4, 2: 7, 3: 9, 4: 2, 5: 5, 6: 8, 7: 1, 8: 3}
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                output_grid[r][c] = 0
            else:
                sub_color = substitution_table.get(input_grid[r][c], input_grid[r][c])
                try:
                    pos = seq.index(sub_color)
                except ValueError:
                    pos = 0
                new_index = ((r + c) % 4 + pos) % 4
                output_grid[r][c] = seq[new_index]
    return output_grid
