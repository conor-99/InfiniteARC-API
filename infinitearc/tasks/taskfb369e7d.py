# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: fb369e7d
Difficulty: hard

=== Tags ===
- Truth table visualization
- Progressive rule shift
- Detect background color

=== Description ===
Input grids feature a single background color (e.g., gray) with a 2×2 truth
table visualization in the top-left corner, where each cell's color represents
the output of a logical operation (e.g., AND, XOR, OR) for all combinations of
two binary inputs. The truth table uses two distinct foreground colors (e.g.,
red for "true" and blue for "false") to visually encode the operation. The rest
of the grid contains multiple disconnected, non-overlapping colored shapes (each
shape is a contiguous region of a single color), with shapes larger than 2×2 and
no two shapes overlapping. The output grid transforms each shape's color based
on the truth table's operation, applying a progressive rule shift: for each row
in the grid, the transformation rule cycles through a fixed sequence of logical
operations (e.g., AND → XOR → OR → NOT), with the rule for row *i* determined by
*i mod 4*. The background color remains unchanged, and shapes retain their
positions and dimensions. The transformation uses the truth table's visual
pattern to map input colors to output colors (e.g., if the truth table
represents XOR and a shape's color corresponds to "true" in the table's output
for its input, the output color is red; otherwise, blue), with the rule sequence
shifting per row to create a dynamic, non-uniform transformation across the
grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, rand_sprite

def get_truth_table(op):
    if op == 'AND':
        return [[1, 1], [1, 2]]
    elif op == 'XOR':
        return [[1, 2], [2, 1]]
    elif op == 'OR':
        return [[1, 2], [2, 2]]
    elif op == 'NOT':
        return [[2, 2], [1, 1]]

def generate():
    operations = ['AND', 'XOR', 'OR', 'NOT']
    op = random.choice(operations)
    truth_table = get_truth_table(op)
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = grid(width, height, 5)
    for r in range(2):
        for c in range(2):
            input_grid[r][c] = truth_table[r][c]
    shapes = []
    colors = [1, 2]
    num_shapes = random.randint(2, 4)
    shape_names = ['el', 'you', 'aitch']
    for _ in range(num_shapes):
        color = random.choice(colors)
        shape_name = random.choice(shape_names)
        pixels = rand_sprite(shape_name, width, height)
        shifted_pixels = [(r + 2, c + 2) for (r, c) in pixels]
        if any(r >= height or c >= width for (r, c) in shifted_pixels):
            continue
        overlap = False
        for existing_pixels, _ in shapes:
            if any(p in existing_pixels for p in shifted_pixels):
                overlap = True
                break
        if overlap:
            continue
        shapes.append((shifted_pixels, color))
        for r, c in shifted_pixels:
            input_grid[r][c] = color
    output_grid = [row[:] for row in input_grid]
    for r in range(height):
        current_op = operations[r % 4]
        for c in range(width):
            if input_grid[r][c] in [1, 2]:
                if current_op == 'XOR' or current_op == 'NOT':
                    output_grid[r][c] = 2 if input_grid[r][c] == 1 else 1
                elif current_op == 'OR':
                    output_grid[r][c] = 2
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    # Ensure input_grid is list of lists
    if input_grid and isinstance(input_grid[0], tuple):
        input_grid = [list(row) for row in input_grid]
    color_count = {}
    for row in input_grid:
        for color in row:
            color_count[color] = color_count.get(color, 0) + 1
    background_color = max(color_count, key=color_count.get)
    truth_table = [
        [input_grid[0][0], input_grid[0][1]],
        [input_grid[1][0], input_grid[1][1]]
    ]
    if truth_table == [[1, 1], [1, 2]]:
        op = 'AND'
    elif truth_table == [[1, 2], [2, 1]]:
        op = 'XOR'
    elif truth_table == [[1, 2], [2, 2]]:
        op = 'OR'
    elif truth_table == [[2, 2], [1, 1]]:
        op = 'NOT'
    else:
        op = 'XOR'
    output_grid = [row[:] for row in input_grid]
    operations = ['AND', 'XOR', 'OR', 'NOT']
    height = len(input_grid)
    for r in range(height):
        current_op = operations[r % 4]
        for c in range(len(input_grid[0])):
            if input_grid[r][c] != background_color and input_grid[r][c] in [1, 2]:
                if current_op == 'XOR' or current_op == 'NOT':
                    output_grid[r][c] = 2 if input_grid[r][c] == 1 else 1
                elif current_op == 'OR':
                    output_grid[r][c] = 2
    return output_grid
