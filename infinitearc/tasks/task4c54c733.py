# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 4c54c733
Difficulty: very hard

=== Tags ===
- Mask based logic
- Grid topology inference
- Chain reaction
- Sequence interpolation
- Count tiles

=== Description ===
Masked Cascade Path  Input grids display a 15×15 grid composed of a 5×5
arrangement of uniform 3×3 tiles, each tile maintaining a single solid color
(1-8). A distinct mask color (9) defines a non-linear, connected path through
the tile grid, forming a complex trajectory such as a spiral or zig-zag that
traverses multiple tiles. Along this mask path, some tiles display the mask
color (indicating missing values), while others exhibit a repeating visual
sequence of colors (e.g., alternating red and blue tiles). The grid topology
must be inferred to trace the complete path, as the mask path may twist or
branch. The sequence pattern is identified by observing the consistent color
transitions between non-mask tiles along the path (e.g., red → green → blue →
red). The chain reaction propagates this sequence: each missing mask tile is
replaced with the next color in the inferred cycle, with interpolation requiring
consistent application along the entire path. The count of tiles in the mask
path determines the cycle length (e.g., a 7-tile path implies a 7-color cycle),
and the output grid updates all mask path tiles with the interpolated sequence
while preserving all non-path tiles and the mask's structural path. This
requires simultaneous inference of path topology, sequence pattern, and cycle
length, with no visible numerical operations or pixel-level matching.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, all_pixels, grid_enhance

def generate():
    width, height = 15, 15
    grid_size = 5
    tile_size = 3
    """Generates a 15x15 grid with a path of 3x3 tiles."""
    # Create empty grid
    inp = grid(width, height, 0)
    # Generate path in tile grid (5x5)
    path = []
    current = (random.randint(0, grid_size-1), random.randint(0, grid_size-1))
    path.append(current)
    for _ in range(random.randint(5, 25)):
        neighbors = []
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = current[0]+dr, current[1]+dc
            if 0 <= nr < grid_size and 0 <= nc < grid_size and (nr, nc) not in path:
                neighbors.append((nr, nc))
        if not neighbors:
            break
        next_tile = random.choice(neighbors)
        path.append(next_tile)
        current = next_tile
    N = len(path)
    # Generate cycle of N colors (1-8)
    cycle = [random.randint(1, 8) for _ in range(N)]
    # Choose contiguous non-mask segment
    S = random.randint(0, N-1)
    L = random.randint(1, min(3, N - S))
    # Set non-mask tiles
    for i, (r, c) in enumerate(path):
        if S <= i < S+L:
            color = cycle[i]
        else:
            color = 9  # mask
        # Fill 3x3 tile
        for tr in range(tile_size):
            for tc in range(tile_size):
                inp[r*tile_size + tr][c*tile_size + tc] = color
    # Fill non-path tiles with random colors (1-8)
    for r in range(grid_size):
        for c in range(grid_size):
            if (r, c) not in path:
                color = random.randint(1, 8)
                for tr in range(tile_size):
                    for tc in range(tile_size):
                        inp[r*tile_size + tr][c*tile_size + tc] = color
    return {"input": inp, "output": compute_output(inp)}

def compute_output(inp):
    width, height = 15, 15
    tile_size = 3
    grid_size = 5
    # Copy input to output
    out = [row[:] for row in inp]
    # Find path tiles
    path = []
    for r in range(grid_size):
        for c in range(grid_size):
            # Check if tile contains non-zero (not background) and mask
            tile_color = inp[r*tile_size][c*tile_size]
            if tile_color != 0:
                path.append((r, c))
    # Sort path to get order
    path = sort_path(path, inp)
    N = len(path)
    # Get cycle from non-mask tiles
    cycle = [None] * N
    for i, (r, c) in enumerate(path):
        color = inp[r*tile_size][c*tile_size]
        if color != 9:
            cycle[i] = color
    # Fill in cycle
    for i in range(N):
        if cycle[i] is None:
            # Find closest non-mask tile
            j = i-1
            while j >= 0 and cycle[j] is None:
                j -= 1
            if j >= 0:
                cycle[i] = cycle[j]
            else:
                j = i+1
                while j < N and cycle[j] is None:
                    j += 1
                if j < N:
                    cycle[i] = cycle[j]
    # Apply cycle to output
    for i, (r, c) in enumerate(path):
        for tr in range(tile_size):
            for tc in range(tile_size):
                out[r*tile_size + tr][c*tile_size + tc] = cycle[i]
    return out

def sort_path(path, inp):
    # Simple path ordering (not perfect, but works for this task)
    start = path[0]
    ordered = [start]
    current = start
    while len(ordered) < len(path):
        found = False
        for neighbor in [(current[0]+1, current[1]), (current[0]-1, current[1]), (current[0], current[1]+1), (current[0], current[1]-1)]:
            if neighbor in path and neighbor not in ordered:
                ordered.append(neighbor)
                current = neighbor
                found = True
                break
        if not found:
            break
    return ordered


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import numpy as np
from common import grid

def p(inp):
    width, height = len(inp[0]), len(inp)
    tile_size = 3
    grid_size = 5
    # Find path tiles
    path = []
    for r in range(grid_size):
        for c in range(grid_size):
            # Check if tile contains non-zero (not background)
            if inp[r*tile_size][c*tile_size] != 0:
                path.append((r, c))
    # Sort path to get order
    path = sort_path(path, inp)
    N = len(path)
    # Get cycle
    cycle = [None] * N
    for i, (r, c) in enumerate(path):
        color = inp[r*tile_size][c*tile_size]
        if color != 9:
            cycle[i] = color
    # Fill cycle
    for i in range(N):
        if cycle[i] is None:
            # Find nearest non-mask
            j = i-1
            while j >= 0 and cycle[j] is None:
                j -= 1
            if j >= 0:
                cycle[i] = cycle[j]
            else:
                j = i+1
                while j < N and cycle[j] is None:
                    j += 1
                if j < N:
                    cycle[i] = cycle[j]
    # Create output grid
    out = grid(width, height, 0)
    for r in range(grid_size):
        for c in range(grid_size):
            if (r, c) in path:
                idx = path.index((r, c))
                color = cycle[idx]
                for tr in range(tile_size):
                    for tc in range(tile_size):
                        out[r*tile_size + tr][c*tile_size + tc] = color
            else:
                # Non-path tiles stay as input
                for tr in range(tile_size):
                    for tc in range(tile_size):
                        out[r*tile_size + tr][c*tile_size + tc] = inp[r*tile_size + tr][c*tile_size + tc]
    return out

def sort_path(path, inp):
    # Simple path ordering
    start = path[0]
    ordered = [start]
    current = start
    while len(ordered) < len(path):
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = current[0]+dr, current[1]+dc
            if (nr, nc) in path and (nr, nc) not in ordered:
                ordered.append((nr, nc))
                current = (nr, nc)
                break
        else:
            break
    return ordered
