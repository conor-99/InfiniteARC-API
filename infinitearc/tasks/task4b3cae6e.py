# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 4b3cae6e
Difficulty: medium–hard

=== Tags ===
- Local rule cascade
- Refraction simulation
- Analogical goal mapping

=== Description ===
**Task Description: Refractive Pathway Cascade**    Input grids are medium to
large (15×15 to 25×25) with a uniform background color (0). Overlaid on this
background are scattered *refractor cells*—each a single cell of color 1–9,
arranged to form a contiguous sequence of directional bends. Each refractor
color encodes a unique *local refraction rule*:   - **Color 1 (blue)**: Beam
bends 45° counterclockwise (e.g., east → northeast).   - **Color 2 (green)**:
Beam bends 45° clockwise (e.g., east → southeast).   - **Color 3 (red)**: Beam
reverses direction (e.g., east → west).   - **Color 4 (yellow)**: Beam continues
straight (no change).   - *Colors 5–9*: Alternate rules (e.g., color 5: 90° left
turn; color 6: 90° right turn).    A *beam starter* is placed on the left edge
(column 0, any row), moving east (rightward). The beam travels cell-by-cell in
its current direction, **overwriting only background cells** (never refractors
or other beams). Upon entering a refractor cell:   1. The beam’s current color
changes to the refractor’s color.   2. The beam’s direction updates per the
refractor’s rule.   3. The beam exits the refractor cell and continues in the
new direction.    The output grid retains all input refractors unchanged but
draws the beam’s **entire path** using its current color at each segment. The
path terminates when the beam exits the grid (no loops or self-intersections).
**Key Complexity**:   - Refractors are arranged to create a *cascade* of
directional changes (e.g., blue → green → red), where each step depends on the
previous color/direction.   - Color transitions must be tracked sequentially
(e.g., a red refractor changes the color to 3, which then affects subsequent
bends).   - The beam’s path must avoid refractors (only bends *at* them, never
overwrites), and no two paths overlap.    **Visual Cues**:   - Refractors are
visually distinct (e.g., blue cells form a diagonal pattern, red cells are
isolated).   - The beam path appears as a continuous line of *current color*
cells, with color shifts at refractors.   - Output paths are *analogous* to the
input refractor arrangement (e.g., a sequence of blue-green refractors creates a
zigzag path mirroring their directional order).
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Directions in clockwise order starting from East
DIRS = [(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1),(-1,0),(-1,1)]
DIR_TO_INDEX = {d:i for i,d in enumerate(DIRS)}
# Rotation steps in units of 45 degrees (positive = clockwise)
ROT_STEPS = {1:-1, 2:1, 3:4, 4:0, 5:-2, 6:2, 7:3, 8:-3, 9:4}


def update_direction(current_dir, color):
    if current_dir not in DIR_TO_INDEX:
        dr, dc = current_dir
        dr = 0 if dr == 0 else (1 if dr > 0 else -1)
        dc = 0 if dc == 0 else (1 if dc > 0 else -1)
        current_dir = (dr, dc)
    idx = DIR_TO_INDEX[current_dir]
    step = ROT_STEPS.get(color, 0)
    new_idx = (idx + step) % 8
    return DIRS[new_idx]


def in_bounds(pos, width, height):
    r, c = pos
    return 0 <= r < height and 0 <= c < width


def add(pos, d, k=1):
    return (pos[0] + d[0] * k, pos[1] + d[1] * k)


def build_path_adjacent(width, height, start_row, length):
    """Build a simple path of adjacent refractor positions (distance 1) without intersections.

    The first refractor is fixed at (start_row, 1). We avoid placing other refractors in column 1
    to ensure the solver can uniquely identify the starter.
    Returns (positions_list, exit_dir) or None if it fails.
    """
    attempts = 0
    while attempts < 60:
        attempts += 1
        used = set()
        used.add((start_row, 0))  # starter cell
        positions = []
        pos = (start_row, 1)
        positions.append(pos)
        used.add(pos)
        # Greedily extend the path by picking a random valid adjacent neighbor at each step
        ok = True
        for _ in range(1, length):
            candidates = []
            for d in DIRS:
                np = add(pos, d)
                if not in_bounds(np, width, height):
                    continue
                if np in used:
                    continue
                # do not place any other refractor on column 0 or column 1
                if np[1] == 0 or np[1] == 1:
                    continue
                # also prevent immediate backtrack
                if len(positions) >= 2 and np == positions[-2]:
                    continue
                candidates.append(d)
            if not candidates:
                ok = False
                break
            d = random.choice(candidates)
            pos = add(pos, d)
            positions.append(pos)
            used.add(pos)
        if not ok:
            continue
        # choose an exit direction from the last position such that the ray to the border doesn't hit used cells
        last = positions[-1]
        exit_dirs = DIRS[:]
        random.shuffle(exit_dirs)
        found_exit = None
        for d in exit_dirs:
            rr, cc = last[0] + d[0], last[1] + d[1]
            blocked = False
            while 0 <= rr < height and 0 <= cc < width:
                if (rr, cc) in used:
                    blocked = True
                    break
                rr += d[0]
                cc += d[1]
            if not blocked:
                found_exit = d
                break
        if found_exit is None:
            continue
        return positions, found_exit
    return None


def generate():
    # We'll attempt a number of times; building an adjacent path is fast and should succeed quickly
    for attempt in range(200):
        width = random.randint(15, 25)
        height = random.randint(15, 25)
        start_row = random.randint(1, max(1, height - 2))
        length = random.randint(4, min(10, (width + height) // 6 + 3))
        built = build_path_adjacent(width, height, start_row, length)
        if built is None:
            continue
        positions, exit_dir = built
        # compute colors so that the beam will follow the path
        colors = []
        for i, pos in enumerate(positions):
            if i == 0:
                prev_dir = (0, 1)
            else:
                prev_dir = (pos[0] - positions[i - 1][0], pos[1] - positions[i - 1][1])
            if i < len(positions) - 1:
                desired_dir = (positions[i + 1][0] - pos[0], positions[i + 1][1] - pos[1])
            else:
                desired_dir = exit_dir
            # normalize to canonical direction
            if desired_dir not in DIR_TO_INDEX:
                dr, dc = desired_dir
                dr = 0 if dr == 0 else (1 if dr > 0 else -1)
                dc = 0 if dc == 0 else (1 if dc > 0 else -1)
                desired_dir = (dr, dc)
            if prev_dir not in DIR_TO_INDEX:
                dr, dc = prev_dir
                dr = 0 if dr == 0 else (1 if dr > 0 else -1)
                dc = 0 if dc == 0 else (1 if dc > 0 else -1)
                prev_dir = (dr, dc)
            idx_prev = DIR_TO_INDEX[prev_dir]
            idx_des = DIR_TO_INDEX[desired_dir]
            delta = (idx_des - idx_prev) % 8
            # find a color that produces this rotation
            candidate = None
            for col, step in ROT_STEPS.items():
                if (step % 8) == delta:
                    candidate = col
                    break
            if candidate is None:
                candidate = 4
            colors.append(candidate)
        # build the input grid
        ingrid = grid(width, height, 0)
        for pos, col in zip(positions, colors):
            ingrid[pos[0]][pos[1]] = col
        # simulate beam to make output
        output = [row[:] for row in ingrid]
        current_color = 4
        current_dir = (0, 1)
        r, c = start_row, 0
        output[r][c] = current_color
        steps = 0
        while True:
            steps += 1
            dr, dc = current_dir
            nr, nc = r + dr, c + dc
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                break
            if ingrid[nr][nc] != 0:
                current_color = ingrid[nr][nc]
                current_dir = update_direction(current_dir, current_color)
            else:
                output[nr][nc] = current_color
            r, c = nr, nc
            if steps > width * height * 2:
                break
        return {"input": ingrid, "output": output}

    # fallback (very unlikely)
    width, height = 15, 15
    start_row = height // 2
    ingrid = grid(width, height, 0)
    ingrid[start_row][1] = 1
    output = [row[:] for row in ingrid]
    current_color = 4
    current_dir = (0, 1)
    r, c = start_row, 0
    output[r][c] = current_color
    while True:
        dr, dc = current_dir
        nr, nc = r + dr, c + dc
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        if ingrid[nr][nc] != 0:
            current_color = ingrid[nr][nc]
            current_dir = update_direction(current_dir, current_color)
        else:
            output[nr][nc] = current_color
        r, c = nr, nc
    return {"input": ingrid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Reconstruct the update rules (must match the generator)
    DIRS = [(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1),(-1,0),(-1,1)]
    DIR_TO_INDEX = {d:i for i,d in enumerate(DIRS)}
    ROT_STEPS = {1:-1, 2:1, 3:4, 4:0, 5:-2, 6:2, 7:3, 8:-3, 9:4}

    def update_direction(current_dir, color):
        if current_dir not in DIR_TO_INDEX:
            dr, dc = current_dir
            dr = 0 if dr == 0 else (1 if dr > 0 else -1)
            dc = 0 if dc == 0 else (1 if dc > 0 else -1)
            current_dir = (dr, dc)
        idx = DIR_TO_INDEX[current_dir]
        step = ROT_STEPS.get(color, 0)
        new_idx = (idx + step) % 8
        return DIRS[new_idx]

    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])

    # Find the start row: the row where column 1 contains a refractor and column 0 is background.
    start_row = None
    for r in range(height):
        if grid_in[r][1] != 0 and grid_in[r][0] == 0:
            start_row = r
            break
    if start_row is None:
        for r in range(height):
            if grid_in[r][1] != 0:
                start_row = r
                break
    if start_row is None:
        return tuple(tuple(row) for row in grid_in)

    output = [row[:] for row in grid_in]
    current_color = 4
    current_dir = (0, 1)
    r, c = start_row, 0
    output[r][c] = current_color

    steps = 0
    while True:
        steps += 1
        dr, dc = current_dir
        nr, nc = r + dr, c + dc
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        if grid_in[nr][nc] != 0:
            current_color = grid_in[nr][nc]
            current_dir = update_direction(current_dir, current_color)
        else:
            output[nr][nc] = current_color
        r, c = nr, nc
        if steps > width * height * 2:
            break

    return tuple(tuple(row) for row in output)

