# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: e544957e
Difficulty: insane

=== Tags ===
- Draw line from point
- Loop filling

=== Description ===
The input grid contains multiple distinct points represented by a single color
(e.g., red), scattered across a 2D grid. These points must be sorted
lexicographically (by row, then column) to determine the connection sequence. A
continuous line (using a second color, e.g., blue) is drawn between consecutive
points in this sorted order, forming a closed loop by connecting the last point
back to the first. The interior of this closed loop is then filled with a third
color (e.g., green), creating a visually distinct enclosed region. For "insane"
difficulty, the input grid features 20â€“30 points arranged in a complex, non-
convex pattern that forms a self-avoiding polygon, requiring the solver to
correctly identify the loop boundary and interior despite irregular vertex
distribution, overlapping edge proximity, and potential edge cases in polygon
filling logic. The transformation must maintain strict adherence to the
lexicographical sorting rule and ensure the loop remains simple (non-
intersecting) to guarantee deterministic filling.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def bresenham(x0, y0, x1, y1):
    points = []
    dx = abs(x1 - x0)
    dy = abs(y1 - y0)
    sx = 1 if x0 < x1 else -1
    sy = 1 if y0 < y1 else -1
    err = dx - dy
    while True:
        points.append((x0, y0))
        if x0 == x1 and y0 == y1:
            break
        e2 = 2 * err
        if e2 > -dy:
            err -= dy
            x0 += sx
        if e2 < dx:
            err += dx
            y0 += sy
    return points

def generate():
    size = 20
    num_points = random.randint(20, 30)
    points = set()
    while len(points) < num_points:
        r = random.randint(0, size-1)
        c = random.randint(0, size-1)
        points.add((r, c))
    points = sorted(points, key=lambda x: (x[0], x[1]))
    
    input_grid = [[0]*size for _ in range(size)]
    for r, c in points:
        input_grid[r][c] = 2
    
    output_grid = [[0]*size for _ in range(size)]
    
    for i in range(len(points)):
        r1, c1 = points[i]
        r2, c2 = points[(i+1) % len(points)]
        line_points = bresenham(r1, c1, r2, c2)
        for r, c in line_points:
            output_grid[r][c] = 4
    
    total_r = sum(r for r, c in points)
    total_c = sum(c for r, c in points)
    centroid_r = total_r // len(points)
    centroid_c = total_c // len(points)
    
    if output_grid[centroid_r][centroid_c] == 4:
        directions = [(1,0), (-1,0), (0,1), (0,-1)]
        for dr, dc in directions:
            nr, nc = centroid_r + dr, centroid_c + dc
            if 0 <= nr < size and 0 <= nc < size and output_grid[nr][nc] == 0:
                centroid_r, centroid_c = nr, nc
                break
    
    queue = [(centroid_r, centroid_c)]
    output_grid[centroid_r][centroid_c] = 3
    while queue:
        r, c = queue.pop(0)
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < size and 0 <= nc < size and output_grid[nr][nc] == 0:
                output_grid[nr][nc] = 3
                queue.append((nr, nc))
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random

def bresenham(x0, y0, x1, y1):
    points = []
    dx = abs(x1 - x0)
    dy = abs(y1 - y0)
    sx = 1 if x0 < x1 else -1
    sy = 1 if y0 < y1 else -1
    err = dx - dy
    while True:
        points.append((x0, y0))
        if x0 == x1 and y0 == y1:
            break
        e2 = 2 * err
        if e2 > -dy:
            err -= dy
            x0 += sx
        if e2 < dx:
            err += dx
            y0 += sy
    return points

def p(input_grid):
    points = []
    size = len(input_grid)
    for r in range(size):
        for c in range(size):
            if input_grid[r][c] == 2:
                points.append((r, c))
    points.sort(key=lambda x: (x[0], x[1]))
    
    output_grid = [[0]*size for _ in range(size)]
    
    for i in range(len(points)):
        r1, c1 = points[i]
        r2, c2 = points[(i+1) % len(points)]
        line_points = bresenham(r1, c1, r2, c2)
        for r, c in line_points:
            output_grid[r][c] = 4
    
    total_r = sum(r for r, c in points)
    total_c = sum(c for r, c in points)
    centroid_r = total_r // len(points)
    centroid_c = total_c // len(points)
    
    if output_grid[centroid_r][centroid_c] == 4:
        directions = [(1,0), (-1,0), (0,1), (0,-1)]
        for dr, dc in directions:
            nr, nc = centroid_r + dr, centroid_c + dc
            if 0 <= nr < size and 0 <= nc < size and output_grid[nr][nc] == 0:
                centroid_r, centroid_c = nr, nc
                break
    
    queue = [(centroid_r, centroid_c)]
    output_grid[centroid_r][centroid_c] = 3
    while queue:
        r, c = queue.pop(0)
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < size and 0 <= nc < size and output_grid[nr][nc] == 0:
                output_grid[nr][nc] = 3
                queue.append((nr, nc))
    
    return output_grid
