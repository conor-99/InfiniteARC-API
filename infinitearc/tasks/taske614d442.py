# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: e614d442
Difficulty: insane

=== Tags ===
- Flow with decay
- Wave reflection
- Kinetic collision
- Nearest color fill
- Image filling

=== Description ===
Dynamic Wave Interference  Input grids feature a uniform background color (0),
solid wall segments (color 9), and multiple wave sources (colors 1-8). Each
source emits diagonal waves traveling in all four diagonal directions (top-left,
top-right, bottom-left, bottom-right) simultaneously. Waves propagate until they
exit the grid, decay to background color, or collide with other waves.  Wave
propagation follows these rules: 1. **Decay**: Each wave cell's color decreases
by 1 from the source (e.g., a color 5 source becomes 4 in the next cell, 3 in
the following, etc.). Waves fade to background (0) and vanish when color reaches
0. 2. **Reflection**: Waves reflect perfectly off walls (color 9) with direction
mirroring (e.g., top-right becomes bottom-right), continuing propagation with
current decayed color. 3. **Collision**: When two waves meet at a cell (from
different directions), they cancel out, resulting in background color (0). 4.
**Filling**: After wave propagation, all background cells (0) not part of wave
paths are filled with the color of the nearest wave source. "Nearest" is
determined by minimal diagonal steps (Chebyshev distance), with ties resolved by
smallest source color value.  Output grids show: - Walls (color 9) unchanged -
Wave paths with visible decayed colors - Collision points (background color) -
Background filled with nearest source colors  This task requires simultaneous
simulation of wave physics (decay/reflection), collision resolution, and spatial
filling, demanding multi-step reasoning across complex wave interactions in
grids with multiple sources and irregular wall layouts.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = [[0] * width for _ in range(height)]
    
    # Place walls (color 9)
    wall_count = random.randint(2, 5)
    for _ in range(wall_count):
        if random.choice([True, False]):
            # Horizontal
            r = random.randint(0, height - 1)
            start_c = random.randint(0, width - 3)
            length = random.randint(1, 3)
            for c in range(start_c, start_c + length):
                grid[r][c] = 9
        else:
            # Vertical
            c = random.randint(0, width - 1)
            start_r = random.randint(0, height - 3)
            length = random.randint(1, 3)
            for r in range(start_r, start_r + length):
                grid[r][c] = 9
    
    # Place sources (1-8)
    sources = []
    for _ in range(random.randint(3, 5)):
        r, c = random.randint(0, height - 1), random.randint(0, width - 1)
        while grid[r][c] != 0:
            r, c = random.randint(0, height - 1), random.randint(0, width - 1)
        color = random.randint(1, 8)
        grid[r][c] = color
        sources.append((r, c, color))
    
    # Compute output
    output = [[0] * width for _ in range(height)]
    wave_colors = [[None] * width for _ in range(height)]
    directions = [(-1, -1), (-1, 1), (1, 1), (1, -1)]
    
    for (r, c, color) in sources:
        for dr, dc in directions:
            cr, cc = r, c
            current_color = color
            while True:
                cr += dr
                cc += dc
                if cr < 0 or cr >= height or cc < 0 or cc >= width:
                    break
                if grid[cr][cc] == 9:
                    dr, dc = -dr, -dc
                    continue
                if current_color <= 0:
                    break
                if wave_colors[cr][cc] is not None:
                    wave_colors[cr][cc] = 0
                else:
                    wave_colors[cr][cc] = current_color
                current_color -= 1
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 9:
                output[r][c] = 9
            else:
                if wave_colors[r][c] is not None:
                    output[r][c] = wave_colors[r][c]
                else:
                    output[r][c] = 0
    
    # Fill background with nearest source
    for r in range(height):
        for c in range(width):
            if output[r][c] != 0:
                continue
            min_dist = float('inf')
            nearest_color = 10
            for (sr, sc, color) in sources:
                dist = max(abs(r - sr), abs(c - sc))
                if dist < min_dist or (dist == min_dist and color < nearest_color):
                    min_dist = dist
                    nearest_color = color
            output[r][c] = nearest_color
    
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    sources = []
    for r in range(height):
        for c in range(width):
            if 1 <= grid[r][c] <= 8:
                sources.append((r, c, grid[r][c]))
    
    output = [[0] * width for _ in range(height)]
    wave_colors = [[None] * width for _ in range(height)]
    directions = [(-1, -1), (-1, 1), (1, 1), (1, -1)]
    
    for (r, c, color) in sources:
        for dr, dc in directions:
            cr, cc = r, c
            current_color = color
            while True:
                cr += dr
                cc += dc
                if cr < 0 or cr >= height or cc < 0 or cc >= width:
                    break
                if grid[cr][cc] == 9:
                    dr, dc = -dr, -dc
                    continue
                if current_color <= 0:
                    break
                if wave_colors[cr][cc] is not None:
                    wave_colors[cr][cc] = 0
                else:
                    wave_colors[cr][cc] = current_color
                current_color -= 1
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 9:
                output[r][c] = 9
            else:
                if wave_colors[r][c] is not None:
                    output[r][c] = wave_colors[r][c]
                else:
                    output[r][c] = 0
    
    # Fill background with nearest source
    for r in range(height):
        for c in range(width):
            if output[r][c] != 0:
                continue
            min_dist = float('inf')
            nearest_color = 10
            for (sr, sc, color) in sources:
                dist = max(abs(r - sr), abs(c - sc))
                if dist < min_dist or (dist == min_dist and color < nearest_color):
                    min_dist = dist
                    nearest_color = color
            output[r][c] = nearest_color
    
    return tuple(tuple(row) for row in output)
