# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 339cad03
Difficulty: mediumâ€“hard

=== Tags ===
- Area based reconstruction
- Draw x on largest object
- Duplicate column pattern

=== Description ===
Input grids consist of multiple connected regions (objects) represented by non-
zero colors on a background (color 0). The output grid is generated through a
sequence of deterministic operations: First, identify the largest connected
region (by pixel count; in case of ties, the region with the highest color value
is selected). Within this region, draw an 'X' pattern by replacing the main
diagonal and anti-diagonal cells (within the region's bounding box) with a
specific marker color (9). Next, identify all columns containing at least one
cell of the 'X' pattern and duplicate each such column immediately to the right
of its original position. All other regions, background, and non-X cells remain
unchanged. The transformation requires recognizing spatial relationships, area-
based analysis, geometric pattern application, and structured column
manipulation to derive the output from the input.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from typing import List, Dict


def _random_connected_region(width, height, size, forbidden):
    # Generate a connected region of 'size' cells avoiding coordinates in forbidden.
    # Uses randomized growth from a random start.
    if size <= 0:
        return []
    max_attempts = 200
    for _ in range(max_attempts):
        start_r = random.randrange(height)
        start_c = random.randrange(width)
        if (start_r, start_c) in forbidden:
            continue
        pixels = [(start_r, start_c)]
        # Grow until we reach desired size
        while len(pixels) < size:
            # collect candidates = neighbors of existing pixels not in pixels nor in forbidden
            candidates = []
            for (r,c) in pixels:
                for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):
                    nr, nc = r+dr, c+dc
                    if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in forbidden and (nr, nc) not in pixels and (nr, nc) not in candidates:
                        candidates.append((nr,nc))
            if not candidates:
                break
            pixels.append(random.choice(candidates))
        if len(pixels) == size:
            return pixels
    return None


def _ensure_has_diagonal(pixels, width, height, other_forbidden):
    # Ensure the connected pixel set contains at least one cell on the
    # main or anti-diagonal of its own bounding box. If necessary, connect
    # a diagonal cell by creating a short Manhattan path from the nearest pixel.
    pixels = list(pixels)
    pixel_set = set(pixels)
    max_attempts = 80
    for _ in range(max_attempts):
        min_r = min(r for r, c in pixel_set)
        max_r = max(r for r, c in pixel_set)
        min_c = min(c for r, c in pixel_set)
        max_c = max(c for r, c in pixel_set)
        height_box = max_r - min_r + 1
        width_box = max_c - min_c + 1
        diag_positions = set()
        length = min(height_box, width_box)
        for k in range(length):
            diag_positions.add((min_r + k, min_c + k))  # main
            diag_positions.add((min_r + k, max_c - k))  # anti
        if pixel_set & diag_positions:
            return list(pixel_set)
        # choose candidates on diagonals that are inside the bounding box
        candidates = [p for p in diag_positions if 0 <= p[0] < height and 0 <= p[1] < width]
        # sort by distance to pixel_set
        if not candidates:
            return list(pixel_set)
        def min_dist_to_set(p):
            return min(abs(p[0]-q[0]) + abs(p[1]-q[1]) for q in pixel_set)
        candidates.sort(key=min_dist_to_set)
        # try to connect nearest candidate by Manhattan path
        connected = False
        for cand in candidates:
            # find nearest pixel in pixel_set
            nearest = min(pixel_set, key=lambda q: abs(q[0]-cand[0]) + abs(q[1]-cand[1]))
            # build Manhattan path from nearest to cand
            path = []
            r, c = nearest
            dr = 1 if cand[0] > r else -1
            while r != cand[0]:
                r += dr
                path.append((r, c))
            dc = 1 if cand[1] > c else -1
            while c != cand[1]:
                c += dc
                path.append((r, c))
            # check path validity: do not overlap other regions and stay inside grid
            invalid = False
            for cell in path:
                if cell in other_forbidden: invalid = True; break
                rr, cc = cell
                if not (0 <= rr < height and 0 <= cc < width):
                    invalid = True; break
            if invalid:
                continue
            # path is ok, add path cells to pixel_set
            for cell in path:
                pixel_set.add(cell)
            connected = True
            break
        if connected:
            # continue loop to re-evaluate diagonals (pixel_set changed)
            continue
        else:
            # cannot connect any diagonal without overlapping forbidden; give up
            break
    return list(pixel_set)


def generate():
    # Generate a grid with multiple connected regions and then create the output
    # by drawing an X on the largest region and duplicating columns that contain X.
    max_width = 20
    max_height = 20
    width = random.randint(5, max_width)
    height = random.randint(5, max_height)
    grid_in = [[0 for _ in range(width)] for __ in range(height)]
    forbidden = set()
    # pick number of regions (including the largest)
    num_regions = random.randint(2, 4)
    # decide sizes: make largest strictly bigger than others to avoid ties
    max_possible = max(3, width * height - (num_regions))  # leave some space
    # ensure large size not too big
    large_min = 3
    large_max = max(large_min, min(max_possible, max(4, (width * height) // 3)))
    size_large = random.randint(large_min, large_max)
    # choose distinct colors (avoid 9 which is reserved for marker)
    colors = random.sample(list(range(1, 9)), num_regions)
    regions = []
    # generate largest region
    pixels = _random_connected_region(width, height, size_large, forbidden)
    if pixels is None:
        # fallback: fill a small compact block
        pixels = []
        r0 = random.randrange(0, height)
        c0 = random.randrange(0, width)
        pixels.append((r0, c0))
        # grow until size reached, greedy
        while len(pixels) < size_large:
            r,c = pixels[-1]
            for dr,dc in ((0,1),(1,0),(0,-1),(-1,0)):
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and (nr,nc) not in pixels:
                    pixels.append((nr,nc))
                    if len(pixels) >= size_large:
                        break
            if len(pixels) < size_large and len(pixels) == 1:
                # expand random neighbor
                nr = min(height-1, r0 + len(pixels))
                nc = min(width-1, c0 + len(pixels))
                pixels.append((nr,nc))
    # ensure diagonal occupancy
    pixels = _ensure_has_diagonal(pixels, width, height, forbidden)
    # register region
    regions.append((pixels, colors[0]))
    for p in pixels:
        forbidden.add(p)
    # create remaining regions (smaller)
    for i in range(1, num_regions):
        # choose size smaller than largest
        max_small = max(1, min(len(pixels)-1, (width * height - len(forbidden) - 1)))
        if max_small < 1:
            break
        size_small = random.randint(1, max_small)
        pix_small = _random_connected_region(width, height, size_small, forbidden)
        if pix_small is None:
            # try smaller sizes
            for s in range(size_small-1, 0, -1):
                pix_small = _random_connected_region(width, height, s, forbidden)
                if pix_small is not None:
                    size_small = s
                    break
        if pix_small is None:
            continue
        regions.append((pix_small, colors[i]))
        for p in pix_small:
            forbidden.add(p)
    # fill input grid
    for pix, color in regions:
        for (r,c) in pix:
            grid_in[r][c] = color
    # build output grid by drawing X in largest region and duplicating columns
    grid_out = [row[:] for row in grid_in]
    # identify largest region by size (break ties by color value)
    # We rely on 'regions' list: find largest by size and in tie highest color
    largest = max(regions, key=lambda rc: (len(rc[0]), rc[1]))
    largest_pixels = set(largest[0])
    # bounding box
    min_r = min(r for r,c in largest_pixels)
    max_r = max(r for r,c in largest_pixels)
    min_c = min(c for r,c in largest_pixels)
    max_c = max(c for r,c in largest_pixels)
    # mark diagonals but only where the cell belongs to the region
    hbox = max_r - min_r + 1
    wbox = max_c - min_c + 1
    length = min(hbox, wbox)
    for k in range(length):
        r_main = min_r + k
        c_main = min_c + k
        if (r_main, c_main) in largest_pixels:
            grid_out[r_main][c_main] = 9
        r_anti = min_r + k
        c_anti = max_c - k
        if (r_anti, c_anti) in largest_pixels:
            grid_out[r_anti][c_anti] = 9
    # find columns containing 9
    cols = [c for c in range(width) if any(grid_out[r][c] == 9 for r in range(height))]
    # duplicate columns to the right, process from right-to-left to avoid index shifts
    cols = sorted(set(cols), reverse=True)
    max_columns = 30
    # cap duplicates so final width <= max_columns
    allowed = max(0, max_columns - width)
    if len(cols) > allowed:
        cols = cols[:allowed]
    for c in cols:
        for r in range(height):
            grid_out[r].insert(c + 1, grid_out[r][c])
    return {'input': grid_in, 'output': grid_out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    if height == 0:
        return tuple(tuple(row) for row in grid)
    width = len(grid[0])
    visited = [[False]*width for _ in range(height)]
    components = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and not visited[r][c]:
                color = grid[r][c]
                q = deque()
                q.append((r,c))
                visited[r][c] = True
                pixels = []
                while q:
                    cr, cc = q.popleft()
                    pixels.append((cr, cc))
                    for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):
                        nr, nc = cr+dr, cc+dc
                        if 0<=nr<height and 0<=nc<width and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            q.append((nr, nc))
                components.append((pixels, color))
    # select largest by size, tie-breaker by color value (higher wins)
    if not components:
        return tuple(tuple(row) for row in grid)
    largest = max(components, key=lambda pc: (len(pc[0]), pc[1]))
    pixels_large = set(largest[0])
    min_r = min(r for r,c in pixels_large)
    max_r = max(r for r,c in pixels_large)
    min_c = min(c for r,c in pixels_large)
    max_c = max(c for r,c in pixels_large)
    # mark diagonals within bounding box, but only where the cell belongs to the region
    hbox = max_r - min_r + 1
    wbox = max_c - min_c + 1
    length = min(hbox, wbox)
    for k in range(length):
        r_main = min_r + k
        c_main = min_c + k
        if (r_main, c_main) in pixels_large:
            grid[r_main][c_main] = 9
        r_anti = min_r + k
        c_anti = max_c - k
        if (r_anti, c_anti) in pixels_large:
            grid[r_anti][c_anti] = 9
    # duplicate columns that contain 9, rightwards. process right-to-left
    cols = [c for c in range(width) if any(grid[r][c] == 9 for r in range(height))]
    cols = sorted(set(cols), reverse=True)
    max_columns = 30
    allowed = max(0, max_columns - width)
    if len(cols) > allowed:
        cols = cols[:allowed]
    for c in cols:
        for r in range(height):
            grid[r].insert(c + 1, grid[r][c])
    return tuple(tuple(row) for row in grid)

