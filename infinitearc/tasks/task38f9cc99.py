# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 38f9cc99
Difficulty: hard

=== Tags ===
- Color matching
- Pattern resizing
- Recursive partition
- Algebra

=== Description ===
The input grid comprises multiple axis-aligned rectangular regions, each
uniformly colored with a distinct value from 0 to 9. The output grid is
generated through a recursive transformation process. Each region is scaled
based on its color: regions of color 1 are horizontally expanded, color 2
vertically expanded, and color 3 expanded in both directions, with all
expansions doubling the original dimensions. The grid is then partitioned into
quadrants, and the same scaling rules are recursively applied to regions within
each quadrant. This results in a fractal-like pattern where each region's size
increases exponentially with recursion depth, and the output grid's structure
reflects the hierarchical scaling of the input's regions. The transformation
requires identifying color-based scaling rules, applying recursive partitioning,
and maintaining visual consistency across multiple hierarchical levels to
achieve the correct output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    max_input_size = 7
    width = random.randint(1, max_input_size)
    height = random.randint(1, max_input_size)
    input_grid = [[random.choice([1, 2, 3]) for _ in range(width)] for _ in range(height)]
    
    def scale(grid):
        if not grid or not grid[0]:
            return grid
        width = len(grid[0])
        height = len(grid)
        row_widths = [sum(2 if grid[i][j] in (1, 3) else 1 for j in range(width)) for i in range(height)]
        col_heights = [sum(2 if grid[i][j] in (2, 3) else 1 for i in range(height)) for j in range(width)]
        new_width = max(row_widths)
        new_height = max(col_heights)
        output = [[0] * new_width for _ in range(new_height)]
        x, y = 0, 0
        for i in range(height):
            for j in range(width):
                color = grid[i][j]
                w = 2 if color in (1, 3) else 1
                h = 2 if color in (2, 3) else 1
                for dy in range(h):
                    for dx in range(w):
                        if y + dy < new_height and x + dx < new_width:
                            output[y + dy][x + dx] = color
                x += w
            x = 0
            y += h
        return output
    
    output1 = scale(input_grid)
    output2 = scale(output1)
    return {
        "input": input_grid,
        "output": output2
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    def scale(grid):
        if not grid or not grid[0]:
            return grid
        width = len(grid[0])
        height = len(grid)
        row_widths = [sum(2 if grid[i][j] in (1, 3) else 1 for j in range(width)) for i in range(height)]
        col_heights = [sum(2 if grid[i][j] in (2, 3) else 1 for i in range(height)) for j in range(width)]
        new_width = max(row_widths)
        new_height = max(col_heights)
        output = [[0] * new_width for _ in range(new_height)]
        x, y = 0, 0
        for i in range(height):
            for j in range(width):
                color = grid[i][j]
                w = 2 if color in (1, 3) else 1
                h = 2 if color in (2, 3) else 1
                for dy in range(h):
                    for dx in range(w):
                        if y + dy < new_height and x + dx < new_width:
                            output[y + dy][x + dx] = color
                x += w
            x = 0
            y += h
        return output
    
    return scale(scale(input_grid))
