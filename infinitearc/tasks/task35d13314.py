# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 35d13314
Difficulty: hard

=== Tags ===
- Gas expansion
- Variable binding by color
- Binary rule overlay
- Diagonals
- Connect two dots with a line
- Maze

=== Description ===
Diagonal Gas Maze Connector  Input grids depict a maze structure with walls
represented by non-zero colors (1-9) and background cells (color 0). The maze
contains two distinct source points located on opposite grid edges (e.g., left
and right), each marked by unique color-coded markers (e.g., color 5 on left
edge, color 6 on right edge). These sources are positioned within open
background corridors (never adjacent to walls) and are separated by a complex
maze of background corridors (0) and walls (non-zero). The maze contains no dead
ends, with a continuous path connecting the two sources through background
cells.  The grid also contains a color-coded "gas expansion" rule system where
each color (1-4) corresponds to a fixed diagonal expansion direction: color 1 =
northeast, color 2 = southeast, color 3 = northwest, color 4 = southwest. The
source colors (5 and 6) activate expansion rules based on their positions: color
5 expands in direction D1 (determined by color value), color 6 expands in
direction D2 (determined by color value). Expansion proceeds diagonally through
background cells (0) at the specified rate until blocked by walls or other
expansions.  The output grid must connect the two source points with a
continuous line of a new color (7), following these rules: 1. The line must
traverse only background cells (0) and cannot pass through walls (non-zero) 2.
The path must follow the diagonal expansion directions from both sources
simultaneously 3. The line forms at the intersection point of the two expansion
paths within the maze corridors 4. If expansion paths don't naturally intersect,
the line follows the shortest possible path respecting both diagonal directions
at corridor junctions 5. The line must not deviate from the maze's background
corridors and must maintain continuous connectivity between sources  The solver
must first map each source color to its expansion direction (e.g., color 5 →
northeast, color 6 → southwest), then determine the diagonal paths each source
would expand along. The output path is the minimal sequence of background cells
that connects both paths while respecting the diagonal constraints. The line
color (7) replaces the background cells along this path, with all other elements
(walls, source markers, other colors) remaining unchanged. The maze structure
ensures exactly one valid path exists that satisfies all expansion constraints,
requiring the solver to simultaneously apply the gas expansion rules, maze
navigation, and diagonal direction mapping.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Try to build a grid where two diagonal expansions (from left and right edges)
    # are guaranteed to intersect. We fix the mapping: 5 -> NE (-1,+1), 6 -> SW (+1,-1).
    # We choose an intersection (ri,ci) and compute the source rows so the diagonals meet.
    for attempt in range(200):
        # Width and height choices. Height must be larger than width by at least 2
        # to make the arithmetic feasible for our fixed directions.
        W = random.randint(10, 18)
        H = random.randint(max(10, W + 2), min(30, W + 8))

        # Fixed diagonal directions for the two sources
        drL = -1  # source 5 goes NE: r += drL, c += 1
        drR = 1   # source 6 goes SW: r += drR, c -= 1

        # Choose a column for the intersection (not on the extreme edges)
        ci = random.randint(1, W - 2)

        # Compute feasible range for ri so that computed source rows are inside [1, H-2]
        # sr = ri - drL*ci  => sr = ri + ci
        # tr = ri - drR*(W-1-ci) => tr = ri - (W-1-ci)
        # Bounds: 1 <= sr <= H-2  and 1 <= tr <= H-2
        # So ri must satisfy: 1 - ci <= ri <= H-2 - ci  and 1 + (W-1-ci) <= ri <= H-2 + (W-1-ci)
        low1, high1 = 1 - ci, H - 2 - ci
        low2, high2 = 1 + (W - 1 - ci), H - 2 + (W - 1 - ci)
        ri_low = max(low1, low2)
        ri_high = min(high1, high2)
        if ri_low > ri_high:
            continue

        ri = random.randint(ri_low, ri_high)
        sr = ri - drL * ci
        tr = ri - drR * (W - 1 - ci)

        # Validate computed source rows
        if not (1 <= sr <= H - 2 and 1 <= tr <= H - 2):
            continue

        # Build grid: fill with wall color (choose a wall color not equal to 5,6,7)
        wall_color = random.choice([1, 2, 3, 4, 8, 9])
        ingrid = grid(W, H, wall_color)

        # Carve the left diagonal path (from source 5 at column 0 towards increasing columns)
        path5 = []
        for k in range(1, ci + 1):
            r = sr + drL * k
            c = 0 + k
            ingrid[r][c] = 0
            path5.append((r, c))

        # Carve the right diagonal path (from source 6 at column W-1 towards decreasing columns)
        path6 = []
        for k in range(1, (W - 1 - ci) + 1):
            r = tr + drR * k
            c = (W - 1) - k
            ingrid[r][c] = 0
            path6.append((r, c))

        # Carve a small open area around sources so they are "in open corridors" (not adjacent to walls)
        for rr, cc in [(sr - 1, 0), (sr + 1, 0), (sr, 1)]:
            if 0 <= rr < H and 0 <= cc < W:
                ingrid[rr][cc] = 0
        for rr, cc in [(tr - 1, W - 1), (tr + 1, W - 1), (tr, W - 2)]:
            if 0 <= rr < H and 0 <= cc < W:
                ingrid[rr][cc] = 0

        # Place sources (they remain non-zero and should not be overwritten by the carved zeros)
        ingrid[sr][0] = 5
        ingrid[tr][W - 1] = 6

        # Make sure the diagonal cells used for expansion are background (0)
        # (They were already set to 0 above.)

        # Prepare output: copy input and draw the gas-expanded connecting line (color 7)
        output = [row[:] for row in ingrid]
        for (r, c) in path5:
            if ingrid[r][c] == 0:
                output[r][c] = 7
        # mark path6 in reverse order (towards the intersection)
        for (r, c) in reversed(path6):
            if ingrid[r][c] == 0:
                output[r][c] = 7

        # Safety: ensure input != output
        if ingrid == output:
            continue

        return {
            "input": ingrid,
            "output": output
        }

    # Fallback deterministic small example (very unlikely to be reached)
    W, H = 10, 12
    ingrid = grid(W, H, 1)
    r = H // 2
    for c in range(W):
        ingrid[r][c] = 0
    ingrid[r][0] = 5
    ingrid[r][W - 1] = 6
    output = [row[:] for row in ingrid]
    for c in range(1, W - 1):
        if ingrid[r][c] == 0:
            output[r][c] = 7
    return {"input": ingrid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    # Convert to a mutable list-of-lists
    grid_in = [list(row) for row in input_grid]
    H = len(grid_in)
    W = len(grid_in[0])

    # Locate the two sources: color 5 on the left edge and color 6 on the right edge
    source5 = None
    source6 = None
    for r in range(H):
        if grid_in[r][0] == 5:
            source5 = (r, 0)
        if grid_in[r][W - 1] == 6:
            source6 = (r, W - 1)

    if source5 is None or source6 is None:
        return grid_in

    # Fixed mapping used by the generator:
    # 5 -> NE (-1, +1)
    # 6 -> SW (+1, -1)
    dr5, dc5 = -1, 1
    dr6, dc6 = 1, -1

    def trace(start, dr, dc):
        r, c = start
        path = []
        while True:
            r += dr
            c += dc
            if r < 0 or r >= H or c < 0 or c >= W:
                break
            # Expansion proceeds only through background (0)
            if grid_in[r][c] != 0:
                break
            path.append((r, c))
        return path

    path5 = trace(source5, dr5, dc5)
    path6 = trace(source6, dr6, dc6)

    # Find an intersection cell (first cell along path5 that is also on path6)
    set6 = set(path6)
    intersection = None
    for cell in path5:
        if cell in set6:
            intersection = cell
            break

    # If there is no direct diagonal intersection (shouldn't happen for generated tasks),
    # connect the two traced frontiers with a shortest path within background cells (BFS).
    if intersection is None:
        # BFS from all cells in path5 to reach any cell in path6
        if not path5 or not path6:
            return grid_in
        goals = set(path6)
        seen = [[False] * W for _ in range(H)]
        prev = {}
        q = deque()
        for s in path5:
            q.append(s)
            seen[s[0]][s[1]] = True
            prev[s] = None
        found = None
        while q:
            r, c = q.popleft()
            if (r, c) in goals:
                found = (r, c)
                break
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = r + dr, c + dc
                if 0 <= nr < H and 0 <= nc < W and not seen[nr][nc] and grid_in[nr][nc] == 0:
                    seen[nr][nc] = True
                    prev[(nr, nc)] = (r, c)
                    q.append((nr, nc))
        if found is None:
            return grid_in
        # reconstruct path from a path5 cell to a path6 cell
        chain = []
        cur = found
        while cur is not None:
            chain.append(cur)
            cur = prev.get(cur)
        # mark that chain as path5 for painting; leave path6 empty (we already reached a goal)
        path5 = chain
        path6 = []

    # Paint the expansions as color 7 on a copy of the input (do not overwrite sources or walls)
    out = [row[:] for row in grid_in]
    for r, c in path5:
        if out[r][c] == 0:
            out[r][c] = 7
    for r, c in path6:
        if out[r][c] == 0:
            out[r][c] = 7

    return out

