# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 49b00061
Difficulty: insane

=== Tags ===
- Multi goal satisfaction

=== Description ===
The input grid consists of a 2D arrangement of integers from 0 to 9,
representing colored pixels. The output grid must satisfy three interdependent
conditions simultaneously: (1) all instances of color 2 are swapped with color 5
(and vice versa), (2) the grid must be vertically symmetric (where each row
reads the same left-to-right as right-to-left), and (3) the number of connected
components of color 7 must exactly equal the number of connected components of
color 8 in the output. The transformation is achieved by first performing the
color swap between 2 and 5, then enforcing vertical symmetry by mirroring the
left half to the right half (preserving all colors), which inherently causes the
connected components of colors 7 and 8 to align in count due to the symmetry
constraint. This creates a deterministic rule that requires the solver to
recognize both the color transformation and the symmetry requirement, while the
connected component equality emerges as a consequence of the symmetry operation
applied to the color-swapped grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    while True:
        width = random.randint(1, 30)
        height = random.randint(1, 30)
        output = grid(width, height)
        
        # Generate symmetric grid (each row is palindrome)
        for r in range(height):
            left_len = (width + 1) // 2
            left_part = [random.randint(0, 9) for _ in range(left_len)]
            if width % 2 == 0:
                right_part = left_part[::-1]
            else:
                right_part = left_part[:-1][::-1]
            output[r] = left_part + right_part
            
        # Check component equality
        def count_components(grid, color):
            visited = [[False] * width for _ in range(height)]
            count = 0
            directions = [(1,0), (-1,0), (0,1), (0,-1)]
            
            def dfs(r, c):
                if r < 0 or r >= height or c < 0 or c >= width or visited[r][c] or grid[r][c] != color:
                    return
                visited[r][c] = True
                for dr, dc in directions:
                    dfs(r + dr, c + dc)
            
            for r in range(height):
                for c in range(width):
                    if not visited[r][c] and grid[r][c] == color:
                        count += 1
                        dfs(r, c)
            return count
        
        comp7 = count_components(output, 7)
        comp8 = count_components(output, 8)
        if comp7 != comp8:
            continue
        
        # Ensure output contains at least one 2 or 5
        has_color = any(2 in row or 5 in row for row in output)
        if not has_color:
            continue
        
        # Create input by swapping 2 and 5
        input_grid = [[5 if cell == 2 else 2 if cell == 5 else cell for cell in row] for row in output]
        
        # Verify input != output
        if input_grid == output:
            continue
        
        return {
            "input": input_grid,
            "output": output
        }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Swap 2 and 5
    output = [[5 if x == 2 else 2 if x == 5 else x for x in row] for row in input_grid]
    
    # Make vertically symmetric (each row is palindrome)
    for row in output:
        left_len = (len(row) + 1) // 2
        left_part = row[:left_len]
        if len(row) % 2 == 0:
            right_part = left_part[::-1]
        else:
            right_part = left_part[:-1][::-1]
        row[:] = left_part + right_part
    return output
