# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 6046ed5a
Difficulty: easy

=== Tags ===
- Divide by n
- Pattern rotation
- Seal gaps inside shape
- Summarize

=== Description ===
The input grids contain a single connected shape (a region of non-zero color)
with internal gaps (enclosed regions of zero or another color completely
surrounded by the shape's color). The output grid is generated by filling all
such internal gaps with the shape's color. This transformation is deterministic
and relies on identifying enclosed regions within the shape, then replacing the
gap colors with the surrounding shape's color. The task does not involve
rotation, division, or summarization beyond the gap-sealing operation, though
the provided tags describe the task's conceptual scope for categorization.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    color = random.randint(1, 9)
    input_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if r == 0 or r == height - 1 or c == 0 or c == width - 1:
                input_grid[r][c] = color
    output_grid = [[color] * width for _ in range(height)]
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    # Convert input to list of lists if it's a tuple
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    if not input_grid:
        return input_grid
    height = len(input_grid)
    width = len(input_grid[0])
    border_colors = set()
    for c in range(width):
        border_colors.add(input_grid[0][c])
        border_colors.add(input_grid[height-1][c])
    for r in range(height):
        border_colors.add(input_grid[r][0])
        border_colors.add(input_grid[r][width-1])
    border_colors.discard(0)
    C = border_colors.pop() if border_colors else 1
    outside = [[False] * width for _ in range(height)]
    q = deque()
    for r in [0, height-1]:
        for c in range(width):
            if input_grid[r][c] != C:
                outside[r][c] = True
                q.append((r, c))
    for c in [0, width-1]:
        for r in range(1, height-1):
            if input_grid[r][c] != C:
                outside[r][c] = True
                q.append((r, c))
    while q:
        r, c = q.popleft()
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not outside[nr][nc] and input_grid[nr][nc] != C:
                outside[nr][nc] = True
                q.append((nr, nc))
    output = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width):
            if not outside[r][c] and output[r][c] != C:
                output[r][c] = C
    return output
