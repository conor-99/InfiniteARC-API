# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 7e8f9a76
Difficulty: hard

=== Tags ===
- Phase transition path
- Elastic reflection

=== Description ===
# Phase Transition Path  Input grids are large (20×20 or larger) with a single
background color (0). Over this background, multiple contiguous regions (phases)
exist, each colored with a unique non-background color (1–9). These phases form
a complex maze-like structure where adjacent regions may share edges, creating
boundaries between different phase types. Each phase color corresponds to a
specific reflection rule: color C (1–9) causes a direction change of (C-1)×45°
clockwise from the current movement direction.  The path begins at a single cell
on the left edge (x=0) moving east. The path traverses only background cells
(0), and when it encounters a phase cell (non-background), it reflects according
to the phase's color rule. The reflection direction changes sequentially as the
path encounters multiple phase regions. The path continues until it exits the
grid through the top, right, or bottom edge.  In the output grid, all phases and
background remain unchanged except for the path. The path is drawn as a
continuous line through background cells, with direction changes applied at each
phase cell. The path never overlaps with phase regions or other elements, and
all direction changes are applied in sequence as the path traverses the grid.
The transformation requires tracking both the path's position and direction
through multiple phase transitions, with the reflection angle determined by the
current phase color. The path must navigate complex phase boundaries without
crossing into non-background regions, requiring the solver to apply multiple
reflection rules in sequence.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
from common import grid, continuous_creature
import random
def generate():
    size = random.randint(20, 30)
    input_grid = grid(size, size, 0)
    phase_colors = random.sample(list(range(1, 10)), random.randint(3, 5))
    path_color = 1
    while path_color in phase_colors:
        path_color += 1

    for color in phase_colors:
        size_region = random.randint(5, 15)
        pixels = continuous_creature(size_region, 30, 30)
        dx = random.randint(0, size - 1)
        dy = random.randint(0, size - 1)
        for (r, c) in pixels:
            new_r = r + dx
            new_c = c + dy
            if 0 <= new_r < size and 0 <= new_c < size:
                input_grid[new_r][new_c] = color

    start_y = None
    for y in range(size):
        if input_grid[0][y] == 0 and input_grid[1][y] == 0:
            start_y = y
            break
    if start_y is None:
        start_y = 0

    directions = [(1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1), (0, -1), (1, -1)]
    current = (0, start_y)
    direction = 0
    path_cells = [current]
    max_steps = 10000
    step_count = 0

    while step_count < max_steps:
        r, c = current
        dr, dc = directions[direction]
        next_r, next_c = r + dr, c + dc
        if not (0 <= next_r < size and 0 <= next_c < size):
            break
        if input_grid[next_r][next_c] != 0:
            C = input_grid[next_r][next_c]
            direction = (direction + C - 1) % 8
        else:
            current = (next_r, next_c)
            path_cells.append(current)
        step_count += 1

    output_grid = [row[:] for row in input_grid]
    for (r, c) in path_cells:
        output_grid[r][c] = path_color

    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    size = len(input_grid)
    grid_list = [list(row) for row in input_grid]
    non_zero_colors = set()
    for row in grid_list:
        for cell in row:
            if cell != 0:
                non_zero_colors.add(cell)
    path_color = 1
    while path_color in non_zero_colors:
        path_color += 1

    start_y = None
    for y in range(size):
        if grid_list[0][y] == 0 and grid_list[1][y] == 0:
            start_y = y
            break
    if start_y is None:
        start_y = 0

    directions = [(1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1), (0, -1), (1, -1)]
    current = (0, start_y)
    direction = 0
    path_cells = [current]
    max_steps = 10000
    step_count = 0

    while step_count < max_steps:
        r, c = current
        dr, dc = directions[direction]
        next_r, next_c = r + dr, c + dc
        if not (0 <= next_r < size and 0 <= next_c < size):
            break
        if grid_list[next_r][next_c] != 0:
            C = grid_list[next_r][next_c]
            direction = (direction + C - 1) % 8
        else:
            current = (next_r, next_c)
            path_cells.append(current)
        step_count += 1

    for (r, c) in path_cells:
        grid_list[r][c] = path_color

    return tuple(tuple(row) for row in grid_list)
