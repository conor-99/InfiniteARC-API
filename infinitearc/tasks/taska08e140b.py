# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: a08e140b
Difficulty: medium–hard

=== Tags ===
- Dependency topological sort
- Connect two dots with a line
- Associate images to images

=== Description ===
**Task Description: Dependency Path Network**  Input grids feature multiple
pairs of identical-colored dots positioned across the grid. Each pair is
accompanied by a unique symbol (e.g., a small star, circle, or triangle) placed
adjacent to the dots. These symbols form a directed dependency graph: an arrow
from symbol X to symbol Y indicates that the pair associated with X must be
connected before the pair associated with Y. The dependency graph is acyclic and
visually encoded through the relative placement of symbols (e.g., a symbol to
the left of another implies a dependency order).  The output grid must connect
each pair of dots with a continuous line of their color, following the shortest
orthogonally connected path that avoids intersecting other lines. The order of
connection is determined by a topological sort of the dependency graph, ensuring
connections are made in sequence to prevent overlaps. Visually, each line’s path
must mirror the shape of its associated symbol: a star symbol requires a small
detour around a single obstacle cell (a cell of a different color), while a
triangle symbol necessitates a straight orthogonal path. This symbol association
ensures the line’s trajectory directly reflects the symbol’s form, blending
topological ordering with visual pattern matching. The background remains
unchanged except for the added lines, and all dot pairs must be connected
exactly once without extending beyond grid boundaries.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Generator for ARC task 452: Dependency Path Network
# Produces an input grid with pairs of colored dots, adjacent symbols (1=star,2=triangle),
# and obstacles (6) for star-symbol pairs. The output grid connects each pair in a
# topological order determined by symbol column (left-to-right) using shortest
# orthogonal paths that avoid obstacles and previously drawn lines.

def generate():
    # Number of pairs
    num_pairs = random.randint(2, 4)

    # Choose grid size large enough to place spaced rows for horizontal paths
    min_height = max(9, 2 * num_pairs + 5)
    height = random.randint(min_height, max(min_height + 6, min_height))
    width = random.randint(10, 18)

    # Create empty input grid
    input_grid = grid(width, height, 0)
    occupied = set()

    # Choose symbol columns (unique) ensuring room on their left for two dots
    possible_symbol_cols = list(range(3, width - 1))
    if len(possible_symbol_cols) < num_pairs:
        # fallback to ensure there are enough columns
        possible_symbol_cols = list(range(2, width - 1))
    symbol_cols = random.sample(possible_symbol_cols, num_pairs)

    # Choose symbol rows with spacing >= 2 so detours (up/down) are available
    possible_rows = list(range(2, height - 2))
    symbol_rows = None
    for _ in range(200):
        cand = random.sample(possible_rows, num_pairs)
        cand.sort()
        ok = True
        for i in range(1, len(cand)):
            if abs(cand[i] - cand[i - 1]) < 2:
                ok = False
                break
        if ok:
            symbol_rows = cand
            break
    if symbol_rows is None:
        # fallback: choose evenly spaced rows
        step = max(2, (height - 4) // (num_pairs + 1))
        symbol_rows = [2 + step * (i + 1) for i in range(num_pairs)]
        # clamp into range
        symbol_rows = [min(max(2, r), height - 3) for r in symbol_rows]

    # Prepare containers
    dot_positions = []  # (r1, c1, r2, c2)
    symbol_cells = []   # (sr, sc, symbol_color, pair_index)

    # Dot colors: choose from allowed colors excluding symbols (1,2) and obstacle (6)
    allowed_dot_colors = [3, 4, 5, 7, 8, 9]
    dot_colors = random.sample(allowed_dot_colors, num_pairs)

    for i in range(num_pairs):
        sr = symbol_rows[i]
        sc = symbol_cols[i]

        # choose symbol color: 1 (star) or 2 (triangle)
        symbol_color = random.choice([1, 2])

        # ensure symbol cell not used
        if (sr, sc) in occupied:
            # find nearest free column from sc to the right (shouldn't usually happen)
            for alt_c in range(sc + 1, width - 1):
                if (sr, alt_c) not in occupied:
                    sc = alt_c
                    break
        input_grid[sr][sc] = symbol_color
        occupied.add((sr, sc))

        # place first dot immediately to the left of the symbol
        c1 = sc - 1
        r1 = sr
        if (r1, c1) in occupied:
            # try right neighbor instead
            c1 = sc + 1
            if c1 >= width:
                # fallback: find any free neighbor
                for dr, dc in [(0, -1), (0, 1), (1, 0), (-1, 0)]:
                    rr, cc = sr + dr, sc + dc
                    if 0 <= rr < height and 0 <= cc < width and (rr, cc) not in occupied:
                        r1, c1 = rr, cc
                        break
        input_grid[r1][c1] = dot_colors[i]
        occupied.add((r1, c1))

        # place second dot in the same row (horizontal pair) to the left of the first dot
        # ensure at least one empty cell between them (Manhattan distance >= 2)
        possible_c2 = list(range(0, c1 - 1))
        random.shuffle(possible_c2)
        placed = False
        for c2 in possible_c2:
            if (r1, c2) in occupied:
                continue
            # ensure path between c2 and c1 has at least one internal cell (so not adjacent)
            if abs(c1 - c2) >= 2:
                # also ensure that the mid cell (if used for obstacle) won't be occupied
                placed = True
                break
        if not placed:
            # As a fallback, try placing the second dot to the right further away
            for c2 in range(c1 + 2, width):
                if (r1, c2) in occupied:
                    continue
                placed = True
                break
        if not placed:
            # extreme fallback: scan whole grid for a free cell in same row with distance>=2
            for c2 in range(width):
                if (r1, c2) in occupied: continue
                if abs(c1 - c2) >=2:
                    c2 = c2
                    placed = True
                    break
        if not placed:
            # should not happen, but break to avoid infinite loop
            raise RuntimeError("Could not place second dot")

        r2, c2 = r1, c2
        input_grid[r2][c2] = dot_colors[i]
        occupied.add((r2, c2))

        # For star symbols (color 1) place a single obstacle on the straight path between the two dots
        if symbol_color == 1:
            if r1 == r2:
                mid_c = (c1 + c2) // 2
                # ensure the obstacle is strictly between them
                if mid_c == c1 or mid_c == c2:
                    # nudge it one step towards the center of the segment
                    if c1 < c2:
                        mid_c = c1 + 1
                    else:
                        mid_c = c2 + 1
                # pick a free location near mid if occupied
                if (r1, mid_c) in occupied:
                    # try up or down cell (detour cell) if within bounds
                    if r1 - 1 >= 0 and (r1 - 1, mid_c) not in occupied:
                        obstacle_r, obstacle_c = r1 - 1, mid_c
                    elif r1 + 1 < height and (r1 + 1, mid_c) not in occupied:
                        obstacle_r, obstacle_c = r1 + 1, mid_c
                    else:
                        # find any free midpoint cell between c1 and c2
                        placed_obs = False
                        for cc in range(min(c1, c2) + 1, max(c1, c2)):
                            if (r1, cc) not in occupied:
                                obstacle_r, obstacle_c = r1, cc
                                placed_obs = True
                                break
                        if not placed_obs:
                            obstacle_r, obstacle_c = None, None
                else:
                    obstacle_r, obstacle_c = r1, mid_c
                if obstacle_r is not None and (obstacle_r, obstacle_c) not in occupied:
                    input_grid[obstacle_r][obstacle_c] = 6
                    occupied.add((obstacle_r, obstacle_c))
        # record positions
        dot_positions.append((r1, c1, r2, c2))
        symbol_cells.append((sr, sc, symbol_color, i))

    # Build output by connecting the pairs in topological order (symbols left-to-right)
    output_grid = [row[:] for row in input_grid]

    # Determine topological order by sorting symbol cells by column (left-to-right)
    symbol_cells.sort(key=lambda x: (x[1], x[0]))
    order = [idx for (_, _, _, idx) in symbol_cells]

    # BFS helper
    from collections import deque
    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # deterministic neighbor order

    for idx in order:
        r1, c1, r2, c2 = dot_positions[idx]
        color = dot_colors[idx]

        # BFS on current output_grid to avoid obstacles (6) and existing lines (non-zero not equal to color)
        h, w = height, width
        visited = [[False] * w for _ in range(h)]
        parent = [[None] * w for _ in range(h)]
        q = deque()
        q.append((r1, c1))
        visited[r1][c1] = True
        found = False
        while q:
            r, c = q.popleft()
            if (r, c) == (r2, c2):
                found = True
                break
            for dr, dc in dirs:
                nr, nc = r + dr, c + dc
                if nr < 0 or nr >= h or nc < 0 or nc >= w: continue
                if visited[nr][nc]: continue
                val = output_grid[nr][nc]
                # allow stepping on free cells (0) and cells with our own color (start/end), but avoid obstacles(6) and other objects
                if val != 0 and val != color:
                    continue
                visited[nr][nc] = True
                parent[nr][nc] = (r, c)
                q.append((nr, nc))
        if not found:
            # As a safety, try BFS that allows stepping over the end even if it's colored differently
            # (shouldn't be necessary with our generator choices)
            pass

        # reconstruct path
        path = []
        rr, cc = r2, c2
        while True:
            path.append((rr, cc))
            if (rr, cc) == (r1, c1):
                break
            rr, cc = parent[rr][cc]
            if rr is None:
                raise RuntimeError("No path found during generation (this should not happen)")
        path.reverse()

        # paint the path onto output
        for (pr, pc) in path:
            output_grid[pr][pc] = color

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    # Convert tuple-of-tuples input into mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Identify dot colors: colors > 2 appearing exactly twice, exclude obstacle color 6
    counts = {}
    for r in range(height):
        for c in range(width):
            val = grid[r][c]
            if val > 2 and val != 6:
                counts[val] = counts.get(val, 0) + 1
    dot_colors = [color for color, cnt in counts.items() if cnt == 2]
    dot_colors.sort()

    # collect dot pairs
    dot_pairs = []  # list of (color, (r1,c1), (r2,c2))
    for color in dot_colors:
        pos = []
        for r in range(height):
            for c in range(width):
                if grid[r][c] == color:
                    pos.append((r, c))
        if len(pos) == 2:
            dot_pairs.append((color, pos[0], pos[1]))

    # find symbols adjacent to the first dot of each pair (or second)
    # Also record which dot is adjacent so we can start BFS from the dot adjacent to the symbol
    symbol_info = []  # (symbol_col, symbol_row, symbol_color, pair_index)
    pair_to_start = {}  # pair_index -> (r,c) dot adjacent to symbol

    for idx, (color, (r1, c1), (r2, c2)) in enumerate(dot_pairs):
        found = False
        for dot in [(r1, c1), (r2, c2)]:
            sr, sc = dot
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                rr, cc = sr + dr, sc + dc
                if 0 <= rr < height and 0 <= cc < width and grid[rr][cc] in (1, 2):
                    symbol_info.append((cc, rr, grid[rr][cc], idx))
                    pair_to_start[idx] = (sr, sc)
                    found = True
                    break
            if found:
                break
        if not found:
            # fallback: scan whole grid for any symbol and associate it
            for rr in range(height):
                for cc in range(width):
                    if grid[rr][cc] in (1, 2):
                        symbol_info.append((cc, rr, grid[rr][cc], idx))
                        # no adjacent dot known; choose the first dot as start
                        pair_to_start.setdefault(idx, (r1, c1))
                        found = True
                        break
                if found:
                    break

    # sort symbols by column (left-to-right) then row
    symbol_info.sort(key=lambda x: (x[0], x[1]))
    order = [pair_idx for (_, _, _, pair_idx) in symbol_info]

    # Prepare output grid as a copy of input
    output_grid = [row[:] for row in grid]

    # BFS neighbor order must match the generator's order
    dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    for pair_idx in order:
        color, pos1, pos2 = dot_pairs[pair_idx]
        # start at the dot adjacent to the symbol if known; otherwise use pos1
        start = pair_to_start.get(pair_idx, pos1)
        if start == pos1:
            r1, c1 = pos1
            r2, c2 = pos2
        else:
            r1, c1 = start
            # the other dot is the end
            if (r1, c1) == pos1:
                r2, c2 = pos2
            else:
                r2, c2 = pos1

        # BFS avoiding obstacles (6) and other colors (non-zero and not our color)
        visited = [[False] * width for _ in range(height)]
        parent = [[None] * width for _ in range(height)]
        q = deque()
        q.append((r1, c1))
        visited[r1][c1] = True
        found = False
        while q:
            r, c = q.popleft()
            if (r, c) == (r2, c2):
                found = True
                break
            for dr, dc in dirs:
                nr, nc = r + dr, c + dc
                if nr < 0 or nr >= height or nc < 0 or nc >= width: continue
                if visited[nr][nc]: continue
                val = output_grid[nr][nc]
                # can step on empty cells or cells of our own color (start/end), but not onto obstacles or other colors
                if val != 0 and val != color:
                    continue
                visited[nr][nc] = True
                parent[nr][nc] = (r, c)
                q.append((nr, nc))
        if not found:
            # If no path found, return input unchanged (should not happen with generator)
            return tuple(tuple(row) for row in output_grid)

        # reconstruct path
        path = []
        rr, cc = r2, c2
        while True:
            path.append((rr, cc))
            if (rr, cc) == (r1, c1):
                break
            rr, cc = parent[rr][cc]
        path.reverse()

        # draw path on output grid
        for (pr, pc) in path:
            output_grid[pr][pc] = color

    return tuple(tuple(row) for row in output_grid)

