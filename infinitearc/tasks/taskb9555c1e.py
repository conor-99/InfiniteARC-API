# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: b9555c1e
Difficulty: medium–hard

=== Tags ===
- Folded grid reasoning
- Texture transfer
- Binary rule overlay

=== Description ===
# Folded Texture Transfer  Input grids are 2D grids with dimensions between
15×15 and 25×25, featuring a central vertical fold line that divides the grid
into two equal halves. The left half contains a complex texture pattern composed
of alternating colored stripes and dots, with no two adjacent cells sharing the
same color in the pattern. The right half contains a binary mask using two
distinct colors: one color (e.g., red) represents "active" regions where texture
transfer should occur, and another color (e.g., blue) represents "inactive"
regions where the background remains unchanged. The background color is uniform
and distinct from both the texture and mask colors.  The output grid is
generated by transferring the texture pattern from the left half to the right
half while respecting the binary mask. For each cell in the right half, if the
mask color is active (red), the cell in the output takes the color from the
corresponding mirrored position in the left half (e.g., column c in the right
half mirrors to column (width - 1 - c) in the left half). If the mask color is
inactive (blue), the cell retains the background color. The mask itself remains
visible in the output, and the transferred texture precisely aligns with the
mirrored positions without distortion. The transformation requires identifying
the fold line, distinguishing the binary mask colors, and applying the mirror
transformation consistently across the grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.choice([16, 18, 20, 22, 24])
    height = random.randint(15, 25)
    input_grid = grid(width, height, 0)
    texture_colors = [1,4,5,6,7,8,9]
    
    for r in range(height):
        for c in range(width // 2):
            color_idx = (r + c) % len(texture_colors)
            input_grid[r][c] = texture_colors[color_idx]
    
    mask_colors = [2, 3]
    mask_grid = []
    for r in range(height):
        row = []
        for c in range(width // 2):
            row.append(random.choice(mask_colors))
        mask_grid.append(row)
    
    while all(cell == 2 for row in mask_grid for cell in row) or all(cell == 3 for row in mask_grid for cell in row):
        mask_grid = []
        for r in range(height):
            row = []
            for c in range(width // 2):
                row.append(random.choice(mask_colors))
            mask_grid.append(row)
    
    for r in range(height):
        for c in range(width // 2):
            input_grid[r][width // 2 + c] = mask_grid[r][c]
    
    output_grid = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width // 2, width):
            if input_grid[r][c] == 2:
                mirror_c = width - 1 - c
                output_grid[r][c] = input_grid[r][mirror_c]
            elif input_grid[r][c] == 3:
                output_grid[r][c] = 0
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = [list(row) for row in input_grid]
    for r in range(height):
        for c in range(width // 2, width):
            if input_grid[r][c] == 2:
                mirror_c = width - 1 - c
                output_grid[r][c] = input_grid[r][mirror_c]
            elif input_grid[r][c] == 3:
                output_grid[r][c] = 0
    return output_grid
