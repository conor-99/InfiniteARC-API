# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: cca10646
Difficulty: mediumâ€“hard

=== Tags ===
- Example condition induction

=== Description ===
Task Name: Rectangular Region Shrinking  Input grids consist of a background
color (0) and multiple disjoint, 4-connected regions of non-background colors
(1-9). Each region is a contiguous block of cells forming a single color, with
no overlapping regions. The grid may contain both solid rectangular regions
(where all cells within the axis-aligned bounding box of the region are part of
the region) and non-rectangular regions (e.g., L-shaped, T-shaped, or regions
with gaps in their bounding box).  The output grid transforms the input by
shrinking each solid rectangular region by one cell on all sides (i.e., removing
the outermost layer of the rectangle), while leaving all non-rectangular regions
unchanged. For a region to be considered solid and eligible for shrinking, it
must be a rectangle with both width and height greater than 1. Regions that are
1xN or Nx1 (lines) or too small to shrink (e.g., 2x2 becomes 0x0) remain
unchanged. The background color remains unaffected. All transformed regions
maintain their original color.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

# Global counter to reduce chance of duplicate outputs across multiple generate() calls
_CALL_COUNT = 0

def _place_rectangle_if_free(grid, r, c, h, w, color):
    height = len(grid)
    width = len(grid[0])
    if r < 0 or c < 0 or r + h > height or c + w > width:
        return False
    for rr in range(r, r + h):
        for cc in range(c, c + w):
            if grid[rr][cc] != 0:
                return False
    for rr in range(r, r + h):
        for cc in range(c, c + w):
            grid[rr][cc] = color
    return True


def generate():
    """
    Generates an input/output pair for the "Rectangular Region Shrinking" task.

    The generator always places multiple disjoint regions (each with a unique color) on
    a zero background. At least one of the regions is a solid rectangle of size at least
    3x3 (so it will be shrunk). Other regions may be non-solid (e.g. a 3x3 with the
    center cleared) or thin lines/2x2 blocks which should remain unchanged.

    Returns:
      A dict with keys 'input' and 'output' mapping to 2D lists of integers (0..9).
    """
    global _CALL_COUNT
    _CALL_COUNT += 1

    # Grid dimensions (kept moderate so generation and solving are quick)
    height = random.randint(6, 14) + (_CALL_COUNT % 3)
    width = random.randint(6, 14) + ((_CALL_COUNT // 3) % 3)
    height = max(5, min(30, height))
    width = max(5, min(30, width))

    grid = [[0 for _ in range(width)] for _ in range(height)]

    # Decide how many regions to place (at least 2). Use unique colors for regions to
    # avoid accidental merges across regions.
    num_regions = random.randint(2, 5)
    colors = random.sample(list(range(1, 10)), num_regions)

    # Ensure at least one shrinkable solid rectangle (>= 3x3)
    shrinkable_idx = random.randint(0, num_regions - 1)

    regions_info = []  # keep track for debugging / potential adjustments

    for idx, color in enumerate(colors):
        placed = False
        attempts = 0
        # Force one guaranteed shrinkable solid rectangle
        want_solid = (idx == shrinkable_idx)

        while not placed and attempts < 200:
            attempts += 1
            # Decide region type and size
            if want_solid:
                # Solid rectangle with both dimensions >= 3 to be shrinkable
                h = random.randint(3, min(7, height))
                w = random.randint(3, min(7, width))
                r = random.randint(0, height - h)
                c = random.randint(0, width - w)
                if _place_rectangle_if_free(grid, r, c, h, w, color):
                    placed = True
                    regions_info.append((color, 'solid', r, c, h, w))
                    break
            else:
                # Randomly choose a variant: solid (but possibly too small to shrink),
                # non-solid (center removed), or 1xN / Nx1 line
                choice = random.random()
                if choice < 0.35:
                    # Solid but possibly small (2x2 etc.)
                    h = random.randint(2, min(6, height))
                    w = random.randint(2, min(6, width))
                    r = random.randint(0, height - h)
                    c = random.randint(0, width - w)
                    if _place_rectangle_if_free(grid, r, c, h, w, color):
                        placed = True
                        regions_info.append((color, 'solid_small', r, c, h, w))
                        break
                elif choice < 0.75:
                    # Non-solid: start with a 3x3 or 4x3 block and clear the center to
                    # make it non-rectangular while keeping it 4-connected.
                    h = random.choice([3, 3, 4])
                    w = random.choice([3, 3, 4])
                    if h > height or w > width:
                        continue
                    r = random.randint(0, height - h)
                    c = random.randint(0, width - w)
                    # Check free area
                    free = True
                    for rr in range(r, r + h):
                        for cc in range(c, c + w):
                            if grid[rr][cc] != 0:
                                free = False
                                break
                        if not free:
                            break
                    if not free:
                        continue
                    # Fill block
                    for rr in range(r, r + h):
                        for cc in range(c, c + w):
                            grid[rr][cc] = color
                    # Carve a center hole or remove a single inside cell to break solidity
                    if h >= 3 and w >= 3:
                        center_r = r + h // 2
                        center_c = c + w // 2
                        grid[center_r][center_c] = 0
                    else:
                        # Remove a corner/edge cell to keep connectedness
                        grid[r][c] = 0
                    placed = True
                    regions_info.append((color, 'non_solid', r, c, h, w))
                    break
                else:
                    # Line: horizontal or vertical
                    if random.random() < 0.5:
                        length = random.randint(2, min(7, width))
                        r = random.randint(0, height - 1)
                        c = random.randint(0, width - length)
                        free = True
                        for cc in range(c, c + length):
                            if grid[r][cc] != 0:
                                free = False
                                break
                        if not free:
                            continue
                        for cc in range(c, c + length):
                            grid[r][cc] = color
                        placed = True
                        regions_info.append((color, 'hline', r, c, 1, length))
                        break
                    else:
                        length = random.randint(2, min(7, height))
                        r = random.randint(0, height - length)
                        c = random.randint(0, width - 1)
                        free = True
                        for rr in range(r, r + length):
                            if grid[rr][c] != 0:
                                free = False
                                break
                        if not free:
                            continue
                        for rr in range(r, r + length):
                            grid[rr][c] = color
                        placed = True
                        regions_info.append((color, 'vline', r, c, length, 1))
                        break
        # If we failed to place this region after many attempts, just skip it.

    # Now compute the output by shrinking each solid rectangular region by removing
    # the outermost layer (one cell thick) on all four sides. Non-solid regions and
    # rectangles that are too small to shrink (width < 3 or height < 3) remain
    # unchanged.
    output_grid = [row[:] for row in grid]
    height = len(grid)
    width = len(grid[0])
    visited = [[False] * width for _ in range(height)]

    for r0 in range(height):
        for c0 in range(width):
            if grid[r0][c0] == 0 or visited[r0][c0]:
                continue
            color = grid[r0][c0]
            # Flood fill to get this connected region
            stack = [(r0, c0)]
            region = []
            visited[r0][c0] = True
            while stack:
                r, c = stack.pop()
                region.append((r, c))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))

            min_r = min(rr for rr, cc in region)
            max_r = max(rr for rr, cc in region)
            min_c = min(cc for rr, cc in region)
            max_c = max(cc for rr, cc in region)
            box_h = max_r - min_r + 1
            box_w = max_c - min_c + 1

            # Check if the bounding box is completely filled with this color
            is_solid = True
            for rr in range(min_r, max_r + 1):
                for cc in range(min_c, max_c + 1):
                    if grid[rr][cc] != color:
                        is_solid = False
                        break
                if not is_solid:
                    break

            # Only shrink if the bounding box is solid and large enough to keep an
            # interior after removing the outermost layer (i.e., both dims >= 3)
            if is_solid and box_h >= 3 and box_w >= 3:
                # Remove left and right columns of the rectangle
                for rr in range(min_r, max_r + 1):
                    output_grid[rr][min_c] = 0
                    output_grid[rr][max_c] = 0
                # Remove top and bottom rows of the rectangle
                for cc in range(min_c, max_c + 1):
                    output_grid[min_r][cc] = 0
                    output_grid[max_r][cc] = 0

    return {'input': grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input (tuple of tuples) to a mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0
    output = [row[:] for row in grid]

    visited = [[False] * width for _ in range(height)]

    for r0 in range(height):
        for c0 in range(width):
            if grid[r0][c0] == 0 or visited[r0][c0]:
                continue
            color = grid[r0][c0]
            # Flood fill to collect this connected region
            stack = [(r0, c0)]
            region = []
            visited[r0][c0] = True
            while stack:
                r, c = stack.pop()
                region.append((r, c))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))

            min_r = min(rr for rr, cc in region)
            max_r = max(rr for rr, cc in region)
            min_c = min(cc for rr, cc in region)
            max_c = max(cc for rr, cc in region)
            box_h = max_r - min_r + 1
            box_w = max_c - min_c + 1

            # Check if the bounding box is completely filled with this color
            is_solid = True
            for rr in range(min_r, max_r + 1):
                for cc in range(min_c, max_c + 1):
                    if grid[rr][cc] != color:
                        is_solid = False
                        break
                if not is_solid:
                    break

            # Shrink only if it's a solid rectangle and large enough (both dims >= 3)
            if is_solid and box_h >= 3 and box_w >= 3:
                for rr in range(min_r, max_r + 1):
                    output[rr][min_c] = 0
                    output[rr][max_c] = 0
                for cc in range(min_c, max_c + 1):
                    output[min_r][cc] = 0
                    output[max_r][cc] = 0

    return output

