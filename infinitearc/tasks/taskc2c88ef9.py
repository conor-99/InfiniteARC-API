# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: c2c88ef9
Difficulty: hard

=== Tags ===
- Color permutation
- Periodic boundary conditions
- Fill shape with tiling

=== Description ===
The input grid contains a single connected region (shape) defined by a specific
non-zero color, while all other cells are background (color 0). The output grid
fills this shape with a repeating 2×2 tile pattern whose colors are a right-
rotated permutation of the base sequence [0, 1, 2, 3], determined by the shape's
color value C. The rotation amount is C positions (with modulo 4 applied for
values ≥4), creating a deterministic color mapping. For example, a shape color
of 2 results in the tile sequence [2, 3, 0, 1]. Each cell within the shape is
filled by indexing the permuted tile using the cell's coordinates modulo 2
(i.e., output[r][c] = tile[r % 2][c % 2]). The background remains color 0. The
transformation relies on recognizing the shape's color, computing the rotation-
based color permutation, and applying the periodic tiling pattern across the
shape's boundary, which must be discovered through analysis of multiple input-
output pairs featuring complex, irregularly shaped regions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

from common import continuous_creature
import random
def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    C = random.randint(1, 9)
    shape_size = random.randint(2, min(50, width * height))
    shape_pixels = continuous_creature(shape_size, width, height)
    
    input_grid = [[0] * width for _ in range(height)]
    for (r, c) in shape_pixels:
        input_grid[r][c] = C
    
    rotation = C % 4
    base = [0, 1, 2, 3]
    rotated = base[-rotation:] + base[:-rotation]
    tile = [[rotated[0], rotated[1]], [rotated[2], rotated[3]]]
    
    output_grid = [[0] * width for _ in range(height)]
    for (r, c) in shape_pixels:
        output_grid[r][c] = tile[r % 2][c % 2]
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    
    C = None
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                C = input_grid[r][c]
                break
        if C is not None:
            break
    
    if C is None:
        return [[0] * width for _ in range(height)]
    
    rotation = C % 4
    base = [0, 1, 2, 3]
    rotated = base[-rotation:] + base[:-rotation]
    tile = [[rotated[0], rotated[1]], [rotated[2], rotated[3]]]
    
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                output_grid[r][c] = tile[r % 2][c % 2]
    
    return output_grid
