# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: d9463ae5
Difficulty: mediumâ€“hard

=== Tags ===
- Coordinate system translation
- Hierarchical repetition

=== Description ===
Input grids feature a primary coordinate system defined by red horizontal and
blue vertical lines, dividing the grid into reference cells. Within each cell,
nested hierarchical patterns are embedded, where each pattern's position is
defined relative to its parent cell's local coordinate system. The output grid
must perform two key transformations: first, translate all nested patterns'
local coordinates to absolute positions in the main coordinate system by summing
parent cell offsets with local offsets; second, hierarchically repeat the entire
pattern structure at each level of nesting, scaling each repetition to align
with the main grid's axes. This creates a self-similar, fractal-like expansion
where each level of hierarchy is replicated and positioned according to the main
coordinate system, preserving all visual relationships while eliminating
coordinate offsets. The output grid's structure must reflect recursive scaling
without overlapping elements, with all patterns visually aligned to the red and
blue reference lines.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import itertools
from common import grid

def generate():
    max_attempts = 1000
    for attempt in range(max_attempts):
        width = random.randint(10, 20)
        height = random.randint(10, 20)
        # Choose number of lines
        max_h_lines = min(4, height - 2)
        max_v_lines = min(4, width - 2)
        if max_h_lines < 2 or max_v_lines < 2:
            continue
        h_count = random.randint(2, max_h_lines)
        v_count = random.randint(2, max_v_lines)
        h_lines = sorted(random.sample(range(1, height - 1), h_count))
        v_lines = sorted(random.sample(range(1, width - 1), v_count))
        # Create grid and draw vertical lines first then horizontal lines so horizontals overwrite intersections
        ingrid = grid(width, height, 0)
        for c in v_lines:
            for r in range(height):
                ingrid[r][c] = 1
        for r in h_lines:
            for c in range(width):
                ingrid[r][c] = 2
        # Compute row/col segments between lines
        row_bounds = [-1] + h_lines + [height]
        row_segments = []
        for i in range(len(row_bounds)-1):
            start = row_bounds[i] + 1
            end = row_bounds[i+1] - 1
            if start <= end:
                row_segments.append((start, end))
        col_bounds = [-1] + v_lines + [width]
        col_segments = []
        for i in range(len(col_bounds)-1):
            start = col_bounds[i] + 1
            end = col_bounds[i+1] - 1
            if start <= end:
                col_segments.append((start, end))
        # ensure minimal cell size
        min_cell_h = min((end - start + 1) for start, end in row_segments)
        min_cell_w = min((end - start + 1) for start, end in col_segments)
        if min_cell_h < 2 or min_cell_w < 2:
            continue
        # Allowed local coordinates (relative to a cell origin) to place template in the input
        allowed_rows = [r for r in range(0, min_cell_h) if r not in h_lines]
        allowed_cols = [c for c in range(0, min_cell_w) if c not in v_lines]
        if not allowed_rows or not allowed_cols:
            continue
        # choose pattern points
        max_points = min(4, len(allowed_rows) * len(allowed_cols))
        n_points = random.randint(1, max_points)
        all_allowed = [(r, c) for r in allowed_rows for c in allowed_cols]
        pattern_points = random.sample(all_allowed, n_points)
        # place pattern points in input at their local coordinates (as though the local origin is (0,0) of the whole grid)
        for (pr, pc) in pattern_points:
            # make sure we don't overwrite lines (shouldn't because of allowed rows/cols)
            if ingrid[pr][pc] == 0:
                ingrid[pr][pc] = 3
            else:
                # if something unexpected there, try next attempt
                break
        else:
            # compute cell origins (top-left of each cell)
            row_starts = [start for start, end in row_segments]
            col_starts = [start for start, end in col_segments]
            origins = [(rs, cs) for rs in row_starts for cs in col_starts]
            # create output as a copy of ingrid
            output = [row[:] for row in ingrid]
            # hierarchical replication depth (fixed to 2 so solver can infer)
            depth = 2
            # for each repetition depth, sum origins and place pattern
            for k in range(1, depth + 1):
                for origin_seq in itertools.product(origins, repeat=k):
                    sum_r = sum(o[0] for o in origin_seq)
                    sum_c = sum(o[1] for o in origin_seq)
                    for (pr, pc) in pattern_points:
                        rr = sum_r + pr
                        cc = sum_c + pc
                        if 0 <= rr < height and 0 <= cc < width:
                            # do not overwrite reference lines
                            if rr in h_lines or cc in v_lines:
                                continue
                            output[rr][cc] = 3
            # ensure input and output are not identical
            if output != ingrid:
                return {'input': ingrid, 'output': output}
    # fallback (shouldn't happen)
    # simple default small grid
    ingrid = grid(10, 10, 0)
    for r in range(3, 6):
        for c in range(10):
            ingrid[r][c] = 2
    for c in range(2, 5):
        for r in range(10):
            ingrid[r][c] = 1
    ingrid[1][1] = 3
    out = [row[:] for row in ingrid]
    out[4][3] = 3
    return {'input': ingrid, 'output': out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    import itertools
    # convert to list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    # detect horizontal lines: rows where every cell equals 2 (horizontal drawn last)
    h_lines = [r for r in range(height) if all(grid[r][c] == 2 for c in range(width))]
    # detect vertical lines: columns where every cell is nonzero (vertical drawn first)
    v_lines = [c for c in range(width) if all(grid[r][c] != 0 for r in range(height))]
    # build row and column segments
    row_bounds = [-1] + h_lines + [height]
    row_segments = []
    for i in range(len(row_bounds)-1):
        start = row_bounds[i] + 1
        end = row_bounds[i+1] - 1
        if start <= end:
            row_segments.append((start, end))
    col_bounds = [-1] + v_lines + [width]
    col_segments = []
    for i in range(len(col_bounds)-1):
        start = col_bounds[i] + 1
        end = col_bounds[i+1] - 1
        if start <= end:
            col_segments.append((start, end))
    # pattern points: any cell that is not background(0) or one of the reference line colors (1 or 2)
    pattern_points = []
    pattern_colors = {}
    for r in range(height):
        for c in range(width):
            val = grid[r][c]
            if val != 0 and val not in (1, 2):
                pattern_points.append((r, c))
                pattern_colors[(r, c)] = val
    # compute origins as top-left of each cell
    row_starts = [start for start, end in row_segments]
    col_starts = [start for start, end in col_segments]
    origins = [(rs, cs) for rs in row_starts for cs in col_starts]
    # prepare output: draw verticals then horizontals (same order used by generator)
    out = [[0 for _ in range(width)] for _ in range(height)]
    for c in v_lines:
        for r in range(height):
            out[r][c] = 1
    for r in h_lines:
        for c in range(width):
            out[r][c] = 2
    # hierarchical replication depth is fixed to 2
    depth = 2
    # pattern_points are given in input as local coordinates (their positions are the local offsets)
    # but pattern_points list currently contains absolute positions of these local offsets.
    # Use those as local offsets
    local_points = [(r, c, pattern_colors[(r, c)]) for (r, c) in pattern_points]
    for k in range(1, depth + 1):
        for origin_seq in itertools.product(origins, repeat=k):
            sum_r = sum(o[0] for o in origin_seq)
            sum_c = sum(o[1] for o in origin_seq)
            for (pr, pc, color) in local_points:
                rr = sum_r + pr
                cc = sum_c + pc
                if 0 <= rr < height and 0 <= cc < width:
                    # do not overwrite reference lines
                    if rr in h_lines or cc in v_lines:
                        continue
                    out[rr][cc] = color
    return out

