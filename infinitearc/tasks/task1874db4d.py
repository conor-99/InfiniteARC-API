# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 1874db4d
Difficulty: medium

=== Tags ===
- Local convolution rule
- Ex nihilo
- Take negative
- Count tiles

=== Description ===
The task involves transforming an input grid into an output grid based on a
local convolution rule that operates on zero-valued cells. For each cell in the
input grid that contains a 0 (indicating an empty space), the corresponding
output cell is computed as 9 minus the count of non-zero neighboring cells
within the 3x3 neighborhood centered at that position. Non-zero cells remain
unchanged in the output. This process uses the "ex nihilo" principle to generate
new values from empty spaces, applies a "take negative" operation via the 9
minus count, and relies on "count tiles" to determine the number of non-zero
neighboring cells (treated as "tiles"). The rule is consistent across all grids,
requiring the solver to recognize that only zero cells are modified based on
their immediate context, while non-zero cells are preserved.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
    if all(cell != 0 for row in input_grid for cell in row):
        r, c = random.randint(0, height-1), random.randint(0, width-1)
        input_grid[r][c] = 0
    output_grid = [[0] * width for _ in range(height)]
    for i in range(height):
        for j in range(width):
            if input_grid[i][j] == 0:
                count = 0
                for dx in (-1, 0, 1):
                    for dy in (-1, 0, 1):
                        ni, nj = i + dx, j + dy
                        if 0 <= ni < height and 0 <= nj < width and input_grid[ni][nj] != 0:
                            count += 1
                output_grid[i][j] = 9 - count
            else:
                output_grid[i][j] = input_grid[i][j]
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input):
    height = len(input)
    width = len(input[0])
    output = [[0] * width for _ in range(height)]
    for i in range(height):
        for j in range(width):
            if input[i][j] == 0:
                count = 0
                for dx in (-1, 0, 1):
                    for dy in (-1, 0, 1):
                        ni, nj = i + dx, j + dy
                        if 0 <= ni < height and 0 <= nj < width and input[ni][nj] != 0:
                            count += 1
                output[i][j] = 9 - count
            else:
                output[i][j] = input[i][j]
    return output
