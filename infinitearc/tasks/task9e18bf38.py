# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 9e18bf38
Difficulty: hard

=== Tags ===
- Pattern sync
- Exclusive or coloring
- Bridges

=== Description ===
The input grid features a background of color 0, with multiple distinct colored
regions (each a connected cluster of a single color from 1-9) separated by gaps
filled with background. Between certain regions, "bridge" structures
exist—horizontal or vertical lines of cells in a unique bridge color (distinct
from all region colors and never used elsewhere in the grid). The bridge color
is fixed per grid and serves as the sole indicator of connectivity.  The output
grid applies two core transformations. First, "exclusive or coloring" identifies
invalid bridges: a bridge is removed (replaced with background) if its color
matches either connected region’s color. Valid bridges (where bridge color
differs from both regions) are retained. Second, "pattern sync" realigns regions
connected by valid bridges: regions are shifted horizontally or vertically to
align their endpoints, forming a continuous path without gaps. Invalid bridges
are removed, and regions are adjusted to ensure only valid bridges remain,
resulting in a grid where all bridges connect regions of colors exclusive to the
bridge color, creating a synchronized, gap-free pattern of connected regions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    """
    Generate an ARC-style input/output pair according to the task description.
    The generator places N rectangular connected regions (color 1-9) in a single row
    band across the grid with gaps between them. It draws horizontal bridges (single-color
    straight segments) between adjacent regions. The bridge color is constant for the grid
    and is chosen to be distinct from all region colors to make it unambiguous.

    The output removes any invalid bridges (if bridge color matched a region color —
    impossible here because we choose the bridge color distinct) and shifts connected regions
    horizontally so that their endpoints align with the bridge endpoints, creating a continuous path.
    """
    # Try repeatedly until a valid configuration is built (fits constraints)
    for _attempt in range(100):
        width = random.randint(12, 20)
        height = random.randint(12, 20)
        # number of regions (kept small but >=3 to create complexity)
        n_regions = random.randint(3, 4)

        # Choose region sizes
        region_ws = [random.randint(2, 4) for _ in range(n_regions)]
        region_hs = [random.randint(2, 4) for _ in range(n_regions)]

        # Minimum inter-region gap to allow bridges that don't touch region edges
        min_gap = 4

        # Quick feasibility check: do the boxes + min gaps fit the width with margins
        sum_region_widths = sum(region_ws)
        if sum_region_widths + (n_regions - 1) * min_gap + 2 > width:
            # won't fit, try again
            continue

        # Allocate gaps between regions so total fits exactly in the grid
        available_between = width - sum_region_widths - 2  # leaving 1-cell margins left and right
        # initialize internal gaps with min_gap each
        internal_gaps = [min_gap for _ in range(n_regions - 1)]
        leftover = available_between - sum(internal_gaps)
        # distribute leftover randomly across gaps
        for _ in range(leftover):
            idx = random.randrange(len(internal_gaps))
            internal_gaps[idx] += 1

        # compute left positions
        lefts = []
        x = 1  # left margin
        for i in range(n_regions):
            lefts.append(x)
            x += region_ws[i]
            if i < n_regions - 1:
                x += internal_gaps[i]

        # vertical placement: choose a base row so all regions roughly share a band -> ensures overlap
        max_h = max(region_hs)
        if height - max_h - 1 < 1:
            continue
        band_top = random.randint(1, height - max_h - 1)
        tops = []
        for i in range(n_regions):
            # small vertical jitter but keep within band to ensure overlap
            jitter = random.randint(-1, 1)
            top = band_top + jitter
            top = max(1, min(top, height - region_hs[i] - 1))
            tops.append(top)

        # assign region colors (single color per region). Allow repeats
        region_colors = [random.randint(1, 9) for _ in range(n_regions)]

        # pick a global bridge color distinct from all region colors (to avoid ambiguity)
        available_colors = [c for c in range(1, 10) if c not in region_colors]
        if not available_colors:
            continue
        bridge_color = random.choice(available_colors)

        # Build the input grid and record region pixel lists
        grid_in = [[0 for _ in range(width)] for _ in range(height)]
        region_pixels = []
        for i in range(n_regions):
            pixels = []
            for r in range(tops[i], tops[i] + region_hs[i]):
                for c in range(lefts[i], lefts[i] + region_ws[i]):
                    grid_in[r][c] = region_colors[i]
                    pixels.append((r, c))
            region_pixels.append(pixels)

        # create bridges between adjacent regions (i, i+1)
        bridges = []  # tuples (left_index, right_index, row, start_col, end_col)
        for i in range(n_regions - 1):
            a_right = lefts[i] + region_ws[i] - 1
            b_left = lefts[i + 1]
            gap = b_left - a_right - 1
            # there should be at least min_gap cells between boxes by construction
            if gap < min_gap:
                continue
            # choose a row inside the overlap band of both regions
            r_low = max(tops[i], tops[i + 1])
            r_high = min(tops[i] + region_hs[i] - 1, tops[i + 1] + region_hs[i + 1] - 1)
            if r_low > r_high:
                # unexpected, but skip this bridge
                continue
            r = random.randint(r_low, r_high)
            # choose start and end inside the gap but not immediately adjacent to the regions
            start_min = a_right + 2
            end_max = b_left - 2
            if start_min > end_max:
                continue
            start = random.randint(start_min, end_max)
            # small bridge length (1-3) but ensure it stays inside start..end_max
            end = start + random.randint(0, min(2, end_max - start))
            # paint bridge cells
            for c in range(start, end + 1):
                grid_in[r][c] = bridge_color
            bridges.append((i, i + 1, r, start, end))

        if not bridges:
            # generate again
            continue

        # Build the output by simulating the two transformation steps
        grid_out = [row[:] for row in grid_in]
        # keep region pixel sets (mutable) for shifting
        region_sets = [set(pix_list) for pix_list in region_pixels]

        # process bridges left-to-right (by start column) to apply deterministic shifts
        bridges = sorted(bridges, key=lambda t: t[3])
        for a_idx, b_idx, r, start, end in bridges:
            colA = region_colors[a_idx]
            colB = region_colors[b_idx]
            # invalid bridge if bridge color matches either region color (impossible here)
            if bridge_color == colA or bridge_color == colB:
                # remove bridge cells
                for c in range(start, end + 1):
                    grid_out[r][c] = 0
                continue

            # Find rightmost column of region A on row r (there should be at least one because of overlap)
            cols_on_row_A = [c for (rr, c) in region_sets[a_idx] if rr == r]
            if not cols_on_row_A:
                # as a fallback, use overall rightmost column
                max_col_A = max(c for (_, c) in region_sets[a_idx])
            else:
                max_col_A = max(cols_on_row_A)
            gapA = start - max_col_A - 1
            if gapA > 0:
                # move region A right by gapA
                newA = set()
                for (rr, cc) in region_sets[a_idx]:
                    new_cc = cc + gapA
                    newA.add((rr, new_cc))
                # clear old cells
                for (rr, cc) in list(region_sets[a_idx]):
                    if 0 <= rr < height and 0 <= cc < width and grid_out[rr][cc] == colA:
                        grid_out[rr][cc] = 0
                # paint new cells
                for (rr, cc) in newA:
                    if 0 <= rr < height and 0 <= cc < width:
                        grid_out[rr][cc] = colA
                region_sets[a_idx] = newA

            # Find leftmost column of region B on row r
            cols_on_row_B = [c for (rr, c) in region_sets[b_idx] if rr == r]
            if not cols_on_row_B:
                min_col_B = min(c for (_, c) in region_sets[b_idx])
            else:
                min_col_B = min(cols_on_row_B)
            gapB = min_col_B - end - 1
            if gapB > 0:
                newB = set()
                for (rr, cc) in region_sets[b_idx]:
                    new_cc = cc - gapB
                    newB.add((rr, new_cc))
                # clear old cells
                for (rr, cc) in list(region_sets[b_idx]):
                    if 0 <= rr < height and 0 <= cc < width and grid_out[rr][cc] == colB:
                        grid_out[rr][cc] = 0
                # paint new cells
                for (rr, cc) in newB:
                    if 0 <= rr < height and 0 <= cc < width:
                        grid_out[rr][cc] = colB
                region_sets[b_idx] = newB

        # Final sanity: ensure input != output
        if grid_in != grid_out:
            return {"input": grid_in, "output": grid_out}

    # If we failed to create a valid case in many attempts, fall back to a minimal example
    width, height = 10, 10
    grid_in = [[0] * width for _ in range(height)]
    grid_out = [[0] * width for _ in range(height)]
    return {"input": grid_in, "output": grid_out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Helper: get 4-connected components per color
    from collections import deque

    visited = [[False] * width for _ in range(height)]
    components_by_color = {}  # color -> list of components (each a list of (r,c))
    for r in range(height):
        for c in range(width):
            color = grid[r][c]
            if color == 0 or visited[r][c]:
                continue
            # BFS
            que = deque([(r, c)])
            visited[r][c] = True
            comp = []
            while que:
                rr, cc = que.popleft()
                comp.append((rr, cc))
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                        visited[nr][nc] = True
                        que.append((nr, nc))
            components_by_color.setdefault(color, []).append(comp)

    # Detect bridge color: choose a color that has at least one 'line' component
    bridge_color = None
    candidates = []
    for color, comps in components_by_color.items():
        if color == 0:
            continue
        line_pixels = 0
        for comp in comps:
            rs = [p[0] for p in comp]
            cs = [p[1] for p in comp]
            rmin, rmax = min(rs), max(rs)
            cmin, cmax = min(cs), max(cs)
            if rmin == rmax or cmin == cmax:
                # this component is a straight line (thin)
                line_pixels += len(comp)
        if line_pixels > 0:
            candidates.append((color, line_pixels))
    if not candidates:
        # nothing to do
        return grid
    # choose the color whose line-like components cover the most pixels
    bridge_color = max(candidates, key=lambda x: x[1])[0]

    # prepare output grid starting from input; we'll mutate it
    out = [row[:] for row in grid]

    # build a flat list of region components (color != bridge_color)
    region_components = {}  # color -> list of sets (component pixel sets)
    for color, comps in components_by_color.items():
        if color == bridge_color:
            continue
        region_components[color] = [set(comp) for comp in comps]

    # Process each bridge-component: determine orientation, endpoints and connected regions
    bridge_comps = components_by_color.get(bridge_color, [])
    valid_bridges = []  # list of tuples: (orientation, pos, start, end, colorA, colorB)

    for comp in bridge_comps:
        rs = [p[0] for p in comp]
        cs = [p[1] for p in comp]
        rmin, rmax = min(rs), max(rs)
        cmin, cmax = min(cs), max(cs)
        if rmin == rmax:
            # horizontal
            r = rmin
            start, end = cmin, cmax
            # scan left from start-1 to find a non-zero non-bridge color
            left_color = None
            for cc in range(start - 1, -1, -1):
                val = out[r][cc]
                if val != 0 and val != bridge_color:
                    left_color = val
                    break
            right_color = None
            for cc in range(end + 1, width):
                val = out[r][cc]
                if val != 0 and val != bridge_color:
                    right_color = val
                    break
            # invalid if one side missing or bridge color matches either side
            if left_color is None or right_color is None:
                for cc in range(start, end + 1):
                    out[r][cc] = 0
                continue
            if left_color == bridge_color or right_color == bridge_color:
                for cc in range(start, end + 1):
                    out[r][cc] = 0
                continue
            valid_bridges.append(("horizontal", r, start, end, left_color, right_color))
        else:
            # vertical
            c = cmin
            start, end = rmin, rmax
            top_color = None
            for rr in range(start - 1, -1, -1):
                val = out[rr][c]
                if val != 0 and val != bridge_color:
                    top_color = val
                    break
            bottom_color = None
            for rr in range(end + 1, height):
                val = out[rr][c]
                if val != 0 and val != bridge_color:
                    bottom_color = val
                    break
            if top_color is None or bottom_color is None:
                for rr in range(start, end + 1):
                    out[rr][c] = 0
                continue
            if top_color == bridge_color or bottom_color == bridge_color:
                for rr in range(start, end + 1):
                    out[rr][c] = 0
                continue
            valid_bridges.append(("vertical", c, start, end, top_color, bottom_color))

    # Now apply pattern-sync shifts for valid bridges (order by the bridge start coordinate to be deterministic)
    valid_bridges = sorted(valid_bridges, key=lambda b: b[2])

    for br in valid_bridges:
        if br[0] == "horizontal":
            _, r, start, end, colorA, colorB = br
            # find the component (set) of colorA that is closest on the left (max column < start)
            compsA = region_components.get(colorA, [])
            best_idx = None
            best_dist = None
            for idx, comp in enumerate(compsA):
                # prefer a component that has pixels on row r
                cols_on_row = [c for (rr, c) in comp if rr == r]
                if cols_on_row:
                    col_max = max(cols_on_row)
                else:
                    col_max = max(c for (_, c) in comp)
                if col_max < start:
                    dist = start - col_max
                    if best_dist is None or dist < best_dist:
                        best_dist = dist
                        best_idx = idx
            if best_idx is None:
                # can't find a suitable component; skip
                continue
            compA = compsA[best_idx]
            # compute shift for A
            cols_on_row = [c for (rr, c) in compA if rr == r]
            if cols_on_row:
                max_col_A = max(cols_on_row)
            else:
                max_col_A = max(c for (_, c) in compA)
            shiftA = start - max_col_A - 1
            if shiftA > 0:
                # clear old pixels
                for (rr, cc) in list(compA):
                    if 0 <= rr < height and 0 <= cc < width and out[rr][cc] == colorA:
                        out[rr][cc] = 0
                # write new positions
                newA = set()
                for (rr, cc) in compA:
                    new_cc = cc + shiftA
                    if 0 <= rr < height and 0 <= new_cc < width:
                        out[rr][new_cc] = colorA
                        newA.add((rr, new_cc))
                region_components[colorA][best_idx] = newA

            # now handle colorB (right region)
            compsB = region_components.get(colorB, [])
            best_idx = None
            best_dist = None
            for idx, comp in enumerate(compsB):
                cols_on_row = [c for (rr, c) in comp if rr == r]
                if cols_on_row:
                    col_min = min(cols_on_row)
                else:
                    col_min = min(c for (_, c) in comp)
                if col_min > end:
                    dist = col_min - end
                    if best_dist is None or dist < best_dist:
                        best_dist = dist
                        best_idx = idx
            if best_idx is None:
                continue
            compB = compsB[best_idx]
            cols_on_row = [c for (rr, c) in compB if rr == r]
            if cols_on_row:
                min_col_B = min(cols_on_row)
            else:
                min_col_B = min(c for (_, c) in compB)
            shiftB = min_col_B - end - 1
            if shiftB > 0:
                for (rr, cc) in list(compB):
                    if 0 <= rr < height and 0 <= cc < width and out[rr][cc] == colorB:
                        out[rr][cc] = 0
                newB = set()
                for (rr, cc) in compB:
                    new_cc = cc - shiftB
                    if 0 <= rr < height and 0 <= new_cc < width:
                        out[rr][new_cc] = colorB
                        newB.add((rr, new_cc))
                region_components[colorB][best_idx] = newB

        else:  # vertical
            _, c, start, end, colorA, colorB = br
            # colorA is top region, colorB bottom region
            compsA = region_components.get(colorA, [])
            best_idx = None
            best_dist = None
            for idx, comp in enumerate(compsA):
                rows_on_col = [r for (r, cc) in comp if cc == c]
                if rows_on_col:
                    row_max = max(rows_on_col)
                else:
                    row_max = max(r for (r, _) in comp)
                if row_max < start:
                    dist = start - row_max
                    if best_dist is None or dist < best_dist:
                        best_dist = dist
                        best_idx = idx
            if best_idx is None:
                continue
            compA = compsA[best_idx]
            rows_on_col = [r for (r, cc) in compA if cc == c]
            if rows_on_col:
                max_row_A = max(rows_on_col)
            else:
                max_row_A = max(r for (r, _) in compA)
            shiftA = start - max_row_A - 1
            if shiftA > 0:
                for (rr, cc) in list(compA):
                    if 0 <= rr < height and 0 <= cc < width and out[rr][cc] == colorA:
                        out[rr][cc] = 0
                newA = set()
                for (rr, cc) in compA:
                    new_rr = rr + shiftA
                    if 0 <= new_rr < height and 0 <= cc < width:
                        out[new_rr][cc] = colorA
                        newA.add((new_rr, cc))
                region_components[colorA][best_idx] = newA

            compsB = region_components.get(colorB, [])
            best_idx = None
            best_dist = None
            for idx, comp in enumerate(compsB):
                rows_on_col = [r for (r, cc) in comp if cc == c]
                if rows_on_col:
                    row_min = min(rows_on_col)
                else:
                    row_min = min(r for (r, _) in comp)
                if row_min > end:
                    dist = row_min - end
                    if best_dist is None or dist < best_dist:
                        best_dist = dist
                        best_idx = idx
            if best_idx is None:
                continue
            compB = compsB[best_idx]
            rows_on_col = [r for (r, cc) in compB if cc == c]
            if rows_on_col:
                min_row_B = min(rows_on_col)
            else:
                min_row_B = min(r for (r, _) in compB)
            shiftB = min_row_B - end - 1
            if shiftB > 0:
                for (rr, cc) in list(compB):
                    if 0 <= rr < height and 0 <= cc < width and out[rr][cc] == colorB:
                        out[rr][cc] = 0
                newB = set()
                for (rr, cc) in compB:
                    new_rr = rr - shiftB
                    if 0 <= new_rr < height and 0 <= cc < width:
                        out[new_rr][cc] = colorB
                        newB.add((new_rr, cc))
                region_components[colorB][best_idx] = newB

    return out

