# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 2d464fdb
Difficulty: easy

=== Tags ===
- Jigsaw
- Color majority row
- Pattern expansion

=== Description ===
The input grid consists of a 2D arrangement of colors where each row has a clear
dominant color (the most frequently appearing color in that row). For each row,
the dominant color is identified, and the output grid is generated by replacing
every cell in the input row with a 2x2 block of that row's dominant color. This
transforms the grid into a larger output grid with dimensions doubled in both
width and height, where each output row corresponds to two identical rows filled
entirely with the dominant color of the input row. The transformation is visual
and relies solely on the dominant color per row, with no numerical calculations
or pixel-level matching required. The output grid is always distinct from the
input due to the uniform expansion of colors.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    h = random.randint(1, 15)
    w = random.randint(1, 15)
    input_grid = []
    for _ in range(h):
        dominant = random.randint(0, 9)
        m = (w // 2) + 1
        remaining = w - m
        row = [dominant] * m
        if remaining > 0:
            non_dominant = [x for x in range(10) if x != dominant]
            row += random.choices(non_dominant, k=remaining)
        random.shuffle(row)
        input_grid.append(row)
    output_grid = []
    for i in range(h):
        row = input_grid[i]
        counts = [row.count(c) for c in range(10)]
        dominant = counts.index(max(counts))
        output_row = [dominant] * (2 * w)
        output_grid.append(output_row)
        output_grid.append(output_row)
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    h = len(input_grid)
    w = len(input_grid[0])
    output_grid = []
    for i in range(h):
        row = input_grid[i]
        counts = [row.count(c) for c in range(10)]
        dominant = counts.index(max(counts))
        output_row = [dominant] * (2 * w)
        output_grid.append(output_row)
        output_grid.append(output_row)
    return output_grid
