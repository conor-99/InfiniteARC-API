# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 94330575
Difficulty: very hard

=== Tags ===
- Cascade fountain
- Zigzag path
- Nested structure detection
- Trim trailing background

=== Description ===
Input grids feature a background color (e.g., 0) overlaid with multiple
concentric, axis-aligned rectangles of distinct colors (1-9), each fully
contained within the previous layer with at least one background cell separating
them. Rectangles are positioned such that their top-left corner aligns with the
grid's top-left edge, creating a nested hierarchy from outermost to innermost.
The output grid transformation requires four sequential steps:   1. **Nested
structure detection**: Identify all rectangles in order from outermost to
innermost, noting their colors and positions.   2. **Zigzag path generation**:
Trace a path starting at the top-left corner of the outermost rectangle, moving
right through background gaps between layers, then down, alternating direction
at each layer boundary (e.g., right → down → right → down). The path must
navigate gaps without intersecting rectangle borders.   3. **Cascade coloring**:
Each segment of the zigzag path between nested layers is filled with the *inner*
rectangle's color (e.g., path between outer layer color 1 and middle layer color
2 uses color 2).   4. **Trim trailing background**: Crop the grid to remove all
rows/columns consisting entirely of background color, resulting in a minimal
bounding box containing only transformed path elements.  This task demands
multi-layered reasoning: recognizing nested structures requires spatial pattern
analysis, identifying the zigzag path necessitates directional logic through
complex gaps, cascade coloring requires mapping inner-layer colors to path
segments, and trimming demands precise edge detection. Inputs must contain ≥4
nested layers with sufficient spacing (≥3 background cells between layers) to
ensure path ambiguity is resolved only through correct rule application.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(20, 30)
    height = random.randint(20, 30)
    input_grid = grid(width, height, 0)
    layers = 4
    gap = 3
    colors = random.sample(range(1, 10), layers)
    
    for i in range(layers):
        top = i * gap
        left = i * gap
        bottom = height - 1 - i * gap
        right = width - 1 - i * gap
        
        for c in range(left, right + 1):
            input_grid[top][c] = colors[i]
            input_grid[bottom][c] = colors[i]
        for r in range(top + 1, bottom):
            input_grid[r][left] = colors[i]
            input_grid[r][right] = colors[i]
    
    output_grid = [list(row) for row in input_grid]
    x, y = 0, gap
    for i in range(layers - 1):
        color = colors[i + 1]
        for _ in range(gap):
            if y < len(output_grid[0]) - 1:
                output_grid[x][y] = color
                y += 1
        for _ in range(gap):
            if x < len(output_grid) - 1:
                output_grid[x][y] = color
                x += 1
    
    while output_grid and all(p == 0 for p in output_grid[-1]):
        output_grid.pop()
    if output_grid:
        while all(row[-1] == 0 for row in output_grid):
            for row in output_grid:
                row.pop()
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    layers = []
    for color in range(1, 10):
        pixels = []
        for r in range(len(input_grid)):
            for c in range(len(input_grid[0])):
                if input_grid[r][c] == color:
                    pixels.append((r, c))
        
        if not pixels:
            continue
        
        min_r = min(p[0] for p in pixels)
        max_r = max(p[0] for p in pixels)
        min_c = min(p[1] for p in pixels)
        max_c = max(p[1] for p in pixels)
        
        is_border = True
        for r in range(min_r, max_r + 1):
            for c in range(min_c, max_c + 1):
                if input_grid[r][c] == color and (r == min_r or r == max_r or c == min_c or c == max_c):
                    continue
                if input_grid[r][c] == color:
                    is_border = False
                    break
            if not is_border:
                break
        
        if is_border:
            layers.append((color, min_r, max_r, min_c, max_c))
    
    # Sort by min_r (outermost layer has smallest min_r)
    layers.sort(key=lambda x: x[1])
    
    output_grid = [list(row) for row in input_grid]
    x, y = 0, 3
    for i in range(len(layers) - 1):
        color = layers[i + 1][0]
        for _ in range(3):
            if y < len(output_grid[0]) - 1:
                output_grid[x][y] = color
                y += 1
        for _ in range(3):
            if x < len(output_grid) - 1:
                output_grid[x][y] = color
                x += 1
    
    while output_grid and all(p == 0 for p in output_grid[-1]):
        output_grid.pop()
    if output_grid:
        while all(row[-1] == 0 for row in output_grid):
            for row in output_grid:
                row.pop()
    
    return output_grid
