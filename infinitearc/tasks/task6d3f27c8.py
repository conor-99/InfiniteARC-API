# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 6d3f27c8
Difficulty: mediumâ€“hard

=== Tags ===
- Pattern repetition with offset
- Path scarring
- Duplicate column pattern
- Color pixels at line intersections

=== Description ===
Input grids consist of a single background color (0) and one straight-line path
of uniform non-background color (1-9) that spans at least two contiguous cells
either horizontally or vertically. The path does not touch grid boundaries or
intersect itself.   Output grids reproduce the input path and duplicate it with
a one-cell offset in the path's direction (right for horizontal paths, downward
for vertical paths). Overlapping cells between the original path and its
duplicate are recolored to a distinct color (5), while all other cells retain
their original values. The background color remains unchanged. If the path
length is insufficient to create overlap (e.g., single cell), the output matches
the input. The transformation requires identifying the path's orientation,
applying the directional offset, and correctly handling overlapping cells to
produce a distinct scar pattern at intersection points.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    path_color = random.randint(1, 9)
    direction = random.choice(['horizontal', 'vertical'])
    
    if direction == 'horizontal':
        max_L = width - 2
        L = random.randint(2, max_L)
        r = random.randint(1, height - 2)
        c = random.randint(1, width - L - 1)
        input_grid = grid(width, height, 0)
        for col in range(c, c + L):
            input_grid[r][col] = path_color
        output_grid = grid(width, height, 0)
        for col in range(c, c + L + 1):
            if col >= width:
                break
            if c + 1 <= col <= c + L - 1:
                output_grid[r][col] = 5
            else:
                output_grid[r][col] = path_color
    else:
        max_L = height - 2
        L = random.randint(2, max_L)
        c = random.randint(1, width - 2)
        r = random.randint(1, height - L - 1)
        input_grid = grid(width, height, 0)
        for row in range(r, r + L):
            input_grid[row][c] = path_color
        output_grid = grid(width, height, 0)
        for row in range(r, r + L + 1):
            if row >= height:
                break
            if r + 1 <= row <= r + L - 1:
                output_grid[row][c] = 5
            else:
                output_grid[row][c] = path_color
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
from common import grid

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    
    path_color = None
    path_start = None
    path_end = None
    direction = None
    
    # Check horizontal
    for r in range(height):
        for c in range(width - 1):
            if input_grid[r][c] != 0 and input_grid[r][c] == input_grid[r][c+1]:
                color = input_grid[r][c]
                c_start = c
                while c_start > 0 and input_grid[r][c_start-1] == color:
                    c_start -= 1
                c_end = c
                while c_end < width - 1 and input_grid[r][c_end+1] == color:
                    c_end += 1
                if c_end - c_start + 1 >= 2:
                    path_color = color
                    path_start = (r, c_start)
                    path_end = (r, c_end)
                    direction = 'horizontal'
                    break
        if direction:
            break
    
    if not direction:
        for c in range(width):
            for r in range(height - 1):
                if input_grid[r][c] != 0 and input_grid[r][c] == input_grid[r+1][c]:
                    color = input_grid[r][c]
                    r_start = r
                    while r_start > 0 and input_grid[r_start-1][c] == color:
                        r_start -= 1
                    r_end = r
                    while r_end < height - 1 and input_grid[r_end+1][c] == color:
                        r_end += 1
                    if r_end - r_start + 1 >= 2:
                        path_color = color
                        path_start = (r_start, c)
                        path_end = (r_end, c)
                        direction = 'vertical'
                        break
            if direction:
                break
    
    output_grid = grid(width, height, 0)
    
    if direction == 'horizontal':
        r, c_start = path_start
        c_end = path_end[1]
        for col in range(c_start, c_end + 2):
            if col < width:
                if c_start + 1 <= col <= c_end:
                    output_grid[r][col] = 5
                else:
                    output_grid[r][col] = path_color
    else:
        c, r_start = path_start[1], path_start[0]
        r_end = path_end[0]
        for row in range(r_start, r_end + 2):
            if row < height:
                if r_start + 1 <= row <= r_end:
                    output_grid[row][c] = 5
                else:
                    output_grid[row][c] = path_color
    
    return output_grid
