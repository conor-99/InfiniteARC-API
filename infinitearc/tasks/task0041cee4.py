# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 0041cee4
Difficulty: mediumâ€“hard

=== Tags ===
- Adaptive behavior switch
- Laser diffusion
- Impact highlight

=== Description ===
# Adaptive Laser Diffusion with Impact Highlight  Input grids feature a grid-
based environment with four distinct visual elements:  - **Laser sources**
(represented by a single consistent color, e.g., red) positioned exclusively
along grid edges (top, bottom, left, or right) with at least one background cell
separating them from other elements. - **Wall structures** (represented by a
second consistent color, e.g., blue) forming contiguous barriers that block
laser movement, always surrounded by background cells or other walls. -
**Adaptive switch cells** (represented by a third consistent color, e.g.,
yellow) positioned adjacent (sharing an edge) to wall cells but never
overlapping walls. - **Background** (represented by a neutral color, e.g.,
black) occupying all other cells.  The transformation process follows these
deterministic rules: 1. **Laser propagation**: From each laser source, a beam
travels outward in its initial direction (e.g., rightward from left-edge
sources) through background cells until it encounters a wall. 2. **Impact
detection**: Upon hitting a wall cell, the beam's collision point is marked with
a **highlight color** (a fourth distinct color, e.g., green) in the output. 3.
**Adaptive behavior**: If the wall cell is adjacent to at least one switch cell,
the beam **diffuses** (splits into two new beams) traveling in perpendicular
directions (e.g., up and down from a right-moving beam). Otherwise, the beam
**reflects** (reverses direction). 4. **Path filling**: All background cells
traversed by the beam (including the path to the wall) are filled with the
source color in the output. 5. **Propagation continuation**: Each new beam (from
diffusion) continues propagating through background cells until encountering
another wall, triggering either another diffusion, reflection, or exiting the
grid boundary.  The output grid retains all original wall structures, switch
cells, and laser sources while: - Drawing complete beam paths using the source
color - Highlighting all impact points with the dedicated highlight color -
Enabling laser diffusion only when adjacent to switch cells - Ensuring no path
overlaps or overwrites non-background elements  This task requires identifying
multiple beam paths simultaneously, checking adjacency relationships for switch
cells, and applying contextual transformation rules based on wall-switch
proximity, making it a medium-hard challenge that tests multi-step visual
reasoning and contextual pattern recognition.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import hollow_conway
def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = [[0] * width for _ in range(height)]
    
    rows, cols = hollow_conway(width, height, tries=10)
    for r, c in zip(rows, cols):
        grid[r][c] = 1
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 1:
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0:
                        if random.random() < 0.3:
                            grid[nr][nc] = 6
    
    for r in range(height):
        if grid[r][0] == 0:
            if (r == 0 or grid[r-1][0] == 0) and (r == height-1 or grid[r+1][0] == 0):
                grid[r][0] = 2
        if grid[r][width-1] == 0:
            if (r == 0 or grid[r-1][width-1] == 0) and (r == height-1 or grid[r+1][width-1] == 0):
                grid[r][width-1] = 2
    for c in range(width):
        if grid[0][c] == 0:
            if (c == 0 or grid[0][c-1] == 0) and (c == width-1 or grid[0][c+1] == 0):
                grid[0][c] = 2
        if grid[height-1][c] == 0:
            if (c == 0 or grid[height-1][c-1] == 0) and (c == width-1 or grid[height-1][c+1] == 0):
                grid[height-1][c] = 2
    
    if not any(grid[r][c] == 2 for r in range(height) for c in range(width)):
        for r in range(height):
            if grid[r][0] == 0:
                grid[r][0] = 2
                break
    
    output = [row[:] for row in grid]
    queue = []
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 2:
                if c == 0:
                    dr, dc = 0, 1
                elif c == width-1:
                    dr, dc = 0, -1
                elif r == 0:
                    dr, dc = 1, 0
                elif r == height-1:
                    dr, dc = -1, 0
                else:
                    continue
                queue.append((r, c, dr, dc))
    
    while queue:
        r, c, dr, dc = queue.pop(0)
        nr = r + dr
        nc = c + dc
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            continue
        if output[nr][nc] == 1:
            output[nr][nc] = 3
            has_switch = False
            for dr2, dc2 in [(0,1), (0,-1), (1,0), (-1,0)]:
                nr2 = nr + dr2
                nc2 = nc + dc2
                if 0 <= nr2 < height and 0 <= nc2 < width and output[nr2][nc2] == 6:
                    has_switch = True
                    break
            if has_switch:
                new_dirs = [(-dc, dr), (dc, -dr)]
                for ndr, ndc in new_dirs:
                    queue.append((nr, nc, ndr, ndc))
            else:
                queue.append((nr, nc, -dr, -dc))
        else:
            output[nr][nc] = 2
            queue.append((nr, nc, dr, dc))
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    output = [row[:] for row in grid]
    queue = []
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 2:
                if c == 0:
                    dr, dc = 0, 1
                elif c == width-1:
                    dr, dc = 0, -1
                elif r == 0:
                    dr, dc = 1, 0
                elif r == height-1:
                    dr, dc = -1, 0
                else:
                    continue
                queue.append((r, c, dr, dc))
    
    while queue:
        r, c, dr, dc = queue.pop(0)
        nr = r + dr
        nc = c + dc
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            continue
        if output[nr][nc] == 1:
            output[nr][nc] = 3
            has_switch = False
            for dr2, dc2 in [(0,1), (0,-1), (1,0), (-1,0)]:
                nr2 = nr + dr2
                nc2 = nc + dc2
                if 0 <= nr2 < height and 0 <= nc2 < width and output[nr2][nc2] == 6:
                    has_switch = True
                    break
            if has_switch:
                new_dirs = [(-dc, dr), (dc, -dr)]
                for ndr, ndc in new_dirs:
                    queue.append((nr, nc, ndr, ndc))
            else:
                queue.append((nr, nc, -dr, -dc))
        else:
            output[nr][nc] = 2
            queue.append((nr, nc, dr, dc))
    
    return output
