# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: f98ea156
Difficulty: very hard

=== Tags ===
- Color carving
- Relational projection
- Flood fill region
- Fractal repetition

=== Description ===
Input grids feature a complex, single large region composed of multiple
interconnected sub-regions (each a 4-connected component of a distinct non-zero
color, 1-9) arranged in a nested, non-overlapping pattern on a background of
color 0. The sub-regions form a hierarchical structure where each is adjacent to
at least one other sub-region of a different color, creating a visually
intricate "color forest" with no isolated regions.  The transformation process
involves three sequential, interdependent steps:  1. **Color Carving**: For each
sub-region (color C), identify all adjacent sub-regions of color C+1 (with color
9 wrapping to color 1). Remove all boundary cells between such adjacent sub-
regions (i.e., carve out the interface between C and C+1), preserving only cells
not adjacent to C+1. This carving is applied simultaneously to all sub-regions.
2. **Relational Projection**: After carving, project the remaining shape of each
sub-region onto all four quadrants of the grid. Each quadrant receives a
mirrored (horizontally and vertically) and scaled version of the sub-region's
shape, maintaining its original color. The scaling ensures the projected shape
fits within the quadrant while preserving aspect ratio.  3. **Fractal
Repetition**: The projected shapes in each quadrant undergo recursive
subdivision. For each quadrant, the current shape is subdivided into four
smaller quadrants, and the carving and projection steps are repeated on the new
sub-shapes. This recursion continues until the smallest sub-shape has a bounding
box of less than 3Ã—3 cells, at which point it is displayed as-is without further
subdivision.  The output grid displays the original large region with all sub-
regions carved according to color adjacency, then projected into all four
quadrants with recursive fractal repetition, where each level of the fractal
maintains the original color of its source sub-region without modification. The
background remains 0, and no new colors are introduced.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, all_pixels

def generate():
    size = random.randint(10, 20)
    grid_size = size
    input_grid = grid(grid_size, grid_size, 0)
    center_x = random.randint(0, grid_size - 1)
    center_y = random.randint(0, grid_size - 1)
    
    # Create nested concentric rings around random center
    for color in range(1, 10):
        radius = color - 1
        r_start = max(0, center_y - radius)
        r_end = min(grid_size, center_y + radius + 1)
        c_start = max(0, center_x - radius)
        c_end = min(grid_size, center_x + radius + 1)
        
        for r in range(r_start, r_end):
            for c in range(c_start, c_end):
                if abs(r - center_y) <= radius and abs(c - center_x) <= radius:
                    if abs(r - center_y) == radius or abs(c - center_x) == radius:
                        input_grid[r][c] = color

    def apply_carving(grid):
        h, w = len(grid), len(grid[0])
        carved = [row[:] for row in grid]
        for r in range(h):
            for c in range(w):
                if grid[r][c] == 0:
                    continue
                current_color = grid[r][c]
                next_color = (current_color % 9) + 1
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < h and 0 <= nc < w and grid[nr][nc] == next_color:
                        carved[r][c] = 0
                        break
        return carved

    carved_grid = apply_carving(input_grid)
    output_grid = [row[:] for row in carved_grid]
    
    quad_size = grid_size // 2
    for r in range(quad_size):
        for c in range(quad_size):
            output_grid[r][c] = carved_grid[quad_size - 1 - r][quad_size - 1 - c]
            output_grid[r][quad_size + c] = carved_grid[quad_size - 1 - r][c]
            output_grid[quad_size + r][c] = carved_grid[r][quad_size - 1 - c]
            output_grid[quad_size + r][quad_size + c] = carved_grid[r][c]

    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    h, w = len(input_grid), len(input_grid[0])
    grid = [list(row) for row in input_grid]

    def apply_carving(grid):
        h, w = len(grid), len(grid[0])
        carved = [row[:] for row in grid]
        for r in range(h):
            for c in range(w):
                if grid[r][c] == 0:
                    continue
                current_color = grid[r][c]
                next_color = (current_color % 9) + 1
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < h and 0 <= nc < w and grid[nr][nc] == next_color:
                        carved[r][c] = 0
                        break
        return carved

    carved_grid = apply_carving(grid)
    output_grid = [row[:] for row in carved_grid]
    
    quad_size = h // 2
    for r in range(quad_size):
        for c in range(quad_size):
            output_grid[r][c] = carved_grid[quad_size - 1 - r][quad_size - 1 - c]
            output_grid[r][quad_size + c] = carved_grid[quad_size - 1 - r][c]
            output_grid[quad_size + r][c] = carved_grid[r][quad_size - 1 - c]
            output_grid[quad_size + r][quad_size + c] = carved_grid[r][c]

    return output_grid
