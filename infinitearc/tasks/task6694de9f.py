# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 6694de9f
Difficulty: hard

=== Tags ===
- Recursive path tracing
- Local convolution rule

=== Description ===
Input grids consist of a single background color (0) with a complex, continuous
path (color 1) winding through the grid from top to bottom. The path contains
directional turns (left or right) at various points, where the path changes
direction by 90 degrees. At each turn point, a local 3x3 convolution rule is
applied to the neighborhood centered at that cell. The rule states: for each
cell in the 3x3 window, if it is background (0), it is replaced with color 2 if
the turn is left, or color 3 if the turn is right. Crucially, this convolution
may generate new path segments (e.g., a left turn convolution creates a
horizontal segment of color 2), which themselves contain directional turns.
These new segments trigger additional convolutions, creating a recursive cascade
where each new turn point applies the same rule to its neighborhood. The output
grid displays the original path plus all convolved cells from the recursive
application, with all new turns processed until no further turns remain.
Convolution never overwrites non-background cells, and the background remains
color 0 except where modified by the rule. The process requires identifying
recursive turn points, applying the color-based convolution rule locally at
each, and propagating the effect through the entire path structure without
overlap or termination errors.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    """
    Generate a random winding path from top to bottom (color 1) on a grid with background 0.
    Then apply the recursive 3x3 convolution rule at every turn: for a left turn fill background
    cells in the 3x3 neighborhood with color 2, for a right turn with color 3. New colored cells
    may create new turns and so the rule is applied repeatedly until no more background cells
    are filled.
    Returns a dict with keys 'input' and 'output' mapping to 2D lists of ints.
    """
    # Retry until we build a valid path with at least one turn
    for attempt in range(100):
        width = random.randint(9, 15)
        height = random.randint(9, 15)

        # start at top row, random column
        r, c = 0, random.randint(0, width - 1)
        path = [(r, c)]
        visited = { (r, c) }

        # Build a monotonic-down winding path: alternate horizontal runs and single down steps
        # This ensures many 90-degree turns
        max_cells = width * height
        while r < height - 1 and len(path) < max_cells:
            # choose horizontal direction
            hr_dir = random.choice([-1, 1])
            # pick a run length (at least 1)
            run_len = random.randint(1, max(1, width // 3))
            for _ in range(run_len):
                nc = c + hr_dir
                if nc < 0 or nc >= width or (r, nc) in visited:
                    break
                c = nc
                visited.add((r, c))
                path.append((r, c))
            # move down one step if possible
            if r < height - 1:
                nr = r + 1
                # if the cell below is already visited (very unlikely in this construction),
                # attempt to make a small horizontal shift to an available column before moving down
                if (nr, c) in visited:
                    shifted = False
                    for shift in (-1, 1):
                        nc = c + shift
                        if 0 <= nc < width and (r, nc) not in visited and (nr, nc) not in visited:
                            c = nc
                            visited.add((r, c))
                            path.append((r, c))
                            shifted = True
                            break
                    if not shifted:
                        break
                r = nr
                visited.add((r, c))
                path.append((r, c))

        # ensure we reached the bottom row and have at least one turn
        if r != height - 1:
            continue

        # detect at least one 90-degree turn in the path
        has_turn = False
        for i in range(1, len(path) - 1):
            r_prev, c_prev = path[i - 1]
            r_curr, c_curr = path[i]
            r_next, c_next = path[i + 1]
            dir1 = (r_curr - r_prev, c_curr - c_prev)
            dir2 = (r_next - r_curr, c_next - c_curr)
            if dir1 != dir2 and (dir1[0] + dir2[0] != 0 or dir1[1] + dir2[1] != 0):
                has_turn = True
                break
        if not has_turn:
            continue

        # We have a valid path; build the input grid
        input_grid = grid(width, height, 0)
        for rr, cc in path:
            input_grid[rr][cc] = 1

        # Compute output by applying the recursive convolution rule
        output_grid = [row[:] for row in input_grid]

        def find_turns(g):
            turns = []
            H = len(g)
            W = len(g[0])
            for rr in range(H):
                for cc in range(W):
                    if g[rr][cc] == 0:
                        continue
                    # collect orthogonal neighbor direction vectors where neighbor is non-zero
                    neigh = []
                    for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                        nr, nc = rr + dr, cc + dc
                        if 0 <= nr < H and 0 <= nc < W and g[nr][nc] > 0:
                            neigh.append((dr, dc))
                    if len(neigh) < 2:
                        continue
                    # find a pair of neighbor vectors that are not opposites (a corner)
                    neigh_sorted = sorted(neigh)
                    found = False
                    for i in range(len(neigh_sorted)):
                        for j in range(i + 1, len(neigh_sorted)):
                            dr1, dc1 = neigh_sorted[i]
                            dr2, dc2 = neigh_sorted[j]
                            # skip opposite directions (straight line)
                            if dr1 + dr2 == 0 and dc1 + dc2 == 0:
                                continue
                            # this is a corner/turn
                            cross = dr1 * dc2 - dr2 * dc1
                            turn_dir = 'left' if cross > 0 else 'right'
                            turns.append((rr, cc, turn_dir))
                            found = True
                            break
                        if found:
                            break
            return turns

        # apply turns iteratively (synchronous per iteration)
        H = len(output_grid)
        W = len(output_grid[0])
        while True:
            turns = find_turns(output_grid)
            if not turns:
                break
            new_grid = [row[:] for row in output_grid]
            any_filled = False
            for rr, cc, tdir in turns:
                color = 2 if tdir == 'left' else 3
                for dr in (-1, 0, 1):
                    for dc in (-1, 0, 1):
                        nr, nc = rr + dr, cc + dc
                        if 0 <= nr < H and 0 <= nc < W and output_grid[nr][nc] == 0:
                            new_grid[nr][nc] = color
                            any_filled = True
            output_grid = new_grid
            if not any_filled:
                break

        # ensure input != output
        # if convolution produced nothing (shouldn't happen because we ensured at least one turn),
        # regenerate
        if input_grid == output_grid:
            continue

        return {'input': input_grid, 'output': output_grid}

    # Fallback: should not hit here in normal operation
    # create a minimal fixed example
    W, H = 9, 9
    inp = grid(W, H, 0)
    for i in range(H):
        inp[i][W//2] = 1
    out = [row[:] for row in inp]
    out[H//2][W//2 + 1] = 2
    return {'input': inp, 'output': out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable grid
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0])

    def find_turns(g):
        turns = []
        for rr in range(H):
            for cc in range(W):
                if g[rr][cc] == 0:
                    continue
                neigh = []
                for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < H and 0 <= nc < W and g[nr][nc] > 0:
                        neigh.append((dr, dc))
                if len(neigh) < 2:
                    continue
                neigh_sorted = sorted(neigh)
                found = False
                for i in range(len(neigh_sorted)):
                    for j in range(i + 1, len(neigh_sorted)):
                        dr1, dc1 = neigh_sorted[i]
                        dr2, dc2 = neigh_sorted[j]
                        if dr1 + dr2 == 0 and dc1 + dc2 == 0:
                            continue
                        cross = dr1 * dc2 - dr2 * dc1
                        turn_dir = 'left' if cross > 0 else 'right'
                        turns.append((rr, cc, turn_dir))
                        found = True
                        break
                    if found:
                        break
        return turns

    # apply convolutions iteratively until no background cells are filled
    while True:
        turns = find_turns(grid)
        if not turns:
            break
        new_grid = [row[:] for row in grid]
        any_filled = False
        for rr, cc, tdir in turns:
            color = 2 if tdir == 'left' else 3
            for dr in (-1, 0, 1):
                for dc in (-1, 0, 1):
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < H and 0 <= nc < W and grid[nr][nc] == 0:
                        new_grid[nr][nc] = color
                        any_filled = True
        grid = new_grid
        if not any_filled:
            break

    return tuple(tuple(row) for row in grid)

