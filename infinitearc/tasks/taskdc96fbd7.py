# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: dc96fbd7
Difficulty: insane

=== Tags ===
- Cyclic painting
- Bridge gaps

=== Description ===
Input grids consist of a large, sparse canvas (15×15 to 30×30) with background
color 0. Multiple disconnected regions of colors 1–9 (4-connected components)
are scattered across the grid, separated by gaps of background cells. Gaps
between regions must be bridged if they are horizontally or vertically aligned
with exactly one or more background cells between the regions.   For each such
gap, the output grid fills the gap cells with a cyclic color sequence derived
from all non-background colors present in the input. The sequence is formed by
sorting all distinct non-background colors in ascending order and rotating the
list so it starts with the color of the region adjacent to the gap’s left (for
horizontal gaps) or top (for vertical gaps). The sequence is then repeated to
fill the gap cells in order. For example, if the input contains colors 3, 1, 5,
the sorted cycle is [1, 3, 5]. A horizontal gap between a region of color 3 and
another region would use the sequence [3, 5, 1, 3, ...] to fill the gap cells
left-to-right.   Bridges must not overlap with existing regions, other bridges,
or non-background elements. The background remains unchanged except where filled
by bridges. The transformation requires identifying all bridging gaps,
determining the cyclic sequence per gap based on global color data, and applying
the sequence without altering the original regions or introducing new elements.
The task demands simultaneous recognition of global color sets, local region
adjacency, and multi-step sequence application.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Generator for ARC task: Bridge gaps horizontally (no vertical bridges to avoid overlap)
# Creates multiple rectangular regions so that some pairs are horizontally aligned with
# background cells between them. Fills the gaps in the output using the cyclic rule.

def generate():
    # Try until we succeed in making at least one bridge
    for attempt_main in range(100):
        width = random.randint(15, 30)
        height = random.randint(15, 30)
        input_grid = grid(width, height, 0)

        # Choose a set of distinct non-background colors (at least 2, up to 5)
        num_colors = random.randint(3, 5)
        colors = random.sample(range(1, 10), num_colors)

        region_cells = set()
        regions = []  # list of dicts: {'color': int, 'cells': set(), 'rows': set(), 'cols': set()}
        used_colors = set()

        # Number of horizontal gap pairs to attempt
        max_pairs = max(1, min(4, height // 4))
        num_pairs = random.randint(1, max_pairs)
        used_rows = set()

        placed_pairs = 0
        # Place horizontal region pairs that share at least one row and have a pure-background gap between
        for pair_idx in range(num_pairs):
            placed = False
            for try_pos in range(120):
                # pick a row that will be in both left and right blocks (so they align horizontally)
                r = random.randint(0, height - 1)
                if r in used_rows:
                    continue

                # block dimensions
                wL = random.randint(1, 4)
                wR = random.randint(1, 4)
                hL = random.randint(1, 3)
                hR = random.randint(1, 3)

                # gap width (at least 1)
                max_gap = max(1, min(6, width - (wL + wR) - 1))
                if width - (wL + wR) - 1 <= 0:
                    continue
                gw = random.randint(1, max_gap)

                # compute feasible left column range so both blocks fit
                max_left = width - (wL + gw + wR)
                if max_left < 0:
                    continue
                left_col = random.randint(0, max_left)
                right_col_min = left_col + wL + gw
                if right_col_min + wR - 1 >= width:
                    continue
                right_col = random.randint(right_col_min, width - wR)

                # choose vertical placement so that each block includes row r
                topL_min = max(0, r - hL + 1)
                topL_max = min(r, height - hL)
                if topL_min > topL_max:
                    continue
                topL = random.randint(topL_min, topL_max)

                topR_min = max(0, r - hR + 1)
                topR_max = min(r, height - hR)
                if topR_min > topR_max:
                    continue
                topR = random.randint(topR_min, topR_max)

                # candidate cells for left and right blocks
                cellsL = set((rr, cc) for rr in range(topL, topL + hL) for cc in range(left_col, left_col + wL))
                cellsR = set((rr, cc) for rr in range(topR, topR + hR) for cc in range(right_col, right_col + wR))

                # ensure they share at least one row (alignment) so there is a horizontal gap
                rowsL = set(rr for rr, _ in cellsL)
                rowsR = set(rr for rr, _ in cellsR)
                common_rows = rowsL & rowsR
                if not common_rows:
                    continue

                # ensure no overlap and not 4-adjacent to existing regions (to avoid merging)
                conflict = False
                for (rr, cc) in cellsL | cellsR:
                    if (rr, cc) in region_cells:
                        conflict = True
                        break
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        if (rr + dr, cc + dc) in region_cells:
                            conflict = True
                            break
                    if conflict:
                        break
                if conflict:
                    continue

                # ensure the cells between left and right on each shared row are background (no other region)
                bad = False
                for row in common_rows:
                    left_cols = [cc for (rr, cc) in cellsL if rr == row]
                    right_cols = [cc for (rr, cc) in cellsR if rr == row]
                    left_max = max(left_cols)
                    right_min = min(right_cols)
                    if left_max >= right_min:
                        bad = True
                        break
                    for cc in range(left_max + 1, right_min):
                        if (row, cc) in region_cells:
                            bad = True
                            break
                    if bad:
                        break
                if bad:
                    continue

                # choose colors for left and right blocks
                colorL = random.choice(colors)
                colorR = random.choice(colors)

                # place them
                for (rr, cc) in cellsL:
                    input_grid[rr][cc] = colorL
                    region_cells.add((rr, cc))
                for (rr, cc) in cellsR:
                    input_grid[rr][cc] = colorR
                    region_cells.add((rr, cc))

                regions.append({'color': colorL, 'cells': cellsL})
                regions.append({'color': colorR, 'cells': cellsR})
                used_colors.add(colorL)
                used_colors.add(colorR)
                used_rows.add(r)
                placed = True
                placed_pairs += 1
                break
            # end try_pos

        # ensure every chosen color appears at least once; if not, place small spare blocks
        for color in colors:
            if color in used_colors:
                continue
            placed_small = False
            for try_small in range(200):
                w = random.randint(1, 3)
                h = random.randint(1, 3)
                left_col = random.randint(0, width - w)
                top = random.randint(0, height - h)
                cellsSmall = set((rr, cc) for rr in range(top, top + h) for cc in range(left_col, left_col + w))
                # ensure free and not adjacent to existing
                bad_small = False
                for (rr, cc) in cellsSmall:
                    if (rr, cc) in region_cells:
                        bad_small = True
                        break
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        if (rr + dr, cc + dc) in region_cells:
                            bad_small = True
                            break
                    if bad_small:
                        break
                if bad_small:
                    continue
                for (rr, cc) in cellsSmall:
                    input_grid[rr][cc] = color
                    region_cells.add((rr, cc))
                regions.append({'color': color, 'cells': cellsSmall})
                used_colors.add(color)
                placed_small = True
                break
            # if couldn't place a particular color, it's okay; generator will still continue

        # If we didn't manage to place any pair at all, retry
        if placed_pairs == 0:
            continue

        # Prepare the global color cycle (sorted distinct non-background colors)
        all_colors_sorted = sorted(set(v for row in input_grid for v in row if v > 0))

        # Build output by scanning rows then columns (horizontal first) consistent with solver
        output_grid = [list(row) for row in input_grid]

        # Horizontal bridges
        for r in range(height):
            c = 0
            while c < width:
                if input_grid[r][c] == 0:
                    start = c
                    while c < width and input_grid[r][c] == 0:
                        c += 1
                    end = c - 1
                    if start > 0 and end < width - 1:
                        left_color = input_grid[r][start - 1]
                        right_color = input_grid[r][end + 1]
                        if left_color > 0 and right_color > 0:
                            # rotate cycle so it starts with left_color
                            cycle = list(all_colors_sorted)
                            if left_color in cycle:
                                idx = cycle.index(left_color)
                                cycle = cycle[idx:] + cycle[:idx]
                            # fill left-to-right
                            for cc in range(start, end + 1):
                                if output_grid[r][cc] == 0:
                                    output_grid[r][cc] = cycle[(cc - start) % len(cycle)]
                else:
                    c += 1

        # Vertical bridges (kept for completeness; generator primarily creates horizontal gaps)
        for c in range(width):
            r = 0
            while r < height:
                if input_grid[r][c] == 0:
                    start = r
                    while r < height and input_grid[r][c] == 0:
                        r += 1
                    end = r - 1
                    if start > 0 and end < height - 1:
                        top_color = input_grid[start - 1][c]
                        bottom_color = input_grid[end + 1][c]
                        if top_color > 0 and bottom_color > 0:
                            cycle = list(all_colors_sorted)
                            if top_color in cycle:
                                idx = cycle.index(top_color)
                                cycle = cycle[idx:] + cycle[:idx]
                            for rr in range(start, end + 1):
                                if output_grid[rr][c] == 0:
                                    output_grid[rr][c] = cycle[(rr - start) % len(cycle)]
                else:
                    r += 1

        # Ensure we made some change
        if input_grid == output_grid:
            continue

        return {"input": input_grid, "output": output_grid}

    # If we failed after many attempts, raise a fallback (shouldn't happen in normal runs)
    raise RuntimeError("Failed to generate a valid task instance")



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

# Solver implementing the same scanning rules as the generator.
# It finds horizontal (and vertical) zero segments that are bounded by non-background colors
# and fills them using the cyclic sorted color list, rotated to start with the left/top neighbor.

def p(input_grid):
    # Convert to mutable list-of-lists
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0]) if height > 0 else 0

    # Global sorted non-background colors
    all_colors = sorted({v for row in input_grid for v in row if v > 0})
    output_grid = [row[:] for row in input_grid]

    # Horizontal gaps
    for r in range(height):
        c = 0
        while c < width:
            if input_grid[r][c] == 0:
                start = c
                while c < width and input_grid[r][c] == 0:
                    c += 1
                end = c - 1
                if start > 0 and end < width - 1:
                    left_color = input_grid[r][start - 1]
                    right_color = input_grid[r][end + 1]
                    if left_color > 0 and right_color > 0:
                        cycle = list(all_colors)
                        if left_color in cycle:
                            idx = cycle.index(left_color)
                            cycle = cycle[idx:] + cycle[:idx]
                        for cc in range(start, end + 1):
                            if output_grid[r][cc] == 0:
                                output_grid[r][cc] = cycle[(cc - start) % len(cycle)]
            else:
                c += 1

    # Vertical gaps
    for c in range(width):
        r = 0
        while r < height:
            if input_grid[r][c] == 0:
                start = r
                while r < height and input_grid[r][c] == 0:
                    r += 1
                end = r - 1
                if start > 0 and end < height - 1:
                    top_color = input_grid[start - 1][c]
                    bottom_color = input_grid[end + 1][c]
                    if top_color > 0 and bottom_color > 0:
                        cycle = list(all_colors)
                        if top_color in cycle:
                            idx = cycle.index(top_color)
                            cycle = cycle[idx:] + cycle[:idx]
                        for rr in range(start, end + 1):
                            if output_grid[rr][c] == 0:
                                output_grid[rr][c] = cycle[(rr - start) % len(cycle)]
            else:
                r += 1

    return output_grid

