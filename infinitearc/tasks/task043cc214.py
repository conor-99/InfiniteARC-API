# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 043cc214
Difficulty: insane

=== Tags ===
- Sequence interpolation
- Mutual reflection
- Wavefront timing
- Momentum transfer
- Move object to nearest corner
- Nearest color fill

=== Description ===
Input grids contain multiple distinct-colored tokens (each occupying a single
cell) placed at arbitrary positions within a grid, each oriented in one of four
cardinal directions (represented by their position relative to adjacent
background cells or a minimal directional marker). The grid background is a
neutral color (0), and tokens move orthogonally one cell per time step according
to their direction. Upon hitting a grid boundary, tokens reflect (e.g., right →
down, down → left), while collisions between tokens reverse both tokens'
directions (momentum transfer). Movement continues iteratively until all tokens
reach the nearest grid corner (based on Manhattan distance to the four corners),
with ties resolved by corner priority (top-left → top-right → bottom-left →
bottom-right). The output grid is generated by filling every cell with the color
of the nearest corner token (using Manhattan distance; ties resolved by corner
priority), creating contiguous Voronoi regions around each corner token. This
process combines wavefront timing (discrete movement steps), sequence
interpolation (path trajectory between start and corner), mutual reflection
(boundary and collision handling), momentum transfer (collision dynamics), and
nearest color fill (final grid composition).
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    """
    Generate an ARC-style input/output pair according to the specification.
    Representation conventions used here:
    - Background: 0
    - Token colors: distinct values from 1..8 (never 9)
    - Direction marker: value 9 placed in the cell in front of the token (the token faces towards the marker)
    - Exactly four tokens are created, one targeting each corner (TL, TR, BL, BR). The token's assigned corner is the nearest corner
      to its initial position (Manhattan distance) using the tie-break priority TL->TR->BL->BR.
    Movement rules (used both in generator and solver):
    - Each time step every active token attempts to move one cell in its current direction.
    - If the attempted cell is out-of-bounds, the token reflects: its direction is rotated clockwise until the attempted cell is in-bounds.
    - If two or more tokens attempt to move into the same target cell, all tokens that were targeting that cell do not move and instead reverse direction.
    - If two tokens attempt to swap positions (A->B's current cell and B->A's current cell), we treat this as a collision: both stay in place and reverse direction.
    - When a token reaches its assigned corner cell, it stops there and is removed from further simulation.
    """
    max_attempts = 200
    attempt = 0
    while True:
        attempt += 1
        if attempt > max_attempts:
            # Extremely unlikely but safe fallback: if we failed to create a valid configuration repeatedly,
            # reduce constraints by making a small fixed grid with a trivial configuration.
            width, height = 5, 5
        else:
            width = random.randint(3, 14)
            height = random.randint(3, 14)

        # Create empty input grid
        input_grid = grid(width, height, 0)

        # Colors: pick 4 distinct token colors from 1..8; reserve 9 for markers
        token_colors = random.sample(list(range(1, 9)), 4)
        marker_color = 9

        # Corner coordinates in priority order TL, TR, BL, BR
        corners = [(0, 0), (0, width - 1), (height - 1, 0), (height - 1, width - 1)]

        # Helper to compute nearest corner index (with tie-break priority via ascending index)
        def nearest_corner_index(r, c):
            d_tl = r + c
            d_tr = r + (width - 1 - c)
            d_bl = (height - 1 - r) + c
            d_br = (height - 1 - r) + (width - 1 - c)
            dists = [d_tl, d_tr, d_bl, d_br]
            min_d = min(dists)
            for i, dd in enumerate(dists):
                if dd == min_d:
                    return i
            return 0

        # All non-corner candidate positions grouped by which corner they are nearest to
        candidates = [[] for _ in range(4)]
        for r in range(height):
            for c in range(width):
                if (r, c) in corners:
                    continue
                idx = nearest_corner_index(r, c)
                candidates[idx].append((r, c))

        # If any corner has no candidate positions (should be rare for small grids) restart
        if any(len(lst) == 0 for lst in candidates):
            continue

        # Attempt to choose one position for each corner and place a token + marker that points toward the corner
        dr = [-1, 0, 1, 0]
        dc = [0, 1, 0, -1]

        placed = []  # list of (r,c,d,color,corner_idx)
        occupied = set()  # cells already used by tokens or markers
        failed = False

        for corner_idx in range(4):
            possible = candidates[corner_idx][:]
            random.shuffle(possible)
            placed_success = False
            # Try several candidate cells for this corner
            for (r, c) in possible:
                if (r, c) in occupied or (r, c) in corners:
                    continue
                # compute directions that reduce Manhattan distance to the assigned corner
                target_r, target_c = corners[corner_idx]
                dr_needed = target_r - r
                dc_needed = target_c - c
                reduce_dirs = []
                if dr_needed < 0:
                    reduce_dirs.append(0)  # up
                if dc_needed > 0:
                    reduce_dirs.append(1)  # right
                if dr_needed > 0:
                    reduce_dirs.append(2)  # down
                if dc_needed < 0:
                    reduce_dirs.append(3)  # left

                # If reduce_dirs is empty (this would mean the position is already at the corner), skip it
                if not reduce_dirs:
                    continue

                random.shuffle(reduce_dirs)
                # Try directions that reduce distance and ensure the marker cell fits and is free
                for d in reduce_dirs:
                    mr, mc = r + dr[d], c + dc[d]
                    if not (0 <= mr < height and 0 <= mc < width):
                        continue
                    if (mr, mc) in occupied:
                        continue
                    # Place token at (r,c) and marker at (mr,mc)
                    color = token_colors[corner_idx]
                    input_grid[r][c] = color
                    input_grid[mr][mc] = marker_color
                    occupied.add((r, c))
                    occupied.add((mr, mc))
                    placed.append({'r': r, 'c': c, 'd': d, 'color': color, 'corner': corner_idx})
                    placed_success = True
                    break
                if placed_success:
                    break
            if not placed_success:
                failed = True
                break

        if failed or len(placed) != 4:
            # try a different grid
            continue

        # Now we have an input_grid with four tokens and four markers. Simulate movement to compute final corner colors.
        tokens = [dict(t) for t in placed]
        corner_colors = {0: None, 1: None, 2: None, 3: None}

        # Movement simulation with the same rules used in the solver (deterministic)
        max_steps = width * height * 20  # generous limit but still small
        for step in range(max_steps):
            if not tokens:
                break
            current_positions = [(t['r'], t['c']) for t in tokens]
            desired = []  # (nr,nc,new_d)
            for t in tokens:
                r, c, d = t['r'], t['c'], t['d']
                # reflect at boundary by rotating clockwise until in-bounds
                tries = 0
                new_d = d
                nr, nc = r + dr[new_d], c + dc[new_d]
                while not (0 <= nr < height and 0 <= nc < width) and tries < 4:
                    new_d = (new_d + 1) % 4
                    nr, nc = r + dr[new_d], c + dc[new_d]
                    tries += 1
                # At this point (nr,nc) is either in-bounds or it's the only possible move (grid 1x1 corner cases handled by above)
                desired.append((nr, nc, new_d))

            # Mark collisions where multiple tokens target same cell
            pos_to_inds = {}
            for i, (nr, nc, nd) in enumerate(desired):
                pos_to_inds.setdefault((nr, nc), []).append(i)

            will_move = [True] * len(tokens)
            new_dirs = [desired[i][2] for i in range(len(tokens))]

            # Multi-target collisions: tokens that try to move into the same cell do not move and reverse direction
            for pos, inds in pos_to_inds.items():
                if len(inds) > 1:
                    for i in inds:
                        will_move[i] = False
                        new_dirs[i] = (new_dirs[i] + 2) % 4

            # Swap-detection: two tokens attempting to exchange positions
            for i in range(len(tokens)):
                for j in range(i + 1, len(tokens)):
                    if not will_move[i] or not will_move[j]:
                        continue
                    di_tgt = (desired[i][0], desired[i][1])
                    dj_tgt = (desired[j][0], desired[j][1])
                    if di_tgt == current_positions[j] and dj_tgt == current_positions[i]:
                        # swap collision: neither moves and both reverse
                        will_move[i] = False
                        will_move[j] = False
                        new_dirs[i] = (new_dirs[i] + 2) % 4
                        new_dirs[j] = (new_dirs[j] + 2) % 4

            # Apply moves (or stays) and update directions
            for idx in range(len(tokens)):
                if will_move[idx]:
                    tokens[idx]['r'], tokens[idx]['c'] = desired[idx][0], desired[idx][1]
                tokens[idx]['d'] = new_dirs[idx]

            # Remove tokens that reached their assigned corner
            remaining = []
            for t in tokens:
                if (t['r'], t['c']) == corners[t['corner']]:
                    corner_colors[t['corner']] = t['color']
                else:
                    remaining.append(t)
            tokens = remaining

        # If simulation did not finish (very unlikely given direction choices), assign remaining tokens to corner colors directly
        if tokens:
            for t in tokens:
                corner_colors[t['corner']] = t['color']
            tokens = []

        # Build output grid as a Voronoi fill by the corner token colors with Manhattan distance and tie-break priority
        output_grid = grid(width, height, 0)
        for r in range(height):
            for c in range(width):
                dists = [r + c, r + (width - 1 - c), (height - 1 - r) + c,
                         (height - 1 - r) + (width - 1 - c)]
                min_d = min(dists)
                # priority TL,TR,BL,BR -> first index with min distance
                for i in range(4):
                    if dists[i] == min_d:
                        color = corner_colors.get(i, 0) or 0
                        output_grid[r][c] = color
                        break

        # Avoid degenerate case where input equals output (unlikely but possible if token+marker pattern filled entire grid exactly)
        if input_grid == output_grid:
            # restart generation
            continue

        return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable list-of-lists (input_grid may be a tuple of tuples)
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])

    # Direction vectors: up, right, down, left
    dr = [-1, 0, 1, 0]
    dc = [0, 1, 0, -1]

    # Corner coordinates TL, TR, BL, BR
    corners = [(0, 0), (0, width - 1), (height - 1, 0), (height - 1, width - 1)]

    # Helper to compute nearest corner index (with tie-break priority via ascending index)
    def nearest_corner_index(r, c):
        d_tl = r + c
        d_tr = r + (width - 1 - c)
        d_bl = (height - 1 - r) + c
        d_br = (height - 1 - r) + (width - 1 - c)
        dists = [d_tl, d_tr, d_bl, d_br]
        min_d = min(dists)
        for i, dd in enumerate(dists):
            if dd == min_d:
                return i
        return 0

    # Extract tokens: token colors are 1..8, markers are 9
    tokens = []  # list of dicts {'r','c','d','color','corner'}
    for r in range(height):
        for c in range(width):
            val = grid_in[r][c]
            if val == 0 or val == 9:
                continue
            color = val
            # Find adjacent marker 9 to determine direction
            direction = None
            for d in range(4):
                nr, nc = r + dr[d], c + dc[d]
                if 0 <= nr < height and 0 <= nc < width and grid_in[nr][nc] == 9:
                    # token faces towards the marker cell
                    direction = d
                    break
            # If no explicit marker found (shouldn't happen for generated inputs), fall back to a direction that reduces distance
            corner_idx = nearest_corner_index(r, c)
            if direction is None:
                # choose a direction that reduces manhattan distance to its nearest corner (deterministic choice)
                target_r, target_c = corners[corner_idx]
                dr_needed = target_r - r
                dc_needed = target_c - c
                if dr_needed < 0:
                    direction = 0
                elif dc_needed > 0:
                    direction = 1
                elif dr_needed > 0:
                    direction = 2
                else:
                    direction = 3
            tokens.append({'r': r, 'c': c, 'd': direction, 'color': color, 'corner': corner_idx})

    # Simulate movement with the same deterministic rules used in the generator
    corner_colors = {0: None, 1: None, 2: None, 3: None}
    max_steps = width * height * 20
    for step in range(max_steps):
        if not tokens:
            break
        current_positions = [(t['r'], t['c']) for t in tokens]
        desired = []
        for t in tokens:
            r, c, d = t['r'], t['c'], t['d']
            # reflect at boundary by rotating clockwise until in-bounds
            tries = 0
            new_d = d
            nr, nc = r + dr[new_d], c + dc[new_d]
            while not (0 <= nr < height and 0 <= nc < width) and tries < 4:
                new_d = (new_d + 1) % 4
                nr, nc = r + dr[new_d], c + dc[new_d]
                tries += 1
            desired.append((nr, nc, new_d))

        pos_to_inds = {}
        for i, (nr, nc, nd) in enumerate(desired):
            pos_to_inds.setdefault((nr, nc), []).append(i)

        will_move = [True] * len(tokens)
        new_dirs = [desired[i][2] for i in range(len(tokens))]

        # Multi-target collisions
        for pos, inds in pos_to_inds.items():
            if len(inds) > 1:
                for i in inds:
                    will_move[i] = False
                    new_dirs[i] = (new_dirs[i] + 2) % 4

        # Swap detection
        for i in range(len(tokens)):
            for j in range(i + 1, len(tokens)):
                if not will_move[i] or not will_move[j]:
                    continue
                di_tgt = (desired[i][0], desired[i][1])
                dj_tgt = (desired[j][0], desired[j][1])
                if di_tgt == current_positions[j] and dj_tgt == current_positions[i]:
                    will_move[i] = False
                    will_move[j] = False
                    new_dirs[i] = (new_dirs[i] + 2) % 4
                    new_dirs[j] = (new_dirs[j] + 2) % 4

        # Apply moves
        for idx in range(len(tokens)):
            if will_move[idx]:
                tokens[idx]['r'], tokens[idx]['c'] = desired[idx][0], desired[idx][1]
            tokens[idx]['d'] = new_dirs[idx]

        # Remove tokens that reached their assigned corner
        remaining = []
        for t in tokens:
            if (t['r'], t['c']) == corners[t['corner']]:
                corner_colors[t['corner']] = t['color']
            else:
                remaining.append(t)
        tokens = remaining

    # If any tokens remain (simulation cap), assign their colors to their corners directly
    if tokens:
        for t in tokens:
            corner_colors[t['corner']] = t['color']

    # Build output grid - Voronoi fill by corner_colors with Manhattan metric and corner priority
    output = [[0 for _ in range(width)] for __ in range(height)]
    for r in range(height):
        for c in range(width):
            dists = [r + c, r + (width - 1 - c), (height - 1 - r) + c,
                     (height - 1 - r) + (width - 1 - c)]
            min_d = min(dists)
            for i in range(4):
                if dists[i] == min_d:
                    output[r][c] = corner_colors.get(i, 0) or 0
                    break

    return output

