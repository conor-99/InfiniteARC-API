# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: d9c4bbe4
Difficulty: very hard

=== Tags ===
- Pattern activation
- Pattern intersection
- Cut and unfold

=== Description ===
Input grids feature two distinct, overlapping visual patterns: a horizontal
pattern where each row repeats a sequence of colors (e.g., red, blue, green,
red, blue, green...) and a vertical pattern where each column repeats a sequence
of colors (e.g., blue, green, red, blue, green, red...). The intersection
points—where the color from the horizontal sequence matches the color from the
vertical sequence at the same cell—form a grid of cut points. The grid is
divided along all rows and columns containing at least one cut point, creating
rectangular regions. Each region is then rotated 180 degrees (top-left corner
moves to bottom-right, etc.) and placed back into its original position within
the grid. The output grid reflects this rotation, with all cut points removed
and regions rearranged according to the rotation. The background color (0)
remains unchanged, and no new patterns are introduced; the transformation is
purely spatial and based on the visual alignment of the input patterns. The
patterns must be non-trivially aligned (e.g., differing sequence periods) to
create complex intersection structures, requiring the solver to identify both
patterns, their intersections, and the rotation of each resulting region.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from typing import List, Dict

def generate():
    # Choose pattern periods (non-trivial periods to create complex intersections)
    h_period = random.randint(3, 5)
    v_period = random.randint(3, 5)

    # Choose grid size ensuring there's room to observe both patterns
    width = random.randint(max(3, h_period + 1), 30)
    height = random.randint(max(3, v_period + 1), 30)

    colors = list(range(1, 10))
    h_pattern = random.sample(colors, h_period)
    v_pattern = random.sample(colors, v_period)

    # Ensure there is at least one shared color so at least one cut point exists
    while set(h_pattern).isdisjoint(v_pattern):
        v_pattern = random.sample(colors, v_period)

    # Ensure vertical pattern has variation (so vertical columns are detectable)
    if len(set(v_pattern)) == 1:
        for i in range(v_period):
            for c in colors:
                if c != v_pattern[0]:
                    v_pattern[i] = c
                    break
            if len(set(v_pattern)) > 1:
                break

    # Choose how many columns will display the vertical pattern (vertical stripes)
    max_vcols = max(1, min(3, width - h_period))
    num_v_cols = random.randint(1, max_vcols)
    # Ensure there remain enough non-vertical columns to reveal the horizontal pattern
    nonvertical_count = width - num_v_cols
    if nonvertical_count < h_period:
        nonvertical_count = h_period
        num_v_cols = width - nonvertical_count

    # Build non-vertical columns so they cover all residues modulo h_period
    nonvertical_cols = list(range(h_period))
    remaining = [j for j in range(h_period, width) if j not in nonvertical_cols]
    extras_needed = nonvertical_count - len(nonvertical_cols)
    if extras_needed > 0:
        if extras_needed <= len(remaining):
            nonvertical_cols += random.sample(remaining, extras_needed)
        else:
            nonvertical_cols += remaining
    nonvertical_cols = sorted(nonvertical_cols)
    vertical_cols = sorted([j for j in range(width) if j not in nonvertical_cols])

    # Build the input grid: vertical columns show v_pattern down the column,
    # other columns show h_pattern across the row
    input_grid = [[0] * width for _ in range(height)]
    for i in range(height):
        for j in range(width):
            if j in vertical_cols:
                input_grid[i][j] = v_pattern[i % v_period]
            else:
                input_grid[i][j] = h_pattern[j % h_period]

    # Conceptual cut points are positions where horizontal and vertical sequences match
    cut_points = [[False] * width for _ in range(height)]
    for i in range(height):
        for j in range(width):
            if h_pattern[j % h_period] == v_pattern[i % v_period]:
                cut_points[i][j] = True

    # Rows and columns containing any cut points are dividers
    row_divs = [i for i in range(height) if any(cut_points[i])]
    col_divs = [j for j in range(width) if any(cut_points[r][j] for r in range(height))]
    row_divs.sort()
    col_divs.sort()

    def intervals(divs, size):
        if not divs:
            return [(0, size - 1)]
        ints = []
        if divs[0] > 0:
            ints.append((0, divs[0] - 1))
        for k in range(len(divs) - 1):
            a = divs[k] + 1
            b = divs[k + 1] - 1
            if a <= b:
                ints.append((a, b))
        if divs[-1] < size - 1:
            ints.append((divs[-1] + 1, size - 1))
        return ints

    row_intervals = intervals(row_divs, height)
    col_intervals = intervals(col_divs, width)

    # Create output: background zeros; each rectangular region (between divider rows/cols) is rotated 180 degrees
    output_grid = [[0] * width for _ in range(height)]
    for r0, r1 in row_intervals:
        for c0, c1 in col_intervals:
            sub = [row[c0:c1 + 1] for row in input_grid[r0:r1 + 1]]
            rotated = [row[::-1] for row in sub[::-1]]
            for dr, r in enumerate(range(r0, r1 + 1)):
                for dc, c in enumerate(range(c0, c1 + 1)):
                    output_grid[r][c] = rotated[dr][dc]

    # If by chance nothing changed (rare), tweak a non-divider cell and recompute
    if output_grid == input_grid:
        changed = False
        for r in range(height):
            for c in range(width):
                if r not in row_divs and c not in col_divs:
                    input_grid[r][c] = (input_grid[r][c] % 9) + 1
                    changed = True
                    break
            if changed:
                break
        output_grid = [[0] * width for _ in range(height)]
        for r0, r1 in row_intervals:
            for c0, c1 in col_intervals:
                sub = [row[c0:c1 + 1] for row in input_grid[r0:r1 + 1]]
                rotated = [row[::-1] for row in sub[::-1]]
                for dr, r in enumerate(range(r0, r1 + 1)):
                    for dc, c in enumerate(range(c0, c1 + 1)):
                        output_grid[r][c] = rotated[dr][dc]

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # Identify vertical columns: columns whose values vary down the rows
    vertical_cols = []
    non_vertical_cols = []
    for j in range(width):
        colvals = [grid[i][j] for i in range(height)]
        if any(colvals[i] != colvals[0] for i in range(1, height)):
            vertical_cols.append(j)
        else:
            non_vertical_cols.append(j)

    # Infer vertical pattern from the first vertical column
    if vertical_cols:
        j0 = vertical_cols[0]
        colvals = [grid[i][j0] for i in range(height)]
        maxp = min(5, height)
        v_period = None
        for p in range(1, maxp + 1):
            ok = True
            for i in range(height):
                if colvals[i] != colvals[i % p]:
                    ok = False
                    break
            if ok:
                v_period = p
                break
        if v_period is None:
            v_period = maxp
        v_pattern = [colvals[i] for i in range(v_period)]
    else:
        # Fallback (shouldn't happen with generator): assume trivial vertical pattern
        v_period = 1
        v_pattern = [grid[0][0] if height and width else 0]

    # Infer horizontal pattern using non-vertical columns (they show the horizontal sequence)
    first_row = grid[0] if height else []
    maxp = min(5, width)
    h_period = None
    h_pattern = None
    if non_vertical_cols:
        for p in range(1, maxp + 1):
            ok = True
            pat = [None] * p
            for j in non_vertical_cols:
                r = j % p
                val = first_row[j]
                if pat[r] is None:
                    pat[r] = val
                elif pat[r] != val:
                    ok = False
                    break
            if ok and all(x is not None for x in pat):
                h_period = p
                h_pattern = pat
                break
        if h_period is None:
            # Build a best-effort pattern from available non-vertical columns
            h_period = min(maxp, max(1, len(non_vertical_cols)))
            pat = [None] * h_period
            for j in non_vertical_cols:
                pat[j % h_period] = first_row[j]
            for i in range(h_period):
                if pat[i] is None:
                    pat[i] = first_row[non_vertical_cols[0]]
            h_pattern = pat
    else:
        # Fallback (shouldn't happen with generator): trivial horizontal pattern
        h_period = 1
        h_pattern = [grid[0][0] if height and width else 0]

    # Compute conceptual cut points where the two sequences agree
    cut_points = [[False] * width for _ in range(height)]
    for i in range(height):
        for j in range(width):
            if h_pattern[j % h_period] == v_pattern[i % v_period]:
                cut_points[i][j] = True

    row_divs = [i for i in range(height) if any(cut_points[i])]
    col_divs = [j for j in range(width) if any(cut_points[r][j] for r in range(height))]
    row_divs.sort()
    col_divs.sort()

    def intervals(divs, size):
        if not divs:
            return [(0, size - 1)]
        ints = []
        if divs[0] > 0:
            ints.append((0, divs[0] - 1))
        for k in range(len(divs) - 1):
            a = divs[k] + 1
            b = divs[k + 1] - 1
            if a <= b:
                ints.append((a, b))
        if divs[-1] < size - 1:
            ints.append((divs[-1] + 1, size - 1))
        return ints

    row_intervals = intervals(row_divs, height)
    col_intervals = intervals(col_divs, width)

    # Build output grid: background zeros and rotated regions
    output = [[0] * width for _ in range(height)]
    for r0, r1 in row_intervals:
        for c0, c1 in col_intervals:
            sub = [grid[r][c0:c1 + 1] for r in range(r0, r1 + 1)]
            rotated = [row[::-1] for row in sub[::-1]]
            for dr, r in enumerate(range(r0, r1 + 1)):
                for dc, c in enumerate(range(c0, c1 + 1)):
                    output[r][c] = rotated[dr][dc]

    return output

