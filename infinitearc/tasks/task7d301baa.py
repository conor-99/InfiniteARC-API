# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 7d301baa
Difficulty: hard

=== Tags ===
- Direction guesingcrop
- Symmetry completion
- Diagonal symmetry
- Create grid

=== Description ===
The task involves input grids containing partially filled colored cells (values
1-9) on a 2D grid of dimensions 1×1 to 30×30. The input grid is not symmetric,
but the existing non-zero cells are consistent with exactly one of two possible
diagonal symmetries: main diagonal symmetry (where cell (i,j) mirrors to (j,i))
or anti-diagonal symmetry (where cell (i,j) mirrors to (width-1-j, height-1-i)
in a rectangular grid). The solver must first infer the correct symmetry
direction by checking which diagonal alignment makes all existing non-zero cells
consistent (i.e., for main diagonal symmetry, existing (i,j) and (j,i) must
match in color; similarly for anti-diagonal). Once the direction is determined,
the output grid is generated by mirroring all non-zero cells across the inferred
diagonal to fill all symmetric positions, leaving empty cells (value 0)
unchanged. The challenge lies in deducing the correct symmetry direction from
the input's scattered non-zero cells, which requires analyzing relational
patterns rather than direct visual matching.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    w = random.randint(1, 30)
    h = random.randint(1, 30)
    while w == 1 and h == 1:
        w = random.randint(1, 30)
        h = random.randint(1, 30)
    grid_in = [[0]*w for _ in range(h)]
    
    symmetry = random.choice(['main', 'anti'])
    
    if symmetry == 'main':
        for i in range(h):
            for j in range(i, w):
                if random.random() > 0.5:
                    color = random.randint(1, 9)
                    grid_in[i][j] = color
                    if j < h:
                        grid_in[j][i] = color
        for i in range(h):
            for j in range(i+1, w):
                if random.random() < 0.3:
                    grid_in[i][j] = 0
        
        def is_symmetric_anti(grid):
            h = len(grid)
            w = len(grid[0])
            for i in range(h):
                for j in range(w):
                    if grid[i][j] != 0:
                        mirror_i = w - 1 - j
                        mirror_j = h - 1 - i
                        if 0 <= mirror_i < h and 0 <= mirror_j < w:
                            if grid[i][j] != grid[mirror_i][mirror_j]:
                                return False
            return True
        
        if is_symmetric_anti(grid_in):
            return generate()
        
        grid_out = [[0]*w for _ in range(h)]
        for i in range(h):
            for j in range(w):
                if grid_in[i][j] != 0:
                    grid_out[i][j] = grid_in[i][j]
                    if j < h and i < w:
                        grid_out[j][i] = grid_in[i][j]
        if grid_in == grid_out:
            return generate()
        return {'input': grid_in, 'output': grid_out}
    else:
        for i in range(h):
            for j in range(w):
                if random.random() > 0.5:
                    color = random.randint(1, 9)
                    grid_in[i][j] = color
                    mirror_i = w - 1 - j
                    mirror_j = h - 1 - i
                    if 0 <= mirror_i < h and 0 <= mirror_j < w:
                        grid_in[mirror_i][mirror_j] = color
        for i in range(h):
            for j in range(w):
                mirror_i = w - 1 - j
                mirror_j = h - 1 - i
                if 0 <= mirror_i < h and 0 <= mirror_j < w:
                    if grid_in[i][j] != 0 and grid_in[mirror_i][mirror_j] != 0:
                        if random.random() < 0.3:
                            grid_in[i][j] = 0
        
        def is_symmetric_main(grid):
            h = len(grid)
            w = len(grid[0])
            for i in range(h):
                for j in range(w):
                    if grid[i][j] != 0:
                        if j < h and i < w:
                            if grid[i][j] != grid[j][i]:
                                return False
            return True
        
        if is_symmetric_main(grid_in):
            return generate()
        
        grid_out = [[0]*w for _ in range(h)]
        for i in range(h):
            for j in range(w):
                if grid_in[i][j] != 0:
                    mirror_i = w - 1 - j
                    mirror_j = h - 1 - i
                    grid_out[i][j] = grid_in[i][j]
                    if 0 <= mirror_i < h and 0 <= mirror_j < w:
                        grid_out[mirror_i][mirror_j] = grid_in[i][j]
        if grid_in == grid_out:
            return generate()
        return {'input': grid_in, 'output': grid_out}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    h = len(input_grid)
    w = len(input_grid[0])
    main_consistent = True
    for i in range(h):
        for j in range(w):
            if input_grid[i][j] != 0:
                if j < h and i < w:
                    if input_grid[j][i] != 0 and input_grid[i][j] != input_grid[j][i]:
                        main_consistent = False
                        break
        if not main_consistent:
            break
    anti_consistent = True
    for i in range(h):
        for j in range(w):
            if input_grid[i][j] != 0:
                mirror_i = w - 1 - j
                mirror_j = h - 1 - i
                if 0 <= mirror_i < h and 0 <= mirror_j < w:
                    if input_grid[mirror_i][mirror_j] != 0 and input_grid[i][j] != input_grid[mirror_i][mirror_j]:
                        anti_consistent = False
                        break
        if not anti_consistent:
            break
    if main_consistent:
        output = [[0]*w for _ in range(h)]
        for i in range(h):
            for j in range(w):
                if input_grid[i][j] != 0:
                    output[i][j] = input_grid[i][j]
                    if j < h and i < w:
                        output[j][i] = input_grid[i][j]
        return output
    else:
        output = [[0]*w for _ in range(h)]
        for i in range(h):
            for j in range(w):
                if input_grid[i][j] != 0:
                    mirror_i = w - 1 - j
                    mirror_j = h - 1 - i
                    output[i][j] = input_grid[i][j]
                    if 0 <= mirror_i < h and 0 <= mirror_j < w:
                        output[mirror_i][mirror_j] = input_grid[i][j]
        return output
