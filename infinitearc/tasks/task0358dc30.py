# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 0358dc30
Difficulty: hard

=== Tags ===
- Multi object alignment

=== Description ===
The input grid consists of multiple distinct, non-overlapping objects
represented as connected regions of non-zero colors (e.g., red, blue, green
pixels). Each object is a contiguous shape with no internal gaps, and objects
are separated by at least one zero-value (background) pixel. The output grid
requires aligning all objects such that their topmost pixels (the smallest row
index containing the object) are positioned at the top row of the grid (row 0).
This transformation involves vertically shifting each object upward by the
number of rows between its current topmost pixel and row 0, while preserving the
internal structure and relative positions of all pixels within the object.
Objects must not overlap in the output, and the background (zero values) fills
all unoccupied areas. The rule is purely positional, relying on the visual
arrangement of pixels rather than numerical properties, color values, or spatial
relationships beyond top alignment.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, rand_sprite, connected, randint, random_colors

def generate():
    width = randint(5, 30)
    height = randint(5, 30)
    grid_in = grid(width, height, 0)
    colors = random_colors(2, exclude=[0])
    sprites = []
    for color in colors:
        sprite_pixels = rand_sprite("el", 3, 3)
        if not connected(sprite_pixels):
            continue
        sprites.append((sprite_pixels, color))
    
    current_col = 0
    for i, (sprite, color) in enumerate(sprites):
        rows = [p[0] for p in sprite]
        cols = [p[1] for p in sprite]
        min_row, max_row = min(rows), max(rows)
        min_col, max_col = min(cols), max(cols)
        sprite_width = max_col - min_col + 1
        
        row_start = randint(1, height - (max_row - min_row + 1))
        for (r, c) in sprite:
            new_r = row_start + (r - min_row)
            new_c = current_col + (c - min_col)
            if 0 <= new_r < height and 0 <= new_c < width:
                grid_in[new_r][new_c] = color
        current_col += sprite_width + 1
        if current_col >= width:
            break
    
    grid_out = grid(width, height, 0)
    for color in colors:
        min_row = height
        for r in range(height):
            for c in range(width):
                if grid_in[r][c] == color:
                    if r < min_row:
                        min_row = r
        if min_row == height:
            continue
        for r in range(height):
            for c in range(width):
                if grid_in[r][c] == color:
                    new_r = r - min_row
                    if 0 <= new_r < height:
                        grid_out[new_r][c] = color
    return {"input": grid_in, "output": grid_out}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid:
        return []
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = [[0] * width for _ in range(height)]
    colors = set()
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                colors.add(input_grid[r][c])
    
    for color in colors:
        min_row = height
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == color:
                    if r < min_row:
                        min_row = r
        if min_row == height:
            continue
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == color:
                    new_r = r - min_row
                    if 0 <= new_r < height:
                        output_grid[new_r][c] = color
    return output_grid
