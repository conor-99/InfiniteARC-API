# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 886a161d
Difficulty: very hard

=== Tags ===
- Cooperative beams
- Role dependent behavior
- Diagonals
- Analogical mapping between pairs

=== Description ===
Diagonal Beam Coordination  Input grids feature multiple diagonally arranged
beams (contiguous sequences of cells with identical color) of varying lengths
and directions. Each color corresponds to a specific role: color 2 (red) acts as
a source beam emitting directional projections, color 3 (blue) as a target beam
that absorbs and re-emits projections, and color 5 (yellow) as a reflector beam
that redirects projections. Beams are positioned at various angles (northeast,
northwest, southeast, southwest) and may intersect within the grid.  The
transformation requires: 1. Identifying each beam's role based on its color 2.
Tracing source beam projections along their diagonal direction until
encountering a target or reflector 3. Resolving intersection priorities: targets
override reflectors, with later intersections overwriting earlier paths 4.
Modifying paths upon interaction:    - Target beams (color 3) replace the
projection path with their own color and continue in original direction    -
Reflector beams (color 5) change projection direction by 90 degrees (e.g.,
northeast â†’ northwest) 5. All non-interactive cells and original beam positions
(except where modified by interactions) remain unchanged  The output grid must
depict all resolved projection paths after all interactions, with new paths
replacing original beams where applicable. This requires simultaneous tracking
of multiple diagonal paths, directional changes at reflectors, priority
resolution at intersections, and maintaining the grid's structural integrity.
The complexity arises from overlapping beam interactions, directional changes
requiring precise angle tracking, and the need to resolve conflicts between
multiple path intersections in a single transformation step.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    """
    Generates an input/output pair for the Diagonal Beam Coordination task.

    Grid contains diagonal beams of colors:
      - 2: source beams (length >= 2)
      - 3: target beams (length >= 1)
      - 5: reflector beams (length >= 1)

    Each source has exactly one open endpoint (the other endpoint touches the border)
    and emits a diagonal projection from that open endpoint. If the projection
    does not encounter any target/reflector along its ray, the generator places a
    single-cell target or reflector on that ray so there is at least one interaction.

    The output is produced by simulating all sources in row-major order. Paths
    overwrite previously drawn path cells; encountering a target retroactively
    recolors the source's drawn path to color 3 and causes subsequent path cells
    to be color 3. Reflectors (color 5) flip the horizontal component of the
    projection (NE->NW, SE->SW, etc.) and remain color 5.
    """
    diags = [(-1, -1), (-1, 1), (1, -1), (1, 1)]
    source_color = 2
    target_color = 3
    reflector_color = 5

    # Try until we create a valid configuration that yields at least one path pixel
    for attempt in range(200):
        size = random.randint(6, 10)
        ingrid = grid(size, size, 0)

        # Random counts
        num_targets = random.randint(1, 3)
        num_reflectors = random.randint(1, 3)
        num_sources = random.randint(1, 3)

        # Helper to test if a cell is inside
        def inside(r, c):
            return 0 <= r < size and 0 <= c < size

        # Place a diagonal beam (contiguous along a diagonal) if possible
        def place_beam(color, min_len=1, max_len=3, require_border_end=False, tries=200):
            for _ in range(tries):
                L = random.randint(min_len, max_len)
                dr, dc = random.choice(diags)
                r0 = random.randint(0, size - 1)
                c0 = random.randint(0, size - 1)
                coords = []
                ok = True
                for k in range(L):
                    r = r0 + k * dr
                    c = c0 + k * dc
                    if not inside(r, c) or ingrid[r][c] != 0:
                        ok = False
                        break
                    coords.append((r, c))
                if not ok:
                    continue

                e1 = coords[0]
                e2 = coords[-1]
                # Ensure at least one endpoint is on the border when required. This
                # helps to create a well-defined open endpoint for sources.
                if require_border_end:
                    at_border = lambda p: p[0] == 0 or p[0] == size - 1 or p[1] == 0 or p[1] == size - 1
                    if not (at_border(e1) or at_border(e2)):
                        continue

                # Place the beam
                for r, c in coords:
                    ingrid[r][c] = color
                return coords
            return None

        # Place targets and reflectors first
        placed_targets = []
        for _ in range(num_targets):
            coords = place_beam(target_color, min_len=1, max_len=3, require_border_end=False)
            if coords:
                placed_targets.append(coords)

        placed_reflectors = []
        for _ in range(num_reflectors):
            coords = place_beam(reflector_color, min_len=1, max_len=3, require_border_end=False)
            if coords:
                placed_reflectors.append(coords)

        # Place sources ensuring they have an open endpoint and at least one interaction
        placed_sources = []
        success_sources = True
        for _ in range(num_sources):
            placed = False
            for tries in range(200):
                coords = place_beam(source_color, min_len=2, max_len=4, require_border_end=True, tries=1)
                # place_beam with tries=1 was called to check a single random placement;
                # if it returned None we need to loop to try another random placement
                if coords is None:
                    continue

                # Determine step vector (dr_step, dc_step). For beams of length>=2,
                # coordinates are placed in generation order so adjacent cells differ by 1.
                if len(coords) >= 2:
                    dr_step = coords[1][0] - coords[0][0]
                    dc_step = coords[1][1] - coords[0][1]
                else:
                    # should not happen for sources since min_len=2
                    dr_step, dc_step = 1, 1

                e_start = coords[0]
                e_end = coords[-1]
                # Beyond cells for each endpoint
                b0 = (e_start[0] - dr_step, e_start[1] - dc_step)
                b1 = (e_end[0] + dr_step, e_end[1] + dc_step)

                def is_open(b):
                    return inside(b[0], b[1]) and ingrid[b[0]][b[1]] == 0

                open0 = is_open(b0)
                open1 = is_open(b1)

                # We expect exactly one open endpoint because we required a border touch
                # on one end; if both open or both blocked try another placement
                if open0 == open1:
                    # Undo placement and continue trying
                    for r, c in coords:
                        ingrid[r][c] = 0
                    continue

                # Determine emission direction: from blocked endpoint toward open endpoint
                if open1:
                    open_end = e_end
                    D = (dr_step, dc_step)
                else:
                    open_end = e_start
                    D = (-dr_step, -dc_step)

                # Trace the ray from the open endpoint to the border, collecting positions
                path = []
                r, c = open_end[0] + D[0], open_end[1] + D[1]
                while inside(r, c):
                    path.append((r, c))
                    r += D[0]
                    c += D[1]

                # There must be at least one cell on the ray; ensure at least one
                # empty cell before the first interaction (so the output will change)
                if len(path) < 1:
                    # Undo placement and continue
                    for rr, cc in coords:
                        ingrid[rr][cc] = 0
                    continue

                # Check if there is already a target or reflector on this ray
                ray_has_interaction = any(ingrid[r][c] in (target_color, reflector_color) for r, c in path)

                if not ray_has_interaction:
                    # Place a single-cell target or reflector on the ray, not at the first
                    # cell (so there will be at least one painted cell before interaction).
                    # Choose an index at least 1 if possible.
                    possible_idxs = [i for i in range(len(path)) if ingrid[path[i][0]][path[i][1]] == 0]
                    # Prefer indices >=1
                    possible_idxs = [i for i in possible_idxs if i >= 1] or possible_idxs
                    if not possible_idxs:
                        # No empty position on the ray (should be unlikely) -> undo and retry
                        for rr, cc in coords:
                            ingrid[rr][cc] = 0
                        continue
                    idx = random.choice(possible_idxs)
                    chosen = path[idx]
                    # Randomly decide whether to place a target (3) or reflector (5)
                    if random.random() < 0.6:
                        ingrid[chosen[0]][chosen[1]] = target_color
                    else:
                        ingrid[chosen[0]][chosen[1]] = reflector_color

                # Keep this source
                placed_sources.append(coords)
                placed = True
                break

            if not placed:
                success_sources = False
                break

        if not success_sources:
            # restart generation
            continue

        # Simulation: compute output by simulating sources in row-major order
        out = [row[:] for row in ingrid]

        # Helper: find diagonal-connected components of colors 2,3,5
        visited = [[False] * size for _ in range(size)]
        components = []  # list of (color, coords_list)
        for r in range(size):
            for c in range(size):
                if ingrid[r][c] in (source_color, target_color, reflector_color) and not visited[r][c]:
                    col = ingrid[r][c]
                    stack = [(r, c)]
                    comp = []
                    visited[r][c] = True
                    while stack:
                        pr, pc = stack.pop()
                        comp.append((pr, pc))
                        for dr, dc in diags:
                            nr, nc = pr + dr, pc + dc
                            if 0 <= nr < size and 0 <= nc < size and not visited[nr][nc] and ingrid[nr][nc] == col:
                                visited[nr][nc] = True
                                stack.append((nr, nc))
                    comp.sort()
                    components.append((col, comp))

        # Extract sources and sort them in row-major order by their top-left coordinate
        sources = []
        for col, comp in components:
            if col != source_color:
                continue
            # compute step vector for the beam (length >=2 guaranteed)
            if len(comp) >= 2:
                # sort by column to get consistent adjacency
                comp_by_col = sorted(comp, key=lambda x: (x[1], x[0]))
                r0, c0 = comp_by_col[0]
                r1, c1 = comp_by_col[1]
                dr_step = r1 - r0
                dc_step = c1 - c0
            else:
                # Fallback (shouldn't happen): treat as SE
                dr_step, dc_step = 1, 1
                comp_by_col = comp
            # endpoints
            e_start = min(comp, key=lambda p: (p[0], p[1]))
            e_end = max(comp, key=lambda p: (p[0], p[1]))
            # Determine open endpoint
            b0 = (e_start[0] - dr_step, e_start[1] - dc_step)
            b1 = (e_end[0] + dr_step, e_end[1] + dc_step)
            def is_open(b):
                return 0 <= b[0] < size and 0 <= b[1] < size and ingrid[b[0]][b[1]] == 0
            open0 = is_open(b0)
            open1 = is_open(b1)
            if open1 and not open0:
                open_end = e_end
                D = (dr_step, dc_step)
            elif open0 and not open1:
                open_end = e_start
                D = (-dr_step, -dc_step)
            else:
                # ambiguous; prefer the endpoint with an empty beyond cell, otherwise pick e_end
                if open1:
                    open_end = e_end
                    D = (dr_step, dc_step)
                elif open0:
                    open_end = e_start
                    D = (-dr_step, -dc_step)
                else:
                    # both blocked; skip this source (should not happen)
                    continue
            sources.append((min(comp), comp, open_end, D))

        # Sort sources by their anchor (top-left cell) to get deterministic "later"
        sources.sort(key=lambda x: (x[0][0], x[0][1]))

        # Simulate each source in order
        for anchor, comp, open_end, D in sources:
            cur_color = source_color
            path_cells = []  # the cells this source paints (so they can be recolored when hitting a target)
            r, c = open_end[0] + D[0], open_end[1] + D[1]
            steps = 0
            while 0 <= r < size and 0 <= c < size and steps < 500:
                steps += 1
                val = ingrid[r][c]
                if val == reflector_color:
                    # Reflect: flip horizontal component (NE->NW etc.). Reflectors remain color 5.
                    D = (D[0], -D[1])
                    r += D[0]
                    c += D[1]
                    continue
                if val == target_color:
                    # Retroactively recolor the path this source has painted so far to target_color
                    for pr, pc in path_cells:
                        # Only recolor cells that were empty in the original input
                        if ingrid[pr][pc] == 0:
                            out[pr][pc] = target_color
                    cur_color = target_color
                    # The target cell itself remains color 3 in out (already is)
                    r += D[0]
                    c += D[1]
                    continue
                # If it's any other non-zero cell (including another source), we stop the ray
                if val != 0:
                    break
                # Empty cell: paint with the current color (overwriting previous path colors)
                out[r][c] = cur_color
                path_cells.append((r, c))
                r += D[0]
                c += D[1]

        # Ensure that we actually changed the grid (output != input)
        changed = any(out[r][c] != ingrid[r][c] for r in range(size) for c in range(size))
        if not changed:
            continue

        return {"input": ingrid, "output": out}

    # Fallback (should not happen)
    size = 6
    ingrid = grid(size, size, 0)
    ingrid[3][1] = 2
    ingrid[2][2] = 3
    out = [row[:] for row in ingrid]
    out[1][3] = 3
    out[0][4] = 3
    return {"input": ingrid, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    ingrid = [list(row) for row in input_grid]
    h = len(ingrid)
    w = len(ingrid[0]) if h else 0

    source_color = 2
    target_color = 3
    reflector_color = 5
    diags = [(-1, -1), (-1, 1), (1, -1), (1, 1)]

    def inside(r, c):
        return 0 <= r < h and 0 <= c < w

    # Find diagonal-connected components of colors 2,3,5
    visited = [[False] * w for _ in range(h)]
    components = []
    for r in range(h):
        for c in range(w):
            if ingrid[r][c] in (source_color, target_color, reflector_color) and not visited[r][c]:
                col = ingrid[r][c]
                stack = [(r, c)]
                comp = []
                visited[r][c] = True
                while stack:
                    pr, pc = stack.pop()
                    comp.append((pr, pc))
                    for dr, dc in diags:
                        nr, nc = pr + dr, pc + dc
                        if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and ingrid[nr][nc] == col:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                comp.sort()
                components.append((col, comp))

    # Extract sources and determine their open endpoint and direction
    sources = []
    for col, comp in components:
        if col != source_color:
            continue
        # Determine step vector
        if len(comp) >= 2:
            comp_by_col = sorted(comp, key=lambda x: (x[1], x[0]))
            r0, c0 = comp_by_col[0]
            r1, c1 = comp_by_col[1]
            dr_step = r1 - r0
            dc_step = c1 - c0
        else:
            # Shouldn't happen for sources in generator, but be robust
            dr_step, dc_step = 1, 1
            comp_by_col = comp
        e_start = min(comp, key=lambda p: (p[0], p[1]))
        e_end = max(comp, key=lambda p: (p[0], p[1]))
        b0 = (e_start[0] - dr_step, e_start[1] - dc_step)
        b1 = (e_end[0] + dr_step, e_end[1] + dc_step)
        def is_open(b):
            return 0 <= b[0] < h and 0 <= b[1] < w and ingrid[b[0]][b[1]] == 0
        open0 = is_open(b0)
        open1 = is_open(b1)
        if open1 and not open0:
            open_end = e_end
            D = (dr_step, dc_step)
        elif open0 and not open1:
            open_end = e_start
            D = (-dr_step, -dc_step)
        else:
            # Ambiguous: pick an open side if any, otherwise treat as blocked (skip)
            if open1:
                open_end = e_end
                D = (dr_step, dc_step)
            elif open0:
                open_end = e_start
                D = (-dr_step, -dc_step)
            else:
                # Skip this source
                continue
        anchor = min(comp)
        sources.append((anchor, comp, open_end, D))

    # Sort sources in row-major order so later sources overwrite earlier ones
    sources.sort(key=lambda x: (x[0][0], x[0][1]))

    out = [row[:] for row in ingrid]

    # Simulate
    for anchor, comp, open_end, D in sources:
        cur_color = source_color
        path_cells = []
        r, c = open_end[0] + D[0], open_end[1] + D[1]
        steps = 0
        while 0 <= r < h and 0 <= c < w and steps < 1000:
            steps += 1
            val = ingrid[r][c]
            if val == reflector_color:
                # Flip horizontal component
                D = (D[0], -D[1])
                r += D[0]
                c += D[1]
                continue
            if val == target_color:
                # Retroactively recolor all cells painted by this source so far to target color
                for pr, pc in path_cells:
                    if ingrid[pr][pc] == 0:
                        out[pr][pc] = target_color
                cur_color = target_color
                r += D[0]
                c += D[1]
                continue
            if val != 0:
                # Hit some non-empty, non-interactive cell (including other sources) -> stop
                break
            # Empty: paint and continue
            out[r][c] = cur_color
            path_cells.append((r, c))
            r += D[0]
            c += D[1]

    return out

