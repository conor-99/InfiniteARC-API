# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 06f24a7f
Difficulty: very hard

=== Tags ===
- Context sensitive recolor
- Adaptive behavior switch
- Color clock
- Local state machine
- Remove intruder

=== Description ===
Input grids contain multiple interconnected, continuous paths formed by adjacent
cells of varying colors. Each path follows a predefined cyclic color sequence
(e.g., 0 → 1 → 2 → 3 → 0), but certain cells within these paths deviate from the
expected sequence—these are termed "intruders" and must be removed.
Additionally, the presence of a color 9 cell adjacent to any part of a path
triggers an adaptive behavior switch: the path's color sequence direction
reverses (e.g., from ascending 0→1→2 to descending 2→1→0) for all cells in that
path. The output grid requires three sequential transformations: first, remove
all intruder cells (cells not conforming to the path's expected sequence);
second, recolor the remaining cells to maintain the sequence while respecting
the direction dictated by the adaptive switch; third, ensure the recoloring is
context-sensitive, meaning each cell's new color depends on its immediate
neighbors and the current sequence direction (local state machine). The
direction switch is applied uniformly to all paths adjacent to a color 9 cell,
and no two adjacent cells in the output may share the same color in the
sequence. The task demands simultaneous tracking of path boundaries, sequence
states, and directional switches across a visually complex grid with overlapping
paths and multiple switches.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, all_pixels

def generate():
    # Generate a random grid size between 5x5 and 20x20
    width = random.randint(5, 20)
    height = random.randint(5, 20)
    input_grid = [[0] * width for _ in range(height)]

    # Place color 9 cells
    num_9 = random.randint(2, 5)
    for _ in range(num_9):
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        input_grid[r][c] = 9

    # Generate paths
    for _ in range(random.randint(2, 4)):
        r, c = random.randint(0, height-1), random.randint(0, width-1)
        path = []
        length = random.randint(5, 10)
        for _ in range(length):
            path.append((r, c))
            dr, dc = random.choice([(0,1), (0,-1), (1,0), (-1,0)])
            r = max(0, min(r + dr, height-1))
            c = max(0, min(c + dc, width-1))

        # Check adjacency to color 9
        adjacent_to_9 = False
        for (r, c) in path:
            for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 9:
                    adjacent_to_9 = True
                    break
            if adjacent_to_9:
                break

        # Determine direction
        direction = -1 if adjacent_to_9 else 1
        
        # Assign expected colors with intruders
        for idx, (r, c) in enumerate(path):
            expected_color = (idx * direction) % 4
            if random.random() < 0.3:  # 30% chance of intruder
                # Choose color not in expected color (0-3) or other (5-8)
                intruder_color = random.choice([x for x in range(4) if x != expected_color] + [5,6,7,8])
                input_grid[r][c] = intruder_color
            else:
                input_grid[r][c] = expected_color

    # Create output grid
    output_grid = [row[:] for row in input_grid]
    visited = [[False] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and input_grid[r][c] != 0 and input_grid[r][c] != 9:
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] != 0 and input_grid[nr][nc] != 9:
                            visited[nr][nc] = True
                            queue.append((nr, nc))

                # Check adjacency to color 9
                adjacent_to_9 = False
                for (cr, cc) in component:
                    for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 9:
                            adjacent_to_9 = True
                            break
                    if adjacent_to_9:
                        break
                direction = -1 if adjacent_to_9 else 1
                component.sort(key=lambda x: (x[0], x[1]))
                for i, (cr, cc) in enumerate(component):
                    expected_color = (i * direction) % 4
                    output_grid[cr][cc] = expected_color

    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    # Convert tuple to list of lists
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    visited = [[False] * width for _ in range(height)]

    for r in range(height):
        for c in range(width):
            if not visited[r][c] and grid[r][c] != 0 and grid[r][c] != 9:
                # Find connected component
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] != 0 and grid[nr][nc] != 9:
                            visited[nr][nc] = True
                            queue.append((nr, nc))

                # Check if component is adjacent to color 9
                adjacent_to_9 = False
                for (cr, cc) in component:
                    for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 9:
                            adjacent_to_9 = True
                            break
                    if adjacent_to_9:
                        break
                direction = -1 if adjacent_to_9 else 1

                # Sort component for consistent sequence
                component.sort(key=lambda x: (x[0], x[1]))
                for i, (cr, cc) in enumerate(component):
                    grid[cr][cc] = (i * direction) % 4

    return grid
