# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 8a455a9e
Difficulty: very hard

=== Tags ===
- Refraction simulation

=== Description ===
Input grids feature a background color with multiple disjoint contiguous colored
regions (each region is a single color, 1-9, distinct from background and other
regions). A light ray begins at the grid's top edge moving right. The ray
travels through background cells until entering a colored region. Upon entering
a region of color C, the ray turns 90 degrees in a fixed direction associated
with C (e.g., color 1 always turns left, color 2 always turns right, etc.),
continuing in the new direction until exiting the grid or entering another
region. The output grid displays the ray's complete path, drawn in the initial
ray color, with all turns accurately reflected. Regions and background remain
unchanged except for the path. The color-to-direction mapping is consistent
across all examples but must be discovered by the solver through induction. The
input grid contains complex arrangements of regions requiring multiple
refractions, with the ray path never overlapping regions or altering them.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    B = 0
    region_colors = random.sample([c for c in range(1, 10) if c != B], 3)
    turn_map = {c: -1 if c % 2 == 1 else 1 for c in region_colors}
    grid = common.grid(width, height, B)
    
    for color in region_colors:
        size = random.randint(3, 10)
        pixels = common.continuous_creature(size, width, height)
        for (r, c) in pixels:
            if r < height and c < width:
                grid[r][c] = color

    start_col = 0
    while start_col < width and grid[0][start_col] != B:
        start_col += 1
    if start_col >= width:
        start_col = random.randint(0, width-1)

    dr = [0, 1, 0, -1]
    dc = [1, 0, -1, 0]
    path = []
    r, c = 0, start_col
    D = 0
    while True:
        path.append((r, c))
        nr, nc = r + dr[D], c + dc[D]
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        if grid[nr][nc] != B:
            color = grid[nr][nc]
            turn = turn_map.get(color, 0)
            D = (D + turn) % 4
            r, c = nr, nc
        else:
            r, c = nr, nc

    output = [row[:] for row in grid]
    for (r, c) in path:
        output[r][c] = 5
    return {
        'input': grid,
        'output': output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    all_vals = [val for row in input_grid for val in row]
    B = max(set(all_vals), key=all_vals.count)
    
    def get_turn(color):
        if color == B:
            return 0
        return -1 if color % 2 == 1 else 1

    dr = [0, 1, 0, -1]
    dc = [1, 0, -1, 0]
    path = []
    r, c = 0, 0
    while c < width and input_grid[0][c] != B:
        c += 1
    if c >= width:
        c = 0
    D = 0
    while True:
        path.append((r, c))
        nr, nc = r + dr[D], c + dc[D]
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        if input_grid[nr][nc] != B:
            color = input_grid[nr][nc]
            turn = get_turn(color)
            D = (D + turn) % 4
            r, c = nr, nc
        else:
            r, c = nr, nc

    output = [list(row) for row in input_grid]
    for (r, c) in path:
        output[r][c] = 5
    return output
