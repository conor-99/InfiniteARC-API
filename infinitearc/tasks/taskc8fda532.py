# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: c8fda532
Difficulty: medium–hard

=== Tags ===
- Modular sequence

=== Description ===
Input grids are large (15×15 or larger) with a uniform background color. A
single, continuous path of distinct colored cells (each cell in the path has a
unique color from 1-9, different from the background) traverses the grid from
the top-left edge to the bottom-right edge. Each color along this path
corresponds to a specific, fixed grid transformation rule (e.g., color 1 =
rotate 90° clockwise, color 2 = flip horizontally, color 3 = shift rows up). The
output grid is generated by sequentially applying each transformation in the
order of the path’s color sequence. Transformations are applied to the current
state of the grid, so each subsequent transformation uses the grid modified by
the prior step. The path’s color sequence must be followed precisely, and all
transformations are deterministic and reversible. The path length is typically
3-5 cells, ensuring the sequence is neither too short to be ambiguous nor too
long to be impractical. The background color remains unchanged unless a
transformation specifically targets it (e.g., replacing background cells with
another color).
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, flip_horiz

def rotate_90(grid):
    return [list(x)[::-1] for x in zip(*grid)]

def shift_rows_up(grid):
    if not grid: return grid
    return grid[1:] + [grid[0]]

def shift_rows_down(grid):
    if not grid: return grid
    return [grid[-1]] + grid[:-1]

def shift_columns_left(grid):
    if not grid or not grid[0]: return grid
    return [row[1:] + [row[0]] for row in grid]

def shift_columns_right(grid):
    if not grid or not grid[0]: return grid
    return [row[-1:] + row[:-1] for row in grid]

def flip_vert(grid):
    return grid[::-1]

def rotate_180(grid):
    return [row[::-1] for row in grid][::-1]

def generate():
    H = 3
    W = 3
    B = random.randint(0, 9)
    
    # Ensure path colors are unique and exclude B
    path_colors = random.sample([c for c in range(1, 10) if c != B], 5)
    
    # Fixed continuous path from (0,0) to (2,2) in 3x3 grid
    path = [(0,0), (0,1), (0,2), (1,2), (2,2)]
    
    # Create input grid
    input_grid = grid(W, H, B)
    for (r, c), color in zip(path, path_colors):
        input_grid[r][c] = color
    
    # Create output grid by applying transformations
    output_grid = [row[:] for row in input_grid]
    for color in path_colors:
        if color == 1:
            output_grid = rotate_90(output_grid)
        elif color == 2:
            output_grid = flip_horiz(output_grid)
        elif color == 3:
            output_grid = shift_rows_up(output_grid)
        elif color == 4:
            output_grid = shift_columns_left(output_grid)
        elif color == 5:
            output_grid = flip_vert(output_grid)
        elif color == 6:
            output_grid = rotate_180(output_grid)
        elif color == 7:
            output_grid = shift_rows_down(output_grid)
        elif color == 8:
            output_grid = shift_columns_right(output_grid)
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import numpy as np
from common import flip_horiz

def rotate_90(grid):
    return [list(x)[::-1] for x in zip(*grid)]

def shift_rows_up(grid):
    if not grid: return grid
    return grid[1:] + [grid[0]]

def shift_rows_down(grid):
    if not grid: return grid
    return [grid[-1]] + grid[:-1]

def shift_columns_left(grid):
    if not grid or not grid[0]: return grid
    return [row[1:] + [row[0]] for row in grid]

def shift_columns_right(grid):
    if not grid or not grid[0]: return grid
    return [row[-1:] + row[:-1] for row in grid]

def flip_vert(grid):
    return grid[::-1]

def rotate_180(grid):
    return [row[::-1] for row in grid][::-1]

def p(input_grid):
    grid = [list(row) for row in input_grid]
    H, W = len(grid), len(grid[0])
    
    # Find background color (most frequent color)
    from collections import Counter
    all_colors = [cell for row in grid for cell in row]
    bg_color = Counter(all_colors).most_common(1)[0][0]
    
    # Find path from (0,0) to (H-1, W-1)
    path = []
    visited = [[False]*W for _ in range(H)]
    stack = [(0, 0)]
    visited[0][0] = True
    
    while stack:
        r, c = stack.pop()
        path.append((r, c))
        if r == H-1 and c == W-1:
            break
        for dr, dc in [(0,1), (1,0), (0,-1), (-1,0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc] and grid[nr][nc] != bg_color:
                visited[nr][nc] = True
                stack.append((nr, nc))
    
    # Get color sequence
    colors = [grid[r][c] for r, c in path]
    
    # Apply transformations
    for color in colors:
        if color == 1:
            grid = rotate_90(grid)
        elif color == 2:
            grid = flip_horiz(grid)
        elif color == 3:
            grid = shift_rows_up(grid)
        elif color == 4:
            grid = shift_columns_left(grid)
        elif color == 5:
            grid = flip_vert(grid)
        elif color == 6:
            grid = rotate_180(grid)
        elif color == 7:
            grid = shift_rows_down(grid)
        elif color == 8:
            grid = shift_columns_right(grid)
    
    return grid
