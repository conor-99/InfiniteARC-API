# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 62d26aa1
Difficulty: medium–hard

=== Tags ===
- Chain reaction
- Layered occlusion unfolding
- Deterministic reflection

=== Description ===
Chain Reaction Path Unfolding  Input grids feature a background of color 0, with
solid walls represented by distinct colors 1–4, transparent occlusion cells
marked by color 5, and a single source cell of color 6 positioned on the grid's
left edge. The walls form a maze-like structure with passages that allow
directional path propagation. The occlusion cells (color 5) are positioned along
potential paths and block movement until interacted with, appearing as layered
overlays on the background.  The transformation follows a deterministic chain
reaction starting at the source cell (color 6), moving eastward through
background cells (0). When the path encounters a wall (colors 1–4), it reflects
90 degrees according to fixed directional rules: east → north, north → west,
west → south, south → east. Upon reaching an occlusion cell (color 5), the cell
is removed (turned to background color 0), and the path continues through the
cell without changing direction. The reaction propagates until the path exits
the grid boundary, with all occlusion cells traversed during the reaction
replaced by background color in the output. Walls and the source cell remain
unchanged, while all other background cells retain their original color. The
output reveals the complete path of the chain reaction, with layered occlusions
systematically unfolded along the path as the reaction progresses.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def reflect(dir):
    dr, dc = dir
    if dr == 0 and dc == 1:
        return (-1, 0)
    elif dr == -1 and dc == 0:
        return (0, -1)
    elif dr == 0 and dc == -1:
        return (1, 0)
    elif dr == 1 and dc == 0:
        return (0, 1)

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    grid = [[0] * width for _ in range(height)]
    
    source_row = random.randint(2, height-3)
    grid[source_row][0] = 6
    
    current = (source_row, 0)
    direction = (0, 1)
    steps_to_wall = random.randint(2, 4)
    steps_count = 0
    max_steps = 1000
    step_count = 0
    
    while step_count < max_steps:
        next_r = current[0] + direction[0]
        next_c = current[1] + direction[1]
        if next_r < 0 or next_r >= height or next_c < 0 or next_c >= width:
            break
        
        if steps_count >= steps_to_wall:
            wall_color = random.choice([1, 2, 3, 4])
            grid[next_r][next_c] = wall_color
            direction = reflect(direction)
            steps_count = 0
            current = (next_r, next_c)
        else:
            grid[next_r][next_c] = 5
            steps_count += 1
            current = (next_r, next_c)
        step_count += 1
    
    output = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 5:
                output[r][c] = 0
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 5:
                grid[i][j] = 0
    return tuple(tuple(row) for row in grid)
