# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: d30b5f34
Difficulty: hard

=== Tags ===
- Embedded rule repetition
- Mimic pattern
- Dominant color

=== Description ===
The input grids feature a dominant background color (e.g., gray) with scattered
source patterns composed of distinct shapes formed by single-color clusters
(e.g., a cross of red pixels, a diagonal line of blue pixels). Embedded within
the grid are two critical visual elements: a rule sequence defined by a
horizontal line of a third color (e.g., yellow) whose length determines the
number of repetitions, and a cycle sequence defined by a horizontal line of
three distinct colors (e.g., red, blue, green) that dictates the color
progression for each repetition. The output grid must generate a new pattern by
replicating each source pattern the specified number of times, with each
repetition's color cycling through the cycle sequence in order. Repetitions are
arranged linearly in a new location (e.g., to the right of the input grid),
maintaining the source shape while sequentially applying the cycle colors. The
dominant background remains unchanged, and all embedded rule elements (rule
sequence, cycle sequence) are removed from the output. This requires identifying
the source shape, extracting the rule length via visual count of the rule
sequence, and applying the color cycle sequence to each repetition, making it a
hard task due to the need to simultaneously parse multiple embedded visual cues
and apply sequential transformations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    w = random.randint(10, 30)
    h = random.randint(10, 30)
    bg = 5
    rule_color = 4
    possible_colors = [1, 2, 3, 6, 7, 8, 9]
    sc = random.choice(possible_colors)
    cycle_colors = random.sample(possible_colors, 3)
    n = random.randint(2, 5)
    
    input_grid = grid(w, h, bg)
    
    r_rule = 5
    c_rule = 5
    for i in range(n):
        if c_rule + i < w:
            input_grid[r_rule][c_rule + i] = rule_color
    
    r_cycle = 6
    c_cycle = 5
    for i in range(3):
        if c_cycle + i < w:
            input_grid[r_cycle][c_cycle + i] = cycle_colors[i]
    
    r_source = 10
    c_source = 10
    r_source = max(1, min(h-2, r_source))
    c_source = max(1, min(w-2, c_source))
    input_grid[r_source][c_source] = sc
    if r_source - 1 >= 0:
        input_grid[r_source-1][c_source] = sc
    if r_source + 1 < h:
        input_grid[r_source+1][c_source] = sc
    if c_source - 1 >= 0:
        input_grid[r_source][c_source-1] = sc
    if c_source + 1 < w:
        input_grid[r_source][c_source+1] = sc
    
    output_grid = grid(w, h, bg)
    for i in range(n):
        color = cycle_colors[i % 3]
        center_x = 1
        center_y = 1 + 5 * i
        if center_x < h and center_y < w:
            output_grid[center_x][center_y] = color
            if center_x - 1 >= 0:
                output_grid[center_x-1][center_y] = color
            if center_x + 1 < h:
                output_grid[center_x+1][center_y] = color
            if center_y - 1 >= 0:
                output_grid[center_x][center_y-1] = color
            if center_y + 1 < w:
                output_grid[center_x][center_y+1] = color
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    h = len(input_list)
    w = len(input_list[0])
    all_pixels = [pixel for row in input_list for pixel in row]
    bg = max(set(all_pixels), key=all_pixels.count)
    
    rule_color = 4
    n = 0
    for r in range(h):
        current_run = 0
        for c in range(w):
            if input_list[r][c] == rule_color:
                current_run += 1
            else:
                if current_run > n:
                    n = current_run
                current_run = 0
        if current_run > n:
            n = current_run
    if n < 2:
        n = 2
    
    cycle_colors = None
    for r in range(h):
        for c in range(w-2):
            colors = [input_list[r][c], input_list[r][c+1], input_list[r][c+2]]
            if all(col != bg and col != rule_color for col in colors) and len(set(colors)) == 3:
                cycle_colors = colors
                break
        if cycle_colors:
            break
    if not cycle_colors:
        cycle_colors = [1, 2, 3]
    
    source_color = None
    for r in range(1, h-1):
        for c in range(1, w-1):
            if input_list[r][c] != bg and input_list[r][c] != rule_color:
                if input_list[r-1][c] == input_list[r][c] and input_list[r+1][c] == input_list[r][c] and input_list[r][c-1] == input_list[r][c] and input_list[r][c+1] == input_list[r][c]:
                    source_color = input_list[r][c]
                    break
        if source_color:
            break
    if not source_color:
        source_color = 1
    
    output_grid = grid(w, h, bg)
    for i in range(n):
        color = cycle_colors[i % 3]
        center_x = 1
        center_y = 1 + 5 * i
        if center_x < h and center_y < w:
            output_grid[center_x][center_y] = color
            if center_x - 1 >= 0:
                output_grid[center_x-1][center_y] = color
            if center_x + 1 < h:
                output_grid[center_x+1][center_y] = color
            if center_y - 1 >= 0:
                output_grid[center_x][center_y-1] = color
            if center_y + 1 < w:
                output_grid[center_x][center_y+1] = color
    
    return output_grid
