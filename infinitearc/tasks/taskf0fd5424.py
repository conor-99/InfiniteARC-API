# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: f0fd5424
Difficulty: hard

=== Tags ===
- Gas expansion
- Rule composition
- Loopless feedback
- Path following

=== Description ===
Input grids feature a single "gas source" cell (a distinct color, such as
purple) positioned along the grid's left edge. Scattered across the grid are
path cells colored with specific hues: red (direction: right), green (direction:
down), blue (direction: left), and yellow (direction: up). The path forms a
continuous, non-looping sequence starting adjacent to the gas source and
extending through the grid, with each path cell's color dictating the next
movement direction. Background cells are a neutral color (e.g., gray).   The
output grid replaces all cells along the path, from the gas source through the
path's endpoint, with the gas source's color. This transformation requires
solvers to trace the path by following each direction indicator, ensuring the
gas expands sequentially without deviation or looping. The complexity arises
from the path's intricate structure, which may include multiple direction
changes, and the need to distinguish path cells from background and other non-
path elements. The task demands compositional reasoning across multiple
directional steps, making it challenging for solvers to identify and follow the
path correctly.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Grid size
    width = random.randint(5, 30)
    height = random.randint(5, 30)

    # Colors (using common-like palette numbers)
    BACK = 5   # gray background
    GAS = 6    # gas source (purple/pink)
    LEFT = 1   # blue -> left
    RIGHT = 2  # red  -> right
    DOWN = 3   # green -> down
    UP = 4     # yellow -> up

    # Create empty grid
    grid = [[BACK for _ in range(width)] for _ in range(height)]

    # Place gas source on left edge
    source_row = random.randint(0, height - 1)
    grid[source_row][0] = GAS

    # Build a self-avoiding path that starts at column 1 and proceeds
    # monotonically toward the right edge (we allow up/down/right moves).
    r, c = source_row, 1
    visited = {(r, c)}
    path = [(r, c)]

    # Assign colors for each step so that each path cell indicates
    # the direction to the next cell. The final cell will point
    # off-grid (to the right) when it reaches the right edge.
    while True:
        # If we're at the rightmost column, mark this cell as pointing right
        # (which exits the grid) and finish.
        if c == width - 1:
            grid[r][c] = RIGHT
            break

        # Collect possible moves: up, down, right (no left to avoid touching col 0)
        candidates = []
        if r - 1 >= 0 and (r - 1, c) not in visited:
            candidates.append((r - 1, c, UP))
        if r + 1 < height and (r + 1, c) not in visited:
            candidates.append((r + 1, c, DOWN))
        if c + 1 < width and (r, c + 1) not in visited:
            candidates.append((r, c + 1, RIGHT))

        # If no candidates (should be rare with this construction), choose an
        # exit direction based on proximity to borders. This ensures the
        # current cell still carries a direction color.
        if not candidates:
            if r == 0:
                grid[r][c] = UP
            elif r == height - 1:
                grid[r][c] = DOWN
            else:
                # Fallback: point right (treat as exit)
                grid[r][c] = RIGHT
            break

        # Prefer moving right to ensure progress toward the exit, but allow
        # vertical wiggles for complexity.
        right_opt = None
        for nb in candidates:
            if nb[2] == RIGHT:
                right_opt = nb
                break
        if right_opt and random.random() < 0.7:
            nr, nc, color = right_opt
        else:
            nr, nc, color = random.choice(candidates)

        # Set the current cell's color to indicate the chosen move,
        # then advance to the next cell.
        grid[r][c] = color
        r, c = nr, nc
        visited.add((r, c))
        path.append((r, c))

    # Ensure the gas source remains the distinct color
    grid[source_row][0] = GAS

    # Add a small number of harmless distractor colored pixels (colors > 6)
    # placed off the path to increase variety. These do not affect solver logic.
    distractors = random.randint(0, 3)
    for _ in range(distractors):
        attempts = 0
        while attempts < 50:
            rr = random.randint(0, height - 1)
            cc = random.randint(1, width - 1)
            if (rr, cc) in visited:
                attempts += 1
                continue
            if (rr == source_row and cc == 0):
                attempts += 1
                continue
            color = random.choice([7, 8, 9])
            grid[rr][cc] = color
            break

    # Build the output grid: everything along the path (including the source)
    # is replaced with the gas color.
    output = [row[:] for row in grid]
    for (pr, pc) in path:
        output[pr][pc] = GAS
    output[source_row][0] = GAS

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    GAS = 6
    # Mapping from color to (dr, dc)
    moves = {1: (0, -1), 2: (0, 1), 3: (1, 0), 4: (-1, 0)}

    # Find the gas source on the left edge
    source_row = None
    for r in range(height):
        if grid[r][0] == GAS:
            source_row = r
            break
    if source_row is None:
        return tuple(tuple(row) for row in grid)

    # Start at the cell immediately to the right of the gas source
    r, c = source_row, 1
    # Follow the directional colors, painting visited path cells with GAS
    while 0 <= r < height and 0 <= c < width:
        color = grid[r][c]
        if color not in moves:
            break
        # Paint this cell with gas color, then move according to its color
        grid[r][c] = GAS
        dr, dc = moves[color]
        r += dr
        c += dc

    # Ensure the source remains GAS
    grid[source_row][0] = GAS
    return tuple(tuple(row) for row in grid)

