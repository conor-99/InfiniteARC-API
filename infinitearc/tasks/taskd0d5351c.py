# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: d0d5351c
Difficulty: medium

=== Tags ===
- Outline shapes
- Periodic tiling
- Associate images to patterns

=== Description ===
The task involves input grids containing a single closed outline shape (border)
of color 1 on a background of color 0. The output grid is formed by tiling the
minimal bounding box of this outline across the entire output grid. The bounding
box is the smallest rectangle that contains all outline pixels (color 1). For
example, if the input contains a 3×3 square outline (border pixels at the edges
of a 3×3 area), the output grid will repeat this exact 3×3 pattern in a grid-
like fashion. The transformation requires identifying the closed shape,
extracting its bounding box, and replicating that specific pattern periodically
without gaps or distortions. The task emphasizes visual recognition of the
shape's boundary and understanding how it scales through periodic repetition,
making it medium difficulty due to the need to distinguish the outline from
background and correctly compute the bounding box.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

count = 0

def generate():
    global count
    W = 2 + (count // 10)
    H = 2 + (count % 10)
    count += 1
    input_grid = [[0] * H for _ in range(W)]
    for i in range(W):
        input_grid[i][0] = 1
        input_grid[i][H-1] = 1
    for j in range(H):
        input_grid[0][j] = 1
        input_grid[W-1][j] = 1
    output_grid = []
    for i in range(2*W):
        row = []
        for j in range(2*H):
            row.append(input_grid[i % W][j % H])
        output_grid.append(row)
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    ones = []
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] == 1:
                ones.append((r, c))
    if not ones:
        return input_grid
    min_r = min(r for r, c in ones)
    max_r = max(r for r, c in ones)
    min_c = min(c for r, c in ones)
    max_c = max(c for r, c in ones)
    pattern = []
    for r in range(min_r, max_r + 1):
        pattern.append(input_grid[r][min_c:max_c + 1])
    h = max_r - min_r + 1
    w = max_c - min_c + 1
    output_grid = []
    for i in range(2*h):
        row = []
        for j in range(2*w):
            row.append(pattern[i % h][j % w])
        output_grid.append(row)
    return output_grid
