# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: e7f3052c
Difficulty: hard

=== Tags ===
- Measure length

=== Description ===
The task involves transforming an input grid into an output grid where each non-
zero cell is replaced by the size of its 4-connected component (including
itself) of the same color. Zero-valued cells remain unchanged. A 4-connected
component consists of adjacent cells (up, down, left, right) sharing the same
non-zero value. The output grid's dimensions match the input exactly, with all
values between 0 and 9. For example, a 3x3 block of color 5 results in all 9
cells in the output being replaced with 9. The transformation requires
identifying connected regions and quantifying their size, making it challenging
due to the need for abstract reasoning about spatial relationships rather than
simple pattern matching.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    while True:
        w_comp = random.randint(1, min(5, width))
        h_comp = random.randint(1, min(5, height))
        S = w_comp * h_comp
        if 2 <= S <= 9:
            break
    colors = [i for i in range(1, 10) if i != S]
    C = random.choice(colors)
    input_grid = [[0] * width for _ in range(height)]
    for r in range(h_comp):
        for c in range(w_comp):
            input_grid[r][c] = C
    output_grid = [[0] * width for _ in range(height)]
    for r in range(h_comp):
        for c in range(w_comp):
            output_grid[r][c] = S
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import collections

def p(input_grid):
    if not input_grid or not input_grid[0]:
        return []
    height = len(input_grid)
    width = len(input_grid[0])
    visited = [[False] * width for _ in range(height)]
    output = [[0] * width for _ in range(height)]
    
    def bfs(r, c, color):
        queue = collections.deque([(r, c)])
        component = []
        while queue:
            r1, c1 = queue.popleft()
            if visited[r1][c1] or input_grid[r1][c1] != color:
                continue
            visited[r1][c1] = True
            component.append((r1, c1))
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                r2, c2 = r1 + dr, c1 + dc
                if 0 <= r2 < height and 0 <= c2 < width and not visited[r2][c2] and input_grid[r2][c2] == color:
                    queue.append((r2, c2))
        return component
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                color = input_grid[r][c]
                comp = bfs(r, c, color)
                size = len(comp)
                for (r2, c2) in comp:
                    output[r2][c2] = size
    return output
