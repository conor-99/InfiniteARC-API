# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 48bebff7
Difficulty: very hard

=== Tags ===
- Local symmetry matching
- Maze wave

=== Description ===
Input grids are medium to large (15×15 to 30×30) featuring a maze-like structure
composed of solid wall segments (non-zero colors) and background path cells
(color 0). The maze contains multiple localized symmetry regions, each defined
by a 2×2 block of wall cells exhibiting mirror symmetry across either a
horizontal or vertical axis through the block's center. These symmetry regions
are distinct, non-overlapping, and each centered on a background path cell (the
symmetry anchor).  In the output grid, each symmetry region is transformed into
a wave pattern that propagates outward from the symmetry anchor along the axis
of symmetry. For horizontal symmetry (mirroring left-right), the wave propagates
vertically (up-down) along the vertical axis through the anchor, alternating
between two distinct colors (e.g., 3 and 4) in a diagonal pattern. For vertical
symmetry (mirroring top-bottom), the wave propagates horizontally (left-right)
along the horizontal axis, alternating between two other colors (e.g., 5 and 6).
The wave pattern extends for 3–5 cells in both directions from the anchor,
replacing the original wall cells in the symmetry region. The background paths
remain unchanged except where overlapped by the wave pattern, and no two wave
patterns intersect or overlap with each other or existing maze walls.  All non-
symmetry regions of the maze remain visually identical to the input grid. The
wave patterns are designed to be visually distinct from the original walls, with
the alternating color sequence clearly visible as a "wave" effect. The task
requires identifying all symmetry anchors, determining the symmetry axis type,
and correctly applying the corresponding wave pattern direction and color
sequence.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid


def generate():
    size = random.randint(15, 30)
    grid_in = grid(size, size, 0)
    
    # Add maze walls (non-zero)
    for r in range(size):
        for c in range(size):
            if random.random() > 0.7:
                grid_in[r][c] = random.randint(1, 9)
    
    grid_out = [row[:] for row in grid_in]
    symmetry_anchors = []
    
    # Find symmetry anchors
    for r in range(1, size-1):
        for c in range(1, size-1):
            if grid_in[r][c] == 0:
                # Horizontal symmetry (left-right)
                if (grid_in[r-1][c-1] == grid_in[r-1][c+1] and 
                    grid_in[r][c-1] == grid_in[r][c+1]):
                    symmetry_anchors.append((r, c, 'horizontal'))
                # Vertical symmetry (top-bottom)
                elif (grid_in[r-1][c-1] == grid_in[r+1][c-1] and 
                      grid_in[r-1][c] == grid_in[r+1][c]):
                    symmetry_anchors.append((r, c, 'vertical'))

    # Apply fixed 3-step wave patterns
    for (r, c, symmetry_type) in symmetry_anchors:
        if symmetry_type == 'horizontal':
            colors = [3, 4]
            for i in range(1, 4):
                if r - i >= 0:
                    grid_out[r-i][c] = colors[i % 2]
                if r + i < size:
                    grid_out[r+i][c] = colors[i % 2]
        else:
            colors = [5, 6]
            for i in range(1, 4):
                if c - i >= 0:
                    grid_out[r][c-i] = colors[i % 2]
                if c + i < size:
                    grid_out[r][c+i] = colors[i % 2]
    
    return {
        "input": grid_in,
        "output": grid_out
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid_in = [list(row) for row in input_grid]
    size = len(grid_in)
    grid_out = [row[:] for row in grid_in]
    
    for r in range(1, size-1):
        for c in range(1, size-1):
            if grid_in[r][c] == 0:
                if (grid_in[r-1][c-1] == grid_in[r-1][c+1] and 
                    grid_in[r][c-1] == grid_in[r][c+1]):
                    for i in range(1, 4):
                        if r - i >= 0:
                            grid_out[r-i][c] = 4 if i % 2 else 3
                        if r + i < size:
                            grid_out[r+i][c] = 4 if i % 2 else 3
                elif (grid_in[r-1][c-1] == grid_in[r+1][c-1] and 
                      grid_in[r-1][c] == grid_in[r+1][c]):
                    for i in range(1, 4):
                        if c - i >= 0:
                            grid_out[r][c-i] = 6 if i % 2 else 5
                        if c + i < size:
                            grid_out[r][c+i] = 6 if i % 2 else 5
    
    return grid_out
