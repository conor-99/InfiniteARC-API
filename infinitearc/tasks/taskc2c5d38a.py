# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: c2c5d38a
Difficulty: hard

=== Tags ===
- Momentum conservation path
- Replace pattern
- Lattice completion

=== Description ===
Input grids consist of a lattice structure formed by disjoint border squares of
uniform color, each containing a uniquely colored embedded square at its center.
The lattice is arranged with non-uniform spacing between squares (1-5 background
cells separating adjacent squares in rows/columns), and all embedded squares
share the same fixed size M (1 ≤ M ≤ N−2, where N is the border square size). A
path through the lattice is defined by a sequence of embedded colors (the
"pattern") visible as a horizontal strip in the bottom-left corner of the grid.
The sequence starts with the top-left lattice square's embedded color, with each
subsequent color indicating the next adjacent square in the path
(up/down/left/right).  The output grid transforms the input by drawing straight
horizontal or vertical bands between consecutive squares in the path. Each band
has a thickness equal to M, occupies only background cells (not overlapping
borders or embedded squares), and uses the embedded color of the starting square
in the pair. Bands are drawn between the facing edges of consecutive squares
(e.g., right edge of square A to left edge of square B for horizontal movement).
The lattice structure, border squares, embedded colors, and pattern strip remain
unchanged. The transformation enforces "momentum conservation" by requiring
bands to align with the direct axis between squares (no diagonal bands), and
"replace pattern" by substituting background cells with band colors along the
path. "Lattice completion" is achieved by visually connecting all path steps
through the lattice with continuous bands.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random


def generate():
    # We will construct a lattice of disjoint border squares (size N) each containing
    # a centered embedded square of size M. Spacings between squares vary 1..5.
    # The lattice shape is chosen so the number of embedded squares <= 8 (we need unique colors).

    shapes = [(2, 2), (2, 3), (2, 4), (3, 2), (4, 2)]

    attempts = 0
    while True:
        attempts += 1
        if attempts > 200:
            # fallback deterministic small shape if we somehow cannot fit after many tries
            R, C = 2, 2
        else:
            R, C = random.choice(shapes)

        N = random.randint(3, 6)           # border square size
        M = random.randint(1, max(1, N - 2))  # embedded square size, must be <= N-2

        # random spacings between adjacent border squares (1..5)
        h_spacings = [random.randint(1, 5) for _ in range(C - 1)]
        v_spacings = [random.randint(1, 5) for _ in range(R - 1)]

        left_margin = random.randint(1, 3)
        top_margin = random.randint(1, 3)
        right_margin = random.randint(1, 3)
        bottom_margin = random.randint(1, 3)
        pattern_height = 1  # we'll draw the horizontal pattern in a single bottom row

        # compute column left positions for border squares
        col_lefts = [left_margin]
        for j in range(1, C):
            col_lefts.append(col_lefts[-1] + N + h_spacings[j - 1])

        # compute row top positions
        row_tops = [top_margin]
        for i in range(1, R):
            row_tops.append(row_tops[-1] + N + v_spacings[i - 1])

        lattice_total_width = col_lefts[-1] + N
        lattice_total_height = row_tops[-1] + N

        grid_width = lattice_total_width + right_margin
        grid_height = lattice_total_height + bottom_margin + pattern_height

        if grid_width <= 30 and grid_height <= 30:
            break

    width, height = grid_width, grid_height
    grid = [[0 for _ in range(width)] for _ in range(height)]

    # pick border color and embedded colors (embedded colors must be unique and != border_color)
    border_color = random.randint(1, 9)
    available = [c for c in range(1, 10) if c != border_color]
    # We ensured R*C <= 8 so this sample is safe
    embedded_colors = random.sample(available, R * C)

    # place border squares and embedded centered squares
    pad = (N - M) // 2

    # map lattice positions to their embedded colors
    color_map = {}
    idx = 0
    for i in range(R):
        for j in range(C):
            color_map[(i, j)] = embedded_colors[idx]
            idx += 1

    for i in range(R):
        for j in range(C):
            r0 = row_tops[i]
            c0 = col_lefts[j]
            # fill border square with border_color
            for rr in range(r0, r0 + N):
                for cc in range(c0, c0 + N):
                    grid[rr][cc] = border_color
            # place embedded centered MxM block
            er = r0 + pad
            ec = c0 + pad
            ecolor = color_map[(i, j)]
            for rr in range(er, er + M):
                for cc in range(ec, ec + M):
                    grid[rr][cc] = ecolor

    # create a simple path that starts at top-left (0,0) and visits adjacent lattice squares
    # Use DFS with backtracking to construct a simple path (no repeats)
    neighbors_cache = {}
    for i in range(R):
        for j in range(C):
            nbs = []
            if i > 0: nbs.append((i - 1, j))
            if i < R - 1: nbs.append((i + 1, j))
            if j > 0: nbs.append((i, j - 1))
            if j < C - 1: nbs.append((i, j + 1))
            neighbors_cache[(i, j)] = nbs

    # target path length (at least 2)
    max_len = R * C
    target_len = random.randint(2, max_len)

    def find_path(start, length):
        path = [start]
        visited = {start}

        def dfs():
            if len(path) == length:
                return True
            cur = path[-1]
            nbs = neighbors_cache[cur][:]
            random.shuffle(nbs)
            for nb in nbs:
                if nb in visited:
                    continue
                visited.add(nb)
                path.append(nb)
                if dfs():
                    return True
                path.pop()
                visited.remove(nb)
            return False

        ok = dfs()
        return path if ok else None

    # try to get a path; if fails, reduce target length
    attempt = 0
    path_coords = None
    while attempt < 50 and target_len >= 2:
        path_coords = find_path((0, 0), target_len)
        if path_coords:
            break
        target_len -= 1
        attempt += 1

    if not path_coords:
        # fallback minimal path
        path_coords = [(0, 0), (0, 1)] if C > 1 else [(0, 0), (1, 0)]

    # draw the pattern strip in the bottom-left corner (single row)
    pattern_row = height - 1
    for k, pos in enumerate(path_coords):
        if k >= width:
            break
        grid[pattern_row][k] = color_map[pos]

    # produce the output by drawing M-thick straight bands between consecutive squares in path
    output = [list(r) for r in grid]

    for a, b in zip(path_coords[:-1], path_coords[1:]):
        i_prev, j_prev = a
        i_curr, j_curr = b
        r_prev = row_tops[i_prev]
        c_prev = col_lefts[j_prev]
        r_curr = row_tops[i_curr]
        c_curr = col_lefts[j_curr]
        ecolor = color_map[(i_prev, j_prev)]

        if i_prev == i_curr:
            # horizontal band: rows = embedded rows, columns between right edge of prev and left edge of curr
            er = r_prev + pad
            rows_to_fill = list(range(er, er + M))
            if c_curr > c_prev:
                start_col = c_prev + N
                end_col = c_curr
            else:
                start_col = c_curr + N
                end_col = c_prev
            for rr in rows_to_fill:
                for cc in range(start_col, end_col):
                    # only replace background cells (do not overwrite borders/embedded squares or the pattern strip)
                    if output[rr][cc] == 0:
                        output[rr][cc] = ecolor
        else:
            # vertical band: columns = embedded columns, rows between bottom edge of prev and top edge of curr
            ec = c_prev + pad
            cols_to_fill = list(range(ec, ec + M))
            if r_curr > r_prev:
                start_row = r_prev + N
                end_row = r_curr
            else:
                start_row = r_curr + N
                end_row = r_prev
            for cc in cols_to_fill:
                for rr in range(start_row, end_row):
                    if output[rr][cc] == 0:
                        output[rr][cc] = ecolor

    return {'input': grid, 'output': output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Find connected components for each non-zero color
    visited = [[False] * width for _ in range(height)]
    components = {}  # color -> list of components (list of (r,c))

    for r in range(height):
        for c in range(width):
            col = grid[r][c]
            if col == 0 or visited[r][c]:
                continue
            # flood fill
            stack = [(r, c)]
            visited[r][c] = True
            comp = []
            while stack:
                rr, cc = stack.pop()
                comp.append((rr, cc))
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == col:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            components.setdefault(col, []).append(comp)

    # Determine M (embedded square size) by examining fully filled square components (area == bbox area)
    filled_squares = []  # tuples (size, color, min_r, min_c)
    for col, comps in components.items():
        for comp in comps:
            rs = [p[0] for p in comp]
            cs = [p[1] for p in comp]
            h = max(rs) - min(rs) + 1
            w = max(cs) - min(cs) + 1
            if h == w and len(comp) == h * w:
                filled_squares.append((h, col, min(rs), min(cs)))

    if not filled_squares:
        return grid

    # Most common filled-square size is M
    from collections import Counter
    size_counts = Counter([t[0] for t in filled_squares])
    M = size_counts.most_common(1)[0][0]

    # Filter filled squares for candidates that look embedded (have non-zero different neighbor outside their bbox)
    embedded = {}
    for size, col, er, ec in filled_squares:
        if size != M:
            continue
        # neighbors just outside the square
        neigh = []
        if er - 1 >= 0:
            neigh.append(grid[er - 1][ec])
        if er + size < height:
            neigh.append(grid[er + size][ec])
        if ec - 1 >= 0:
            neigh.append(grid[er][ec - 1])
        if ec + size < width:
            neigh.append(grid[er][ec + size])
        # prefer candidates that have a non-zero neighbor that is different from the embedded color
        if any(n != 0 and n != col for n in neigh):
            # this is likely the embedded square inside a border
            # only keep the first such component for that color (colors are unique for embedded squares)
            if col not in embedded:
                embedded[col] = (er, ec)

    if not embedded:
        # fallback to any filled squares of size M (this is unlikely but safe)
        for size, col, er, ec in filled_squares:
            if size == M and col not in embedded:
                embedded[col] = (er, ec)

    # For each embedded square find its border square top-left and N by scanning left/up/right from the embedded block
    border_info = {}  # color -> (r_top, c_top, N, border_color)
    for col, (er, ec) in embedded.items():
        # find border color by looking at a neighbour just outside the embedded block (left or above)
        bcolor = None
        if ec - 1 >= 0:
            bcolor = grid[er][ec - 1]
        if (bcolor is None or bcolor == 0) and er - 1 >= 0:
            bcolor = grid[er - 1][ec]
        if bcolor is None:
            bcolor = 0

        # scan left from ec-1 while equal to border color
        c = ec - 1
        while c >= 0 and grid[er][c] == bcolor:
            c -= 1
        c_top = c + 1

        # scan up from er-1 while equal to border color
        r = er - 1
        while r >= 0 and grid[r][ec] == bcolor:
            r -= 1
        r_top = r + 1

        # scan right from ec+M while equal to border color to find right edge
        c2 = ec + M
        while c2 < width and grid[er][c2] == bcolor:
            c2 += 1
        right_edge = c2 - 1

        # compute N as width of border block
        N = right_edge - c_top + 1 if right_edge >= c_top else M

        border_info[col] = (r_top, c_top, N, bcolor)

    # Build sorted lists of embed row and column coordinates to get lattice ordering (top->bottom, left->right)
    embed_rows = sorted({pos[0] for pos in embedded.values()})
    embed_cols = sorted({pos[1] for pos in embedded.values()})

    # Identify the top-left lattice embedded color (start of path)
    top_left_row = embed_rows[0]
    top_left_col = embed_cols[0]
    top_left_color = None
    for col, (er, ec) in embedded.items():
        if er == top_left_row and ec == top_left_col:
            top_left_color = col
            break

    # find the pattern row by scanning bottom-up for a left-anchored contiguous run of nonzero cells
    pattern_row = None
    pattern = []
    embed_color_set = set(embedded.keys())
    for r in range(height - 1, -1, -1):
        c = 0
        seq = []
        while c < width and grid[r][c] != 0:
            seq.append(grid[r][c])
            c += 1
        if seq and all(x in embed_color_set for x in seq) and seq[0] == top_left_color:
            pattern_row = r
            pattern = seq
            break

    if not pattern:
        # fallback: try any leftmost run in the last two rows
        for r in range(max(0, height - 3), height):
            c = 0
            seq = []
            while c < width and grid[r][c] != 0:
                seq.append(grid[r][c])
                c += 1
            if seq and all(x in embed_color_set for x in seq):
                pattern_row = r
                pattern = seq
                break

    if not pattern:
        return grid

    # Convert pattern colors to lattice embed top-left positions
    path_positions = []  # list of (er, ec)
    for col in pattern:
        if col in embedded:
            path_positions.append(embedded[col])

    output = [row[:] for row in grid]

    # Draw bands between consecutive embedded squares according to the rules
    for k in range(1, len(path_positions)):
        prev_er, prev_ec = path_positions[k - 1]
        cur_er, cur_ec = path_positions[k]
        prev_color = grid[prev_er][prev_ec]

        # recover border info using the color at the previous embedded square
        info = border_info.get(prev_color)
        if not info:
            # attempt to locate by coordinate
            found_col = None
            for col, (er, ec) in embedded.items():
                if er == prev_er and ec == prev_ec:
                    found_col = col
                    break
            info = border_info.get(found_col)
            if not info:
                continue

        prev_rtop, prev_ctop, prev_N, _ = info

        # get current's border info as well
        cur_color = grid[cur_er][cur_ec]
        cur_info = border_info.get(cur_color)
        if not cur_info:
            for col, (er, ec) in embedded.items():
                if er == cur_er and ec == cur_ec:
                    cur_info = border_info.get(col)
                    break
        if not cur_info:
            continue
        cur_rtop, cur_ctop, cur_N, _ = cur_info

        if prev_er == cur_er:
            # horizontal connection
            rows_to_fill = range(prev_er, prev_er + M)
            if cur_ctop > prev_ctop:
                start_col = prev_ctop + prev_N
                end_col = cur_ctop
            else:
                start_col = cur_ctop + cur_N
                end_col = prev_ctop
            for rr in rows_to_fill:
                for cc in range(start_col, end_col):
                    if 0 <= rr < height and 0 <= cc < width and output[rr][cc] == 0:
                        output[rr][cc] = prev_color
        else:
            # vertical connection
            cols_to_fill = range(prev_ec, prev_ec + M)
            if cur_rtop > prev_rtop:
                start_row = prev_rtop + prev_N
                end_row = cur_rtop
            else:
                start_row = cur_rtop + cur_N
                end_row = prev_rtop
            for cc in cols_to_fill:
                for rr in range(start_row, end_row):
                    if 0 <= rr < height and 0 <= cc < width and output[rr][cc] == 0:
                        output[rr][cc] = prev_color

    return output

