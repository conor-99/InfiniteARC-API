# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 58bb8c7c
Difficulty: very hard

=== Tags ===
- Collision marking
- Local convolution rule
- Pattern modification
- Feedback route
- Complete the 2x2 color pattern

=== Description ===
Input grids consist of a large grid (e.g., 16×16) composed of overlapping 2×2
blocks arranged in a grid-like pattern, where each block contains four distinct
colors (0–9) with background cells (color 0) filling gaps between blocks.
Adjacent blocks sharing an edge may have matching colors along their common
boundary (e.g., the right edge of a left block matches the left edge of a right
block). At each such matching boundary, a collision mark (color 9) is placed in
the output grid between the blocks. The collision marks form a non-rectilinear
path that must be completed to form a consistent 2×2 color pattern. The output
grid is generated through three sequential steps: (1) marking all boundary
collisions with color 9, (2) identifying the incomplete 2×2 pattern formed by
the collision path (e.g., a diagonal, spiral, or cycle), and (3) completing the
pattern by adding missing collision marks in the direction of the existing path,
ensuring the completed pattern aligns with the progression of the input marks.
The background remains unchanged, and all original block colors are preserved.
The task requires detecting edge matches, recognizing the path's geometric
progression, and applying spatial reasoning to complete the 2×2 pattern without
overwriting existing block colors or background.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    size = 15
    grid_size = size
    input_grid = grid(grid_size, grid_size, 0)
    
    # Place 5x5 blocks (each 2x2) with 1 gap between
    for i in range(5):
        for j in range(5):
            # Generate 4 distinct colors for the block
            colors = random.sample(range(1, 10), 4)
            r0, c0 = i * 3, j * 3
            input_grid[r0][c0] = colors[0]
            input_grid[r0][c0+1] = colors[1]
            input_grid[r0+1][c0] = colors[2]
            input_grid[r0+1][c0+1] = colors[3]

    # Create output grid as copy of input
    output_grid = [row[:] for row in input_grid]

    # Check horizontal adjacencies and mark collision
    for i in range(5):
        for j in range(4):
            r0 = i * 3
            # Right edge of block (i,j)
            right_edge = (input_grid[r0][j*3+1], input_grid[r0+1][j*3+1])
            # Left edge of block (i,j+1)
            left_edge = (input_grid[r0][j*3+3], input_grid[r0+1][j*3+3])
            if right_edge == left_edge:
                # Mark gap cells (columns j*3+2, rows r0 and r0+1)
                output_grid[r0][j*3+2] = 9
                output_grid[r0+1][j*3+2] = 9

    # Check vertical adjacencies and mark collision
    for j in range(5):
        for i in range(4):
            c0 = j * 3
            # Bottom edge of block (i,j)
            bottom_edge = (input_grid[i*3+1][c0], input_grid[i*3+1][c0+1])
            # Top edge of block (i+1,j)
            top_edge = (input_grid[i*3+3][c0], input_grid[i*3+3][c0+1])
            if bottom_edge == top_edge:
                # Mark gap cells (rows i*3+2, columns c0 and c0+1)
                output_grid[i*3+2][c0] = 9
                output_grid[i*3+2][c0+1] = 9

    # Ensure one specific gap is missing for 2x2 pattern completion
    # Target pattern: (3,2), (3,5), (4,2), (4,5)
    # Ensure (3,5) is missing (no collision)
    output_grid[3][5] = 0  # Ensure it's not set from edge match
    output_grid[4][5] = 0  # Ensure it's not set from edge match
    output_grid[3][5] = 9  # Complete the pattern
    output_grid[4][5] = 9

    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    size = len(input_grid)
    
    # Create output grid as copy of input
    output_grid = [row[:] for row in input_grid]

    # Mark all valid collisions (9s) between blocks
    for i in range(5):
        for j in range(4):
            r0 = i * 3
            # Right edge of block (i,j)
            right_edge = (input_grid[r0][j*3+1], input_grid[r0+1][j*3+1])
            # Left edge of block (i,j+1)
            left_edge = (input_grid[r0][j*3+3], input_grid[r0+1][j*3+3])
            if right_edge == left_edge:
                output_grid[r0][j*3+2] = 9
                output_grid[r0+1][j*3+2] = 9

    for j in range(5):
        for i in range(4):
            c0 = j * 3
            # Bottom edge of block (i,j)
            bottom_edge = (input_grid[i*3+1][c0], input_grid[i*3+1][c0+1])
            # Top edge of block (i+1,j)
            top_edge = (input_grid[i*3+3][c0], input_grid[i*3+3][c0+1])
            if bottom_edge == top_edge:
                output_grid[i*3+2][c0] = 9
                output_grid[i*3+2][c0+1] = 9

    # Complete the 2x2 pattern (target: (3,2), (3,5), (4,2), (4,5))
    if output_grid[3][5] == 0:
        output_grid[3][5] = 9
    if output_grid[4][5] == 0:
        output_grid[4][5] = 9

    return output_grid
