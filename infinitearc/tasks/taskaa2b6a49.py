# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: aa2b6a49
Difficulty: medium–hard

=== Tags ===
- Substitution rule discovery
- Draw pattern from point

=== Description ===
Input grids consist of a single background color (0) with scattered rule markers
and source cells. Rule markers are 2×2 blocks of distinct colors (e.g., color
2), each positioned such that a single trigger cell of a different color (e.g.,
color 5) is adjacent to the block in one of the four cardinal directions (up,
down, left, right). Triggers are non-background and never overlap with other
elements. The grid also contains one or more source cells (color 1) placed along
the top edge (row 0) in background cells, separated by at least one background
cell from other elements.   The output grid transforms the input by drawing a
path from each source cell. The path begins moving east (right) from the source,
continuing in the current direction until encountering a non-background cell. At
each step, the path color changes according to the substitution rule: if the
current direction of movement aligns with the direction of a trigger cell
relative to a rule marker (e.g., moving east and the trigger is east of the rule
marker), the path color changes to the trigger color for all subsequent steps in
that direction. The path is drawn exclusively over background cells (0), with
the rule markers and triggers remaining visible and unchanged. The substitution
rule must be discovered by observing the spatial relationship between triggers
and rule markers in the input grid. Paths stop before non-background cells, and
no two paths intersect or overwrite existing elements.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = [[0] * width for _ in range(height)]
    
    num_markers = random.randint(1, 3)
    markers = []
    for _ in range(num_markers):
        r = random.randint(1, height-2)
        c = random.randint(0, width-2)
        for dr in range(2):
            for dc in range(2):
                grid[r+dr][c+dc] = 2
        markers.append((r, c))
    
    for (r, c) in markers:
        directions = ['north', 'south', 'west', 'east']
        while True:
            d = random.choice(directions)
            if d == 'north':
                tr, tc = r-1, c
                if tr >= 0 and grid[tr][tc] == 0:
                    break
            elif d == 'south':
                tr, tc = r+2, c
                if tr < height and grid[tr][tc] == 0:
                    break
            elif d == 'west':
                tr, tc = r, c-1
                if tc >= 0 and grid[tr][tc] == 0:
                    break
            elif d == 'east':
                tr, tc = r, c+2
                if tc < width and grid[tr][tc] == 0:
                    break
        color = random.randint(3, 9)
        grid[tr][tc] = color
    
    sources = []
    for c in range(width):
        if grid[0][c] == 0:
            if not sources or c - sources[-1] > 2:
                grid[0][c] = 1
                sources.append(c)
    if not sources:
        for c in range(width):
            if grid[0][c] == 0:
                grid[0][c] = 1
                sources.append(c)
                break
    
    output = [row[:] for row in grid]
    substitution = {'east': None, 'west': None, 'north': None, 'south': None}
    for r in range(height-1):
        for c in range(width-1):
            if grid[r][c] == 2 and grid[r][c+1] == 2 and grid[r+1][c] == 2 and grid[r+1][c+1] == 2:
                if c+2 < width and 3 <= grid[r][c+2] <= 9:
                    substitution['east'] = grid[r][c+2]
                if c-1 >= 0 and 3 <= grid[r][c-1] <= 9:
                    substitution['west'] = grid[r][c-1]
                if r+2 < height and 3 <= grid[r+2][c] <= 9:
                    substitution['south'] = grid[r+2][c]
                if r-1 >= 0 and 3 <= grid[r-1][c] <= 9:
                    substitution['north'] = grid[r-1][c]
    
    for c in sources:
        current_color = 1
        if substitution['east'] is not None:
            current_color = substitution['east']
        col = c + 1
        while col < width and output[0][col] == 0:
            output[0][col] = current_color
            col += 1
    
    return {'input': grid, 'output': output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    height = len(input_list)
    width = len(input_list[0])
    
    output = [row[:] for row in input_list]
    
    substitution = {'east': None, 'west': None, 'north': None, 'south': None}
    for r in range(height-1):
        for c in range(width-1):
            if input_list[r][c] == 2 and input_list[r][c+1] == 2 and input_list[r+1][c] == 2 and input_list[r+1][c+1] == 2:
                if c+2 < width and 3 <= input_list[r][c+2] <= 9:
                    substitution['east'] = input_list[r][c+2]
                if c-1 >= 0 and 3 <= input_list[r][c-1] <= 9:
                    substitution['west'] = input_list[r][c-1]
                if r+2 < height and 3 <= input_list[r+2][c] <= 9:
                    substitution['south'] = input_list[r+2][c]
                if r-1 >= 0 and 3 <= input_list[r-1][c] <= 9:
                    substitution['north'] = input_list[r-1][c]
    
    sources = [c for c in range(width) if input_list[0][c] == 1]
    
    for c in sources:
        current_color = 1
        if substitution['east'] is not None:
            current_color = substitution['east']
        col = c + 1
        while col < width and output[0][col] == 0:
            output[0][col] = current_color
            col += 1
    
    return output
