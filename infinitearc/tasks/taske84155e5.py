# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: e84155e5
Difficulty: easy

=== Tags ===
- Swap positions of two objects
- Replace pattern
- Count patterns

=== Description ===
The task involves a grid containing two distinct single-cell objects (e.g., a
red cell and a blue cell) positioned at different locations. The transformation
requires swapping the positions of these two objects. Additionally, a specific
pattern (e.g., a 2x2 square of green cells) must be identified, counted, and
replaced with a new pattern (e.g., a 2x2 square of yellow cells). For this easy
difficulty task, the pattern to replace appears exactly once in the input grid,
making the count straightforward (always 1). The output grid will reflect the
swapped object positions and the replaced pattern, with all other grid elements
unchanged. The solver must recognize the two objects to swap, identify the
single instance of the target pattern, and apply the replacement without relying
on numerical values or sums.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 10)
    height = random.randint(5, 10)
    grid = [[0] * width for _ in range(height)]
    
    r1, c1 = random.randint(0, height-1), random.randint(0, width-1)
    grid[r1][c1] = 2
    r2, c2 = r1, c1
    while r2 == r1 and c2 == c1:
        r2, c2 = random.randint(0, height-1), random.randint(0, width-1)
    grid[r2][c2] = 3
    
    placed = False
    while not placed:
        r3 = random.randint(0, height-2)
        c3 = random.randint(0, width-2)
        if (r3 == r1 and c3 == c1) or (r3 == r2 and c3 == c2) or \
           (r3 == r1 and c3+1 == c1) or (r3 == r2 and c3+1 == c2) or \
           (r3+1 == r1 and c3 == c1) or (r3+1 == r2 and c3 == c2) or \
           (r3+1 == r1 and c3+1 == c1) or (r3+1 == r2 and c3+1 == c2):
            continue
        grid[r3][c3] = 4
        grid[r3][c3+1] = 4
        grid[r3+1][c3] = 4
        grid[r3+1][c3+1] = 4
        placed = True
    
    output_grid = [row[:] for row in grid]
    output_grid[r1][c1], output_grid[r2][c2] = output_grid[r2][c2], output_grid[r1][c1]
    output_grid[r3][c3] = 5
    output_grid[r3][c3+1] = 5
    output_grid[r3+1][c3] = 5
    output_grid[r3+1][c3+1] = 5
    
    return {"input": grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random

def p(input_grid):
    # Convert input_grid to list of lists if it's a tuple of tuples
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    
    pos2 = None
    pos3 = None
    for i in range(len(input_grid)):
        for j in range(len(input_grid[0])):
            if input_grid[i][j] == 2:
                pos2 = (i, j)
            elif input_grid[i][j] == 3:
                pos3 = (i, j)
    if pos2 is None or pos3 is None:
        raise ValueError("Missing color 2 or 3")
    
    top_left = None
    for i in range(len(input_grid) - 1):
        for j in range(len(input_grid[0]) - 1):
            if (input_grid[i][j] == 4 and 
                input_grid[i][j+1] == 4 and 
                input_grid[i+1][j] == 4 and 
                input_grid[i+1][j+1] == 4):
                top_left = (i, j)
                break
        if top_left is not None:
            break
    if top_left is None:
        raise ValueError("No 2x2 block of color 4 found")
    
    output = [list(row) for row in input_grid]  # Ensure mutable lists
    
    # Perform swap using temporary variable
    temp = output[pos2[0]][pos2[1]]
    output[pos2[0]][pos2[1]] = output[pos3[0]][pos3[1]]
    output[pos3[0]][pos3[1]] = temp
    
    i, j = top_left
    output[i][j] = 5
    output[i][j+1] = 5
    output[i+1][j] = 5
    output[i+1][j+1] = 5
    return output
