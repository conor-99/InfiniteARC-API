# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 2378ee01
Difficulty: insane

=== Tags ===
- Beam reflection
- Draw pattern from point
- Local rule cascade
- Image expasion
- Count hor lines

=== Description ===
Input grids are large (20×20 or larger) with a uniform background color (0).
Overlaid on this background are walls composed of contiguous horizontal or
vertical segments of color 1, forming a grid-like obstacle structure. Scattered
across the grid are horizontal line segments of color 5—each defined as a
contiguous run of 5s within a single row, separated by non-5 cells—and a set of
single-cell "emitter" points of color 2 positioned away from walls and
horizontal lines. The horizontal lines form a distinct visual pattern, with no
two segments overlapping or adjacent.  The transformation process begins by
counting all horizontal line segments of color 5 in the input grid (each
contiguous horizontal sequence in a row counts as one segment). This count,
denoted N, governs both the beam propagation and the cascade expansion. For each
emitter point (color 2), a diagonal beam is initiated moving northeast (top-
right). The beam travels through background cells (0) until it encounters a wall
(color 1), at which point it reflects according to a fixed cycle: east → north →
west → south → east. Each reflection increments the beam’s color (e.g., 2 → 3 →
4), and the beam travels exactly N steps in its new direction before the next
reflection. The beam path is drawn on background cells with its current color,
never overwriting walls, horizontal lines, or emitters.  Simultaneously, a local
rule cascade is triggered along the beam’s path: for every cell traversed by the
beam (excluding reflection points), all background cells within a Manhattan
distance of N in the four orthogonal directions are set to the beam’s current
color. This cascade propagates outward from each beam cell, expanding the
pattern without overlapping walls or horizontal lines. The cascade effect
creates a visible "image expansion" that grows from the beam path, with the
expansion distance directly tied to the count N of horizontal lines. The output
grid retains all original walls, horizontal lines, and emitters, while the beam
paths and their cascaded patterns visually emerge as the solution. The
complexity arises from the interplay between the count-driven reflection steps,
the directional cascade propagation, and the requirement that all
transformations must be derived solely from the visual arrangement of colors and
lines in the input.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from typing import List, Tuple

def generate():
    size = random.randint(20,25)
    grid = [[0 for _ in range(size)] for _ in range(size)]

    # Place walls as horizontal or vertical segments of color 1.
    wall_segments = random.randint(6,12)
    attempts = 0
    placed = 0
    while placed < wall_segments and attempts < wall_segments*10:
        attempts += 1
        orient = random.choice(['h','v'])
        length = random.randint(2,6)
        if orient == 'h':
            r = random.randint(0,size-1)
            c0 = random.randint(0,size-length)
            if any(grid[r][c] != 0 for c in range(c0, c0+length)):
                continue
            # place horizontal wall
            for c in range(c0, c0+length):
                grid[r][c] = 1
            placed += 1
        else:
            c = random.randint(0,size-1)
            r0 = random.randint(0,size-length)
            if any(grid[r][c] != 0 for r in range(r0, r0+length)):
                continue
            for r in range(r0, r0+length):
                grid[r][c] = 1
            placed += 1

    # Place horizontal 5-segments (color 5), ensure non-adjacent and non-overlapping
    target_segments = random.randint(2,6)
    segments = []
    attempts = 0
    while len(segments) < target_segments and attempts < target_segments*200:
        attempts += 1
        r = random.randint(0,size-1)
        length = random.randint(2,4)
        c0 = random.randint(0, size-length)
        c1 = c0 + length - 1
        # check within row there is no existing 5 and no adjacency to other 5s
        ok = True
        # check vicinity (c0-1 to c1+1) for 5s
        for c in range(max(0,c0-1), min(size-1,c1+1)+1):
            if grid[r][c] == 5:
                ok = False
                break
        # do not overwrite walls
        if not ok: continue
        if any(grid[r][c] != 0 for c in range(c0, c1+1)):
            continue
        # place segment
        for c in range(c0, c1+1):
            grid[r][c] = 5
        segments.append((r,c0,c1))
    # ensure at least one segment
    if len(segments) == 0:
        # fallback: place one small segment
        r = random.randint(0,size-1)
        c0 = random.randint(0,size-2)
        if grid[r][c0] == 0:
            grid[r][c0] = 5
        else:
            for rr in range(size):
                for cc in range(size-1):
                    if grid[rr][cc] == 0 and grid[rr][cc+1] == 0:
                        grid[rr][cc] = 5
                        break
                else:
                    continue
                break
        # recompute segments list
        segments = []
        for rr in range(size):
            in_seg = False
            for cc in range(size):
                if grid[rr][cc] == 5 and not in_seg:
                    in_seg = True
                    start = cc
                elif grid[rr][cc] != 5 and in_seg:
                    segments.append((rr,start,cc-1))
                    in_seg = False
            if in_seg:
                segments.append((rr,start, size-1))
                in_seg = False

    # Count horizontal segments
    def count_h_segments(g):
        count = 0
        for rr in range(len(g)):
            in_seg = False
            for cc in range(len(g[rr])):
                if g[rr][cc] == 5 and not in_seg:
                    count += 1
                    in_seg = True
                elif g[rr][cc] != 5:
                    in_seg = False
        return count
    N = count_h_segments(grid)

    # Place emitters (color 2) away from non-zero cells
    emitters = []
    emitter_count = random.randint(1,3)
    attempts = 0
    while len(emitters) < emitter_count and attempts < emitter_count*200:
        attempts += 1
        r = random.randint(0,size-1)
        c = random.randint(0,size-1)
        if grid[r][c] != 0: continue
        # ensure no orthogonal neighbor is non-zero (distance 1)
        ok = True
        for dr,dc in [(0,1),(0,-1),(1,0),(-1,0)]:
            rr,cc = r+dr, c+dc
            if 0 <= rr < size and 0 <= cc < size and grid[rr][cc] != 0:
                ok = False
                break
        if not ok: continue
        grid[r][c] = 2
        emitters.append((r,c))

    # Ensure at least one emitter
    if len(emitters) == 0:
        for rr in range(size):
            for cc in range(size):
                if grid[rr][cc] == 0:
                    # ensure neighbors are 0
                    ok = True
                    for dr,dc in [(0,1),(0,-1),(1,0),(-1,0)]:
                        r2,c2 = rr+dr, cc+dc
                        if 0 <= r2 < size and 0 <= c2 < size and grid[r2][c2] != 0:
                            ok = False
                            break
                    if ok:
                        grid[rr][cc] = 2
                        emitters.append((rr,cc))
                        break
            if emitters:
                break

    # Prepare output as a copy
    output = [row[:] for row in grid]

    # Beam propagation function (identical logic will be used in solver)
    def propagate_from(em_r, em_c):
        nonlocal output
        # initial state
        current_r, current_c = em_r, em_c
        mode = 'diag'  # 'diag' for northeast diagonal, 'card' for cardinal movement
        reflect_count = 0
        color = 2  # initial color for diagonal path
        # direction cycle for reflections: east, north, west, south
        cycle = [(0,1), (-1,0), (0,-1), (1,0)]
        # Use a safety counter to avoid infinite loops
        steps_limit = size * size * 4
        steps = 0
        while steps < steps_limit:
            steps += 1
            if mode == 'diag':
                nr, nc = current_r - 1, current_c + 1
                # out of bounds => beam ends
                if not (0 <= nr < size and 0 <= nc < size):
                    break
                val = grid[nr][nc]
                if val == 1:
                    # reflect: increment reflection count, update color and switch to cardinal mode
                    reflect_count += 1
                    color = 2 + (reflect_count % 8)
                    mode = 'card'
                    # on reflection we do not move into the wall cell
                    continue
                if val != 0:
                    # hit a non-wall obstacle (horizontal line or emitter) -> beam stops
                    break
                # move into the background cell
                current_r, current_c = nr, nc
                # color the beam cell if empty (do not overwrite walls/lines/emitters or previous beam)
                if output[current_r][current_c] == 0:
                    output[current_r][current_c] = color
                # apply cascade: in four orthogonal directions up to distance N
                if N > 0:
                    for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                        for d in range(1, N+1):
                            r2 = current_r + dr * d
                            c2 = current_c + dc * d
                            if 0 <= r2 < size and 0 <= c2 < size:
                                # only color background cells and do not overwrite non-zero or previously colored
                                if grid[r2][c2] == 0 and output[r2][c2] == 0:
                                    output[r2][c2] = color
                continue

            else:  # cardinal movement
                # determine direction from reflect_count
                if reflect_count <= 0:
                    # if we are in cardinal mode but haven't reflected yet, treat as ending
                    break
                dir_idx = (reflect_count - 1) % 4
                dr, dc = cycle[dir_idx]
                steps_in_dir = 0
                while steps_in_dir < N:
                    nr, nc = current_r + dr, current_c + dc
                    # out of bounds => beam ends
                    if not (0 <= nr < size and 0 <= nc < size):
                        return
                    val = grid[nr][nc]
                    if val == 1:
                        # immediate reflection on encountering a wall
                        reflect_count += 1
                        color = 2 + (reflect_count % 8)
                        # update direction for next cardinal movement
                        break
                    if val != 0:
                        # hit a non-wall obstacle -> beam stops entirely
                        return
                    # move into the background cell
                    current_r, current_c = nr, nc
                    # color the beam cell if empty
                    if output[current_r][current_c] == 0:
                        output[current_r][current_c] = color
                    # apply cascade
                    if N > 0:
                        for dr2, dc2 in [(1,0),(-1,0),(0,1),(0,-1)]:
                            for d in range(1, N+1):
                                r2 = current_r + dr2 * d
                                c2 = current_c + dc2 * d
                                if 0 <= r2 < size and 0 <= c2 < size:
                                    if grid[r2][c2] == 0 and output[r2][c2] == 0:
                                        output[r2][c2] = color
                    steps_in_dir += 1
                else:
                    # finished exactly N steps without hitting a wall: reflect and change direction
                    reflect_count += 1
                    color = 2 + (reflect_count % 8)
                    # continue with new direction in next loop iteration
                    continue
                # if we broke because of a wall, loop to continue with updated reflect_count
                continue

        # end while

    # propagate beams from each emitter (sorted to ensure deterministic order)
    for (er, ec) in sorted(emitters):
        propagate_from(er, ec)

    return {'input': grid, 'output': output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # convert input_grid to list of lists
    grid = [list(row) for row in input_grid]
    size = len(grid)
    # count horizontal segments (color 5)
    def count_h_segments(g):
        count = 0
        for rr in range(size):
            in_seg = False
            for cc in range(size):
                if g[rr][cc] == 5 and not in_seg:
                    count += 1
                    in_seg = True
                elif g[rr][cc] != 5:
                    in_seg = False
        return count
    N = count_h_segments(grid)
    # find emitters
    emitters = []
    for r in range(size):
        for c in range(size):
            if grid[r][c] == 2:
                emitters.append((r,c))
    # prepare output copy
    output = [row[:] for row in grid]
    # propagate function replicating generator logic
    def propagate_from(em_r, em_c):
        nonlocal output
        current_r, current_c = em_r, em_c
        mode = 'diag'
        reflect_count = 0
        color = 2
        cycle = [(0,1), (-1,0), (0,-1), (1,0)]
        steps_limit = size*size*4
        steps = 0
        while steps < steps_limit:
            steps += 1
            if mode == 'diag':
                nr, nc = current_r - 1, current_c + 1
                if not (0 <= nr < size and 0 <= nc < size):
                    break
                val = grid[nr][nc]
                if val == 1:
                    reflect_count += 1
                    color = 2 + (reflect_count % 8)
                    mode = 'card'
                    continue
                if val != 0:
                    break
                current_r, current_c = nr, nc
                if output[current_r][current_c] == 0:
                    output[current_r][current_c] = color
                if N > 0:
                    for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                        for d in range(1, N+1):
                            r2 = current_r + dr * d
                            c2 = current_c + dc * d
                            if 0 <= r2 < size and 0 <= c2 < size:
                                if grid[r2][c2] == 0 and output[r2][c2] == 0:
                                    output[r2][c2] = color
                continue
            else:
                if reflect_count <= 0:
                    break
                dir_idx = (reflect_count - 1) % 4
                dr, dc = cycle[dir_idx]
                steps_in_dir = 0
                while steps_in_dir < N:
                    nr, nc = current_r + dr, current_c + dc
                    if not (0 <= nr < size and 0 <= nc < size):
                        return
                    val = grid[nr][nc]
                    if val == 1:
                        reflect_count += 1
                        color = 2 + (reflect_count % 8)
                        break
                    if val != 0:
                        return
                    current_r, current_c = nr, nc
                    if output[current_r][current_c] == 0:
                        output[current_r][current_c] = color
                    if N > 0:
                        for dr2, dc2 in [(1,0),(-1,0),(0,1),(0,-1)]:
                            for d in range(1, N+1):
                                r2 = current_r + dr2 * d
                                c2 = current_c + dc2 * d
                                if 0 <= r2 < size and 0 <= c2 < size:
                                    if grid[r2][c2] == 0 and output[r2][c2] == 0:
                                        output[r2][c2] = color
                    steps_in_dir += 1
                else:
                    reflect_count += 1
                    color = 2 + (reflect_count % 8)
                    continue
                continue
        return
    for (er,ec) in sorted(emitters):
        propagate_from(er,ec)
    return output

