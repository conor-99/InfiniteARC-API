# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: d869ad44
Difficulty: insane

=== Tags ===
- Hollow core detection
- Connect all dots of same color
- Draw path through ordered checkpoints

=== Description ===
The input grid features a background color (0) and multiple distinct colored
regions. A region is a **hollow core** if it forms a closed loop around a
background area (i.e., all cells of the region are connected and enclose
background cells within their boundary). Checkpoints are marked by a distinct
color (e.g., 9) placed along the boundary of hollow cores, with their order
determined by spatial position (top-left to bottom-right).  The output grid
transforms the input by: 1. **Detecting hollow cores**: Identifying all regions
that form closed loops around background areas. 2. **Connecting all boundary
cells**: For each hollow core, drawing a continuous path that traverses every
cell along its boundary (including checkpoint markers). 3. **Ordering through
checkpoints**: The path must visit checkpoint markers in the sequence they
appear from top-left to bottom-right.  The path is drawn using a new color
(e.g., 5), while preserving the original hollow core regions. Solid regions
(non-hollow cores) remain unchanged. The output ensures that all boundary cells
are connected in a single path that sequentially passes through checkpoints from
first to last, with no detours or skips. This requires simultaneous detection of
enclosed regions, boundary traversal, and sequential checkpoint navigation
within the spatial constraints of the grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid


def _rect_perimeter(r0, c0, r1, c1):
    perim = []
    for c in range(c0, c1 + 1):
        perim.append((r0, c))
        perim.append((r1, c))
    for r in range(r0 + 1, r1):
        perim.append((r, c0))
        perim.append((r, c1))
    # preserve order but remove duplicates
    seen = set()
    uniq = []
    for p in perim:
        if p not in seen:
            seen.add(p)
            uniq.append(p)
    return uniq


def generate():
    """
    Generate an input/output pair where the input contains several 1-pixel-thick
    rectangular hollow cores (closed loops) in distinct colors and some optional
    solid regions. Checkpoints (color 9) are placed on loop boundaries in the
    input. The output colors every loop boundary cell with 5 (including
    checkpoint cells). Solid regions remain unchanged.
    """
    tries = 0
    while tries < 200:
        tries += 1
        size = random.randint(8, 20)
        grid_input = grid(size, size, 0)

        # Colors available for rings (avoid 5 and 9)
        palette = [1, 2, 3, 4, 6, 7, 8]
        num_cores = random.randint(2, 3)
        colors = random.sample(palette, num_cores)

        ring_perimeters = []
        placed_colors = []

        # Try to place each rectangular ring without overlap and not touching the border
        success = True
        for color in colors:
            placed = False
            for attempt in range(120):
                # Keep a one-cell margin from the outer border so the ring encloses an area
                r0 = random.randint(1, max(1, size - 5))
                c0 = random.randint(1, max(1, size - 5))
                # choose r1,c1 so that r1-r0 >= 2 and c1-c0 >= 2 (so interior >= 1x1)
                max_h = max(2, min(6, size - 2 - r0))
                max_w = max(2, min(6, size - 2 - c0))
                h = random.randint(2, max_h)
                w = random.randint(2, max_w)
                r1 = r0 + h
                c1 = c0 + w
                if r1 >= size - 1 or c1 >= size - 1:
                    continue
                if r1 - r0 < 2 or c1 - c0 < 2:
                    continue

                perim = _rect_perimeter(r0, c0, r1, c1)

                # Check that the perimeter and a one-cell margin around it are free
                ok = True
                for rr in range(max(0, r0 - 1), min(size, r1 + 2)):
                    for cc in range(max(0, c0 - 1), min(size, c1 + 2)):
                        if grid_input[rr][cc] != 0:
                            ok = False
                            break
                    if not ok:
                        break
                if not ok:
                    continue

                # Place the perimeter
                for (rr, cc) in perim:
                    grid_input[rr][cc] = color

                ring_perimeters.append(perim)
                placed_colors.append(color)
                placed = True
                break
            if not placed:
                success = False
                break

        if not success or len(ring_perimeters) != len(colors):
            continue

        # Place checkpoints (color 9) on each ring's boundary
        for perim in ring_perimeters:
            k = random.randint(2, min(4, len(perim)))
            picks = random.sample(perim, k)
            for (rr, cc) in picks:
                grid_input[rr][cc] = 9

        # Place a few solid (filled) regions (they must remain unchanged in output)
        # Avoid creating 2x2 solids because a 2x2 filled block would also satisfy the
        # "each cell has 2 neighbors" pattern and could be misclassified as a loop.
        # Also ensure solids keep a one-cell margin from existing non-zero cells so
        # they don't accidentally connect to rings.
        remaining_colors = [c for c in palette if c not in placed_colors]
        solid_count = random.randint(0, 2)
        for _ in range(solid_count):
            if not remaining_colors:
                break
            sc = random.choice(remaining_colors)
            placed_solid = False
            for attempt in range(120):
                rr = random.randint(0, max(0, size - 3))
                cc = random.randint(0, max(0, size - 3))
                sh = random.randint(2, min(4, size - rr))
                sw = random.randint(2, min(4, size - cc))
                # disallow the 2x2 case which would mimic a loop
                if sh == 2 and sw == 2:
                    continue
                # require a one-cell margin around the solid to be empty to avoid adjacency
                ok = True
                for rcheck in range(max(0, rr - 1), min(size, rr + sh + 1)):
                    for ccheck in range(max(0, cc - 1), min(size, cc + sw + 1)):
                        if grid_input[rcheck][ccheck] != 0:
                            ok = False
                            break
                    if not ok:
                        break
                if not ok:
                    continue
                for rrr in range(rr, rr + sh):
                    for ccc in range(cc, cc + sw):
                        grid_input[rrr][ccc] = sc
                placed_solid = True
                break
            if placed_solid:
                remaining_colors.remove(sc)

        # Build the output: color every ring boundary cell (including checkpoints) with 5
        grid_output = [row[:] for row in grid_input]
        for perim in ring_perimeters:
            for (rr, cc) in perim:
                grid_output[rr][cc] = 5

        # Guarantee input != output (at least one ring existed)
        changed = False
        for r in range(size):
            for c in range(size):
                if grid_input[r][c] != grid_output[r][c]:
                    changed = True
                    break
            if changed:
                break
        if not changed:
            continue

        return {
            "input": grid_input,
            "output": grid_output
        }
    # If we somehow fail to generate within attempts, raise an exception
    raise RuntimeError("Failed to generate a valid pair")



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid_in = [list(row) for row in input_grid]
    h = len(grid_in)
    w = len(grid_in[0])
    output = [row[:] for row in grid_in]

    # Find connected components of non-background cells (treat any non-zero as part of a region,
    # this includes checkpoint markers (9)).
    visited = [[False] * w for _ in range(h)]
    components = []
    for r in range(h):
        for c in range(w):
            if grid_in[r][c] != 0 and not visited[r][c]:
                stack = [(r, c)]
                visited[r][c] = True
                comp = []
                while stack:
                    rr, cc = stack.pop()
                    comp.append((rr, cc))
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = rr + dr, cc + dc
                        if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid_in[nr][nc] != 0:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append(comp)

    # A hollow core (1-pixel-thick closed loop) will have every cell with exactly two
    # orthogonal neighbors inside the same component. Detect such components and
    # color their cells with 5 in the output.
    for comp in components:
        if len(comp) < 4:
            continue
        s = set(comp)
        is_loop = True
        for (r, c) in comp:
            neigh = 0
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                if (r + dr, c + dc) in s:
                    neigh += 1
            if neigh != 2:
                is_loop = False
                break
        if is_loop:
            for (r, c) in comp:
                output[r][c] = 5

    return output

