# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 858f4752
Difficulty: hard

=== Tags ===
- Weave patterns
- Constraint satisfaction coloring

=== Description ===
The input grid is a 2D grid of colors ranging from 0 to 9. The output grid is
generated by first identifying the two most frequent colors present in the input
grid; in cases of ties, the smaller color values are prioritized. The output
grid is then transformed into a checkerboard pattern where each cell at position
(i, j) is assigned the first selected color if (i + j) is even, and the second
selected color if (i + j) is odd. This ensures that no two adjacent cells
(horizontally or vertically) share the same color, satisfying the constraint
satisfaction requirement. The transformation is deterministic, relying on global
color frequency analysis and a fixed parity-based pattern application, making it
challenging to discern the underlying rule through simple visual inspection
alone.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    from collections import Counter
    while True:
        width = random.randint(1, 30)
        height = random.randint(1, 30)
        if width * height < 2:
            continue
        grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
        colors = set()
        for row in grid:
            colors.update(row)
        if len(colors) < 2:
            continue
        break
    counts = Counter()
    for row in grid:
        for color in row:
            counts[color] += 1
    sorted_colors = sorted(counts.items(), key=lambda x: (-x[1], x[0]))
    color1, color2 = sorted_colors[0][0], sorted_colors[1][0]
    output = [[color1 if (i + j) % 2 == 0 else color2 for j in range(width)] for i in range(height)]
    if grid == output:
        while grid == output:
            width = random.randint(1, 30)
            height = random.randint(1, 30)
            if width * height < 2:
                continue
            grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
            colors = set()
            for row in grid:
                colors.update(row)
            if len(colors) < 2:
                continue
            counts = Counter()
            for row in grid:
                for color in row:
                    counts[color] += 1
            sorted_colors = sorted(counts.items(), key=lambda x: (-x[1], x[0]))
            color1, color2 = sorted_colors[0][0], sorted_colors[1][0]
            output = [[color1 if (i + j) % 2 == 0 else color2 for j in range(width)] for i in range(height)]
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    from collections import Counter
    counts = Counter()
    for row in input_grid:
        for color in row:
            counts[color] += 1
    sorted_colors = sorted(counts.items(), key=lambda x: (-x[1], x[0]))
    color1, color2 = sorted_colors[0][0], sorted_colors[1][0]
    width = len(input_grid[0])
    height = len(input_grid)
    return [[color1 if (i + j) % 2 == 0 else color2 for j in range(width)] for i in range(height)]
