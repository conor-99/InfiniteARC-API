# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: b3bbacea
Difficulty: insane

=== Tags ===
- Indexed painting
- Progressive rule shift
- Column parity coloring

=== Description ===
**Task Name**: Progressive Column Parity Painting    **Input Grids**:   - Input
grids are large (20×20 or larger) with a uniform background color (0).   -
Overlaid on the background are vertical stripes (each exactly 1 column wide) of
distinct non-background colors (1–9), separated by at least one background
column. The number of stripes equals the length of the reference palette in the
top row.   - The top row (row 0) contains a sequence of colors matching the
number of stripes, ordered left to right. This sequence serves as the reference
palette.    **Output Grid Transformation**:   1. **Stripe Indexing**: Each
vertical stripe is assigned a unique index *i* (0-based, left to right).   2.
**Progressive Rule Shift**: For stripe *i*, the reference palette is cyclically
shifted left by *i* positions. For example, a palette `[A, B, C]` with *i* = 2
becomes `[C, A, B]`.   3. **Column Parity Coloring**: For each column *j* in the
output:      - If *j* is even, the column is painted with the **first color** of
the shifted palette for its stripe.      - If *j* is odd, the column is painted
with the **second color** of the shifted palette (wrapping if the palette has
only one color).   4. **Stripe Alignment**: Each stripe’s columns (all columns
belonging to the same stripe) adopt the same shifted palette, but the parity
rule applies independently per column *j* (not per stripe).    **Key Visual
Features**:   - The reference palette in row 0 is visually distinct from the
stripes.   - The progressive shift (*i* positions for stripe *i*) creates a
dynamic color pattern across the grid.   - Column parity (even/odd *j*) ensures
adjacent columns in the same stripe alternate colors, generating a striped
"wave" effect.   - No numerical operations (e.g., sums, indices) are used; all
rules derive from visual patterns (stripe order, column position, palette
sequence).    **Insane Difficulty Justification**:   - Requires simultaneous
tracking of stripe order, parity, and cyclic palette shifts.   - Shifted
palettes create non-intuitive color assignments (e.g., the third stripe’s second
column may use the palette’s last color).   - Background separation and stripe
width constraints demand precise spatial reasoning.   - Output grid must
maintain visual coherence while applying layered rules to every column.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = 20
    height = 20
    n = random.randint(3, 5)
    colors = list(range(1, 10))
    palette = random.sample(colors, n)
    input_grid = common.grid(width, height, 0)
    for i in range(n):
        col = 2 * i + 1
        for r in range(height):
            input_grid[r][col] = palette[i]
    output_grid = common.grid(width, height, 0)
    palette_row = [input_grid[0][j] for j in range(width) if input_grid[0][j] != 0]
    n_val = len(palette_row)
    for j in range(width):
        if input_grid[0][j] != 0:
            i_index = palette_row.index(input_grid[0][j])
            output_color = palette_row[(i_index + 1) % n_val]
            for r in range(height):
                output_grid[r][j] = output_color
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    width = len(input_list[0])
    height = len(input_list)
    palette_row = [input_list[0][j] for j in range(width) if input_list[0][j] != 0]
    n_val = len(palette_row)
    output_grid = common.grid(width, height, 0)
    for j in range(width):
        if input_list[0][j] != 0:
            i_index = palette_row.index(input_list[0][j])
            output_color = palette_row[(i_index + 1) % n_val]
            for r in range(height):
                output_grid[r][j] = output_color
    return output_grid
