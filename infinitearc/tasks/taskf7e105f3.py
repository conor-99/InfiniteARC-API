# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: f7e105f3
Difficulty: insane

=== Tags ===
- Pattern intersection
- Symmetry axis completion
- Image repetition

=== Description ===
Input grids are 25×25, featuring a vertical symmetry axis (midline between
columns 12 and 13) and multiple distinct colored patterns. The left half
(columns 0–12) contains fully formed patterns of varying shapes (e.g., geometric
clusters, organic blobs), while the right half (columns 13–24) is incomplete or
misaligned. A repeating color sequence (e.g., red → green → blue → red) appears
as a horizontal pattern at fixed intervals (every 4 columns) along the top edge,
but this sequence is broken at the symmetry axis. Additionally, the grid
contains "intersection markers" (small 2×2 blocks of color 9) at points where
patterns overlap, signaling color blending zones.  The output grid must
simultaneously execute three interdependent transformations:   1. **Symmetry
axis completion**: Mirror all patterns from the left half to the right half
across the vertical midline, ensuring perfect reflection (e.g., a leftward
triangle at (r, 5) becomes a rightward triangle at (r, 19)).   2. **Pattern
intersection resolution**: At cells marked by intersection markers (color 9),
blend the colors of intersecting patterns using a predefined rule (e.g., red +
blue = purple, green + yellow = orange), prioritizing the dominant pattern’s
hue.   3. **Image repetition restoration**: Extend the top-edge repeating color
sequence horizontally across the entire grid, maintaining its order (e.g., red →
green → blue) while adjusting for symmetry (e.g., the mirrored sequence on the
right half reverses direction: blue → green → red).  The task demands precise
spatial reasoning to resolve overlapping rules: symmetry dictates pattern
placement, intersection markers trigger color blending, and repetition ensures
sequence continuity. No two patterns overlap without an intersection marker, and
all repetitions must align with the symmetry axis. The solution requires
identifying the axis, tracing the repetition sequence, resolving intersections,
and applying all transformations without overwriting existing markers or
breaking the sequence’s cyclic nature.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, all_pixels, random_color

def generate():
    size = 25
    input_grid = grid(size, size, 0)
    output_grid = grid(size, size, 0)
    
    # Place intersection markers only on background (0)
    for r in range(5, 7):
        for c in range(12, 14):
            if input_grid[r][c] == 0:
                input_grid[r][c] = 9
                output_grid[r][c] = 9

    # Generate left patterns (cols 0-12)
    for r in range(1, 24):
        for c in range(0, 13):
            if random.random() > 0.7:
                input_grid[r][c] = random_color(exclude=[0, 9])
                output_grid[r][c] = input_grid[r][c]

    # Mirror left to right (cols 13-24)
    for r in range(size):
        for c in range(13, size):
            output_grid[r][c] = input_grid[r][24 - c]

    # BLEND INTERSECTION MARKERS (CORRECTED CONDITION)
    for r in range(5, 7):
        if input_grid[r][12] == 9 and input_grid[r][13] == 9:
            A = input_grid[r][12]  # This is 9, but solver uses actual pattern
            B = input_grid[r][11]
            blended = (A + B) % 10
            output_grid[r][12] = blended
            output_grid[r][13] = blended
            if r < size - 1:
                A2 = input_grid[r+1][12]
                B2 = input_grid[r+1][11]
                blended2 = (A2 + B2) % 10
                output_grid[r+1][12] = blended2
                output_grid[r+1][13] = blended2

    # Generate top edge sequence (row 0)
    sequence = [random_color(exclude=[0, 9]) for _ in range(13)]
    for c in range(13):
        input_grid[0][c] = sequence[c]
        output_grid[0][c] = sequence[c]
    for c in range(13, 25):
        input_grid[0][c] = sequence[c - 13]
    reversed_seq = sequence[::-1]
    for c in range(13, 25):
        output_grid[0][c] = reversed_seq[c - 13]

    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    size = len(input_grid)
    output_grid = [row[:] for row in input_grid]
    
    # Mirror right half
    for r in range(size):
        for c in range(13, size):
            output_grid[r][c] = input_grid[r][24 - c]
    
    # BLEND INTERSECTION MARKERS (CORRECTED LOGIC)
    for r in range(size - 1):
        if input_grid[r][12] == 9 and input_grid[r][13] == 9:
            A = input_grid[r][12]  # This is 9, but solver uses pattern colors
            B = input_grid[r][11]
            blended = (A + B) % 10
            output_grid[r][12] = blended
            output_grid[r][13] = blended
            if r < size - 1:
                A2 = input_grid[r+1][12]
                B2 = input_grid[r+1][11]
                blended2 = (A2 + B2) % 10
                output_grid[r+1][12] = blended2
                output_grid[r+1][13] = blended2
    
    # Fix top edge sequence
    left_seq = input_grid[0][:13]
    reversed_seq = left_seq[::-1]
    for c in range(13, 25):
        output_grid[0][c] = reversed_seq[c - 13]
    
    return output_grid
