# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 231121f6
Difficulty: hard

=== Tags ===
- Hierarchical repetition

=== Description ===
The task involves transforming an input grid into an output grid through
hierarchical repetition with geometric transformations. The input grid contains
a distinct structural pattern (e.g., a diagonal line, L-shape, or scattered
elements). The output grid is formed by replicating the input pattern into four
quadrants of a larger grid, with each quadrant transformed based on its
position:  - **Top-left quadrant**: Input pattern unchanged. - **Top-right
quadrant**: Input pattern flipped horizontally. - **Bottom-left quadrant**:
Input pattern flipped vertically. - **Bottom-right quadrant**: Input pattern
rotated 180 degrees.  The output grid size is exactly double the input grid
dimensions in both width and height (e.g., a 3×3 input produces a 6×6 output).
The transformation requires recognizing that the input pattern is hierarchically
repeated across the output grid, with each repetition undergoing a position-
dependent geometric operation. The pattern's structural features (e.g., relative
positions of colored cells) must be preserved through the transformations,
making the output visually distinct from the input and requiring multi-step
reasoning to deduce the quadrant-specific rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common
def generate():
    H = random.randint(1, 15)
    W = random.randint(1, 15)
    color = random.randint(1, 9)
    pixels = common.random_el(W, H)
    input_grid = [[0] * W for _ in range(H)]
    for r, c in pixels:
        input_grid[r][c] = color
    output_grid = [[0] * (2 * W) for _ in range(2 * H)]
    for r in range(H):
        for c in range(W):
            output_grid[r][c] = input_grid[r][c]
            output_grid[r][W + c] = input_grid[r][W - 1 - c]
            output_grid[H + r][c] = input_grid[H - 1 - r][c]
            output_grid[H + r][W + c] = input_grid[H - 1 - r][W - 1 - c]
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    H = len(input_grid)
    W = len(input_grid[0])
    output_grid = [[0] * (2 * W) for _ in range(2 * H)]
    for r in range(H):
        for c in range(W):
            output_grid[r][c] = input_grid[r][c]
            output_grid[r][W + c] = input_grid[r][W - 1 - c]
            output_grid[H + r][c] = input_grid[H - 1 - r][c]
            output_grid[H + r][W + c] = input_grid[H - 1 - r][W - 1 - c]
    return output_grid
