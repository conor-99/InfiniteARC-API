# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 8882bd7f
Difficulty: insane

=== Tags ===
- Rotating signal
- Periodic offset matching
- Reactive surface
- Extend line to edge

=== Description ===
Input grids are large (20×20 or larger) with a single background color (0). They
contain a distinct starting signal cell (color 1) and a periodic arrangement of
reactive cells (colors 2–9) placed at regular intervals along grid lines. Each
reactive cell's color encodes a rotational rule: color 2 (90° clockwise), color
3 (90° counterclockwise), color 4 (180°), color 5 (270° clockwise), and colors
6–9 follow a consistent rotational pattern (e.g., color 6 = 90° clockwise, color
7 = 90° counterclockwise, etc.). The signal begins moving east from the starting
cell (color 1), traversing background cells (0) to extend a path (color 1) until
exiting the grid. Upon encountering a reactive cell, the signal rotates per the
cell's color *without* traversing the reactive cell, then continues moving in
the new direction. The path is drawn *only* on background cells (0), preserving
all reactive cells and the starting cell. The output grid displays the input
with the path drawn (color 1) over background cells, while reactive cells retain
their original colors and the starting cell remains visible. The periodic
placement of reactive cells creates predictable offset intervals (e.g., every 3
columns east, every 2 rows north), requiring the solver to detect both the
pattern and apply rotational rules sequentially as the path extends to the grid
edge.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from typing import List, Tuple

def generate() -> dict:
    width = random.randint(20, 30)
    height = random.randint(20, 30)
    grid_in = [[0] * width for _ in range(height)]
    
    start_x, start_y = 0, 10
    grid_in[start_y][start_x] = 1
    
    for x in range(3, width, 3):
        for y in range(2, height, 2):
            if x == start_x and y == start_y:
                continue
            color = random.randint(2, 9)
            grid_in[y][x] = color
    
    grid_out = [row[:] for row in grid_in]
    x, y = start_x, start_y
    dx, dy = 1, 0
    
    for _ in range(width * height):
        nx, ny = x + dx, y + dy
        if nx < 0 or nx >= width or ny < 0 or ny >= height:
            break
        if grid_in[ny][nx] != 0 and grid_in[ny][nx] != 1:
            color = grid_in[ny][nx]
            if color in [2, 6]:
                dx, dy = -dy, dx
            elif color in [3, 7]:
                dx, dy = dy, -dx
            elif color in [4, 8]:
                dx, dy = -dx, -dy
            elif color in [5, 9]:
                dx, dy = dy, -dx
        else:
            grid_out[ny][nx] = 1
            x, y = nx, ny
    
    return {"input": grid_in, "output": grid_out}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from typing import Tuple

def p(input_grid: Tuple[Tuple[int, ...], ...]) -> Tuple[Tuple[int, ...], ...]:
    grid_in = [list(row) for row in input_grid]
    width = len(grid_in[0])
    height = len(grid_in)
    
    start_x, start_y = -1, -1
    for y in range(height):
        for x in range(width):
            if grid_in[y][x] == 1:
                start_x, start_y = x, y
                break
        if start_x != -1:
            break
    
    if start_x == -1:
        return input_grid
    
    x, y = start_x, start_y
    dx, dy = 1, 0
    grid_out = [row[:] for row in grid_in]
    
    for _ in range(width * height):
        nx, ny = x + dx, y + dy
        if nx < 0 or nx >= width or ny < 0 or ny >= height:
            break
        if grid_in[ny][nx] != 0 and grid_in[ny][nx] != 1:
            color = grid_in[ny][nx]
            if color in [2, 6]:
                dx, dy = -dy, dx
            elif color in [3, 7]:
                dx, dy = dy, -dx
            elif color in [4, 8]:
                dx, dy = -dx, -dy
            elif color in [5, 9]:
                dx, dy = dy, -dx
        else:
            grid_out[ny][nx] = 1
            x, y = nx, ny
    
    return tuple(tuple(row) for row in grid_out)
