# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 205db7e2
Difficulty: medium–hard

=== Tags ===
- Paint on collision
- Refraction simulation
- Image rotation
- Create image from info

=== Description ===
Task Name: Refractive Path Paint  Tags: Paint on collision, Refraction
simulation, Image rotation, Create image from info  Description:  Input grids
are large (15×15 to 30×30) with a uniform background color (0). Overlaid are
multiple "source" cells (color 9) positioned along the left edge, each emitting
a single ray moving horizontally rightward. The grid contains "refractor" cells
(colors 1–8) that dictate direction changes upon ray collision. Each refractor
color corresponds to a fixed transformation:  - **Color 1 (red):** Turns left
(90° counterclockwise) - **Color 2 (blue):** Turns right (90° clockwise) -
**Color 3 (green):** Reverses direction (180°) - **Color 4 (yellow):** Continues
straight - **Colors 5–8:** Repeat the pattern of 1–4 (e.g., color 5 = color 1)
When a ray (initially color 9) collides with a refractor cell, the cell is
repainted to color 9, and the ray’s direction updates per the refractor’s rule.
Rays continue until exiting the grid (top, bottom, or right edge), never
intersecting or overlapping. The output grid is formed by first applying all
collision repaints (changing refractor cells to color 9), then rotating the
entire grid 90° clockwise. This rotation transforms horizontal paths into
vertical paths, creating a new visual representation of the refracted ray
trajectories. All background elements and unpainted cells remain unchanged, with
the final output clearly displaying the rotated path network of color 9.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(15, 30)
    height = random.randint(15, 30)
    grid = [[0] * width for _ in range(height)]
    sources = []
    num_sources = random.randint(1, 3)
    for _ in range(num_sources):
        r = random.randint(1, height - 2)
        if grid[r][0] == 0:
            grid[r][0] = 9
            sources.append(r)
    for r in sources:
        c = random.randint(1, width - 2)
        color = random.randint(1, 8)
        grid[r][c] = color
    post_collision = [row[:] for row in grid]
    for r in sources:
        current_r, current_c = r, 0
        direction = (0, 1)
        while True:
            next_r = current_r + direction[0]
            next_c = current_c + direction[1]
            if next_r < 0 or next_r >= height or next_c < 0 or next_c >= width:
                break
            cell_val = post_collision[next_r][next_c]
            if 1 <= cell_val <= 8:
                post_collision[next_r][next_c] = 9
                idx = (cell_val - 1) % 4
                if idx == 0:
                    direction = (-direction[1], direction[0])
                elif idx == 1:
                    direction = (direction[1], -direction[0])
                elif idx == 2:
                    direction = (-direction[0], -direction[1])
                current_r, current_c = next_r, next_c
            else:
                current_r, current_c = next_r, next_c
    rotated = [list(row) for row in zip(*post_collision[::-1])]
    return {"input": grid, "output": rotated}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    for r in range(height):
        if grid[r][0] == 9:
            current_r, current_c = r, 0
            direction = (0, 1)
            while True:
                next_r = current_r + direction[0]
                next_c = current_c + direction[1]
                if next_r < 0 or next_r >= height or next_c < 0 or next_c >= width:
                    break
                cell_val = grid[next_r][next_c]
                if 1 <= cell_val <= 8:
                    grid[next_r][next_c] = 9
                    idx = (cell_val - 1) % 4
                    if idx == 0:
                        direction = (-direction[1], direction[0])
                    elif idx == 1:
                        direction = (direction[1], -direction[0])
                    elif idx == 2:
                        direction = (-direction[0], -direction[1])
                    current_r, current_c = next_r, next_c
                else:
                    current_r, current_c = next_r, next_c
    rotated = [list(row) for row in zip(*grid[::-1])]
    return rotated
