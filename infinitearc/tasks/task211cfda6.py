# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 211cfda6
Difficulty: hard

=== Tags ===
- Chain reaction
- Path merging

=== Description ===
Input grids contain multiple disconnected paths composed of distinct non-
background colors (1-9), each path forming a connected sequence of cells aligned
in a single direction (horizontal, vertical, or diagonal). Paths are separated
by background (color 0) but positioned such that their endpoints approach
potential merge points. When two paths of colors A and B meet at a cell
(adjacent in direction of travel), they merge into a new color C via a hidden
color transformation rule (e.g., red + blue → green, blue + yellow → purple),
and the merged path continues in a direction determined by the vector sum of the
original paths' orientations (e.g., horizontal + vertical → diagonal). This
merge triggers a chain reaction: the newly formed path immediately seeks
adjacent paths to merge with, repeating the transformation until no further
merges occur. The output grid displays the final state after all possible chain
reactions, where all paths have been consolidated into a single continuous path
or set of interconnected paths adhering to the transformation rules. Background
cells remain unchanged, and all merges strictly follow the consistent color and
directional rules inferred from the input-output examples. The task requires
identifying both the color transformation logic and directional propagation
rules through iterative pattern recognition across multiple path configurations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Generate grid size
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = [[0] * width for _ in range(height)]
    
    # Create paths for chain reaction (aligned horizontally)
    pathA = [(1, 1), (1, 2)]
    colorA = random.randint(1, 9)
    pathB = [(1, 3), (1, 4)]
    colorB = random.randint(1, 9)
    pathC = [(1, 5), (1, 6)]
    colorC = random.randint(1, 9)
    
    # Place paths on grid
    for r, c in pathA:
        if 0 <= r < height and 0 <= c < width:
            grid[r][c] = colorA
    for r, c in pathB:
        if 0 <= r < height and 0 <= c < width:
            grid[r][c] = colorB
    for r, c in pathC:
        if 0 <= r < height and 0 <= c < width:
            grid[r][c] = colorC
    
    # Compute output grid by merging
    output_grid = merge_all(grid, width, height)
    
    return {"input": grid, "output": output_grid}

def merge_all(grid, width, height):
    current_grid = [row[:] for row in grid]
    changed = True
    while changed:
        changed = False
        paths = find_paths(current_grid, width, height)
        if not paths:
            break
        merged = False
        for i in range(len(paths)):
            for j in range(i + 1, len(paths)):
                color1, path1 = paths[i]
                color2, path2 = paths[j]
                if can_merge(path1, path2):
                    new_color = (color1 + color2 - 1) % 9 + 1
                    for (r, c) in path1:
                        current_grid[r][c] = new_color
                    for (r, c) in path2:
                        current_grid[r][c] = new_color
                    changed = True
                    merged = True
                    break
            if merged:
                break
    return current_grid

def find_paths(grid, width, height):
    visited = [[False] * width for _ in range(height)]
    paths = []
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and grid[r][c] != 0:
                path_cells = []
                stack = [(r, c)]
                color = grid[r][c]
                while stack:
                    cr, cc = stack.pop()
                    if not visited[cr][cc] and grid[cr][cc] == color:
                        visited[cr][cc] = True
                        path_cells.append((cr, cc))
                        for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                                stack.append((nr, nc))
                if is_straight_line(path_cells):
                    paths.append((color, path_cells))
    return paths

def is_straight_line(path_cells):
    if len(path_cells) <= 1:
        return True
    path_cells.sort(key=lambda x: (x[0], x[1]))
    start = path_cells[0]
    end = path_cells[-1]
    dr = end[0] - start[0]
    dc = end[1] - start[1]
    for cell in path_cells:
        r, c = cell
        if dr == 0:
            if r != start[0]:
                return False
        elif dc == 0:
            if c != start[1]:
                return False
        else:
            if (r - start[0]) * dc != (c - start[1]) * dr:
                return False
    return True

def can_merge(path1, path2):
    end1 = path1[-1]
    start2 = path2[0]
    dir2 = get_path_direction(path2)
    if end1 == (start2[0] - dir2[0], start2[1] - dir2[1]):
        return True
    return False

def get_path_direction(path_cells):
    if len(path_cells) < 2:
        return (0, 0)
    dr = path_cells[-1][0] - path_cells[0][0]
    dc = path_cells[-1][1] - path_cells[0][1]
    if dr == 0:
        return (0, 1) if dc > 0 else (0, -1)
    if dc == 0:
        return (1, 0) if dr > 0 else (-1, 0)
    if dr > 0 and dc > 0:
        return (1, 1)
    if dr > 0 and dc < 0:
        return (1, -1)
    if dr < 0 and dc > 0:
        return (-1, 1)
    if dr < 0 and dc < 0:
        return (-1, -1)
    return (dr, dc)


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    
    def find_paths(grid, width, height):
        visited = [[False] * width for _ in range(height)]
        paths = []
        for r in range(height):
            for c in range(width):
                if not visited[r][c] and grid[r][c] != 0:
                    path_cells = []
                    stack = [(r, c)]
                    color = grid[r][c]
                    while stack:
                        cr, cc = stack.pop()
                        if not visited[cr][cc] and grid[cr][cc] == color:
                            visited[cr][cc] = True
                            path_cells.append((cr, cc))
                            for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                                nr, nc = cr + dr, cc + dc
                                if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                                    stack.append((nr, nc))
                    if is_straight_line(path_cells):
                        paths.append((color, path_cells))
        return paths
    
    def can_merge(path1, path2):
        end1 = path1[-1]
        start2 = path2[0]
        dir2 = get_path_direction(path2)
        if end1 == (start2[0] - dir2[0], start2[1] - dir2[1]):
            return True
        return False
    
    def get_path_direction(path_cells):
        if len(path_cells) < 2:
            return (0, 0)
        dr = path_cells[-1][0] - path_cells[0][0]
        dc = path_cells[-1][1] - path_cells[0][1]
        if dr == 0:
            return (0, 1) if dc > 0 else (0, -1)
        if dc == 0:
            return (1, 0) if dr > 0 else (-1, 0)
        if dr > 0 and dc > 0:
            return (1, 1)
        if dr > 0 and dc < 0:
            return (1, -1)
        if dr < 0 and dc > 0:
            return (-1, 1)
        if dr < 0 and dc < 0:
            return (-1, -1)
        return (dr, dc)
    
    def is_straight_line(path_cells):
        if len(path_cells) <= 1:
            return True
        path_cells.sort(key=lambda x: (x[0], x[1]))
        start = path_cells[0]
        end = path_cells[-1]
        dr = end[0] - start[0]
        dc = end[1] - start[1]
        for cell in path_cells:
            r, c = cell
            if dr == 0:
                if r != start[0]:
                    return False
            elif dc == 0:
                if c != start[1]:
                    return False
            else:
                if (r - start[0]) * dc != (c - start[1]) * dr:
                    return False
        return True
    
    changed = True
    while changed:
        changed = False
        paths = find_paths(grid, width, height)
        if not paths:
            break
        merged = False
        for i in range(len(paths)):
            for j in range(i + 1, len(paths)):
                color1, path1 = paths[i]
                color2, path2 = paths[j]
                if can_merge(path1, path2):
                    new_color = (color1 + color2 - 1) % 9 + 1
                    for (r, c) in path1:
                        grid[r][c] = new_color
                    for (r, c) in path2:
                        grid[r][c] = new_color
                    changed = True
                    merged = True
                    break
            if merged:
                break
    return grid
