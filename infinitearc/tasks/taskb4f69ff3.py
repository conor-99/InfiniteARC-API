# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: b4f69ff3
Difficulty: hard

=== Tags ===
- Homeomorphism
- Image repetition

=== Description ===
The input grid contains a single, connected shape with distinct topological
features (e.g., holes or connected components) formed by non-zero color values.
The output grid is generated by first applying a homeomorphic transformation to
the input shape—preserving its topological properties such as connectivity, hole
count, and adjacency relationships. This transformation may involve continuous
deformations like rotation, reflection, or scaling, which maintain the shape's
structural integrity without tearing or merging components. Subsequently, the
transformed shape is repeated exactly four times in a 2×2 grid arrangement to
form the output, with each quadrant containing the same transformed shape. The
output grid dimensions are precisely double the input grid's width and height,
ensuring the transformed shape fits seamlessly into each quadrant. For instance,
an input shape with a central hole (e.g., a square ring) will retain its hole
after rotation, and the rotated shape will be replicated in all four corners of
the output. The challenge lies in recognizing the topological features of the
input to apply the correct transformation before arranging the repetitions,
requiring multi-step visual reasoning rather than simple geometric operations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    W = common.randint(5, 10)
    H = common.randint(5, 10)
    rows, cols = common.hollow_conway(W, H, 5)
    input_grid = common.grid(W, H, 0)
    for r, c in zip(rows, cols):
        input_grid[r][c] = 1
    transformed = common.flip_horiz(input_grid)
    output_grid = common.grid(2 * W, 2 * H, 0)
    for i in range(2):
        for j in range(2):
            for r in range(H):
                for c in range(W):
                    output_grid[i * H + r][j * W + c] = transformed[r][c]
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    H = len(input_grid)
    W = len(input_grid[0])
    transformed = common.flip_horiz(input_grid)
    output_grid = common.grid(2 * W, 2 * H, 0)
    for i in range(2):
        for j in range(2):
            for r in range(H):
                for c in range(W):
                    output_grid[i * H + r][j * W + c] = transformed[r][c]
    return output_grid
