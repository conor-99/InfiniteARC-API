# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: cda18c9c
Difficulty: insane

=== Tags ===
- Draw path through ordered checkpoints
- Alternating agents
- Relational projection
- Truth table visualization
- Propagate label
- Draw x on largest object

=== Description ===
Input grids feature a background color (0) and multiple distinct colored objects
(1–8), each a connected region of a single color. Each object contains a
designated checkpoint cell, identified as the top-left cell of the object's
bounding box. Checkpoints are ordered by row-major position (smallest row index
first, then smallest column index).   The output grid transforms the input by
drawing a path between consecutive checkpoints in sequence. Path segments
alternate between two colors (e.g., color A for segment 1→2, color B for 2→3),
following the shortest route through background cells (0) while avoiding all
non-background cells. Path segments are drawn as straight horizontal/vertical
lines where possible; if obstructed, they take the nearest available route.
Relational projection determines segment directions: the vector from checkpoint
i to i+1 is projected relative to the bounding boxes of the corresponding
objects. For example, if object i is north of object i+1, the path segment moves
south.   Truth table visualization is achieved by mapping each segment’s
direction (N/S/E/W) to binary values (e.g., N=0, S=1, E=0, W=1), forming a row
in a two-variable truth table. Labels (0 or 1) are propagated along path
segments, with each cell labeled according to its segment’s truth value.   The
largest object (by area) in the input is identified, and an 'X' pattern (two
crossing lines) is drawn centered on this object using color 9, without
overlapping background cells. The output preserves all input objects,
checkpoints, and the pattern strip, with no overwriting of non-background
regions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque
from common import grid

# We'll place objects in a grid of 3x3 blocks so that rows/cols divisible by 3 are corridors (background)
# This allows deterministic straight corridor routing that avoids objects.

NEIGHBORS = [(0, 1), (1, 0), (0, -1), (-1, 0)]


def route_manhattan_on_corridors(port1, port2):
    # Both ports are on corridor intersections (coords divisible by 3)
    (r1, c1), (r2, c2) = port1, port2
    path = []
    # Horizontal step from c1 to c2 on row r1
    step = 1 if c2 >= c1 else -1
    for c in range(c1, c2 + step, step):
        path.append((r1, c))
    # Vertical step from r1 to r2 on column c2, skip starting intersection at (r1,c2) to avoid duplicate
    step = 1 if r2 >= r1 else -1
    for r in range(r1 + step, r2 + step, step):
        path.append((r, c2))
    return path


def place_block_objects(width, height, count):
    # Blocks start at rows 1,4,7,... and columns 1,4,7,... each block is 2x2
    block_rows = (height - 1) // 3
    block_cols = (width - 1) // 3
    blocks = []
    for br in range(block_rows):
        for bc in range(block_cols):
            r0 = 1 + br * 3
            c0 = 1 + bc * 3
            blocks.append((r0, c0))
    random.shuffle(blocks)
    count = min(count, len(blocks))
    chosen = blocks[:count]
    colors = random.sample(list(range(1, 9)), count)
    grid_in = grid(width, height, 0)
    objects = []
    for (r0, c0), color in zip(chosen, colors):
        pixels = []
        # fill 2x2 block
        for dr in range(2):
            for dc in range(2):
                r = r0 + dr
                c = c0 + dc
                if 0 <= r < height and 0 <= c < width:
                    grid_in[r][c] = color
                    pixels.append((r, c))
        objects.append((color, pixels))
    return grid_in, objects


def bbox_of(pixels):
    rs = [p[0] for p in pixels]
    cs = [p[1] for p in pixels]
    return min(rs), max(rs), min(cs), max(cs)


def pick_largest_object(objects):
    # Choose object with largest area; ties broken by smallest top-left coordinate
    best = None
    best_key = None
    for color, pixels in objects:
        area = len(pixels)
        rmin, rmax, cmin, cmax = bbox_of(pixels)
        key = (area, -rmin, -cmin)  # larger area preferred, then smaller rmin,cmin
        if best is None or key > best_key:
            best = (color, pixels)
            best_key = key
    return best


def generate():
    width = random.randint(12, 20)
    height = random.randint(12, 20)
    count = random.randint(3, 5)

    grid_in, objects = place_block_objects(width, height, count)

    # Compute checkpoints as top-left of each object's bbox
    checkpoints = []
    for color, pixels in objects:
        rmin, rmax, cmin, cmax = bbox_of(pixels)
        checkpoints.append((rmin, cmin, color, pixels))
    checkpoints.sort(key=lambda x: (x[0], x[1]))

    grid_out = [row[:] for row in grid_in]

    # For each consecutive pair, compute corridor ports (round down to nearest multiple of 3) and route
    path_colors = [6, 7]
    color_idx = 0
    ports = []
    for (rmin, cmin, _, _) in checkpoints:
        port = (rmin - (rmin % 3), cmin - (cmin % 3))
        ports.append(port)
    for i in range(len(ports) - 1):
        p1 = ports[i]
        p2 = ports[i + 1]
        path = route_manhattan_on_corridors(p1, p2)
        color = path_colors[color_idx % 2]
        color_idx += 1
        for (r, c) in path:
            # only draw on background
            if grid_out[r][c] == 0:
                grid_out[r][c] = color

    # Draw X on largest object
    largest = pick_largest_object(objects)
    if largest:
        _, pixels = largest
        pixset = set(pixels)
        rmin, rmax, cmin, cmax = bbox_of(pixels)
        diag_len = min(rmax - rmin, cmax - cmin) + 1
        for i in range(diag_len):
            r1 = rmin + i
            c1 = cmin + i
            if (r1, c1) in pixset:
                grid_out[r1][c1] = 9
            r2 = rmin + i
            c2 = cmax - i
            if (r2, c2) in pixset:
                grid_out[r2][c2] = 9

    return {"input": grid_in, "output": grid_out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque
from common import grid

# Same corridor routing logic as generator

def route_manhattan_on_corridors(port1, port2):
    (r1, c1), (r2, c2) = port1, port2
    path = []
    step = 1 if c2 >= c1 else -1
    for c in range(c1, c2 + step, step):
        path.append((r1, c))
    step = 1 if r2 >= r1 else -1
    for r in range(r1 + step, r2 + step, step):
        path.append((r, c2))
    return path


def place_block_objects(width, height, count):
    block_rows = (height - 1) // 3
    block_cols = (width - 1) // 3
    blocks = []
    for br in range(block_rows):
        for bc in range(block_cols):
            r0 = 1 + br * 3
            c0 = 1 + bc * 3
            blocks.append((r0, c0))
    return blocks


def bbox_of(pixels):
    rs = [p[0] for p in pixels]
    cs = [p[1] for p in pixels]
    return min(rs), max(rs), min(cs), max(cs)


def pick_largest_object(objects):
    best = None
    best_key = None
    for color, pixels in objects:
        area = len(pixels)
        rmin, rmax, cmin, cmax = bbox_of(pixels)
        key = (area, -rmin, -cmin)
        if best is None or key > best_key:
            best = (color, pixels)
            best_key = key
    return best


def p(input_grid):
    grid_in = [list(row) for row in input_grid]
    rows = len(grid_in)
    cols = len(grid_in[0])

    # Find connected components of non-zero cells
    visited = [[False] * cols for _ in range(rows)]
    objects = []
    from collections import deque as _deque
    NEIGHBORS = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    for r in range(rows):
        for c in range(cols):
            if grid_in[r][c] != 0 and not visited[r][c]:
                color = grid_in[r][c]
                q = _deque()
                q.append((r, c))
                visited[r][c] = True
                pixels = []
                while q:
                    cr, cc = q.popleft()
                    pixels.append((cr, cc))
                    for dr, dc in NEIGHBORS:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and grid_in[nr][nc] == color:
                            visited[nr][nc] = True
                            q.append((nr, nc))
                objects.append((color, pixels))

    # Determine checkpoints (top-left of bbox) sorted row-major
    checkpoints = []
    for color, pixels in objects:
        rmin = min(p[0] for p in pixels)
        cmin = min(p[1] for p in pixels)
        checkpoints.append((rmin, cmin, color, pixels))
    checkpoints.sort(key=lambda x: (x[0], x[1]))

    grid_out = [row[:] for row in grid_in]

    if len(checkpoints) >= 2:
        path_colors = [6, 7]
        color_idx = 0
        ports = []
        for (rmin, cmin, _, _) in checkpoints:
            port = (rmin - (rmin % 3), cmin - (cmin % 3))
            ports.append(port)
        for i in range(len(ports) - 1):
            p1 = ports[i]
            p2 = ports[i + 1]
            path = route_manhattan_on_corridors(p1, p2)
            color = path_colors[color_idx % 2]
            color_idx += 1
            for (r, c) in path:
                if grid_out[r][c] == 0:
                    grid_out[r][c] = color

    # Draw X on largest object
    if objects:
        largest = pick_largest_object(objects)
        _, pixels = largest
        pixset = set(pixels)
        rmin, rmax, cmin, cmax = bbox_of(pixels)
        diag_len = min(rmax - rmin, cmax - cmin) + 1
        for i in range(diag_len):
            r1 = rmin + i
            c1 = cmin + i
            if (r1, c1) in pixset:
                grid_out[r1][c1] = 9
            r2 = rmin + i
            c2 = cmax - i
            if (r2, c2) in pixset:
                grid_out[r2][c2] = 9

    return tuple(tuple(row) for row in grid_out)
