# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 6de92bb8
Difficulty: very hard

=== Tags ===
- Region partitioning
- Boundary tracing
- Gas expansion

=== Description ===
The input grid features a black background (color 0), multiple contiguous
colored regions (each a single distinct color), and gray boundary lines (color
5) that form complex, interconnected paths and closed loops. The boundaries act
as impassable barriers that prevent regions from expanding across them. The
output grid is generated by expanding each colored region into adjacent black
cells in all four cardinal directions (up, down, left, right), continuing until
expansion would either cross a gray boundary, overlap another region's area, or
exceed grid boundaries. Each black cell in the output is filled with the color
of the nearest region, where "nearest" is determined by the shortest path along
the grid that avoids gray boundaries. This results in a fully partitioned grid
where regions expand to fill all accessible background space without crossing
boundaries or overlapping other regions, creating a visually coherent
partitioning that respects the structural constraints imposed by the boundary
lines. The complexity arises from the need to simultaneously track multiple
expansion fronts, navigate intricate boundary networks, and resolve conflicts at
boundary intersections where regions would otherwise compete for the same space.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque

def generate():
    """
    Generate an ARC-style input/output pair for the region-partitioning task.

    The generator builds a grid with gray (5) boundary lines that partition
    the space into several connected background components. It then plants a
    small contiguous colored seed (one color per component) inside each
    background component (but only a few cells, so there remain black cells to
    be expanded). Finally it computes the multi-source BFS expansion of those
    seeds (not crossing gray boundaries) to produce the output.
    """
    for attempt in range(200):
        width = random.randint(6, 20)
        height = random.randint(6, 20)
        ingrid = [[0 for _ in range(width)] for _ in range(height)]

        # 1) Draw a mixture of barriers so the partitioning is nontrivial.
        # Horizontal and vertical strokes with gaps plus some rectangular loops.
        # This yields varied, but not too numerous, components.
        for r in range(1, height - 1):
            if random.random() < 0.18:
                for c in range(width):
                    # occasionally leave gaps
                    if random.random() < 0.86:
                        ingrid[r][c] = 5
        for c in range(1, width - 1):
            if random.random() < 0.18:
                for r in range(height):
                    if random.random() < 0.86:
                        ingrid[r][c] = 5

        # Add 0-3 small rectangular loops to increase topological complexity
        for _ in range(random.randint(0, 3)):
            if width < 4 or height < 4:
                break
            top = random.randint(1, height - 3)
            left = random.randint(1, width - 3)
            bottom = random.randint(top + 1, min(height - 2, top + 4))
            right = random.randint(left + 1, min(width - 2, left + 4))
            for c in range(left, right + 1):
                ingrid[top][c] = 5
                ingrid[bottom][c] = 5
            for r in range(top, bottom + 1):
                ingrid[r][left] = 5
                ingrid[r][right] = 5

        # 2) Find connected components of background (0) using 4-neighborhood.
        visited = [[False] * width for _ in range(height)]
        components = []
        for r in range(height):
            for c in range(width):
                if ingrid[r][c] != 0 or visited[r][c]:
                    continue
                comp = []
                dq = deque([(r, c)])
                visited[r][c] = True
                while dq:
                    cr, cc = dq.popleft()
                    comp.append((cr, cc))
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and ingrid[nr][nc] == 0:
                            visited[nr][nc] = True
                            dq.append((nr, nc))
                components.append(comp)

        total_zero = sum(len(comp) for comp in components)

        # We want 2..8 components and at least one component bigger than 1 so that
        # the BFS expansion actually changes the grid (input != output). If we
        # fail to produce such a layout, try again.
        if not (2 <= len(components) <= 8 and total_zero > len(components)):
            # fallback: try a regular spaced grid of barriers after some attempts
            if attempt < 30:
                continue
            # create fallback grid lines (coarser) to ensure enough structure
            spacing = 3
            ingrid = [[0] * width for _ in range(height)]
            for rr in range(height):
                for cc in range(width):
                    if (rr + 1) % spacing == 0 or (cc + 1) % spacing == 0:
                        ingrid[rr][cc] = 5
            # recompute components on fallback
            visited = [[False] * width for _ in range(height)]
            components = []
            for r in range(height):
                for c in range(width):
                    if ingrid[r][c] != 0 or visited[r][c]:
                        continue
                    comp = []
                    dq = deque([(r, c)])
                    visited[r][c] = True
                    while dq:
                        cr, cc = dq.popleft()
                        comp.append((cr, cc))
                        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and ingrid[nr][nc] == 0:
                                visited[nr][nc] = True
                                dq.append((nr, nc))
                    components.append(comp)
            total_zero = sum(len(comp) for comp in components)
            if not (2 <= len(components) <= 8 and total_zero > len(components)):
                continue

        # 3) Place exactly one colored region per connected component. Each region
        # is small (1..3 cells) and contiguous so there remain black cells to be
        # expanded into. Colors are distinct and exclude 5 (gray).
        color_choices = [c for c in range(1, 10) if c != 5]
        num_comp = len(components)
        colors = random.sample(color_choices, num_comp)

        for comp_index, comp in enumerate(components):
            comp_set = set(comp)
            comp_size = len(comp)
            # Prefer small seeds so expansion will occur; if comp_size==1 we must use 1.
            if comp_size == 1:
                seed_size = 1
            else:
                seed_size = random.randint(1, min(3, comp_size - 1))

            # Pick a start cell and grow a tiny contiguous patch inside the component.
            start = random.choice(comp)
            region = {start}
            frontier = [start]
            while len(region) < seed_size:
                candidates = []
                for cell in frontier:
                    r0, c0 = cell
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nb = (r0 + dr, c0 + dc)
                        if nb in comp_set and nb not in region:
                            candidates.append(nb)
                if not candidates:
                    # pick any remaining cell in component that has neighbors
                    possibles = [p for p in comp if any(((p[0] + dr, p[1] + dc) in comp_set and (p[0] + dr, p[1] + dc) not in region) for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)))]
                    if not possibles:
                        break
                    new = random.choice(possibles)
                else:
                    new = random.choice(candidates)
                region.add(new)
                frontier.append(new)

            # Color the small seed region
            color = colors[comp_index]
            for (r, c) in region:
                ingrid[r][c] = color

        # Ensure the input grid still has at least one zero cell to be filled
        remaining_zeros = sum(1 for r in range(height) for c in range(width) if ingrid[r][c] == 0)
        if remaining_zeros == 0:
            continue

        # 4) Compute the output by a multi-source BFS (sources are all colored
        # cells, scanned row-major to match solver tie-breaking). Gray (5) cells
        # are impassable.
        dist = [[10 ** 9] * width for _ in range(height)]
        color_map = [[0] * width for _ in range(height)]
        q = deque()
        for r in range(height):
            for c in range(width):
                if ingrid[r][c] != 0 and ingrid[r][c] != 5:
                    dist[r][c] = 0
                    color_map[r][c] = ingrid[r][c]
                    q.append((r, c))

        while q:
            r, c = q.popleft()
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    if ingrid[nr][nc] == 0 and dist[nr][nc] > dist[r][c] + 1:
                        dist[nr][nc] = dist[r][c] + 1
                        color_map[nr][nc] = color_map[r][c]
                        q.append((nr, nc))

        output = [row[:] for row in ingrid]
        for r in range(height):
            for c in range(width):
                if output[r][c] == 0:
                    output[r][c] = color_map[r][c]

        # Sanity checks: dimensions OK and values in 0..9
        assert 1 <= width <= 30 and 1 <= height <= 30
        for row in output:
            for v in row:
                assert 0 <= v <= 9

        return {"input": ingrid, "output": output}

# If someone imports this file and expects generate to exist, it does.



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    # Convert tuple-of-tuples to list-of-lists if necessary
    ingrid = [list(row) for row in input_grid]
    height = len(ingrid)
    width = len(ingrid[0]) if height > 0 else 0

    dist = [[10 ** 9] * width for _ in range(height)]
    color_map = [[0] * width for _ in range(height)]
    q = deque()

    # Initialize BFS from all colored cells (exclude 0 and boundary 5). Scan
    # row-major so ties are resolved the same way the generator does.
    for r in range(height):
        for c in range(width):
            if ingrid[r][c] != 0 and ingrid[r][c] != 5:
                dist[r][c] = 0
                color_map[r][c] = ingrid[r][c]
                q.append((r, c))

    while q:
        r, c = q.popleft()
        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width:
                # Only expand into background cells (0) and never cross 5.
                if ingrid[nr][nc] == 0 and dist[nr][nc] > dist[r][c] + 1:
                    dist[nr][nc] = dist[r][c] + 1
                    color_map[nr][nc] = color_map[r][c]
                    q.append((nr, nc))

    # Fill background cells with the color of the nearest seed (or leave 0 if unreachable).
    out = [row[:] for row in ingrid]
    for r in range(height):
        for c in range(width):
            if out[r][c] == 0:
                out[r][c] = color_map[r][c]

    return out

