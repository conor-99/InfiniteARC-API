# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 3ab729f4
Difficulty: medium

=== Tags ===
- Image expasion
- Associate color to bools
- Pattern coloring
- Maze

=== Description ===
The input grid represents a maze where color 1 (red) indicates the path and
color 0 (black) represents walls. The output grid is created by expanding each
input cell into a 2×2 block. Path cells (color 1) are transformed into solid 2×2
blocks of color 1. Wall cells (color 0) are transformed into a checkerboard
pattern alternating between color 0 (black) and color 5 (gray). This rule
applies uniformly across all cells, producing an output grid with dimensions
twice the width and height of the input. The transformation relies on visual
color associations rather than numerical properties, with the maze structure
visually preserved through the checkerboard pattern for walls and solid path
representation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(1, 15)
    height = random.randint(1, 15)
    input_grid = [[random.choice([0, 1]) for _ in range(width)] for _ in range(height)]
    output_width = 2 * width
    output_height = 2 * height
    output_grid = [[0] * output_width for _ in range(output_height)]
    for i in range(height):
        for j in range(width):
            if input_grid[i][j] == 1:
                output_grid[2*i][2*j] = 1
                output_grid[2*i][2*j+1] = 1
                output_grid[2*i+1][2*j] = 1
                output_grid[2*i+1][2*j+1] = 1
            else:
                output_grid[2*i][2*j] = 0
                output_grid[2*i][2*j+1] = 5
                output_grid[2*i+1][2*j] = 5
                output_grid[2*i+1][2*j+1] = 0
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output_width = 2 * width
    output_height = 2 * height
    output_grid = [[0] * output_width for _ in range(output_height)]
    for i in range(height):
        for j in range(width):
            if input_grid[i][j] == 1:
                output_grid[2*i][2*j] = 1
                output_grid[2*i][2*j+1] = 1
                output_grid[2*i+1][2*j] = 1
                output_grid[2*i+1][2*j+1] = 1
            else:
                output_grid[2*i][2*j] = 0
                output_grid[2*i][2*j+1] = 5
                output_grid[2*i+1][2*j] = 5
                output_grid[2*i+1][2*j+1] = 0
    return output_grid
