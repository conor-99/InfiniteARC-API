# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: b48eed36
Difficulty: very hard

=== Tags ===
- Hollow shape detection
- Gravity with barriers
- Obstacles
- Detect symmetry
- Adapt image to grid

=== Description ===
Input grids consist of 2D grids (1×1 to 30×30) with background color (0),
obstacles (fixed color 5), and multiple colored shapes (colors 1–4). Shapes may
be solid or hollow, where hollow shapes are defined as connected regions of non-
background color that enclose at least one background cell (forming a ring-like
structure with a hole). Obstacles are fixed barriers that block gravity-driven
filling and remain unchanged throughout the transformation.  The transformation
process involves three sequential operations:   1. **Hollow Shape Detection**:
Identify all connected hollow shapes by locating non-background regions that
enclose background cells (using 4-connectivity for shape boundaries).   2.
**Gravity Application**: For each hollow shape, fill its interior background
cells by simulating downward gravity (top to bottom). Starting from the topmost
interior background cell, propagate the shape's color downward until
encountering an obstacle (color 5), the grid boundary, or the shape's boundary.
Each filled cell adopts the shape's color.   3. **Symmetry Adaptation**: After
filling, enforce vertical symmetry by mirroring the left half of the grid to the
right half (column *i* becomes column *width−1−i*). This overwrites asymmetric
right-half cells with mirrored left-half values, preserving obstacles, filled
areas, and background. The middle column (if width is odd) remains unchanged.
The output grid must strictly adhere to these steps: hollow shapes are filled
via gravity with obstacle constraints, and the final grid is vertically
symmetric. No input grid matches its output due to the symmetry adaptation and
gravity filling.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque

# Generator for ARC Task 478: hollow ring detection, gravity filling, vertical symmetry

def generate():
    """
    Generate an input/output pair following the specification:
    - background 0, obstacles 5, shapes colors 1-4
    - at least one hollow shape (ring) is placed (guaranteed)
    - obstacles are placed first and do not overlap the placed shapes
    - interior (enclosed) background cells are filled by gravity (top to bottom)
      within each enclosed region, blocked by obstacles and shape boundaries
    - finally mirror left half to right half (copy left->right) but do NOT
      overwrite obstacle cells and do NOT create new obstacles (do not copy
      left obstacles to right and do not overwrite right obstacles)
    """

    # Choose grid size large enough to host a hollow ring reliably
    width = random.randint(5, min(20, 30))
    height = random.randint(5, min(20, 30))

    # Initialize empty grid
    grid = [[0 for _ in range(width)] for _ in range(height)]

    # Place some obstacles (color 5) first so they don't accidentally break rings
    max_obstacles = max(0, (width * height) // 10)
    obstacle_count = random.randint(0, max_obstacles)
    all_cells = [(r, c) for r in range(height) for c in range(width)]
    random.shuffle(all_cells)
    for i in range(obstacle_count):
        r, c = all_cells[i]
        grid[r][c] = 5

    colors = [1, 2, 3, 4]
    random.shuffle(colors)

    placed_hollow = False
    used_colors = []

    # Place 1..3 shapes; ensure at least one hollow ring is actually placed
    shape_count = random.randint(1, min(3, len(colors)))
    for si in range(shape_count):
        color = colors[si]
        # Decide shape type: prefer to place at least one hollow ring
        want_hollow = (not placed_hollow) or (random.random() < 0.5)

        if want_hollow:
            # ring sizes must be at least 3x3 and at most fit within width-2/height-2
            sprite_w = random.randint(3, min(9, width - 2))
            sprite_h = random.randint(3, min(9, height - 2))
            # To ensure a true enclosed hole, place the ring away from the grid border
            r0_min = 1
            r0_max = height - sprite_h - 1
            c0_min = 1
            c0_max = width - sprite_w - 1
            if r0_max < r0_min or c0_max < c0_min:
                # not enough space for a hollow ring here; fall back to solid
                want_hollow = False
        else:
            # solid rectangles can touch borders
            sprite_w = random.randint(1, min(8, width))
            sprite_h = random.randint(1, min(8, height))
            r0_min = 0
            r0_max = height - sprite_h
            c0_min = 0
            c0_max = width - sprite_w

        placed = False
        # Try to place the shape at a non-overlapping location
        for _ in range(50):
            r0 = random.randint(r0_min, r0_max)
            c0 = random.randint(c0_min, c0_max)
            coords = []
            if want_hollow:
                # ring border cells only
                for rr in range(sprite_h):
                    for cc in range(sprite_w):
                        if rr == 0 or rr == sprite_h - 1 or cc == 0 or cc == sprite_w - 1:
                            coords.append((r0 + rr, c0 + cc))
            else:
                # solid rectangle
                for rr in range(sprite_h):
                    for cc in range(sprite_w):
                        coords.append((r0 + rr, c0 + cc))

            # ensure coords are in-bounds and do not collide with obstacles or existing shapes
            ok = True
            for (r, c) in coords:
                if grid[r][c] != 0:
                    ok = False
                    break
            if not ok:
                continue

            # place the shape
            for (r, c) in coords:
                grid[r][c] = color

            used_colors.append(color)
            if want_hollow:
                placed_hollow = True
            placed = True
            break

        # continue to next shape

    # If we failed to place any hollow ring, force one small hollow 3x3 ring in a valid spot
    if not placed_hollow:
        placed_flag = False
        for _ in range(200):
            sprite_w = 3
            sprite_h = 3
            r0 = random.randint(1, height - sprite_h - 1)
            c0 = random.randint(1, width - sprite_w - 1)
            coords = [(r0 + rr, c0 + cc) for rr in range(sprite_h) for cc in range(sprite_w)
                      if rr == 0 or rr == sprite_h - 1 or cc == 0 or cc == sprite_w - 1]
            if all(grid[r][c] == 0 for (r, c) in coords):
                col = random.choice(colors)
                for (r, c) in coords:
                    grid[r][c] = col
                used_colors.append(col)
                placed_flag = True
                break
        # by construction with height,width >=5 this should succeed
        if not placed_flag:
            # As a final fallback (extremely unlikely), overwrite a 3x3 area in the interior
            r0 = 1
            c0 = 1
            col = colors[0]
            for rr in range(3):
                for cc in range(3):
                    if rr == 0 or rr == 2 or cc == 0 or cc == 2:
                        grid[r0 + rr][c0 + cc] = col
            used_colors.append(col)

    # Prepare input copy
    input_grid = [row[:] for row in grid]

    # --- Apply transformation rules to produce output ---
    # Step A: identify background cells reachable from the boundary (outside background)
    visited = [[False] * width for _ in range(height)]
    q = deque()
    # top and bottom rows
    for c in range(width):
        if input_grid[0][c] == 0 and not visited[0][c]:
            visited[0][c] = True
            q.append((0, c))
        if input_grid[height - 1][c] == 0 and not visited[height - 1][c]:
            visited[height - 1][c] = True
            q.append((height - 1, c))
    # left and right columns (excluding corners already added)
    for r in range(1, height - 1):
        if input_grid[r][0] == 0 and not visited[r][0]:
            visited[r][0] = True
            q.append((r, 0))
        if input_grid[r][width - 1] == 0 and not visited[r][width - 1]:
            visited[r][width - 1] = True
            q.append((r, width - 1))

    while q:
        r, c = q.popleft()
        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == 0:
                visited[nr][nc] = True
                q.append((nr, nc))

    # interior background cells are zeros that are NOT visited
    interior = [(r, c) for r in range(height) for c in range(width) if input_grid[r][c] == 0 and not visited[r][c]]
    interior_set = set(interior)

    # Group interior cells into connected components (4-connectivity)
    components = []
    while interior_set:
        start = next(iter(interior_set))
        comp = {start}
        dq = deque([start])
        interior_set.remove(start)
        while dq:
            r, c = dq.popleft()
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = r + dr, c + dc
                if (nr, nc) in interior_set:
                    interior_set.remove((nr, nc))
                    comp.add((nr, nc))
                    dq.append((nr, nc))
        components.append(comp)

    output = [row[:] for row in input_grid]

    # For each enclosed component, determine the enclosing shape color (neighboring non-obstacle non-background)
    for comp in components:
        neighbor_colors = {}
        for (r, c) in comp:
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    val = input_grid[nr][nc]
                    if val != 0 and val != 5:
                        neighbor_colors[val] = neighbor_colors.get(val, 0) + 1
        if not neighbor_colors:
            # No enclosing color (rare if surrounded only by obstacles) - skip
            continue
        # choose the most common neighboring non-obstacle color
        enclosing_color = max(neighbor_colors.keys(), key=lambda k: neighbor_colors[k])

        # Build per-column lists of rows inside this component
        cols = {}
        for (r, c) in comp:
            cols.setdefault(c, []).append(r)

        min_c = min(cols.keys())
        max_c = max(cols.keys())

        # For each column in the component, fill from topmost interior cell downward while staying inside the component
        for c in range(min_c, max_c + 1):
            if c not in cols:
                continue
            top_r = min(cols[c])
            for r in range(top_r, height):
                if (r, c) not in comp:
                    break
                # stop at an obstacle if encountered (though obstacles are not in comp)
                if output[r][c] == 5:
                    break
                output[r][c] = enclosing_color

    # Apply vertical symmetry: copy left half to right half, but do NOT overwrite obstacles and do NOT create new obstacles
    half = width // 2
    for r in range(height):
        for c in range(half):
            left = output[r][c]
            rc = width - 1 - c
            # preserve obstacle positions and do not create new obstacles
            if output[r][rc] == 5 or left == 5:
                continue
            output[r][rc] = left

    return {"input": input_grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    # Convert input to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    if height == 0 or width == 0:
        return grid

    # Step 1: Identify background cells connected to the boundary
    visited = [[False] * width for _ in range(height)]
    q = deque()

    # top and bottom rows
    for c in range(width):
        if grid[0][c] == 0 and not visited[0][c]:
            visited[0][c] = True
            q.append((0, c))
        if grid[height - 1][c] == 0 and not visited[height - 1][c]:
            visited[height - 1][c] = True
            q.append((height - 1, c))

    # left and right columns (excluding corners again)
    for r in range(1, height - 1):
        if grid[r][0] == 0 and not visited[r][0]:
            visited[r][0] = True
            q.append((r, 0))
        if grid[r][width - 1] == 0 and not visited[r][width - 1]:
            visited[r][width - 1] = True
            q.append((r, width - 1))

    while q:
        r, c = q.popleft()
        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == 0:
                visited[nr][nc] = True
                q.append((nr, nc))

    # interior cells are background cells not reachable from boundary
    interior_cells = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == 0 and not visited[r][c]]
    interior_set = set(interior_cells)

    # Step 2: group interior cells into connected components and fill by gravity per component
    components = []
    while interior_set:
        start = next(iter(interior_set))
        comp = {start}
        dq = deque([start])
        interior_set.remove(start)
        while dq:
            r, c = dq.popleft()
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = r + dr, c + dc
                if (nr, nc) in interior_set:
                    interior_set.remove((nr, nc))
                    comp.add((nr, nc))
                    dq.append((nr, nc))
        components.append(comp)

    output = [row[:] for row in grid]

    for comp in components:
        # Determine the enclosing shape color by looking at non-obstacle non-background neighbors
        neighbor_counts = {}
        for (r, c) in comp:
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    v = grid[nr][nc]
                    if v != 0 and v != 5:
                        neighbor_counts[v] = neighbor_counts.get(v, 0) + 1
        if not neighbor_counts:
            continue
        enclosing_color = max(neighbor_counts.keys(), key=lambda k: neighbor_counts[k])

        # Group rows by column inside component
        cols = {}
        for (r, c) in comp:
            cols.setdefault(c, []).append(r)
        min_c = min(cols.keys())
        max_c = max(cols.keys())

        # For each column, find topmost interior cell and fill downward while staying in the component
        for c in range(min_c, max_c + 1):
            if c not in cols:
                continue
            top_r = min(cols[c])
            for r in range(top_r, height):
                if (r, c) not in comp:
                    break
                if output[r][c] == 5:
                    # obstacle blocks filling
                    break
                output[r][c] = enclosing_color

    # Step 3: Mirror left half to right half without overwriting or creating obstacles
    half = width // 2
    for r in range(height):
        for c in range(half):
            left = output[r][c]
            rc = width - 1 - c
            if output[r][rc] == 5 or left == 5:
                continue
            output[r][rc] = left

    return output

