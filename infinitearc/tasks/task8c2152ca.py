# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 8c2152ca
Difficulty: insane

=== Tags ===
- Cut and unfold
- Normalize orientation

=== Description ===
Task Name: Cut and Unfold  Description: Input grids are square with dimensions
between 10×10 and 30×30. Each input grid contains a single continuous line of a
uniform color that spans the entire grid either horizontally or vertically,
dividing it into two distinct regions. One of these regions is folded over the
line, resulting in a mirrored version of itself superimposed on the opposite
region. The output grid is the original grid before folding, with the fold line
removed and all elements normalized to their canonical orientation (i.e.,
horizontal features aligned left-to-right and vertical features aligned top-to-
bottom).  For example: - If the fold line is horizontal (spanning the middle
row), the bottom region is folded upward and mirrored over the line. The output
grid restores the bottom region to its original orientation (not mirrored),
aligning all horizontal features left-to-right. - If the fold line is vertical
(spanning the middle column), the right region is folded leftward and mirrored
over the line. The output grid restores the right region to its original
orientation (not mirrored), aligning all vertical features top-to-bottom.  The
transformation requires identifying the direction of the fold line, reversing
the mirroring of the folded region, and ensuring all features are oriented along
the grid's natural axes. The task is "insane" due to the need to detect the fold
line direction, reverse the mirroring in the correct region, and normalize
orientation across a large, complex grid with multiple distinct features.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_color

def generate():
    # Square size between 10 and 30, force odd to make halves symmetric
    n = random.randint(10, 30)
    if n % 2 == 0:
        if n < 30:
            n += 1
        else:
            n -= 1
    base = grid(n, n, 0)

    # Fixed special colors (fold line and anchor) and content colors avoid them
    FOLD_COLOR = 1
    ANCHOR_COLOR = 9

    # choose fold direction and which side is the original (contains the real content)
    fold_dir = random.choice(["horizontal", "vertical"])  # where the 1-line will go
    mid = n // 2

    # helper to pick a random content color excluding fold and anchor
    def rand_content_color():
        return random_color(exclude=[0, FOLD_COLOR, ANCHOR_COLOR])

    # Populate the base grid: place content only on the chosen original side
    if fold_dir == "horizontal":
        original_side = random.choice(["top", "bottom"])  # which half holds the real content
        for r in range(n):
            for c in range(n):
                if original_side == "top":
                    if r < mid and random.random() < 0.25:
                        base[r][c] = rand_content_color()
                else:
                    if r > mid and random.random() < 0.25:
                        base[r][c] = rand_content_color()
        # place a unique anchor pixel in the original half (guaranteed unique color)
        if original_side == "top":
            anchor_r = random.randint(0, mid - 1)
        else:
            anchor_r = random.randint(mid + 1, n - 1)
        anchor_c = random.randint(0, n - 1)
        base[anchor_r][anchor_c] = ANCHOR_COLOR

        # Build the input grid: copy base, insert fold line, and mirror the original half onto the other side
        input_grid = [row[:] for row in base]
        # insert fold line
        input_grid[mid] = [FOLD_COLOR] * n

        if original_side == "top":
            # copy top into bottom mirrored across the fold line, but do not copy the anchor pixel
            for r in range(mid + 1, n):
                src_r = 2 * mid - r
                row = []
                for c in range(n):
                    val = base[src_r][c]
                    row.append(0 if val == ANCHOR_COLOR else val)
                input_grid[r] = row
        else:
            # copy bottom into top mirrored across fold line
            for r in range(0, mid):
                src_r = 2 * mid - r
                row = []
                for c in range(n):
                    val = base[src_r][c]
                    row.append(0 if val == ANCHOR_COLOR else val)
                input_grid[r] = row

    else:
        original_side = random.choice(["left", "right"])  # which half holds the real content
        for r in range(n):
            for c in range(n):
                if original_side == "left":
                    if c < mid and random.random() < 0.25:
                        base[r][c] = rand_content_color()
                else:
                    if c > mid and random.random() < 0.25:
                        base[r][c] = rand_content_color()
        # place anchor in the original half
        if original_side == "left":
            anchor_c = random.randint(0, mid - 1)
        else:
            anchor_c = random.randint(mid + 1, n - 1)
        anchor_r = random.randint(0, n - 1)
        base[anchor_r][anchor_c] = ANCHOR_COLOR

        input_grid = [row[:] for row in base]
        # insert fold column
        for r in range(n):
            input_grid[r][mid] = FOLD_COLOR

        if original_side == "left":
            # copy left into right mirrored across the fold column
            for c in range(mid + 1, n):
                src_c = 2 * mid - c
                for r in range(n):
                    val = base[r][src_c]
                    input_grid[r][c] = 0 if val == ANCHOR_COLOR else val
        else:
            # copy right into left mirrored across the fold column
            for c in range(0, mid):
                src_c = 2 * mid - c
                for r in range(n):
                    val = base[r][src_c]
                    input_grid[r][c] = 0 if val == ANCHOR_COLOR else val

    return {"input": input_grid, "output": base}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid_in = [list(row) for row in input_grid]
    n = len(grid_in)
    if n == 0:
        return grid_in

    # Detect fold line: a full row or full column of color 1
    FOLD_COLOR = 1
    ANCHOR_COLOR = 9
    fold_row = None
    fold_col = None
    for r in range(n):
        if all(grid_in[r][c] == FOLD_COLOR for c in range(n)):
            fold_row = r
            break
    if fold_row is None:
        for c in range(n):
            if all(grid_in[r][c] == FOLD_COLOR for r in range(n)):
                fold_col = c
                break

    # If no fold line found, return input unchanged
    if fold_row is None and fold_col is None:
        return grid_in

    # Find anchor location (unique marker)
    anchor_pos = None
    for r in range(n):
        for c in range(n):
            if grid_in[r][c] == ANCHOR_COLOR:
                anchor_pos = (r, c)
                break
        if anchor_pos:
            break

    # Prepare empty output grid
    output = [[0 for _ in range(n)] for _ in range(n)]

    if fold_row is not None:
        mid = fold_row
        # Determine which half is original by anchor row
        if anchor_pos is None:
            # fallback: prefer the half that contains more non-zero pixels
            top_count = sum(1 for r in range(0, mid) for c in range(n) if grid_in[r][c] != 0)
            bottom_count = sum(1 for r in range(mid + 1, n) for c in range(n) if grid_in[r][c] != 0)
            original_is_top = top_count >= bottom_count
        else:
            original_is_top = (anchor_pos[0] < mid)

        if original_is_top:
            for r in range(0, mid):
                output[r] = grid_in[r][:]
        else:
            for r in range(mid + 1, n):
                output[r] = grid_in[r][:]
        # fold line row stays zeros
        return output

    else:
        mid = fold_col
        # Determine which half is original by anchor column
        if anchor_pos is None:
            left_count = sum(1 for r in range(n) for c in range(0, mid) if grid_in[r][c] != 0)
            right_count = sum(1 for r in range(n) for c in range(mid + 1, n) if grid_in[r][c] != 0)
            original_is_left = left_count >= right_count
        else:
            original_is_left = (anchor_pos[1] < mid)

        if original_is_left:
            for r in range(n):
                for c in range(0, mid):
                    output[r][c] = grid_in[r][c]
        else:
            for r in range(n):
                for c in range(mid + 1, n):
                    output[r][c] = grid_in[r][c]
        # fold column stays zeros
        return output

