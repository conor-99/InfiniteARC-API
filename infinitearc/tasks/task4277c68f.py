# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 4277c68f
Difficulty: insane

=== Tags ===
- Alternating rule composition
- Grid overlay blending
- Mask based logic
- Substitution rule discovery

=== Description ===
Input grids are large (15×15 to 30×30) with a background color (0) and multiple
contiguous regions of distinct colors (1–9). A specific "mask color" (e.g.,
color 5) forms a complex, non-uniform mask that divides the grid into
alternating connected regions. The mask regions are contiguous areas where the
mask color appears, and they are arranged such that adjacent mask regions are
separated by non-mask regions. The output grid is generated through a sequence
of alternating rule compositions:   1. **Mask-based substitution**: Within mask
regions, each color is replaced by the next color in a fixed cyclic sequence
(e.g., 1→2, 2→3, ..., 9→1).   2. **Non-mask substitution**: Within non-mask
regions, each color is replaced by the previous color in the same cyclic
sequence (e.g., 1→9, 2→1, ..., 9→8).   3. **Grid overlay blending**: The
substitution rules alternate based on the parity of the cell’s row index (even
rows apply mask substitution, odd rows apply non-mask substitution), creating a
blended visual effect where the mask structure and alternating rule application
interact to transform the grid.    The transformation requires discovering the
cyclic color sequence (independent of numerical values), identifying the mask
regions, and recognizing the row-based alternation pattern to apply the correct
substitution rule to each cell. The output grid’s complexity arises from the
interplay between the mask’s irregular shape, the cyclic color shifts, and the
parity-based rule alternation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    mask_color = random.randint(1, 9)
    width = random.randint(15, 30)
    height = random.randint(15, 30)
    input_grid = [[0] * width for _ in range(height)]
    
    # Ensure first mask region has at least one cell
    first_region_set = False
    for r in range(3, 6):
        for c in range(3, 6):
            if not first_region_set and random.random() > 0.5:
                input_grid[r][c] = mask_color
                first_region_set = True

    # Ensure second mask region has at least one cell
    second_region_set = False
    for r in range(height - 6, height - 3):
        for c in range(width - 6, width - 3):
            if not second_region_set and random.random() > 0.5:
                input_grid[r][c] = mask_color
                second_region_set = True

    # Fill non-mask cells with fixed background color
    background_color = 1
    if background_color == mask_color:
        background_color = 2
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                input_grid[r][c] = background_color

    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            current = input_grid[r][c]
            is_mask = (current == mask_color)
            if r % 2 == 0:
                if is_mask:
                    new_color = (current % 9) + 1
                else:
                    new_color = (current - 2) % 9 + 1
            else:
                if is_mask:
                    new_color = (current - 2) % 9 + 1
                else:
                    new_color = (current % 9) + 1
            output_grid[r][c] = new_color
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    mask_color = None
    for color in range(1, 10):
        pixels = []
        for r in range(len(input_grid)):
            for c in range(len(input_grid[0])):
                if input_grid[r][c] == color:
                    pixels.append((r, c))
        if not pixels:
            continue
        visited = set()
        components = 0
        for (r, c) in pixels:
            if (r, c) not in visited:
                components += 1
                queue = [(r, c)]
                visited.add((r, c))
                while queue:
                    cr, cc = queue.pop(0)
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < len(input_grid) and 0 <= nc < len(input_grid[0]) and input_grid[nr][nc] == color and (nr, nc) not in visited:
                            visited.add((nr, nc))
                            queue.append((nr, nc))
        if components >= 2:
            mask_color = color
            break
    if mask_color is None:
        mask_color = 5
    
    output_grid = [[0] * len(input_grid[0]) for _ in range(len(input_grid))]
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            current = input_grid[r][c]
            is_mask = (current == mask_color)
            if r % 2 == 0:
                if is_mask:
                    new_color = (current % 9) + 1
                else:
                    new_color = (current - 2) % 9 + 1
            else:
                if is_mask:
                    new_color = (current - 2) % 9 + 1
                else:
                    new_color = (current % 9) + 1
            output_grid[r][c] = new_color
    return output_grid
