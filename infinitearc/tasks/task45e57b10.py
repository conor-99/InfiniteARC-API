# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 45e57b10
Difficulty: very hard

=== Tags ===
- Token following
- Flow with decay
- Signal tracing
- Emergent behavior
- Wraparound copy

=== Description ===
# Token Flow Network  Input grids feature a complex, interconnected network of
direction signals (represented by colors 1-4 indicating right, down, left, and
up respectively) embedded within a background of color 0. Scattered throughout
the grid are tokens (color T, distinct from signal colors) positioned on
background cells that connect to direction signal pathways. The grid dimensions
range from 15×15 to 30×30, with paths forming intricate mazes that include
turns, loops, and intersecting routes.  The transformation applies multi-step
signal tracing where each token follows its directional path: starting at the
token's position, it moves in the direction indicated by the current cell's
signal color, leaving a decaying color trail in each subsequent background cell
(0) it occupies. The trail color decays by 1 at each step (mod 10), meaning a
token with initial color 7 would leave trails of 7, 6, 5, 4, 3, 2, 1, 0, 9, 8,
and repeating. If movement would take the token off the grid, the path wraps to
the opposite edge (e.g., moving right from the rightmost column wraps to the
leftmost column). The trail only occupies background cells (0), stopping when
encountering non-background cells (direction signals or other trail elements).
The output grid reveals emergent patterns formed by overlapping decaying trails
from multiple tokens. Tokens moving toward each other may create symmetrical
decay patterns, while loops generate concentric color rings that wrap around the
grid. Direction changes at path junctions cause trails to split and merge,
producing complex interference patterns where decay rates interact with
wraparound mechanics. The direction signals remain visible beneath the trails,
and no two trails may occupy the same cell (trails overwrite only background
cells).  This task demands recognizing the direction network, tracking multiple
token paths simultaneously, applying decaying color sequences, handling grid
wraparound, and interpreting emergent patterns formed by overlapping trails —
all while ignoring the original token positions and direction signals in the
final output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, all_pixels

def generate():
    width = random.randint(15, 30)
    height = random.randint(15, 30)
    ingrid = grid(width, height, 0)
    
    # Add direction signals (1-4) in a grid pattern
    for r in range(height):
        for c in range(width):
            if random.random() < 0.2:
                ingrid[r][c] = random.randint(1, 4)

    # Place tokens (color 5) on background cells
    tokens = []
    for r in range(height):
        for c in range(width):
            if ingrid[r][c] == 0 and random.random() < 0.1:
                ingrid[r][c] = 5
                tokens.append((r, c))

    # Create output grid by simulating token paths
    output = grid(width, height, 0)
    
    for (r, c) in tokens:
        current_r, current_c = r, c
        color = 5
        while True:
            # Determine direction from current cell
            if ingrid[current_r][current_c] == 0:
                # No direction signal, stop
                break
            
            # Get direction (1-4)
            direction = ingrid[current_r][current_c]
            
            # Move in direction with wraparound
            if direction == 1:  # right
                current_c = (current_c + 1) % width
            elif direction == 2:  # down
                current_r = (current_r + 1) % height
            elif direction == 3:  # left
                current_c = (current_c - 1) % width
            elif direction == 4:  # up
                current_r = (current_r - 1) % height
            
            # Check if cell is background
            if ingrid[current_r][current_c] != 0:
                break
            
            # Draw trail with decay
            if output[current_r][current_c] == 0:
                output[current_r][current_c] = color
                color = (color - 1) % 10
            else:
                break
            
    return {
        "input": ingrid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    ingrid = [list(row) for row in input_grid]
    output = [[0] * width for _ in range(height)]
    
    # Find tokens (color 5)
    tokens = []
    for r in range(height):
        for c in range(width):
            if ingrid[r][c] == 5:
                tokens.append((r, c))

    for (r, c) in tokens:
        current_r, current_c = r, c
        color = 5
        while True:
            # Get current direction from cell (ignore token color)
            if ingrid[current_r][current_c] == 5:
                # Skip token cell (shouldn't happen in path)
                break
            direction = ingrid[current_r][current_c]
            
            # Move in direction with wraparound
            if direction == 1:  # right
                current_c = (current_c + 1) % width
            elif direction == 2:  # down
                current_r = (current_r + 1) % height
            elif direction == 3:  # left
                current_c = (current_c - 1) % width
            elif direction == 4:  # up
                current_r = (current_r - 1) % height
            
            # Check if cell is background
            if ingrid[current_r][current_c] != 0:
                break
            
            # Draw trail with decay
            if output[current_r][current_c] == 0:
                output[current_r][current_c] = color
                color = (color - 1) % 10
            else:
                break
    return output
