# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: f924d1ea
Difficulty: medium–hard

=== Tags ===
- Dual source paths
- Color by distance to edge

=== Description ===
The task features input grids containing two distinct, connected paths of non-
background colors, each path forming a continuous sequence of cells that spans
from one edge of the grid to the opposite edge without intersecting the other
path. These paths are composed of a single color per path (e.g., path A uses
color 3, path B uses color 7) and must be fully connected via orthogonal
adjacency. The rest of the grid is filled with a background color (0).   For the
output grid, the two paths retain their original colors and structure. All
background cells (originally 0) are recolored based on their minimum Manhattan
distance to the nearest grid edge. The distance for a cell at position (r, c) in
an H×W grid is calculated as min(r, H - 1 - r, c, W - 1 - c). Each distinct
distance value maps to a unique, sequential color in a predefined palette (e.g.,
distance 0 → color 5, distance 1 → color 6, distance 2 → color 7, etc.), cycling
through colors 5–9 as distance increases. This transformation requires
identifying the paths, excluding them from recoloring, and applying a consistent
distance-to-color mapping to all remaining cells. The complexity arises from
ensuring path connectivity, edge distance calculation, and palette mapping
without relying on specific color values, demanding multi-step reasoning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    H = random.randint(8, 30)
    W = random.randint(8, 30)
    grid = [[0] * W for _ in range(H)]
    path_color1 = 1
    path_color2 = 2
    
    # Generate path A (horizontal)
    r = random.randint(0, H-1)
    grid[r][0] = path_color1
    prev_r = r
    for c in range(1, W):
        r_next = prev_r + random.randint(-1, 1)
        r_next = max(0, min(r_next, H-1))
        grid[r_next][c] = path_color1
        prev_r = r_next
    
    # Generate path B (vertical)
    c = random.randint(0, W-1)
    grid[0][c] = path_color2
    prev_c = c
    for r in range(1, H):
        c_next = prev_c + random.randint(-1, 1)
        c_next = max(0, min(c_next, W-1))
        if grid[r][c_next] == path_color1:
            for dc in [-1, 1, 0]:
                c_candidate = prev_c + dc
                if 0 <= c_candidate < W and grid[r][c_candidate] != path_color1:
                    c_next = c_candidate
                    break
            else:
                return generate()
        grid[r][c_next] = path_color2
        prev_c = c_next
    
    output = [[0] * W for _ in range(H)]
    for r in range(H):
        for c in range(W):
            if grid[r][c] in (path_color1, path_color2):
                output[r][c] = grid[r][c]
            else:
                d = min(r, H-1 - r, c, W-1 - c)
                color = 5 + (d % 5)
                output[r][c] = color
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0])
    
    def is_connected(color, start, end):
        from collections import deque
        visited = [[False] * W for _ in range(H)]
        queue = deque([start])
        visited[start[0]][start[1]] = True
        while queue:
            r, c = queue.popleft()
            if (r, c) == end:
                return True
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc] and grid[nr][nc] == color:
                    visited[nr][nc] = True
                    queue.append((nr, nc))
        return False
    
    colors = set()
    for r in range(H):
        for c in range(W):
            if grid[r][c] != 0:
                colors.add(grid[r][c])
    
    horiz_color = None
    vert_color = None
    for color in colors:
        left_found = any(grid[r][0] == color for r in range(H))
        right_found = any(grid[r][W-1] == color for r in range(H))
        if left_found and right_found:
            left_pos = next((r, 0) for r in range(H) if grid[r][0] == color)
            right_pos = next((r, W-1) for r in range(H) if grid[r][W-1] == color)
            if is_connected(color, left_pos, right_pos):
                horiz_color = color
                continue
        top_found = any(grid[0][c] == color for c in range(W))
        bottom_found = any(grid[H-1][c] == color for c in range(W))
        if top_found and bottom_found:
            top_pos = next((0, c) for c in range(W) if grid[0][c] == color)
            bottom_pos = next((H-1, c) for c in range(W) if grid[H-1][c] == color)
            if is_connected(color, top_pos, bottom_pos):
                vert_color = color
                continue
    
    if horiz_color is None or vert_color is None:
        path_colors = list(colors)
    else:
        path_colors = [horiz_color, vert_color]
    
    output = [[0] * W for _ in range(H)]
    for r in range(H):
        for c in range(W):
            if grid[r][c] in path_colors:
                output[r][c] = grid[r][c]
            else:
                d = min(r, H-1 - r, c, W-1 - c)
                color = 5 + (d % 5)
                output[r][c] = color
    return output
