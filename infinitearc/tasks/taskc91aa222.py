# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: c91aa222
Difficulty: hard

=== Tags ===
- Mutual reflection
- Synchronized bounce
- Nested structure detection
- Mask based logic
- Project shadow

=== Description ===
Input grids feature a medium-to-large grid (15×15 to 30×30) with a uniform
background color. Overlaid are two symmetric main rectangular structures (e.g.,
6×6) positioned along a vertical axis, each surrounded by a border of a distinct
color. Within each main structure, a smaller, perfectly centered nested
rectangle (e.g., 3×3) occupies the interior, using a unique color different from
both the border and background. Between the main structures lies a contiguous
mask region—a background-defined corridor of 2–5 cells wide—serving as the
projection zone.   The output grid retains all original elements but adds shadow
bands derived from the nested structures. For each nested rectangle, a shadow
band is projected toward the mask region, with its color matching the nested
rectangle’s color and thickness equal to the nested rectangle’s dimensions.
Within the mask, the shadows "bounce" off the mask’s edges, creating a
synchronized mirrored pattern: the left structure’s shadow reflects rightward to
the mask’s right edge, while the right structure’s shadow reflects leftward to
the mask’s left edge. This mutual reflection ensures the shadow bands form a
continuous, non-overlapping pattern across the mask, adhering strictly to the
mask’s boundaries. Mask-based logic prevents shadows from overlapping with main
structures or other shadows, while nested structure detection ensures the
correct color and dimensions are applied. The final output visualizes the
synchronized bounce effect as a harmonized, geometric shadow lattice within the
mask.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Main rectangle sizes (allow some variation for uniqueness)
    main_width = random.randint(5, 8)
    main_height = random.randint(5, 8)

    # Mask width between 2 and 5
    mask_width = random.randint(2, 5)

    # Ensure overall width can fit two main rectangles and the mask
    min_width = max(15, 2 * main_width + mask_width)
    width = random.randint(min_width, 30)

    # Height must be at least large enough for the main rectangles
    height = random.randint(max(15, main_height), 30)

    # Horizontal placement: center the pair of main rectangles + mask
    x_left = (width - (2 * main_width + mask_width)) // 2
    x_right = x_left + main_width + mask_width

    # Vertical placement: allow variable vertical centering
    y = random.randint(0, height - main_height)

    # Colors: pick background, border, and two nested colors (distinct)
    colors = list(range(10))
    bkg = random.choice(colors)
    remaining = [c for c in colors if c != bkg]
    bdr = random.choice(remaining)
    remaining = [c for c in remaining if c != bdr]
    left_nst = random.choice(remaining)
    remaining = [c for c in remaining if c != left_nst]
    # Ensure right nested color is distinct from background and border and left nested
    if remaining:
        right_nst = random.choice(remaining)
    else:
        # Fallback, though with 10 colors this should not happen
        right_nst = left_nst

    # Nested rectangle sizes (must fit inside the main rectangle interior)
    nested_width_left = random.randint(2, max(2, main_width - 2))
    nested_height_left = random.randint(2, max(2, main_height - 2))
    nested_width_right = random.randint(2, max(2, main_width - 2))
    nested_height_right = random.randint(2, max(2, main_height - 2))

    # Create input and output grids
    input_grid = grid(width, height, bkg)
    output_grid = grid(width, height, bkg)

    # Draw left main border (outline thickness = 1)
    for r in range(y, y + main_height):
        for c in range(x_left, x_left + main_width):
            if r == y or r == y + main_height - 1 or c == x_left or c == x_left + main_width - 1:
                input_grid[r][c] = bdr
                output_grid[r][c] = bdr

    # Draw right main border
    for r in range(y, y + main_height):
        for c in range(x_right, x_right + main_width):
            if r == y or r == y + main_height - 1 or c == x_right or c == x_right + main_width - 1:
                input_grid[r][c] = bdr
                output_grid[r][c] = bdr

    # Draw left nested rectangle centered inside left main rectangle
    left_n_r0 = y + (main_height - nested_height_left) // 2
    left_n_c0 = x_left + (main_width - nested_width_left) // 2
    for r in range(left_n_r0, left_n_r0 + nested_height_left):
        for c in range(left_n_c0, left_n_c0 + nested_width_left):
            input_grid[r][c] = left_nst
            output_grid[r][c] = left_nst

    # Draw right nested rectangle centered inside right main rectangle
    right_n_r0 = y + (main_height - nested_height_right) // 2
    right_n_c0 = x_right + (main_width - nested_width_right) // 2
    for r in range(right_n_r0, right_n_r0 + nested_height_right):
        for c in range(right_n_c0, right_n_c0 + nested_width_right):
            input_grid[r][c] = right_nst
            output_grid[r][c] = right_nst

    # Project synchronized shadow bands into the mask region in the output grid
    mask_start = x_left + main_width
    mask_end = x_right - 1

    left_thick = nested_width_left
    right_thick = nested_width_right

    L = mask_start
    R = mask_end

    # Vertical band span: use the vertical span of the main rectangles
    top_row = y
    bottom_row = y + main_height - 1

    while L <= R:
        # Left shadow band
        left_end = min(L + left_thick - 1, R)
        for rr in range(top_row, bottom_row + 1):
            for cc in range(L, left_end + 1):
                output_grid[rr][cc] = left_nst
        L = left_end + 1
        if L > R:
            break
        # Right shadow band
        right_start = max(R - right_thick + 1, L)
        for rr in range(top_row, bottom_row + 1):
            for cc in range(right_start, R + 1):
                output_grid[rr][cc] = right_nst
        R = right_start - 1

    return {
        "input": input_grid,
        "output": output_grid
    }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to a mutable list of lists
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])

    from collections import Counter
    all_colors = [c for row in grid_in for c in row]
    bkg = Counter(all_colors).most_common(1)[0][0]

    # Find connected components (4-connected) of non-background colors
    visited = [[False] * width for _ in range(height)]
    components = []  # list of dicts: {'color': c, 'cells': [(r,c), ...]}

    for r in range(height):
        for c in range(width):
            if visited[r][c] or grid_in[r][c] == bkg:
                continue
            color = grid_in[r][c]
            stack = [(r, c)]
            visited[r][c] = True
            cells = []
            while stack:
                rr, cc = stack.pop()
                cells.append((rr, cc))
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid_in[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            components.append({'color': color, 'cells': cells})

    # Classify components into filled rectangles (nested) and outline rectangles (main borders)
    filled_rects = []
    outline_rects = []

    for comp in components:
        color = comp['color']
        cells = comp['cells']
        rs = [p[0] for p in cells]
        cs = [p[1] for p in cells]
        r0, r1 = min(rs), max(rs)
        c0, c1 = min(cs), max(cs)
        h = r1 - r0 + 1
        w = c1 - c0 + 1

        # Check for filled rectangle
        if len(cells) == h * w:
            filled_rects.append({'r0': r0, 'r1': r1, 'c0': c0, 'c1': c1, 'color': color})
            continue

        # Check for outline rectangle (thin border)
        expected_outline = 2 * h + 2 * w - 4
        if len(cells) == expected_outline:
            ok = True
            for rr in range(r0, r1 + 1):
                for cc in range(c0, c1 + 1):
                    on_border = (rr == r0 or rr == r1 or cc == c0 or cc == c1)
                    if on_border:
                        if grid_in[rr][cc] != color:
                            ok = False
                            break
                    else:
                        if grid_in[rr][cc] == color:
                            ok = False
                            break
                if not ok:
                    break
            if ok:
                outline_rects.append({'r0': r0, 'r1': r1, 'c0': c0, 'c1': c1, 'color': color})

    # Need at least two outline rectangles
    if len(outline_rects) < 2:
        # If detection fails, return input unchanged (safe fallback)
        return [row[:] for row in grid_in]

    # Choose the two largest outline rectangles (robust against extra artifacts) and sort by horizontal position
    outline_rects_sorted = sorted(outline_rects, key=lambda x: (-(x['r1'] - x['r0'] + 1) * (x['c1'] - x['c0'] + 1)))
    main_two = outline_rects_sorted[:2]
    main_two = sorted(main_two, key=lambda x: x['c0'])
    left_br, right_br = main_two[0], main_two[1]

    # Find nested (filled) rectangle inside each main border
    def find_nested_for(border):
        candidates = []
        for fr in filled_rects:
            if fr['r0'] >= border['r0'] and fr['r1'] <= border['r1'] and fr['c0'] >= border['c0'] and fr['c1'] <= border['c1']:
                candidates.append(fr)
        if not candidates:
            return None
        # Prefer the largest filled rectangle inside the border
        return max(candidates, key=lambda x: (x['r1'] - x['r0'] + 1) * (x['c1'] - x['c0'] + 1))

    left_nested = find_nested_for(left_br)
    right_nested = find_nested_for(right_br)
    if left_nested is None or right_nested is None:
        return [row[:] for row in grid_in]

    left_color = left_nested['color']
    right_color = right_nested['color']
    left_thick = left_nested['c1'] - left_nested['c0'] + 1
    right_thick = right_nested['c1'] - right_nested['c0'] + 1

    # Mask horizontal bounds
    mask_start = left_br['c1'] + 1
    mask_end = right_br['c0'] - 1
    if mask_start > mask_end:
        return [row[:] for row in grid_in]

    # Vertical span for shadows: overlap of the two main rectangles
    top_row = max(left_br['r0'], right_br['r0'])
    bottom_row = min(left_br['r1'], right_br['r1'])

    output = [row[:] for row in grid_in]

    L = mask_start
    R = mask_end
    while L <= R:
        # Left band
        left_end = min(L + left_thick - 1, R)
        for rr in range(top_row, bottom_row + 1):
            for cc in range(L, left_end + 1):
                output[rr][cc] = left_color
        L = left_end + 1
        if L > R:
            break
        # Right band
        right_start = max(R - right_thick + 1, L)
        for rr in range(top_row, bottom_row + 1):
            for cc in range(right_start, R + 1):
                output[rr][cc] = right_color
        R = right_start - 1

    return output

