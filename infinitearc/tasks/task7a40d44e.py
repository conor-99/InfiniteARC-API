# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 7a40d44e
Difficulty: medium–hard

=== Tags ===
- Rotational pattern mapping
- Multi object alignment
- Draw line from point
- Replace pattern

=== Description ===
**Task Name**: Rotational Alignment Network    **Description**:    Input grids
contain multiple distinct, non-overlapping colored patterns (each occupying a
3×3 or 4×4 subgrid) scattered across the grid. Each pattern is a simple
geometric shape (e.g., triangle, arrow, or cross) oriented in one of four
cardinal directions (up, down, left, right), with the shape’s orientation
visually encoded by the pattern itself (e.g., a triangle pointing right uses a
right-facing arrow design). The color of each pattern is unique and corresponds
to a specific rotation rule:    - **Red patterns**: Rotate 90° clockwise.   -
**Blue patterns**: Rotate 180°.   - **Green patterns**: Rotate 270° clockwise.
- **Yellow patterns**: Remain unrotated (0°).    In the output grid:    1.
**Rotate each pattern** according to its color’s rule, preserving its color.
2. **Align all rotated patterns** such that their top-left corners form a
horizontal line (if rotated by 90° or 270°) or vertical line (if rotated by 180°
or 0°).   3. **Replace each pattern** with a straight line segment connecting
its new position to the position of the next pattern in the alignment order
(e.g., left-to-right for horizontal alignment), using a line color derived from
the rotation angle:      - 90° rotation → **green line**.      - 180° rotation →
**blue line**.      - 270° rotation → **red line**.      - 0° rotation →
**yellow line**.   4. **Background cells** remain unchanged, and all original
patterns are removed.    The alignment order is determined by the original
leftmost-to-rightmost (horizontal) or top-to-bottom (vertical) positions of the
patterns before rotation. The output grid must maintain all non-pattern elements
(e.g., background colors, unmodified grid edges) and only replace patterns with
lines. No patterns overlap in the input, and all rotations preserve the
pattern’s internal structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, randint

# Helper functions to create and rotate matrices

def rotate_cw(mat):
    h = len(mat)
    w = len(mat[0])
    return [[mat[h - 1 - r][c] for r in range(h)] for c in range(w)]

def rotate_180(mat):
    return [row[::-1] for row in mat[::-1]]

def rotate_ccw(mat):
    h = len(mat)
    w = len(mat[0])
    return [[mat[r][w - 1 - c] for r in range(h)] for c in range(w)][::-1]


def make_right_triangle(s):
    # right-pointing triangular shape that touches all rows and columns of sxs box
    mat = [[0 for _ in range(s)] for _ in range(s)]
    for i in range(s):
        for j in range(s):
            if j >= i:
                mat[i][j] = 1
    return mat


def shape_oriented(s, orientation):
    # orientation in {'right','down','left','up'}
    base = make_right_triangle(s)
    if orientation == 'right':
        return base
    if orientation == 'down':
        return rotate_cw(base)
    if orientation == 'left':
        return rotate_180(base)
    if orientation == 'up':
        return rotate_ccw(base)
    return base


def place_shape_ok(grid_in, shape, r0, c0):
    h = len(grid_in)
    w = len(grid_in[0])
    s = len(shape)
    # Ensure shape fits
    if r0 < 0 or c0 < 0 or r0 + s > h or c0 + s > w:
        return False
    # Ensure no overlap and at least one-cell separation (no 4-neighbor touching)
    for i in range(s):
        for j in range(s):
            if shape[i][j] == 0:
                continue
            rr = r0 + i
            cc = c0 + j
            if grid_in[rr][cc] != 0:
                return False
            # check 4-neighbors of target cell (to avoid adjacency merging components)
            for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)]:
                nr, nc = rr + dr, cc + dc
                if 0 <= nr < h and 0 <= nc < w and grid_in[nr][nc] != 0:
                    return False
    return True


def draw_line_on_grid(g, r1, c1, r2, c2, color):
    # draw inclusive straight line (either horizontal or vertical)
    if r1 == r2:
        r = r1
        cstart = min(c1, c2)
        cend = max(c1, c2)
        for c in range(cstart, cend + 1):
            g[r][c] = color
    elif c1 == c2:
        c = c1
        rstart = min(r1, r2)
        rend = max(r1, r2)
        for r in range(rstart, rend + 1):
            g[r][c] = color
    else:
        # In case of diagonal, draw stepwise (shouldn't happen with our alignment)
        steps = max(abs(r2 - r1), abs(c2 - c1))
        for step in range(steps + 1):
            r = r1 + int(round(step * (r2 - r1) / steps))
            c = c1 + int(round(step * (c2 - c1) / steps))
            g[r][c] = color


def generate():
    # grid size
    size = randint(15, 30)
    input_grid = grid(size, size, 0)
    output_grid = grid(size, size, 0)

    # Decide number of patterns (2..4 to ensure alignment fits)
    num_patterns = randint(2, 4)

    sizes = [3, 4]
    orientations = ['right', 'down', 'left', 'up']

    # Unique colors among patterns chosen from the rotation-color set {1,2,3,4}
    available_colors = [1, 2, 3, 4]
    colors = random.sample(available_colors, num_patterns)

    patterns = []  # list of dicts: {r,c,s,color,orientation,shape}

    attempts = 0
    for color in colors:
        placed = False
        for _ in range(200):
            attempts += 1
            s = random.choice(sizes)
            orientation = random.choice(orientations)
            shape = shape_oriented(s, orientation)
            r0 = randint(0, size - s)
            c0 = randint(0, size - s)
            if place_shape_ok(input_grid, shape, r0, c0):
                # place
                for i in range(s):
                    for j in range(s):
                        if shape[i][j]:
                            input_grid[r0 + i][c0 + j] = color
                patterns.append({'r': r0, 'c': c0, 's': s, 'color': color, 'shape': shape})
                placed = True
                break
        if not placed:
            # couldn't place this color after many tries; reduce num_patterns
            break

    # Ensure at least two patterns placed (the solver expects multiple lines)
    if len(patterns) < 2:
        # fallback: try again with smaller num_patterns until 2 placed
        return generate()

    # Copy input to output and remove pattern pixels (replace patterns with background)
    output_grid = [row[:] for row in input_grid]
    for pat in patterns:
        r0, c0, s, color, shape = pat['r'], pat['c'], pat['s'], pat['color'], pat['shape']
        for i in range(s):
            for j in range(s):
                if shape[i][j]:
                    output_grid[r0 + i][c0 + j] = 0

    # Rotation mapping: color -> angle
    color_to_angle = {2: 90, 1: 180, 3: 270, 4: 0}
    # Line color mapping: rotation angle (as defined by color) -> output line color
    line_color_map = {2: 3, 1: 1, 3: 2, 4: 4}

    # Split into groups
    horiz_group = []  # patterns rotated 90 or 270
    vert_group = []   # patterns rotated 0 or 180
    for pat in patterns:
        angle = color_to_angle[pat['color']]
        if angle in (90, 270):
            horiz_group.append(pat)
        else:
            vert_group.append(pat)

    # Helper to compute aligned positions for a group
    def compute_aligned_positions(group, horizontal):
        if not group:
            return []
        # For ordering, use original left-to-right for horizontal group, top-to-bottom for vertical group
        if horizontal:
            group_sorted = sorted(group, key=lambda p: (p['c'], p['r']))
        else:
            group_sorted = sorted(group, key=lambda p: (p['r'], p['c']))

        if horizontal:
            total_width = sum(p['s'] for p in group_sorted) + max(0, len(group_sorted) - 1)
            # anchor column: try to use leftmost original column but clamp so it fits
            anchor_col = min(p['c'] for p in group_sorted)
            anchor_col = max(0, min(anchor_col, size - total_width))
            anchor_row = min(p['r'] for p in group_sorted)
            pos_list = []
            col = anchor_col
            for p in group_sorted:
                pos_list.append((anchor_row, col, p))
                col += p['s'] + 1
            return pos_list
        else:
            total_height = sum(p['s'] for p in group_sorted) + max(0, len(group_sorted) - 1)
            anchor_row = min(p['r'] for p in group_sorted)
            anchor_row = max(0, min(anchor_row, size - total_height))
            anchor_col = min(p['c'] for p in group_sorted)
            pos_list = []
            row = anchor_row
            for p in group_sorted:
                pos_list.append((row, anchor_col, p))
                row += p['s'] + 1
            return pos_list

    horiz_positions = compute_aligned_positions(horiz_group, horizontal=True)
    vert_positions = compute_aligned_positions(vert_group, horizontal=False)

    # Draw lines: for each group, connect each pattern to next in group order
    for group_positions in (horiz_positions, vert_positions):
        for i in range(len(group_positions) - 1):
            r1, c1, p1 = group_positions[i]
            r2, c2, p2 = group_positions[i + 1]
            # line color derived from p1 rotation color
            color = line_color_map[p1['color']]
            draw_line_on_grid(output_grid, r1, c1, r2, c2, color)

    return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from typing import List, Tuple
from common import grid

# Helper functions (mirror those in generator so behavior is identical)

def rotate_cw(mat):
    h = len(mat)
    w = len(mat[0])
    return [[mat[h - 1 - r][c] for r in range(h)] for c in range(w)]


def rotate_180(mat):
    return [row[::-1] for row in mat[::-1]]


def rotate_ccw(mat):
    h = len(mat)
    w = len(mat[0])
    return [[mat[r][w - 1 - c] for r in range(h)] for c in range(w)][::-1]


def make_right_triangle(s):
    mat = [[0 for _ in range(s)] for _ in range(s)]
    for i in range(s):
        for j in range(s):
            if j >= i:
                mat[i][j] = 1
    return mat


def shape_oriented(s, orientation):
    base = make_right_triangle(s)
    if orientation == 'right':
        return base
    if orientation == 'down':
        return rotate_cw(base)
    if orientation == 'left':
        return rotate_180(base)
    if orientation == 'up':
        return rotate_ccw(base)
    return base


def draw_line_on_grid(g, r1, c1, r2, c2, color):
    if r1 == r2:
        r = r1
        cstart = min(c1, c2)
        cend = max(c1, c2)
        for c in range(cstart, cend + 1):
            g[r][c] = color
    elif c1 == c2:
        c = c1
        rstart = min(r1, r2)
        rend = max(r1, r2)
        for r in range(rstart, rend + 1):
            g[r][c] = color
    else:
        steps = max(abs(r2 - r1), abs(c2 - c1))
        for step in range(steps + 1):
            r = r1 + int(round(step * (r2 - r1) / steps))
            c = c1 + int(round(step * (c2 - c1) / steps))
            g[r][c] = color


def p(input_grid: Tuple[Tuple[int, ...], ...]) -> Tuple[Tuple[int, ...], ...]:
    # Convert to mutable list
    grid_in = [list(row) for row in input_grid]
    h = len(grid_in)
    w = len(grid_in[0]) if h > 0 else 0
    output_grid = [row[:] for row in grid_in]

    # Find connected components of non-zero cells (4-neighbor)
    visited = [[0] * w for _ in range(h)]
    components = []  # list of list of (r,c)
    for r in range(h):
        for c in range(w):
            if grid_in[r][c] == 0 or visited[r][c]:
                continue
            color = grid_in[r][c]
            # BFS
            stack = [(r, c)]
            comp = []
            visited[r][c] = 1
            while stack:
                rr, cc = stack.pop()
                comp.append((rr, cc))
                for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)]:
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid_in[nr][nc] == color:
                        visited[nr][nc] = 1
                        stack.append((nr, nc))
            components.append((comp, color))

    # For each component compute bounding box and accept if size 3 or 4
    patterns = []
    for comp, color in components:
        rows = [p[0] for p in comp]
        cols = [p[1] for p in comp]
        r0 = min(rows)
        r1 = max(rows)
        c0 = min(cols)
        c1 = max(cols)
        height = r1 - r0 + 1
        width = c1 - c0 + 1
        s = max(height, width)
        if s not in (3, 4):
            continue
        # verify that the component fits within an s x s box and looks like pattern
        # (i.e., at least one cell in every row and column)
        ok = True
        for rr in range(r0, r0 + s):
            found = False
            for cc in range(c0, c0 + s):
                if 0 <= rr < h and 0 <= cc < w and grid_in[rr][cc] == color:
                    found = True
                    break
            if not found:
                ok = False
                break
        for cc in range(c0, c0 + s):
            found = False
            for rr in range(r0, r0 + s):
                if 0 <= rr < h and 0 <= cc < w and grid_in[rr][cc] == color:
                    found = True
                    break
            if not found:
                ok = False
                break
        if not ok:
            continue
        # record the pattern (use top-left bounding box cell as its reference)
        patterns.append({'r': r0, 'c': c0, 's': s, 'color': color})

    if not patterns:
        return tuple(tuple(row) for row in output_grid)

    # Remove original pattern pixels from output (exactly the colored cells)
    for pat in patterns:
        r0, c0, s, color = pat['r'], pat['c'], pat['s'], pat['color']
        for rr in range(r0, r0 + s):
            for cc in range(c0, c0 + s):
                if 0 <= rr < h and 0 <= cc < w and grid_in[rr][cc] == color:
                    output_grid[rr][cc] = 0

    # Rotation and line color mappings (must match generator)
    color_to_angle = {2: 90, 1: 180, 3: 270, 4: 0}
    line_color_map = {2: 3, 1: 1, 3: 2, 4: 4}

    horiz_group = []
    vert_group = []
    for pat in patterns:
        angle = color_to_angle.get(pat['color'], 0)
        if angle in (90, 270):
            horiz_group.append(pat)
        else:
            vert_group.append(pat)

    def compute_aligned_positions(group, horizontal):
        if not group:
            return []
        if horizontal:
            group_sorted = sorted(group, key=lambda p: (p['c'], p['r']))
        else:
            group_sorted = sorted(group, key=lambda p: (p['r'], p['c']))
        if horizontal:
            total_width = sum(p['s'] for p in group_sorted) + max(0, len(group_sorted) - 1)
            anchor_col = min(p['c'] for p in group_sorted)
            anchor_col = max(0, min(anchor_col, w - total_width))
            anchor_row = min(p['r'] for p in group_sorted)
            pos_list = []
            col = anchor_col
            for p in group_sorted:
                pos_list.append((anchor_row, col, p))
                col += p['s'] + 1
            return pos_list
        else:
            total_height = sum(p['s'] for p in group_sorted) + max(0, len(group_sorted) - 1)
            anchor_row = min(p['r'] for p in group_sorted)
            anchor_row = max(0, min(anchor_row, h - total_height))
            anchor_col = min(p['c'] for p in group_sorted)
            pos_list = []
            row = anchor_row
            for p in group_sorted:
                pos_list.append((row, anchor_col, p))
                row += p['s'] + 1
            return pos_list

    horiz_positions = compute_aligned_positions(horiz_group, True)
    vert_positions = compute_aligned_positions(vert_group, False)

    # Draw lines for each group
    for group_positions in (horiz_positions, vert_positions):
        for i in range(len(group_positions) - 1):
            r1, c1, p1 = group_positions[i]
            r2, c2, p2 = group_positions[i + 1]
            color = line_color_map[p1['color']]
            draw_line_on_grid(output_grid, r1, c1, r2, c2, color)

    return tuple(tuple(row) for row in output_grid)

