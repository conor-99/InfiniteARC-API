# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 189aec9c
Difficulty: medium

=== Tags ===
- Sort colors by index
- Image rotation
- Rotate to canonical
- Close line gaps

=== Description ===
The task involves transforming an input grid into an output grid through a
sequence of consistent, deterministic operations. The input grids contain a
primary line (a sequence of connected non-zero pixels) that is rotated at an
arbitrary angle. The transformation requires:  1. **Image rotation**: Rotate the
grid to a canonical orientation (e.g., 90° clockwise, 180°, or 270°) such that
the primary line becomes horizontal. The canonical orientation is determined by
aligning the longest continuous line (with the most non-zero pixels) to run
horizontally.  2. **Sort colors by index**: Once the line is horizontal, sort
the colors along this line in ascending numerical order (e.g., 1, 2, 3, ...).
The sorting is based on the color values, not their positions in the grid.  3.
**Close line gaps**: After sorting, any gaps (cells with value 0) within the
horizontal line are filled with the correct color from the sorted sequence to
ensure the line is continuous. For example, if the sorted sequence is [2, 3, 5]
and the input line has a gap (0) at position 1, the gap is filled with 3 to form
[2, 3, 5].  The output grid reflects these operations: the rotated grid with the
horizontal line sorted numerically and all gaps closed. The transformation is
applied uniformly to all input grids, regardless of the initial line orientation
or the specific color values, relying solely on the rules of rotation, numerical
sorting, and gap closure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, transpose, flip_horiz

def generate():
    width = random.randint(1, 30)
    height = random.randint(2, 30)  # Ensure height ≥ 2 to avoid infinite loop
    col = random.randint(0, width-1)
    while True:
        colors = [random.randint(1, 9) for _ in range(height)]
        if sorted(colors) != colors:
            break
    input_grid = grid(width, height, 0)
    for r in range(height):
        input_grid[r][col] = colors[r]
    rotated = transpose(input_grid)
    rotated = flip_horiz(rotated)
    line_row = None
    for r in range(len(rotated)):
        if any(rotated[r][c] != 0 for c in range(len(rotated[0]))):
            line_row = r
            break
    if line_row is None:
        line_row = 0
    sorted_colors = sorted(colors)
    output_grid = rotated
    output_grid[line_row] = sorted_colors
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import transpose, flip_horiz

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    visited = [[False] * width for _ in range(height)]
    components = []
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and input_grid[r][c] != 0:
                stack = [(r, c)]
                component = []
                visited[r][c] = True
                while stack:
                    r_cur, c_cur = stack.pop()
                    component.append((r_cur, c_cur))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = r_cur + dr, c_cur + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] != 0:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append(component)
    
    primary_line = max(components, key=len)
    colors = [input_grid[r][c] for (r, c) in primary_line]
    sorted_colors = sorted(colors)
    
    col = primary_line[0][1]
    if all(c == col for (r, c) in primary_line):
        rotated = transpose(input_grid)
        rotated = flip_horiz(rotated)
    else:
        rotated = input_grid
    
    max_nonzero = 0
    line_row = 0
    for r in range(len(rotated)):
        count = sum(1 for c in range(len(rotated[0])) if rotated[r][c] != 0)
        if count > max_nonzero:
            max_nonzero = count
            line_row = r
    
    rotated[line_row] = sorted_colors
    return rotated
