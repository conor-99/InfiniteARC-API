# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: dd3eb96c
Difficulty: hard

=== Tags ===
- Fluid spread
- Add frame
- Associate colors to colors

=== Description ===
Input grids feature a background color (0) overlaid with multiple distinct
foreground color regions (1-9). Each color in the grid has a fixed, predefined
association to another color (e.g., color 2 associates with color 7, color 5
associates with color 4), forming a consistent mapping across all grids. The
transformation requires two sequential operations:  1. **Fluid Spread**: For
every foreground cell of color C, its associated color D is propagated to all
directly adjacent background cells (up, down, left, right). If a background cell
is adjacent to multiple foreground cells, the propagation uses the highest-value
color (numerically) among those adjacent cells to determine D. This creates a
diffusion-like effect where colors "spread" through background areas while
respecting the color association hierarchy.  2. **Frame Addition**: After the
fluid spread, a one-cell-thick border frame is added around the entire grid (all
outermost cells), colored with the association of the background color (0). This
frame overrides any existing border colors and appears as a distinct, unchanging
border in all outputs.  The output grid is generated by first applying the fluid
spread to the input grid (only modifying background cells), then adding the
frame. The fluid spread never alters non-background cells, and the frame
addition is applied uniformly regardless of input border content. This task
demands recognition of the color association mapping, correct handling of
overlapping spread priorities, and precise sequential application of both rules
to produce the output. The complexity arises from the interplay between dynamic
color propagation and the fixed frame addition, requiring users to
simultaneously track multiple spatial and relational transformations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

# Deterministic, fixed color association used by both generator and solver.
# Maps each color 0..9 to a color in 1..9 (never 0) so the added frame is visible.
COLOR_MAPPING = {i: ((i * 7 + 3) % 9) + 1 for i in range(10)}

# Keep a record of pairs already produced so we return unique pairs across calls.
_seen_pairs = set()


def generate():
    """
    Generate one input/output pair following the task specification.

    Rules implemented:
    - Start from a background (0) grid and sprinkle several colored regions (1-9).
    - Fluid spread: for each background cell, if it has any non-zero orthogonal
      neighbor(s), pick the highest-value neighbor color C and set the cell to
      COLOR_MAPPING[C]. (All background cells are updated simultaneously.)
    - Frame addition: overwrite the entire outermost ring with COLOR_MAPPING[0].

    Returns: dict with keys 'input' and 'output' where each value is a 2D list of ints.
    """
    global _seen_pairs

    attempts = 0
    while True:
        attempts += 1
        # Choose a moderate grid size so there is room for regions and spread.
        w = random.randint(3, 12)
        h = random.randint(3, 12)

        # Number of distinct regions (colors) to place.
        max_regions = min(6, max(1, (w * h) // 6))
        num_regions = random.randint(1, max_regions)

        # Start with all background
        inp = [[0 for _ in range(w)] for _ in range(h)]

        # Place a few connected regions. Use unique colors for regions to encourage
        # multi-color interactions.
        colors = random.sample(range(1, 10), num_regions)
        for color in colors:
            size = random.randint(1, max(1, (w * h) // 10))
            # seed position
            r0 = random.randrange(h)
            c0 = random.randrange(w)
            tiles = {(r0, c0)}
            frontier = [(r0, c0)]
            # Grow region by random walk / frontier expansion until desired size
            while len(tiles) < size and frontier:
                rr, cc = random.choice(frontier)
                dr, dc = random.choice([(1, 0), (-1, 0), (0, 1), (0, -1)])
                nr, nc = rr + dr, cc + dc
                if 0 <= nr < h and 0 <= nc < w and (nr, nc) not in tiles:
                    tiles.add((nr, nc))
                    frontier.append((nr, nc))
                # Occasionally remove from frontier so shapes don't grow in simple lines
                if random.random() < 0.25:
                    try:
                        frontier.remove((rr, cc))
                    except ValueError:
                        pass
            for (rr, cc) in tiles:
                inp[rr][cc] = color

        # Ensure there is some background left to be affected by the spread
        if all(inp[r][c] != 0 for r in range(h) for c in range(w)):
            # clear a few random cells to create background
            for _ in range(max(1, (w * h) // 6)):
                inp[random.randrange(h)][random.randrange(w)] = 0

        # Apply fluid spread (single synchronous pass based on original inp)
        after_spread = [row[:] for row in inp]
        for r in range(h):
            for c in range(w):
                if inp[r][c] == 0:
                    max_neighbor = -1
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < h and 0 <= nc < w:
                            neigh = inp[nr][nc]
                            if neigh != 0 and neigh > max_neighbor:
                                max_neighbor = neigh
                    if max_neighbor != -1:
                        after_spread[r][c] = COLOR_MAPPING[max_neighbor]

        # Add one-cell-thick frame using the association for background color (0)
        final = [row[:] for row in after_spread]
        frame_color = COLOR_MAPPING[0]
        for r in range(h):
            for c in range(w):
                if r == 0 or r == h - 1 or c == 0 or c == w - 1:
                    final[r][c] = frame_color

        # Avoid returning identical input/output pairs and ensure global uniqueness
        if inp == final:
            # If nothing changed, try again
            if attempts > 2000:
                # extremely unlikely; fall back to a guaranteed simple change
                final[0][0] = COLOR_MAPPING[0]
            else:
                continue

        key = (tuple(tuple(row) for row in inp), tuple(tuple(row) for row in final))
        if key in _seen_pairs:
            # Already produced; try again
            continue
        _seen_pairs.add(key)
        return {"input": inp, "output": final}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------


# Solver that implements the same deterministic mapping and transformation as the generator.

COLOR_MAPPING = {i: ((i * 7 + 3) % 9) + 1 for i in range(10)}

def p(input_grid):
    """
    Compute the expected output grid for a given input grid.

    Steps:
    - For every background cell (0) look at orthogonal neighbors in the original input.
      If there are any non-zero neighbors, pick the highest neighbor color C and set the
      cell to COLOR_MAPPING[C]. This is a single synchronous pass (do not let newly
      filled cells participate in further spreading).
    - After that pass, overwrite the outermost border of the grid with COLOR_MAPPING[0].

    Returns a tuple-of-tuples grid (immutable) as required by the validator.
    """
    # Convert to mutable lists
    grid_in = [list(row) for row in input_grid]
    h = len(grid_in)
    w = len(grid_in[0]) if h > 0 else 0

    # Start with a copy of the input for output; only background cells will change in spread
    out = [row[:] for row in grid_in]

    # Single synchronous spread pass based on the original input
    for r in range(h):
        for c in range(w):
            if grid_in[r][c] == 0:
                max_neighbor = -1
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < h and 0 <= nc < w:
                        neigh = grid_in[nr][nc]
                        if neigh != 0 and neigh > max_neighbor:
                            max_neighbor = neigh
                if max_neighbor != -1:
                    out[r][c] = COLOR_MAPPING[max_neighbor]

    # Frame addition (overwrite border cells)
    frame_color = COLOR_MAPPING[0]
    for r in range(h):
        for c in range(w):
            if r == 0 or r == h - 1 or c == 0 or c == w - 1:
                out[r][c] = frame_color

    # Return immutable structure
    return tuple(tuple(row) for row in out)

