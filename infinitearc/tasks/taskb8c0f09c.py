# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: b8c0f09c
Difficulty: insane

=== Tags ===
- Goal conditioned path
- Shape extrusion

=== Description ===
Input grids are large (20×20 or larger) with a single background color (0).
Scattered across the grid are multiple distinct shapes, each represented as a
connected region of a single non-background color (1–9). Each shape has a clear
extrusion direction encoded by its geometric orientation: horizontal lines
extrude left/right, vertical lines extrude up/down, and L-shaped or T-shaped
configurations extrude along their primary axis. The grid also contains a start
cell (color S, typically 1) positioned on the left edge (column 0) and a goal
cell (color G, typically 2) positioned on the right edge (column max).   The
output grid must draw a continuous path from the start to the goal. The path
begins moving rightward and follows background cells (color 0) until it collides
with a shape. Upon collision, the path turns to follow the shape's extrusion
direction (e.g., hitting a horizontal shape causes the path to turn vertically,
with the direction determined by the shape's orientation relative to the path's
incoming direction). The path's color cycles sequentially through a predefined
sequence (e.g., 1→2→3→1) with each step. Crucially, the extrusion direction of
each shape is **goal-conditioned**: the shape's orientation is designed such
that following its extrusion direction leads the path toward the goal, requiring
the solver to recognize the geometric alignment between shapes and the goal's
position. Shapes remain fully visible in the output, and the path never overlaps
with shapes, the start, or goal. The complexity arises from navigating multiple
shapes with varying extrusion directions while maintaining the cyclic color
progression, all while ensuring the path converges to the goal without loops or
dead ends.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    # Grid size (large as requested)
    size = random.randint(20, 25)
    inp = common.grid(size, size, 0)

    # Place start (color 1) on left edge and goal (color 2) on right edge
    start_row = random.randint(1, size - 2)
    goal_row = random.randint(1, size - 2)
    # avoid trivial identical rows most of the time
    if random.random() < 0.8:
        tries = 0
        while goal_row == start_row and tries < 10:
            goal_row = random.randint(1, size - 2)
            tries += 1

    inp[start_row][0] = 1
    inp[goal_row][size - 1] = 2

    # Build a path (kept only in memory for output drawing)
    path = [(start_row, 0)]
    cur_row = start_row
    cur_col = 0

    # Choose obstacle columns (vertical walls) spaced apart
    pool = list(range(2, size - 2))
    max_obst = min(6, max(3, len(pool) // 3))
    n_obst = random.randint(3, max_obst)

    min_gap = 2
    tries = 0
    while True:
        cols = sorted(random.sample(pool, n_obst))
        if all(cols[i + 1] - cols[i] >= min_gap for i in range(len(cols) - 1)):
            break
        tries += 1
        if tries > 200:
            # fallback to an evenly spaced selection
            step = max(2, len(pool) // n_obst)
            cols = [pool[0] + i * step for i in range(n_obst)]
            cols = [c for c in cols if c < size - 2]
            cols = cols[:n_obst]
            break

    # Shape colors (avoid using 1 or 2; avoid path color choice)
    shape_colors = [6, 7, 8, 9]
    sc_idx = 0

    for c in cols:
        # Move horizontally until the column just before the obstacle
        for cc in range(cur_col + 1, c):
            path.append((cur_row, cc))
        # update the column where the path currently is (just before obstacle)
        cur_col = c - 1

        # We expect a collision at (cur_row, c). Choose a gap (background cell) in that column.
        if goal_row == cur_row:
            prefer_dir = random.choice([-1, 1])
        else:
            prefer_dir = 1 if goal_row > cur_row else -1

        if prefer_dir == 1:
            candidates = [r for r in range(cur_row + 1, size - 1)]
        else:
            candidates = [r for r in range(1, cur_row)]

        # Prefer gaps that move the path toward the goal (reduce vertical distance)
        candidates_toward = [r for r in candidates if abs(r - goal_row) <= abs(cur_row - goal_row)]
        if candidates_toward:
            g = random.choice(candidates_toward)
        elif candidates:
            g = random.choice(candidates)
        else:
            # fallback
            g = 1 if cur_row != 1 else size - 2

        # Build a vertical wall (two connected segments) at column c with a single gap at row g.
        top_color = shape_colors[sc_idx % len(shape_colors)]; sc_idx += 1
        bottom_color = shape_colors[sc_idx % len(shape_colors)]; sc_idx += 1

        # top segment rows (1 .. g-1)
        for r in range(1, g):
            inp[r][c] = top_color
        # bottom segment rows (g+1 .. size-2)
        for r in range(g + 1, size - 1):
            inp[r][c] = bottom_color

        # Move vertically along the column just before the obstacle (cur_col) from cur_row toward g
        if g != cur_row:
            step = 1 if g > cur_row else -1
            for rr in range(cur_row + step, g + step, step):
                path.append((rr, cur_col))

        # Step into the gap at (g, c)
        path.append((g, c))
        cur_row = g
        cur_col = c

    # Final horizontal run to the column immediately left of the goal (size-2)
    for cc in range(cur_col + 1, size - 1):
        path.append((cur_row, cc))

    # Build the output: copy input and paint the path (do not overwrite shapes/start/goal)
    out = [row[:] for row in inp]
    color_seq = [3, 4, 5]
    for idx, (r, c) in enumerate(path[1:]):
        if out[r][c] == 0:
            out[r][c] = color_seq[idx % len(color_seq)]

    return {"input": inp, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to a mutable grid
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])

    # Find start (color 1) and goal (color 2)
    start = None
    for r in range(h):
        if grid[r][0] == 1:
            start = (r, 0)
            break
    if start is None:
        raise ValueError("Start cell with color 1 not found on left edge")
    goal = None
    for r in range(h):
        if grid[r][w - 1] == 2:
            goal = (r, w - 1)
            break
    if goal is None:
        raise ValueError("Goal cell with color 2 not found on right edge")

    cur_r, cur_c = start
    goal_r = goal[0]
    path = [(cur_r, cur_c)]

    color_seq = [3, 4, 5]

    # Simulate the same navigation strategy used by the generator:
    # advance right until blocked, then move vertically along our current column to a gap in the obstacle column
    steps_limit = 10000
    steps = 0
    while cur_c < w - 1 and steps < steps_limit:
        steps += 1
        # stop if we are immediately left of the goal
        if cur_c == w - 2:
            break

        nx_r = cur_r
        nx_c = cur_c + 1
        # If next cell is free background, step right
        if grid[nx_r][nx_c] == 0:
            cur_c = nx_c
            path.append((cur_r, cur_c))
            continue

        # Next cell is an obstacle (non-zero and not the goal). Find the gap row in column nx_c.
        gap_rows = [r for r in range(1, h - 1) if grid[r][nx_c] == 0]
        # Filter gap rows that are reachable by moving along column cur_c
        candidates = []
        for r in gap_rows:
            clear = True
            lo = min(cur_r, r)
            hi = max(cur_r, r)
            for rr in range(lo, hi + 1):
                if grid[rr][cur_c] != 0:
                    clear = False
                    break
            if clear:
                candidates.append(r)

        if not candidates and gap_rows:
            # If none reachable in the immediate column, allow any gap row (shouldn't usually happen)
            candidates = gap_rows[:]
        if not candidates:
            # cannot resolve; break to avoid infinite loop
            break

        # Prefer a gap that moves toward the goal if available
        toward = [r for r in candidates if (r - cur_r) * (goal_r - cur_r) > 0]
        if toward:
            g = min(toward, key=lambda r: abs(r - cur_r))
        else:
            g = min(candidates, key=lambda r: abs(r - goal_r))

        # Move vertically along column cur_c to row g
        if g != cur_r:
            step = 1 if g > cur_r else -1
            for rr in range(cur_r + step, g + step, step):
                path.append((rr, cur_c))
        # Step into the gap at (g, nx_c)
        cur_r = g
        cur_c = nx_c
        path.append((cur_r, cur_c))

    # Ensure we reach the column immediately left of the goal (w-2)
    while cur_c < w - 2:
        cur_c += 1
        path.append((cur_r, cur_c))

    # Paint the path onto a copy of the input (do not overwrite shapes/start/goal)
    out = [row[:] for row in grid]
    for idx, (r, c) in enumerate(path[1:]):
        if out[r][c] == 0:
            out[r][c] = color_seq[idx % len(color_seq)]

    return out

