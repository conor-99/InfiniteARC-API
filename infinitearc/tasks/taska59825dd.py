# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: a59825dd
Difficulty: insane

=== Tags ===
- Pattern completion
- Dominant color

=== Description ===
The task involves transforming an input grid where a single connected shape
(composed of non-zero colors) encloses one or more zero-filled holes. The output
grid fills all enclosed holes with the dominant color of the input, which is the
most frequently occurring non-zero color (with ties broken by selecting the
smallest color value). The input grid features a complex, irregularly shaped
boundary with multiple internal voids, requiring careful visual analysis to
identify all enclosed regions. The dominant color is determined by counting all
non-zero pixels in the grid, making it a visual pattern completion task where
the solver must recognize the shape's structure, determine the dominant hue
through frequency analysis, and apply it to complete the enclosed spaces. The
complexity arises from the intricate boundary design, numerous small holes, and
the necessity to accurately count color frequencies to avoid misidentifying the
dominant color, especially in cases where colors are closely balanced in
frequency.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque
from common import hollow_conway, grid

def generate():
    w = random.randint(5, 30)
    h = random.randint(5, 30)
    rows, cols = hollow_conway(w, h)
    n = len(rows)
    dominant_color = random.randint(1, 9)
    input_grid = grid(w, h, 0)
    
    for i in range(n):
        r, c = rows[i], cols[i]
        if i < n * 7 // 10:
            input_grid[r][c] = dominant_color
        else:
            other_color = random.choice([c for c in range(1, 10) if c != dominant_color])
            input_grid[r][c] = other_color
    
    visited = [[False] * w for _ in range(h)]
    queue = deque()
    
    for r in range(h):
        for c in [0, w-1]:
            if input_grid[r][c] == 0 and not visited[r][c]:
                visited[r][c] = True
                queue.append((r, c))
    for c in range(w):
        for r in [0, h-1]:
            if input_grid[r][c] == 0 and not visited[r][c]:
                visited[r][c] = True
                queue.append((r, c))
    
    while queue:
        r, c = queue.popleft()
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and input_grid[nr][nc] == 0:
                visited[nr][nc] = True
                queue.append((nr, nc))
    
    output_grid = [row[:] for row in input_grid]
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] == 0 and not visited[r][c]:
                output_grid[r][c] = dominant_color
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    # Ensure input_grid is list of lists (not tuple)
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    h = len(input_grid)
    w = len(input_grid[0])
    colors = []
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] > 0:
                colors.append(input_grid[r][c])
    
    if not colors:
        return input_grid
    
    color_count = {}
    for color in colors:
        color_count[color] = color_count.get(color, 0) + 1
    max_count = max(color_count.values())
    dominant_color = min([color for color, count in color_count.items() if count == max_count])
    
    visited = [[False] * w for _ in range(h)]
    queue = deque()
    
    for r in range(h):
        for c in [0, w-1]:
            if input_grid[r][c] == 0 and not visited[r][c]:
                visited[r][c] = True
                queue.append((r, c))
    for c in range(w):
        for r in [0, h-1]:
            if input_grid[r][c] == 0 and not visited[r][c]:
                visited[r][c] = True
                queue.append((r, c))
    
    while queue:
        r, c = queue.popleft()
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and input_grid[nr][nc] == 0:
                visited[nr][nc] = True
                queue.append((nr, nc))
    
    output_grid = [row[:] for row in input_grid]
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] == 0 and not visited[r][c]:
                output_grid[r][c] = dominant_color
    
    return output_grid
