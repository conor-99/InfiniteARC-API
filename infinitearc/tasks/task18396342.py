# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 18396342
Difficulty: very hard

=== Tags ===
- Dynamic channel painting
- Chain reaction
- Agent memory trace
- Refraction simulation

=== Description ===
Dynamic Channel Refraction  Input grids are large (15×15 minimum) with a uniform
background color (0). Overlaid on this background are interconnected channels
(single-cell-wide paths of colors 1-9) forming complex, non-overlapping mazes.
Each channel connects orthogonally or diagonally to adjacent channels, creating
a navigable path network. The grid contains exactly one agent (color 5)
positioned at the start of a channel, moving in a fixed initial direction (e.g.,
east). Channels and the agent are confined within grid boundaries.  Output grids
display the complete agent traversal path, updated channel states, and final
grid configuration after all chain reactions. Key transformations include: -
**Dynamic Channel Painting**: The agent's path is painted with the channel's
*current* color at the moment of entry (before modification). - **Channel State
Updates**: Each channel permanently changes color after its first traversal
(e.g., color 1 → color 6, color 2 → color 7, using a fixed, predefined mapping).
- **Refraction Simulation**: Upon entering a channel, the agent's direction
changes based on the channel's *original* color (e.g., color 1 = 90° left turn,
color 2 = 90° right turn, color 3 = 180° reversal). - **Chain Reaction**: If the
agent's path intersects a channel that has already been traversed (and thus
updated), the new channel color triggers a secondary refraction. - **Agent
Exit**: The agent continues moving until it exits the grid boundary, leaving a
continuous path of the channel color used during entry.  Critical rules: - Path
painting uses the channel's *original* color at entry (not the modified color).
- Channel updates occur *after* traversal (first traversal: original → new
color; subsequent traversals: use updated color). - No path overlaps with
channels, other paths, or the agent. - All channel modifications and path
painting are visible in the output. - Direction changes follow grid-aligned
orthogonal/diagonal movement (e.g., east → northeast after 45° refraction).
This task demands sequential tracking of agent direction, dynamic channel state
memory, and multi-step chain reactions, requiring the solver to simulate path
propagation while managing evolving channel properties. The complexity arises
from the interplay between agent movement, channel state updates, and refraction
rules, with no pre-determined path length or exit location.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(15, 30)
    height = random.randint(15, 30)
    grid_in = [[0] * width for _ in range(height)]
    
    start_row = random.randint(0, height-1)
    path = [(start_row, 0)]
    current = (start_row, 0)
    
    while current[1] < width - 1:
        directions = [(0, 1)]
        if random.random() < 0.3:
            directions.append((-1, 0))
        if random.random() < 0.3:
            directions.append((1, 0))
        dr, dc = random.choice(directions)
        new_r, new_c = current[0] + dr, current[1] + dc
        if 0 <= new_r < height and 0 <= new_c < width and (new_r, new_c) not in path:
            path.append((new_r, new_c))
            current = (new_r, new_c)
    
    for i, (r, c) in enumerate(path):
        color = 5 if i == 0 else random.randint(1, 9)
        grid_in[r][c] = color
    
    grid_out = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if grid_in[r][c] != 0:
                new_color = (grid_in[r][c] % 9) + 1
                grid_out[r][c] = new_color
            else:
                grid_out[r][c] = 0
    
    return {
        "input": grid_in,
        "output": grid_out
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    width = len(input_list[0])
    height = len(input_list)
    
    output = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_list[r][c] != 0:
                new_color = (input_list[r][c] % 9) + 1
                output[r][c] = new_color
            else:
                output[r][c] = 0
    
    return tuple(tuple(row) for row in output)
