# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 8411f755
Difficulty: medium

=== Tags ===
- Associate images to patterns
- Bouncing
- Obstacles
- Image reflection

=== Description ===
The task involves transforming an input grid into an output grid where a
horizontal path of color 1 bounces off obstacles (color 5), reversing direction
at each obstacle. The input grid contains a path moving right, encountering
obstacles (color 5), and the output grid reflects the path's new direction after
bouncing. Obstacles remain unchanged in position, while the path continues in
the opposite direction immediately following each obstacle. For example, a path
moving right (1s) approaching an obstacle (5) results in the path moving left
(1s) starting from the cell adjacent to the obstacle in the output grid. This
transformation follows consistent reflection rules at obstacle points, requiring
recognition of path direction reversal upon obstacle contact.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
def generate():
    width = random.randint(5, 30)
    obstacle_col = random.randint(1, width - 2)
    left_count = random.randint(1, obstacle_col)
    
    input_row = [0] * width
    output_row = [0] * width
    
    # Fill input with 1s to the left of obstacle
    for i in range(obstacle_col - left_count, obstacle_col):
        input_row[i] = 1
    input_row[obstacle_col] = 5
    
    # Fill output with 1s to the right of obstacle (with bounds check)
    end = min(obstacle_col + 1 + left_count, width)
    for i in range(obstacle_col + 1, end):
        output_row[i] = 1
    output_row[obstacle_col] = 5
    
    return {"input": [input_row], "output": [output_row]}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    row = input_grid[0]
    obstacle_col = row.index(5)
    
    count = 0
    for i in range(obstacle_col - 1, -1, -1):
        if row[i] == 1:
            count += 1
        else:
            break
    
    output_row = [0] * len(row)
    output_row[obstacle_col] = 5
    for i in range(obstacle_col + 1, obstacle_col + 1 + count):
        if i < len(row):
            output_row[i] = 1
    
    return [output_row]
