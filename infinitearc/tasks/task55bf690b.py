# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 55bf690b
Difficulty: easy

=== Tags ===
- Diagonals
- Detect hor lines
- Concentric

=== Description ===
The input grid contains a rectangular region defined by two horizontal lines
(top and bottom rows) where all cells in each row are identical and non-zero.
The output grid is identical to the input, except the main diagonal of the
rectangular region is drawn using the same color as the horizontal lines. The
main diagonal spans from the top-left corner to the bottom-right corner of the
rectangle, including the corners which are already part of the horizontal lines.
The transformation applies the diagonal pattern to all cells within the
rectangle where the row index equals the column index, maintaining the
horizontal line colors while adding the diagonal structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common
def generate():
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    s = random.randint(3, min(width, height))
    r = random.randint(0, height - s)
    c = random.randint(0, width - s)
    C = random.randint(1, 9)
    input_grid = common.grid(width, height, 0)
    for col in range(c, c + s):
        input_grid[r][col] = C
    for col in range(c, c + s):
        input_grid[r + s - 1][col] = C
    output_grid = [row[:] for row in input_grid]
    for k in range(s):
        output_grid[r + k][c + k] = C
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random
import common
def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    segments = []
    for r in range(height):
        c = 0
        while c < width:
            if input_grid[r][c] == 0:
                c += 1
                continue
            color = input_grid[r][c]
            start = c
            while c < width and input_grid[r][c] == color:
                c += 1
            end = c - 1
            segments.append((color, start, end, r))
    
    for i in range(len(segments)):
        for j in range(i + 1, len(segments)):
            color1, start1, end1, r1 = segments[i]
            color2, start2, end2, r2 = segments[j]
            if color1 == color2 and start1 == start2 and end1 == end2 and r1 < r2:
                r_top, r_bottom = r1, r2
                color = color1
                c_start, c_end = start1, end1
                break
        else:
            continue
        break
    else:
        return input_grid
    
    s = r_bottom - r_top + 1
    output_grid = [list(row) for row in input_grid]
    for k in range(s):
        r_pos = r_top + k
        c_pos = c_start + k
        if r_pos < height and c_pos < width:
            output_grid[r_pos][c_pos] = color
    return output_grid
