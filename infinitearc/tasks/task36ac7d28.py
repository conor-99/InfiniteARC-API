# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 36ac7d28
Difficulty: medium–hard

=== Tags ===
- Interleaved streams
- Fractal growth
- Topological invariance
- Color matching

=== Description ===
# Task Description: Interleaved Fractal Streams  Input grids depict a fractal
structure formed by multiple interleaved colored streams. Each stream is a
continuous path of a single color, with adjacent streams alternating colors to
create a braided pattern (e.g., color 0, color 1, color 0, color 1). The fractal
grows outward from a central core, doubling the number of streams at each level:
1 stream at the core, 2 streams at the next level, 4 streams at the following
level, and so on. The streams maintain consistent spacing and alignment, forming
a geometrically regular pattern that expands outward while preserving its
topological structure.  The output grid extends the fractal to the next level by
adding new streams between existing ones while maintaining the interleaving
pattern. Each new stream's color follows a strict sequence: if a stream at level
N has color C, the two new streams at level N+1 replacing it will have colors
C+1 and C-1 (mod 9), ensuring the alternating pattern continues seamlessly. This
results in a denser, more complex braid of colors that maintains the original
fractal's geometric structure and connectivity.  Topological invariance is
preserved as the relative positions, connections, and spacing between streams
remain unchanged—only the number of streams and their colors evolve according to
the transformation rule. Color matching ensures that the new colors integrate
naturally into the existing sequence without disrupting the alternating pattern,
creating a visually coherent progression. The background remains unchanged, and
all operations apply only to the stream patterns, leaving non-stream areas
untouched.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    start_color = random.randint(1, 9)
    N = random.choice([0, 1, 2])
    height = random.randint(3, 30)
    input_width = (1 << (N + 1)) - 1
    colors = [start_color]
    for _ in range(N):
        new_colors = []
        for c in colors:
            c1 = (c + 1) % 9
            if c1 == 0:
                c1 = 9
            c2 = (c - 1) % 9
            if c2 == 0:
                c2 = 9
            new_colors.append(c1)
            new_colors.append(c2)
        colors = new_colors
    input_grid = grid(input_width, height, 0)
    for idx, c in enumerate(colors):
        col = 2 * idx
        for r in range(height):
            input_grid[r][col] = c
    output_colors = []
    for c in colors:
        c1 = (c + 1) % 9
        if c1 == 0:
            c1 = 9
        c2 = (c - 1) % 9
        if c2 == 0:
            c2 = 9
        output_colors.append(c1)
        output_colors.append(c2)
    output_width = (1 << (N + 2)) - 1
    output_grid = grid(output_width, height, 0)
    for idx, c in enumerate(output_colors):
        col = 2 * idx
        for r in range(height):
            output_grid[r][col] = c
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    stream_columns = []
    for c in range(width):
        all_non_zero = True
        for r in range(height):
            if input_grid[r][c] == 0:
                all_non_zero = False
                break
        if all_non_zero:
            stream_columns.append(c)
    stream_columns.sort()
    input_colors = [input_grid[0][c] for c in stream_columns]
    output_colors = []
    for c in input_colors:
        c1 = (c + 1) % 9
        if c1 == 0:
            c1 = 9
        c2 = (c - 1) % 9
        if c2 == 0:
            c2 = 9
        output_colors.append(c1)
        output_colors.append(c2)
    output_width = 2 * width + 1
    output_grid = grid(output_width, height, 0)
    for idx, c in enumerate(output_colors):
        col = 2 * idx
        for r in range(height):
            output_grid[r][col] = c
    return output_grid
