# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: e01a9c15
Difficulty: medium–hard

=== Tags ===
- Symbolic spatial binding
- Beam reflection
- Draw x on largest object

=== Description ===
Input grids feature a background (color 0), multiple distinct colored objects
(connected regions of non-zero colors), and diagonal beams (color 9) that travel
through the background and reflect off objects according to standard reflection
rules. The beams are part of the input structure but do not influence the
transformation. The largest object is defined as the connected region with the
highest cell count, excluding the background.  The output grid must retain all
input elements except for the largest object, which is modified by drawing an
'X' pattern. This is achieved by identifying the object's bounding box, then
setting the top-left and bottom-right diagonal cells within this box to color 9.
For objects that are 2×2 in size, both diagonal cells are set to 9. For larger
objects, the X is centered within the bounding box, with the diagonal cells
aligned to the main diagonals (e.g., for a 3×3 object, cells (0,0), (1,1), (2,2)
and (0,2), (1,1), (2,0) are used, but only the corner endpoints are modified to
color 9 to form the X). The transformation ignores beam paths and focuses solely
on object size and spatial positioning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
from common import grid, continuous_creature, randint, random_colors

def generate():
    width = randint(5, 30)
    height = randint(5, 30)
    grid = [[0] * width for _ in range(height)]
    
    colors = random_colors(3, exclude=[0, 9])
    objects = []
    
    for i, color in enumerate(colors):
        size = 5 if i == 0 else randint(2, 4)
        pixels = continuous_creature(size, width, height)
        rows, cols = zip(*pixels) if pixels else ([], [])
        for r, c in zip(rows, cols):
            if grid[r][c] == 0:
                grid[r][c] = color
        objects.append((color, rows, cols))
    
    # Add beams (color 9) in background
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 and common.random.random() > 0.5:
                grid[r][c] = 9
    
    output = [row[:] for row in grid]
    
    # Find largest object
    max_size = 0
    largest_object = None
    for color, rows, cols in objects:
        size = len(rows)
        if size > max_size:
            max_size = size
            largest_object = (rows, cols)
    
    if largest_object is None:
        return {"input": grid, "output": grid}
    
    rows, cols = largest_object
    min_r, max_r = min(rows), max(rows)
    min_c, max_c = min(cols), max(cols)
    
    # Draw X in bounding box
    for r in range(min_r, max_r + 1):
        c1 = min_c + (r - min_r)
        c2 = max_c - (r - min_r)
        if min_c <= c1 <= max_c:
            output[r][c1] = 9
        if min_c <= c2 <= max_c:
            output[r][c2] = 9
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    
    visited = [[False] * width for _ in range(height)]
    objects = []  # (size, rows, cols)
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and input_grid[r][c] != 0 and input_grid[r][c] != 9:
                color = input_grid[r][c]
                stack = [(r, c)]
                visited[r][c] = True
                comp_r, comp_c = [], []
                while stack:
                    cr, cc = stack.pop()
                    comp_r.append(cr)
                    comp_c.append(cc)
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                objects.append((len(comp_r), comp_r, comp_c))
    
    if not objects:
        return input_grid
    
    largest = max(objects, key=lambda x: x[0])
    _, rows, cols = largest
    min_r, max_r = min(rows), max(rows)
    min_c, max_c = min(cols), max(cols)
    
    for r in range(min_r, max_r + 1):
        c1 = min_c + (r - min_r)
        c2 = max_c - (r - min_r)
        if min_c <= c1 <= max_c:
            input_grid[r][c1] = 9
        if min_c <= c2 <= max_c:
            input_grid[r][c2] = 9
    
    return input_grid
