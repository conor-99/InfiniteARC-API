# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 5251716c
Difficulty: insane

=== Tags ===
- Recursive partition
- Oscillating rule
- Holes
- Mark extrema corners

=== Description ===
# Recursive Partition Oscillation  Input grids are medium to large (10×10 to
20×20) with a background color (0) and multiple distinct colored regions (1-8)
forming connected components. Each region contains at least one hole—a
background cell (0) completely enclosed by the region's color (i.e., a
background cell surrounded by non-background cells in all four orthogonal
directions within the region's bounding box). Regions may overlap in bounding
boxes but never in actual colored cells.  The transformation process involves
two primary operations applied sequentially: 1. **Region Corner Marking**: For
every region, identify its minimal bounding box (the smallest rectangle
containing all cells of that region). For each of the four corners of this
bounding box, if the cell at that position is background (0) in the input, mark
it with color 9 (a dedicated marker color) in the output. This marks the
"extrema corners" of each region without altering non-background cells.  2.
**Recursive Oscillating Partitioning**: Recursively partition the entire grid
into quadrants, alternating the split direction at each recursion level
(horizontal at even levels, vertical at odd levels). Partitioning stops when:
- A quadrant contains a hole (background cell inside a region's bounding box)
- A quadrant is 1×1    - The quadrant contains a cell marked as a region corner
(color 9)        For every quadrant resulting from this partitioning (including
intermediate splits), mark its four corners with color 8 if the cell is
background (0) in the input. This creates a nested pattern of alternating corner
markers (9 for regions, 8 for partitions) that visually highlights the recursive
structure.  The output grid retains all original region colors and holes, with
only the specified corner positions altered to 8 or 9. The pattern forms a
complex hierarchical structure where the oscillating partitioning reveals nested
geometric relationships between regions and their holes, with the markers
creating a visual "skeleton" of the recursive decomposition. The most
challenging aspect is recognizing that the partitioning alternates direction
while simultaneously tracking which regions contain holes and which corners
remain background.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Grid size
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    # Create empty input grid (height rows, width cols)
    input_grid = grid(width, height, 0)

    # Track occupied (colored) cells so regions do not overlap in actual colored pixels
    occupied = [[False for _ in range(width)] for _ in range(height)]

    # Create a random number of regions (3-5), each with a unique color in 1..8
    num_regions = random.randint(3, 5)
    region_colors = random.sample(list(range(1, 9)), num_regions)

    for color in region_colors:
        placed = False
        # Try to place a region up to many attempts to avoid infinite loops
        for _attempt in range(200):
            size_h = random.randint(3, min(8, height))
            size_w = random.randint(3, min(8, width))
            top = random.randint(0, height - size_h)
            left = random.randint(0, width - size_w)
            bottom = top + size_h - 1
            right = left + size_w - 1

            # Ensure the region's colored cells won't overlap previously placed colored cells
            conflict = False
            for r in range(top, bottom + 1):
                for c in range(left, right + 1):
                    if occupied[r][c]:
                        conflict = True
                        break
                if conflict:
                    break
            if conflict:
                continue

            # Fill the rectangle with the region color
            for r in range(top, bottom + 1):
                for c in range(left, right + 1):
                    input_grid[r][c] = color
                    occupied[r][c] = True

            # Randomly remove 0-2 corner cells (set them back to background) so the minimal
            # bounding box can have corners that are background (these will become 9 markers)
            corners = [(top, left), (top, right), (bottom, left), (bottom, right)]
            remove_count = random.randint(0, 2)
            if remove_count > 0:
                for (r, c) in random.sample(corners, remove_count):
                    input_grid[r][c] = 0
                    occupied[r][c] = False

            # Create at least one interior hole (a background cell inside the bounding box)
            if bottom - top >= 2 and right - left >= 2:
                hole_r = random.randint(top + 1, bottom - 1)
                hole_c = random.randint(left + 1, right - 1)
                input_grid[hole_r][hole_c] = 0
                occupied[hole_r][hole_c] = False

            placed = True
            break
        # If placement failed after many attempts we skip this color
        if not placed:
            continue

    # Recompute regions by finding connected components for colors 1-8 so that the solver
    # (which computes components from the input) will see the same minimal bounding boxes.
    visited = [[False for _ in range(width)] for _ in range(height)]
    regions = []
    for r in range(height):
        for c in range(width):
            if visited[r][c]:
                continue
            color = input_grid[r][c]
            if not (1 <= color <= 8):
                continue
            # Flood fill to collect the connected component
            stack = [(r, c)]
            visited[r][c] = True
            cells = []
            while stack:
                rr, cc = stack.pop()
                cells.append((rr, cc))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            rows = [p[0] for p in cells]
            cols = [p[1] for p in cells]
            top, bottom = min(rows), max(rows)
            left, right = min(cols), max(cols)
            regions.append((color, top, bottom, left, right))

    # Prepare output as a copy of input (we will add 9 and 8 markers on top)
    output_grid = [row[:] for row in input_grid]

    # Step 1: Region corner marking (color 9) based on input
    region_corner_positions = set()
    for (_color, top, bottom, left, right) in regions:
        for (r, c) in [(top, left), (top, right), (bottom, left), (bottom, right)]:
            # Only mark if the cell is background in the input
            if input_grid[r][c] == 0:
                output_grid[r][c] = 9
                region_corner_positions.add((r, c))

    # Step 2: Precompute holes: background cells inside region bounding boxes that are
    # orthogonally surrounded by non-background cells within that bounding box
    holes = set()
    for (_color, top, bottom, left, right) in regions:
        for r in range(top + 1, bottom):
            for c in range(left + 1, right):
                if input_grid[r][c] != 0:
                    continue
                # Check four orthogonal neighbors are inside the bounding box and non-zero
                enclosed = True
                for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                    nr, nc = r + dr, c + dc
                    if not (top <= nr <= bottom and left <= nc <= right):
                        enclosed = False
                        break
                    if input_grid[nr][nc] == 0:
                        enclosed = False
                        break
                if enclosed:
                    holes.add((r, c))

    # Recursive oscillating partitioning (mark quadrant corners with color 8)
    def mark_quad_corners(top, left, bottom, right):
        for (r, c) in [(top, left), (top, right), (bottom, left), (bottom, right)]:
            if 0 <= r < height and 0 <= c < width:
                # Do not overwrite existing 9 markers; only mark background cells that are
                # background in the input
                if input_grid[r][c] == 0 and output_grid[r][c] == 0:
                    output_grid[r][c] = 8

    def partition(top, left, bottom, right, depth):
        # Mark corners for this quadrant (intermediate and leaf nodes alike)
        mark_quad_corners(top, left, bottom, right)

        # Stop if this is a 1x1 cell
        if top == bottom and left == right:
            return

        # Stop if this quadrant contains any hole or any region corner (these are defined
        # with respect to the original input)
        contains_hole = any(top <= hr <= bottom and left <= hc <= right for (hr, hc) in holes)
        contains_region_corner = any(top <= rr <= bottom and left <= cc <= right for (rr, cc) in region_corner_positions)
        if contains_hole or contains_region_corner:
            return

        # Alternating split direction: horizontal at even depths, vertical at odd depths.
        horizontal = (depth % 2 == 0)

        # If the intended split cannot be performed because the dimension is 1, fall back
        # to the other axis if possible. If neither can split, stop.
        if horizontal:
            if top < bottom:
                mid = (top + bottom) // 2
                partition(top, left, mid, right, depth + 1)
                partition(mid + 1, left, bottom, right, depth + 1)
            elif left < right:
                mid = (left + right) // 2
                partition(top, left, bottom, mid, depth + 1)
                partition(top, mid + 1, bottom, right, depth + 1)
            else:
                return
        else:
            if left < right:
                mid = (left + right) // 2
                partition(top, left, bottom, mid, depth + 1)
                partition(top, mid + 1, bottom, right, depth + 1)
            elif top < bottom:
                mid = (top + bottom) // 2
                partition(top, left, mid, right, depth + 1)
                partition(mid + 1, left, bottom, right, depth + 1)
            else:
                return

    partition(0, 0, height - 1, width - 1, 0)

    return {
        "input": input_grid,
        "output": output_grid
    }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input (tuple of tuples) to a mutable list of lists
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0]) if height > 0 else 0

    # Find connected regions (connected components) for colors 1-8
    visited = [[False] * width for _ in range(height)]
    regions = []  # list of (color, top, bottom, left, right)
    for r in range(height):
        for c in range(width):
            if visited[r][c]:
                continue
            color = grid_in[r][c]
            if not (1 <= color <= 8):
                continue
            # Flood fill this component
            stack = [(r, c)]
            visited[r][c] = True
            cells = []
            while stack:
                rr, cc = stack.pop()
                cells.append((rr, cc))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid_in[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            rows = [p[0] for p in cells]
            cols = [p[1] for p in cells]
            top, bottom = min(rows), max(rows)
            left, right = min(cols), max(cols)
            regions.append((color, top, bottom, left, right))

    # Prepare output as a copy of input and compute region-corner positions
    grid_out = [row[:] for row in grid_in]
    region_corner_positions = set()
    for (_color, top, bottom, left, right) in regions:
        for (rr, cc) in [(top, left), (top, right), (bottom, left), (bottom, right)]:
            if 0 <= rr < height and 0 <= cc < width and grid_in[rr][cc] == 0:
                grid_out[rr][cc] = 9
                region_corner_positions.add((rr, cc))

    # Compute holes (background cells inside region bounding boxes orthogonally surrounded
    # by non-background cells within that box)
    holes = set()
    for (_color, top, bottom, left, right) in regions:
        for rr in range(top + 1, bottom):
            for cc in range(left + 1, right):
                if grid_in[rr][cc] != 0:
                    continue
                enclosed = True
                for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                    nr, nc = rr + dr, cc + dc
                    if not (top <= nr <= bottom and left <= nc <= right):
                        enclosed = False
                        break
                    if grid_in[nr][nc] == 0:
                        enclosed = False
                        break
                if enclosed:
                    holes.add((rr, cc))

    # Recursive partitioning: mark corners with color 8 (do not override 9)
    def mark_quad_corners(top, left, bottom, right):
        for (rr, cc) in [(top, left), (top, right), (bottom, left), (bottom, right)]:
            if 0 <= rr < height and 0 <= cc < width:
                if grid_in[rr][cc] == 0 and grid_out[rr][cc] == 0:
                    grid_out[rr][cc] = 8

    def partition(top, left, bottom, right, depth):
        # Mark this quadrant's corners first
        mark_quad_corners(top, left, bottom, right)

        # Stop if 1x1
        if top == bottom and left == right:
            return

        # Stop if contains hole or a region corner
        contains_hole = any(top <= hr <= bottom and left <= hc <= right for (hr, hc) in holes)
        contains_region_corner = any(top <= rc <= bottom and left <= cc <= right for (rc, cc) in region_corner_positions)
        if contains_hole or contains_region_corner:
            return

        horizontal = (depth % 2 == 0)
        if horizontal:
            if top < bottom:
                mid = (top + bottom) // 2
                partition(top, left, mid, right, depth + 1)
                partition(mid + 1, left, bottom, right, depth + 1)
            elif left < right:
                mid = (left + right) // 2
                partition(top, left, bottom, mid, depth + 1)
                partition(top, mid + 1, bottom, right, depth + 1)
            else:
                return
        else:
            if left < right:
                mid = (left + right) // 2
                partition(top, left, bottom, mid, depth + 1)
                partition(top, mid + 1, bottom, right, depth + 1)
            elif top < bottom:
                mid = (top + bottom) // 2
                partition(top, left, mid, right, depth + 1)
                partition(mid + 1, left, bottom, right, depth + 1)
            else:
                return

    if height > 0 and width > 0:
        partition(0, 0, height - 1, width - 1, 0)

    return grid_out

