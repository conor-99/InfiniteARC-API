# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 404e9362
Difficulty: hard

=== Tags ===
- Alternating direction
- Pattern to sequence mapping
- Color permutation

=== Description ===
Task Name: Directional Color Sequence  Description: Input grids contain a
continuous path of non-background colors embedded within a uniform background.
The path consists of a sequence of adjacent cells (horizontally or vertically
connected) where each cell's color follows a repeating pattern. The output grid
transforms the path by reversing each movement direction (e.g., right becomes
left, down becomes up) and applying a right cyclic shift to the color sequence
(moving the last color to the front). The transformed path must remain
continuous, fit within grid boundaries, and maintain all background cells
unchanged. This requires identifying the path's direction sequence, reversing
each direction step, and applying a consistent color permutation to the
sequence, demanding precise pattern recognition and multi-step transformation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    max_total_tries = 500
    tries = 0
    while True:
        tries += 1
        width = random.randint(5, 20)
        height = random.randint(5, 20)
        # center cell (start)
        cr, cc = height // 2, width // 2
        # allowed bounding box for positions so that reflection across center stays in grid
        rmin_allowed = max(0, 2*cr - (height - 1))
        rmax_allowed = min(height - 1, 2*cr)
        cmin_allowed = max(0, 2*cc - (width - 1))
        cmax_allowed = min(width - 1, 2*cc)
        # minimal path length
        min_len = 5
        # available cells in allowed bbox
        avail_cells = (rmax_allowed - rmin_allowed + 1) * (cmax_allowed - cmin_allowed + 1)
        if avail_cells < min_len:
            continue
        max_len = min(18, avail_cells)
        length = random.randint(min_len, max_len)
        # build a simple path (self-avoiding walk) starting at center
        path = [(cr, cc)]
        visited = set(path)
        stuck = False
        for _ in range(length - 1):
            r, c = path[-1]
            neighbors = []
            for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                nr, nc = r + dr, c + dc
                if nr < rmin_allowed or nr > rmax_allowed or nc < cmin_allowed or nc > cmax_allowed:
                    continue
                if not (0 <= nr < height and 0 <= nc < width):
                    continue
                if (nr, nc) in visited:
                    continue
                # avoid touching earlier visited cells (only allowed neighbor is the previous cell)
                touches_earlier = False
                for adr, adc in [(1,0),(-1,0),(0,1),(0,-1)]:
                    neighbor_pos = (nr + adr, nc + adc)
                    if neighbor_pos in visited and neighbor_pos != path[-1]:
                        touches_earlier = True
                        break
                if touches_earlier:
                    continue
                neighbors.append((nr, nc))
            if not neighbors:
                stuck = True
                break
            next_cell = random.choice(neighbors)
            path.append(next_cell)
            visited.add(next_cell)
        if stuck:
            if tries > max_total_tries:
                # if too many failures, relax constraints a bit by reducing min_len
                min_len = max(2, min_len - 1)
            continue
        # create repeating color cycle
        cycle_len = random.randint(2, 4)
        cycle_colors = random.sample(range(1, 10), cycle_len)
        colors = [cycle_colors[i % cycle_len] for i in range(len(path))]
        # build input grid
        input_grid = grid(width, height, 0)
        for (r, c), col in zip(path, colors):
            input_grid[r][c] = col
        # build output by reflecting across center and right cyclic shifting colors
        n = len(path)
        output_grid = grid(width, height, 0)
        valid_output = True
        for idx, (r, c) in enumerate(path):
            rr = 2*cr - r
            cc2 = 2*cc - c
            if not (0 <= rr < height and 0 <= cc2 < width):
                valid_output = False
                break
            out_col = colors[(idx - 1) % n]
            output_grid[rr][cc2] = out_col
        if not valid_output:
            continue
        # ensure input and output differ
        if input_grid == output_grid:
            continue
        return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # convert to mutable list of lists
    grid_list = [list(row) for row in input_grid]
    height = len(grid_list)
    if height == 0:
        return grid_list
    width = len(grid_list[0])
    # center coordinates (same convention used in generator)
    cr, cc = height // 2, width // 2
    # collect non-background cells
    nonzero = [(r, c) for r in range(height) for c in range(width) if grid_list[r][c] != 0]
    if not nonzero:
        return grid_list
    # neighbor counts
    neigh_count = {}
    for r, c in nonzero:
        cnt = 0
        for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and grid_list[nr][nc] != 0:
                cnt += 1
        neigh_count[(r, c)] = cnt
    # choose start: prefer center if it's part of the path
    if (cr, cc) in neigh_count:
        start = (cr, cc)
    else:
        # otherwise pick an endpoint (degree 1) if any, else pick any colored cell
        endpoints = [p for p, cnt in neigh_count.items() if cnt == 1]
        start = endpoints[0] if endpoints else nonzero[0]
    # traverse the path from start
    path = []
    visited = set()
    cur = start
    while True:
        path.append(cur)
        visited.add(cur)
        r, c = cur
        next_cell = None
        for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and grid_list[nr][nc] != 0 and (nr, nc) not in visited:
                next_cell = (nr, nc)
                break
        if next_cell is None:
            break
        cur = next_cell
    # read colors along the path and apply right cyclic shift
    colors = [grid_list[r][c] for (r, c) in path]
    n = len(colors)
    if n == 0:
        return grid_list
    shifted = [colors[(i - 1) % n] for i in range(n)]
    # build output grid by reflecting positions across center with shifted colors
    output = [[0 for _ in range(width)] for __ in range(height)]
    for (r, c), col in zip(path, shifted):
        rr = 2*cr - r
        cc2 = 2*cc - c
        if 0 <= rr < height and 0 <= cc2 < width:
            output[rr][cc2] = col
    return output
