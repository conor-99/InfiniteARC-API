# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 085d6805
Difficulty: hard

=== Tags ===
- Gate chain construction
- Blockwise rule application
- Mark extrema corners
- Add center crosshair

=== Description ===
**Task Description:**  **Input Grids:**   Grids contain multiple non-overlapping
rectangular blocks (each block is a solid color, background is color 0). Each
block is axis-aligned, with dimensions at least 2×2. Blocks are separated by
background cells (color 0), and no two blocks share a common edge. Blocks may
vary in color, size, and position, but all are clearly distinguishable from the
background.  **Transformation Rules:**   1. **Mark Extrema Corners:** For each
block, identify its top-left and bottom-right corners (the corners of the
bounding box). Replace these two corner cells with color 9 (a distinct marker
color).   2. **Gate Chain Construction:** Sort all blocks by their top-left
corner coordinates (row-major order: by increasing row, then by increasing
column). For each consecutive pair of blocks in this sorted order, draw a "gate
chain" — a straight horizontal or vertical line connecting the bottom-right
corner of the current block to the top-left corner of the next block. The chain
is drawn using color 8, occupying only background cells (color 0), and must not
overlap with any block or previously drawn chain. If a direct
horizontal/vertical path is blocked by another block, the chain detours around
the obstacle using the shortest possible path (only moving through background
cells).   3. **Add Center Crosshair:** Compute the grid's geometric center
(rounded down to integer coordinates for even dimensions). Place a crosshair (a
+ shape) centered at this point: set the center cell, and its immediate up,
down, left, and right neighbors to color 9. If the grid has even dimensions, the
crosshair is centered within the central 2×2 cell block (e.g., in a 4×4 grid,
the crosshair is placed at (1,1), (1,2), (2,1), (2,2)).  **Output Grid:**   The
output grid is identical to the input grid, with the following additions:   -
All block corners (top-left and bottom-right) marked as color 9.   - A
continuous gate chain connecting sorted blocks using color 8, avoiding
obstacles.   - A center crosshair (color 9) precisely positioned at the grid's
center.    **Key Complexity for Hard Difficulty:**   - Blocks must be identified
correctly (rectangular, non-overlapping, background-separated).   - Sorting
blocks by top-left coordinates requires precise spatial reasoning.   - The gate
chain must dynamically navigate around obstacles while maintaining minimal
detours.   - The center crosshair placement must account for even/odd grid
dimensions.   - All transformations are blockwise and spatially constrained,
requiring multi-step reasoning without relying on color values beyond the
background.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random
import collections

# Generator for ARC task 420 (Gate chain construction with corner markers and center crosshair)

def generate():
    """
    Generates an input/output pair following the specification:
    - Place several non-overlapping rectangular blocks (colors 1..7), each at least 2x2.
    - Ensure blocks are separated by at least one background cell and also not touching the grid border
      (leave a 1-cell margin) so that corner-based pathfinding is possible.
    - In the output, mark each block's top-left and bottom-right corners with color 9.
    - Connect consecutive blocks (sorted by top-left row-major) by a shortest-path gate chain of color 8
      that travels only through background cells (0) and does not overwrite blocks or earlier chains.
      The chain connects the bottom-right corner of the current block to the top-left corner of the next
      block; endpoints remain color 9.
    - Finally, add a center crosshair (color 9). For even-by-even grids the crosshair is the central 2x2
      block; otherwise it is a + shape (center plus up/down/left/right neighbors).

    Returns:
        dict with keys "input" and "output" mapping to 2D lists of ints.
    """

    # Helper: BFS shortest path that may start/end on non-zero endpoints (start/end often color 9).
    # Movement allowed only through cells equal to 0, except the end cell which is allowed even if non-zero.
    # Previously-drawn chains (value 8) and block cells are treated as obstacles.
    def find_path(grid, start, end, height, width):
        queue = collections.deque([start])
        parent = {}
        visited = set([start])
        # neighbor expansion order must be deterministic and consistent with the solver
        neighbors = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        while queue:
            r, c = queue.popleft()
            if (r, c) == end:
                # reconstruct
                path = []
                pos = end
                while pos != start:
                    path.append(pos)
                    pos = parent[pos]
                path.append(start)
                path.reverse()
                return path
            for dr, dc in neighbors:
                nr, nc = r + dr, c + dc
                if not (0 <= nr < height and 0 <= nc < width):
                    continue
                if (nr, nc) in visited:
                    continue
                # allow stepping into the end even if it's not background
                if (nr, nc) == end:
                    parent[(nr, nc)] = (r, c)
                    visited.add((nr, nc))
                    queue.append((nr, nc))
                elif grid[nr][nc] == 0:
                    parent[(nr, nc)] = (r, c)
                    visited.add((nr, nc))
                    queue.append((nr, nc))
        return None

    max_global_attempts = 300
    attempt = 0
    while attempt < max_global_attempts:
        attempt += 1
        width = random.randint(10, 30)
        height = random.randint(10, 30)
        # create input grid with background color 0
        input_grid = common.grid(width, height, 0)

        # place a random number of blocks (3..6)
        num_blocks = random.randint(3, 6)
        blocks = []  # list of tuples (r, c, w, h, color)

        # bounds for block sizes (leave a 1-cell margin around the grid to guarantee corner adjacency to background)
        max_block_w = min(6, width - 4)
        max_block_h = min(6, height - 4)
        if max_block_w < 2 or max_block_h < 2:
            # grid too small for constraints; try again
            continue

        placement_failed = False
        for _ in range(num_blocks):
            placed = False
            for _ in range(300):
                w = random.randint(2, max_block_w)
                h = random.randint(2, max_block_h)
                # ensure at least 1-cell margin from borders so corners have external neighbors
                r = random.randint(1, height - h - 1)
                c = random.randint(1, width - w - 1)

                # check separation: ensure the one-cell-expanded rectangle is free
                rr0 = max(0, r - 1)
                rr1 = min(height, r + h + 1)
                cc0 = max(0, c - 1)
                cc1 = min(width, c + w + 1)
                conflict = False
                for rr in range(rr0, rr1):
                    for cc in range(cc0, cc1):
                        if input_grid[rr][cc] != 0:
                            conflict = True
                            break
                    if conflict:
                        break
                if conflict:
                    continue

                color = random.randint(1, 7)  # avoid 8 and 9 which are reserved for chains and markers
                for rr in range(r, r + h):
                    for cc in range(c, c + w):
                        input_grid[rr][cc] = color
                blocks.append((r, c, w, h, color))
                placed = True
                break
            if not placed:
                placement_failed = True
                break

        if placement_failed or len(blocks) != num_blocks:
            continue

        # Prepare the output grid
        output_grid = [row[:] for row in input_grid]

        # Sort blocks by top-left corner (row-major)
        blocks.sort(key=lambda x: (x[0], x[1]))

        # Mark each block's top-left and bottom-right corners with color 9
        for (r, c, w, h, color) in blocks:
            output_grid[r][c] = 9
            output_grid[r + h - 1][c + w - 1] = 9

        # Build gate chains sequentially; if any chain is impossible, restart generation
        failed_chain = False
        for i in range(len(blocks) - 1):
            r1, c1, w1, h1, _ = blocks[i]
            r2, c2, w2, h2, _ = blocks[i + 1]
            start = (r1 + h1 - 1, c1 + w1 - 1)  # bottom-right of current
            end = (r2, c2)  # top-left of next

            path = find_path(output_grid, start, end, height, width)
            if path is None:
                failed_chain = True
                break

            # paint the path with color 8, but do not overwrite the two endpoints (they stay color 9)
            for (pr, pc) in path:
                if (pr, pc) == start or (pr, pc) == end:
                    continue
                # if it's not background then something went wrong
                if output_grid[pr][pc] != 0:
                    failed_chain = True
                    break
                output_grid[pr][pc] = 8
            if failed_chain:
                break

        if failed_chain:
            # try to generate a fresh layout
            continue

        # Add the center crosshair (color 9). For even-by-even grids, fill the central 2x2
        center_row = (height - 1) // 2
        center_col = (width - 1) // 2
        cross_cells = []
        if height % 2 == 0 and width % 2 == 0:
            cross_cells = [
                (center_row, center_col),
                (center_row, center_col + 1),
                (center_row + 1, center_col),
                (center_row + 1, center_col + 1),
            ]
        else:
            # plus-shaped crosshair: center and its four orthogonal neighbors (within bounds)
            cross_cells.append((center_row, center_col))
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nr, nc = center_row + dr, center_col + dc
                if 0 <= nr < height and 0 <= nc < width:
                    cross_cells.append((nr, nc))

        for (cr, cc) in cross_cells:
            output_grid[cr][cc] = 9

        # Ensure input != output and return
        if output_grid == input_grid:
            # unlikely, but regenerate if nothing changed
            continue

        return {"input": input_grid, "output": output_grid}

    # If generation repeatedly fails (very unlikely), raise an error
    raise RuntimeError("Failed to generate a valid task after many attempts")



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
import collections

def p(input_grid):
    """
    Solver: given an input grid (tuple of tuples), detect rectangular blocks, mark corners,
    build gate chains, and add the center crosshair — reproducing the generator's logic.
    """

    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Flood-fill to find connected components of non-zero pixels (blocks)
    visited = [[False] * width for _ in range(height)]
    blocks = []  # (min_r, min_c, width, height, color)
    for r in range(height):
        for c in range(width):
            if grid[r][c] > 0 and not visited[r][c]:
                color = grid[r][c]
                cells = []
                queue = collections.deque([(r, c)])
                visited[r][c] = True
                while queue:
                    cr, cc = queue.popleft()
                    cells.append((cr, cc))
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                min_r = min(rr for rr, cc in cells)
                max_r = max(rr for rr, cc in cells)
                min_c = min(cc for rr, cc in cells)
                max_c = max(cc for rr, cc in cells)

                # Validate that the component fills its bounding rectangle with the same color
                valid = True
                for rr in range(min_r, max_r + 1):
                    for cc in range(min_c, max_c + 1):
                        if grid[rr][cc] != color:
                            valid = False
                            break
                    if not valid:
                        break
                if valid:
                    blocks.append((min_r, min_c, max_c - min_c + 1, max_r - min_r + 1, color))

    # Sort blocks row-major by top-left coordinates
    blocks.sort(key=lambda x: (x[0], x[1]))

    # Copy input to output and then apply transformations
    output_grid = [row[:] for row in grid]

    # Mark top-left and bottom-right corners with color 9
    for (min_r, min_c, w, h, color) in blocks:
        output_grid[min_r][min_c] = 9
        output_grid[min_r + h - 1][min_c + w - 1] = 9

    # Helper BFS identical to generator's: allow stepping on background (0) and on the end cell (even if non-zero)
    def find_path(grid_state, start, end, height, width):
        queue = collections.deque([start])
        parent = {}
        visited = set([start])
        neighbors = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        while queue:
            r, c = queue.popleft()
            if (r, c) == end:
                path = []
                pos = end
                while pos != start:
                    path.append(pos)
                    pos = parent[pos]
                path.append(start)
                path.reverse()
                return path
            for dr, dc in neighbors:
                nr, nc = r + dr, c + dc
                if not (0 <= nr < height and 0 <= nc < width):
                    continue
                if (nr, nc) in visited:
                    continue
                if (nr, nc) == end:
                    parent[(nr, nc)] = (r, c)
                    visited.add((nr, nc))
                    queue.append((nr, nc))
                elif grid_state[nr][nc] == 0:
                    parent[(nr, nc)] = (r, c)
                    visited.add((nr, nc))
                    queue.append((nr, nc))
        return None

    # Build gate chains between consecutive blocks
    for i in range(len(blocks) - 1):
        min_r, min_c, w, h, _ = blocks[i]
        min_r2, min_c2, w2, h2, _ = blocks[i + 1]
        start = (min_r + h - 1, min_c + w - 1)
        end = (min_r2, min_c2)

        path = find_path(output_grid, start, end, height, width)
        if path is None:
            # If no path found, we conservatively do nothing (generator guarantees a path exists)
            continue

        for (pr, pc) in path:
            if (pr, pc) == start or (pr, pc) == end:
                continue
            output_grid[pr][pc] = 8

    # Add the center crosshair in the same manner as the generator
    center_row = (height - 1) // 2
    center_col = (width - 1) // 2
    cross_cells = []
    if height % 2 == 0 and width % 2 == 0:
        cross_cells = [
            (center_row, center_col),
            (center_row, center_col + 1),
            (center_row + 1, center_col),
            (center_row + 1, center_col + 1),
        ]
    else:
        cross_cells.append((center_row, center_col))
        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            nr, nc = center_row + dr, center_col + dc
            if 0 <= nr < height and 0 <= nc < width:
                cross_cells.append((nr, nc))

    for (cr, cc) in cross_cells:
        output_grid[cr][cc] = 9

    return tuple(tuple(row) for row in output_grid)

