# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: cb46ce9f
Difficulty: insane

=== Tags ===
- Beam splitter
- Cave escape

=== Description ===
# Beam Splitter Cave Escape  Input grids depict a large cave-like structure
(20×20 or larger) with a single background color (black). Walls form irregular,
enclosed passages in a distinct wall color (gray), creating a navigable path
through the cave. Scattered throughout are beam splitters, recognizable by their
distinctive cross-shaped patterns in a bright yellow color. Along the left edge,
there are multiple source points (each marked by a unique color: red, green,
blue) that emit beams traveling rightward. On the right edge, multiple exit
points exist (each marked by a different color: cyan, magenta, yellow) that must
be reached by the beams.  The transformation rules require tracking all beams as
they navigate the cave. Each beam starts as a single line moving rightward from
its source. When a beam encounters a beam splitter, it splits into two
perpendicular beams (one moving up, one moving down if the original was
horizontal, or one moving left, one moving right if the original was vertical).
Each new beam segment must follow the cave's passages without crossing walls,
and beams cannot occupy the same cell simultaneously. The color of each beam
segment cycles through a predefined sequence (red → orange → yellow → green →
blue → purple → ...) with each new segment created by a split advancing the
color sequence. Walls block beams (beams stop at walls), and beam splitters
remain visible but do not overwrite the path. Each beam must exit the cave
through a designated exit point on the right edge. The output grid visually
represents all beam paths using their current color in the sequence, with no
loops or dead ends—every beam must reach an exit after a finite number of splits
and movements. The complexity arises from multiple interacting beams, the need
to track color progression for each split, and the requirement that all paths
must navigate through the cave's intricate wall structure without overlapping or
blocking each other's paths.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random
from collections import deque

def generate():
    width = random.randint(20, 30)
    height = random.randint(20, 30)
    grid_input = common.grid(width, height, 0)
    
    start_row = random.randint(0, height - 1)
    path = []
    r, c = start_row, 0
    path.append((r, c))
    while c < width - 1:
        c += 1
        path.append((r, c))
        if random.random() < 0.3 and r > 0:
            r -= 1
        elif random.random() < 0.3 and r < height - 1:
            r += 1
    
    for r in range(height):
        for c in range(width):
            if (r, c) not in path:
                grid_input[r][c] = 5

    num_splitters = random.randint(3, 7)
    for _ in range(num_splitters):
        pos = random.choice(path)
        r, c = pos
        if (r-1, c) in path and (r+1, c) in path and (r, c-1) in path and (r, c+1) in path:
            grid_input[r][c] = 4
            for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
                nr, nc = r + dr, c + dc
                if (nr, nc) in path:
                    grid_input[nr][nc] = 4

    sources = []
    for r in range(height):
        if (r, 0) in path and (r, 1) in path:
            sources.append(r)
    sources = sources[:2] if len(sources) >= 2 else sources
    if not sources:
        sources = [random.randint(0, height-1) for _ in range(2)]
    for r in sources:
        grid_input[r][0] = 2

    exits = []
    for r in range(height):
        if (r, width-1) in path and (r, width-2) in path:
            exits.append(r)
    exits = exits[:3] if len(exits) >= 3 else exits
    if len(exits) < 3:
        exits.extend([random.randint(0, height-1) for _ in range(3 - len(exits))])
    exit_colors = [8, 6, 7]
    for i, r in enumerate(exits[:3]):
        grid_input[r][width-1] = exit_colors[i]

    grid_output = common.grid(width, height, 0)
    color_sequence = [2, 7, 4, 3, 9, 5, 8, 6, 1]
    queue = deque()
    
    for r in sources:
        queue.append((r, 0, (0, 1), 0))
    
    while queue:
        r, c, (dr, dc), color_idx = queue.popleft()
        current_color = color_sequence[color_idx]
        
        while True:
            nr, nc = r + dr, c + dc
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                break
            if grid_input[nr][nc] == 5:
                break
            if grid_input[nr][nc] == 4:
                grid_output[r][c] = current_color
                new_directions = [(-1, 0), (1, 0)] if dr == 0 else [(0, -1), (0, 1)]
                for ndr, ndc in new_directions:
                    new_color_idx = (color_idx + 1) % len(color_sequence)
                    queue.append((nr, nc, (ndr, ndc), new_color_idx))
                break
            else:
                grid_output[r][c] = current_color
                r, c = nr, nc
                color_idx = (color_idx + 1) % len(color_sequence)
                current_color = color_sequence[color_idx]
    
    return {
        "input": grid_input,
        "output": grid_output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
from collections import deque

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = common.grid(width, height, 0)
    color_sequence = [2, 7, 4, 3, 9, 5, 8, 6, 1]
    
    queue = deque()
    
    for r in range(height):
        if input_grid[r][0] == 2:
            queue.append((r, 0, (0, 1), 0))
    
    while queue:
        r, c, (dr, dc), color_idx = queue.popleft()
        current_color = color_sequence[color_idx]
        
        while True:
            nr, nc = r + dr, c + dc
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                break
            if input_grid[nr][nc] == 5:
                break
            if input_grid[nr][nc] == 4:
                output_grid[r][c] = current_color
                new_directions = [(-1, 0), (1, 0)] if dr == 0 else [(0, -1), (0, 1)]
                for ndr, ndc in new_directions:
                    new_color_idx = (color_idx + 1) % len(color_sequence)
                    queue.append((nr, nc, (ndr, ndc), new_color_idx))
                break
            else:
                output_grid[r][c] = current_color
                r, c = nr, nc
                color_idx = (color_idx + 1) % len(color_sequence)
                current_color = color_sequence[color_idx]
    
    return output_grid
