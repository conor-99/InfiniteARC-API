# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: fbdf9d58
Difficulty: hard

=== Tags ===
- Gradient flood

=== Description ===
# Gradient Flood  Input grids contain a background (color 0), multiple isolated
source points (color 2), and barrier structures (color 1). The barriers form
continuous walls that block movement in all four orthogonal directions, creating
disconnected regions within the grid. The output grid must transform the input
by applying a gradient flood effect that propagates from each source point
through traversable background cells while avoiding barriers.  For every non-
barrier cell, the output color is determined by its minimal Manhattan distance
to the nearest source cell, calculated through the shortest orthogonal path that
avoids barriers. The color progression follows: source cells (distance 0) retain
color 2, adjacent traversable cells (distance 1) become color 3, next (distance
2) become color 4, and so on, cycling through the color sequence 0-9 as distance
increases. Barrier cells (color 1) remain unchanged in the output.  The
transformation requires identifying all sources, computing the shortest path
distances through background cells while navigating around barriers, and
applying the color progression rule. The gradient must propagate through all
reachable cells, with distant cells cycling through the color palette. The
output grid will show a visually distinct gradient pattern where the color
intensity increases with distance from the nearest source, with barriers
creating sharp color transitions and disconnected regions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

from common import hollow_conway, grid
from random import randint, sample
from collections import deque
def generate():
    width = randint(5, 30)
    height = randint(5, 30)
    grid_input = grid(width, height, 0)
    
    barriers_rows, barriers_cols = hollow_conway(width, height, tries=5)
    for r, c in zip(barriers_rows, barriers_cols):
        grid_input[r][c] = 1
    
    background_cells = []
    for r in range(height):
        for c in range(width):
            if grid_input[r][c] == 0:
                background_cells.append((r, c))
    
    if not background_cells:
        return generate()
    
    num_sources = randint(2, 5)
    if num_sources > len(background_cells):
        num_sources = len(background_cells)
    source_cells = sample(background_cells, num_sources)
    
    for r, c in source_cells:
        grid_input[r][c] = 2
    
    grid_output = grid(width, height, 0)
    dist = [[-1] * width for _ in range(height)]
    q = deque()
    
    for r, c in source_cells:
        dist[r][c] = 0
        q.append((r, c))
    
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    
    while q:
        r, c = q.popleft()
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width:
                if grid_input[nr][nc] != 1 and dist[nr][nc] == -1:
                    dist[nr][nc] = dist[r][c] + 1
                    q.append((nr, nc))
    
    for r in range(height):
        for c in range(width):
            if grid_input[r][c] == 1:
                grid_output[r][c] = 1
            elif grid_input[r][c] == 2:
                grid_output[r][c] = 2
            else:
                d = dist[r][c]
                if d == -1:
                    grid_output[r][c] = 0
                else:
                    grid_output[r][c] = (2 + d) % 10
    
    return {"input": grid_input, "output": grid_output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque
def p(input_grid):
    grid_input = [list(row) for row in input_grid]
    width = len(grid_input[0])
    height = len(grid_input)
    
    sources = []
    for r in range(height):
        for c in range(width):
            if grid_input[r][c] == 2:
                sources.append((r, c))
    
    if not sources:
        return grid_input
    
    dist = [[-1] * width for _ in range(height)]
    q = deque()
    
    for r, c in sources:
        dist[r][c] = 0
        q.append((r, c))
    
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    
    while q:
        r, c = q.popleft()
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width:
                if grid_input[nr][nc] != 1 and dist[nr][nc] == -1:
                    dist[nr][nc] = dist[r][c] + 1
                    q.append((nr, nc))
    
    grid_output = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if grid_input[r][c] == 1:
                grid_output[r][c] = 1
            elif grid_input[r][c] == 2:
                grid_output[r][c] = 2
            else:
                d = dist[r][c]
                if d == -1:
                    grid_output[r][c] = 0
                else:
                    grid_output[r][c] = (2 + d) % 10
    
    return grid_output
