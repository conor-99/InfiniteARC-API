# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 8f696b76
Difficulty: hard

=== Tags ===
- Rotating signal
- Inverse rule reconstruction
- Recolor

=== Description ===
Input grids consist of multiple disconnected, geometric regions (each a
connected component of a single color) arranged across a background. Each
region's color encodes a rotation direction: color 1 indicates a 90° clockwise
rotation around the region's centroid, color 2 indicates 90° counterclockwise,
and color 3 indicates 180° rotation. The input grid is the result of applying
these rotations to the original unrotated regions.   The output grid must
reconstruct the original unrotated regions by applying the inverse rotation for
each region's color (color 1 regions rotated 90° counterclockwise, color 2
regions rotated 90° clockwise, color 3 regions unchanged), while recoloring each
region to a new color determined by the rotation angle. For 90° rotations (both
directions), regions are recolored to a single fixed color (e.g., color 4),
while 180° rotations recolor to another fixed color (e.g., color 5). The
recoloring rule must be inferred from the input-output examples, as the output
color mapping is not explicitly stated in the input.   All regions in the output
must maintain their original shape and connectivity, with no overlaps or
boundary violations. The task requires identifying the rotation direction from
the input color, applying the inverse rotation, and deducing the consistent
recoloring pattern before generating the final grid. The complexity arises from
handling multiple regions with different rotation rules simultaneously, the need
to reverse spatial transformations, and the requirement to infer a hidden
recoloring mapping based on visual patterns rather than explicit numerical
rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

# Generator for ARC task: create several centrally-symmetric connected shapes, place them,
# rotate them (according to color 1=cw90, 2=ccw90, 3=180) about their centroid (which will be
# an integer grid point because shapes are built symmetric), and produce input (rotated shapes
# colored by rotation type) and output (original unrotated shapes recolored: 4 for 90deg, 5 for 180deg).


def _build_symmetric_shape(size, max_attempts=200):
    """Build a centrally-symmetric 4-connected shape of given odd size >=1.

    The shape is built as offsets relative to center (0,0). The algorithm always keeps the
    set symmetric: if (r,c) in shape then (-r,-c) in shape. We start with {(0,0)} and add
    symmetric pairs by attaching a neighbor to an existing symmetric cell.
    """
    assert size % 2 == 1 and size >= 1
    shape = set([(0, 0)])
    attempts = 0
    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    while len(shape) < size and attempts < max_attempts:
        bases = [p for p in shape if (-p[0], -p[1]) in shape]
        if not bases:
            bases = list(shape)
        base = random.choice(bases)
        dr, dc = random.choice(dirs)
        new1 = (base[0] + dr, base[1] + dc)
        new2 = (-new1[0], -new1[1])
        if new1 in shape or new2 in shape:
            attempts += 1
            continue
        shape.add(new1)
        shape.add(new2)
        attempts = 0
    if len(shape) > size:
        removable = [p for p in shape if p != (0, 0)]
        random.shuffle(removable)
        while len(shape) > size and removable:
            p = removable.pop()
            if p in shape and (-p[0], -p[1]) in shape:
                shape.remove(p)
                shape.remove((-p[0], -p[1]))
    return sorted(list(shape))


def _rotate_offset(offset, rotation_type):
    dr, dc = offset
    if rotation_type == 1:
        # 90 deg clockwise: (dr,dc) -> (dc, -dr)
        return (dc, -dr)
    if rotation_type == 2:
        # 90 deg counterclockwise: (dr,dc) -> (-dc, dr)
        return (-dc, dr)
    # 180 deg
    return (-dr, -dc)


def generate():
    for attempt_whole in range(30):
        width = random.randint(10, 20)
        height = random.randint(10, 20)
        input_grid = common.grid(width, height, 0)
        output_grid = common.grid(width, height, 0)

        occupied_input = set()
        occupied_output = set()
        occupied_input_by_color = {1: set(), 2: set(), 3: set()}

        num_regions = random.randint(2, 4)
        regions = []
        success = True
        for _ in range(num_regions):
            size = random.choice([3, 5, 7, 9])
            shape = _build_symmetric_shape(size)

            rotation_type = random.choice([1, 2, 3])
            color_in = rotation_type
            color_out = 4 if rotation_type in (1, 2) else 5

            orig_rs = [p[0] for p in shape]
            orig_cs = [p[1] for p in shape]
            min_r_orig, max_r_orig = min(orig_rs), max(orig_rs)
            min_c_orig, max_c_orig = min(orig_cs), max(orig_cs)

            rotated = [_rotate_offset(p, rotation_type) for p in shape]
            rot_rs = [p[0] for p in rotated]
            rot_cs = [p[1] for p in rotated]
            min_r_rot, max_r_rot = min(rot_rs), max(rot_rs)
            min_c_rot, max_c_rot = min(rot_cs), max(rot_cs)

            cr_min = max(0 - min_r_orig, 0 - min_r_rot)
            cr_max = min(height - 1 - max_r_orig, height - 1 - max_r_rot)
            cc_min = max(0 - min_c_orig, 0 - min_c_rot)
            cc_max = min(width - 1 - max_c_orig, width - 1 - max_c_rot)

            if cr_min > cr_max or cc_min > cc_max:
                success = False
                break

            placed = False
            for _try in range(300):
                cr = random.randint(cr_min, cr_max)
                cc = random.randint(cc_min, cc_max)
                orig_positions = [(cr + dr, cc + dc) for (dr, dc) in shape]
                rotated_positions = [(cr + dr, cc + dc) for (dr, dc) in rotated]

                bad = False
                # check original positions don't collide with existing output shapes
                for pos in orig_positions:
                    r, c = pos
                    if not (0 <= r < height and 0 <= c < width):
                        bad = True
                        break
                    if pos in occupied_output:
                        bad = True
                        break
                if bad:
                    continue

                # check rotated positions don't collide with any existing input cell
                # and ensure they are not adjacent to existing same-color input regions (to avoid merging)
                for pos in rotated_positions:
                    r, c = pos
                    if not (0 <= r < height and 0 <= c < width):
                        bad = True
                        break
                    if pos in occupied_input:
                        bad = True
                        break
                    # adjacency check for same color
                    for drn, dcn in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        neighbor = (r + drn, c + dcn)
                        if neighbor in occupied_input_by_color[color_in]:
                            bad = True
                            break
                    if bad:
                        break
                if bad:
                    continue

                # passed checks, place the shape
                for (r, c) in rotated_positions:
                    input_grid[r][c] = color_in
                    occupied_input.add((r, c))
                    occupied_input_by_color[color_in].add((r, c))
                for (r, c) in orig_positions:
                    output_grid[r][c] = color_out
                    occupied_output.add((r, c))

                regions.append((shape, (cr, cc), rotation_type))
                placed = True
                break

            if not placed:
                success = False
                break

        if not success:
            continue

        if input_grid == output_grid:
            continue
        if len(regions) < 2:
            continue

        return {"input": input_grid, "output": output_grid}

    # fallback deterministic example
    width, height = 10, 10
    input_grid = common.grid(width, height, 0)
    output_grid = common.grid(width, height, 0)
    shape = [(0, 0), (1, 0), (-1, 0), (0, 1), (0, -1)]
    cr, cc = 4, 4
    rotation_type = 1
    for dr, dc in shape:
        rr = cr + dc
        cc2 = cc - dr
        input_grid[rr][cc2] = rotation_type
        output_grid[cr + dr][cc + dc] = 4
    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

# Solver: find connected components of colors 1,2,3 in the input, compute their centroid,
# apply the inverse rotation to map rotated pixels back to the original coordinates, and
# recolor with 4 for 90-degree rotations and 5 for 180-degree rotations.


def _inverse_map(r, c, center_r, center_c, rotation_type):
    # compute offset relative to center
    dr = r - center_r
    dc = c - center_c
    # rotation_type encodes how the original was rotated to produce the input.
    # We apply the inverse rotation to the input offset to recover the original offset.
    if rotation_type == 1:
        # input = original rotated 90deg clockwise -> inverse is 90deg counterclockwise
        # inverse: (dr,dc) -> (-dc, dr)
        new_dr = -dc
        new_dc = dr
    elif rotation_type == 2:
        # input = original rotated 90deg counterclockwise -> inverse is 90deg clockwise
        # inverse: (dr,dc) -> (dc, -dr)
        new_dr = dc
        new_dc = -dr
    else:
        # 180 deg is its own inverse
        new_dr = -dr
        new_dc = -dc
    new_r = center_r + new_dr
    new_c = center_c + new_dc
    return int(round(new_r)), int(round(new_c))


def p(input_grid):
    # convert to list of lists
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0]) if height else 0
    out = common.grid(width, height, 0)

    visited = [[False] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            color = grid_in[r][c]
            if color not in (1, 2, 3) or visited[r][c]:
                continue
            # BFS to get this connected region (4-neighbors)
            queue = [(r, c)]
            visited[r][c] = True
            region = []
            qi = 0
            while qi < len(queue):
                cr, cc = queue[qi]
                qi += 1
                region.append((cr, cc))
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid_in[nr][nc] == color:
                        visited[nr][nc] = True
                        queue.append((nr, nc))

            # compute centroid (may be integer or half-integer)
            n = len(region)
            center_r = sum(p[0] for p in region) / n
            center_c = sum(p[1] for p in region) / n

            # apply inverse rotation to every pixel of the region
            for (rr, cc) in region:
                new_r, new_c = _inverse_map(rr, cc, center_r, center_c, color)
                if 0 <= new_r < height and 0 <= new_c < width:
                    out[new_r][new_c] = 4 if color in (1, 2) else 5
    return out

