# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 7e87d6dd
Difficulty: very hard

=== Tags ===
- Color modulated logic
- Color wavefront
- Color particle emission

=== Description ===
# Color Wavefront Modulation  Input grids feature a single background color (0)
across a 10×10 to 30×30 canvas, with multiple distinct colored elements. Sources
appear as isolated cells of color 1-9, positioned away from walls and other
elements. Modulators are scattered cells of color 1-9 that alter the wavefront's
color upon contact. Obstacles are walls of color 1-9 that block wavefront
propagation. The grid contains no overlapping elements, with all sources,
modulators, and obstacles fully surrounded by background.  The output grid is
generated by simulating a wavefront propagation starting from all source cells
simultaneously. The wavefront spreads outward in all four cardinal directions
(up, down, left, right) from each source, moving only through background cells
(0). When the wavefront encounters a modulator cell, its color changes to the
modulator's color, and the wavefront continues spreading from that cell with the
new color. Obstacle cells block propagation but remain unchanged. Propagation
occurs in a breadth-first manner, with all cells at the current distance
processed before advancing to the next distance. Each background cell is colored
with the wavefront's current color at the time of first contact, and the
simulation halts when no further background cells can be reached.  The task
requires identifying all sources, tracking the wavefront's evolving color
through modulators, navigating around obstacles, and ensuring background cells
are colored exactly once by the earliest wavefront to reach them. The complexity
arises from modulator sequences that create non-linear color transitions,
obstacle placements that force pathfinding around barriers, and multiple sources
that may converge on the same background cell from different directions with
different colors. The output must preserve all sources, modulators, and
obstacles while transforming background cells according to the propagation
rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    grid = [[0] * width for _ in range(height)]
    
    valid_positions = []
    for r in range(1, height-1):
        for c in range(1, width-1):
            valid_positions.append((r, c))
    random.shuffle(valid_positions)
    
    # Place all non-obstacle non-zero cells as sources
    num_sources = random.randint(5, 15)
    sources = []
    for _ in range(num_sources):
        if not valid_positions:
            break
        pos = valid_positions.pop(0)
        sources.append(pos)
        for dr, dc in [(0,0), (1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = pos[0] + dr, pos[1] + dc
            if (nr, nc) in valid_positions:
                valid_positions.remove((nr, nc))
    
    # Place obstacles
    num_obstacles = random.randint(3, 10)
    obstacles = []
    for _ in range(num_obstacles):
        if not valid_positions:
            break
        pos = valid_positions.pop(0)
        obstacles.append(pos)
        for dr, dc in [(0,0), (1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = pos[0] + dr, pos[1] + dc
            if (nr, nc) in valid_positions:
                valid_positions.remove((nr, nc))
    
    # Assign colors
    for r, c in sources:
        grid[r][c] = random.randint(1, 8)
    for r, c in obstacles:
        grid[r][c] = 9
    
    output_grid = [[0] * width for _ in range(height)]
    visited = [[False] * width for _ in range(height)]
    queue = deque()
    
    directions = [(1,0), (-1,0), (0,1), (0,-1)]
    # Start BFS from all non-zero non-9 cells (sources)
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and grid[r][c] != 9:
                color = grid[r][c]
                output_grid[r][c] = color
                visited[r][c] = True
                queue.append((r, c, color))
    
    while queue:
        r, c, color = queue.popleft()
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            if not (0 <= nr < height and 0 <= nc < width):
                continue
            if visited[nr][nc]:
                continue
            if grid[nr][nc] == 0:
                output_grid[nr][nc] = color
                visited[nr][nc] = True
                queue.append((nr, nc, color))
            elif grid[nr][nc] == 9:
                continue
            else:
                output_grid[nr][nc] = grid[nr][nc]
                visited[nr][nc] = True
                queue.append((nr, nc, grid[nr][nc]))
    
    return {"input": grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque
def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = [[0] * width for _ in range(height)]
    visited = [[False] * width for _ in range(height)]
    queue = deque()
    directions = [(1,0), (-1,0), (0,1), (0,-1)]
    
    # Start BFS from all non-zero non-9 cells
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and input_grid[r][c] != 9:
                color = input_grid[r][c]
                output_grid[r][c] = color
                visited[r][c] = True
                queue.append((r, c, color))
    
    while queue:
        r, c, color = queue.popleft()
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                continue
            if visited[nr][nc]:
                continue
            if input_grid[nr][nc] == 0:
                output_grid[nr][nc] = color
                visited[nr][nc] = True
                queue.append((nr, nc, color))
            elif input_grid[nr][nc] == 9:
                continue
            else:
                output_grid[nr][nc] = input_grid[nr][nc]
                visited[nr][nc] = True
                queue.append((nr, nc, input_grid[nr][nc]))
    
    return output_grid
