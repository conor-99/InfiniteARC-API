# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 3ecd10e0
Difficulty: very hard

=== Tags ===
- Recursive partition
- Beam splitter
- Modular sequence
- Alternating agents
- Bring patterns close
- Paint outer ring

=== Description ===
The input grid features multiple distinct colored regions (each a contiguous
block of identical color) surrounded by a neutral background. Scattered across
the grid are beam splitter structures (thin horizontal or vertical lines of a
neutral color) that alter the trajectory of moving regions. Each region moves in
a straight line until intersecting a beam splitter, at which point it splits
into two regions moving perpendicular to each other. The direction of splitting
alternates between horizontal and vertical with each intersection (e.g.,
horizontal split → vertical split → horizontal split), creating a modular
sequence of path transformations. This recursive splitting continues until all
regions converge into adjacency, forming a single contiguous shape where no gaps
remain between previously separate regions. The "alternating agents" refer to
the dual movement paths generated by each split, which interact with subsequent
splitters to progressively bring regions closer. Once convergence occurs, the
outermost perimeter of the unified shape is painted with a fixed accent color
(e.g., yellow), while inner regions retain their original colors. The process
requires tracking multiple recursive path transformations and spatial
convergence, with beam splitters and alternating split directions creating
complex, non-linear movement patterns that must be resolved in sequence to
achieve the final clustered configuration with a painted outer boundary.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    size = random.randint(10, 20)
    grid = [[0]*size for _ in range(size)]
    
    region1_size = random.randint(3, 5)
    region2_size = random.randint(3, 5)
    
    r1, c1 = random.randint(0, size//2 - region1_size), random.randint(0, size//2 - region1_size)
    for r in range(r1, r1 + region1_size):
        for c in range(c1, c1 + region1_size):
            if r < size and c < size:
                grid[r][c] = 1
    
    r2, c2 = random.randint(size//2, size - region2_size), random.randint(size//2, size - region2_size)
    for r in range(r2, r2 + region2_size):
        for c in range(c2, c2 + region2_size):
            if r < size and c < size:
                grid[r][c] = 2
    
    output = [[0]*size for _ in range(size)]
    merged_cells = []
    
    for r in range(size):
        for c in range(size):
            if grid[r][c] != 0:
                output[r][c] = 1
                merged_cells.append((r, c))
    
    if not merged_cells:
        return {"input": grid, "output": output}
    
    min_r = min(r for r, c in merged_cells)
    max_r = max(r for r, c in merged_cells)
    min_c = min(c for r, c in merged_cells)
    max_c = max(c for r, c in merged_cells)
    
    for r in range(min_r, max_r + 1):
        for c in [min_c, max_c]:
            output[r][c] = 4
    for c in range(min_c, max_c + 1):
        for r in [min_r, max_r]:
            output[r][c] = 4
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    size = len(grid)
    
    merged_cells = []
    for r in range(size):
        for c in range(size):
            if grid[r][c] != 0:
                merged_cells.append((r, c))
    
    if not merged_cells:
        return grid
    
    min_r = min(r for r, c in merged_cells)
    max_r = max(r for r, c in merged_cells)
    min_c = min(c for r, c in merged_cells)
    max_c = max(c for r, c in merged_cells)
    
    output = [[0]*size for _ in range(size)]
    
    for r in range(min_r, max_r + 1):
        for c in range(min_c, max_c + 1):
            if (r, c) in merged_cells:
                output[r][c] = 1
    
    for r in range(min_r, max_r + 1):
        for c in [min_c, max_c]:
            output[r][c] = 4
    for c in range(min_c, max_c + 1):
        for r in [min_r, max_r]:
            output[r][c] = 4
    
    return output
