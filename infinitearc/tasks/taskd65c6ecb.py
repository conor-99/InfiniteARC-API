# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: d65c6ecb
Difficulty: hard

=== Tags ===
- Flow with decay
- Multi object alignment

=== Description ===
Input grids feature a background color (0) with multiple distinct colored
objects (e.g., horizontal lines, vertical lines, or L-shaped structures)
scattered across the grid. Each object has a clear orientation (horizontal,
vertical, or diagonal). Additionally, the grid contains "flow sources" (cells
with a starting color S) positioned away from objects. The flow propagates from
each source in a fixed initial direction (e.g., rightward), decaying by one
color value per step (e.g., red → orange → yellow → ...), until it encounters an
obstacle or the grid boundary.    The output grid requires that each flow path
aligns with the nearest object's orientation within a 3-cell radius. If multiple
objects are equally close, the flow aligns with the object having the highest
priority (e.g., horizontal > vertical > diagonal). Upon alignment, the flow
direction changes to match the object's orientation and continues propagating
with decay, ignoring obstacles that would normally block the flow (obstacles
only block the initial straight path, not the aligned path). The decay sequence
continues uninterrupted through alignment points.    The transformation must
account for multiple flows converging near the same object, ensuring no overlap
between flow paths. All objects remain visible in the output, and the background
color remains unchanged except where flows are drawn. The alignment rule is
deterministic: for any cell in a flow path, the nearest object's orientation
dictates the flow's direction at that point, overriding the initial propagation
direction.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = 15
    height = 15
    grid = [[0] * width for _ in range(height)]

    # Place horizontal objects (avoid color 5)
    for _ in range(3):
        r = random.randint(0, height-1)
        c_start = random.randint(0, width-5)
        c_end = c_start + random.randint(2, 4)
        color = random.choice([1,2,3,4,6,7,8,9])
        for c in range(c_start, c_end):
            grid[r][c] = color

    # Place vertical objects (avoid color 5)
    for _ in range(2):
        c = random.randint(0, width-1)
        r_start = random.randint(0, height-5)
        r_end = r_start + random.randint(2, 4)
        color = random.choice([1,2,3,4,6,7,8,9])
        for r in range(r_start, r_end):
            grid[r][c] = color

    # Place L-shape objects (avoid color 5)
    for _ in range(2):
        r = random.randint(0, height-3)
        c = random.randint(0, width-3)
        color = random.choice([1,2,3,4,6,7,8,9])
        for i in range(3):
            grid[r][c+i] = color
        for i in range(1, 3):
            grid[r+i][c+2] = color

    S = 5  # Fixed flow source color
    sources = []
    for _ in range(2):
        r = random.randint(0, height-1)
        c = random.randint(0, width-5)
        if grid[r][c] == 0:
            grid[r][c] = S
            sources.append((r, c))

    output = [row[:] for row in grid]

    for (r, c) in sources:
        cr, cc = r, c
        color = S
        direction = (0, 1)  # Right
        while color > 0:
            nr = cr + direction[0]
            nc = cc + direction[1]
            if not (0 <= nr < height and 0 <= nc < width):
                break

            # Find nearest object within 3 cells
            nearest_obj = None
            min_dist = 4
            for r_obj in range(height):
                for c_obj in range(width):
                    if grid[r_obj][c_obj] != 0 and grid[r_obj][c_obj] != S:
                        dist = abs(r_obj - cr) + abs(c_obj - cc)
                        if dist <= 3 and dist < min_dist:
                            min_dist = dist
                            nearest_obj = (r_obj, c_obj, grid[r_obj][c_obj])

            if nearest_obj:
                r_obj, c_obj, obj_color = nearest_obj
                is_horizontal = False
                if (c_obj > 0 and grid[r_obj][c_obj-1] == obj_color) or (c_obj < width-1 and grid[r_obj][c_obj+1] == obj_color):
                    is_horizontal = True
                is_vertical = False
                if (r_obj > 0 and grid[r_obj-1][c_obj] == obj_color) or (r_obj < height-1 and grid[r_obj+1][c_obj] == obj_color):
                    is_vertical = True
                direction = (0, 1) if is_horizontal else (1, 0)

            if output[nr][nc] == 0:
                output[nr][nc] = color - 1
                cr, cc = nr, nc
                color -= 1
            else:
                break

    return {'input': grid, 'output': output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    S = 5

    # Precompute object positions from input grid (avoiding color S)
    objects = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and input_grid[r][c] != S:
                objects.append((r, c, input_grid[r][c]))

    sources = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == S:
                sources.append((r, c))

    for (r, c) in sources:
        cr, cc = r, c
        color = S
        direction = (0, 1)
        while color > 0:
            nr = cr + direction[0]
            nc = cc + direction[1]
            if not (0 <= nr < height and 0 <= nc < width):
                break

            # Find nearest object using precomputed list
            nearest_obj = None
            min_dist = 4
            for (r_obj, c_obj, obj_color) in objects:
                dist = abs(r_obj - cr) + abs(c_obj - cc)
                if dist <= 3 and dist < min_dist:
                    min_dist = dist
                    nearest_obj = (r_obj, c_obj, obj_color)

            if nearest_obj:
                r_obj, c_obj, obj_color = nearest_obj
                is_horizontal = False
                if (c_obj > 0 and input_grid[r_obj][c_obj-1] == obj_color) or (c_obj < width-1 and input_grid[r_obj][c_obj+1] == obj_color):
                    is_horizontal = True
                is_vertical = False
                if (r_obj > 0 and input_grid[r_obj-1][c_obj] == obj_color) or (r_obj < height-1 and input_grid[r_obj+1][c_obj] == obj_color):
                    is_vertical = True
                direction = (0, 1) if is_horizontal else (1, 0)

            if grid[nr][nc] == 0:
                grid[nr][nc] = color - 1
                cr, cc = nr, nc
                color -= 1
            else:
                break

    return tuple(tuple(row) for row in grid)
