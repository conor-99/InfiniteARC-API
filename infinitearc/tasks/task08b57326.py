# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 08b57326
Difficulty: hard

=== Tags ===
- Jigsaw
- Count tiles
- Pattern deconstruction
- Take minimum

=== Description ===
The input grid features irregularly shaped regions of non-zero colors separated
by a consistent separator color (0), forming a jigsaw-like arrangement. Each
region corresponds to a "tile" in the jigsaw puzzle. The output grid is
generated by replacing every non-separator cell in a region with the minimum
color value found within that region, while preserving the separator color (0)
in all positions where it appeared in the input. The transformation requires
identifying connected regions (ignoring separator color), computing the minimum
value per region, and applying it uniformly across each region's cells. This
process involves pattern deconstruction to isolate regions from the separator
structure, followed by a minimum-value operation on each deconstructed tile.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid_input = grid(width, height, 0)
    
    regions = []
    for _ in range(2):
        r, c = random.randint(0, height-1), random.randint(0, width-1)
        region = [(r, c)]
        while len(region) < random.randint(2, 5):
            r, c = region[-1]
            directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
            random.shuffle(directions)
            found = False
            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in region:
                    region.append((nr, nc))
                    found = True
                    break
            if not found:
                break
        regions.append(region)
    
    adjacent = False
    for r1, c1 in regions[0]:
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            r2, c2 = r1 + dr, c1 + dc
            if (r2, c2) in regions[1]:
                adjacent = True
                break
        if adjacent:
            break
    if adjacent:
        return generate()
    
    for region in regions:
        colors = [random.randint(1, 9) for _ in range(len(region))]
        while len(set(colors)) == 1:
            colors = [random.randint(1, 9) for _ in range(len(region))]
        for (r, c), color in zip(region, colors):
            grid_input[r][c] = color
    
    grid_output = [row[:] for row in grid_input]
    for region in regions:
        region_colors = [grid_input[r][c] for (r, c) in region]
        min_color = min(region_colors)
        for (r, c) in region:
            grid_output[r][c] = min_color
    
    return {"input": grid_input, "output": grid_output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    visited = [[False] * width for _ in range(height)]
    output_grid = [row[:] for row in input_grid]
    
    for i in range(height):
        for j in range(width):
            if input_grid[i][j] != 0 and not visited[i][j]:
                queue = [(i, j)]
                visited[i][j] = True
                region = []
                while queue:
                    r, c = queue.pop(0)
                    region.append((r, c))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] != 0:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                min_val = min([input_grid[r][c] for r, c in region])
                for r, c in region:
                    output_grid[r][c] = min_val
    return output_grid
