# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 5da36438
Difficulty: very hard

=== Tags ===
- Pattern completion
- Hierarchical repetition
- Fractal growth
- Propagation by rule weight
- Threshold by area
- Color guessing

=== Description ===
# Fractal Pattern Completion with Hierarchical Color Propagation  Input grids
feature a partially developed fractal structure composed of multiple colors,
where each color represents a distinct hierarchical level of the pattern. The
fractal exhibits self-similarity at different scales, with smaller repeating
units embedded within larger structures. The input grid contains incomplete
sections where the next hierarchical level should be added, but key elements are
missing or overwritten by background color (0).  The transformation requires the
following steps:  1. **Identify the seed pattern**: Analyze the input to
determine the smallest fractal unit (typically the most frequent color with the
highest local density) that serves as the base for hierarchical growth.  2.
**Determine color progression**: Infer the color sequence rule (e.g., 1→2→3→...)
by examining existing color distributions and their spatial relationships within
the input. The progression may follow a cyclic pattern or depend on the
fractal's directional growth.  3. **Apply threshold-based propagation**: For
each region exceeding a visual area threshold (e.g., occupying at least 15% of
the grid's total space), propagate the next hierarchical level. The threshold is
not explicitly stated but must be deduced from the input's incomplete structure.
4. **Complete pattern with color guessing**: Fill missing sections using
hierarchical repetition (replacing each cell of color C with a scaled-down
version of the entire pattern), while selecting the next color in the inferred
sequence. The color choice must match the pattern's visual context, requiring
the solver to predict the correct color based on surrounding elements.  5.
**Ensure structural consistency**: New fractal elements must align with the
input's directional growth pattern (e.g., expanding outward from the seed in
specific quadrants) without overlapping existing structures or violating the
hierarchical repetition rule.  The output grid completes the fractal pattern by
extending the hierarchy to the next level, maintaining the input's visual
structure while applying all inferred rules. The task demands simultaneous
analysis of visual patterns, spatial relationships, and hidden color sequences,
with no explicit numerical values or pixel-level matching required.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from typing import Dict, List


def generate():
    """
    Generate a fractal-like hierarchical pattern with K levels (K=2 or 3).
    The output contains K hierarchical color levels; the input has the top level removed (set to 0).
    The pattern uses spacings that are powers of 3 (3, 9, 27) and offsets that are congruent
    across levels so the pattern is hierarchical.
    """
    # Number of hierarchical levels in the final (output) grid: 2 or 3
    K = random.choice([2, 3])

    # Spacing for each level: s_i = 3^(i+1)  (i = 0 -> 3, i = 1 -> 9, i = 2 -> 27)
    s_values = [3 ** (i + 1) for i in range(K)]

    # Choose hierarchical offsets so that offsets are congruent modulo smaller spacings
    r_offsets: List[int] = []
    c_offsets: List[int] = []
    for i, s in enumerate(s_values):
        if i == 0:
            r0 = random.randint(0, 2)
            c0 = random.randint(0, 2)
        else:
            prev_r = r_offsets[i - 1]
            prev_c = c_offsets[i - 1]
            s_prev = s_values[i - 1]
            # ensure congruence: r0 % s_prev == prev_r, choose among the three possibilities
            r0 = prev_r + s_prev * random.randint(0, 2)
            c0 = prev_c + s_prev * random.randint(0, 2)
        r_offsets.append(r0)
        c_offsets.append(c0)

    # Color progression: sequential colors modulo 9 (1..9)
    color_start = random.randint(1, 9)
    colors: List[int] = [((color_start + i - 1) % 9) + 1 for i in range(K)]

    # Ensure the grid is at least as large as the largest spacing (s_top)
    s_top = s_values[-1]
    size = random.randint(s_top, 30)

    # Build the full output grid with K levels
    output = [[0 for _ in range(size)] for _ in range(size)]
    for level in range(K):
        s = s_values[level]
        roff = r_offsets[level] % s
        coff = c_offsets[level] % s
        color = colors[level]
        # Place a pixel of "color" at every coordinate congruent to (roff, coff) modulo s
        for r in range(size):
            if (r % s) != roff:
                continue
            for c in range(size):
                if (c % s) == coff:
                    output[r][c] = color

    # Create input by removing the top level (set top-level color pixels to 0)
    top_color = colors[-1]
    input_grid = [[0 for _ in range(size)] for _ in range(size)]
    removed = 0
    for r in range(size):
        for c in range(size):
            if output[r][c] == top_color:
                input_grid[r][c] = 0
                removed += 1
            else:
                input_grid[r][c] = output[r][c]

    # Guarantee we actually removed at least one top-level pixel (should always be true given size >= s_top)
    if removed == 0:
        # As a fallback, remove one top-level position if present in bounds
        r_try = r_offsets[-1] % s_top
        c_try = c_offsets[-1] % s_top
        if r_try < size and c_try < size:
            input_grid[r_try][c_try] = 0
            removed = 1

    return {"input": input_grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import math

def p(grid):
    """
    Solve the hierarchical fractal completion:
    - Identify the most coarse (largest-spacing) color present.
    - Infer the next spacing as three times that spacing.
    - Infer the residue (offset) for the next spacing using the congruence of the coarse color
      and by choosing the candidate offset that best matches the occupancy of blocks and the
      fact that top-level positions are zeros in the input.
    - Fill zeros at coordinates that match that residue modulo the next spacing with the next color.
    """
    # Convert to mutable list of lists
    input_list = [list(row) for row in grid]
    H = len(input_list)
    W = len(input_list[0]) if H > 0 else 0

    # Collect positions for each nonzero color
    color_positions = {}
    for r in range(H):
        for c in range(W):
            v = input_list[r][c]
            if v == 0:
                continue
            color_positions.setdefault(v, []).append((r, c))

    if not color_positions:
        return input_list

    # Helper to compute gcd of pairwise differences among row and column coordinates
    def compute_gcd_of_diffs(coords):
        rows = sorted({p[0] for p in coords})
        cols = sorted({p[1] for p in coords})
        diffs = []
        for i in range(len(rows)):
            for j in range(i + 1, len(rows)):
                diffs.append(rows[j] - rows[i])
        for i in range(len(cols)):
            for j in range(i + 1, len(cols)):
                diffs.append(cols[j] - cols[i])
        if not diffs:
            return 1
        g = diffs[0]
        for d in diffs[1:]:
            g = math.gcd(g, d)
        return max(1, g)

    # Compute a spacing estimate for each color
    s_map = {}
    for color, coords in color_positions.items():
        s_map[color] = compute_gcd_of_diffs(coords)

    # Choose the color with the largest spacing (coarsest / highest hierarchical level present)
    color_max = None
    s_max = None
    for color, s in s_map.items():
        if s_max is None or s > s_max or (s == s_max and len(color_positions[color]) > len(color_positions.get(color_max, []))):
            s_max = s
            color_max = color

    if color_max is None:
        return input_list

    # Next spacing is three times the largest present spacing
    s_top = s_max * 3

    # Determine candidate residues for the top level using congruence with the coarse color
    coarse_coord = color_positions[color_max][0]
    r_res = coarse_coord[0] % s_max
    c_res = coarse_coord[1] % s_max

    # Candidate residues are r_res + k * s_max for k in {0,1,2} (but constrained to < s_top)
    r_candidates = [r_res + k * s_max for k in range(3) if (r_res + k * s_max) < s_top]
    c_candidates = [c_res + k * s_max for k in range(3) if (c_res + k * s_max) < s_top]
    if not r_candidates:
        r_candidates = [r_res % max(1, s_top)]
    if not c_candidates:
        c_candidates = [c_res % max(1, s_top)]

    # Precompute occupancy (nonzero count) for each s_top block
    nb_r = (H + s_top - 1) // s_top
    nb_c = (W + s_top - 1) // s_top
    block_occ = {}
    for br in range(nb_r):
        for bc in range(nb_c):
            r0 = br * s_top
            c0 = bc * s_top
            r1 = min((br + 1) * s_top, H)
            c1 = min((bc + 1) * s_top, W)
            cnt = 0
            for rr in range(r0, r1):
                for cc in range(c0, c1):
                    if input_list[rr][cc] != 0:
                        cnt += 1
            block_occ[(br, bc)] = cnt

    # Evaluate candidate residue pairs; prefer pairs that have many zeros at the top-level positions
    # (since the generator erases the top level in the input), break ties by block occupancy.
    best_pair = (0, 0)
    best_key = (-1, -1)  # (zero_count, occupancy_sum)
    for roff in r_candidates:
        for coff in c_candidates:
            zero_count = 0
            occ_sum = 0
            for br in range(nb_r):
                for bc in range(nb_c):
                    posr = br * s_top + roff
                    posc = bc * s_top + coff
                    if posr < H and posc < W:
                        if input_list[posr][posc] == 0:
                            zero_count += 1
                        occ_sum += block_occ[(br, bc)]
            key = (zero_count, occ_sum)
            if key > best_key:
                best_key = key
                best_pair = (roff, coff)

    roff, coff = best_pair

    # Infer the next color in the progression from the coarse color
    next_color = (color_max % 9) + 1

    # Fill zeros at the inferred top-level residue positions
    for r in range(H):
        for c in range(W):
            if input_list[r][c] == 0 and (r % s_top) == roff and (c % s_top) == coff:
                input_list[r][c] = next_color

    return input_list

