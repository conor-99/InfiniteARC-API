# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 070e9e8f
Difficulty: mediumâ€“hard

=== Tags ===
- Contouring
- Coordinate warp
- Symmetry axis completion
- Spatial signal
- Paint outer ring

=== Description ===
The input grid features a background color (0) with a distinct vertical symmetry
axis line (color 5) spanning the entire grid height. On one side of this axis
(e.g., left), a single-colored shape (color 1) is positioned such that it does
not touch the axis or grid boundaries. The shape exhibits incomplete symmetry,
with no corresponding elements on the opposite side of the axis.  The
transformation process consists of two sequential steps: First, the shape is
mirrored across the axis line to complete the symmetric pattern, creating a
fully symmetrical shape centered on the axis. Second, a single-cell-wide outer
ring (color 2) is painted around the entire completed symmetric shape, occupying
all background cells adjacent to any part of the shape's perimeter. The axis
line (color 5) remains unchanged throughout, and no other elements of the input
grid are modified. The ring must be continuous around the entire shape without
overlapping the axis or the original shape's color.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
def generate():
    width = random.randint(6, 30)
    height = random.randint(6, 30)
    axis_col = random.randint(3, width // 2)
    input_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        input_grid[r][axis_col] = 5
    possible_pixels = []
    for r in range(1, height - 1):
        for c in range(1, axis_col - 1):
            possible_pixels.append((r, c))
    if possible_pixels:
        num_pixels = random.randint(1, min(10, len(possible_pixels)))
        left_shape = random.sample(possible_pixels, num_pixels)
    else:
        left_shape = [(1, 1)]
    for r, c in left_shape:
        input_grid[r][c] = 1
    output_grid = [row[:] for row in input_grid]
    for r, c in left_shape:
        mirror_c = 2 * axis_col - c
        output_grid[r][mirror_c] = 1
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] == 1:
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and output_grid[nr][nc] == 0:
                        output_grid[nr][nc] = 2
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    axis_col = None
    for c in range(width):
        if all(input_grid[r][c] == 5 for r in range(height)):
            axis_col = c
            break
    if axis_col is None:
        return input_grid
    left_shape = []
    for r in range(height):
        for c in range(axis_col):
            if input_grid[r][c] == 1:
                left_shape.append((r, c))
    output_grid = [list(row) for row in input_grid]
    for r, c in left_shape:
        mirror_c = 2 * axis_col - c
        if 0 <= mirror_c < width:
            output_grid[r][mirror_c] = 1
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] == 1:
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and output_grid[nr][nc] == 0:
                        output_grid[nr][nc] = 2
    return output_grid
