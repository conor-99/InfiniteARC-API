# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 326d9891
Difficulty: very hard

=== Tags ===
- Magnetic path alignment
- Meta rule switching
- Source target routing

=== Description ===
Magnetic Path Alignment: Input grids depict a network of colored path segments
where each color represents a distinct magnetic polarity. Sources (e.g., red)
and targets (e.g., blue) are embedded within the grid, with path segments
forming connections between them. The magnetic alignment rule requires adjacent
segments to have complementary polarities (e.g., red connects to blue), but this
rule is dynamically altered by "switch" segments (e.g., yellow). Each switch
traversed toggles the polarity mapping: for example, red might map to green
after one switch, then to purple after another. The output grid must display the
shortest valid path from source to target, adhering to the current polarity
mapping at each segment, with path segments rendered in the source color. Non-
path elements remain unchanged, and the solution requires sequential tracking of
the polarity mapping as the path crosses multiple switches. The path must avoid
invalid connections (e.g., same polarity adjacent segments) while navigating all
switches in order, making the task highly dependent on contextual rule
application rather than static pattern recognition.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    input_grid = grid(width, height, 0)
    
    # Place source (red) at top-left
    input_grid[0][0] = 2  # red
    # Target (blue) at bottom-right
    input_grid[height-1][width-1] = 1  # blue
    
    # Random number of switches (1 or 2)
    num_switches = random.choice([1, 2])
    path_colors = [2, 1, 4]  # source, first segment, switch
    
    # Generate path sequence with random colors for switches
    for _ in range(num_switches):
        # Choose random color for next segment (not 2,1,4)
        color = random.choice([3, 5, 6, 7, 8, 9])
        path_colors.extend([color, 2])
        if _ < num_switches - 1:
            path_colors.append(4)  # Additional switch
    path_colors.append(1)  # Target
    
    # Generate path coordinates with random right/down steps
    path = []
    path.append((0, 0))  # Start
    
    # Randomly choose right steps before first switch
    right_steps = random.randint(3, width-4)
    for c in range(1, right_steps):
        path.append((0, c))
    
    # Randomly choose down steps before first switch
    down_steps = random.randint(3, height-4)
    for r in range(1, down_steps):
        path.append((r, right_steps-1))
    
    # Add remaining path to reach target
    current_r, current_c = path[-1]
    while current_r < height-1 or current_c < width-1:
        if current_r < height-1 and (random.random() > 0.5 or current_c == width-1):
            current_r += 1
        else:
            current_c += 1
        path.append((current_r, current_c))
    
    # Ensure path length matches color sequence
    if len(path) < len(path_colors):
        # Extend path with duplicates
        path.extend([path[-1]] * (len(path_colors) - len(path)))
    elif len(path) > len(path_colors):
        # Truncate path
        path = path[:len(path_colors)]
    
    # Assign colors to path cells
    for idx, (r, c) in enumerate(path):
        if idx < len(path_colors):
            input_grid[r][c] = path_colors[idx]
        
    # Create output grid: path cells become source color (2)
    output_grid = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and input_grid[r][c] != 4:
                output_grid[r][c] = 2
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    # Find source (red=2) and target (blue=1)
    source = None
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 2:
                source = (r, c)
            elif grid[r][c] == 1:
                target = (r, c)
    
    # Output: set all path cells to source color (2)
    output = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and grid[r][c] != 4:
                output[r][c] = 2
    
    return output
