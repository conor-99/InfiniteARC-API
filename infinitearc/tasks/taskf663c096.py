# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: f663c096
Difficulty: insane

=== Tags ===
- Compositional reflection
- Pattern to sequence mapping

=== Description ===
Input grids feature a continuous visual pattern composed of colored markers
arranged in a distinctive sequence (e.g., a spiral, zigzag, or nested loop) on a
uniform background. Each marker's color corresponds to a specific reflection
axis: color 1 = horizontal reflection, color 2 = vertical reflection, color 3 =
diagonal reflection (top-left to bottom-right), and color 4 = diagonal
reflection (top-right to bottom-left). The output grid is generated by
sequentially applying each reflection to the input grid, using the markers'
sequence as the transformation order. Reflections are applied cumulatively: the
first reflection is applied to the original input, the second to the result of
the first, and so on. Each reflection axis is determined solely by the marker's
color, with no reference to its position or other properties. The output grid
preserves all background elements and marker positions, but grid content (non-
background elements) is transformed according to the sequence. Reflections may
compound (e.g., a vertical reflection followed by a horizontal reflection
results in a 180Â° rotation), and the sequence length can exceed 3, requiring
solvers to track multiple transformation steps. The pattern sequence must be
identified from the grid's visual structure, and the transformation order is
strictly determined by the marker sequence's visual arrangement.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Generator for ARC task: markers along a contiguous path define a sequence
# of reflections. Background is a uniform color (0). Other colored pixels
# (5..9) are content and are transformed by the reflection sequence.


def spiral_path(n):
    path = []
    top, left, bottom, right = 0, 0, n - 1, n - 1
    while top <= bottom and left <= right:
        for c in range(left, right + 1):
            path.append((top, c))
        top += 1
        for r in range(top, bottom + 1):
            path.append((r, right))
        right -= 1
        if top <= bottom:
            for c in range(right, left - 1, -1):
                path.append((bottom, c))
            bottom -= 1
        if left <= right:
            for r in range(bottom, top - 1, -1):
                path.append((r, left))
            left += 1
    return path


def snake_path(n):
    path = []
    for r in range(n):
        if r % 2 == 0:
            for c in range(n):
                path.append((r, c))
        else:
            for c in range(n - 1, -1, -1):
                path.append((r, c))
    return path


def generate():
    # Try a few times if we accidentally produce an identity transformation
    for _attempt in range(200):
        n = random.randint(5, 12)  # square grid for safe diagonal reflections
        # choose a path shape
        path_type = random.choice(["spiral", "snake"])
        path = spiral_path(n) if path_type == "spiral" else snake_path(n)

        L = random.randint(3, min(12, len(path)))
        markers = [random.randint(1, 4) for _ in range(L)]

        # background is uniform 0
        input_grid = grid(n, n, 0)
        marker_positions = []
        for i in range(L):
            r, c = path[i]
            input_grid[r][c] = markers[i]
            marker_positions.append((r, c))
        marker_set = set(marker_positions)

        # place 1..3 colored shapes (colors 5..9) that will be transformed
        occupied = set(marker_positions)
        content_colors = [5, 6, 7, 8, 9]
        num_shapes = random.randint(1, 3)
        for s in range(num_shapes):
            shape = random.choice(["rect", "plus", "line", "dot", "blob"]) 
            color = random.choice(content_colors)
            placed = False
            for _try in range(50):
                if shape == "rect":
                    h = random.randint(1, max(1, n // 3))
                    w = random.randint(1, max(1, n // 3))
                    r0 = random.randint(0, n - h)
                    c0 = random.randint(0, n - w)
                    pts = [(r0 + dr, c0 + dc) for dr in range(h) for dc in range(w)]
                elif shape == "plus":
                    arm = random.randint(1, max(1, n // 4))
                    if arm >= n // 2:
                        arm = max(1, n // 4)
                    if arm >= n:
                        arm = 1
                    r0 = random.randint(arm, n - 1 - arm)
                    c0 = random.randint(arm, n - 1 - arm)
                    pts = [(r0, c0)]
                    for a in range(1, arm + 1):
                        pts.append((r0 + a, c0))
                        pts.append((r0 - a, c0))
                        pts.append((r0, c0 + a))
                        pts.append((r0, c0 - a))
                elif shape == "line":
                    horiz = random.choice([True, False])
                    if horiz:
                        r0 = random.randint(0, n - 1)
                        length = random.randint(1, max(1, n // 2))
                        c0 = random.randint(0, n - length)
                        pts = [(r0, c0 + i) for i in range(length)]
                    else:
                        c0 = random.randint(0, n - 1)
                        length = random.randint(1, max(1, n // 2))
                        r0 = random.randint(0, n - length)
                        pts = [(r0 + i, c0) for i in range(length)]
                elif shape == "blob":
                    k = random.randint(1, max(1, n // 3))
                    pts = []
                    for _ in range(k):
                        pt = (random.randint(0, n - 1), random.randint(0, n - 1))
                        pts.append(pt)
                else:  # dot
                    pts = [(random.randint(0, n - 1), random.randint(0, n - 1))]

                # ensure none of these pts overlap markers
                if any(p in occupied for p in pts):
                    continue
                # place
                for (r, c) in pts:
                    input_grid[r][c] = color
                    occupied.add((r, c))
                placed = True
                break
            # if not placed, skip this shape

        # gather content pixels (non-background, non-markers)
        content = []
        for r in range(n):
            for c in range(n):
                v = input_grid[r][c]
                if v != 0 and v not in (1, 2, 3, 4):
                    content.append((r, c, v))
        # sort deterministically row-major
        content.sort(key=lambda t: (t[0], t[1]))

        # function to reflect a point on an n x n grid by axis code
        def reflect_point(pt, axis):
            r, c = pt
            if axis == 1:  # horizontal (top<->bottom)
                return (n - 1 - r, c)
            if axis == 2:  # vertical (left<->right)
                return (r, n - 1 - c)
            if axis == 3:  # main diagonal (r,c) -> (c,r)
                return (c, r)
            if axis == 4:  # anti-diagonal (top-right to bottom-left)
                return (n - 1 - c, n - 1 - r)
            return (r, c)

        # apply the reflections in sequence, updating content positions
        current = [(r, c, v) for (r, c, v) in content]
        for axis in markers:
            newmap = {}
            # iterate in deterministic order
            for (r, c, v) in sorted(current, key=lambda t: (t[0], t[1])):
                r2, c2 = reflect_point((r, c), axis)
                # do not overwrite marker positions; skip such placements
                if (r2, c2) in marker_set:
                    continue
                newmap[(r2, c2)] = v
            # create new content list sorted row-major
            current = [(rr, cc, newmap[(rr, cc)]) for (rr, cc) in sorted(newmap.keys())]

        # build output grid: background (0), markers in original positions, and transformed content
        output_grid = grid(n, n, 0)
        for (r, c), col in zip(path[:L], markers):
            output_grid[r][c] = col
        for (r, c, v) in current:
            output_grid[r][c] = v

        # ensure output is different from input (otherwise try again)
        if output_grid != input_grid:
            return {"input": input_grid, "output": output_grid}

    # Fallback (should almost never happen): make at least one pixel move by forcing one reflection
    n = 5
    input_grid = grid(n, n, 0)
    input_grid[0][0] = 1
    input_grid[0][1] = 5
    output_grid = grid(n, n, 0)
    output_grid[0][0] = 1
    output_grid[n - 1][1] = 5
    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list
    mat = [list(row) for row in input_grid]
    H = len(mat)
    W = len(mat[0]) if H else 0
    if H == 0 or W == 0:
        return tuple(tuple(row) for row in mat)

    # identify markers (1..4)
    markers = {}
    marker_positions = []
    for r in range(H):
        for c in range(W):
            v = mat[r][c]
            if 1 <= v <= 4:
                markers[(r, c)] = v
                marker_positions.append((r, c))

    # if no markers, nothing to do
    if not markers:
        return tuple(tuple(row) for row in mat)

    # determine background color as the most common non-marker color
    freq = {}
    for r in range(H):
        for c in range(W):
            v = mat[r][c]
            if 1 <= v <= 4:
                continue
            freq[v] = freq.get(v, 0) + 1
    # pick most frequent non-marker value as background
    if freq:
        background = max(freq.items(), key=lambda x: (x[1], -x[0]))[0]
    else:
        background = 0

    # build adjacency among markers (4-neighbor)
    marker_set = set(marker_positions)
    neighbors = {pos: [] for pos in marker_positions}
    for (r, c) in marker_positions:
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nbr = (r + dr, c + dc)
            if nbr in marker_set:
                neighbors[(r, c)].append(nbr)

    # find endpoints (degree 1). If none, pick the lexicographically smallest marker as start
    endpoints = [pos for pos, nbrs in neighbors.items() if len(nbrs) == 1]
    if endpoints:
        start = min(endpoints)
    else:
        start = min(marker_positions)

    # traverse the chain deterministically from start
    order = [start]
    visited = {start}
    cur = start
    while True:
        nexts = [nbr for nbr in neighbors[cur] if nbr not in visited]
        if not nexts:
            break
        # deterministic choice (there should be at most one unvisited neighbor in a simple path)
        cur = min(nexts)
        visited.add(cur)
        order.append(cur)

    # sequence of reflection axes (colors)
    seq = [markers[pos] for pos in order]

    # collect content pixels (non-background, non-markers)
    content = []
    for r in range(H):
        for c in range(W):
            v = mat[r][c]
            if v != background and not (1 <= v <= 4):
                content.append((r, c, v))
    # deterministic ordering
    content.sort(key=lambda t: (t[0], t[1]))

    # reflection helper (works for square grids; generator creates square grids)
    def reflect_point(r, c, axis):
        if axis == 1:  # horizontal
            return (H - 1 - r, c)
        if axis == 2:  # vertical
            return (r, W - 1 - c)
        if axis == 3:  # main diagonal
            return (c, r)
        if axis == 4:  # anti-diagonal
            return (W - 1 - c, H - 1 - r)
        return (r, c)

    # apply reflections in sequence to content
    current = [(r, c, v) for (r, c, v) in content]
    for axis in seq:
        newmap = {}
        for (r, c, v) in sorted(current, key=lambda t: (t[0], t[1])):
            r2, c2 = reflect_point(r, c, axis)
            # skip if landing on a marker
            if (r2, c2) in marker_set:
                continue
            newmap[(r2, c2)] = v
        # convert to list sorted row-major
        current = [(rr, cc, newmap[(rr, cc)]) for (rr, cc) in sorted(newmap.keys())]

    # compose output grid: background, markers, then content
    out = [[background for _ in range(W)] for _ in range(H)]
    for (r, c), col in markers.items():
        out[r][c] = col
    for (r, c, v) in current:
        out[r][c] = v

    return tuple(tuple(row) for row in out)

