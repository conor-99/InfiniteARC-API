# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: fdb1c593
Difficulty: hard

=== Tags ===
- Synchronized bounce
- Color permutation
- Enlarge image

=== Description ===
Input grids are small (3×3 to 7×7) with a uniform background color (0) and
multiple distinct colored objects (1–9) positioned along a grid of
vertical/horizontal alignment lines. Each object moves in a fixed direction
(determined by its position: left-edge objects move right, top-edge objects move
down, etc.) until it hits a boundary, at which point it bounces (reverses
direction) and undergoes a color permutation. The color permutation follows a
fixed cyclic pattern (e.g., 1→2→3→1 for colors 1–3, with other colors cycling
independently) that must be deduced from input-output pairs.   The output grid
is a 2× enlarged version of the input, where each input cell becomes a 2×2
block. Objects that bounced during the transformation have their permuted colors
displayed in their new positions within the 2×2 blocks. Background cells remain
unchanged (color 0). The enlargement ensures bounce paths and color transitions
are clearly visible without overlap. Crucially, the permutation cycle must be
inferred from the input-output examples, as it varies per task instance and is
not explicitly stated. The transformation requires synchronizing movement (all
objects move one step per frame), applying color permutations upon bounce, and
scaling the grid—making it challenging to deduce the hidden permutation logic
and coordinate the multi-step transformation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    n = random.randint(3, 7)
    input_grid = grid(n, n, 0)
    
    def permute_color(c):
        return (c % 9) + 1

    # Place objects on edges (non-corner)
    for col in range(1, n-1):
        if random.choice([True, False]):
            color = random.randint(1, 9)
            input_grid[0][col] = color  # Top edge
    for row in range(1, n-1):
        if random.choice([True, False]):
            color = random.randint(1, 9)
            input_grid[row][0] = color  # Left edge
    
    # Create transformed grid (same size as input)
    transformed = grid(n, n, 0)
    
    # Move objects to boundary and permute colors
    for r in range(n):
        for c in range(n):
            if input_grid[r][c] != 0:
                color = input_grid[r][c]
                if r == 0 and 1 <= c <= n-2:  # Top edge
                    transformed[n-1][c] = permute_color(color)
                elif c == 0 and 1 <= r <= n-2:  # Left edge
                    transformed[r][n-1] = permute_color(color)
                # Other edges not handled for simplicity
    
    # Scale to 2x
    output_grid = []
    for r in range(n):
        row1 = []
        row2 = []
        for c in range(n):
            color = transformed[r][c]
            row1.extend([color, color])
            row2.extend([color, color])
        output_grid.append(row1)
        output_grid.append(row2)
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    n = len(input_grid)
    
    def permute_color(c):
        return (c % 9) + 1

    transformed = [[0] * n for _ in range(n)]
    
    for r in range(n):
        for c in range(n):
            color = input_grid[r][c]
            if color != 0:
                if r == 0 and 1 <= c < n-1:  # Top edge
                    transformed[n-1][c] = permute_color(color)
                elif c == 0 and 1 <= r < n-1:  # Left edge
                    transformed[r][n-1] = permute_color(color)
    
    # Scale to 2x
    output = []
    for r in range(n):
        row1 = []
        row2 = []
        for c in range(n):
            color = transformed[r][c]
            row1.extend([color, color])
            row2.extend([color, color])
        output.append(row1)
        output.append(row2)
    
    return output
