# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 659e7a3d
Difficulty: hard

=== Tags ===
- Directed field
- Oscillating rule
- Infer hidden grid
- Dual grid translation

=== Description ===
The input grid is a large, complex 25×25 grid with a background color (0) and
multiple distinct non-background colors (1–9) arranged in a dense, non-uniform
pattern. Embedded within this grid is a hidden 3×3 "directed field" grid, which
is not visible but can be inferred by identifying all cells of a specific color
(e.g., color 7) and sorting their coordinates into a 3×3 grid structure based on
row and column indices. Each cell in this hidden grid encodes a direction (0:
up, 1: down, 2: left, 3: right).   The transformation requires two critical
steps: first, inferring the hidden grid from the input's color pattern, then
applying a dual grid translation with an oscillating rule. For each non-
background symbol in row-major order (top-left to bottom-right), the symbol is
moved based on the direction from the hidden grid cell corresponding to its
position (using modulo-3 indexing for the hidden grid). However, the movement
direction oscillates: for the nth symbol (starting at n=1), odd-numbered symbols
move in the direction specified by the hidden grid, while even-numbered symbols
move in the opposite direction. The output grid reflects all symbols at their
new positions after this transformation, with all other cells retaining the
background color. This task demands simultaneous pattern recognition (to infer
the hidden grid), sequential application of an oscillating rule, and multi-step
spatial reasoning to map input to output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    size = 25
    input_grid = grid(size, size, 0)
    
    # Place 9 color 7 cells at (i*8, j*8) for i,j in 0-2
    for i in range(3):
        for j in range(3):
            r, c = i * 8, j * 8
            input_grid[r][c] = 7

    # Generate non-background symbols (colors 1-6,8-9)
    symbols = []
    for r in range(size):
        for c in range(size):
            if input_grid[r][c] != 7 and random.random() < 0.05:
                color = random.choice([1,2,3,4,5,6,8,9])
                input_grid[r][c] = color
                symbols.append((r, c, color))

    # Sort symbols by row-major order
    symbols.sort(key=lambda x: (x[0], x[1]))
    output_grid = grid(size, size, 0)
    
    # Apply transformation
    for idx, (r, c, color) in enumerate(symbols):
        n = idx + 1
        i, j = r % 3, c % 3
        direction = (i + j) % 4
        if n % 2 == 1:
            direction = direction
        else:
            direction = (direction + 2) % 4
        
        dr, dc = 0, 0
        if direction == 0: dr = -1
        elif direction == 1: dc = 1
        elif direction == 2: dr = 1
        elif direction == 3: dc = -1
        
        new_r, new_c = r + dr, c + dc
        if 0 <= new_r < size and 0 <= new_c < size:
            output_grid[new_r][new_c] = color

    return {
        'input': input_grid,
        'output': output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(grid):
    size = len(grid)
    input_grid = [list(row) for row in grid]
    output_grid = [[0] * size for _ in range(size)]
    
    symbols = []
    for r in range(size):
        for c in range(size):
            if input_grid[r][c] != 0 and input_grid[r][c] != 7:
                symbols.append((r, c, input_grid[r][c]))
    
    symbols.sort(key=lambda x: (x[0], x[1]))
    
    for idx, (r, c, color) in enumerate(symbols):
        n = idx + 1
        i, j = r % 3, c % 3
        direction = (i + j) % 4
        if n % 2 == 1:
            direction = direction
        else:
            direction = (direction + 2) % 4
        
        dr, dc = 0, 0
        if direction == 0: dr = -1
        elif direction == 1: dc = 1
        elif direction == 2: dr = 1
        elif direction == 3: dc = -1
        
        new_r, new_c = r + dr, c + dc
        if 0 <= new_r < size and 0 <= new_c < size:
            output_grid[new_r][new_c] = color
    
    return output_grid
