# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: b3d64f72
Difficulty: easy

=== Tags ===
- Grid coloring
- Shape guessing
- Collapse duplicates

=== Description ===
The task involves input grids where each color represents a connected region
(shape) of identical values. The output grid is generated by retaining only the
first occurrence (in row-major order) of each connected region for every color,
and replacing all other cells of the same color with 0. This process collapses
duplicate shapes of the same color into a single instance while maintaining the
grid's original dimensions. For example, if a color appears in two separate
connected regions, only the region encountered first during row-major traversal
remains intact, and all other cells of that color are set to 0. The rule relies
solely on visual shape recognition and position, avoiding numerical computations
or pixel-level matching.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

from common import grid
import random
from collections import deque

def generate():
    w = random.randint(2, 30)
    h = random.randint(2, 30)
    input_grid = grid(w, h, 0)
    color = random.randint(1, 9)
    positions = []
    for _ in range(2):
        while True:
            r = random.randint(0, h-1)
            c = random.randint(0, w-1)
            if not positions:
                positions.append((r, c))
                break
            for (pr, pc) in positions:
                if abs(r - pr) <= 1 and abs(c - pc) <= 1:
                    break
            else:
                positions.append((r, c))
                break
    for (r, c) in positions:
        input_grid[r][c] = color
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] == 0:
                input_grid[r][c] = random.randint(0, 9)
    
    output_grid = [row[:] for row in input_grid]
    
    for color_val in range(1, 10):
        first_cell = None
        for r in range(h):
            for c in range(w):
                if input_grid[r][c] == color_val:
                    first_cell = (r, c)
                    break
            if first_cell:
                break
        if first_cell is None:
            continue
        visited = [[False] * w for _ in range(h)]
        queue = deque([first_cell])
        visited[first_cell[0]][first_cell[1]] = True
        connected_region = []
        while queue:
            r, c = queue.popleft()
            connected_region.append((r, c))
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and input_grid[nr][nc] == color_val:
                    visited[nr][nc] = True
                    queue.append((nr, nc))
        for r in range(h):
            for c in range(w):
                if input_grid[r][c] == color_val and (r, c) not in connected_region:
                    output_grid[r][c] = 0
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque
def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    if not input_grid:
        return []
    h = len(input_grid)
    w = len(input_grid[0])
    output_grid = [row[:] for row in input_grid]
    for color_val in range(1, 10):
        first_cell = None
        for r in range(h):
            for c in range(w):
                if input_grid[r][c] == color_val:
                    first_cell = (r, c)
                    break
            if first_cell:
                break
        if first_cell is None:
            continue
        visited = [[False] * w for _ in range(h)]
        queue = deque([first_cell])
        visited[first_cell[0]][first_cell[1]] = True
        connected_region = []
        while queue:
            r, c = queue.popleft()
            connected_region.append((r, c))
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and input_grid[nr][nc] == color_val:
                    visited[nr][nc] = True
                    queue.append((nr, nc))
        for r in range(h):
            for c in range(w):
                if input_grid[r][c] == color_val and (r, c) not in connected_region:
                    output_grid[r][c] = 0
    return output_grid
