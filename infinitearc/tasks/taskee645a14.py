# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: ee645a14
Difficulty: hard

=== Tags ===
- Staircase construction

=== Description ===
The input grid features a uniform background color overlaid with multiple
horizontal line segments (treads) of a single non-background color, each
spanning consecutive columns within a single row. These treads form a partial
staircase structure where each subsequent tread (positioned higher in the grid)
begins at the exact column where the tread below ends. The treads are spaced
vertically with background cells separating them, and no two treads share rows
or columns. The input contains distractor horizontal segments that do not align
with the staircase pattern.   The output grid replicates all input elements
while adding vertical line segments (risers) of a distinct color between each
pair of consecutive treads. Each riser connects the end column of a lower tread
to the start column of the upper tread (which matches by design), spanning all
background rows between them. The risers must precisely align with the endpoints
of the treads, forming a continuous staircase without overlapping existing
treads or background elements. The transformation requires identifying the
unique sequence of treads (sorted by vertical position from bottom to top),
verifying endpoint alignment, and drawing risers only between valid consecutive
pairs. This task is challenging due to the need to distinguish the correct
staircase sequence from distractor segments and the precision required in
vertical positioning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Grid size
    width = random.randint(8, 20)
    height = random.randint(8, 20)

    # Background color
    bg = random.randint(0, 9)

    # Choose a tread color different from background
    colors = list(range(0, 10))
    tread_choices = [c for c in colors if c != bg]
    tread_color = random.choice(tread_choices)

    # Determine a feasible number of treads based on width and height constraints
    max_n_width = (width - 1) // 2
    max_n_height = (height + 1) // 2
    max_n = min(5, max_n_width, max_n_height)
    if max_n < 3:
        max_n = 3
    n = random.randint(3, max_n)

    # Choose vertical gaps (each gap >= 2 rows so there's at least one background row)
    while True:
        gaps = [random.randint(2, 4) for _ in range(n - 1)]
        total_gaps = sum(gaps)
        if total_gaps <= height - 1:
            bottom = random.randint(total_gaps, height - 1)
            rows = [bottom]
            cur = bottom
            for g in gaps:
                cur -= g
                rows.append(cur)
            break

    # Choose horizontal lengths for the treads so they fit in width
    min_len = 3
    min_sum = min_len * n
    max_sum = width - 1 + n  # derived constraint so the staircase fits
    if max_sum < min_sum:
        # relax the minimum length if the grid is tight (very unlikely with chosen bounds)
        min_len = 2
        min_sum = min_len * n
        if max_sum < min_sum:
            # As a last resort, reduce n so things fit
            n = max(3, (width - 1) // 2)
            min_len = 2
            min_sum = min_len * n

    sum_l = random.randint(min_sum, max_sum)
    # Start with minimum lengths and distribute the extra randomly
    lengths = [min_len] * n
    extra = sum_l - min_len * n
    for _ in range(extra):
        lengths[random.randrange(n)] += 1

    # Compute the maximum possible start column for the bottom tread
    s0_max = width - 1 - sum(lengths) + n
    if s0_max < 0:
        # If somehow negative, clamp starts to 0 and shrink lengths to fit
        s0 = 0
        while sum(lengths) > width - 1 + n:
            # reduce any length greater than min_len
            for i in range(n):
                if sum(lengths) <= width - 1 + n:
                    break
                if lengths[i] > min_len:
                    lengths[i] -= 1
    else:
        s0 = random.randint(0, s0_max)

    # Build the staircase treads: each next starts at the previous end
    treads = []
    end_prev = s0
    for i in range(n):
        start = end_prev if i > 0 else s0
        end = start + lengths[i] - 1
        if end >= width:
            end = width - 1
        treads.append((rows[i], start, end))
        end_prev = end

    # Ensure treads are sorted from bottom to top for later use
    treads.sort(key=lambda x: x[0], reverse=True)

    # Compute riser columns (end columns of the lower treads in each pair)
    riser_columns = set(e for _, _, e in treads[:-1])

    # Generate distractor horizontal segments (different color than the treads)
    distractors = []
    num_distractors = random.randint(2, 6)
    used_rows = set(r for r, _, _ in treads)
    # Choose distractor colors without replacement to avoid forming multi-row chains of the same color
    available_dcolors = [c for c in range(1, 10) if c != tread_color and c != bg]
    random.shuffle(available_dcolors)
    dcolors_pool = available_dcolors[:num_distractors]
    for color_choice in dcolors_pool:
        row_candidates = [r for r in range(height) if r not in used_rows]
        if not row_candidates:
            break
        row = random.choice(row_candidates)
        used_rows.add(row)
        # pick a segment that does not use any riser column
        attempts = 0
        while True:
            attempts += 1
            d_len = random.randint(1, min(4, width))
            start = random.randint(0, max(0, width - d_len))
            end = start + d_len - 1
            if riser_columns.isdisjoint(range(start, end + 1)):
                break
            if attempts > 20:
                # give up on avoiding riser columns and pick a safe short segment near left
                start = 0
                end = min(start + d_len - 1, width - 1)
                if riser_columns.isdisjoint(range(start, end + 1)):
                    break
                # if still bad, skip this distractor
                start = None
                break
        if start is None:
            continue
        distractors.append((row, start, end, color_choice))

    # Create the input grid
    input_grid = [[bg] * width for _ in range(height)]
    for (r, s, e) in treads:
        for c in range(s, e + 1):
            input_grid[r][c] = tread_color
    for (r, s, e, col) in distractors:
        for c in range(s, e + 1):
            input_grid[r][c] = col

    # Choose riser color deterministically as the smallest color (1..9) not present in the input
    used_colors = set()
    for row in input_grid:
        used_colors.update(row)
    riser_color = None
    for c in range(1, 10):
        if c not in used_colors:
            riser_color = c
            break
    if riser_color is None:
        # fallback: any color not equal to bg
        riser_color = next(c for c in range(1, 10) if c != bg)

    # Create the output grid by drawing risers (vertical segments) between consecutive treads
    output_grid = [list(r) for r in input_grid]
    for i in range(len(treads) - 1):
        r_low, s_low, e_low = treads[i]
        r_up, s_up, e_up = treads[i + 1]
        # Draw only on the background rows between the two treads (exclusive endpoints)
        col = e_low
        for r in range(r_up + 1, r_low):
            output_grid[r][col] = riser_color

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert tuple-of-tuples to list-of-lists if necessary
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Find background as the most frequent color
    all_vals = [v for row in grid for v in row]
    bg = max(set(all_vals), key=all_vals.count)

    # Find all horizontal segments for each non-background color
    segments_by_color = {}
    for r in range(height):
        c = 0
        while c < width:
            val = grid[r][c]
            if val == bg:
                c += 1
                continue
            color = val
            start = c
            while c < width and grid[r][c] == color:
                c += 1
            end = c - 1
            segments_by_color.setdefault(color, []).append((r, start, end))

    # Helper to check that vertical column 'col' between rows r_upper and r_lower is all background
    def is_clear_vertical(col, r_upper, r_lower):
        if r_lower - r_upper < 2:
            return False
        for rr in range(r_upper + 1, r_lower):
            if grid[rr][col] != bg:
                return False
        return True

    # For each color find the longest valid staircase chain (bottom-to-top)
    best_chain_overall = []
    for color, segs in segments_by_color.items():
        # sort bottom->top (larger row index first)
        segs_sorted = sorted(segs, key=lambda x: x[0], reverse=True)

        from functools import lru_cache

        @lru_cache(None)
        def best_from_index(idx):
            r0, s0, e0 = segs_sorted[idx]
            best_suffix = []
            for j in range(idx + 1, len(segs_sorted)):
                rj, sj, ej = segs_sorted[j]
                # check alignment and clear vertical path
                if sj == e0 and is_clear_vertical(e0, rj, r0):
                    candidate = best_from_index(j)
                    if len(candidate) > len(best_suffix):
                        best_suffix = candidate
            return [segs_sorted[idx]] + best_suffix

        best_chain_for_color = []
        for i in range(len(segs_sorted)):
            chain = best_from_index(i)
            if len(chain) > len(best_chain_for_color):
                best_chain_for_color = chain
            elif len(chain) == len(best_chain_for_color) and len(chain) > 0:
                # tie break: prefer chain with more total pixels
                if sum(c[2] - c[1] + 1 for c in chain) > sum(c[2] - c[1] + 1 for c in best_chain_for_color):
                    best_chain_for_color = chain

        if len(best_chain_for_color) > len(best_chain_overall):
            best_chain_overall = best_chain_for_color
        elif len(best_chain_for_color) == len(best_chain_overall) and len(best_chain_for_color) > 0:
            if sum(c[2] - c[1] + 1 for c in best_chain_for_color) > sum(c[2] - c[1] + 1 for c in best_chain_overall):
                best_chain_overall = best_chain_for_color

    # If no valid chain found, return input unchanged
    if len(best_chain_overall) < 2:
        return grid

    # Choose riser color deterministically as the smallest color (1..9) not present in the input
    used_colors = set(all_vals)
    riser_color = None
    for c in range(1, 10):
        if c not in used_colors:
            riser_color = c
            break
    if riser_color is None:
        # fallback
        riser_color = next(c for c in range(1, 10) if c != bg)

    # Draw risers between consecutive segments in the best staircase chain
    output = [row[:] for row in grid]
    # Ensure chain sorted bottom->top
    best_chain_overall = sorted(best_chain_overall, key=lambda x: x[0], reverse=True)
    for i in range(len(best_chain_overall) - 1):
        r_low, s_low, e_low = best_chain_overall[i]
        r_up, s_up, e_up = best_chain_overall[i + 1]
        col = e_low
        for r in range(r_up + 1, r_low):
            output[r][col] = riser_color

    return output

