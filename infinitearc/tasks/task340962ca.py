# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 340962ca
Difficulty: hard

=== Tags ===
- Recursive mirroring
- Move object to nearest corner

=== Description ===
Input grids feature a single background color (e.g., 0) and a contiguous non-
background object (a connected region of a distinct color) that is fully
surrounded by background with no adjacency to grid edges. The output grid is
generated by two sequential transformations: first, moving the object to the
nearest corner (top-left, top-right, bottom-left, or bottom-right) based on
Manhattan distance from the object's centroid to each corner (with priority
order resolving ties), then applying recursive mirroring. The mirroring process
reflects the object across the vertical and horizontal grid midlines, and each
resulting copy undergoes further reflection across the new midlines of its
mirrored position, repeating until no new mirror placements can occur within
grid boundaries. This creates a symmetric fractal-like pattern expanding from
the corner, with all mirrored copies remaining non-overlapping and contiguous,
while background cells retain their original values.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random
import collections

global_history = set()


def _serialize_pair(inp, out):
    # Serialize as tuple of tuples for hashing
    return (tuple(tuple(row) for row in inp), tuple(tuple(row) for row in out))


def generate():
    """
    Generate a pair (input, output) following the task spec.
    The generator ensures the object is contiguous, placed away from edges,
    then moved to the nearest corner and recursively mirrored (with flips)
    into non-overlapping tiles until no more placements fit.
    """
    tries = 0
    while True:
        tries += 1
        # Choose reasonably sized grid so there is room for mirroring
        W = random.randint(6, 20)
        H = random.randint(6, 20)

        # Create a contiguous object inside the inner (W-2)x(H-2) area
        max_area = (W - 2) * (H - 2)
        if max_area < 2:
            continue
        S = random.randint(2, min(12, max_area))
        # continuous_creature(size, width, height)
        obj = common.continuous_creature(S, width=W - 2, height=H - 2)
        # Shift into the interior so it does not touch the outer edges
        object_pixels = [(r + 1, c + 1) for (r, c) in obj]

        # Bounding box of original object (in its current interior position)
        min_r = min(r for r, c in object_pixels)
        max_r = max(r for r, c in object_pixels)
        min_c = min(c for r, c in object_pixels)
        max_c = max(c for r, c in object_pixels)
        h_obj = max_r - min_r + 1
        w_obj = max_c - min_c + 1

        # Ensure there is room to place at least one mirror copy (so output != input)
        if not (W >= 2 * w_obj or H >= 2 * h_obj):
            # try again (object too large relative to grid to mirror)
            if tries > 200:
                # fallback: shrink the object by regenerating with a smaller size
                S = max(2, min(12, max_area // 2))
                obj = common.continuous_creature(S, width=W - 2, height=H - 2)
                object_pixels = [(r + 1, c + 1) for (r, c) in obj]
                min_r = min(r for r, c in object_pixels)
                max_r = max(r for r, c in object_pixels)
                min_c = min(c for r, c in object_pixels)
                max_c = max(c for r, c in object_pixels)
                h_obj = max_r - min_r + 1
                w_obj = max_c - min_c + 1
                if not (W >= 2 * w_obj or H >= 2 * h_obj):
                    # if still no room, restart with new grid
                    continue
            else:
                continue

        # Compute centroid to choose nearest corner (Manhattan distance)
        S_actual = len(object_pixels)
        centroid_r = sum(r for r, c in object_pixels) / S_actual
        centroid_c = sum(c for r, c in object_pixels) / S_actual

        corners = [("tl", 0, 0), ("tr", 0, W - 1), ("bl", H - 1, 0), ("br", H - 1, W - 1)]
        distances = []
        for idx, (name, cr, cc) in enumerate(corners):
            d = abs(centroid_r - cr) + abs(centroid_c - cc)
            distances.append((d, idx, name))
        distances.sort(key=lambda x: (x[0], x[1]))
        chosen_corner = distances[0][2]

        # Compute shift to move object's bounding box to the chosen corner
        if chosen_corner == "tl":
            new_top, new_left = 0, 0
        elif chosen_corner == "tr":
            new_top, new_left = 0, W - w_obj
        elif chosen_corner == "bl":
            new_top, new_left = H - h_obj, 0
        else:  # br
            new_top, new_left = H - h_obj, W - w_obj

        shift_r = new_top - min_r
        shift_c = new_left - min_c
        shifted_pixels = [(r + shift_r, c + shift_c) for (r, c) in object_pixels]

        # Relative shape within its bounding box (base orientation)
        shape_rel = sorted(((r - new_top, c - new_left) for (r, c) in shifted_pixels))

        # BFS to place mirrored copies. Each tile is a placement with a top-left anchor and flips
        occ = set()
        queue = collections.deque()
        # orientation flags: fx==True means horizontally flipped relative to base
        #                         fy==True means vertically flipped relative to base
        queue.append((new_top, new_left, False, False))
        visited = set()

        while queue:
            top, left, fx, fy = queue.popleft()
            if (top, left, fx, fy) in visited:
                continue
            visited.add((top, left, fx, fy))

            # Build tile pixels for this orientation
            tile_pixels = []
            out_of_bounds = False
            for dr, dc in shape_rel:
                dr_m = (h_obj - 1 - dr) if fy else dr
                dc_m = (w_obj - 1 - dc) if fx else dc
                r = top + dr_m
                c = left + dc_m
                if r < 0 or r >= H or c < 0 or c >= W:
                    out_of_bounds = True
                    break
                tile_pixels.append((r, c))
            if out_of_bounds:
                continue

            # Overlap check
            if any(p in occ for p in tile_pixels):
                continue

            # Accept this tile and mark its pixels
            for p in tile_pixels:
                occ.add(p)

            # enqueue neighbors (right, down, and diagonal) with flipped orientations
            # Right neighbor (mirror across vertical boundary) toggles horizontal flip
            nr, nc, nfx, nfy = top, left + w_obj, (not fx), fy
            if 0 <= nc and nc + w_obj <= W and 0 <= nr and nr + h_obj <= H:
                queue.append((nr, nc, nfx, nfy))
            # Down neighbor (mirror across horizontal boundary) toggles vertical flip
            nr, nc, nfx, nfy = top + h_obj, left, fx, (not fy)
            if 0 <= nr and nr + h_obj <= H and 0 <= nc and nc + w_obj <= W:
                queue.append((nr, nc, nfx, nfy))
            # Diagonal neighbor toggles both
            nr, nc, nfx, nfy = top + h_obj, left + w_obj, (not fx), (not fy)
            if 0 <= nr and nr + h_obj <= H and 0 <= nc and nc + w_obj <= W:
                queue.append((nr, nc, nfx, nfy))

        # Ensure output differs from input (at least one mirrored copy added)
        initial_set = set(object_pixels)
        if occ == initial_set:
            # try again to get a configuration that produces mirrors
            if tries > 200:
                # If we are unlucky, restart with new dimensions
                continue
            else:
                continue

        # Build input and output grids
        color = common.random_color(exclude=[0])
        input_grid = common.grid(W, H, 0)
        for (r, c) in object_pixels:
            input_grid[r][c] = color

        output_grid = common.grid(W, H, 0)
        for (r, c) in occ:
            output_grid[r][c] = color

        pair = _serialize_pair(input_grid, output_grid)
        if pair in global_history:
            # Rare duplicate, try again
            if tries > 500:
                # give up and return (shouldn't happen)
                global_history.add(pair)
                return {"input": input_grid, "output": output_grid}
            continue
        global_history.add(pair)
        return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
import collections

def p(input_grid):
    # Convert tuple inputs to mutable lists
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]

    H = len(input_grid)
    W = len(input_grid[0])

    # Find the object color and its pixels (non-background)
    color = None
    pixels = []
    for r in range(H):
        for c in range(W):
            v = input_grid[r][c]
            if v != 0:
                if color is None:
                    color = v
                pixels.append((r, c))

    if not pixels:
        return common.grid(W, H, 0)

    # Centroid (for Manhattan distance) --- use arithmetic mean of coordinates
    centroid_r = sum(r for r, c in pixels) / len(pixels)
    centroid_c = sum(c for r, c in pixels) / len(pixels)

    corners = [("tl", 0, 0), ("tr", 0, W - 1), ("bl", H - 1, 0), ("br", H - 1, W - 1)]
    distances = []
    for idx, (name, cr, cc) in enumerate(corners):
        d = abs(centroid_r - cr) + abs(centroid_c - cc)
        distances.append((d, idx, name))
    distances.sort(key=lambda x: (x[0], x[1]))
    chosen_corner = distances[0][2]

    # Bounding box of the object
    min_r = min(r for r, c in pixels)
    max_r = max(r for r, c in pixels)
    min_c = min(c for r, c in pixels)
    max_c = max(c for r, c in pixels)
    h_obj = max_r - min_r + 1
    w_obj = max_c - min_c + 1

    # Compute new top-left for the object moved to the chosen corner
    if chosen_corner == "tl":
        new_top, new_left = 0, 0
    elif chosen_corner == "tr":
        new_top, new_left = 0, W - w_obj
    elif chosen_corner == "bl":
        new_top, new_left = H - h_obj, 0
    else:  # br
        new_top, new_left = H - h_obj, W - w_obj

    shift_r = new_top - min_r
    shift_c = new_left - min_c
    shifted_pixels = [(r + shift_r, c + shift_c) for (r, c) in pixels]

    # Base shape relative to its bounding box
    shape_rel = sorted(((r - new_top, c - new_left) for (r, c) in shifted_pixels))

    # BFS with orientation flips to place mirrored copies
    occ = set()
    queue = collections.deque()
    queue.append((new_top, new_left, False, False))
    visited = set()

    while queue:
        top, left, fx, fy = queue.popleft()
        if (top, left, fx, fy) in visited:
            continue
        visited.add((top, left, fx, fy))

        # build tile pixels for this orientation
        tile_pixels = []
        out_of_bounds = False
        for dr, dc in shape_rel:
            dr_m = (h_obj - 1 - dr) if fy else dr
            dc_m = (w_obj - 1 - dc) if fx else dc
            r = top + dr_m
            c = left + dc_m
            if r < 0 or r >= H or c < 0 or c >= W:
                out_of_bounds = True
                break
            tile_pixels.append((r, c))
        if out_of_bounds:
            continue
        if any(p in occ for p in tile_pixels):
            continue
        for p in tile_pixels:
            occ.add(p)

        # enqueue neighbors (right, down, diagonal)
        nr, nc, nfx, nfy = top, left + w_obj, (not fx), fy
        if 0 <= nc and nc + w_obj <= W and 0 <= nr and nr + h_obj <= H:
            queue.append((nr, nc, nfx, nfy))
        nr, nc, nfx, nfy = top + h_obj, left, fx, (not fy)
        if 0 <= nr and nr + h_obj <= H and 0 <= nc and nc + w_obj <= W:
            queue.append((nr, nc, nfx, nfy))
        nr, nc, nfx, nfy = top + h_obj, left + w_obj, (not fx), (not fy)
        if 0 <= nr and nr + h_obj <= H and 0 <= nc and nc + w_obj <= W:
            queue.append((nr, nc, nfx, nfy))

    # Build output grid
    output = common.grid(W, H, 0)
    for (r, c) in occ:
        output[r][c] = color
    return output

