# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 78190ad5
Difficulty: very hard

=== Tags ===
- Mirror twins
- Infer hidden grid
- Interleaved streams
- Procedural painting

=== Description ===
Input grids feature a complex, interleaved network of multiple color streams
forming a continuous circuit, where each stream is a connected path of a single
color with no overlapping streams of the same color. The circuit appears as a
single flow but is composed of two mirror-image sub-circuits (mirror twins)
along a diagonal axis. The visible sub-circuit occupies the top-left quadrant of
the grid, while its mirror twin (hidden grid) is implied in the bottom-right
quadrant but obscured by background color and overlapping streams. The mirror
axis is the main diagonal (top-left to bottom-right), but the hidden sub-
circuit's path is not directly visible due to partial occlusion by other
streams.  To generate the output, the solver must: 1. **Infer the hidden grid**:
Identify the mirror path by reflecting each cell of the visible sub-circuit
across the main diagonal. Fill in missing cells in the hidden sub-circuit to
maintain path continuity, ensuring the hidden path is a perfect mirror of the
visible path. This requires tracing the flow direction through interleaved
streams and deducing connections where the input is ambiguous. 2. **Apply
procedural painting**: Recolor all cells in the inferred hidden grid using a
color distinct from all colors present in the visible sub-circuit. The color is
chosen as the first unused color in the palette (0â€“9) based on the input's color
usage. 3. **Integrate interleaved streams**: Combine the visible sub-circuit and
the recolored hidden sub-circuit into the output, preserving the original
interleaving pattern. The output visually displays both mirror twins as
distinct, connected streams with the hidden twin clearly distinguishable by its
new color, while background cells are adjusted to emphasize the mirror
relationship.  The task demands spatial reasoning to deduce the hidden mirror
axis and path, procedural color mapping without numerical dependencies, and
disentangling complex interleaved flows to reveal the mirror twins. The
difficulty arises from the need to simultaneously process multiple layers of
visual ambiguity, ensuring the inferred hidden grid aligns with the input's flow
continuity and color constraints.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    n = random.randint(10, 30)
    C = random.randint(1, 9)
    
    def generate_path_in_upper_triangle(n, start=(0,1)):
        path = [start]
        visited = set(path)
        r, c = start
        while len(path) < 20:
            directions = []
            if c + 1 < n and r < c + 1 and (r, c+1) not in visited:
                directions.append((0, 1))
            if r + 1 < c and r + 1 < n and (r+1, c) not in visited:
                directions.append((1, 0))
            if r - 1 >= 0 and (r-1, c) not in visited:
                directions.append((-1, 0))
            if c - 1 > r and c - 1 >= 0 and (r, c-1) not in visited:
                directions.append((0, -1))
            if not directions:
                break
            dr, dc = random.choice(directions)
            r += dr
            c += dc
            path.append((r, c))
            visited.add((r, c))
        return path
    
    path = generate_path_in_upper_triangle(n)
    input_grid = common.grid(n, n, 0)
    for (r, c) in path:
        input_grid[r][c] = C
    D = 1
    while D == C:
        D += 1
    output_grid = [row[:] for row in input_grid]
    for (r, c) in path:
        output_grid[c][r] = D
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    n = len(input_list)
    upper_path = []
    for r in range(n):
        for c in range(n):
            if r < c and input_list[r][c] != 0:
                upper_path.append((r, c))
    if not upper_path:
        return input_list
    C = input_list[upper_path[0][0]][upper_path[0][1]]
    colors = set(range(1,10))
    D = min(colors - {C})
    for (r, c) in upper_path:
        input_list[c][r] = D
    return input_list
