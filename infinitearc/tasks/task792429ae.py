# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 792429ae
Difficulty: medium–hard

=== Tags ===
- Local rule cascade

=== Description ===
Cascading Color Shifts  Input grids are 10×10 to 20×20 grids with a single
background color (0). They contain multiple distinct contiguous colored regions
(1-9), each forming a 4-connected block of identical color. Regions are strictly
separated by at least one background cell in all directions (no diagonal
adjacency or touching regions).  The transformation applies two sequential local
rule cascades:  1. **Expansion Phase**: For every cell in a colored region,
examine its four orthogonal neighbors. If a neighbor is background (0), it
becomes part of the region (color set to the original region's color). This
expansion occurs simultaneously across all regions, but only affects background
cells not adjacent to any other region (preventing overlap between regions).  2.
**Color Shift Phase**: After expansion, every cell that was background before
expansion (now part of a region due to expansion) changes color to the next
color in the cyclic sequence (1→2, 2→3, ..., 9→1). Cells that were already part
of the original regions remain unchanged.  The output grid displays the original
regions unchanged, with newly expanded cells shifted to the next color in
sequence. Background cells remain 0, and no cell is overwritten if it was not
part of the expansion. This creates a distinct "halo" of shifted color around
each original region, with the halo color determined by the original region's
color.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random


def generate():
    """Generate an input/output pair for the "Cascading Color Shifts" task.

    Rules implemented:
    - Grid size: random between 10 and 20.
    - Place 3-5 distinct contiguous (4-connected) regions using common.continuous_creature.
    - Regions use unique colors from 1..9 and are placed so that every colored cell
      has an empty (0) neighbor in its 8-neighborhood from other regions (i.e., regions
      do not touch even diagonally).
    - Expansion phase (simultaneous): any background cell that has orthogonal neighbors
      belonging to exactly one region color is considered expanded into that region.
      If a background cell is adjacent orthogonally to two or more distinct region
      colors, it is not expanded.
    - Color shift phase: cells that were background and became part of a region via
      expansion change to the next color in the cyclic sequence 1->2->...->9->1.

    The function retries generation if placement fails or if no expansion occurred
    (ensures input != output).
    """
    # Try a few times to create a valid layout
    for attempt in range(200):
        size = random.randint(10, 20)
        grid = common.grid(size, size, 0)

        # Number of regions and their distinct colors
        num_regions = random.randint(3, 5)
        colors = random.sample(list(range(1, 10)), num_regions)

        placement_ok = True
        # Try to place each region
        for color in colors:
            placed = False
            # Several attempts to place this region
            for _ in range(200):
                # Local bounding box for the creature
                max_box = min(6, max(2, size - 2))
                local_h = random.randint(2, max_box)
                local_w = random.randint(2, max_box)
                max_cells = local_h * local_w
                # region size at least 3, at most min(12, max_cells)
                region_size = random.randint(3, min(12, max_cells))
                # Create a contiguous creature in the local box
                try:
                    local_pixels = common.continuous_creature(region_size, width=local_w, height=local_h)
                except Exception:
                    continue

                # Choose an anchor so the local box fits entirely in the grid
                r0 = random.randint(0, size - local_h)
                c0 = random.randint(0, size - local_w)
                global_pixels = [(r0 + pr, c0 + pc) for pr, pc in local_pixels]

                # Ensure pixels lie within grid (they should) and that every pixel's
                # 8-neighborhood is background (so regions are separated by at least one
                # background cell in all directions).
                ok = True
                for gr, gc in global_pixels:
                    if not (0 <= gr < size and 0 <= gc < size):
                        ok = False
                        break
                    for dr in (-1, 0, 1):
                        for dc in (-1, 0, 1):
                            nr, nc = gr + dr, gc + dc
                            if 0 <= nr < size and 0 <= nc < size and grid[nr][nc] != 0:
                                ok = False
                                break
                        if not ok:
                            break
                    if not ok:
                        break

                if not ok:
                    continue

                # Place the region
                for gr, gc in global_pixels:
                    grid[gr][gc] = color
                placed = True
                break

            if not placed:
                placement_ok = False
                break

        if not placement_ok:
            continue

        # Compute output according to the two-phase rule description
        inp = [row[:] for row in grid]
        out = [row[:] for row in grid]
        expanded_any = False
        for r in range(size):
            for c in range(size):
                if inp[r][c] != 0:
                    continue
                neighbor_colors = set()
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < size and 0 <= nc < size:
                        v = inp[nr][nc]
                        if v != 0:
                            neighbor_colors.add(v)
                # Expand only if exactly one distinct neighboring region color
                if len(neighbor_colors) == 1:
                    orig_color = next(iter(neighbor_colors))
                    new_color = (orig_color % 9) + 1
                    out[r][c] = new_color
                    expanded_any = True

        # Ensure at least one expansion happened (so input != output)
        if not expanded_any:
            continue

        return {"input": inp, "output": out}

    # If we fail to construct after many attempts, raise an error
    raise RuntimeError("Failed to generate a valid grid after many attempts")



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    rows = len(grid)
    cols = len(grid[0]) if rows > 0 else 0

    inp = [row[:] for row in grid]
    out = [row[:] for row in grid]

    # For every background cell in the original input, check orthogonal neighbors.
    # If exactly one distinct non-zero neighbor color is present, this cell was
    # expanded and then shifted to the next color in the 1..9 cyclic sequence.
    for r in range(rows):
        for c in range(cols):
            if inp[r][c] != 0:
                continue
            neighbor_colors = set()
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = r + dr, c + dc
                if 0 <= nr < rows and 0 <= nc < cols:
                    v = inp[nr][nc]
                    if v != 0:
                        neighbor_colors.add(v)
            if len(neighbor_colors) == 1:
                orig_color = next(iter(neighbor_colors))
                out[r][c] = (orig_color % 9) + 1
    return out

