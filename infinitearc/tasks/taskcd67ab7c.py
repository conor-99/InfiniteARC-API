# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: cd67ab7c
Difficulty: easy

=== Tags ===
- Divide by n
- Create grid
- Contouring

=== Description ===
The task involves transforming an input grid into an output grid by first
identifying the contour of the shape within the input (where a cell is part of
the contour if it is non-zero and has at least one adjacent zero cell in the
four cardinal directions), then downsampling the contour grid by a fixed factor
`n` (e.g., `n=2`). The output grid's dimensions are derived by dividing the
input grid's width and height by `n`, resulting in a smaller grid. Each cell in
the output grid corresponds to an `n√ón` block in the input grid; if any cell
within the block belongs to the contour, the output cell is set to 1, otherwise
0. The input grids are always sized such that their dimensions are divisible by
`n`, ensuring the output grid has integer dimensions. This process combines
contour detection with grid downsampling, creating a clear, rule-based
transformation suitable for an easy difficulty task.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    width = random.choice(range(2, 31, 2))
    height = random.choice(range(2, 31, 2))
    input_grid = [[0] * width for _ in range(height)]
    start_x = random.randint(0, width - 2)
    start_y = random.randint(0, height - 2)
    for r in range(start_y, start_y + 2):
        for c in range(start_x, start_x + 2):
            input_grid[r][c] = 1
    contour = [[0] * width for _ in range(height)]
    directions = [(1,0), (-1,0), (0,1), (0,-1)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                has_zero = False
                for dr, dc in directions:
                    nr, nc = r + dr, c + dc
                    if nr < 0 or nr >= height or nc < 0 or nc >= width:
                        has_zero = True
                        break
                    if input_grid[nr][nc] == 0:
                        has_zero = True
                        break
                if has_zero:
                    contour[r][c] = 1
    output_width = width // 2
    output_height = height // 2
    output_grid = [[0] * output_width for _ in range(output_height)]
    for r in range(output_height):
        for c in range(output_width):
            for br in range(2):
                for bc in range(2):
                    if contour[r*2 + br][c*2 + bc] == 1:
                        output_grid[r][c] = 1
                        break
                if output_grid[r][c] == 1:
                    break
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    contour = [[0] * width for _ in range(height)]
    directions = [(1,0), (-1,0), (0,1), (0,-1)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                has_zero = False
                for dr, dc in directions:
                    nr, nc = r + dr, c + dc
                    if nr < 0 or nr >= height or nc < 0 or nc >= width:
                        has_zero = True
                        break
                    if input_grid[nr][nc] == 0:
                        has_zero = True
                        break
                if has_zero:
                    contour[r][c] = 1
    output_width = width // 2
    output_height = height // 2
    output_grid = [[0] * output_width for _ in range(output_height)]
    for r in range(output_height):
        for c in range(output_width):
            for br in range(2):
                for bc in range(2):
                    if contour[r*2 + br][c*2 + bc] == 1:
                        output_grid[r][c] = 1
                        break
                if output_grid[r][c] == 1:
                    break
    return output_grid
