# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: b4b06e85
Difficulty: hard

=== Tags ===
- Connect all dots of same color
- Adapt image to grid
- Collapse duplicates

=== Description ===
Input grids feature scattered single-cell "dots" of various non-zero colors
(1-9) on a background of color 0. Each dot of the same color is disconnected
from other dots of that color, forming isolated points with no adjacency. The
output grid must transform these inputs by connecting all dots of each color
into a single contiguous region while adhering to strict geometric and priority
rules.  For each color present in the input, the output grid fills the minimal
axis-aligned rectangle that encloses all dots of that color. This rectangle is
defined by the smallest and largest row and column indices where the color
appears. All cells within this rectangle are set to the color, creating a solid
block that inherently connects all original dots through the filled area.   To
resolve overlapping rectangles (where multiple colors' bounding boxes
intersect), the output applies a deterministic priority: colors are processed in
ascending numerical order (1, then 2, up to 9). When rectangles overlap, the
cell adopts the color of the earliest processed color (lowest number) in the
priority order. This "collapsing" of overlapping regions ensures no visual
ambiguity while preserving the geometric essence of the input's dot
distribution.  The output grid retains only these filled rectangles, with all
other cells set to background (color 0). This process adapts the scattered dot
pattern into a structured grid-based representation, where connectivity is
achieved through the bounding box geometry, and duplicate regions are resolved
via priority-based collapse. The transformation requires careful analysis of
spatial distribution, color prioritization, and geometric containmentâ€”making it
a challenging task that demands multi-step reasoning about spatial relationships
and rule application.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 20)
    height = random.randint(5, 20)
    input_grid = [[0] * width for _ in range(height)]
    num_colors = random.randint(2, 5)
    colors = random.sample(range(1, 10), num_colors)
    for color in colors:
        count = random.randint(2, 5)
        positions = []
        while len(positions) < count:
            r = random.randint(0, height-1)
            c = random.randint(0, width-1)
            if any(abs(r - pr) + abs(c - pc) == 1 for pr, pc in positions):
                continue
            positions.append((r, c))
        for r, c in positions:
            input_grid[r][c] = color
    output_grid = [[0] * width for _ in range(height)]
    for color in range(1, 10):
        positions = []
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == color:
                    positions.append((r, c))
        if not positions:
            continue
        min_row = min(r for r, c in positions)
        max_row = max(r for r, c in positions)
        min_col = min(c for r, c in positions)
        max_col = max(c for r, c in positions)
        for r in range(min_row, max_row + 1):
            for c in range(min_col, max_col + 1):
                if output_grid[r][c] == 0:
                    output_grid[r][c] = color
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    output = [[0] * width for _ in range(height)]
    for color in range(1, 10):
        positions = []
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == color:
                    positions.append((r, c))
        if not positions:
            continue
        min_row = min(r for r, c in positions)
        max_row = max(r for r, c in positions)
        min_col = min(c for r, c in positions)
        max_col = max(c for r, c in positions)
        for r in range(min_row, max_row + 1):
            for c in range(min_col, max_col + 1):
                if output[r][c] == 0:
                    output[r][c] = color
    return output
