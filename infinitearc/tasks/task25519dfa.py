# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 25519dfa
Difficulty: insane

=== Tags ===
- Shape to color encoding
- Wave reflection
- Tile mutation rule
- Remove singletons

=== Description ===
Input grids are 20×20 grids with a background of color 0, containing multiple
connected regions (shapes) of distinct non-zero colors (1–9). Each color encodes
a functional role: color 1 (emitters) generate diagonal waves, color 2
(reflectors) cause wave reflection, color 3 (mutators) redirect waves, and
colors 4–9 represent passive shapes.   The transformation applies four
sequential operations:   1. **Wave Propagation**: Emitters (color 1) emit four
diagonal waves (northeast, southeast, northwest, southwest) from their central
cell. Waves travel until hitting a reflector (color 2), mutator (color 3), or
grid boundary. Upon hitting a reflector, waves reflect with angle preservation
and adopt the reflector’s color. Mutators absorb waves and redirect them in the
opposite direction, adopting the mutator’s color.   2. **Tile Mutation**: All
cells adjacent (orthogonally or diagonally) to active wave paths change to the
wave’s current color, overriding background (0) and lower-numbered colors.   3.
**Singleton Removal**: Any cell with no orthogonally adjacent cells of the same
color is removed (set to background 0).   4. **Passive Shape Preservation**:
Passive shapes (colors 4–9) remain visually intact but may be altered by
mutations or singleton removal if adjacent to wave paths.    The output grid
reflects all transformations: waves are reflected, tiles are mutated, singletons
are removed, and passive shapes retain their structure unless overwritten. The
process requires identifying color roles, tracking wave interactions, and
applying sequential rules to complex, interconnected grid patterns.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common
from typing import List, Tuple, Dict


def generate() -> Dict[str, List[List[int]]]:
    size = 20
    grid = [[0 for _ in range(size)] for _ in range(size)]

    def place_passive_shape(color: int):
        # Try to place a contiguous creature (sprite) somewhere without overlap
        for _ in range(300):
            region_w = random.randint(2, 6)
            region_h = random.randint(2, 6)
            max_cells = region_w * region_h
            size_region = random.randint(3, min(12, max_cells))
            pixels = common.continuous_creature(size_region, width=region_w, height=region_h)
            if not pixels:
                continue
            maxr = max(p[0] for p in pixels)
            maxc = max(p[1] for p in pixels)
            top = random.randint(0, size - 1 - maxr)
            left = random.randint(0, size - 1 - maxc)
            conflict = False
            for pr, pc in pixels:
                if grid[top + pr][left + pc] != 0:
                    conflict = True
                    break
            if conflict:
                continue
            for pr, pc in pixels:
                grid[top + pr][left + pc] = color
            return True
        return False

    def place_segment(color: int, length: int, orientation: str) -> bool:
        # orientation: 'h' or 'v'
        for _ in range(300):
            if orientation == 'h':
                r = random.randint(0, size - 1)
                c = random.randint(0, size - length)
                cells = [(r, c + i) for i in range(length)]
            else:
                r = random.randint(0, size - length)
                c = random.randint(0, size - 1)
                cells = [(r + i, c) for i in range(length)]
            conflict = any(grid[r0][c0] != 0 for (r0, c0) in cells)
            if conflict:
                continue
            for (r0, c0) in cells:
                grid[r0][c0] = color
            return True
        return False

    # Place passive shapes (colors 4-9)
    for color in range(4, 10):
        place_passive_shape(color)

    # Place a few reflectors (color 2) as small line segments
    for _ in range(random.randint(1, 3)):
        orient = random.choice(['h', 'v'])
        length = random.choice([2, 3])
        placed = place_segment(2, length, orient)
        if not placed:
            # fallback try with length 1
            place_segment(2, 1, random.choice(['h', 'v']))

    # Place a couple of mutators (color 3)
    for _ in range(random.randint(1, 3)):
        orient = random.choice(['h', 'v'])
        length = random.choice([1, 2])
        placed = place_segment(3, length, orient)
        if not placed:
            place_segment(3, 1, 'h')

    # Place emitters (color 1). Ensure each emitter has at least one diagonal empty neighbor so waves can propagate.
    emitter_positions = []
    need_emitters = random.randint(1, 3)
    tries = 0
    while len(emitter_positions) < need_emitters and tries < 1000:
        tries += 1
        r = random.randint(1, size - 2)
        c = random.randint(1, size - 2)
        if grid[r][c] != 0:
            continue
        diag_ok = False
        for dr, dc in [(-1, -1), (-1, 1), (1, -1), (1, 1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < size and 0 <= nc < size and grid[nr][nc] == 0:
                diag_ok = True
                break
        if not diag_ok:
            continue
        grid[r][c] = 1
        emitter_positions.append((r, c))

    # If we failed to place any emitters, force one in an empty spot
    if not emitter_positions:
        for r in range(size):
            for c in range(size):
                if grid[r][c] == 0:
                    grid[r][c] = 1
                    emitter_positions.append((r, c))
                    break
            if emitter_positions:
                break

    input_grid = [row[:] for row in grid]

    # Now simulate the exact same rules that the solver will use to produce the output.
    # We implement a local solver here to compute the output so the generator does not depend on the external solver function.
    from collections import deque

    def solve_local(in_grid: List[List[int]]) -> List[List[int]]:
        rows = len(in_grid)
        cols = len(in_grid[0])
        original = [row[:] for row in in_grid]

        # collect emitters
        emitters = []
        for rr in range(rows):
            for cc in range(cols):
                if original[rr][cc] == 1:
                    emitters.append((rr, cc))

        directions = [(-1, 1), (1, 1), (-1, -1), (1, -1)]
        q = deque()
        for er, ec in emitters:
            for dr, dc in directions:
                nr, nc = er + dr, ec + dc
                if 0 <= nr < rows and 0 <= nc < cols:
                    q.append((nr, nc, dr, dc, 1))

        visited = set()
        wave_path = {}  # maps (r,c) -> max color seen on path

        while q:
            r0, c0, dr, dc, cur_col = q.popleft()
            state = (r0, c0, dr, dc, cur_col)
            if state in visited:
                continue
            visited.add(state)

            cell_color = original[r0][c0]
            # Determine the wave's color at this cell (it adopts reflector/mutator color if present)
            if cell_color == 2:
                wave_color = 2
            elif cell_color == 3:
                wave_color = 3
            else:
                wave_color = cur_col

            prev = wave_path.get((r0, c0), 0)
            if wave_color > prev:
                wave_path[(r0, c0)] = wave_color

            if cell_color == 2:
                # reflector: determine orientation by neighboring reflector cells
                horiz = (c0 - 1 >= 0 and original[r0][c0 - 1] == 2) or (c0 + 1 < cols and original[r0][c0 + 1] == 2)
                vert = (r0 - 1 >= 0 and original[r0 - 1][c0] == 2) or (r0 + 1 < rows and original[r0 + 1][c0] == 2)
                if horiz and not vert:
                    nd_r, nd_c = -dr, dc
                elif vert and not horiz:
                    nd_r, nd_c = dr, -dc
                elif horiz and vert:
                    nd_r, nd_c = -dr, -dc
                else:
                    nd_r, nd_c = -dr, -dc
                nr, nc = r0 + nd_r, c0 + nd_c
                if 0 <= nr < rows and 0 <= nc < cols:
                    q.append((nr, nc, nd_r, nd_c, 2))
                continue

            if cell_color == 3:
                # mutator: reverse direction and adopt mutator's color
                nd_r, nd_c = -dr, -dc
                nr, nc = r0 + nd_r, c0 + nd_c
                if 0 <= nr < rows and 0 <= nc < cols:
                    q.append((nr, nc, nd_r, nd_c, 3))
                continue

            # Otherwise continue straight
            nr, nc = r0 + dr, c0 + dc
            if 0 <= nr < rows and 0 <= nc < cols:
                q.append((nr, nc, dr, dc, cur_col))

        # Apply tile mutation: all 8-neighbors (not the path cell itself) to the wave color if they are lower-numbered
        mutated = [row[:] for row in original]
        for (r1, c1), col in list(wave_path.items()):
            for dr in (-1, 0, 1):
                for dc in (-1, 0, 1):
                    if dr == 0 and dc == 0:
                        continue
                    nr, nc = r1 + dr, c1 + dc
                    if 0 <= nr < rows and 0 <= nc < cols:
                        if mutated[nr][nc] < col:
                            mutated[nr][nc] = col

        # Singleton removal (orthogonal neighbors only)
        output = [row[:] for row in mutated]
        for r2 in range(rows):
            for c2 in range(cols):
                val = mutated[r2][c2]
                if val == 0:
                    continue
                has_neighbor = False
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = r2 + dr, c2 + dc
                    if 0 <= nr < rows and 0 <= nc < cols and mutated[nr][nc] == val:
                        has_neighbor = True
                        break
                if not has_neighbor:
                    output[r2][c2] = 0

        return output

    output_grid = solve_local(input_grid)

    # Ensure input != output; if equal, try to perturb grid slightly by adding another emitter in empty place
    attempts = 0
    while input_grid == output_grid and attempts < 50:
        attempts += 1
        placed = False
        for r in range(size):
            for c in range(size):
                if input_grid[r][c] == 0:
                    input_grid[r][c] = 1
                    placed = True
                    break
            if placed:
                break
        output_grid = solve_local(input_grid)

    # Final safety: ensure they are different
    if input_grid == output_grid:
        # If still identical (very unlikely), flip a background cell adjacent to an emitter to color 1 so wave will mutate it
        for r in range(1, size - 1):
            for c in range(1, size - 1):
                if input_grid[r][c] == 0:
                    input_grid[r][c] = 1
                    output_grid = solve_local(input_grid)
                    break
            if input_grid != output_grid:
                break

    return {"input": [row[:] for row in input_grid], "output": [row[:] for row in output_grid]}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from typing import Tuple, List
from collections import deque


def p(input_grid: Tuple[Tuple[int, ...], ...]) -> Tuple[Tuple[int, ...], ...]:
    grid = [list(row) for row in input_grid]
    rows, cols = len(grid), len(grid[0])
    original = [row[:] for row in grid]

    # collect emitters
    emitters = []
    for r in range(rows):
        for c in range(cols):
            if original[r][c] == 1:
                emitters.append((r, c))

    directions = [(-1, 1), (1, 1), (-1, -1), (1, -1)]
    q = deque()
    for er, ec in emitters:
        for dr, dc in directions:
            nr, nc = er + dr, ec + dc
            if 0 <= nr < rows and 0 <= nc < cols:
                q.append((nr, nc, dr, dc, 1))

    visited = set()
    wave_path = {}  # maps (r,c) -> max color seen on path

    while q:
        r0, c0, dr, dc, cur_col = q.popleft()
        state = (r0, c0, dr, dc, cur_col)
        if state in visited:
            continue
        visited.add(state)

        cell_color = original[r0][c0]
        # Determine the wave's color at this cell (it adopts reflector/mutator color if present)
        if cell_color == 2:
            wave_color = 2
        elif cell_color == 3:
            wave_color = 3
        else:
            wave_color = cur_col

        prev = wave_path.get((r0, c0), 0)
        if wave_color > prev:
            wave_path[(r0, c0)] = wave_color

        if cell_color == 2:
            # reflector: determine orientation by neighboring reflector cells
            horiz = (c0 - 1 >= 0 and original[r0][c0 - 1] == 2) or (c0 + 1 < cols and original[r0][c0 + 1] == 2)
            vert = (r0 - 1 >= 0 and original[r0 - 1][c0] == 2) or (r0 + 1 < rows and original[r0 + 1][c0] == 2)
            if horiz and not vert:
                nd_r, nd_c = -dr, dc
            elif vert and not horiz:
                nd_r, nd_c = dr, -dc
            elif horiz and vert:
                nd_r, nd_c = -dr, -dc
            else:
                nd_r, nd_c = -dr, -dc
            nr, nc = r0 + nd_r, c0 + nd_c
            if 0 <= nr < rows and 0 <= nc < cols:
                q.append((nr, nc, nd_r, nd_c, 2))
            continue

        if cell_color == 3:
            # mutator: reverse direction and adopt mutator's color
            nd_r, nd_c = -dr, -dc
            nr, nc = r0 + nd_r, c0 + nd_c
            if 0 <= nr < rows and 0 <= nc < cols:
                q.append((nr, nc, nd_r, nd_c, 3))
            continue

        # Otherwise continue straight
        nr, nc = r0 + dr, c0 + dc
        if 0 <= nr < rows and 0 <= nc < cols:
            q.append((nr, nc, dr, dc, cur_col))

    # Apply tile mutation: all 8-neighbors (not the path cell itself) to the wave color if they are lower-numbered
    mutated = [row[:] for row in original]
    for (r1, c1), col in list(wave_path.items()):
        for dr in (-1, 0, 1):
            for dc in (-1, 0, 1):
                if dr == 0 and dc == 0:
                    continue
                nr, nc = r1 + dr, c1 + dc
                if 0 <= nr < rows and 0 <= nc < cols:
                    if mutated[nr][nc] < col:
                        mutated[nr][nc] = col

    # Singleton removal (orthogonal neighbors only)
    output = [row[:] for row in mutated]
    for r2 in range(rows):
        for c2 in range(cols):
            val = mutated[r2][c2]
            if val == 0:
                continue
            has_neighbor = False
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = r2 + dr, c2 + dc
                if 0 <= nr < rows and 0 <= nc < cols and mutated[nr][nc] == val:
                    has_neighbor = True
                    break
            if not has_neighbor:
                output[r2][c2] = 0

    return tuple(tuple(row) for row in output)

