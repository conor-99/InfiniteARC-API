# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: d4c2f30e
Difficulty: insane

=== Tags ===
- Symbol grounding
- Proximity guessing
- Color guessing
- Pattern coloring

=== Description ===
The task involves identifying a primary symbol color (S) based on the largest
connected region of size ≥3 in the input grid (using 4-connectivity). If
multiple colors share the largest region size, S is the smallest color value
(color guessing). For each cell in the output grid, the color is determined by
the Manhattan distance to the nearest S cell, calculated as (S + 2 × distance)
mod 10. This requires recognizing S through connected component analysis (symbol
grounding), computing proximity to S (proximity guessing), resolving color ties
(color guessing), and applying the distance-based color pattern (pattern
coloring).
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid
def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    while width < 3 and height < 3:
        width = random.randint(1, 30)
        height = random.randint(1, 30)
    
    input_grid = grid(width, height, 0)
    S = random.randint(1, 9)
    
    if width >= 3:
        r = random.randint(0, height - 1)
        c = random.randint(0, width - 3)
        for i in range(3):
            input_grid[r][c + i] = S
    else:
        c = random.randint(0, width - 1)
        r = random.randint(0, height - 3)
        for i in range(3):
            input_grid[r + i][c] = S
    
    output_grid = [[0] * width for _ in range(height)]
    s_positions = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == S:
                s_positions.append((r, c))
    
    for r in range(height):
        for c in range(width):
            min_dist = 10**9
            for sr, sc in s_positions:
                dist = abs(r - sr) + abs(c - sc)
                if dist < min_dist:
                    min_dist = dist
            output_grid[r][c] = (S + 2 * min_dist) % 10
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    non_zero = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                non_zero.append((r, c))
    
    if not non_zero:
        return grid(width, height, 0)
    
    visited = set()
    components = {}
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    
    for r, c in non_zero:
        if (r, c) in visited:
            continue
        color = input_grid[r][c]
        stack = [(r, c)]
        visited.add((r, c))
        comp = []
        while stack:
            cr, cc = stack.pop()
            comp.append((cr, cc))
            for dr, dc in directions:
                nr, nc = cr + dr, cc + dc
                if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == color and (nr, nc) not in visited:
                    visited.add((nr, nc))
                    stack.append((nr, nc))
        if color not in components:
            components[color] = []
        components[color].append(comp)
    
    largest_size = 0
    candidates = []
    for color, comps in components.items():
        max_size = max(len(comp) for comp in comps)
        if max_size > largest_size:
            largest_size = max_size
            candidates = [color]
        elif max_size == largest_size:
            candidates.append(color)
    
    S = min(candidates)
    
    s_positions = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == S:
                s_positions.append((r, c))
    
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            min_dist = 10**9
            for sr, sc in s_positions:
                dist = abs(r - sr) + abs(c - sc)
                if dist < min_dist:
                    min_dist = dist
            output_grid[r][c] = (S + 2 * min_dist) % 10
    
    return output_grid
