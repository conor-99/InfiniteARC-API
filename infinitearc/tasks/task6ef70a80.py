# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 6ef70a80
Difficulty: medium

=== Tags ===
- Direction guessing
- Pattern differences
- Pattern moving
- Tiled majority vote

=== Description ===
The input grid contains a single connected region (pattern) of non-zero colors
on a zero-background. The direction of movement is determined by the pattern's
orientation: if the pattern's width exceeds its height (horizontal), it moves
right; if height exceeds width (vertical), it moves down. Each cell in the
pattern shifts one position in the determined direction, wrapping around the
grid edges. The output grid is formed by dividing the shifted grid into 2x2
tiles, where each tile's value is the majority non-zero color within that tile
(zeros are ignored in the majority calculation). This task requires identifying
the pattern's shape, inferring its movement direction, applying the shift, and
then applying the tiled majority vote rule.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = 2 * random.randint(2, 15)
    height = 2 * random.randint(2, 15)
    max_size = width * height
    size = random.randint(5, min(20, max_size))
    pattern = common.continuous_creature(size, width, height)
    if not pattern:
        pattern = [(0, 0)]
    color = common.random_color(exclude=[0])
    input_grid = common.grid(width, height, 0)
    for (r, c) in pattern:
        input_grid[r][c] = color
    rows = [p[0] for p in pattern]
    cols = [p[1] for p in pattern]
    min_r, max_r = min(rows), max(rows)
    min_c, max_c = min(cols), max(cols)
    bbox_width = max_c - min_c + 1
    bbox_height = max_r - min_r + 1
    direction = 'right' if bbox_width > bbox_height else 'down'
    shifted_pattern = []
    for (r, c) in pattern:
        if direction == 'right':
            new_c = (c + 1) % width
            shifted_pattern.append((r, new_c))
        else:
            new_r = (r + 1) % height
            shifted_pattern.append((new_r, c))
    shifted_grid = common.grid(width, height, 0)
    for (r, c) in shifted_pattern:
        shifted_grid[r][c] = color
    output_width = width // 2
    output_height = height // 2
    output_grid = common.grid(output_width, output_height, 0)
    for i in range(output_height):
        for j in range(output_width):
            tile_colors = []
            for dr in [0, 1]:
                for dc in [0, 1]:
                    r = i*2 + dr
                    c = j*2 + dc
                    if shifted_grid[r][c] != 0:
                        tile_colors.append(shifted_grid[r][c])
            if tile_colors:
                count = {}
                for col in tile_colors:
                    count[col] = count.get(col, 0) + 1
                majority = max(count.items(), key=lambda x: x[1])[0]
                output_grid[i][j] = majority
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    color = None
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] != 0:
                color = input_grid[r][c]
                break
        if color is not None:
            break
    if color is None:
        return input_grid
    pattern = []
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] == color:
                pattern.append((r, c))
    rows = [p[0] for p in pattern]
    cols = [p[1] for p in pattern]
    min_r, max_r = min(rows), max(rows)
    min_c, max_c = min(cols), max(cols)
    bbox_width = max_c - min_c + 1
    bbox_height = max_r - min_r + 1
    direction = 'right' if bbox_width > bbox_height else 'down'
    width = len(input_grid[0])
    height = len(input_grid)
    shifted_pattern = []
    for (r, c) in pattern:
        if direction == 'right':
            new_c = (c + 1) % width
            shifted_pattern.append((r, new_c))
        else:
            new_r = (r + 1) % height
            shifted_pattern.append((new_r, c))
    shifted_grid = common.grid(width, height, 0)
    for (r, c) in shifted_pattern:
        shifted_grid[r][c] = color
    output_width = width // 2
    output_height = height // 2
    output_grid = common.grid(output_width, output_height, 0)
    for i in range(output_height):
        for j in range(output_width):
            tile_colors = []
            for dr in [0, 1]:
                for dc in [0, 1]:
                    r = i*2 + dr
                    c = j*2 + dc
                    if shifted_grid[r][c] != 0:
                        tile_colors.append(shifted_grid[r][c])
            if tile_colors:
                count = {}
                for col in tile_colors:
                    count[col] = count.get(col, 0) + 1
                majority = max(count.items(), key=lambda x: x[1])[0]
                output_grid[i][j] = majority
    return output_grid
