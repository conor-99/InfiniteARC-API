# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 5728ea2b
Difficulty: insane

=== Tags ===
- Multi layer projection
- Expand to square canvas
- Propagate color until boundary

=== Description ===
Input grids are rectangular (width ≠ height) with a background color (0) and
multiple distinct, connected regions of non-background colors (1-9), each region
surrounded by background. Each region is a contiguous 4-connected component. The
grid dimensions range from 3×5 to 25×30, ensuring non-square inputs.  Output
grids are square (width = height = max(input_width, input_height)), with the
input placed in the top-left corner and padding filled with background. For each
non-background color region:  1. Calculate the centroid row (average row index
of all cells in the region). 2. If the centroid row is in the top half of the
input grid (row < input_height/2), the region propagates downward from its
lowest row until it meets another non-background color or the bottom boundary.
3. If the centroid row is in the bottom half (row ≥ input_height/2), the region
propagates upward from its highest row until it meets another non-background
color or the top boundary.  Propagation fills all cells in the direction of
travel until blocked, with no overlapping colors (the first propagating region
to reach a cell determines its color). The output combines all propagations,
preserving the input's original regions while expanding them according to their
directional rules. Overlapping propagation paths are resolved by the order of
region centroid rows (topmost regions propagate first), creating complex,
interwoven patterns that require multi-step geometric reasoning to predict.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    H = common.randint(3, 25)
    W = common.randint(5, 30)
    if H == W:
        W = common.randint(5, 30)
    grid = common.grid(W, H, 0)
    pixels = common.random_pixels(W, H, 0.2)
    while not pixels:
        pixels = common.random_pixels(W, H, 0.2)
    components = []
    while pixels:
        start = pixels[0]
        component = []
        queue = [start]
        pixels.remove(start)
        while queue:
            r, c = queue.pop(0)
            component.append((r, c))
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if (nr, nc) in pixels:
                    queue.append((nr, nc))
                    pixels.remove((nr, nc))
        components.append(component)
    components = components[:4]  # Ensure at most 4 regions
    colors = common.sample(range(1, 10), len(components))
    for i, component in enumerate(components):
        color = colors[i]
        for (r, c) in component:
            grid[r][c] = color
    size = max(H, W)
    output = common.grid(size, size, 0)
    for r in range(H):
        for c in range(W):
            output[r][c] = grid[r][c]
    regions = [(colors[i], components[i]) for i in range(len(components))]
    regions.sort(key=lambda x: sum(r for (r, c) in x[1]) / len(x[1]))
    for color, component in regions:
        total_rows = sum(r for (r, c) in component)
        centroid_row = total_rows / len(component)
        if centroid_row < H / 2:
            max_row = max(r for (r, c) in component)
            for c in range(W):
                if (max_row, c) in component:
                    for r in range(max_row + 1, size):
                        if output[r][c] != 0:
                            break
                        output[r][c] = color
        else:
            min_row = min(r for (r, c) in component)
            for c in range(W):
                if (min_row, c) in component:
                    for r in range(min_row - 1, -1, -1):
                        if output[r][c] != 0:
                            break
                        output[r][c] = color
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    H = len(input_grid)
    W = len(input_grid[0])
    size = max(H, W)
    output = common.grid(size, size, 0)
    for r in range(H):
        for c in range(W):
            output[r][c] = input_grid[r][c]
    visited = [[False] * W for _ in range(H)]
    regions = []
    for r in range(H):
        for c in range(W):
            if input_grid[r][c] != 0 and not visited[r][c]:
                color = input_grid[r][c]
                component = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < H and 0 <= nc < W and input_grid[nr][nc] == color and not visited[nr][nc]:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                regions.append((color, component))
    regions.sort(key=lambda x: sum(r for (r, c) in x[1]) / len(x[1]))
    for color, component in regions:
        total_rows = sum(r for (r, c) in component)
        centroid_row = total_rows / len(component)
        if centroid_row < H / 2:
            max_row = max(r for (r, c) in component)
            for c in range(W):
                if (max_row, c) in component:
                    for r in range(max_row + 1, size):
                        if output[r][c] != 0:
                            break
                        output[r][c] = color
        else:
            min_row = min(r for (r, c) in component)
            for c in range(W):
                if (min_row, c) in component:
                    for r in range(min_row - 1, -1, -1):
                        if output[r][c] != 0:
                            break
                        output[r][c] = color
    return output
