# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: f89005a2
Difficulty: very hard

=== Tags ===
- Dynamic environment
- Rotational pattern mapping
- Boundary tracing

=== Description ===
Input grids feature multiple disjoint, convex regions of distinct colors (1-9)
on a uniform background (color 0). Each region is surrounded by background and
forms a simple polygonal shape with a clear boundary. The output grid maintains
all original regions but adds a new boundary trace layer where each directional
step in the boundary path is rotated 90Â° clockwise relative to the input. For
example, a rightward boundary segment becomes downward, a downward segment
becomes leftward, a leftward segment becomes upward, and an upward segment
becomes rightward. The traced boundary is drawn exclusively in color 9, with no
overlap or alteration of existing region colors. The transformation must be
applied consistently across all regions, requiring precise boundary
identification, directional mapping, and non-overlapping drawing on the
background.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Create a square grid with room for exterior traces
    size = random.randint(15, 30)
    grid = [[0 for _ in range(size)] for _ in range(size)]

    # Colors reserved for regions (1-8). We'll draw 3-5 rectangular convex regions.
    colors = list(range(1, 9))
    random.shuffle(colors)
    num_regions = random.randint(3, 5)

    # Keep track of placements so regions have at least one-cell background around them
    occupied = [[False for _ in range(size)] for _ in range(size)]
    regions = []  # list of (r, c, w, h, color)

    for _ in range(num_regions):
        placed = False
        # Try several times to find a placement that fits with a 1-cell background margin
        for _try in range(200):
            # Ensure rectangles are at least 3x3, and small enough to leave margins
            max_wh = max(3, min(10, size - 4))
            w = random.randint(3, max_wh)
            h = random.randint(3, max_wh)
            r = random.randint(1, size - h - 1)
            c = random.randint(1, size - w - 1)

            # Check 1-cell buffer around candidate rectangle (so the region is surrounded by background)
            conflict = False
            for rr in range(r - 1, r + h + 1):
                for cc in range(c - 1, c + w + 1):
                    if 0 <= rr < size and 0 <= cc < size:
                        if occupied[rr][cc]:
                            conflict = True
                            break
                if conflict:
                    break
            if conflict:
                continue

            # Place region
            if not colors:
                break
            color = colors.pop()
            regions.append((r, c, w, h, color))
            for rr in range(r, r + h):
                for cc in range(c, c + w):
                    grid[rr][cc] = color
                    occupied[rr][cc] = True
            # Mark the surrounding buffer as occupied to avoid placing another region too close
            for rr in range(r - 1, r + h + 1):
                for cc in range(c - 1, c + w + 1):
                    if 0 <= rr < size and 0 <= cc < size:
                        occupied[rr][cc] = True
            placed = True
            break
        if not placed:
            break

    # Construct output by adding the rotated-boundary traces in color 9 on background cells only
    output = [row[:] for row in grid]
    for (r, c, w, h, color) in regions:
        # We choose a consistent traversal orientation such that the rotated step points outward.
        # For rectangles this means interpreting the top edge as moving left, left edge as moving down,
        # bottom edge as moving right, and right edge as moving up. Rotating these 90deg clockwise
        # yields outward directions: top -> up, left -> left, bottom -> down, right -> right.

        # Top edge (row r, columns c..c+w-1) -> mark one cell above
        for j in range(w):
            tr = r - 1
            tc = c + j
            if 0 <= tr < size and 0 <= tc < size and output[tr][tc] == 0:
                output[tr][tc] = 9

        # Left edge (rows r..r+h-1, col c) -> mark one cell left
        for i in range(h):
            tr = r + i
            tc = c - 1
            if 0 <= tr < size and 0 <= tc < size and output[tr][tc] == 0:
                output[tr][tc] = 9

        # Bottom edge (row r+h-1, columns c..c+w-1) -> mark one cell below
        for j in range(w):
            tr = r + h
            tc = c + j
            if 0 <= tr < size and 0 <= tc < size and output[tr][tc] == 0:
                output[tr][tc] = 9

        # Right edge (rows r..r+h-1, col c+w-1) -> mark one cell right
        for i in range(h):
            tr = r + i
            tc = c + w
            if 0 <= tr < size and 0 <= tc < size and output[tr][tc] == 0:
                output[tr][tc] = 9

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0])

    out = [row[:] for row in grid]

    # Collect distinct region colors (exclude background 0 and tracer 9)
    colors = set()
    for r in range(H):
        for c in range(W):
            v = grid[r][c]
            if v != 0 and v != 9:
                colors.add(v)

    for color in colors:
        # Cells of this color
        cells = [(r, c) for r in range(H) for c in range(W) if grid[r][c] == color]
        if not cells:
            continue
        rmin = min(r for r, c in cells)
        rmax = max(r for r, c in cells)
        cmin = min(c for r, c in cells)
        cmax = max(c for r, c in cells)

        # If the component is a full rectangle (as the generator produces), draw traces exactly as generator
        rectangular = True
        for rr in range(rmin, rmax + 1):
            for cc in range(cmin, cmax + 1):
                if grid[rr][cc] != color:
                    rectangular = False
                    break
            if not rectangular:
                break

        if rectangular:
            # Top edge -> mark one cell above
            for cc in range(cmin, cmax + 1):
                tr = rmin - 1
                tc = cc
                if 0 <= tr < H and 0 <= tc < W and out[tr][tc] == 0:
                    out[tr][tc] = 9
            # Left edge -> mark one cell left
            for rr in range(rmin, rmax + 1):
                tr = rr
                tc = cmin - 1
                if 0 <= tr < H and 0 <= tc < W and out[tr][tc] == 0:
                    out[tr][tc] = 9
            # Bottom edge -> mark one cell below
            for cc in range(cmin, cmax + 1):
                tr = rmax + 1
                tc = cc
                if 0 <= tr < H and 0 <= tc < W and out[tr][tc] == 0:
                    out[tr][tc] = 9
            # Right edge -> mark one cell right
            for rr in range(rmin, rmax + 1):
                tr = rr
                tc = cmax + 1
                if 0 <= tr < H and 0 <= tc < W and out[tr][tc] == 0:
                    out[tr][tc] = 9
        else:
            # Fallback for unexpected shapes: trace boundary pixels and rotate their local step
            # Identify boundary pixels (region pixels with at least one adjacent background cell)
            boundary = []
            for (rr, cc) in cells:
                for dr, dc in ((0, 1), (1, 0), (0, -1), (-1, 0)):
                    nr, nc = rr + dr, cc + dc
                    if nr < 0 or nr >= H or nc < 0 or nc >= W or grid[nr][nc] == 0:
                        boundary.append((rr, cc))
                        break
            # Unique preserve order
            seen = set()
            boundary = [p for p in boundary if not (p in seen or seen.add(p))]

            for (rr, cc) in boundary:
                # Pick a neighbor-of-same-color to determine the local boundary step direction if possible
                step = None
                for dr, dc in ((0, 1), (1, 0), (0, -1), (-1, 0)):
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < H and 0 <= nc < W and grid[nr][nc] == color:
                        step = (dr, dc)
                        break
                if step is None:
                    # isolated boundary pixel - choose arbitrary right step
                    dr, dc = 0, 1
                else:
                    dr, dc = step
                # Rotate the step 90 degrees clockwise: (dr,dc) -> (dc, -dr)
                rr2 = rr + dc
                cc2 = cc - dr
                if 0 <= rr2 < H and 0 <= cc2 < W and out[rr2][cc2] == 0:
                    out[rr2][cc2] = 9

    return out

