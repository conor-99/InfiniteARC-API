# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 77752f14
Difficulty: hard

=== Tags ===
- Associate images to colors

=== Description ===
The task involves input grids containing connected regions (components) of non-
zero colors. Each component is a maximal set of edge-connected cells sharing the
same color. The transformation rule replaces every cell in a component with a
color equal to the size of the component modulo 10. For example, a component of
size 7 becomes color 7, while a component of size 12 becomes color 2. The output
grid is generated by applying this rule to all components, ignoring their
original colors. The solver must identify connected components, count their
cells, compute the modulo 10 value, and replace all cells in the component with
the result. This requires recognizing spatial patterns, counting, and modular
arithmetic, making it challenging due to the need to process multiple components
independently while avoiding confusion between original colors and component
size-based outputs. The rule ensures input grids differ from outputs, as
component sizes rarely align with original colors, and the transformation is
deterministic and generalizable across varying grid sizes.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    while True:
        input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
        output_grid = [[0] * width for _ in range(height)]
        visited = [[False] * width for _ in range(height)]
        
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] != 0 and not visited[r][c]:
                    color = input_grid[r][c]
                    component = []
                    queue = [(r, c)]
                    visited[r][c] = True
                    while queue:
                        cr, cc = queue.pop(0)
                        component.append((cr, cc))
                        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                            nr = cr + dr
                            nc = cc + dc
                            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                                visited[nr][nc] = True
                                queue.append((nr, nc))
                    s = len(component)
                    target = s % 10
                    for (cr, cc) in component:
                        output_grid[cr][cc] = target
        
        if input_grid != output_grid:
            return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = [[0] * width for _ in range(height)]
    visited = [[False] * width for _ in range(height)]
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                color = input_grid[r][c]
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr = cr + dr
                        nc = cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                s = len(component)
                target = s % 10
                for (cr, cc) in component:
                    output_grid[cr][cc] = target
    return output_grid
