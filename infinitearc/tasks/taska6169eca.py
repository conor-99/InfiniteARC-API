# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: a6169eca
Difficulty: medium–hard

=== Tags ===
- Echo trail
- Infer hidden grid
- Impact highlight
- Cooperative rule network

=== Description ===
**Task Name: Echo Trail Network**    **Description:**    Input grids feature a
background of black (color 0), with red (color 2), green (color 3), yellow
(color 4), and blue (color 5) cells acting as reflectors, and white (color 1)
cells acting as emitters. Each reflector’s color encodes a direction: red
indicates rightward movement, green upward, yellow leftward, and blue downward.
For every white emitter cell adjacent (horizontally or vertically) to a
reflector, a trail is generated. The trail starts at the emitter and moves in
the reflector’s direction, stepping through background cells (black), with each
step sequentially adopting colors from the cycle (color 6 → 7 → 8 → 9 → 6...).
The trail terminates upon encountering any non-background cell (emitter,
reflector, or another trail), and the terminal cell is highlighted with cyan
(color 9). The output grid renders all trails, preserving original emitters and
reflectors, while the "hidden grid" is the complete network of echo trails
formed by the cooperative interaction of directional encoding and color cycling.
The "impact highlight" marks collision points with cyan, and the "cooperative
rule network" ensures trails propagate without overlapping or conflicting with
existing elements.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    """Generates an ARC-style input/output pair for the "Echo Trail Network" task.

    Grid encoding:
      0 - background (black)
      1 - emitter (white)
      2 - red reflector (right)
      3 - green reflector (up)
      4 - yellow reflector (left)
      5 - blue reflector (down)
      6-9 - trail colors (6->7->8->9 cycle), final impact highlighted with 9
    """
    # Grid size between 5 and 30 (kept moderate to ensure variety & speed)
    size = random.randint(5, 30)
    grid = [[0 for _ in range(size)] for _ in range(size)]

    directions = {2: (0, 1), 3: (-1, 0), 4: (0, -1), 5: (1, 0)}

    # We will place reflectors and for each place exactly one emitter adjacent to it.
    # To avoid ambiguous emitters (adjacent to multiple reflectors) and overlapping
    # reserved trail paths we keep a set of reserved cells that cannot be used for
    # reflectors/emitters.
    reserved = set()
    reflectors = []
    emitters = []

    # Number of reflectors to attempt to place
    num_reflectors = random.randint(1, min(6, max(1, size // 2)))

    attempts = 0
    max_attempts = max(200, num_reflectors * 80)

    while len(reflectors) < num_reflectors and attempts < max_attempts:
        attempts += 1
        r = random.randint(1, size - 2)
        c = random.randint(1, size - 2)
        if grid[r][c] != 0 or (r, c) in reserved:
            continue

        color = random.choice([2, 3, 4, 5])

        # Avoid placing reflectors directly adjacent to another reflector
        blocked = False
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < size and 0 <= nc < size and grid[nr][nc] in [2, 3, 4, 5]:
                blocked = True
                break
        if blocked:
            continue

        # Try to place an emitter adjacent to this reflector such that the
        # subsequent trail (in the reflector's direction) has at least one
        # background cell available and does not conflict with previously
        # reserved path cells or other reflectors/emitters.
        neighbors = [(r + dr, c + dc) for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]]
        random.shuffle(neighbors)
        placed = False
        for r_e, c_e in neighbors:
            if not (0 <= r_e < size and 0 <= c_e < size):
                continue
            if grid[r_e][c_e] != 0 or (r_e, c_e) in reserved:
                continue

            dirr = directions[color]
            # The first path cell (one step from the emitter in the reflector's direction)
            cr, cc = r_e + dirr[0], c_e + dirr[1]
            if not (0 <= cr < size and 0 <= cc < size):
                continue

            # Collect the maximal list of consecutive background cells from cr,cc
            path = []
            while 0 <= cr < size and 0 <= cc < size and grid[cr][cc] == 0 and (cr, cc) not in reserved:
                path.append((cr, cc))
                cr += dirr[0]
                cc += dirr[1]

            # Need at least one cell to draw the trail
            if len(path) == 0:
                continue

            # Place reflector and emitter, and reserve the path cells so future
            # placements don't conflict with this trail.
            grid[r][c] = color
            grid[r_e][c_e] = 1
            reflectors.append((r, c, color))
            emitters.append((r_e, c_e))
            for cell in path:
                reserved.add(cell)
            placed = True
            break

        if not placed:
            # Try another location
            continue

    # If we failed to place any emitters (very unlikely), force a simple placement
    if len(emitters) == 0:
        # Place a single reflector/emitter pair near the center with a guaranteed path
        cr = size // 2
        cc = size // 2
        color = random.choice([2, 3, 4, 5])
        grid[cr][cc] = color
        # find a neighbor to place an emitter where there is room for at least one step
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            re, ce = cr + dr, cc + dc
            dirr = directions[color]
            nr, nc = re + dirr[0], ce + dirr[1]
            if 0 <= re < size and 0 <= ce < size and grid[re][ce] == 0 and 0 <= nr < size and 0 <= nc < size and grid[nr][nc] == 0:
                grid[re][ce] = 1
                reflectors.append((cr, cc, color))
                emitters.append((re, ce))
                break

    # Build output by painting trails. We must paint emitters in row-major order to
    # ensure deterministic painting order that the solver will replicate.
    output = [row[:] for row in grid]

    colors_cycle = [6, 7, 8, 9]

    for r_e, c_e in sorted(emitters):  # row-major deterministic order
        # find the (unique) adjacent reflector for this emitter
        ref_color = None
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r_e + dr, c_e + dc
            if 0 <= nr < size and 0 <= nc < size and output[nr][nc] in [2, 3, 4, 5]:
                ref_color = output[nr][nc]
                break
        if ref_color is None:
            # no adjacent reflector (shouldn't happen given placement rules)
            continue

        dirr = directions[ref_color]
        cr, cc = r_e + dirr[0], c_e + dirr[1]
        idx = 0
        last = None
        while 0 <= cr < size and 0 <= cc < size and output[cr][cc] == 0:
            output[cr][cc] = colors_cycle[idx % len(colors_cycle)]
            last = (cr, cc)
            idx += 1
            cr += dirr[0]
            cc += dirr[1]

        # highlight the terminal cell with cyan (9) if we painted at least one cell
        if last is not None:
            lr, lc = last
            output[lr][lc] = 9

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert tuple-of-tuples input to a mutable list-of-lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0]) if h > 0 else 0

    directions = {2: (0, 1), 3: (-1, 0), 4: (0, -1), 5: (1, 0)}
    colors_cycle = [6, 7, 8, 9]

    # Scan emitters in row-major order and grow trails. Modifying grid in-place
    # matches the generator behavior (so trails can block later trails).
    for r in range(h):
        for c in range(w):
            if grid[r][c] != 1:
                continue

            # find adjacent reflector (unique by construction of the generator)
            ref_color = None
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < h and 0 <= nc < w and grid[nr][nc] in [2, 3, 4, 5]:
                    ref_color = grid[nr][nc]
                    break
            if ref_color is None:
                continue

            dirr = directions[ref_color]
            cr, cc = r + dirr[0], c + dirr[1]
            idx = 0
            last = None
            while 0 <= cr < h and 0 <= cc < w and grid[cr][cc] == 0:
                grid[cr][cc] = colors_cycle[idx % len(colors_cycle)]
                last = (cr, cc)
                idx += 1
                cr += dirr[0]
                cc += dirr[1]

            if last is not None:
                lr, lc = last
                grid[lr][lc] = 9

    # Return as tuple-of-tuples as expected by the validator
    return tuple(tuple(row) for row in grid)

