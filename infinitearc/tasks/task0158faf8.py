# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 0158faf8
Difficulty: medium

=== Tags ===
- Color permutation
- Concentric
- Color matching
- Local convolution rule

=== Description ===
The input grid is a square or rectangular grid of colors ranging from 0 to 9.
The transformation applies a concentric layer-based color permutation: for each
cell, its concentric layer index is determined by the Chebyshev distance
(maximum of horizontal and vertical distances) from the grid's center. The
output color for each cell is computed as (input color + layer index) modulo 10.
The center cell (if the grid size is odd) has layer index 0, and each subsequent
outward layer increments the index by 1. This rule creates a consistent color
permutation that varies with the concentric position, satisfying the "Color
permutation" and "Concentric" tags. The "Local convolution rule" is interpreted
as the layer index being a local property determined per cell, while "Color
matching" refers to the systematic mapping between input and output colors
through modular arithmetic. The transformation is deterministic, generalizable
across grid sizes (1×1 to 30×30), and requires abstract reasoning to identify
the layer-dependent color shift.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import math

def generate():
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
    center_r = (height - 1) / 2.0
    center_c = (width - 1) / 2.0
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            dr = abs(r - center_r)
            dc = abs(c - center_c)
            layer = int(math.floor(max(dr, dc)))
            output_grid[r][c] = (input_grid[r][c] + layer) % 10
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import math

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    center_r = (height - 1) / 2.0
    center_c = (width - 1) / 2.0
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            dr = abs(r - center_r)
            dc = abs(c - center_c)
            layer = int(math.floor(max(dr, dc)))
            output_grid[r][c] = (input_grid[r][c] + layer) % 10
    return output_grid
