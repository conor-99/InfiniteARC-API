# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 5424ba5e
Difficulty: insane

=== Tags ===
- Perimeter smoothing
- Impact highlight
- Associate colors to images

=== Description ===
Input grids are large (20×20 or larger) with a uniform background color (0) and
multiple disconnected, solid-colored shapes (colors 1–9). Each shape is a
connected region of at least 2×2 cells, separated from other shapes by at least
one background cell. Shapes must not touch orthogonally or diagonally.
**Perimeter Smoothing**: For each shape, identify all convex corner cells on its
perimeter. A convex corner cell is defined as a perimeter cell (adjacent to
background) with two orthogonally adjacent shape cells forming a 90° outward
angle (e.g., a cell with shape neighbors to the north and east). Replace all
such convex corner cells with color 9 (a fixed "smooth" color), while preserving
all other shape cells and background.  **Impact Highlight**: For each pair of
shapes diagonally adjacent (i.e., their closest cells are separated by exactly
one background cell in both row and column directions), identify the background
cell lying between them (e.g., shape A at (r-1,c-1), shape B at (r+1,c+1),
background cell at (r,c)). Replace this background cell with the **mapped
color** of the shape with the higher original color value. The color mapping
rule is fixed: 1→2, 2→3, 3→4, 4→5, 5→6, 6→7, 7→8, 8→9, 9→1.  **Associate Colors
to Images**: The output grid uses the fixed color mapping to link each input
shape's color to its corresponding impact highlight color, creating a consistent
association between input shapes and output highlights. The perimeter smoothing
(color 9) and impact highlights (mapped colors) are the only modifications to
the original grid, with all other cells (shape interiors, background, non-impact
cells) remaining unchanged.  The task requires identifying multiple structural
properties (shape connectivity, corner geometry, diagonal adjacency) and
applying a compositional color transformation rule that must be inferred from
minimal examples. No numerical sums or parity checks are used—only visual
pattern recognition of shape features and color associations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = random.randint(20, 30)
    height = random.randint(20, 30)
    grid = [[0]*width for _ in range(height)]
    shapes = []
    
    num_shapes = random.randint(3, 5)
    for _ in range(num_shapes):
        color = random.randint(1, 9)
        size = random.randint(4, 9)
        pixels = common.continuous_creature(size, width=3, height=3)
        rows = [p[0] for p in pixels]
        cols = [p[1] for p in pixels]
        min_r, max_r = min(rows), max(rows)
        min_c, max_c = min(cols), max(cols)
        shape_height = max_r - min_r + 1
        shape_width = max_c - min_c + 1
        
        while True:
            r0 = random.randint(0, height - shape_height)
            c0 = random.randint(0, width - shape_width)
            valid = True
            for r, c in zip(rows, cols):
                nr, nc = r0 + r, c0 + c
                if grid[nr][nc] != 0:
                    valid = False
                    break
            if valid:
                break
        
        for r, c in zip(rows, cols):
            nr, nc = r0 + r, c0 + c
            grid[nr][nc] = color
        shapes.append((color, rows, cols, r0, c0))
    
    output = [row[:] for row in grid]
    
    for (color, rows, cols, r0, c0) in shapes:
        for r, c in zip(rows, cols):
            r_pos = r0 + r
            c_pos = c0 + c
            perimeter = False
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r_pos + dr, c_pos + dc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0:
                    perimeter = True
                    break
            if not perimeter:
                continue
            
            neighbors = []
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r_pos + dr, c_pos + dc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                    neighbors.append((dr, dc))
            if len(neighbors) != 2:
                continue
            
            if (neighbors[0][0] != 0 and neighbors[0][1] == 0 and neighbors[1][0] == 0 and neighbors[1][1] != 0) or \
               (neighbors[0][0] == 0 and neighbors[0][1] != 0 and neighbors[1][0] != 0 and neighbors[1][1] == 0):
                output[r_pos][c_pos] = 9
    
    for r in range(1, height-1):
        for c in range(1, width-1):
            if grid[r][c] != 0:
                continue
            if grid[r-1][c-1] != 0 and grid[r+1][c+1] != 0:
                color1 = grid[r-1][c-1]
                color2 = grid[r+1][c+1]
                if color1 != color2:
                    max_color = max(color1, color2)
                    mapped = (max_color % 9) + 1
                    output[r][c] = mapped
            if grid[r-1][c+1] != 0 and grid[r+1][c-1] != 0:
                color1 = grid[r-1][c+1]
                color2 = grid[r+1][c-1]
                if color1 != color2:
                    max_color = max(color1, color2)
                    mapped = (max_color % 9) + 1
                    output[r][c] = mapped
    
    return {'input': grid, 'output': output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    output = [row[:] for row in grid]
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0:
                continue
            perimeter = False
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0:
                    perimeter = True
                    break
            if not perimeter:
                continue
            
            neighbors = []
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                    neighbors.append((dr, dc))
            if len(neighbors) != 2:
                continue
            
            if (neighbors[0][0] != 0 and neighbors[0][1] == 0 and neighbors[1][0] == 0 and neighbors[1][1] != 0) or \
               (neighbors[0][0] == 0 and neighbors[0][1] != 0 and neighbors[1][0] != 0 and neighbors[1][1] == 0):
                output[r][c] = 9
    
    for r in range(1, height-1):
        for c in range(1, width-1):
            if grid[r][c] != 0:
                continue
            if grid[r-1][c-1] != 0 and grid[r+1][c+1] != 0:
                color1 = grid[r-1][c-1]
                color2 = grid[r+1][c+1]
                if color1 != color2:
                    max_color = max(color1, color2)
                    mapped = (max_color % 9) + 1
                    output[r][c] = mapped
            if grid[r-1][c+1] != 0 and grid[r+1][c-1] != 0:
                color1 = grid[r-1][c+1]
                color2 = grid[r+1][c-1]
                if color1 != color2:
                    max_color = max(color1, color2)
                    mapped = (max_color % 9) + 1
                    output[r][c] = mapped
    
    return output
