# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 8c6059ba
Difficulty: hard

=== Tags ===
- Competitive agents
- Swap positions of two objects

=== Description ===
Input grids feature a uniform background color (0) with multiple disconnected
colored regions (each region is a 4-connected set of cells, size 4, color 1-9).
The two regions to be swapped are defined by:   1. Each region is a tetromino
shape with a distinct "handle" configuration:      - Region A: A 3-cell
horizontal base with a single cell attached to the top or bottom (forming a
T-shape pointing vertically).      - Region B: A 3-cell vertical base with a
single cell attached to the left or right (forming a T-shape pointing
horizontally).   2. Region A and Region B must be oriented such that their
handles point in perpendicular directions (e.g., Region A's handle points up,
Region B's handle points right).    The output grid is generated by swapping the
positions of Region A and Region B. This involves moving each region to the
other's original location while maintaining its shape and color. All other
regions and background cells remain unchanged. The swap is direct and does not
involve intermediate steps or pathfinding; the output reflects the new locations
of the two regions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def detect_t(region_set):
    """Detect whether a 4-cell region is a T tetromino of type A or B.

    Returns ('A', center) for horizontal-base T (handle up/down),
    ('B', center) for vertical-base T (handle left/right), or None.
    """
    if len(region_set) != 4:
        return None
    for cell in region_set:
        r, c = cell
        neighs = [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]
        present = [n in region_set for n in neighs]
        # present == [up, down, left, right]
        if sum(present) != 3:
            continue
        up, down, left, right = present
        # horizontal base (left & right present) and a single handle up or down -> Region A
        if left and right and (up != down):
            return ('A', cell)
        # vertical base (up & down present) and a single handle left or right -> Region B
        if up and down and (left != right):
            return ('B', cell)
    return None


def place_t_center(center_r, center_c, kind, handle_dir):
    """Return list of 4 cell coordinates for a T-shape centered at (center_r, center_c).

    kind: 'A' (horizontal base) or 'B' (vertical base)
    handle_dir: -1 or +1 indicating up/down for A and left/right for B
    """
    if kind == 'A':
        return [(center_r, center_c-1), (center_r, center_c), (center_r, center_c+1), (center_r + handle_dir, center_c)]
    else:
        return [(center_r-1, center_c), (center_r, center_c), (center_r+1, center_c), (center_r, center_c + handle_dir)]


def generate():
    """Generates an input/output pair where two T-shaped tetrominoes are swapped.

    The swap is implemented by moving each shape so that its base-center (the central
    cell of the three-cell base) moves to the other's base-center. This anchor ensures
    integer translations and keeps orientations unchanged.
    """
    MAX_ATTEMPTS = 800
    for attempt in range(MAX_ATTEMPTS):
        # size chosen to allow a 1-cell margin around centers (centers in [1, h-2] x [1, w-2])
        height = random.randint(7, 15)
        width = random.randint(7, 15)
        margin = 1

        # pick distinct centers for the two T shapes (these are the middle cell of the 3-cell base)
        rA = random.randint(margin, height - margin - 1)
        cA = random.randint(margin, width - margin - 1)
        rB = random.randint(margin, height - margin - 1)
        cB = random.randint(margin, width - margin - 1)
        if (rA, cA) == (rB, cB):
            continue

        A_handle = random.choice([-1, 1])  # up or down
        B_handle = random.choice([-1, 1])  # left or right

        region_A = place_t_center(rA, cA, 'A', A_handle)
        region_B = place_t_center(rB, cB, 'B', B_handle)

        # All cells must be inside the grid
        all_cells = region_A + region_B
        if any(not (0 <= rr < height and 0 <= cc < width) for rr, cc in all_cells):
            continue

        setA = set(region_A)
        setB = set(region_B)
        if setA & setB:
            continue

        # Compute where each shape would land after swapping center-to-center
        dr = rB - rA
        dc = cB - cA
        A_shifted = {(r + dr, c + dc) for (r, c) in setA}
        B_shifted = {(r - dr, c - dc) for (r, c) in setB}

        # shifted cells must be within bounds
        if any(not (0 <= rr < height and 0 <= cc < width) for rr, cc in (A_shifted | B_shifted)):
            continue

        # pick two distinct colors for A and B
        color_A = random.randint(1, 9)
        color_B = random.randint(1, 9)
        if color_B == color_A:
            color_B = (color_A % 9) + 1

        # Build initial blank grid and place the two T shapes
        grid = [[0 for _ in range(width)] for _ in range(height)]
        for (rr, cc) in setA:
            grid[rr][cc] = color_A
        for (rr, cc) in setB:
            grid[rr][cc] = color_B

        # Reserve cells that must remain free for the swap (so other regions won't conflict)
        reserved = setA | setB | A_shifted | B_shifted

        # Place a small number of other 4-cell connected regions; avoid reserved cells and avoid creating T shapes
        other_colors = [c for c in range(1, 10) if c not in (color_A, color_B)]
        num_other = random.randint(0, 3)
        available_cells = [(r, c) for r in range(height) for c in range(width) if (r, c) not in reserved and grid[r][c] == 0]

        def try_grow_region(start):
            # greedily grow a connected set of 4 cells starting from start
            region = [start]
            region_set = {start}
            for _ in range(3):
                # collect neighbor candidates (4-neighborhood) not in reserved, not already used
                cand = []
                for (rr, cc) in list(region):
                    for ddr, ddc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = rr + ddr, cc + ddc
                        if not (0 <= nr < height and 0 <= nc < width):
                            continue
                        if (nr, nc) in region_set or (nr, nc) in reserved:
                            continue
                        if grid[nr][nc] != 0:
                            continue
                        cand.append((nr, nc))
                if not cand:
                    return None
                nxt = random.choice(cand)
                region.append(nxt)
                region_set.add(nxt)
            # Avoid accidentally constructing a T-shape (which would be ambiguous)
            if detect_t(region_set) is not None:
                return None
            return region_set

        success = True
        for _ in range(num_other):
            placed = False
            attempts_inner = 0
            while attempts_inner < 200 and available_cells:
                attempts_inner += 1
                start = random.choice(available_cells)
                region_set = try_grow_region(start)
                if not region_set:
                    # try another start
                    continue
                # ensure the chosen region does not intersect already placed other regions (grid check)
                conflict = any(grid[rr][cc] != 0 for rr, cc in region_set)
                if conflict:
                    continue
                # place the region with a random allowed color
                color = random.choice(other_colors)
                for rr, cc in region_set:
                    grid[rr][cc] = color
                # add these cells to reserved so subsequent other regions don't overlap
                reserved |= region_set
                available_cells = [(r, c) for r in range(height) for c in range(width) if (r, c) not in reserved and grid[r][c] == 0]
                placed = True
                break
            if not placed:
                success = False
                break

        if not success:
            continue

        # Build output grid by swapping the two T shapes (translate center-to-center)
        output = [row[:] for row in grid]
        # clear original positions
        for (rr, cc) in setA:
            output[rr][cc] = 0
        for (rr, cc) in setB:
            output[rr][cc] = 0
        # place A at B's center and B at A's center
        for (rr, cc) in setA:
            nr, nc = rr + dr, cc + dc
            output[nr][nc] = color_A
        for (rr, cc) in setB:
            nr, nc = rr - dr, cc - dc
            output[nr][nc] = color_B

        # Sanity checks before returning
        if grid == output:
            # ensure we actually moved something
            continue

        return {"input": grid, "output": output}

    # Should not normally reach here
    raise RuntimeError('Failed to generate a valid puzzle after many attempts')


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    def detect_t(region_set):
        if len(region_set) != 4:
            return None
        for cell in region_set:
            r, c = cell
            neighs = [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]
            present = [n in region_set for n in neighs]
            if sum(present) != 3:
                continue
            up, down, left, right = present
            if left and right and (up != down):
                return ('A', cell)
            if up and down and (left != right):
                return ('B', cell)
        return None

    # Find all connected components of non-zero cells (4-connected)
    visited = [[False] * width for _ in range(height)]
    components = []  # list of (set_of_cells, color)
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 or visited[r][c]:
                continue
            color = grid[r][c]
            stack = [(r, c)]
            visited[r][c] = True
            comp = []
            while stack:
                cr, cc = stack.pop()
                comp.append((cr, cc))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            if len(comp) == 4:
                components.append((set(comp), color))

    region_A = None
    region_B = None
    center_A = None
    center_B = None
    for comp_set, color in components:
        det = detect_t(comp_set)
        if det is None:
            continue
        kind, center = det
        if kind == 'A' and region_A is None:
            region_A = (comp_set, color)
            center_A = center
        elif kind == 'B' and region_B is None:
            region_B = (comp_set, color)
            center_B = center

    # If we didn't find both special regions, return input unchanged
    if region_A is None or region_B is None:
        return grid

    # Compute translation vector from A center to B center
    dr = center_B[0] - center_A[0]
    dc = center_B[1] - center_A[1]

    # Perform the swap: clear original A/B and place them translated
    output = [row[:] for row in grid]
    A_cells, A_color = region_A
    B_cells, B_color = region_B

    for (r, c) in A_cells:
        output[r][c] = 0
    for (r, c) in B_cells:
        output[r][c] = 0

    for (r, c) in A_cells:
        nr, nc = r + dr, c + dc
        # safety: only write within bounds
        if 0 <= nr < height and 0 <= nc < width:
            output[nr][nc] = A_color
    for (r, c) in B_cells:
        nr, nc = r - dr, c - dc
        if 0 <= nr < height and 0 <= nc < width:
            output[nr][nc] = B_color

    return output
