# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: a91b253d
Difficulty: hard

=== Tags ===
- Minimal path fill
- Texture transfer
- Recursive agent following
- Goal conditioned path
- Take complement
- Direction guessing

=== Description ===
The input grid features a start marker (S), a goal marker (G), a textured region
(T) composed of contiguous cells arranged in a visual pattern that encodes
directional flow (e.g., horizontal gradients indicate rightward movement,
vertical gradients indicate downward movement), and obstacle regions (O) marked
by a distinct background color. The task requires generating the shortest path
from S to G that adheres to the directional constraints encoded within the
textured region. Each step of the path must follow the direction indicated by
the texture pattern at the cell it enters. The path is filled using the
complement color of the texture's color (e.g., if a texture cell uses color 3,
the path uses color 6, where complement = 9 - texture color). The path must
avoid obstacles, remain within grid boundaries, and form the minimal-length
sequence of moves to reach G. The output grid retains the original S and G
markers, preserves obstacles, and fills the path with the complement color,
ensuring all directional and color constraints are satisfied through recursive
agent following from S through T to G.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    from common import grid

    # Try multiple times to produce a valid nontrivial textured path with S and G
    for attempt in range(500):
        width = random.randint(6, 20)
        height = random.randint(6, 20)

        # Path length between 3 and a modest cap so it fits comfortably
        max_len = min(12, max(3, (width * height) // 20))
        path_len = random.randint(3, max_len)

        # Try to build a simple non-self-intersecting 4-neighbor path
        for path_attempt in range(400):
            # start somewhere (allow margin of 1 to make room for S/G)
            r0 = random.randint(1, height - 2) if height > 2 else 0
            c0 = random.randint(1, width - 2) if width > 2 else 0
            path = [(r0, c0)]
            stuck = False
            for _ in range(path_len - 1):
                r, c = path[-1]
                neighbors = []
                for dr, dc in ((0, 1), (1, 0), (0, -1), (-1, 0)):
                    rr, cc = r + dr, c + dc
                    if 0 <= rr < height and 0 <= cc < width and (rr, cc) not in path:
                        neighbors.append((rr, cc))
                if not neighbors:
                    stuck = True
                    break
                path.append(random.choice(neighbors))
            if stuck:
                continue

            # compute S (just before first texture cell) and G (just after last texture cell)
            dr0 = path[1][0] - path[0][0]
            dc0 = path[1][1] - path[0][1]
            S_pos = (path[0][0] - dr0, path[0][1] - dc0)

            last_dr = path[-1][0] - path[-2][0]
            last_dc = path[-1][1] - path[-2][1]
            G_pos = (path[-1][0] + last_dr, path[-1][1] + last_dc)

            # Ensure S and G are inside bounds and not overlapping the path
            if not (0 <= S_pos[0] < height and 0 <= S_pos[1] < width):
                continue
            if not (0 <= G_pos[0] < height and 0 <= G_pos[1] < width):
                continue
            if S_pos in path or G_pos in path or S_pos == G_pos:
                continue

            # We found a usable path
            break
        else:
            # try different grid size if path construction failed repeatedly
            continue

        # Build the input grid
        input_grid = grid(width, height, 0)

        # Direction -> texture color mapping (deterministic)
        dir2color = {(0, 1): 4, (1, 0): 5, (0, -1): 6, (-1, 0): 7}

        # Paint the textured path: each texture cell encodes the direction to the next cell
        for i, (r, c) in enumerate(path):
            if i < len(path) - 1:
                dr = path[i + 1][0] - r
                dc = path[i + 1][1] - c
            else:
                # last texture cell should point toward G
                dr, dc = last_dr, last_dc
            input_grid[r][c] = dir2color[(dr, dc)]

        # Place S and G markers (colors 2 and 3)
        input_grid[S_pos[0]][S_pos[1]] = 2
        input_grid[G_pos[0]][G_pos[1]] = 3

        # Scatter some obstacles (color 1), but never overwrite S, G or texture cells
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == 0 and random.random() < 0.15:
                    input_grid[r][c] = 1

        # Create the expected output: texture cells replaced by their complement (9 - texture_color)
        output_grid = [row[:] for row in input_grid]
        for (r, c) in path:
            output_grid[r][c] = 9 - input_grid[r][c]

        # sanity: ensure input != output
        if input_grid == output_grid:
            continue

        return {"input": input_grid, "output": output_grid}

    # Fallback deterministic example if random attempts fail (very unlikely)
    input_grid = grid(7, 7, 0)
    path = [(3, 1), (3, 2), (3, 3), (2, 3)]
    dir2color = {(0, 1): 4, (1, 0): 5, (0, -1): 6, (-1, 0): 7}
    for i, (r, c) in enumerate(path):
        if i < len(path) - 1:
            dr = path[i + 1][0] - r
            dc = path[i + 1][1] - c
        else:
            dr, dc = -1, 0
        input_grid[r][c] = dir2color[(dr, dc)]
    S_pos = (3, 0)
    G_pos = (1, 3)
    input_grid[S_pos[0]][S_pos[1]] = 2
    input_grid[G_pos[0]][G_pos[1]] = 3
    output_grid = [row[:] for row in input_grid]
    for (r, c) in path:
        output_grid[r][c] = 9 - input_grid[r][c]
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input (tuple-of-tuples) into a mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # Copy the input to produce the output
    output = [row[:] for row in grid]

    # The generator encodes the texture directions using colors 4..7.
    # The correct transformation is: for every texture cell (color in 4..9)
    # replace it with its complement 9 - color. Preserve S (2), G (3) and obstacles.
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if 4 <= v <= 9:
                output[r][c] = 9 - v

    return output
