# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 6ea76827
Difficulty: very hard

=== Tags ===
- Alternating direction
- Loop filling
- Extrapolate image from grid

=== Description ===
Input grids are large (20×20 or larger) with a single background color (0). Over
this background, a continuous path of color 1 forms multiple non-overlapping
closed loops. The path alternates between right and left turns at each junction,
with the turn direction determining the loop's traversal direction (right turns
→ clockwise, left turns → counterclockwise). Each loop is enclosed by the path
and contains a background region that must be filled.  In the output grid, the
background region enclosed by each loop is filled with a pattern of alternating
colors (2 and 3), starting with color 2 for clockwise loops and color 3 for
counterclockwise loops. The filling proceeds by traversing the inner perimeter
of the loop in the determined direction, filling each background cell in
sequence with the alternating color. For nested loops, the inner loop's filling
pattern is independent of the outer loop's pattern. The path (color 1) and
background (color 0) outside all loops remain unchanged.  Additionally, the task
requires extrapolating the loop structure: if the input contains a repeating
pattern of loops (e.g., a grid of identical loops), the output extends this
pattern to fill all enclosed regions within the grid, following the alternating
color rules. However, the primary rule is to fill each loop's interior based on
its direction, with no overlap between loops' filled regions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque
from common import grid

# Simplified and faster generator for ARC task 494.
# To keep validation fast, create 1 or 2 non-overlapping rectangular loops on a 20x20..22x22 grid.
# The same filling algorithm used by the solver is applied here to produce the output.

DIRS = [(-1, 0), (0, 1), (1, 0), (0, -1)]

def neighbors4(r, c, H, W):
    for dr, dc in DIRS:
        nr, nc = r + dr, c + dc
        if 0 <= nr < H and 0 <= nc < W:
            yield nr, nc


def find_components(grid, H, W, value):
    visited = [[False] * W for _ in range(H)]
    comps = []
    for r in range(H):
        for c in range(W):
            if grid[r][c] != value or visited[r][c]:
                continue
            comp = []
            dq = deque()
            dq.append((r, c))
            visited[r][c] = True
            while dq:
                cr, cc = dq.popleft()
                comp.append((cr, cc))
                for nr, nc in neighbors4(cr, cc, H, W):
                    if not visited[nr][nc] and grid[nr][nc] == value:
                        visited[nr][nc] = True
                        dq.append((nr, nc))
            comps.append(comp)
    return comps


def trace_border(border_set):
    start = min(border_set)
    for dr, dc in DIRS:
        cand = (start[0] + dr, start[1] + dc)
        if cand in border_set:
            next_pixel = cand
            break
    else:
        return [start]
    path = [start]
    prev = start
    cur = next_pixel
    while True:
        path.append(cur)
        found = None
        for dr, dc in DIRS:
            cand = (cur[0] + dr, cur[1] + dc)
            if cand in border_set and cand != prev:
                found = cand
                break
        if found is None:
            break
        prev, cur = cur, found
        if cur == start:
            break
    return path


def fill_enclosed_regions(inp):
    H = len(inp)
    W = len(inp[0])
    grid_in = [row[:] for row in inp]
    out = [row[:] for row in grid_in]

    ones_comps = find_components(grid_in, H, W, 1)
    ones_map = {}
    for idx, comp in enumerate(ones_comps):
        for cell in comp:
            ones_map[cell] = idx

    zero_comps = find_components(grid_in, H, W, 0)

    for zcomp in zero_comps:
        if any(r == 0 or c == 0 or r == H - 1 or c == W - 1 for (r, c) in zcomp):
            continue
        zset = set(zcomp)
        adj_counts = {}
        for (r, c) in zcomp:
            for nr, nc in neighbors4(r, c, H, W):
                if (nr, nc) in ones_map:
                    adj_counts[ones_map[(nr, nc)]] = adj_counts.get(ones_map[(nr, nc)], 0) + 1
        if not adj_counts:
            continue
        border_id = max(adj_counts.keys(), key=lambda k: adj_counts[k])
        border_coords = set(ones_comps[border_id])
        border_list = trace_border(border_coords)
        if len(border_list) < 3:
            continue
        area2 = 0
        for i in range(len(border_list)):
            r1, c1 = border_list[i]
            r2, c2 = border_list[(i + 1) % len(border_list)]
            area2 += (c1 * r2 - c2 * r1)
        is_clockwise = area2 > 0
        start_color = 2 if is_clockwise else 3

        inner_neighbors = [None] * len(border_list)
        for i, (br, bc) in enumerate(border_list):
            for nr, nc in neighbors4(br, bc, H, W):
                if (nr, nc) in zset:
                    inner_neighbors[i] = (nr, nc)
                    break

        dist = {}
        origin = {}
        dq = deque()
        for i, cell in enumerate(inner_neighbors):
            if cell is None:
                continue
            if cell not in dist:
                dist[cell] = 0
                origin[cell] = i
                dq.append(cell)
        while dq:
            cr, cc = dq.popleft()
            for nr, nc in neighbors4(cr, cc, H, W):
                if (nr, nc) in zset and (nr, nc) not in dist:
                    dist[(nr, nc)] = dist[(cr, cc)] + 1
                    origin[(nr, nc)] = origin[(cr, cc)]
                    dq.append((nr, nc))

        if not dist:
            continue
        groups = {}
        maxd = 0
        for cell, d in dist.items():
            groups.setdefault(d, []).append(cell)
            if d > maxd:
                maxd = d

        order = []
        for d in range(maxd + 1):
            cells = groups.get(d, [])
            cells.sort(key=lambda x: origin[x])
            if not is_clockwise:
                cells = cells[::-1]
            order.extend(cells)

        color = start_color
        for (r, c) in order:
            out[r][c] = color
            color = 3 if color == 2 else 2

    return out


def generate():
    H = W = random.randint(20, 22)
    inp = grid(W, H, 0)

    # Place one or two rectangular loops
    rects = []
    count = 1 if random.random() < 0.8 else 2
    tries = 0
    while len(rects) < count and tries < 200:
        tries += 1
        rh = random.randint(3, min(10, H - 4))
        rw = random.randint(3, min(10, W - 4))
        r1 = random.randint(1, H - rh - 2)
        c1 = random.randint(1, W - rw - 2)
        r2 = r1 + rh - 1
        c2 = c1 + rw - 1
        # ensure padding 1 cell around
        er1 = max(0, r1 - 1)
        ec1 = max(0, c1 - 1)
        er2 = min(H - 1, r2 + 1)
        ec2 = min(W - 1, c2 + 1)
        collision = False
        for rr in range(er1, er2 + 1):
            for cc in range(ec1, ec2 + 1):
                if inp[rr][cc] != 0:
                    collision = True
                    break
            if collision:
                break
        if collision:
            continue
        # draw border
        for cc in range(c1, c2 + 1):
            inp[r1][cc] = 1
            inp[r2][cc] = 1
        for rr in range(r1 + 1, r2):
            inp[rr][c1] = 1
            inp[rr][c2] = 1
        rects.append((r1, c1, r2, c2))

    out = fill_enclosed_regions(inp)
    return {"input": inp, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

DIRS = [(-1, 0), (0, 1), (1, 0), (0, -1)]

def neighbors4(r, c, H, W):
    for dr, dc in DIRS:
        nr, nc = r + dr, c + dc
        if 0 <= nr < H and 0 <= nc < W:
            yield nr, nc


def find_components(grid, H, W, value):
    visited = [[False] * W for _ in range(H)]
    comps = []
    for r in range(H):
        for c in range(W):
            if grid[r][c] != value or visited[r][c]:
                continue
            comp = []
            dq = deque()
            dq.append((r, c))
            visited[r][c] = True
            while dq:
                cr, cc = dq.popleft()
                comp.append((cr, cc))
                for nr, nc in neighbors4(cr, cc, H, W):
                    if not visited[nr][nc] and grid[nr][nc] == value:
                        visited[nr][nc] = True
                        dq.append((nr, nc))
            comps.append(comp)
    return comps


def trace_border(border_set):
    start = min(border_set)
    for dr, dc in DIRS:
        cand = (start[0] + dr, start[1] + dc)
        if cand in border_set:
            next_pixel = cand
            break
    else:
        return [start]
    path = [start]
    prev = start
    cur = next_pixel
    while True:
        path.append(cur)
        found = None
        for dr, dc in DIRS:
            cand = (cur[0] + dr, cur[1] + dc)
            if cand in border_set and cand != prev:
                found = cand
                break
        if found is None:
            break
        prev, cur = cur, found
        if cur == start:
            break
    return path


def p(input_grid):
    grid_in = [list(row) for row in input_grid]
    H = len(grid_in)
    W = len(grid_in[0])
    out = [row[:] for row in grid_in]

    ones_comps = find_components(grid_in, H, W, 1)
    ones_map = {}
    for idx, comp in enumerate(ones_comps):
        for cell in comp:
            ones_map[cell] = idx

    zero_comps = find_components(grid_in, H, W, 0)

    for zcomp in zero_comps:
        if any(r == 0 or c == 0 or r == H - 1 or c == W - 1 for (r, c) in zcomp):
            continue
        zset = set(zcomp)
        adj_counts = {}
        for (r, c) in zcomp:
            for nr, nc in neighbors4(r, c, H, W):
                if (nr, nc) in ones_map:
                    adj_counts[ones_map[(nr, nc)]] = adj_counts.get(ones_map[(nr, nc)], 0) + 1
        if not adj_counts:
            continue
        border_id = max(adj_counts.keys(), key=lambda k: adj_counts[k])
        border_coords = set(ones_comps[border_id])
        border_list = trace_border(border_coords)
        if len(border_list) < 3:
            continue
        area2 = 0
        for i in range(len(border_list)):
            r1, c1 = border_list[i]
            r2, c2 = border_list[(i + 1) % len(border_list)]
            area2 += (c1 * r2 - c2 * r1)
        is_clockwise = area2 > 0
        start_color = 2 if is_clockwise else 3

        inner_neighbors = [None] * len(border_list)
        for i, (br, bc) in enumerate(border_list):
            for nr, nc in neighbors4(br, bc, H, W):
                if (nr, nc) in zset:
                    inner_neighbors[i] = (nr, nc)
                    break

        dist = {}
        origin = {}
        dq = deque()
        for i, cell in enumerate(inner_neighbors):
            if cell is None:
                continue
            if cell not in dist:
                dist[cell] = 0
                origin[cell] = i
                dq.append(cell)
        while dq:
            cr, cc = dq.popleft()
            for nr, nc in neighbors4(cr, cc, H, W):
                if (nr, nc) in zset and (nr, nc) not in dist:
                    dist[(nr, nc)] = dist[(cr, cc)] + 1
                    origin[(nr, nc)] = origin[(cr, cc)]
                    dq.append((nr, nc))

        if not dist:
            continue
        groups = {}
        maxd = 0
        for cell, d in dist.items():
            groups.setdefault(d, []).append(cell)
            if d > maxd:
                maxd = d

        order = []
        for d in range(maxd + 1):
            cells = groups.get(d, [])
            cells.sort(key=lambda x: origin[x])
            if not is_clockwise:
                cells = cells[::-1]
            order.extend(cells)

        color = start_color
        for (r, c) in order:
            out[r][c] = color
            color = 3 if color == 2 else 2

    return out

