# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: cf96235a
Difficulty: hard

=== Tags ===
- Hierarchical repetition
- Rule composition

=== Description ===
Input grids feature three concentric rectangular frames, each centered and
separated by a single background cell. Each frame contains a unique color
pattern composed of two or more colors arranged in a visually distinct
configuration. The transformation from one frame to the next follows a
consistent composition of two visual operations applied sequentially: a
geometric transformation (rotation by 90Â° clockwise or vertical reflection)
followed by a color transformation (swapping two specific colors or cycling
through a fixed color sequence). The sequence of geometric operations alternates
between rotation and reflection, while the color operations alternate between
color swapping and cyclic color progression. For example, the outermost frame
(frame 1) transforms to frame 2 via rotation followed by color swapping, frame 2
transforms to frame 3 via reflection followed by color cycling, and the output
grid must extend this sequence by adding a fourth frame (frame 4) that applies
rotation followed by color swapping, continuing the established cycle. All
background spaces and frame separations remain unchanged, and the new frame must
maintain the same relative positioning and scale as the existing frames.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    G = random.choice([15,17,19,21,23,25,27,29])
    bg = 0
    colors = list(range(1,10))
    X, Y, Z = random.sample(colors, 3)
    
    def create_pattern(X, Y):
        return [
            [X, Y, bg],
            [Y, bg, X],
            [bg, X, Y]
        ]
    
    p1 = create_pattern(X, Y)
    
    def rotate_90(pattern):
        return [list(x)[::-1] for x in zip(*pattern)]
    
    p2 = rotate_90(p1)
    p2_swapped = [[Y if x == X else X if x == Y else x for x in row] for row in p2]
    
    def reflect_vertical(pattern):
        return pattern[::-1]
    
    p3 = reflect_vertical(p2_swapped)
    p3_cycled = [[Y if x == X else Z if x == Y else x for x in row] for row in p3]
    
    p4 = rotate_90(p3_cycled)
    p4_swapped = [[Z if x == Y else Y if x == Z else x for x in row] for row in p4]
    
    input_grid = grid(G, G, bg)
    output_grid = grid(G, G, bg)
    
    def place_pattern(grid, pattern, k):
        start = (G - 3) // 2 - (k - 1)
        for r in range(3):
            for c in range(3):
                grid[start + r][start + c] = pattern[r][c]
    
    place_pattern(input_grid, p1, 1)
    place_pattern(input_grid, p2_swapped, 2)
    place_pattern(input_grid, p3_cycled, 3)
    
    place_pattern(output_grid, p1, 1)
    place_pattern(output_grid, p2_swapped, 2)
    place_pattern(output_grid, p3_cycled, 3)
    place_pattern(output_grid, p4_swapped, 4)
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    G = len(input_grid)
    input_grid = [list(row) for row in input_grid]
    start_frame3 = (G - 3) // 2 - 2
    pattern = []
    for r in range(3):
        row = []
        for c in range(3):
            row.append(input_grid[start_frame3 + r][start_frame3 + c])
        pattern.append(row)
    
    rotated = [list(x)[::-1] for x in zip(*pattern)]
    colors = set()
    for r in range(3):
        for c in range(3):
            if rotated[r][c] != 0:
                colors.add(rotated[r][c])
    A, B = sorted(colors)
    swapped = [[B if x == A else A if x == B else x for x in row] for row in rotated]
    
    output_grid = [row[:] for row in input_grid]
    start_frame4 = (G - 3) // 2 - 3
    for r in range(3):
        for c in range(3):
            output_grid[start_frame4 + r][start_frame4 + c] = swapped[r][c]
    
    return output_grid
