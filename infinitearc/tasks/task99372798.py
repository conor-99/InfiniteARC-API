# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 99372798
Difficulty: medium–hard

=== Tags ===
- Source target routing
- Color space mapping
- Grid topology inference
- Multi exit routes
- Move object to nearest corner

=== Description ===
Input grids are medium-sized (15×15 to 25×25) with a uniform background color
(0). Scattered throughout are distinct colored sources (1–9), each occupying
exactly one cell, and obstacles (color 9) that block movement. The grid contains
four corner cells (top-left, top-right, bottom-left, bottom-right) that serve as
target locations. For each source, the output requires drawing the shortest
orthogonal path (no diagonals) from the source to its nearest target corner,
determined by Manhattan distance (with ties broken by corner priority: top-left
> top-right > bottom-left > bottom-right). The path must avoid all obstacles
(color 9) and may not overlap with other paths. The path is drawn using the
source’s color, replacing the background in each cell along the route. The
source cells themselves retain their original color, and the output grid
preserves all input elements except for the added path segments. The task
requires inferring the grid topology (obstacle positions) to compute the
shortest path, with multi-exit routes implying multiple potential paths for some
sources, but only the shortest valid route is drawn. Color space mapping ensures
paths use the source’s color for visual consistency, and the nearest corner rule
enforces deterministic path selection based on geometric proximity.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque

def find_nearest_corner(r, c, width, height):
    corners = [(0, 0), (0, width - 1), (height - 1, 0), (height - 1, width - 1)]
    distances = [(abs(r - cr) + abs(c - cc), idx) for idx, (cr, cc) in enumerate(corners)]
    distances.sort(key=lambda x: (x[0], x[1]))
    return corners[distances[0][1]]

def find_shortest_path(grid, start_r, start_c, target):
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    width = len(grid[0])
    height = len(grid)
    visited = [[False] * width for _ in range(height)]
    parent = {}
    queue = deque()
    queue.append((start_r, start_c))
    visited[start_r][start_c] = True
    parent[(start_r, start_c)] = None
    
    while queue:
        r, c = queue.popleft()
        if (r, c) == target:
            break
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] != 9:
                visited[nr][nc] = True
                parent[(nr, nc)] = (r, c)
                queue.append((nr, nc))
    else:
        return None
    
    path = []
    cur = target
    while cur is not None:
        path.append(cur)
        cur = parent.get(cur)
    return path[::-1]

def generate():
    width = random.randint(15, 25)
    height = random.randint(15, 25)
    grid = [[0] * width for _ in range(height)]
    
    corner_positions = [(0, 0), (0, width - 1), (height - 1, 0), (height - 1, width - 1)]
    num_obstacles = random.randint(10, 20)
    for _ in range(num_obstacles):
        r, c = random.randint(0, height - 1), random.randint(0, width - 1)
        if (r, c) in corner_positions:
            continue
        grid[r][c] = 9
    
    all_cells = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 and (r, c) not in corner_positions:
                all_cells.append((r, c))
    
    num_sources = random.randint(3, 5)
    if len(all_cells) < num_sources:
        return generate()
    source_positions = random.sample(all_cells, num_sources)
    source_colors = random.sample(range(1, 9), num_sources)
    
    for (r, c), color in zip(source_positions, source_colors):
        grid[r][c] = color
    
    paths = []
    for (r, c), color in zip(source_positions, source_colors):
        target = find_nearest_corner(r, c, width, height)
        path = find_shortest_path(grid, r, c, target)
        if path is None:
            return generate()
        paths.append((path, color))
    
    path_cells = set()
    for path, color in paths:
        for (pr, pc) in path:
            if (pr, pc) != (r, c):
                if (pr, pc) in path_cells:
                    return generate()
                path_cells.add((pr, pc))
    
    output = [row[:] for row in grid]
    for path, color in paths:
        for (pr, pc) in path:
            if output[pr][pc] == 0:
                output[pr][pc] = color
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque
def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    
    def find_nearest_corner(r, c, width, height):
        corners = [(0, 0), (0, width - 1), (height - 1, 0), (height - 1, width - 1)]
        distances = [(abs(r - cr) + abs(c - cc), idx) for idx, (cr, cc) in enumerate(corners)]
        distances.sort(key=lambda x: (x[0], x[1]))
        return corners[distances[0][1]]
    
    def find_shortest_path(grid, start_r, start_c, target):
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        width = len(grid[0])
        height = len(grid)
        visited = [[False] * width for _ in range(height)]
        parent = {}
        queue = deque()
        queue.append((start_r, start_c))
        visited[start_r][start_c] = True
        parent[(start_r, start_c)] = None
        
        while queue:
            r, c = queue.popleft()
            if (r, c) == target:
                break
            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] != 9:
                    visited[nr][nc] = True
                    parent[(nr, nc)] = (r, c)
                    queue.append((nr, nc))
        else:
            return None
        
        path = []
        cur = target
        while cur is not None:
            path.append(cur)
            cur = parent.get(cur)
        return path[::-1]
    
    sources = []
    for r in range(height):
        for c in range(width):
            color = input_grid[r][c]
            if 1 <= color <= 8:
                sources.append((r, c, color))
    
    for (r, c, color) in sources:
        target = find_nearest_corner(r, c, width, height)
        path = find_shortest_path(input_grid, r, c, target)
        if path is None:
            continue
        for (pr, pc) in path:
            if input_grid[pr][pc] == 0:
                input_grid[pr][pc] = color
    
    return tuple(tuple(row) for row in input_grid)
