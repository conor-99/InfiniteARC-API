# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 0d64e9c3
Difficulty: very hard

=== Tags ===
- Color implication network
- Rule transfer between regions
- Take complement
- Separate shapes

=== Description ===
Input grids consist of multiple disconnected shapes (each shape is a connected
region of uniform color, 1-9, using 4-connectivity), separated by background
color 0. Shapes are positioned such that no two shapes touch or overlap. The
largest shape (by cell count) is designated as the source region. The smallest
shape (by cell count) is designated as the target region. In the output grid,
all cells within the target shape are replaced with their color complement,
defined as 9 minus the original color value (e.g., color 3 becomes 6, color 8
becomes 1). All other cells—including the source region, other shapes, and
background—remain unchanged. The transformation requires identifying the source
and target shapes through size comparison and applying a fixed visual color
mapping without mathematical operations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    N = random.randint(2, 5)
    sizes = random.sample(range(2, 10), N)
    shapes = []
    for size in sizes:
        pixels = common.continuous_creature(size, width, height)
        # Ensure shape has exactly `size` cells
        while len(pixels) != size:
            pixels = common.continuous_creature(size, width, height)
        shapes.append(pixels)
    
    shapes = sorted(shapes, key=lambda pixels: len(pixels))
    
    shifted_shapes = []
    for i, pixels in enumerate(shapes):
        shift_x = i * (width // (N + 1))
        shift_y = i * (height // (N + 1))
        new_pixels = []
        for (r, c) in pixels:
            nr = r + shift_y
            nc = c + shift_x
            if 0 <= nr < height and 0 <= nc < width:
                new_pixels.append((nr, nc))
        overlap = False
        for prev_shape in shifted_shapes:
            if set(new_pixels) & set(prev_shape):
                overlap = True
                break
        if overlap:
            shift_x += width // (N + 1)
            shift_y += height // (N + 1)
            new_pixels = []
            for (r, c) in pixels:
                nr = r + shift_y
                nc = c + shift_x
                if 0 <= nr < height and 0 <= nc < width:
                    new_pixels.append((nr, nc))
        shifted_shapes.append(new_pixels)
    
    colors = [random.randint(1, 9) for _ in range(N)]
    input_grid = common.grid(width, height, 0)
    for i, pixels in enumerate(shifted_shapes):
        for (r, c) in pixels:
            input_grid[r][c] = colors[i]
    
    smallest_shape = shifted_shapes[0]
    output_grid = [row[:] for row in input_grid]
    for (r, c) in smallest_shape:
        output_grid[r][c] = 9 - input_grid[r][c]
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    visited = [[False] * width for _ in range(height)]
    components = []
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and input_grid[r][c] != 0:
                color = input_grid[r][c]
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                components.append((color, component))
    
    if not components:
        return input_grid
    
    smallest_comp = min(components, key=lambda x: (len(x[1]), x[1][0][0], x[1][0][1]))
    output_grid = [row[:] for row in input_grid]
    for (r, c) in smallest_comp[1]:
        output_grid[r][c] = 9 - input_grid[r][c]
    
    return output_grid
