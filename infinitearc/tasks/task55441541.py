# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 55441541
Difficulty: hard

=== Tags ===
- Layered occlusion unfolding
- Count different colors

=== Description ===
The task involves transforming an input grid where specific cells (marked with
color 0, representing occlusion) are replaced by the count of distinct non-zero
colors in their immediate 3x3 neighborhood. For each occluded cell (value 0),
the output grid displays the number of unique colors present in the surrounding
cells (excluding 0s). Non-occluded cells retain their original values. This
requires identifying occluded regions and visually counting the variety of
colors in adjacent areas to determine the correct output values, making it a
complex visual reasoning challenge.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    h = common.randint(3, 30)
    w = common.randint(3, 30)
    input_grid = common.grid(w, h, common.random_color(exclude=[0]))
    inner_positions = [(r, c) for r in range(1, h-1) for c in range(1, w-1)]
    if not inner_positions:
        inner_positions = [(1, 1)]
    upper = max(1, len(inner_positions) // 2)
    num_zeros = common.randint(1, upper)
    zero_positions = common.sample(inner_positions, num_zeros)
    for r, c in zero_positions:
        input_grid[r][c] = 0
    output_grid = [row[:] for row in input_grid]
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] == 0:
                colors = set()
                for dr in (-1, 0, 1):
                    for dc in (-1, 0, 1):
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < h and 0 <= nc < w:
                            val = input_grid[nr][nc]
                            if val != 0:
                                colors.add(val)
                output_grid[r][c] = len(colors)
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    h = len(input_grid)
    w = len(input_grid[0])
    output_grid = [row[:] for row in input_grid]
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] == 0:
                colors = set()
                for dr in (-1, 0, 1):
                    for dc in (-1, 0, 1):
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < h and 0 <= nc < w:
                            val = input_grid[nr][nc]
                            if val != 0:
                                colors.add(val)
                output_grid[r][c] = len(colors)
    return output_grid
