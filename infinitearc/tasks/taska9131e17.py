# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: a9131e17
Difficulty: insane

=== Tags ===
- Gravity with barriers
- Circuit reflection
- Take minimum
- Recolor object based on neighbor count

=== Description ===
**Gravity-Barrier Circuit Refraction**  Input grids consist of a background
(color 0), fixed barrier structures (color 1) arranged in interconnected
pathways, and mobile objects (colors 2-9) positioned above barriers. Barriers
form non-orthogonal, continuous paths with varying widths, creating enclosed
"circuit" routes. Mobile objects are initially placed in open background cells,
not adjacent to barriers.  The transformation applies three sequential rules:
1. **Gravity with barriers**: All mobile objects fall downward (increasing row
index) until they contact a barrier (color 1) or the grid bottom. Objects fall
in parallel, maintaining horizontal relative positions. Falling objects stop
immediately upon contact with barriers but do not occupy barrier cells.  2.
**Circuit reflection**: After falling, objects adjacent to barriers undergo
reflection. The barrier's orientation (vertical/horizontal) determines the
reflection direction: vertical barriers reflect objects horizontally
(left/right), horizontal barriers reflect vertically (up/down). The reflection
propagates through the barrier network, causing objects to "trace" the circuit
path until they exit the grid boundary. The output grid visualizes the *entire
reflected path* as a continuous line, with each segment's color cycling through
the object's original color sequence.  3. **Recolor and minimum**: For each
segment of the reflected path, the color is determined by the *minimum* between
the object's original color and the neighbor count (orthogonal cells with color
> 0 in the *input* grid). If the neighbor count exceeds 9, it cycles (e.g.,
count=10 â†’ color=1). The background remains unchanged except for the path
segments.  Output grids retain barriers and background unchanged, with all
reflected paths drawn as continuous lines using the recolored segments. No two
paths overlap, and all objects exit the grid within 15 reflections. The
transformation requires identifying barrier orientations, simulating path
reflections, and dynamically recoloring based on neighbor counts and minimum
rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

# Small deterministic counter so repeated calls produce different grids
_GENERATE_COUNTER = 0


def _draw_h_line(grid, r, c1, c2, thickness=1):
    height = len(grid)
    width = len(grid[0])
    for c in range(min(c1, c2), max(c1, c2) + 1):
        for t in range(thickness):
            rr = r + t - (thickness // 2)
            if 0 <= rr < height:
                grid[rr][c] = 1


def _draw_v_line(grid, c, r1, r2, thickness=1):
    height = len(grid)
    width = len(grid[0])
    for r in range(min(r1, r2), max(r1, r2) + 1):
        for t in range(thickness):
            cc = c + t - (thickness // 2)
            if 0 <= cc < width:
                grid[r][cc] = 1


def _draw_rect(grid, top, left, bottom, right, thickness=1):
    for t in range(thickness):
        _draw_h_line(grid, top + t, left, right, 1)
        _draw_h_line(grid, bottom - t, left, right, 1)
        _draw_v_line(grid, left + t, top, bottom, 1)
        _draw_v_line(grid, right - t, top, bottom, 1)


def _in_bounds(r, c, h, w):
    return 0 <= r < h and 0 <= c < w


def generate():
    """
    Generates an input/output pair following the specification.
    The generator builds a connected-ish barrier network composed of line segments and rectangles,
    places 1-3 mobile objects above barriers (not adjacent), and simulates the gravity + reflection
    tracing along barrier boundaries. The output contains the recolored traced paths.
    """
    global _GENERATE_COUNTER
    # Make sure we always produce different examples across repeated calls
    call_id = _GENERATE_COUNTER
    _GENERATE_COUNTER += 1

    # Grid size (kept moderate for speed and validation reliability)
    width = random.randint(10, 18)
    height = random.randint(10, 18)
    ingrid = [[0 for _ in range(width)] for _ in range(height)]

    # Draw a number of L-shaped segments (horizontal then vertical or vice versa) with random thickness
    segments = random.randint(3, 6)
    for s in range(segments):
        r1 = random.randint(1, height - 2)
        c1 = random.randint(1, width - 2)
        r2 = random.randint(1, height - 2)
        c2 = random.randint(1, width - 2)
        thickness = random.choice([1, 1, 2])
        if (call_id + s) % 2 == 0:
            _draw_h_line(ingrid, r1, c1, c2, thickness)
            _draw_v_line(ingrid, c2, r1, r2, thickness)
        else:
            _draw_v_line(ingrid, c1, r1, r2, thickness)
            _draw_h_line(ingrid, r2, c1, c2, thickness)

    # Add a few rectangular loops to create circuit-like routes
    loops = random.randint(0, 2)
    for _ in range(loops):
        top = random.randint(1, max(1, height - 5))
        left = random.randint(1, max(1, width - 5))
        bottom = min(height - 2, top + random.randint(2, 4))
        right = min(width - 2, left + random.randint(2, 4))
        _draw_rect(ingrid, top, left, bottom, right, thickness=1)

    # Ensure at least one barrier touches the boundary so reflected traces can exit the grid
    side = (call_id % 4)
    if side == 0:
        r = random.randint(0, height - 1)
        ingrid[r][0] = 1
    elif side == 1:
        r = random.randint(0, height - 1)
        ingrid[r][width - 1] = 1
    elif side == 2:
        c = random.randint(0, width - 1)
        ingrid[0][c] = 1
    else:
        c = random.randint(0, width - 1)
        ingrid[height - 1][c] = 1

    # Collect columns that have a barrier somewhere
    columns_with_barrier = set()
    for r in range(height):
        for c in range(width):
            if ingrid[r][c] == 1:
                columns_with_barrier.add(c)
    if not columns_with_barrier:
        # Ensure there is at least one barrier if something went wrong
        rr, cc = height // 2, width // 2
        ingrid[rr][cc] = 1
        columns_with_barrier.add(cc)

    # Candidate columns for placing objects: require at least two empty cells above the top-most barrier
    potential_cols = []
    for c in columns_with_barrier:
        barrier_rows = [r for r in range(height) if ingrid[r][c] == 1]
        if not barrier_rows:
            continue
        top_barrier_row = min(barrier_rows)
        # need at least one space between object and barrier and the object should not be adjacent
        if top_barrier_row >= 2:
            potential_cols.append((c, top_barrier_row))

    # If no potential columns, turn some existing barrier cells into a barrier row to create space
    if not potential_cols:
        # carve a shallow horizontal barrier near the bottom and make its column candidates
        base_row = max(2, height - 4)
        for c in range(1, width - 1):
            ingrid[base_row][c] = 1
        for c in range(width):
            potential_cols.append((c, base_row))

    # Place 1-3 objects in distinct columns
    num_objects = random.randint(1, min(3, len(potential_cols)))
    chosen = random.sample(potential_cols, num_objects)
    object_positions = []
    object_colors = []

    for (c, top_barrier_row) in chosen:
        # choose an object row well above the barrier and not adjacent to any barrier
        placed = False
        attempts = 0
        while not placed and attempts < 10:
            attempts += 1
            r_obj = random.randint(0, top_barrier_row - 2)
            if ingrid[r_obj][c] != 0:
                continue
            adj_barrier = False
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                rr = r_obj + dr
                cc = c + dc
                if 0 <= rr < height and 0 <= cc < width and ingrid[rr][cc] == 1:
                    adj_barrier = True
                    break
            if adj_barrier:
                continue
            # good placement
            object_positions.append((r_obj, c))
            object_colors.append(random.randint(2, 9))
            ingrid[r_obj][c] = object_colors[-1]
            placed = True
        # if we failed to place in this column, skip it

    # If somehow no object was placed (shouldn't happen), place one at a safe default
    if not object_positions:
        # find a column with a barrier and put the object at top row 0 if it's not adjacent
        c = list(columns_with_barrier)[0]
        r_obj = 0
        if ingrid[r_obj][c] == 0:
            object_positions.append((r_obj, c))
            object_colors.append(random.randint(2, 9))
            ingrid[r_obj][c] = object_colors[-1]

    # Now simulate gravity and reflection to create the output grid
    output = [row[:] for row in ingrid]

    def _is_barrier(rr, cc):
        return 0 <= rr < height and 0 <= cc < width and ingrid[rr][cc] == 1

    def _is_background(rr, cc):
        return 0 <= rr < height and 0 <= cc < width and ingrid[rr][cc] == 0

    def _is_boundary_cell(rr, cc):
        # background cell that touches a barrier orthogonally
        if not _is_background(rr, cc):
            return False
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            if _is_barrier(rr + dr, cc + dc):
                return True
        return False

    used_cells = set()

    # Process objects in scanning order (top-to-bottom, left-to-right) so that solver's scanning order matches
    objects = list(zip(object_positions, object_colors))
    objects.sort(key=lambda item: (item[0][0], item[0][1]))

    for (r0, c0), color in objects:
        # Gravity: fall until the cell below is barrier or bottom
        new_r = r0
        while new_r < height - 1 and ingrid[new_r + 1][c0] == 0:
            new_r += 1
        start_r, start_c = new_r, c0

        # If not adjacent to a barrier after falling, nothing to trace
        if not any(_is_barrier(start_r + dr, start_c + dc) for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]):
            # If it landed on bottom with no barrier adjacency, leave the object in place (no path)
            continue

        # Choose which adjacent barrier to consider (deterministic order: down, left, right, up)
        adj_dir = None
        for dr, dc in [(1, 0), (0, -1), (0, 1), (-1, 0)]:
            br, bc = start_r + dr, start_c + dc
            if _is_barrier(br, bc):
                adj_dir = (dr, dc, br, bc)
                break

        # Determine barrier orientation
        if adj_dir is None:
            continue
        br, bc = adj_dir[2], adj_dir[3]
        vertical = (_is_barrier(br - 1, bc) or _is_barrier(br + 1, bc))
        horizontal = (_is_barrier(br, bc - 1) or _is_barrier(br, bc + 1))

        # initial preference based on barrier orientation
        if vertical and not horizontal:
            preferred_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)]  # reflect horizontally
        elif horizontal and not vertical:
            preferred_dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # reflect vertically
        else:
            # intersection or single pixel: prefer turning left first, then up, right, down
            preferred_dirs = [(0, -1), (-1, 0), (0, 1), (1, 0)]

        # Trace along the boundary: always move to background cells that touch a barrier and avoid barriers
        path = [(start_r, start_c)]
        prev = None
        max_steps = width * height  # safe upper bound
        steps = 0
        while steps < max_steps:
            steps += 1
            cur_r, cur_c = path[-1]

            # If we are at the edge and moving in any preferred dir would step outside, stop to simulate exit
            exited = False
            for d in preferred_dirs:
                nr, nc = cur_r + d[0], cur_c + d[1]
                if not _in_bounds(nr, nc, height, width):
                    # an exit in preferred direction
                    exited = True
                    break
            if exited:
                break

            found = False
            # Try preferred dirs first (while avoiding going back to prev), then fallback order
            for d in preferred_dirs + [(-1, 0), (0, -1), (1, 0), (0, 1)]:
                nr, nc = cur_r + d[0], cur_c + d[1]
                if not _in_bounds(nr, nc, height, width):
                    continue
                if (nr, nc) == prev:
                    continue
                if not _is_background(nr, nc):
                    continue
                if not _is_boundary_cell(nr, nc):
                    continue
                if (nr, nc) in used_cells:
                    # avoid overlapping other object's path
                    continue
                # choose this move
                prev = (cur_r, cur_c)
                path.append((nr, nc))
                found = True
                break
            if not found:
                break

        # Mark used cells and color them in the output using the recolor/min rule
        for (pr, pc) in path:
            used_cells.add((pr, pc))
            # count orthogonal neighbors in the input grid that are > 0
            count = 0
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                rr, cc = pr + dr, pc + dc
                if 0 <= rr < height and 0 <= cc < width and ingrid[rr][cc] > 0:
                    count += 1
            # cycle counts into 1..9
            effective = ((count - 1) % 9) + 1
            new_color = min(color, effective)
            output[pr][pc] = new_color

    return {"input": ingrid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input (tuple of tuples) to list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    def _in_bounds(r, c):
        return 0 <= r < height and 0 <= c < width

    def _is_barrier(r, c):
        return _in_bounds(r, c) and grid[r][c] == 1

    def _is_background(r, c):
        return _in_bounds(r, c) and grid[r][c] == 0

    def _is_boundary_cell(r, c):
        if not _is_background(r, c):
            return False
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            if _is_barrier(r + dr, c + dc):
                return True
        return False

    # Find object positions (colors 2..9)
    objects = []
    for r in range(height):
        for c in range(width):
            if 2 <= grid[r][c] <= 9:
                objects.append((r, c, grid[r][c]))

    output = [row[:] for row in grid]
    used_cells = set()

    for (r0, c0, color) in objects:
        # Gravity: fall until the cell below is barrier or bottom
        new_r = r0
        while new_r < height - 1 and grid[new_r + 1][c0] == 0:
            new_r += 1
        start_r, start_c = new_r, c0

        # If not adjacent to a barrier after falling, nothing to trace
        if not any(_is_barrier(start_r + dr, start_c + dc) for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]):
            continue

        # Choose which adjacent barrier to consider (deterministic order: down, left, right, up)
        adj = None
        for dr, dc in [(1, 0), (0, -1), (0, 1), (-1, 0)]:
            br, bc = start_r + dr, start_c + dc
            if _is_barrier(br, bc):
                adj = (dr, dc, br, bc)
                break
        if adj is None:
            continue

        br, bc = adj[2], adj[3]
        vertical = (_is_barrier(br - 1, bc) or _is_barrier(br + 1, bc))
        horizontal = (_is_barrier(br, bc - 1) or _is_barrier(br, bc + 1))

        if vertical and not horizontal:
            preferred_dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)]
        elif horizontal and not vertical:
            preferred_dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        else:
            preferred_dirs = [(0, -1), (-1, 0), (0, 1), (1, 0)]

        path = [(start_r, start_c)]
        prev = None
        max_steps = width * height
        steps = 0
        while steps < max_steps:
            steps += 1
            cur_r, cur_c = path[-1]

            # If any preferred direction would step outside, treat that as an exit
            exited = False
            for d in preferred_dirs:
                nr, nc = cur_r + d[0], cur_c + d[1]
                if not _in_bounds(nr, nc):
                    exited = True
                    break
            if exited:
                break

            found = False
            for d in preferred_dirs + [(-1, 0), (0, -1), (1, 0), (0, 1)]:
                nr, nc = cur_r + d[0], cur_c + d[1]
                if not _in_bounds(nr, nc):
                    continue
                if (nr, nc) == prev:
                    continue
                if not _is_background(nr, nc):
                    continue
                if not _is_boundary_cell(nr, nc):
                    continue
                if (nr, nc) in used_cells:
                    continue
                prev = (cur_r, cur_c)
                path.append((nr, nc))
                found = True
                break
            if not found:
                break

        for (pr, pc) in path:
            used_cells.add((pr, pc))
            count = 0
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                rr, cc = pr + dr, pc + dc
                if 0 <= rr < height and 0 <= cc < width and grid[rr][cc] > 0:
                    count += 1
            effective = ((count - 1) % 9) + 1
            new_color = min(color, effective)
            output[pr][pc] = new_color

    return output

