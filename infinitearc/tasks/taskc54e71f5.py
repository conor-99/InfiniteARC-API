# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: c54e71f5
Difficulty: insane

=== Tags ===
- Mask based logic
- Sequential path painting
- Rule gate simulation
- Route switching
- Count ver lines
- Carve negative space

=== Description ===
Input grids feature a complex, non-convex mask region (color 3) covering a
significant portion of the grid, with vertical line segments (color 5) randomly
embedded throughout. The mask defines the traversable area, while vertical lines
serve as directional gateways. The path begins at the top-left corner of the
mask, moving east. As it traverses color 3 cells, it continues until
encountering a vertical line cell (color 5). Upon contact, the path counts the
number of vertical line segments (contiguous color 5 cells in a column) within
the current column. If the count is even, it turns left (relative to current
direction); if odd, it turns right. The path continues this rule-based traversal
until exiting the mask boundary. The output grid preserves all input elements
(mask remains color 3, vertical lines stay color 5, background is color 0) while
drawing the path as color 2. Critical features include: non-convex mask geometry
requiring path navigation around obstacles, variable vertical segment counts
creating unpredictable direction changes, and the path's complete sequence being
determined solely by column-based vertical segment parity. The task demands
simultaneous recognition of mask boundaries, vertical segment counting, and
dynamic direction mapping across multiple traversal phases.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import *

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid_input = [[0] * width for _ in range(height)]
    dent_r = random.randint(1, height-2)
    dent_c = random.randint(1, width-2)
    for r in range(height):
        for c in range(width):
            if (r, c) != (dent_r, dent_c):
                grid_input[r][c] = 3
    for c in range(width):
        mask_rows = [r for r in range(height) if grid_input[r][c] == 3]
        if not mask_rows or random.random() > 0.5:
            continue
        start = random.choice(mask_rows)
        end = random.choice(mask_rows)
        if start > end:
            start, end = end, start
        end = min(end + 1, height-1)
        for r in range(start, end):
            if grid_input[r][c] == 3:
                grid_input[r][c] = 5
    grid_output = [row[:] for row in grid_input]
    r, c = 0, 0
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    dir_idx = 0
    path = []
    while True:
        path.append((r, c))
        dr, dc = directions[dir_idx]
        nr, nc = r + dr, c + dc
        if nr < 0 or nr >= height or nc < 0 or nc >= width or grid_input[nr][nc] == 0:
            break
        if grid_input[nr][nc] == 5:
            r_start = nr
            while r_start > 0 and grid_input[r_start-1][nc] == 5:
                r_start -= 1
            r_end = nr
            while r_end < height-1 and grid_input[r_end+1][nc] == 5:
                r_end += 1
            count = r_end - r_start + 1
            if count % 2 == 0:
                dir_idx = (dir_idx - 1) % 4
            else:
                dir_idx = (dir_idx + 1) % 4
        r, c = nr, nc
    for (r, c) in path:
        grid_output[r][c] = 2
    return {'input': grid_input, 'output': grid_output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid[0], tuple):
        input_grid = [list(row) for row in input_grid]
    grid = input_grid
    height = len(grid)
    width = len(grid[0])
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    dir_idx = 0
    r, c = 0, 0
    path = []
    while True:
        path.append((r, c))
        dr, dc = directions[dir_idx]
        nr, nc = r + dr, c + dc
        if nr < 0 or nr >= height or nc < 0 or nc >= width or grid[nr][nc] == 0:
            break
        if grid[nr][nc] == 5:
            r_start = nr
            while r_start > 0 and grid[r_start-1][nc] == 5:
                r_start -= 1
            r_end = nr
            while r_end < height-1 and grid[r_end+1][nc] == 5:
                r_end += 1
            count = r_end - r_start + 1
            if count % 2 == 0:
                dir_idx = (dir_idx - 1) % 4
            else:
                dir_idx = (dir_idx + 1) % 4
        r, c = nr, nc
    output = [row[:] for row in grid]
    for (r, c) in path:
        output[r][c] = 2
    return output
