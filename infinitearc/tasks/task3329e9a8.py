# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 3329e9a8
Difficulty: medium–hard

=== Tags ===
- Enclosure completion
- Role dependent behavior
- Pattern moving

=== Description ===
The task involves grids containing multiple irregularly shaped enclosed regions,
each partially bounded by walls (missing segments). Within each enclosure, a
unique role marker (a single cell of a specific color) and a small 2×2 color
pattern are present. The role marker's color determines the direction of two
transformations: the enclosure's missing wall is completed in that direction,
and the pattern is shifted one cell in the same direction (wrapping around if
necessary).   Color-to-direction mapping is fixed: red (color 2) moves right,
blue (color 1) moves down, green (color 3) moves left, yellow (color 4) moves
up. For example, an enclosure with a red role marker will have its right wall
completed with red, and the pattern will shift right. Enclosure walls are
completed with the role marker's color, and the pattern is shifted orthogonally.
All other grid elements (background, unrelated walls, patterns) remain
unchanged. The output grid must reflect all enclosure completions and pattern
shifts simultaneously, requiring the solver to identify each enclosure's role
marker, apply the direction mapping, and execute both transformations in
parallel.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Generator for ARC task 462

def generate():
    # Fixed wall color and pattern color ranges
    WALL = 5
    BACK = 0
    ROLE_COLORS = [1, 2, 3, 4]  # 1: down, 2: right, 3: left, 4: up
    PATTERN_COLORS = [6, 7, 8, 9]

    def get_direction(role_color):
        if role_color == 1:
            return 'down'
        if role_color == 2:
            return 'right'
        if role_color == 3:
            return 'left'
        if role_color == 4:
            return 'up'
        return None

    # Grid size (varies for uniqueness but remains reasonable)
    width = random.randint(12, 18)
    height = random.randint(12, 18)

    input_grid = grid(width, height, BACK)
    output_grid = grid(width, height, BACK)

    enclosures = []  # store placed enclosure specs

    # Helper to test if two outer boxes (top,left,bottom,right) overlap or are too close
    def boxes_conflict(a, b, gap=1):
        at, al, ab, ar = a
        bt, bl, bb, br = b
        if al > br + gap or bl > ar + gap or at > bb + gap or bt > ab + gap:
            return False
        return True

    # Keep track of taken outer boxes for spacing
    boxes = []

    num_enclosures = random.randint(2, 3)

    attempts_total = 0
    placed = 0
    while placed < num_enclosures and attempts_total < 200:
        attempts_total += 1
        # interior size (must be at least 3x3 to allow 2x2 pattern + movement)
        interior_h = random.randint(3, 6)
        interior_w = random.randint(3, 6)
        outer_h = interior_h + 2
        outer_w = interior_w + 2

        # choose top/left so outer rectangle fits with at least one-cell margin from edges
        if height - outer_h - 1 >= 1:
            top = random.randint(1, height - outer_h - 1)
        else:
            top = random.randint(0, max(0, height - outer_h))
        if width - outer_w - 1 >= 1:
            left = random.randint(1, width - outer_w - 1)
        else:
            left = random.randint(0, max(0, width - outer_w))

        bottom = top + outer_h - 1
        right = left + outer_w - 1

        cand_box = (top, left, bottom, right)
        conflict = False
        for b in boxes:
            if boxes_conflict(cand_box, b, gap=1):
                conflict = True
                break
        if conflict:
            continue

        role_color = random.choice(ROLE_COLORS)
        direction = get_direction(role_color)

        # choose role marker inside interior
        r_marker = random.randint(top + 1, bottom - 1)
        c_marker = random.randint(left + 1, right - 1)

        # try to choose a 2x2 pattern placement that doesn't conflict with marker
        pattern_ok = False
        for _ in range(120):
            pr = random.randint(top + 1, bottom - 2)
            pc = random.randint(left + 1, right - 2)
            pattern_positions = [(pr + dr, pc + dc) for dr in range(2) for dc in range(2)]
            # must not overlap role marker
            if (r_marker, c_marker) in pattern_positions:
                continue

            # compute shifted positions with wrapping inside interior
            interior_top = top + 1
            interior_bottom = bottom - 1
            interior_left = left + 1
            interior_right = right - 1

            new_positions = []
            for (r0, c0) in pattern_positions:
                if direction == 'right':
                    nc = c0 + 1
                    if nc > interior_right:
                        nc = interior_left
                    new_positions.append((r0, nc))
                elif direction == 'left':
                    nc = c0 - 1
                    if nc < interior_left:
                        nc = interior_right
                    new_positions.append((r0, nc))
                elif direction == 'down':
                    nr = r0 + 1
                    if nr > interior_bottom:
                        nr = interior_top
                    new_positions.append((nr, c0))
                elif direction == 'up':
                    nr = r0 - 1
                    if nr < interior_top:
                        nr = interior_bottom
                    new_positions.append((nr, c0))

            # Ensure pattern positions and their shifted positions are inside interior and do not touch
            invalid = False
            for pos in pattern_positions + new_positions:
                rpos, cpos = pos
                if not (interior_top <= rpos <= interior_bottom and interior_left <= cpos <= interior_right):
                    invalid = True
                    break
                # also ensure not overlapping previously placed interiors
                for b in boxes:
                    bt, bl, bb, br = b
                    # interior region of existing enclosure
                    i_t, i_l, i_b, i_r = bt + 1, bl + 1, bb - 1, br - 1
                    if i_l <= cpos <= i_r and i_t <= rpos <= i_b:
                        invalid = True
                        break
                if invalid:
                    break
            if invalid:
                continue

            # pattern placement seems valid
            pattern_ok = True
            pattern_start = (pr, pc)
            break

        if not pattern_ok:
            continue

        # choose four colors for the 2x2 pattern
        pattern_colors = random.sample(PATTERN_COLORS, 4)

        # Commit walls to grids (initially full walls)
        for r in range(top, bottom + 1):
            for c in range(left, right + 1):
                if r == top or r == bottom or c == left or c == right:
                    input_grid[r][c] = WALL
                    output_grid[r][c] = WALL

        # Remove the missing wall in the input (the side implied by the role marker)
        if direction == 'right':
            for r in range(top, bottom + 1):
                input_grid[r][right] = BACK
        elif direction == 'left':
            for r in range(top, bottom + 1):
                input_grid[r][left] = BACK
        elif direction == 'up':
            for c in range(left, right + 1):
                input_grid[top][c] = BACK
        elif direction == 'down':
            for c in range(left, right + 1):
                input_grid[bottom][c] = BACK

        # Place role marker (single cell)
        input_grid[r_marker][c_marker] = role_color
        output_grid[r_marker][c_marker] = role_color

        # Place pattern into input (and into output for now; we'll shift in output later)
        pr, pc = pattern_start
        for idx, (dr, dc) in enumerate([(0, 0), (0, 1), (1, 0), (1, 1)]):
            rpos, cpos = pr + dr, pc + dc
            color = pattern_colors[idx]
            input_grid[rpos][cpos] = color
            output_grid[rpos][cpos] = color

        # record enclosure
        enclosures.append((top, left, bottom, right, role_color, pr, pc, pattern_colors))
        boxes.append(cand_box)
        placed += 1

    # Apply transformations to the output grid: fill missing wall with role_color and shift pattern
    for (top, left, bottom, right, role_color, pr, pc, pattern_colors) in enclosures:
        direction = get_direction(role_color)
        # fill missing wall in output with role color
        if direction == 'right':
            for r in range(top, bottom + 1):
                output_grid[r][right] = role_color
        elif direction == 'left':
            for r in range(top, bottom + 1):
                output_grid[r][left] = role_color
        elif direction == 'up':
            for c in range(left, right + 1):
                output_grid[top][c] = role_color
        elif direction == 'down':
            for c in range(left, right + 1):
                output_grid[bottom][c] = role_color

        # shift pattern inside output with wrapping
        pattern_positions = [(pr + dr, pc + dc) for dr in range(2) for dc in range(2)]
        interior_top = top + 1
        interior_bottom = bottom - 1
        interior_left = left + 1
        interior_right = right - 1

        new_positions = []
        for (r0, c0) in pattern_positions:
            if direction == 'right':
                nc = c0 + 1
                if nc > interior_right:
                    nc = interior_left
                new_positions.append((r0, nc))
            elif direction == 'left':
                nc = c0 - 1
                if nc < interior_left:
                    nc = interior_right
                new_positions.append((r0, nc))
            elif direction == 'down':
                nr = r0 + 1
                if nr > interior_bottom:
                    nr = interior_top
                new_positions.append((nr, c0))
            elif direction == 'up':
                nr = r0 - 1
                if nr < interior_top:
                    nr = interior_bottom
                new_positions.append((nr, c0))

        # clear old pattern in output
        for (r0, c0) in pattern_positions:
            output_grid[r0][c0] = BACK

        # place new pattern colors in output
        for idx, (rnew, cnew) in enumerate(new_positions):
            output_grid[rnew][cnew] = pattern_colors[idx]

    return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Accept either tuple-of-tuples or list-of-lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])

    WALL = 5
    BACK = 0

    def get_direction(role_color):
        if role_color == 1:
            return 'down'
        if role_color == 2:
            return 'right'
        if role_color == 3:
            return 'left'
        if role_color == 4:
            return 'up'
        return None

    # Find all wall connected components (4-connected)
    visited = [[False] * w for _ in range(h)]
    components = []  # list of (coords_list, minr, minc, maxr, maxc)
    for r in range(h):
        for c in range(w):
            if grid[r][c] != WALL or visited[r][c]:
                continue
            # BFS
            stack = [(r, c)]
            visited[r][c] = True
            coords = []
            minr, maxr, minc, maxc = r, r, c, c
            while stack:
                rr, cc = stack.pop()
                coords.append((rr, cc))
                if rr < minr: minr = rr
                if rr > maxr: maxr = rr
                if cc < minc: minc = cc
                if cc > maxc: maxc = cc
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] == WALL:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            components.append((coords, minr, minc, maxr, maxc))

    # find role markers
    role_markers = []  # list of (r,c,color)
    for r in range(h):
        for c in range(w):
            if 1 <= grid[r][c] <= 4:
                role_markers.append((r, c, grid[r][c]))

    out = [row[:] for row in grid]

    # for each role marker, associate with the enclosing wall component
    for (rmr, rmc, role_color) in role_markers:
        direction = get_direction(role_color)
        # find the component whose bounding box contains the marker
        chosen = None
        for (coords, minr, minc, maxr, maxc) in components:
            if minr <= rmr <= maxr and minc <= rmc <= maxc:
                chosen = (coords, minr, minc, maxr, maxc)
                break
        if chosen is None:
            # fallback: choose nearest component by distance to bounding box
            best = None
            best_dist = None
            for (coords, minr, minc, maxr, maxc) in components:
                # distance from marker to bounding box
                dr = 0
                if rmr < minr:
                    dr = minr - rmr
                elif rmr > maxr:
                    dr = rmr - maxr
                dc = 0
                if rmc < minc:
                    dc = minc - rmc
                elif rmc > maxc:
                    dc = rmc - maxc
                dist = dr + dc
                if best_dist is None or dist < best_dist:
                    best_dist = dist
                    best = (coords, minr, minc, maxr, maxc)
            chosen = best

        if chosen is None:
            continue

        (coords, minr, minc, maxr, maxc) = chosen
        # reconstruct the full outer rectangle depending on missing side
        if direction == 'right':
            top = minr
            bottom = maxr
            left = minc
            right = maxc + 1
        elif direction == 'left':
            top = minr
            bottom = maxr
            left = minc - 1
            right = maxc
        elif direction == 'up':
            top = minr - 1
            bottom = maxr
            left = minc
            right = maxc
        elif direction == 'down':
            top = minr
            bottom = maxr + 1
            left = minc
            right = maxc
        else:
            # unknown, skip
            continue

        # Clip to grid bounds (safety)
        top = max(0, top)
        left = max(0, left)
        bottom = min(h - 1, bottom)
        right = min(w - 1, right)

        # Fill the missing wall in the output with the role color
        if direction == 'right':
            for rr in range(top, bottom + 1):
                out[rr][right] = role_color
        elif direction == 'left':
            for rr in range(top, bottom + 1):
                out[rr][left] = role_color
        elif direction == 'up':
            for cc in range(left, right + 1):
                out[top][cc] = role_color
        elif direction == 'down':
            for cc in range(left, right + 1):
                out[bottom][cc] = role_color

        # find the 2x2 pattern inside the interior
        interior_top = top + 1
        interior_bottom = bottom - 1
        interior_left = left + 1
        interior_right = right - 1

        pattern_found = False
        pattern_start = None
        pattern_colors = None
        for rr in range(interior_top, interior_bottom):
            for cc in range(interior_left, interior_right):
                # check 2x2 block rr,cc -> rr+1,cc+1
                if rr + 1 > interior_bottom or cc + 1 > interior_right:
                    continue
                vals = [grid[rr][cc], grid[rr][cc + 1], grid[rr + 1][cc], grid[rr + 1][cc + 1]]
                # pattern colors were chosen from 6..9 in generator
                if all(v >= 6 for v in vals):
                    pattern_found = True
                    pattern_start = (rr, cc)
                    pattern_colors = vals
                    break
            if pattern_found:
                break

        if not pattern_found:
            # Nothing to move for this enclosure
            continue

        pr, pc = pattern_start
        # clear old pattern cells in the output
        for dr in range(2):
            for dc in range(2):
                out[pr + dr][pc + dc] = BACK

        # compute new positions with wrapping
        new_positions = []
        for dr in range(2):
            for dc in range(2):
                r0 = pr + dr
                c0 = pc + dc
                if direction == 'right':
                    nc = c0 + 1
                    if nc > interior_right:
                        nc = interior_left
                    new_positions.append((r0, nc))
                elif direction == 'left':
                    nc = c0 - 1
                    if nc < interior_left:
                        nc = interior_right
                    new_positions.append((r0, nc))
                elif direction == 'down':
                    nr = r0 + 1
                    if nr > interior_bottom:
                        nr = interior_top
                    new_positions.append((nr, c0))
                elif direction == 'up':
                    nr = r0 - 1
                    if nr < interior_top:
                        nr = interior_bottom
                    new_positions.append((nr, c0))

        # place pattern colors into new positions (preserve mapping order)
        for idx, (rnew, cnew) in enumerate(new_positions):
            out[rnew][cnew] = pattern_colors[idx]

    return [tuple(row) for row in out]
