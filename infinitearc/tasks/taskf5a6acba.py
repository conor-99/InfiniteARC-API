# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: f5a6acba
Difficulty: mediumâ€“hard

=== Tags ===
- Draw pattern from point
- Color signal exchange
- Threshold by touch count

=== Description ===
The input grid consists of cells colored with values from 0 to 9, where 0
represents background. The output grid is generated by modifying all non-
background cells that have at least two adjacent (horizontally or vertically)
neighbors of color 2 to color 3. This creates a pattern where cells forming
clusters with sufficient adjacency to color 2 are highlighted with color 3,
effectively drawing a boundary or structural pattern around these clusters. The
transformation follows a consistent rule based solely on neighbor counts,
avoiding numerical operations, and results in a visually distinct output that
reveals the spatial relationship between color 2 clusters and their surrounding
cells.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(2, 30)
    height = random.randint(2, 30)
    grid = [[0] * width for _ in range(height)]
    r = random.randint(1, height - 1)
    c = random.randint(1, width - 1)
    grid[r - 1][c] = 2
    grid[r][c - 1] = 2
    grid[r][c] = 1
    for i in range(height):
        for j in range(width):
            if grid[i][j] == 0:
                grid[i][j] = random.randint(0, 9)
    output = [row[:] for row in grid]
    for i in range(height):
        for j in range(width):
            if grid[i][j] != 0:
                count = 0
                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    ni, nj = i + dx, j + dy
                    if 0 <= ni < height and 0 <= nj < width and grid[ni][nj] == 2:
                        count += 1
                if count >= 2:
                    output[i][j] = 3
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    output = [list(row) for row in input_grid]
    for i in range(height):
        for j in range(width):
            if input_grid[i][j] != 0:
                count = 0
                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    ni, nj = i + dx, j + dy
                    if 0 <= ni < height and 0 <= nj < width and input_grid[ni][nj] == 2:
                        count += 1
                if count >= 2:
                    output[i][j] = 3
    return output
