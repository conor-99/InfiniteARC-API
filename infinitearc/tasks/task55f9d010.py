# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 55f9d010
Difficulty: insane

=== Tags ===
- Fluid spread
- Diagonal weaving
- Color the row with most dots

=== Description ===
Input grids feature a background color (0) overlaid with a complex arrangement
of non-background colors (1-9) arranged in interconnected diagonal patterns. The
grid exhibits two key visual features: a fluid-like diagonal spread where colors
propagate through adjacent diagonal cells (top-left to bottom-right and top-
right to bottom-left), creating continuous diagonal pathways, and a diagonal
weaving pattern where alternating colors form braided structures along multiple
diagonal axes, with no two adjacent diagonal lines sharing the same color.  The
transformation requires three sequential steps:   1. **Fluid Spread**: Each non-
background color spreads diagonally to all adjacent background cells along both
diagonal directions, repeating until no further propagation occurs. This creates
denser diagonal pathways while preserving the original color identity.   2.
**Diagonal Weaving**: Existing diagonal lines are processed to enforce
alternating color patterns (e.g., color A followed by color B along a diagonal),
merging overlapping lines into a continuous braid where possible.   3. **Row
Density Coloring**: After transformations, the row visually containing the
highest density of non-background cells (the "row with the most dots") is
entirely recolored using a new, distinct color (e.g., color 9), while all other
grid elements remain unchanged.    This task demands recognition of fluid
dynamics in diagonal propagation, decoding of alternating weave patterns, and
visual assessment of row densityâ€”requiring multi-step reasoning without
numerical computation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque

def generate():
    def fluid_spread(grid):
        height = len(grid)
        width = len(grid[0])
        spread_grid = [row[:] for row in grid]
        q = deque()
        for r in range(height):
            for c in range(width):
                if grid[r][c] != 0:
                    q.append((r, c))
        while q:
            r, c = q.popleft()
            color = spread_grid[r][c]
            for dr, dc in [(-1,-1), (-1,1), (1,-1), (1,1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and spread_grid[nr][nc] == 0:
                    spread_grid[nr][nc] = color
                    q.append((nr, nc))
        return spread_grid
    
    def weave_diagonals(grid):
        height = len(grid)
        width = len(grid[0])
        woven = [row[:] for row in grid]
        for d in range(-width+1, height):
            cells = []
            for r in range(height):
                c = r - d
                if 0 <= c < width:
                    cells.append((r, c))
            for i in range(1, len(cells)):
                r1, c1 = cells[i-1]
                r2, c2 = cells[i]
                if woven[r1][c1] == woven[r2][c2]:
                    current = woven[r1][c1]
                    new_color = current % 8 + 1
                    woven[r2][c2] = new_color
        for s in range(0, height + width - 1):
            cells = []
            for r in range(height):
                c = s - r
                if 0 <= c < width:
                    cells.append((r, c))
            for i in range(1, len(cells)):
                r1, c1 = cells[i-1]
                r2, c2 = cells[i]
                if woven[r1][c1] == woven[r2][c2]:
                    current = woven[r1][c1]
                    new_color = current % 8 + 1
                    woven[r2][c2] = new_color
        return woven
    
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = [[0] * width for _ in range(height)]
    colors = list(range(1, 9))
    
    for _ in range(random.randint(2, 4)):
        color = random.choice(colors)
        d = random.randint(-width+1, height-1)
        r = max(0, d)
        c = r - d
        while r < height and c < width:
            input_grid[r][c] = color
            r += 2
            c += 2
    
    for _ in range(random.randint(2, 4)):
        color = random.choice(colors)
        s = random.randint(0, height + width - 2)
        r = max(0, s - width + 1)
        c = s - r
        while r < height and 0 <= c < width:
            input_grid[r][c] = color
            r += 2
            c -= 2
    
    spread_grid = fluid_spread(input_grid)
    woven_grid = weave_diagonals(spread_grid)
    row_counts = [sum(1 for cell in row if cell != 0) for row in woven_grid]
    max_row_idx = row_counts.index(max(row_counts))
    output_grid = [list(row) for row in woven_grid]
    for c in range(width):
        output_grid[max_row_idx][c] = 9
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    # Ensure input is list of lists even if passed as tuple
    input_grid = [list(row) for row in input_grid]
    
    def fluid_spread(grid):
        height = len(grid)
        width = len(grid[0])
        spread_grid = [row[:] for row in grid]
        q = deque()
        for r in range(height):
            for c in range(width):
                if grid[r][c] != 0:
                    q.append((r, c))
        while q:
            r, c = q.popleft()
            color = spread_grid[r][c]
            for dr, dc in [(-1,-1), (-1,1), (1,-1), (1,1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and spread_grid[nr][nc] == 0:
                    spread_grid[nr][nc] = color
                    q.append((nr, nc))
        return spread_grid
    
    def weave_diagonals(grid):
        height = len(grid)
        width = len(grid[0])
        woven = [row[:] for row in grid]
        for d in range(-width+1, height):
            cells = []
            for r in range(height):
                c = r - d
                if 0 <= c < width:
                    cells.append((r, c))
            for i in range(1, len(cells)):
                r1, c1 = cells[i-1]
                r2, c2 = cells[i]
                if woven[r1][c1] == woven[r2][c2]:
                    current = woven[r1][c1]
                    new_color = current % 8 + 1
                    woven[r2][c2] = new_color
        for s in range(0, height + width - 1):
            cells = []
            for r in range(height):
                c = s - r
                if 0 <= c < width:
                    cells.append((r, c))
            for i in range(1, len(cells)):
                r1, c1 = cells[i-1]
                r2, c2 = cells[i]
                if woven[r1][c1] == woven[r2][c2]:
                    current = woven[r1][c1]
                    new_color = current % 8 + 1
                    woven[r2][c2] = new_color
        return woven
    
    spread_grid = fluid_spread(input_grid)
    woven_grid = weave_diagonals(spread_grid)
    width = len(input_grid[0])
    height = len(input_grid)
    row_counts = [sum(1 for cell in row if cell != 0) for row in woven_grid]
    max_row_idx = row_counts.index(max(row_counts))
    output_grid = [list(row) for row in woven_grid]
    for c in range(width):
        output_grid[max_row_idx][c] = 9
    return output_grid
