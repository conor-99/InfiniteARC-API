# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 31f5ef34
Difficulty: medium

=== Tags ===
- Associate colors to numbers
- Spacing
- Rectangle guessing

=== Description ===
The input grids consist of multiple contiguous rectangles (blocks of uniformly
colored cells) arranged in a grid. Each color in the input corresponds to a
specific number of empty cells to be inserted between adjacent rectangles. The
output grid is generated by inserting the appropriate number of empty cells
between horizontally or vertically adjacent rectangles, based on the color of
the rectangle that appears first in the direction of adjacency (left for
horizontal pairs, top for vertical pairs). For example, if a red rectangle
(color 2) is to the left of a blue rectangle (color 5), the output will have
exactly 2 empty cells between them, regardless of the blue rectangle's color.
The exact color-to-spacing mapping must be deduced by the solver from the
provided input-output examples, with the spacing visually represented as empty
gaps in the output grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid
def generate():
    colors = random.sample(range(1, 10), 2)
    C1, C2 = colors
    W1 = random.randint(2, 4)
    W2 = random.randint(2, 4)
    H = random.randint(2, 4)
    
    input_grid = grid(W1 + W2, H, 0)
    for r in range(H):
        for c in range(W1):
            input_grid[r][c] = C1
        for c in range(W1, W1 + W2):
            input_grid[r][c] = C2
    
    output_grid = grid(W1 + C1 + W2, H, 0)
    for r in range(H):
        for c in range(W1):
            output_grid[r][c] = C1
        for c in range(W1 + C1, W1 + C1 + W2):
            output_grid[r][c] = C2
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid or not input_grid[0]:
        return input_grid
    height = len(input_grid)
    width = len(input_grid[0])
    
    first_row = input_grid[0]
    blocks = []
    start = 0
    current_color = first_row[0]
    for c in range(1, width):
        if first_row[c] != current_color:
            blocks.append((start, c, current_color))
            start = c
            current_color = first_row[c]
    blocks.append((start, width, current_color))
    
    total_block_width = 0
    for start, end, _ in blocks:
        total_block_width += end - start
    total_spacing = 0
    for i in range(len(blocks) - 1):
        total_spacing += blocks[i][2]
    new_width = total_block_width + total_spacing
    
    output = [[0] * new_width for _ in range(height)]
    
    col_idx = 0
    for i, (start, end, color) in enumerate(blocks):
        for c in range(start, end):
            for r in range(height):
                output[r][col_idx] = input_grid[r][c]
            col_idx += 1
        if i < len(blocks) - 1:
            col_idx += color
    return output
