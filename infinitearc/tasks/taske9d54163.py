# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: e9d54163
Difficulty: easy

=== Tags ===
- Adapt image to grid
- Algebra
- Paint outer ring
- Mark extrema corners

=== Description ===
The input grid is a 2D grid with dimensions of at least 3Ã—3, where all four
corner cells (top-left, top-right, bottom-left, and bottom-right) share the same
color. The output grid is generated by repainting every cell along the outer
perimeter (all cells in the first and last rows, and all cells in the first and
last columns) with this corner color, while preserving all inner cells (those
not on the perimeter) exactly as they appear in the input. This transformation
ensures the output grid differs from the input, as the perimeter cells
(excluding the corners, which may already match the corner color) are updated to
align with the corner color, creating a visually consistent outer ring. The rule
relies solely on visual color identity and positional structure, avoiding
numerical computations or value-based reasoning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    rows = random.randint(3, 30)
    cols = random.randint(3, 30)
    C = random.randint(0, 9)
    input_grid = [[random.randint(0, 9) for _ in range(cols)] for _ in range(rows)]
    input_grid[0][0] = C
    input_grid[0][cols-1] = C
    input_grid[rows-1][0] = C
    input_grid[rows-1][cols-1] = C
    all_perimeter_C = True
    for r in range(rows):
        for c in range(cols):
            if r == 0 or r == rows-1 or c == 0 or c == cols-1:
                if input_grid[r][c] != C:
                    all_perimeter_C = False
                    break
        if not all_perimeter_C:
            break
    if all_perimeter_C:
        non_corner_perim = []
        for r in range(1, rows-1):
            non_corner_perim.append((r, 0))
            non_corner_perim.append((r, cols-1))
        for c in range(1, cols-1):
            non_corner_perim.append((0, c))
            non_corner_perim.append((rows-1, c))
        r, c = random.choice(non_corner_perim)
        input_grid[r][c] = (input_grid[r][c] + 1) % 10
        if input_grid[r][c] == C:
            input_grid[r][c] = (input_grid[r][c] + 1) % 10
    output_grid = [row[:] for row in input_grid]
    for r in range(rows):
        for c in range(cols):
            if r == 0 or r == rows-1 or c == 0 or c == cols-1:
                output_grid[r][c] = C
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    rows = len(input_grid)
    cols = len(input_grid[0])
    C = input_grid[0][0]
    output = [row[:] for row in input_grid]
    for c in range(cols):
        output[0][c] = C
        output[rows-1][c] = C
    for r in range(1, rows-1):
        output[r][0] = C
        output[r][cols-1] = C
    return output
