# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 9ec964bd
Difficulty: hard

=== Tags ===
- Laser diffusion
- Field interference pattern
- Synchronized bounce
- Gas expansion
- Background filling

=== Description ===
# Laser Diffusion Field  Input grids feature a complex maze-like structure
composed of walls (color 0) and background cells (color 9), with multiple
distinct colored sources (colors 1-8) positioned at various locations. The walls
form interconnected passages with at least one clear path between all sources.
The grid contains no isolated background regionsâ€”every background cell is
reachable from at least one source through a path that avoids walls.  The output
grid is generated through a multi-stage diffusion process where each source
emits a "gas" that expands through adjacent background cells in all four
cardinal directions (up, down, left, right) simultaneously. Gas propagation
follows these rules:  1. **Gas expansion**: Each background cell is filled with
the color of the nearest source (measured by Manhattan distance), with ties
broken by the number of paths of equal minimal length.  2. **Wall interaction**:
When gas encounters a wall (color 0), it "bounces" and continues expanding along
the wall's perimeter, maintaining its direction until a passage is found. This
creates synchronized reflection patterns where gas from multiple sources bounce
off walls in coordination, creating interference zones.  3. **Field
interference**: When gas from two or more sources reaches the same cell via
paths of identical length (synchronized bounce), the cell adopts a unique
interference color determined by a predefined color combination table (e.g.,
sources of color 1 and 2 combine to color 6). The interference color is visually
distinct and consistent across all such intersections.  4. **Background
filling**: All background cells are filled with either a single source color or
an interference pattern. Walls (color 0) remain unchanged, and no gas may pass
through walls. The process terminates when all reachable background cells are
filled.  The transformation requires identifying synchronized bounce paths
around walls, recognizing interference conditions through visual pattern
matching rather than numerical computation, and applying the color combination
rules to generate the final output grid. The complexity arises from the need to
track multiple expanding fields, their coordinated reflections around walls, and
the visual recognition of interference patterns at intersection points.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def is_background_connected(grid):
    width = len(grid[0])
    height = len(grid)
    start = None
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 9:
                start = (r, c)
                break
        if start:
            break
    if not start:
        return False
    visited = [[False] * width for _ in range(height)]
    queue = [start]
    visited[start[0]][start[1]] = True
    while queue:
        r, c = queue.pop(0)
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == 9:
                visited[nr][nc] = True
                queue.append((nr, nc))
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 9 and not visited[r][c]:
                return False
    return True

def get_interference(sources):
    total = sum(sources)
    return (total % 8) + 1

def compute_output(grid):
    width = len(grid[0])
    height = len(grid)
    sources = []
    for r in range(height):
        for c in range(width):
            if 1 <= grid[r][c] <= 8:
                sources.append((r, c, grid[r][c]))
    
    output = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 9:
                min_dist = float('inf')
                closest_sources = []
                for sr, sc, color in sources:
                    dist = abs(r - sr) + abs(c - sc)
                    if dist < min_dist:
                        min_dist = dist
                        closest_sources = [(sr, sc, color)]
                    elif dist == min_dist:
                        closest_sources.append((sr, sc, color))
                source_colors = [color for _, _, color in closest_sources]
                if len(source_colors) == 1:
                    output[r][c] = source_colors[0]
                else:
                    output[r][c] = get_interference(source_colors)
    return output

def generate():
    width = random.randint(15, 25)
    height = random.randint(15, 25)
    grid_in = grid(width, height, 9)
    
    max_tries = 10
    for _ in range(max_tries):
        grid_in = grid(width, height, 9)
        for _ in range(width * height // 3):
            r = random.randint(0, height-1)
            c = random.randint(0, width-1)
            grid_in[r][c] = 0
        if is_background_connected(grid_in):
            break
    else:
        grid_in = grid(width, height, 9)
    
    background_positions = []
    for r in range(height):
        for c in range(width):
            if grid_in[r][c] == 9:
                background_positions.append((r, c))
    
    num_sources = random.randint(2, 4)
    for _ in range(num_sources):
        if not background_positions:
            break
        r, c = random.choice(background_positions)
        source_color = random.randint(1, 8)
        grid_in[r][c] = source_color
        background_positions.remove((r, c))
    
    grid_out = compute_output(grid_in)
    return {
        "input": grid_in,
        "output": grid_out
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid_in = [list(row) for row in input_grid]
    width = len(grid_in[0])
    height = len(grid_in)
    sources = []
    for r in range(height):
        for c in range(width):
            if 1 <= grid_in[r][c] <= 8:
                sources.append((r, c, grid_in[r][c]))
    
    output = [row[:] for row in grid_in]
    for r in range(height):
        for c in range(width):
            if grid_in[r][c] == 9:
                min_dist = float('inf')
                closest_sources = []
                for sr, sc, color in sources:
                    dist = abs(r - sr) + abs(c - sc)
                    if dist < min_dist:
                        min_dist = dist
                        closest_sources = [(sr, sc, color)]
                    elif dist == min_dist:
                        closest_sources.append((sr, sc, color))
                source_colors = [color for _, _, color in closest_sources]
                if len(source_colors) == 1:
                    output[r][c] = source_colors[0]
                else:
                    total = sum(source_colors)
                    output[r][c] = (total % 8) + 1
    return output
