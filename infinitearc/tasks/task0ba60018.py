# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 0ba60018
Difficulty: medium

=== Tags ===
- Take maximum
- Bring patterns close
- Only one

=== Description ===
The task involves identifying the color with the most connected regions
(contiguous blocks of the same color, connected by edges) in the input grid. The
output grid must merge all regions of this color into a single connected region
by eliminating gaps between them (i.e., bringing patterns close together), while
removing all other colors. The result will contain exactly one contiguous region
representing the merged patterns of the selected color, with all other colors
absent. This process requires analyzing region counts, selecting the dominant
color, and spatially reconfiguring its components to form a single connected
block, avoiding reliance on numerical properties or pixel-level details.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    size = random.randint(5, 30)
    width = size
    height = size
    grid = [[0]*width for _ in range(height)]
    main_color = random.randint(1, 9)
    N = random.randint(2, 5)
    regions = []
    for _ in range(N):
        while True:
            r = random.randint(0, height-1)
            c = random.randint(0, width-1)
            if grid[r][c] == 0:
                adjacent = False
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == main_color:
                        adjacent = True
                        break
                if not adjacent:
                    grid[r][c] = main_color
                    regions.append((r, c))
                    break
    colors = [c for c in range(1, 10) if c != main_color]
    random.shuffle(colors)
    for color in colors:
        num_regions = random.randint(1, N-1)
        for _ in range(num_regions):
            while True:
                r = random.randint(0, height-1)
                c = random.randint(0, width-1)
                if grid[r][c] == 0:
                    adjacent = False
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == color:
                            adjacent = True
                            break
                    if not adjacent:
                        grid[r][c] = color
                        break
    main_positions = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] == main_color:
                main_positions.append((r, c))
    if not main_positions:
        main_positions = [(0,0)]
    min_r = min(r for r, c in main_positions)
    max_r = max(r for r, c in main_positions)
    min_c = min(c for r, c in main_positions)
    max_c = max(c for r, c in main_positions)
    output = [[0]*width for _ in range(height)]
    for r in range(min_r, max_r + 1):
        for c in range(min_c, max_c + 1):
            output[r][c] = main_color
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    colors = set()
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                colors.add(input_grid[r][c])
    max_regions = 0
    main_color = None
    for color in colors:
        visited = [[False]*width for _ in range(height)]
        regions = 0
        for r in range(height):
            for c in range(width):
                if not visited[r][c] and input_grid[r][c] == color:
                    regions += 1
                    queue = [(r, c)]
                    visited[r][c] = True
                    while queue:
                        cr, cc = queue.pop(0)
                        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                                visited[nr][nc] = True
                                queue.append((nr, nc))
        if regions > max_regions:
            max_regions = regions
            main_color = color
    main_positions = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == main_color:
                main_positions.append((r, c))
    if not main_positions:
        return [[0]*width for _ in range(height)]
    min_r = min(r for r, c in main_positions)
    max_r = max(r for r, c in main_positions)
    min_c = min(c for r, c in main_positions)
    max_c = max(c for r, c in main_positions)
    output = [[0]*width for _ in range(height)]
    for r in range(min_r, max_r + 1):
        for c in range(min_c, max_c + 1):
            output[r][c] = main_color
    return output
