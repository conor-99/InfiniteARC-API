# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: d74ec850
Difficulty: hard

=== Tags ===
- Separate image

=== Description ===
The task involves transforming an input grid containing a single connected
region (composed of a single non-zero color) that is connected via a minimal
bridge pixel. The output grid is identical to the input except the bridge
pixel—the unique pixel whose removal splits the connected region into exactly
two disconnected components—is changed to the background color (0). This
requires identifying the narrowest connection point between two larger parts of
the shape, where the bridge pixel is the sole point of contact between the two
components. The rule is deterministic: for any valid input, the bridge pixel is
the only pixel whose removal results in exactly two connected components of the
original color.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_color

def generate():
    width = random.randint(5, 10)
    height = random.randint(5, 10)
    color = random_color()
    
    x = random.randint(0, width - 4)
    y = random.randint(0, height - 3)
    
    input_grid = grid(width, height, 0)
    
    for i in range(2):
        for j in range(2):
            input_grid[y + i][x + j] = color
    
    for i in range(2):
        for j in range(2):
            input_grid[y + 1 + i][x + 2 + j] = color
    
    bridge_i, bridge_j = y + 1, x + 1
    
    output_grid = [row[:] for row in input_grid]
    output_grid[bridge_i][bridge_j] = 0
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    
    color = None
    for i in range(len(input_grid)):
        for j in range(len(input_grid[0])):
            if input_grid[i][j] > 0:
                color = input_grid[i][j]
                break
        if color is not None:
            break
    if color is None:
        return input_grid
    
    positions = []
    for i in range(len(input_grid)):
        for j in range(len(input_grid[0])):
            if input_grid[i][j] == color:
                positions.append((i, j))
    
    for (i, j) in positions:
        temp_grid = [row[:] for row in input_grid]
        temp_grid[i][j] = 0
        visited = set()
        components = 0
        for r in range(len(temp_grid)):
            for c in range(len(temp_grid[0])):
                if temp_grid[r][c] == color and (r, c) not in visited:
                    components += 1
                    queue = [(r, c)]
                    visited.add((r, c))
                    while queue:
                        cr, cc = queue.pop(0)
                        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < len(temp_grid) and 0 <= nc < len(temp_grid[0]):
                                if temp_grid[nr][nc] == color and (nr, nc) not in visited:
                                    visited.add((nr, nc))
                                    queue.append((nr, nc))
        if components == 2:
            output = [row[:] for row in input_grid]
            output[i][j] = 0
            return output
    return input_grid
