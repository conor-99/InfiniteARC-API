# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 55503c2b
Difficulty: medium–hard

=== Tags ===
- Signal tracing
- Multi step traversal
- Pattern intersection
- Perimeter smoothing

=== Description ===
Input grids feature a complex network of colored paths, each consisting of
horizontally or vertically connected cells of a single color. These paths may
intersect at shared cells, creating overlapping segments. The transformation
involves two distinct, sequential operations:    First, **pattern intersection**
is applied: any cell where two or more paths overlap is recolored to a fixed
intersection color (e.g., pink, color 6). This step ensures intersections are
visually distinct from non-overlapping path segments.    Second, **perimeter
smoothing** refines the outer boundary of the entire path structure. For every
2×2 grid block containing exactly three non-background cells (path segments),
the background cell within the block is recolored to match the dominant color of
the three path cells. If a tie exists (e.g., two colors each appear twice), the
color diagonally opposite the background cell is prioritized. This eliminates
jagged edges and creates a more uniform perimeter.    The output grid preserves
all non-intersection path colors, applies the fixed intersection color to
overlapping cells, and smooths the perimeter using the 2×2 block rule. No new
paths are introduced, and all transformations are strictly deterministic based
on visual configuration.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, rand_sprite

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = [[0] * width for _ in range(height)]
    
    sprite1 = rand_sprite('el', width, height)
    sprite2 = rand_sprite('you', width, height)
    
    for r, c in sprite1:
        if 0 <= r < height and 0 <= c < width:
            grid[r][c] = 1
    
    for r, c in sprite2:
        if 0 <= r < height and 0 <= c < width:
            grid[r][c] = 2
    
    output = [row[:] for row in grid]
    
    for r in range(height):
        for c in range(width):
            if output[r][c] == 0:
                continue
            has_diff_color = False
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    if output[nr][nc] != 0 and output[nr][nc] != output[r][c]:
                        has_diff_color = True
                        break
            if has_diff_color:
                output[r][c] = 6
    
    for r in range(height - 1):
        for c in range(width - 1):
            cells = [
                output[r][c], output[r][c+1],
                output[r+1][c], output[r+1][c+1]
            ]
            non_bg = [cell for cell in cells if cell != 0]
            if len(non_bg) == 3:
                bg_pos = None
                for i, cell in enumerate(cells):
                    if cell == 0:
                        bg_pos = i
                        break
                if bg_pos is None:
                    continue
                if bg_pos == 0:
                    color_to_use = output[r+1][c+1]
                elif bg_pos == 1:
                    color_to_use = output[r+1][c]
                elif bg_pos == 2:
                    color_to_use = output[r][c+1]
                else:
                    color_to_use = output[r][c]
                if bg_pos == 0:
                    output[r][c] = color_to_use
                elif bg_pos == 1:
                    output[r][c+1] = color_to_use
                elif bg_pos == 2:
                    output[r+1][c] = color_to_use
                else:
                    output[r+1][c+1] = color_to_use
    
    if grid == output:
        return generate()
    
    return {'input': grid, 'output': output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0:
                continue
            has_diff_color = False
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    if grid[nr][nc] != 0 and grid[nr][nc] != grid[r][c]:
                        has_diff_color = True
                        break
            if has_diff_color:
                grid[r][c] = 6
    
    for r in range(height - 1):
        for c in range(width - 1):
            cells = [
                grid[r][c], grid[r][c+1],
                grid[r+1][c], grid[r+1][c+1]
            ]
            non_bg = [cell for cell in cells if cell != 0]
            if len(non_bg) == 3:
                bg_pos = None
                for i, cell in enumerate(cells):
                    if cell == 0:
                        bg_pos = i
                        break
                if bg_pos is None:
                    continue
                if bg_pos == 0:
                    color_to_use = grid[r+1][c+1]
                elif bg_pos == 1:
                    color_to_use = grid[r+1][c]
                elif bg_pos == 2:
                    color_to_use = grid[r][c+1]
                else:
                    color_to_use = grid[r][c]
                if bg_pos == 0:
                    grid[r][c] = color_to_use
                elif bg_pos == 1:
                    grid[r][c+1] = color_to_use
                elif bg_pos == 2:
                    grid[r+1][c] = color_to_use
                else:
                    grid[r+1][c+1] = color_to_use
    
    return tuple(tuple(row) for row in grid)
