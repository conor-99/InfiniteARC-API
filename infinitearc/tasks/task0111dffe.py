# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 0111dffe
Difficulty: hard

=== Tags ===
- Interlock pieces
- Rettangle guessing
- Compare image

=== Description ===
The task involves transforming an input grid containing multiple rectangular
regions (contiguous blocks of the same color connected orthogonally) into an
output grid. The transformation rule is as follows: for each rectangular region,
if it shares at least one edge (not just a corner) with a region of a different
color, all pixels of that region are changed to color 9 (a distinct, predefined
color). Regions that do not share an edge with any differently colored region
remain unchanged. The output grid thus highlights all "interlocked" rectangles
(those adjacent to other rectangles of different colors) by converting them to
color 9, while non-interlocked rectangles retain their original colors. This
requires identifying contiguous regions, comparing their adjacency with
neighboring regions, and applying a color transformation based on relational
properties between regions, making it a hard task that tests abstract reasoning
about spatial relationships and relational comparison.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    num_regions = random.choice([2, 3])
    colors = random.sample(range(1, 10), num_regions)
    
    if num_regions == 2:
        if random.choice([True, False]):
            split = random.randint(1, width - 1)
            input_grid = [[colors[0] if c < split else colors[1] for c in range(width)] for _ in range(height)]
        else:
            split = random.randint(1, height - 1)
            input_grid = [[colors[0] if r < split else colors[1] for c in range(width)] for r in range(height)]
    else:  # num_regions == 3
        if random.choice([True, False]):
            split1 = random.randint(1, width - 2)
            split2 = random.randint(split1 + 1, width - 1)
            input_grid = [
                [colors[0] if c < split1 else colors[1] if c < split2 else colors[2] for c in range(width)]
                for _ in range(height)
            ]
        else:
            split1 = random.randint(1, height - 2)
            split2 = random.randint(split1 + 1, height - 1)
            input_grid = [
                [colors[0] if r < split1 else colors[1] if r < split2 else colors[2] for c in range(width)]
                for r in range(height)
            ]
    
    visited = [[False] * width for _ in range(height)]
    output_grid = [[0] * width for _ in range(height)]
    
    for r in range(height):
        for c in range(width):
            if visited[r][c]:
                continue
            color = input_grid[r][c]
            stack = [(r, c)]
            comp = []
            visited[r][c] = True
            while stack:
                cr, cc = stack.pop()
                comp.append((cr, cc))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            is_adjacent = False
            for (cr, cc) in comp:
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        if input_grid[nr][nc] != color:
                            is_adjacent = True
                            break
                if is_adjacent:
                    break
            for (cr, cc) in comp:
                output_grid[cr][cc] = 9 if is_adjacent else color
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid:
        return input_grid
    width = len(input_grid[0])
    height = len(input_grid)
    visited = [[False] * width for _ in range(height)]
    output_grid = [[0] * width for _ in range(height)]
    
    for r in range(height):
        for c in range(width):
            if visited[r][c]:
                continue
            color = input_grid[r][c]
            stack = [(r, c)]
            comp = []
            visited[r][c] = True
            while stack:
                cr, cc = stack.pop()
                comp.append((cr, cc))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            is_adjacent = False
            for (cr, cc) in comp:
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        if input_grid[nr][nc] != color:
                            is_adjacent = True
                            break
                if is_adjacent:
                    break
            for (cr, cc) in comp:
                output_grid[cr][cc] = 9 if is_adjacent else color
    return output_grid
