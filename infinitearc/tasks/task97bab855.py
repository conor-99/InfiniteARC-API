# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 97bab855
Difficulty: hard

=== Tags ===
- Cascade fountain
- Draw line of sight
- Repeat pattern to fill shape

=== Description ===
Input grids feature a background color (0), a single "fountain source" cell
(color S) positioned at the top edge of the grid, a container region defined by
a closed boundary of color B (with the interior being background), and optional
obstacles (color O) within the container. The container is a connected region
with no holes.  The output grid transforms the input through three sequential
operations: 1. **Line of sight determination**: From the fountain source, draw a
straight line (horizontal, vertical, or diagonal) toward the container's
interior. The direction is determined by the container's relative position to
the source (e.g., down-right if the container is below and to the right). The
line stops at the first obstacle or container boundary. 2. **Cascade fountain
replication**: Starting at the source, replicate a 2×1 vertical motif (color S)
along the line of sight direction. Each subsequent copy is shifted by one cell
in the line's direction. Replication continues until the line reaches the
container boundary, with the last copy placed just before the boundary. 3.
**Pattern filling**: Within the container, tile the interior with the 2×1 motif
aligned to the line of sight direction. Tiling begins at the container's
entrance point (where the line of sight meets the boundary) and extends inward,
filling the container's area without overlapping obstacles. The container's
boundary (color B) remains visible, and obstacles (color O) are preserved as
distinct features.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(7, 30)
    height = random.randint(7, 30)
    S = random.choice([2,3,4,5,6,7,8,9])
    B = 1
    O = random.choice([2,3,4,5,6,7,8,9])
    while O == S:
        O = random.choice([2,3,4,5,6,7,8,9])
    
    input_grid = [[0]*width for _ in range(height)]
    c_source = random.randint(1, width-2)
    input_grid[0][c_source] = S
    
    r1 = random.randint(2, height-5)
    r2 = random.randint(r1+2, height-3)
    c1 = random.randint(1, width-4)
    c2 = random.randint(c1+2, width-2)
    
    for c in range(c1, c2+1):
        input_grid[r1][c] = B
        input_grid[r2][c] = B
    for r in range(r1, r2+1):
        input_grid[r][c1] = B
        input_grid[r][c2] = B
    
    for _ in range(3):
        r = random.randint(r1+1, r2-1)
        c = random.randint(c1+1, c2-1)
        input_grid[r][c] = O
    
    closest_dist = float('inf')
    closest_b = None
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == B:
                dist = abs(r) + abs(c - c_source)
                if dist < closest_dist:
                    closest_dist = dist
                    closest_b = (r, c)
    if closest_b is None:
        closest_b = (r1, c_source)
    
    dr = closest_b[0] - 0
    dc = closest_b[1] - c_source
    dr = 1 if dr > 0 else -1 if dr < 0 else 0
    dc = 1 if dc > 0 else -1 if dc < 0 else 0
    
    r, c = 0, c_source
    line_cells = []
    while True:
        r += dr
        c += dc
        if r < 0 or r >= height or c < 0 or c >= width:
            break
        if input_grid[r][c] != 0:
            break
        line_cells.append((r, c))
    
    output_grid = [row[:] for row in input_grid]
    for r, c in line_cells:
        output_grid[r][c] = S
    
    for r in range(r1+1, r2):
        for c in range(c1+1, c2):
            if input_grid[r][c] == 0:
                output_grid[r][c] = S
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    
    for c in range(width):
        if input_grid[0][c] != 0:
            S = input_grid[0][c]
            c_source = c
            break
    else:
        return input_grid
    
    B_color = 1
    B_cells = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == B_color:
                B_cells.append((r, c))
    if not B_cells:
        return input_grid
    
    closest_dist = float('inf')
    closest_b = None
    for (r, c) in B_cells:
        dist = abs(r) + abs(c - c_source)
        if dist < closest_dist:
            closest_dist = dist
            closest_b = (r, c)
    
    dr = closest_b[0] - 0
    dc = closest_b[1] - c_source
    dr = 1 if dr > 0 else -1 if dr < 0 else 0
    dc = 1 if dc > 0 else -1 if dc < 0 else 0
    
    r, c = 0, c_source
    line_cells = []
    while True:
        r += dr
        c += dc
        if r < 0 or r >= height or c < 0 or c >= width:
            break
        if input_grid[r][c] != 0:
            break
        line_cells.append((r, c))
    
    output_grid = [row[:] for row in input_grid]
    for (r, c) in line_cells:
        output_grid[r][c] = S
    
    r1 = min(r for (r, c) in B_cells)
    r2 = max(r for (r, c) in B_cells)
    c1 = min(c for (r, c) in B_cells)
    c2 = max(c for (r, c) in B_cells)
    
    for r in range(r1+1, r2):
        for c in range(c1+1, c2):
            if input_grid[r][c] == 0:
                output_grid[r][c] = S
    
    return output_grid
