# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: e18d73d5
Difficulty: hard

=== Tags ===
- Color matching
- Multi agent path weaving
- Concentric

=== Description ===
The input grid contains multiple concentric circular paths (rings), each forming
a closed loop of uniform color with no gaps, nested such that each ring encloses
the next smaller ring. The innermost ring has no enclosed rings, and the
outermost ring has no enclosing rings. The output grid transforms each ring by
alternating the original color with the color of the immediately inner ring
(wrapping to the outermost ring for the innermost ring's odd positions).
Specifically, for each cell in a ring, if its position along the ring (traversed
clockwise) is even (0-based), the color remains unchanged; if odd, the color is
replaced with the color of the ring one step inward (with the innermost ring's
odd positions using the outermost ring's color). This creates a woven pattern
where adjacent cells along each ring alternate between the ring's original color
and the color of the inner ring, producing a braided effect across all
concentric layers. The transformation requires identifying nested ring
structures, ordering them by size, and applying position-based color alternation
relative to adjacent concentric rings.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    sizes = list(range(3, 30, 2))
    N = random.choice(sizes)
    num_layers = (N + 1) // 2
    
    colors = [random.randint(1, 9)]
    for _ in range(1, num_layers):
        color = random.randint(1, 9)
        while color == colors[-1]:
            color = random.randint(1, 9)
        colors.append(color)
    
    input_grid = [[0]*N for _ in range(N)]
    for r in range(N):
        for c in range(N):
            k = min(r, N-1-r, c, N-1-c)
            input_grid[r][c] = colors[k]
    
    output_grid = [[0]*N for _ in range(N)]
    for k in range(num_layers):
        top = [(k, c) for c in range(k, N - k)]
        right = [(r, N - 1 - k) for r in range(k + 1, N - k - 1)]
        bottom = [(N - 1 - k, c) for c in range(N - 1 - k, k - 1, -1)]
        left = [(r, k) for r in range(N - 1 - k - 1, k, -1)]
        clockwise = top + right + bottom + left
        for idx, (r, c) in enumerate(clockwise):
            if idx % 2 == 0:
                output_grid[r][c] = colors[k]
            else:
                inner_k = (k + 1) % num_layers
                output_grid[r][c] = colors[inner_k]
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    N = len(input_grid)
    num_layers = (N + 1) // 2
    layer_colors = [input_grid[k][k] for k in range(num_layers)]
    output_grid = [[0] * N for _ in range(N)]
    for k in range(num_layers):
        top = [(k, c) for c in range(k, N - k)]
        right = [(r, N - 1 - k) for r in range(k + 1, N - k - 1)]
        bottom = [(N - 1 - k, c) for c in range(N - 1 - k, k - 1, -1)]
        left = [(r, k) for r in range(N - 1 - k - 1, k, -1)]
        clockwise = top + right + bottom + left
        for idx, (r, c) in enumerate(clockwise):
            if idx % 2 == 0:
                output_grid[r][c] = layer_colors[k]
            else:
                inner_k = (k + 1) % num_layers
                output_grid[r][c] = layer_colors[inner_k]
    return output_grid
