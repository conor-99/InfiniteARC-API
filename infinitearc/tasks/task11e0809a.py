# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 11e0809a
Difficulty: insane

=== Tags ===
- Count shapes
- Multi world portals
- Inside out
- Color guessing

=== Description ===
The task involves processing an input grid containing multiple distinct shapes
(connected regions of non-zero values, considering 4-directional adjacency).
First, the number of distinct shapes (N) is counted. Each shape is then
transformed by retaining only its boundary cells (the outermost cells of the
shape that are adjacent to background or other shapes), and setting all boundary
cells to color N. The resulting output grid consists solely of these boundary
outlines in color N, with all other cells set to 0. This process requires
identifying shapes, counting them, and applying an inside-out transformation
(boundary extraction) using the count as the color value for the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
from common import grid, randint, random_color, continuous_creature

def generate():
    width = randint(5, 30)
    height = randint(5, 30)
    input_grid = grid(width, height, 0)
    
    # Generate 2-5 distinct shapes
    for _ in range(randint(2, 5)):
        size = randint(3, 10)
        pixels = continuous_creature(size, width, height)
        r_offset = randint(0, height - 1)
        c_offset = randint(0, width - 1)
        for (r, c) in pixels:
            nr = (r + r_offset) % height
            nc = (c + c_offset) % width
            input_grid[nr][nc] = random_color(exclude=[0])
    
    # Compute actual number of connected components (N)
    visited = [[False] * width for _ in range(height)]
    N = 0
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                N += 1
    
    # Create output grid
    output_grid = grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 0:
                        output_grid[r][c] = N
                        break
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    visited = [[False] * width for _ in range(height)]
    N = 0
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                N += 1
    
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 0:
                        output_grid[r][c] = N
                        break
    return output_grid
