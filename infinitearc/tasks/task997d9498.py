# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 997d9498
Difficulty: medium

=== Tags ===
- Trace perimeter

=== Description ===
The input grid contains a single connected region (using 4-connectivity) of a
non-background color (represented by a single number between 1 and 9),
surrounded by background (0). The output grid is derived by retaining only the
perimeter pixels of this region—those pixels adjacent to background or grid
boundaries—and setting all inner pixels of the region to background (0).
Perimeter pixels are defined as those within the connected region that have at
least one neighboring background pixel (up, down, left, right) or lie on the
grid edge. The output grid maintains the same dimensions as the input, with
inner pixels of the region removed, ensuring the input and output grids are
distinct.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
def generate():
    width = random.randint(6, 30)
    height = random.randint(6, 30)
    color = random.randint(1, 9)
    h = random.randint(3, height - 3)
    w = random.randint(3, width - 3)
    r = random.randint(1, height - h - 1)
    c = random.randint(1, width - w - 1)
    
    input_grid = [[0] * width for _ in range(height)]
    for i in range(r, r + h):
        for j in range(c, c + w):
            input_grid[i][j] = color
    
    output_grid = [row[:] for row in input_grid]
    for i in range(r + 1, r + h - 1):
        for j in range(c + 1, c + w - 1):
            output_grid[i][j] = 0
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = [[0] * width for _ in range(height)]
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    
    for i in range(height):
        for j in range(width):
            if input_grid[i][j] == 0:
                continue
            perimeter = False
            for dx, dy in directions:
                ni, nj = i + dx, j + dy
                if ni < 0 or ni >= height or nj < 0 or nj >= width:
                    perimeter = True
                    break
                if input_grid[ni][nj] == 0:
                    perimeter = True
                    break
            if perimeter:
                output_grid[i][j] = input_grid[i][j]
    
    return output_grid
