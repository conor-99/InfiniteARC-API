# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 8c9cd8af
Difficulty: mediumâ€“hard

=== Tags ===
- Hierarchical repetition
- Draw line of sight
- Pattern guided construction
- Diagonals
- Periodic run length encoding

=== Description ===
Input grids feature a background color (0) and multiple diagonal lines (top-left
to bottom-right) originating from the grid's edges. Each diagonal consists of
alternating color segments where the segment lengths follow a periodic sequence
(e.g., two red cells followed by three blue cells, repeating). The input grid
displays the initial segment sequence of these diagonals, with no overlapping
segments or interruptions. Background cells remain uniformly colored.   Output
grids extend each diagonal line beyond the grid's boundaries while maintaining
the observed periodic run-length pattern. The extension continues the exact
sequence of segment lengths and colors visible in the input, repeating the
pattern without modification. For diagonals that terminate at grid edges, the
extension progresses rightward and downward. The background remains unchanged,
and no new elements are introduced. Hierarchical repetition is demonstrated
through multiple diagonals with distinct periodic patterns (e.g., one diagonal
follows a 2-3 length cycle, another a 1-2-1 cycle), requiring the solver to
independently recognize and apply each pattern's period to its respective
diagonal. Diagonals are visually distinguishable by color and segment sequence,
with no color overlap between segments.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Create a grid with at least some space so diagonals can be meaningfully extended
    # We'll retry until we successfully place at least one diagonal that can be extended
    attempts = 0
    while True:
        attempts += 1
        W = random.randint(5, 20)
        H = random.randint(5, 20)
        bg = 0
        input_grid = [[bg for _ in range(W)] for _ in range(H)]
        output_grid = [[bg for _ in range(W)] for _ in range(H)]

        # Candidate start positions: top row (0, c) and left column (r, 0) (excluding (0,0) duplication)
        starts = [(0, c) for c in range(W)] + [(r, 0) for r in range(1, H)]
        random.shuffle(starts)

        num_diagonals = random.randint(1, min(3, len(starts)))
        placed = 0
        used_colors = set()

        for (r0, c0) in starts:
            if placed >= num_diagonals:
                break
            diag_len = min(H - r0, W - c0)
            # require at least some space so we can show an initial sequence and extend it
            if diag_len < 4:
                continue

            # choose number of segments in the repeating run-length pattern
            max_k = min(4, diag_len - 1)
            k = random.randint(2, max_k)

            # pick run-lengths so that the sum S is strictly less than the diagonal length
            # (so the output will extend beyond what the input shows)
            run_lengths = None
            for _ in range(200):
                # each segment length at least 1 and at most min(4, diag_len-1)
                max_run = min(4, diag_len - 1)
                candidate = [random.randint(1, max_run) for _ in range(k)]
                S = sum(candidate)
                if 1 < S < diag_len:
                    run_lengths = candidate
                    break
            if run_lengths is None:
                continue

            # choose distinct colors for this diagonal (prefer colors not used by other diagonals)
            avail = [col for col in range(1, 10) if col not in used_colors]
            if len(avail) >= k:
                colors = random.sample(avail, k)
            else:
                colors = random.sample(range(1, 10), k)
            used_colors.update(colors)

            # Build the full per-cell pattern along the diagonal by repeating segments in order
            full_pattern = []
            seg_idx = 0
            while len(full_pattern) < diag_len:
                seg_len = run_lengths[seg_idx % len(run_lengths)]
                seg_color = colors[seg_idx % len(run_lengths)]
                need = min(seg_len, diag_len - len(full_pattern))
                full_pattern.extend([seg_color] * need)
                seg_idx += 1

            # The input should show only the initial sequence (one period = sum(run_lengths))
            S = sum(run_lengths)
            # Fill input with the first S cells of the pattern, and output with the full diagonal
            for d in range(S):
                r = r0 + d
                c = c0 + d
                input_grid[r][c] = full_pattern[d]

            for d in range(diag_len):
                r = r0 + d
                c = c0 + d
                output_grid[r][c] = full_pattern[d]

            placed += 1

        # Must have placed at least one diagonal and ensure input != output
        if placed >= 1 and input_grid != output_grid:
            return {"input": input_grid, "output": output_grid}
        # otherwise retry (should be rare)
        if attempts > 1000:
            # fallback: produce a simple guaranteed example
            W = 6
            H = 6
            input_grid = [[0] * W for _ in range(H)]
            output_grid = [[0] * W for _ in range(H)]
            # single diagonal starting at (0,1)
            run_lengths = [2, 1]
            colors = [3, 4]
            diag_len = min(H - 0, W - 1)
            full_pattern = []
            seg_idx = 0
            while len(full_pattern) < diag_len:
                seg_len = run_lengths[seg_idx % len(run_lengths)]
                seg_color = colors[seg_idx % len(run_lengths)]
                need = min(seg_len, diag_len - len(full_pattern))
                full_pattern.extend([seg_color] * need)
                seg_idx += 1
            S = sum(run_lengths)
            for d in range(S):
                input_grid[0 + d][1 + d] = full_pattern[d]
            for d in range(diag_len):
                output_grid[0 + d][1 + d] = full_pattern[d]
            return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert tuple-of-tuples to list-of-lists if necessary
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0]) if H > 0 else 0

    # Start from a copy of the input so background and any existing pixels are preserved
    output = [row[:] for row in grid]

    # Find diagonal starts: non-zero cells on the top row or left column where the up-left neighbor is empty/out
    starts = []
    for r in range(H):
        for c in range(W):
            if grid[r][c] == 0:
                continue
            # A diagonal start in these tasks originates on an edge (top row or left col)
            if not (r == 0 or c == 0):
                continue
            # ensure it's the beginning of a diagonal (no colored up-left neighbor)
            if r > 0 and c > 0 and grid[r - 1][c - 1] != 0:
                continue
            starts.append((r, c))

    for (r0, c0) in starts:
        # collect the contiguous non-zero prefix along the diagonal
        prefix = []
        d = 0
        while r0 + d < H and c0 + d < W and grid[r0 + d][c0 + d] != 0:
            prefix.append(grid[r0 + d][c0 + d])
            d += 1
        if len(prefix) == 0:
            continue

        # Deduce run-length encoding from the prefix (colors and their consecutive lengths)
        colors = []
        run_lengths = []
        cur = prefix[0]
        cnt = 1
        for x in prefix[1:]:
            if x == cur:
                cnt += 1
            else:
                colors.append(cur)
                run_lengths.append(cnt)
                cur = x
                cnt = 1
        colors.append(cur)
        run_lengths.append(cnt)

        # Now extend this pattern along the full diagonal length
        diag_len = min(H - r0, W - c0)
        pattern = []
        seg_idx = 0
        while len(pattern) < diag_len:
            seg_len = run_lengths[seg_idx % len(run_lengths)]
            seg_color = colors[seg_idx % len(run_lengths)]
            need = min(seg_len, diag_len - len(pattern))
            pattern.extend([seg_color] * need)
            seg_idx += 1

        # Fill the output diagonal with the constructed pattern
        for i in range(diag_len):
            output[r0 + i][c0 + i] = pattern[i]

    return output

