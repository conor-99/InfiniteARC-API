# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 583e30e9
Difficulty: very hard

=== Tags ===
- Synchronized bounce
- Symmetry completion
- Alternating agents
- Threshold by area

=== Description ===
**Task Description**    Input grids are large (20×20 or larger) with a single
background color (0). The grid contains two distinct agents (colors 1 and 2)
positioned on opposite edges (agent 1 on the left, agent 2 on the right), moving
toward each other. Obstacles (colors 3–9) block movement. Agents alternate turns
moving one cell in their current direction (agent 1 moves right, agent 2 moves
left), with movement continuing until the combined area covered by both paths
(unique cells visited) reaches a threshold of 25% of the grid’s total area. When
agents would collide in the same cell during a move, they *synchronously bounce*
(reverse direction simultaneously). The output grid retains all obstacles but
draws agent paths: agent 1’s path is color 1, agent 2’s path is color 2, and
overlapping cells are color 3. Finally, the grid is *symmetry-completed* by
mirroring the left half’s path pattern to the right half (vertical axis),
ensuring perfect symmetry in the output. This symmetry completion overrides any
asymmetry in the input’s path traversal, requiring the solver to infer the
mirrored pattern from the partial paths.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common
from typing import List, Dict, Tuple, Set


def _simulate_path(width: int, height: int, start1: Tuple[int, int], start2: Tuple[int, int], target_area: int, obstacles: Set[Tuple[int,int]] = None, max_steps: int = 3000):
    if obstacles is None:
        obstacles = set()
    pos1 = start1
    pos2 = start2
    visited1 = {pos1}
    visited2 = {pos2}

    heading1 = 1
    heading2 = -1
    # deterministic vertical preferences to keep simulation fast and reproducible
    vdir1 = 1 if start1[0] % 2 == 0 else -1
    vdir2 = -1 if start2[0] % 2 == 0 else 1

    turn = 0  # 0 -> agent1, 1 -> agent2
    for step in range(max_steps):
        if len(visited1 | visited2) >= target_area:
            break
        if turn == 0:
            r, c = pos1
            cand_h = (r, c + heading1)
            if 0 <= cand_h[0] < height and 0 <= cand_h[1] < width and cand_h == pos2:
                heading1 = -heading1
                heading2 = -heading2
            else:
                if 0 <= cand_h[0] < height and 0 <= cand_h[1] < width and cand_h not in obstacles and cand_h != pos2:
                    pos1 = cand_h
                    visited1.add(pos1)
                else:
                    cand_v = (r + vdir1, c)
                    if 0 <= cand_v[0] < height and 0 <= cand_v[1] < width and cand_v not in obstacles and cand_v != pos2:
                        pos1 = cand_v
                        visited1.add(pos1)
                    else:
                        vdir1 = -vdir1
                        cand_v2 = (r + vdir1, c)
                        if 0 <= cand_v2[0] < height and 0 <= cand_v2[1] < width and cand_v2 not in obstacles and cand_v2 != pos2:
                            pos1 = cand_v2
                            visited1.add(pos1)
                        else:
                            heading1 = -heading1
            turn = 1
        else:
            r, c = pos2
            cand_h = (r, c + heading2)
            if 0 <= cand_h[0] < height and 0 <= cand_h[1] < width and cand_h == pos1:
                heading1 = -heading1
                heading2 = -heading2
            else:
                if 0 <= cand_h[0] < height and 0 <= cand_h[1] < width and cand_h not in obstacles and cand_h != pos1:
                    pos2 = cand_h
                    visited2.add(pos2)
                else:
                    cand_v = (r + vdir2, c)
                    if 0 <= cand_v[0] < height and 0 <= cand_v[1] < width and cand_v not in obstacles and cand_v != pos1:
                        pos2 = cand_v
                        visited2.add(pos2)
                    else:
                        vdir2 = -vdir2
                        cand_v2 = (r + vdir2, c)
                        if 0 <= cand_v2[0] < height and 0 <= cand_v2[1] < width and cand_v2 not in obstacles and cand_v2 != pos1:
                            pos2 = cand_v2
                            visited2.add(pos2)
                        else:
                            heading2 = -heading2
            turn = 0
    return visited1, visited2


def generate() -> Dict[str, List[List[int]]]:
    tries = 0
    while True:
        tries += 1
        width = random.randint(20, 30)
        height = random.randint(20, 30)
        total_area = width * height
        target_area = max(1, int(0.25 * total_area))

        r1 = random.randint(1, height - 2)
        r2 = random.randint(1, height - 2)
        start1 = (r1, 0)
        start2 = (r2, width - 1)

        # Use a modest step cap proportional to target_area for speed
        max_steps = max(600, target_area * 4)
        visited1, visited2 = _simulate_path(width, height, start1, start2, target_area, obstacles=set(), max_steps=max_steps)
        combined = visited1 | visited2
        if len(combined) < target_area:
            if tries < 6:
                continue
            # accept what we have after several tries

        # Build input grid with symmetric obstacles placed only outside the path
        input_grid = common.grid(width, height, 0)
        obstacle_colors = list(range(4, 10))

        mid = width // 2
        combined_set = set(combined)

        # Determine available left-half cells (we will sample pairs randomly without building the full list)
        max_pairs = random.randint(6, 20)
        placed = 0
        attempts = 0
        max_attempts = max_pairs * 12
        used = set()
        while placed < max_pairs and attempts < max_attempts:
            attempts += 1
            r = random.randrange(0, height)
            c = random.randrange(0, mid)
            mirror_c = width - 1 - c
            if (r, c) in combined_set or (r, mirror_c) in combined_set:
                continue
            if (r, c) == start1 or (r, mirror_c) == start1 or (r, c) == start2 or (r, mirror_c) == start2:
                continue
            if (r, c) in used or (r, mirror_c) in used:
                continue
            color = random.choice(obstacle_colors)
            input_grid[r][c] = color
            input_grid[r][mirror_c] = color
            used.add((r, c))
            used.add((r, mirror_c))
            placed += 1

        # Small chance to place a symmetric center obstacle if width odd
        if width % 2 == 1 and random.random() < 0.3:
            center_c = mid
            r = random.randrange(0, height)
            if (r, center_c) not in combined_set and (r, center_c) != start1 and (r, center_c) != start2:
                input_grid[r][center_c] = random.choice(obstacle_colors)

        # Starting agent markers in the input
        input_grid[start1[0]][start1[1]] = 1
        input_grid[start2[0]][start2[1]] = 2

        # Build output by drawing agent paths
        output_grid = [row[:] for row in input_grid]
        overlap = 3
        for (r, c) in visited1:
            if output_grid[r][c] >= 4:
                continue
            output_grid[r][c] = 1
        for (r, c) in visited2:
            if output_grid[r][c] >= 4:
                continue
            if output_grid[r][c] == 1:
                output_grid[r][c] = overlap
            else:
                output_grid[r][c] = 2

        # Symmetry completion (mirror left half to right), do not overwrite obstacles
        for r in range(height):
            for c in range(mid):
                left_val = output_grid[r][c]
                mirror_c = width - 1 - c
                if left_val in (1, 2, overlap) and output_grid[r][mirror_c] < 4:
                    output_grid[r][mirror_c] = left_val

        return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from typing import List, Tuple, Set


def _simulate_on_input(input_grid: List[List[int]], start1: Tuple[int,int], start2: Tuple[int,int], target_area: int, max_steps: int = 3000):
    height = len(input_grid)
    width = len(input_grid[0])
    obstacles = {(r,c) for r in range(height) for c in range(width) if input_grid[r][c] >= 4}

    pos1 = start1
    pos2 = start2
    visited1 = {pos1}
    visited2 = {pos2}

    heading1 = 1
    heading2 = -1
    vdir1 = 1 if start1[0] % 2 == 0 else -1
    vdir2 = -1 if start2[0] % 2 == 0 else 1

    turn = 0
    for step in range(max_steps):
        if len(visited1 | visited2) >= target_area:
            break
        if turn == 0:
            r, c = pos1
            cand_h = (r, c + heading1)
            if 0 <= cand_h[0] < height and 0 <= cand_h[1] < width and cand_h == pos2:
                heading1 = -heading1
                heading2 = -heading2
            else:
                if 0 <= cand_h[0] < height and 0 <= cand_h[1] < width and cand_h not in obstacles and cand_h != pos2:
                    pos1 = cand_h
                    visited1.add(pos1)
                else:
                    cand_v = (r + vdir1, c)
                    if 0 <= cand_v[0] < height and 0 <= cand_v[1] < width and cand_v not in obstacles and cand_v != pos2:
                        pos1 = cand_v
                        visited1.add(pos1)
                    else:
                        vdir1 = -vdir1
                        cand_v2 = (r + vdir1, c)
                        if 0 <= cand_v2[0] < height and 0 <= cand_v2[1] < width and cand_v2 not in obstacles and cand_v2 != pos2:
                            pos1 = cand_v2
                            visited1.add(pos1)
                        else:
                            heading1 = -heading1
            turn = 1
        else:
            r, c = pos2
            cand_h = (r, c + heading2)
            if 0 <= cand_h[0] < height and 0 <= cand_h[1] < width and cand_h == pos1:
                heading1 = -heading1
                heading2 = -heading2
            else:
                if 0 <= cand_h[0] < height and 0 <= cand_h[1] < width and cand_h not in obstacles and cand_h != pos1:
                    pos2 = cand_h
                    visited2.add(pos2)
                else:
                    cand_v = (r + vdir2, c)
                    if 0 <= cand_v[0] < height and 0 <= cand_v[1] < width and cand_v not in obstacles and cand_v != pos1:
                        pos2 = cand_v
                        visited2.add(pos2)
                    else:
                        vdir2 = -vdir2
                        cand_v2 = (r + vdir2, c)
                        if 0 <= cand_v2[0] < height and 0 <= cand_v2[1] < width and cand_v2 not in obstacles and cand_v2 != pos1:
                            pos2 = cand_v2
                            visited2.add(pos2)
                        else:
                            heading2 = -heading2
            turn = 0
    return visited1, visited2


def p(input_grid: Tuple[Tuple[int]]):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    agent1 = None
    agent2 = None
    for r in range(height):
        if grid[r][0] == 1:
            agent1 = (r, 0)
        if grid[r][width-1] == 2:
            agent2 = (r, width-1)
    if agent1 is None or agent2 is None:
        for r in range(height):
            for c in range(width):
                if grid[r][c] == 1 and agent1 is None:
                    agent1 = (r, c)
                if grid[r][c] == 2 and agent2 is None:
                    agent2 = (r, c)
    if agent1 is None or agent2 is None:
        return grid

    total_area = width * height
    target_area = max(1, int(0.25 * total_area))

    visited1, visited2 = _simulate_on_input(grid, agent1, agent2, target_area, max_steps=max(600, target_area * 4))

    output = [row[:] for row in grid]
    overlap = 3
    for (r, c) in visited1:
        if output[r][c] >= 4:
            continue
        output[r][c] = 1
    for (r, c) in visited2:
        if output[r][c] >= 4:
            continue
        if output[r][c] == 1:
            output[r][c] = overlap
        else:
            output[r][c] = 2

    mid = width // 2
    for r in range(height):
        for c in range(mid):
            left_val = output[r][c]
            mirror_c = width - 1 - c
            if left_val in (1, 2, overlap) and output[r][mirror_c] < 4:
                output[r][mirror_c] = left_val

    return output

