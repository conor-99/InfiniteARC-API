# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: e53bbdf7
Difficulty: hard

=== Tags ===
- Ripple spread
- Pattern bounce
- Maze
- Replace pattern

=== Description ===
**Task Name**: Ripple Path Convergence  **Tags**: Ripple spread, Pattern bounce,
Maze, Replace pattern  **Description**:  Input grids are medium to large (15×15
to 30×30), featuring a maze structure defined by a single background color
(e.g., 0) and walls of a distinct color (e.g., 1). A horizontal "pattern strip"
of 2–4 colors is positioned along the top edge (second row, columns 0–3),
representing a repeating sequence for the ripple’s color progression. A single
source cell (background color) is embedded within the maze, not adjacent to
walls or the grid edge, with the maze containing exactly one valid path from the
source to an edge (top/right).   The maze corridors are defined by background
cells, with walls forming irregular barriers that create a single continuous
path from the source to the grid edge. The pattern strip’s colors are unique
within the grid (not matching background or walls). Walls are never orthogonal
but form irregular, non-rectangular barriers ensuring the path remains
unobstructed.  In the output grid, the ripple path is drawn as follows: Starting
from the source’s right neighbor (moving right), each background cell along the
path is colored with the next color in the pattern strip (cycling the sequence).
Upon encountering a wall in the current direction, the ripple bounces, changing
direction to the next perpendicular direction (right → up → left → down →
right), and the color advances. The path continues until exiting the grid
(reaching the top or right edge), with all cells on the path colored according
to the sequence. Walls, the pattern strip, and non-path background cells remain
unchanged. The output uniquely satisfies the ripple’s movement rules, with no
alternative paths matching the color sequence at every bounce. The maze’s
complexity requires tracking multiple bounces and color cycles to determine the
correct path, ensuring the solution is non-trivial and requires sequential
reasoning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Try multiple times to produce a valid maze + path that meets constraints
    for attempt in range(200):
        width = random.randint(15, 30)
        height = random.randint(15, 30)

        # Start with all walls (1)
        inp = [[1 for _ in range(width)] for _ in range(height)]

        # Pick a source location that is well inside the grid so a 3x3 open area fits
        sr = random.randint(3, height - 4)
        sc = random.randint(3, width - 4)

        # Carve a 3x3 open area around the source so source is not adjacent to walls
        source_area = []
        for dr in (-1, 0, 1):
            for dc in (-1, 0, 1):
                r, c = sr + dr, sc + dc
                inp[r][c] = 0
                source_area.append((r, c))

        source = (sr, sc)
        # Starting cell for ripple is the right neighbor of the source
        start = (sr, sc + 1)
        inp[start[0]][start[1]] = 0

        # Keep track of carved path cells in order
        path_set = set(source_area)
        path_set.add(start)
        path = [start]

        # Select exit side (only 'top' or 'right')
        exit_side = random.choice(["top", "right"])

        # Direction order: right, up, left, down
        dirs = [(0, 1), (-1, 0), (0, -1), (1, 0)]
        dir_idx = 0  # start moving right

        def allowed(nr, nc):
            # Must be inside grid
            if not (0 <= nr < height and 0 <= nc < width):
                return False
            # Don't revisit cells
            if (nr, nc) in path_set:
                return False
            # Disallow reaching left column or bottom row (we only allow top or right exits)
            if nr == height - 1 or nc == 0:
                return False
            # Allow final exits on top row (excluding corners) or right column (excluding corners)
            if nr == 0:
                if not (1 <= nc <= width - 2):
                    return False
            if nc == width - 1:
                if not (1 <= nr <= height - 2):
                    return False
            # Interior positions must be strictly inside the border (so 1..height-2 and 1..width-2)
            if not (1 <= nr <= height - 2 and 1 <= nc <= width - 2):
                # It might be the final exit (handled above), otherwise reject
                if not ((nr == 0 and 1 <= nc <= width - 2) or (nc == width - 1 and 1 <= nr <= height - 2)):
                    return False
            return True

        # Helper: distance to chosen exit (smaller is closer)
        def dist_to_exit(r, c):
            if exit_side == 'top':
                return r  # row index: closer to 0 is closer
            else:
                return (width - 1) - c  # distance to right column

        # Build the path step by step, following the bounce-order logic
        curr = start
        max_steps = width * height // 2
        success = False
        for _ in range(max_steps):
            cr, cc = curr
            # Check if we're already at the exit (top or right)
            if (exit_side == 'top' and cr == 0 and 1 <= cc <= width - 2) or (
                    exit_side == 'right' and cc == width - 1 and 1 <= cr <= height - 2):
                success = True
                break

            # Candidate directions in bounce order
            candidate_dirs = [(dir_idx + i) % 4 for i in range(4)]

            # Find valid candidates in that order
            candidates = []
            for d in candidate_dirs:
                nr = cr + dirs[d][0]
                nc = cc + dirs[d][1]
                if allowed(nr, nc):
                    candidates.append((d, nr, nc))

            if not candidates:
                # dead end, abort this attempt
                success = False
                break

            # Prefer a candidate that reduces distance to the exit
            cur_dist = dist_to_exit(cr, cc)
            chosen = None
            for d, nr, nc in candidates:
                if dist_to_exit(nr, nc) < cur_dist:
                    chosen = (d, nr, nc)
                    break
            if chosen is None:
                # Otherwise pick the first candidate in bounce order
                chosen = candidates[0]

            d_idx, nr, nc = chosen
            # Carve the chosen cell (we purposely do NOT carve the forward cell if we bounced)
            inp[nr][nc] = 0
            path_set.add((nr, nc))
            path.append((nr, nc))
            curr = (nr, nc)
            dir_idx = d_idx

        # If we didn't reach a proper exit, try again
        if not success:
            continue

        # Ensure path has some length to be non-trivial
        if len(path) < 6:
            continue

        # Place pattern strip on row 1 (second row), columns 0..k-1
        k = random.randint(2, 4)
        # Choose k unique colors from 2..9 excluding wall color 1
        pattern_colors = random.sample([c for c in range(2, 10)], k)
        # Place them starting at column 0
        for j in range(k):
            inp[1][j] = pattern_colors[j]

        # Build output by applying the ripple-coloring along the path starting from start
        out = [row[:] for row in inp]
        # Color sequence starts when the ripple begins on the right neighbor of the source
        idx = 0
        # Simulate exactly the same movement as the solver will: follow path by looking at input background
        x, y = start
        dir_idx = 0
        steps = 0
        while 0 <= x < height and 0 <= y < width and steps < width * height:
            # Only color background cells
            if inp[x][y] != 0:
                break
            out[x][y] = pattern_colors[idx % k]
            idx += 1
            steps += 1
            # If current cell is on the top row or right column, stop (the path reaches edge)
            if x == 0 or y == width - 1:
                break
            # Find next move in bounce order
            moved = False
            for i in range(4):
                d = (dir_idx + i) % 4
                nx = x + dirs[d][0]
                ny = y + dirs[d][1]
                if 0 <= nx < height and 0 <= ny < width and inp[nx][ny] == 0:
                    dir_idx = d
                    x, y = nx, ny
                    moved = True
                    break
            if not moved:
                break

        # Final sanity checks
        # Ensure input and output are not identical
        if inp == out:
            continue

        return {"input": inp, "output": out}

    # Fallback: minimal simple grid (should rarely happen)
    w, h = 15, 15
    inp = [[1 for _ in range(w)] for _ in range(h)]
    sr, sc = h // 2, w // 2
    for dr in (-1, 0, 1):
        for dc in (-1, 0, 1):
            inp[sr + dr][sc + dc] = 0
    start = (sr, sc + 1)
    inp[start[0]][start[1]] = 0
    # simple straight path to the right
    for c in range(start[1], w - 1):
        inp[start[0]][c] = 0
    pattern_colors = [2, 3, 4]
    for j, col in enumerate(pattern_colors):
        inp[1][j] = col
    out = [row[:] for row in inp]
    idx = 0
    x, y = start
    while 0 <= x < h and 0 <= y < w:
        out[x][y] = pattern_colors[idx % len(pattern_colors)]
        idx += 1
        if y == w - 1:
            break
        y += 1
    return {"input": inp, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert tuple-of-tuples input to a mutable list-of-lists if necessary
    if isinstance(input_grid, tuple):
        grid = [list(row) for row in input_grid]
    else:
        grid = [list(row) for row in input_grid]

    height = len(grid)
    width = len(grid[0])

    # Find the source cell: a background cell (0) whose four orthogonal neighbors are also background
    source_r = source_c = -1
    for r in range(1, height - 1):
        for c in range(1, width - 1):
            if grid[r][c] != 0:
                continue
            if grid[r - 1][c] == 0 and grid[r + 1][c] == 0 and grid[r][c - 1] == 0 and grid[r][c + 1] == 0:
                source_r, source_c = r, c
                break
        if source_r != -1:
            break
    # Fallback to center if not found
    if source_r == -1:
        source_r, source_c = height // 2, width // 2

    # Extract pattern colors from row 1 (second row), reading left to right until a 0 or 1 appears
    pattern_colors = []
    for j in range(width):
        v = grid[1][j]
        if v == 0 or v == 1:
            break
        pattern_colors.append(v)
    if not pattern_colors:
        # fallback default
        pattern_colors = [2, 3, 4]

    # Prepare output grid
    out = [row[:] for row in grid]

    # Movement directions in bounce order: right, up, left, down
    dirs = [(0, 1), (-1, 0), (0, -1), (1, 0)]
    dir_idx = 0

    # Start at the right neighbor of the source
    x, y = source_r, source_c + 1
    idx = 0
    steps = 0
    max_steps = width * height
    while 0 <= x < height and 0 <= y < width and steps < max_steps:
        # Only color background cells
        if grid[x][y] != 0:
            break
        out[x][y] = pattern_colors[idx % len(pattern_colors)]
        idx += 1
        steps += 1
        # Stop when reaching the top row or the rightmost column
        if x == 0 or y == width - 1:
            break
        # Look for next move in bounce order (try current direction, then rotate)
        moved = False
        for i in range(4):
            d = (dir_idx + i) % 4
            nx = x + dirs[d][0]
            ny = y + dirs[d][1]
            if 0 <= nx < height and 0 <= ny < width and grid[nx][ny] == 0:
                dir_idx = d
                x, y = nx, ny
                moved = True
                break
        if not moved:
            break

    return out

