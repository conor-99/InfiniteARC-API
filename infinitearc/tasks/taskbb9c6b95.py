# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: bb9c6b95
Difficulty: hard

=== Tags ===
- Image repetition
- Pattern reflection

=== Description ===
The input grid contains a distinct, repeating pattern of connected non-zero
pixels (e.g., a shape that appears multiple times, possibly with gaps or
spacing). The output grid is generated by reflecting each occurrence of this
pattern across a vertical axis (left-right mirror) while preserving its original
position and spacing. The reflection operation is applied uniformly to all
instances of the pattern, resulting in a grid where every instance of the
original pattern is replaced by its mirrored counterpart. This transformation
requires identifying the repeating pattern, determining its vertical reflection,
and replacing each instance within the grid, ensuring the pattern's structural
integrity and spatial relationships remain consistent. The difficulty arises
from the need to isolate the repeating pattern from potential noise or
background elements, and to correctly apply the reflection without altering
other grid elements.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
from common import grid, randint, continuous_creature
def is_symmetric(base_pixels):
    if not base_pixels:
        return True
    base_rows = [p[0] for p in base_pixels]
    base_cols = [p[1] for p in base_pixels]
    min_r, max_r = min(base_rows), max(base_rows)
    min_c, max_c = min(base_cols), max(base_cols)
    width = max_c - min_c + 1
    height = max_r - min_r + 1
    base_grid = [[0]*width for _ in range(height)]
    for r, c in base_pixels:
        base_grid[r - min_r][c - min_c] = 1
    for r in range(height):
        for c in range(width // 2):
            if base_grid[r][c] != base_grid[r][width - 1 - c]:
                return False
    return True
def generate():
    width = randint(10, 30)
    height = randint(10, 30)
    input_grid = grid(width, height, 0)
    output_grid = grid(width, height, 0)

    base_size = randint(3, 5)
    base_pixels = continuous_creature(base_size, 3, 3)
    while is_symmetric(base_pixels):
        base_pixels = continuous_creature(base_size, 3, 3)

    base_rows = [p[0] for p in base_pixels]
    base_cols = [p[1] for p in base_pixels]
    min_r, min_c = min(base_rows), min(base_cols)
    base_rows = [r - min_r for r in base_rows]
    base_cols = [c - min_c for c in base_cols]
    base_width = max(base_cols) - min(base_cols) + 1

    num_repeats = randint(2, 4)
    spacing = randint(2, 3)
    total_width = (base_width + spacing) * num_repeats - spacing
    if total_width > width - 1:
        num_repeats = max(1, (width - 1) // (base_width + spacing))
        total_width = (base_width + spacing) * num_repeats - spacing
        if total_width > width - 1:
            num_repeats = 1

    for i in range(num_repeats):
        start_col = i * (base_width + spacing)
        for r, c in zip(base_rows, base_cols):
            if start_col + c < width and r < height:
                input_grid[r][start_col + c] = 1

    for i in range(num_repeats):
        start_col = i * (base_width + spacing)
        for r, c in zip(base_rows, base_cols):
            if start_col + c < width and r < height:
                reflected_col = 2 * start_col + base_width - 1 - (start_col + c)
                if 0 <= reflected_col < width:
                    output_grid[r][reflected_col] = 1

    if input_grid == output_grid:
        return generate()

    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    visited = [[False] * width for _ in range(height)]
    output_grid = [[0] * width for _ in range(height)]

    def dfs(r, c, component):
        if r < 0 or r >= height or c < 0 or c >= width or input_grid[r][c] == 0 or visited[r][c]:
            return
        visited[r][c] = True
        component.append((r, c))
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            dfs(r + dr, c + dc, component)

    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                component = []
                dfs(r, c, component)
                min_col = min(c for _, c in component)
                max_col = max(c for _, c in component)
                for r2, c2 in component:
                    new_c = min_col + max_col - c2
                    output_grid[r2][new_c] = input_grid[r2][c2]
    return output_grid
