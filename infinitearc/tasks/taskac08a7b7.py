# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: ac08a7b7
Difficulty: insane

=== Tags ===
- Wavefront timing
- Inference from demonstration
- Hollow shape detection
- Create image from info

=== Description ===
Input grids display a single hollow geometric shape (e.g., irregular ring,
nested polygons, or fragmented loops) defined by a closed boundary of a distinct
color, with the interior filled with background color. The grid also contains
one or more wave sources—distinct colored markers placed along the boundary's
edge. The output grid must generate a filled representation of the hollow
interior, where each cell's color corresponds to the time step at which a
wavefront first reaches it from the nearest wave source. Wavefronts propagate
inward from sources at constant speed (one cell per time step), moving only
through the hollow interior (not through the boundary loop), with propagation
paths determined by Manhattan distance. If multiple wavefronts reach a cell
simultaneously, it is colored with a designated overlap indicator (e.g., gray).
The color mapping for time steps (1→color A, 2→color B, etc.) is fixed but not
explicitly provided, requiring inference from input-output examples. The
boundary loop remains unchanged, and the background outside the hollow shape is
preserved. Solving requires detecting the hollow shape's boundary, identifying
wave sources, computing shortest-path distances, inferring the color-time
mapping, and applying the filled pattern.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    n = random.randint(10, 30)
    input_grid = grid(n, n, 0)
    start_row, start_col = 2, 2
    end_row, end_col = n - 3, n - 3
    
    for c in range(start_col, end_col + 1):
        input_grid[start_row][c] = 1
        input_grid[end_row][c] = 1
    for r in range(start_row, end_row + 1):
        input_grid[r][start_col] = 1
        input_grid[r][end_col] = 1
    
    boundary_pixels = set()
    for c in range(start_col, end_col + 1):
        boundary_pixels.add((start_row, c))
        boundary_pixels.add((end_row, c))
    for r in range(start_row, end_row + 1):
        boundary_pixels.add((r, start_col))
        boundary_pixels.add((r, end_col))
    
    sources = random.sample(boundary_pixels, random.randint(2, 4))
    for r, c in sources:
        input_grid[r][c] = 2
    
    output_grid = [row[:] for row in input_grid]
    for r in range(start_row + 1, end_row):
        for c in range(start_col + 1, end_col):
            min_dist = min(abs(r - sr) + abs(c - sc) for sr, sc in sources)
            color = min(3 + min_dist, 9)
            output_grid[r][c] = color
    
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    n = len(input_grid)
    m = len(input_grid[0])
    boundary = []
    sources = []
    for r in range(n):
        for c in range(m):
            if input_grid[r][c] == 1:
                boundary.append((r, c))
            elif input_grid[r][c] == 2:
                sources.append((r, c))
    
    seed = (n//2, m//2)
    while input_grid[seed[0]][seed[1]] != 0:
        seed = (seed[0] + 1, seed[1])
        if seed[0] >= n:
            seed = (seed[0] - 1, seed[1])
    
    interior = set()
    queue = deque([seed])
    visited = set([seed])
    while queue:
        r, c = queue.popleft()
        interior.add((r, c))
        for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < n and 0 <= nc < m and input_grid[nr][nc] == 0 and (nr, nc) not in visited:
                visited.add((nr, nc))
                queue.append((nr, nc))
    
    output_grid = [list(row) for row in input_grid]
    for r, c in interior:
        min_dist = min(abs(r - sr) + abs(c - sc) for sr, sc in sources)
        color = min(3 + min_dist, 9)
        output_grid[r][c] = color
    
    return output_grid
