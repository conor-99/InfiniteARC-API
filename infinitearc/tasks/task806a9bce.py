# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 806a9bce
Difficulty: hard

=== Tags ===
- Perimeter smoothing
- Rule based tiling
- Chain reaction
- Momentum conservation path
- Measure distance from side
- Rectangle guessing

=== Description ===
Input grids feature a single, irregularly shaped region composed of non-
background colors (1-9) surrounded by a background (color 0). The shape has a
jagged perimeter with protrusions (extensions beyond a smooth boundary) and
indentations (recesses into the shape), creating complex edge patterns that
depend on their proximity to the grid's outer edges.  The output grid applies a
multi-stage transformation: 1. **Edge-proximity measurement**: For each cell on
the shape's perimeter (adjacent to background), calculate its Manhattan distance
to the nearest grid edge (top, bottom, left, right). 2. **Edge-adjacent chain
reaction**:     - Cells within distance 1 of any grid edge trigger recursive
smoothing:      - Protrusions (background adjacent on ≥3 sides) are removed (set
to background).      - Indentations (shape adjacent on ≥3 sides) are filled (set
to shape color).    - This triggers a chain reaction: each modification
propagates to adjacent cells, repeating until all edge-adjacent irregularities
are resolved. 3. **Inner smoothing**: For remaining perimeter cells (distance >
1 from grid edges), replace any 2x2 corner-like patterns with a diagonal tile:
- Retain top-left and bottom-right cells of the 2x2 block.    - Fill top-right
and bottom-left cells with the dominant color of the original block.    - This
creates smooth diagonal transitions while preserving the shape's core structure.
The transformation sequence ensures the perimeter becomes progressively smoother
from the grid edges inward, with the chain reaction resolving edge effects
before applying inner smoothing. The output maintains the original shape's area
and color distribution, with no new cells added or removed beyond the perimeter
adjustments. The solution requires identifying distance-based rules, executing
recursive chain reactions, and applying context-sensitive tiling to achieve a
visually consistent rectangular approximation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import continuous_creature

def generate():
    while True:
        width = random.randint(5, 30)
        height = random.randint(5, 30)
        shape_color = random.randint(1, 9)
        shape_size = random.randint(5, 20)
        input_grid = [[0] * width for _ in range(height)]
        pixels = continuous_creature(shape_size, width, height)
        for r, c in pixels:
            if 0 <= r < height and 0 <= c < width:
                input_grid[r][c] = shape_color
        
        grid = [row[:] for row in input_grid]
        height = len(grid)
        width = len(grid[0])
        shape_color = None
        for r in range(height):
            for c in range(width):
                if grid[r][c] != 0:
                    shape_color = grid[r][c]
                    break
            if shape_color is not None:
                break
        if shape_color is None:
            continue  # Skip all-background grids
        
        from collections import deque
        queue = deque()
        
        def count_bg(r, c):
            count = 0
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0:
                    count += 1
            return count

        def count_shape(r, c):
            count = 0
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                    count += 1
            return count

        dists = [[min(r, height - 1 - r, c, width - 1 - c) for c in range(width)] for r in range(height)]

        for r in range(height):
            for c in range(width):
                has_bg = False
                has_shape = False
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        if grid[nr][nc] == 0:
                            has_bg = True
                        else:
                            has_shape = True
                if has_bg and has_shape and dists[r][c] <= 1:
                    queue.append((r, c))

        while queue:
            r, c = queue.popleft()
            has_bg = False
            has_shape = False
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    if grid[nr][nc] == 0:
                        has_bg = True
                    else:
                        has_shape = True
            if not (has_bg and has_shape):
                continue
            if grid[r][c] != 0:
                if count_bg(r, c) >= 3:
                    grid[r][c] = 0
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < height and 0 <= nc < width:
                            queue.append((nr, nc))
            else:
                if count_shape(r, c) >= 3:
                    grid[r][c] = shape_color
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < height and 0 <= nc < width:
                            queue.append((nr, nc))

        for r in range(height - 1):
            for c in range(width - 1):
                tl = grid[r][c]
                tr = grid[r][c+1]
                bl = grid[r+1][c]
                br = grid[r+1][c+1]
                if tl != 0 and br != 0 and tr == 0 and bl == 0:
                    grid[r][c+1] = shape_color
                    grid[r+1][c] = shape_color

        output_grid = grid
        if input_grid != output_grid:
            return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Ensure input_grid is list of lists
    if isinstance(input_grid[0], tuple):
        input_grid = [list(row) for row in input_grid]
    grid = [row[:] for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    shape_color = None
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                shape_color = grid[r][c]
                break
        if shape_color is not None:
            break
    if shape_color is None:
        return input_grid
    
    from collections import deque
    queue = deque()
    
    def count_bg(r, c):
        count = 0
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0:
                count += 1
        return count

    def count_shape(r, c):
        count = 0
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                count += 1
        return count

    dists = [[min(r, height - 1 - r, c, width - 1 - c) for c in range(width)] for r in range(height)]

    for r in range(height):
        for c in range(width):
            has_bg = False
            has_shape = False
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    if grid[nr][nc] == 0:
                        has_bg = True
                    else:
                        has_shape = True
            if has_bg and has_shape and dists[r][c] <= 1:
                queue.append((r, c))

    while queue:
        r, c = queue.popleft()
        has_bg = False
        has_shape = False
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width:
                if grid[nr][nc] == 0:
                    has_bg = True
                else:
                    has_shape = True
        if not (has_bg and has_shape):
            continue
        if grid[r][c] != 0:
            if count_bg(r, c) >= 3:
                grid[r][c] = 0
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        queue.append((nr, nc))
        else:
            if count_shape(r, c) >= 3:
                grid[r][c] = shape_color
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        queue.append((nr, nc))

    for r in range(height - 1):
        for c in range(width - 1):
            tl = grid[r][c]
            tr = grid[r][c+1]
            bl = grid[r+1][c]
            br = grid[r+1][c+1]
            if tl != 0 and br != 0 and tr == 0 and bl == 0:
                grid[r][c+1] = shape_color
                grid[r+1][c] = shape_color

    return grid
