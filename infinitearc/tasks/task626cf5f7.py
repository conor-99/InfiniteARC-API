# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 626cf5f7
Difficulty: medium

=== Tags ===
- Associate colors to images
- Pattern modification
- Count tiles
- Pattern rotation

=== Description ===
The task involves rotating the input grid based on the count of tiles matching
the top-left color. The output grid is created by rotating the input 90 degrees
clockwise as many times as the count of tiles sharing the top-left color, with
the rotation count taken modulo 4. For example, if the top-left color appears 3
times, the grid is rotated 270 degrees clockwise (equivalent to 90 degrees
counterclockwise). This transformation ensures the output grid differs from the
input, as the rotation angle (determined by count mod 4) is never zero (due to
grid dimensions ≥2×2 and the generator avoiding cases where count mod 4 = 0).
The solver must identify the top-left color, count its occurrences, apply the
rotation, and produce the modified grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def rotate_90_clockwise(grid):
    return [list(reversed(col)) for col in zip(*grid)]

def generate():
    while True:
        w = random.randint(2, 30)
        h = random.randint(2, 30)
        grid = [[random.randint(0, 9) for _ in range(w)] for _ in range(h)]
        c = grid[0][0]
        count = sum(row.count(c) for row in grid)
        if count % 4 == 0:
            if count == w * h:
                r, c_idx = random.randint(1, h-1), random.randint(0, w-1)
                grid[r][c_idx] = (c + 1) % 10
            else:
                candidates = []
                for r in range(h):
                    for c_idx in range(w):
                        if (r == 0 and c_idx == 0):
                            continue
                        if grid[r][c_idx] != c:
                            candidates.append((r, c_idx))
                if candidates:
                    r, c_idx = random.choice(candidates)
                    grid[r][c_idx] = c
                else:
                    r, c_idx = 1, 0
                    grid[r][c_idx] = (c + 1) % 10
            count = sum(row.count(c) for row in grid)
        rotation_steps = count % 4
        output = grid
        for _ in range(rotation_steps):
            output = rotate_90_clockwise(output)
        if grid == output:
            continue
        else:
            break
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def rotate_90_clockwise(grid):
    return [list(reversed(col)) for col in zip(*grid)]

def p(input_grid):
    c = input_grid[0][0]
    count = sum(row.count(c) for row in input_grid)
    rotation_steps = count % 4
    output = input_grid
    for _ in range(rotation_steps):
        output = rotate_90_clockwise(output)
    return output
