# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: be865e75
Difficulty: insane

=== Tags ===
- Multi condition recolor
- Reflective maze
- Meta rule learning
- Find and fix broken symmetry

=== Description ===
Input grids are 25×25 to 30×30, featuring a complex maze structure defined by
colored walls (values 1-9) on a uniform background (0). The maze is designed to
exhibit perfect vertical symmetry (left-right mirroring) across the central
axis, but contains deliberate, non-random errors: walls missing on one side,
walls present where they shouldn't be, and color mismatches between mirrored
positions. Additionally, the maze incorporates "reflective" properties where
wall colors must maintain consistent color relationships when
mirrored—specifically, colors must follow a meta rule determined by the grid's
structural features.   The output grid corrects all symmetry errors through a
multi-stage process:   1. **Reference color identification**: The first non-
background cell encountered in the top-left quadrant (scanning row-major from
(0,0) to (width/2, height/2)) defines the reference color. This color serves as
the universal standard for all symmetry corrections.   2. **Symmetry
validation**: For every cell (r, c) in the left half (c < width/2), the mirrored
position (r, width-1-c) is checked against the reference color.   3. **Multi-
condition recoloring**:      - If the mirrored cell contains a wall (color > 0)
but differs from the reference color, recolor it to the reference color.      -
If the left cell is a wall (color > 0) but the mirrored cell is background (0),
recolor the mirrored cell to the reference color.      - If the left cell is
background (0) but the mirrored cell is a wall (color > 0), recolor the mirrored
cell to background (0).   4. **Reflective consistency enforcement**: After
recoloring, the maze must exhibit perfect vertical symmetry with *only* the
reference color used for all corrected walls. Non-symmetry elements (e.g., the
reference wall itself) remain unchanged, and all original background cells stay
intact.    This task demands meta-rule learning (dynamically identifying the
reference color), multi-condition recoloring (applying rules based on position,
color, and symmetry), and iterative symmetry correction—making it exceptionally
challenging due to the interdependence of all rules and the need to resolve
conflicting errors (e.g., a misplaced wall that must be both recolored *and*
removed).
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    size = random.randint(25, 30)
    ref_color = random.randint(1, 9)
    
    output = grid(size, size, 0)
    for r in range(size):
        for c in range(size // 2):
            if random.random() > 0.5:
                output[r][c] = ref_color
                output[r][size - 1 - c] = ref_color
    
    input_grid = [row[:] for row in output]
    
    for r in range(size):
        for c in range(size // 2):
            if (r == 0 and c == 0):
                continue
            if input_grid[r][c] != 0:
                if random.random() > 0.7:
                    input_grid[r][size - 1 - c] = 0
                elif random.random() > 0.5:
                    new_color = ref_color
                    while new_color == ref_color:
                        new_color = random.randint(1, 9)
                    input_grid[r][size - 1 - c] = new_color
            else:
                if random.random() > 0.7:
                    input_grid[r][size - 1 - c] = ref_color
    
    return {
        "input": input_grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    
    ref_color = None
    for r in range(height):
        for c in range(width // 2):
            if input_grid[r][c] > 0:
                ref_color = input_grid[r][c]
                break
        if ref_color is not None:
            break
    
    for r in range(height):
        for c in range(width // 2):
            mirrored_c = width - 1 - c
            left = input_grid[r][c]
            right = input_grid[r][mirrored_c]
            
            if right > 0 and right != ref_color:
                input_grid[r][mirrored_c] = ref_color
            if left > 0 and right == 0:
                input_grid[r][mirrored_c] = ref_color
            if left == 0 and right > 0:
                input_grid[r][mirrored_c] = 0
    
    return tuple(tuple(row) for row in input_grid)
