# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: bd14f2bd
Difficulty: hard

=== Tags ===
- Mirror bounce
- Mark wall impact
- Sequence interpolation
- Beam reflection
- Order numbers

=== Description ===
Input grids consist of a 2D grid of colors (0-9) representing a maze-like
environment with distinct elements: a single starting beam cell (color 1),
mirror elements (diagonal patterns represented by colors 2 and 3 for / and \
respectively), wall obstacles (color 4), and a sequence strip (a horizontal or
vertical row of cells displaying colors corresponding to numerical sequence
values, e.g., color 5=1, color 6=2, color 7=3). The beam begins moving
horizontally to the right from its starting cell. It travels in straight lines
until encountering either a mirror or a wall. Mirrors reflect the beam's
direction (e.g., / reflects right→up, \ reflects right→down), while walls
reflect the beam's direction (e.g., top wall reflection → down, side wall
reflection → opposite horizontal direction) and mark the wall cell with the next
color in the sequence strip. The sequence repeats cyclically after reaching its
end. The beam continues until it exits the grid boundaries. Output grids must
precisely show the beam's complete path (including all reflections), with each
wall impact replaced by the sequence color corresponding to its position in the
ordered sequence. The sequence strip and mirror orientations remain unchanged in
the output. The task requires tracking the beam's path through multiple
reflections while correctly applying the sequence order to wall impacts, making
it challenging due to the need for precise path prediction and sequence
management in complex grid layouts.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = common.grid(width, height, 0)
    
    seq = [5, 6, 7]
    for col in range(1, 4):
        if col < width:
            grid[0][col] = seq[(col - 1) % len(seq)]
    
    start_row = random.randint(1, height - 2)
    start_col = 0
    grid[start_row][start_col] = 1
    
    mirror_col = start_col + 2
    mirror_row = start_row
    wall_row = mirror_row - 2
    wall_col = mirror_col
    
    if mirror_col < width - 1 and wall_row >= 0:
        grid[mirror_row][mirror_col] = 2
        grid[wall_row][wall_col] = 4
    
    def simulate_path(start_row, start_col, grid):
        directions = [(0, 1), (-1, 0), (0, -1), (1, 0)]
        current_r, current_c = start_row, start_col
        dir_idx = 0
        hits = []
        while True:
            dr, dc = directions[dir_idx]
            next_r, next_c = current_r + dr, current_c + dc
            if next_r < 0 or next_r >= len(grid) or next_c < 0 or next_c >= len(grid[0]):
                break
            cell = grid[next_r][next_c]
            if cell == 2:
                dir_idx = (dir_idx + 1) % 4
            elif cell == 3:
                dir_idx = (dir_idx + 3) % 4
            elif cell == 4:
                hits.append((next_r, next_c))
                dir_idx = (dir_idx + 2) % 4
            current_r, current_c = next_r, next_c
        return hits
    
    hits = simulate_path(start_row, start_col, grid)
    if not hits:
        for r in range(height):
            for c in range(width):
                if grid[r][c] == 0:
                    grid[r][c] = 4
                    hits = simulate_path(start_row, start_col, grid)
                    if hits:
                        break
            if hits:
                break
    
    output_grid = [row[:] for row in grid]
    for i, (r, c) in enumerate(hits):
        output_grid[r][c] = seq[i % len(seq)]
    
    return {"input": grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    start_pos = None
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 1:
                start_pos = (r, c)
                break
        if start_pos:
            break
    
    if not start_pos:
        return input_grid
    
    def simulate_path(start_row, start_col, grid):
        directions = [(0, 1), (-1, 0), (0, -1), (1, 0)]
        current_r, current_c = start_row, start_col
        dir_idx = 0
        hits = []
        while True:
            dr, dc = directions[dir_idx]
            next_r, next_c = current_r + dr, current_c + dc
            if next_r < 0 or next_r >= len(grid) or next_c < 0 or next_c >= len(grid[0]):
                break
            cell = grid[next_r][next_c]
            if cell == 2:
                dir_idx = (dir_idx + 1) % 4
            elif cell == 3:
                dir_idx = (dir_idx + 3) % 4
            elif cell == 4:
                hits.append((next_r, next_c))
                dir_idx = (dir_idx + 2) % 4
            current_r, current_c = next_r, next_c
        return hits
    
    hits = simulate_path(start_pos[0], start_pos[1], grid)
    seq = [5, 6, 7]
    output_grid = [row[:] for row in grid]
    for i, (r, c) in enumerate(hits):
        output_grid[r][c] = seq[i % len(seq)]
    
    return tuple(tuple(row) for row in output_grid)
