# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 85dc60b3
Difficulty: hard

=== Tags ===
- Enlarge image
- Associate colors to patterns

=== Description ===
The task requires transforming an input grid into an output grid by scaling the
entire grid according to a specific color pattern. The input grid contains a
distinct, isolated pattern formed by a single color (e.g., a small square,
triangle, or other contiguous shape surrounded by background colors). This
pattern must be visually identifiable as a cohesive feature (e.g., a solid 2×2
square of color 5 in a sea of other colors). The color of this pattern
determines the scaling factor: each input cell is replaced by a block of size
(color value + 1) × (color value + 1) in the output grid. The output grid size
is calculated as (input width × (color + 1)) × (input height × (color + 1)),
ensuring it remains within the 1×1 to 30×30 constraint. The transformation
requires recognizing the pattern's color through visual inspection (not
numerical counts or sums), associating it with the scaling rule, and applying
uniform scaling to all cells. For example, a pattern of color 3 (green) in the
input results in a 4×4 block expansion per input cell, producing an output grid
four times larger in both dimensions. The challenge lies in distinguishing the
target pattern from other colors and shapes, as multiple patterns may exist, but
only the intended one (e.g., the largest or most centrally located) determines
the scaling factor.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    c = random.randint(1, 9)
    s = c + 1
    max_size = 30 // s
    w = random.randint(2, max_size)
    h = random.randint(2, max_size)
    
    bg_colors = [i for i in range(1, 10) if i != c]
    if len(bg_colors) < 2:
        bg_colors = [1, 2]
    bg1 = random.choice(bg_colors)
    bg_colors.remove(bg1)
    bg2 = random.choice(bg_colors)
    
    input_grid = [[bg1 if (i >= 2 or j >= 2) and (i + j) % 2 == 0 else bg2 for j in range(w)] for i in range(h)]
    
    for i in range(2):
        for j in range(2):
            if i < h and j < w:
                input_grid[i][j] = c
    
    output_grid = []
    for i in range(h):
        for _ in range(s):
            new_row = []
            for j in range(w):
                for _ in range(s):
                    new_row.append(input_grid[i][j])
            output_grid.append(new_row)
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    rows = len(input_grid)
    cols = len(input_grid[0])
    visited = [[False] * cols for _ in range(rows)]
    max_size = 0
    largest_color = 0
    
    directions = [(1,0), (-1,0), (0,1), (0,-1)]
    
    for i in range(rows):
        for j in range(cols):
            if visited[i][j]:
                continue
            color = input_grid[i][j]
            if color == 0:
                continue
            queue = deque()
            queue.append((i, j))
            visited[i][j] = True
            size = 0
            current_color = color
            while queue:
                r, c = queue.popleft()
                size += 1
                for dr, dc in directions:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and input_grid[nr][nc] == color:
                        visited[nr][nc] = True
                        queue.append((nr, nc))
            if size > max_size:
                max_size = size
                largest_color = color
    
    s = largest_color + 1
    output = []
    for i in range(rows):
        for _ in range(s):
            new_row = []
            for j in range(cols):
                for _ in range(s):
                    new_row.append(input_grid[i][j])
            output.append(new_row)
    return output
