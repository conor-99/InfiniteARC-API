# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: a87b5e4e
Difficulty: medium

=== Tags ===
- Algebra
- Adapt image to grid
- Dominant color
- Cluster by color

=== Description ===
The task involves transforming an input grid into an output grid by analyzing
connected clusters of the same color. Each cluster (connected via 4-directional
adjacency) is identified, and its size (number of cells) is calculated. The new
color for every cell in the cluster is determined by the formula: (original
color value + cluster size) modulo 10. This algebraic operation modifies the
color based on both the original value and the spatial extent of the cluster.
The output grid is formed by replacing all cells in each cluster with their new
computed color, resulting in a grid where color changes reflect the cluster's
size and original hue. The transformation ensures the output grid differs from
the input by leveraging the cluster-based algebraic rule, incorporating the
concepts of clustering, algebraic manipulation, and adaptive color adaptation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
    output_grid = [[0] * width for _ in range(height)]
    visited = [[False] * width for _ in range(height)]
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c]:
                color = input_grid[r][c]
                cluster = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    cluster.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                size = len(cluster)
                new_color = (color + size) % 10
                for (cr, cc) in cluster:
                    output_grid[cr][cc] = new_color
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = [[0] * width for _ in range(height)]
    visited = [[False] * width for _ in range(height)]
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c]:
                color = input_grid[r][c]
                cluster = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    cluster.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                size = len(cluster)
                new_color = (color + size) % 10
                for (cr, cc) in cluster:
                    output_grid[cr][cc] = new_color
    return output_grid
