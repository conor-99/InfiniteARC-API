# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: ac2065e8
Difficulty: insane

=== Tags ===
- Recursive agent following
- State machine grid
- Laser diffusion
- Lattice completion

=== Description ===
Task: Recursive Laser Lattice  Input grids are large (25×25) with a uniform gray
background. Over this background, two key elements appear: scattered color-coded
state cells (1-9 distinct colors) and multiple source cells positioned along the
left edge. Each source cell contains a unique color (e.g., red) that initiates a
laser beam traveling rightward. State cells are arranged in a non-orthogonal
lattice pattern, with each color corresponding to a specific state in a 5-state
machine:   - **State 1 (blue)**: Reflects beam 90° upward   - **State 2
(green)**: Splits beam into upward and downward directions   - **State 3
(yellow)**: Splits beam into left and right directions   - **State 4 (purple)**:
Allows beam to pass without changing direction   - **State 5 (orange)**: Absorbs
beam (no further propagation)    Laser beams propagate through background cells,
changing color cyclically through a predefined sequence (e.g., red → blue →
green → red...) with each cell traversed. Upon hitting a state cell, the beam's
behavior is determined by the cell's color, triggering recursive path expansion:
- Splitting beams create new agents following the same state rules   - Reflected
beams continue propagation in the new direction   - Absorbed beams terminate
immediately    The output grid preserves all source cells and state cells but
fills background paths with beam trails. Beam color at each cell corresponds to
the current color in the cyclic sequence. No beam overwrites state cells,
sources, or other beams. Path completion requires all beams to exit the grid
(top, bottom, left, or right edges) without overlapping. The lattice structure
emerges as beams form interconnected pathways that visually "complete" the
grid's underlying pattern through recursive diffusion and reflection.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque
from common import grid

def generate():
    size = 25
    input_grid = grid(size, size, 0)
    sources = []
    for _ in range(random.randint(1, 2)):
        r = random.randint(1, size-2)
        if input_grid[r][1] != 0:
            continue
        input_grid[r][0] = 2
        sources.append((r, 0))
    
    state_colors = [1, 3, 4, 6, 7]
    lattice_rows = [5, 8, 11, 14, 17, 20]
    lattice_cols = [5, 8, 11, 14, 17, 20]
    for color in state_colors:
        for _ in range(random.randint(3, 5)):
            r = random.choice(lattice_rows)
            c = random.choice(lattice_cols)
            if input_grid[r][c] == 0:
                input_grid[r][c] = color
    
    output_grid = [row[:] for row in input_grid]
    sequence = [1, 3, 4, 6, 7, 2]
    beam_queue = deque()
    
    for r, c in sources:
        beam_queue.append((r, 0, 0, 1, 0))
    
    steps = 0
    max_steps = 10000
    while beam_queue and steps < max_steps:
        steps += 1
        r, c, dr, dc, idx = beam_queue.popleft()
        nr, nc = r + dr, c + dc
        if not (0 <= nr < size and 0 <= nc < size):
            continue
        if input_grid[nr][nc] != 0:
            state_color = input_grid[nr][nc]
            if state_color == 1:
                new_dr, new_dc = -1, 0
            elif state_color == 3:
                beam_queue.append((r, c, -1, 0, idx))
                beam_queue.append((r, c, 1, 0, idx))
                continue
            elif state_color == 4:
                beam_queue.append((r, c, 0, -1, idx))
                beam_queue.append((r, c, 0, 1, idx))
                continue
            elif state_color == 6:
                new_dr, new_dc = dr, dc
            elif state_color == 7:
                continue
            if state_color in [1, 6]:
                beam_queue.append((r, c, new_dr, new_dc, idx))
        else:
            color = sequence[idx % len(sequence)]
            output_grid[nr][nc] = color
            idx += 1
            beam_queue.append((nr, nc, dr, dc, idx))
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    size = len(input_grid)
    output_grid = [list(row) for row in input_grid]
    sequence = [1, 3, 4, 6, 7, 2]
    beam_queue = deque()
    
    sources = []
    for r in range(size):
        if input_grid[r][0] == 2:
            sources.append((r, 0))
    
    for r, c in sources:
        beam_queue.append((r, 0, 0, 1, 0))
    
    steps = 0
    max_steps = 10000
    while beam_queue and steps < max_steps:
        steps += 1
        r, c, dr, dc, idx = beam_queue.popleft()
        nr, nc = r + dr, c + dc
        if not (0 <= nr < size and 0 <= nc < size):
            continue
        if input_grid[nr][nc] != 0:
            state_color = input_grid[nr][nc]
            if state_color == 1:
                new_dr, new_dc = -1, 0
            elif state_color == 3:
                beam_queue.append((r, c, -1, 0, idx))
                beam_queue.append((r, c, 1, 0, idx))
                continue
            elif state_color == 4:
                beam_queue.append((r, c, 0, -1, idx))
                beam_queue.append((r, c, 0, 1, idx))
                continue
            elif state_color == 6:
                new_dr, new_dc = dr, dc
            elif state_color == 7:
                continue
            if state_color in [1, 6]:
                beam_queue.append((r, c, new_dr, new_dc, idx))
        else:
            color = sequence[idx % len(sequence)]
            output_grid[nr][nc] = color
            idx += 1
            beam_queue.append((nr, nc, dr, dc, idx))
    
    return output_grid
