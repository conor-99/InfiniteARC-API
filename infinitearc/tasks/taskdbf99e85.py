# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: dbf99e85
Difficulty: insane

=== Tags ===
- Recursive agent following
- Dynamic channel painting
- Contouring
- Bidirectional mapping

=== Description ===
# Recursive Contour Channel Mapping  Input grids feature a complex, multi-region
landscape composed of contiguous blocks of distinct colors (0-9), each separated
by thin, one-cell-wide contour lines (typically color 5) that form intricate,
interconnected boundaries between regions. A unique starting marker (color 9)
appears at a single cell along the contour network, positioned at the
intersection of multiple contour paths. The grid contains a dynamic color
sequence (a repeating cycle of 4 distinct colors, e.g., red, green, blue,
yellow) that will be used for channel painting.  The task requires a recursive
agent following the contour lines starting from the marker. The agent moves
along contour paths in the direction that maintains the region on its left
(consistent with a standard boundary-following algorithm). As it moves, each
contour cell is dynamically painted with the next color in the sequence (cycling
through the 4 colors continuously). When the agent encounters a contour junction
(a cell where three or more contour paths meet), it splits into multiple agents,
each following a distinct available direction. Each new agent begins painting
with the next color in the sequence following the last color used by the parent
agent.  The output grid preserves all original region colors and contours, but
replaces the contour cells with the dynamically painted channels. The recursive
branching creates a complex, multi-layered channel network in the output.
Crucially, the bidirectional mapping manifests as mirrored channel patterns: for
every channel segment painted in one direction, a corresponding segment is
painted in the opposite direction at the same relative position within the
region boundaries, creating a symmetrical channel structure that reflects the
contour's inherent bidirectional nature. The channel thickness remains one cell
wide, and channels never overlap or overwrite original region colors.  The
transformation requires simultaneously tracking the agent's recursive path,
managing the dynamic color sequence, identifying contour junctions, and applying
the bidirectional symmetry rule to generate the final channel structure. The
output reveals a visually complex, symmetrical channel network that encodes the
recursive contour-following process through its color progression and mirrored
structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def _partition(n, k):
    # partition n into k positive integers
    if k <= 0:
        return []
    if k == 1:
        return [n]
    # choose k-1 cut points between 1 and n-1
    cuts = sorted(random.sample(range(1, n), k - 1))
    parts = []
    prev = 0
    for c in cuts:
        parts.append(c - prev)
        prev = c
    parts.append(n - prev)
    return parts


def generate():
    # size between 9 and 25 to allow for multi-block layout plus separators
    size = random.randint(9, 25)

    # dynamic color sequence is deterministic so the solver can reproduce it
    dynamic_colors = [1, 2, 3, 4]

    # choose number of region block rows/cols (at least 2 each)
    max_blocks = min(4, max(2, size // 3))
    R = random.randint(2, max_blocks)
    C = random.randint(2, max_blocks)

    # compute how many rows/cols are available for block interiors (exclude separators)
    total_sep_rows = R - 1
    total_sep_cols = C - 1
    inner_rows = size - total_sep_rows
    inner_cols = size - total_sep_cols
    # ensure feasibility
    R = min(R, max(2, inner_rows))
    C = min(C, max(2, inner_cols))
    total_sep_rows = R - 1
    total_sep_cols = C - 1
    inner_rows = size - total_sep_rows
    inner_cols = size - total_sep_cols

    # partition the inner rows/cols into block heights/widths
    heights = _partition(inner_rows, R)
    widths = _partition(inner_cols, C)

    # compute start indices for each block and separator indices
    rstarts = []
    cstarts = []
    sep_rows = []
    sep_cols = []

    r = 0
    for i, h in enumerate(heights):
        rstarts.append(r)
        r += h
        if i < R - 1:
            sep_rows.append(r)
            r += 1
    c = 0
    for j, w in enumerate(widths):
        cstarts.append(c)
        c += w
        if j < C - 1:
            sep_cols.append(c)
            c += 1

    # prepare grid and region colors
    g = grid(size, size, 0)
    # choose region colors avoiding contour (5) and marker (9) and dynamic colors if possible
    all_colors = [c for c in range(1, 10) if c not in (5, 9)]
    region_pool = [c for c in all_colors if c not in dynamic_colors]
    if not region_pool:
        region_pool = all_colors[:]

    # fill blocks
    for i in range(R):
        for j in range(C):
            color = random.choice(region_pool)
            rs, cs = rstarts[i], cstarts[j]
            h, w = heights[i], widths[j]
            for rr in range(rs, rs + h):
                for cc in range(cs, cs + w):
                    g[rr][cc] = color

    # draw separators (contours) with color 5
    for rr in sep_rows:
        for cc in range(size):
            g[rr][cc] = 5
    for cc in sep_cols:
        for rr in range(size):
            g[rr][cc] = 5

    # choose a junction (intersection of a horizontal and vertical separator) to be the start marker
    intersections = [(rr, cc) for rr in sep_rows for cc in sep_cols]
    if not intersections:
        # fallback: pick any contour cell with degree >= 3
        contour = [(r0, c0) for r0 in range(size) for c0 in range(size) if g[r0][c0] == 5]
        def deg(cell):
            r0, c0 = cell
            d = 0
            for dr, dc in [(-1,0),(0,1),(1,0),(0,-1)]:
                nr, nc = r0+dr, c0+dc
                if 0 <= nr < size and 0 <= nc < size and g[nr][nc] == 5:
                    d += 1
            return d
        junctions = [c for c in contour if deg(c) >= 3]
        if junctions:
            start = random.choice(junctions)
        else:
            # as last resort pick center of grid
            start = (size // 2, size // 2)
            g[start[0]][start[1]] = 5
    else:
        start = random.choice(intersections)

    g[start[0]][start[1]] = 9

    # build contour graph
    contour_nodes = set()
    for r0 in range(size):
        for c0 in range(size):
            if g[r0][c0] == 5 or g[r0][c0] == 9:
                contour_nodes.add((r0, c0))

    neighbors = {}
    directions = [(-1,0),(0,1),(1,0),(0,-1)]
    for (r0, c0) in contour_nodes:
        neigh = []
        for dr, dc in directions:
            nr, nc = r0+dr, c0+dc
            if (nr, nc) in contour_nodes:
                neigh.append((nr, nc))
        neighbors[(r0, c0)] = neigh

    # deterministic DFS order (so solver can replicate)
    visited_order = {}
    idx = 0
    def dfs(prev, cur):
        nonlocal idx
        if cur in visited_order:
            return
        visited_order[cur] = idx
        idx += 1
        # iterate neighbors in fixed directional order
        # skip going straight back to prev first to emulate boundary-following preference
        neighs = neighbors.get(cur, [])[:]
        # sort by our preferred direction order
        dir_index = {(-1,0):0,(0,1):1,(1,0):2,(0,-1):3}
        neighs_sorted = sorted(neighs, key=lambda p: dir_index[(p[0]-cur[0], p[1]-cur[1])])
        for nb in neighs_sorted:
            if nb == prev:
                continue
            dfs(cur, nb)
        # allow backtracking to prev neighbor if there are unvisited neighbors left
        for nb in neighs_sorted:
            if nb not in visited_order:
                dfs(cur, nb)

    dfs(None, start)

    # build output by painting contour nodes according to visitation order and mirrored symmetry
    output = [row[:] for row in g]
    INF = 10**9
    for cell, order_idx in visited_order.items():
        r0, c0 = cell
        output[r0][c0] = dynamic_colors[order_idx % len(dynamic_colors)]

    # apply mirrored (bidirectional) mapping: for each contour cell, ensure its mirror across start
    sr, sc = start
    for (r0, c0) in list(contour_nodes):
        mr, mc = 2*sr - r0, 2*sc - c0
        if not (0 <= mr < size and 0 <= mc < size):
            continue
        if g[mr][mc] not in (5, 9):
            continue
        idx_a = visited_order.get((r0, c0), INF)
        idx_b = visited_order.get((mr, mc), INF)
        chosen = min(idx_a, idx_b)
        if chosen < INF:
            col = dynamic_colors[chosen % len(dynamic_colors)]
            output[r0][c0] = col
            output[mr][mc] = col

    return {"input": g, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    if h == 0:
        return grid
    w = len(grid[0])

    # dynamic colors are deterministic so solver matches generator
    dynamic_colors = [1, 2, 3, 4]

    # find start marker (9)
    start = None
    for r in range(h):
        for c in range(w):
            if grid[r][c] == 9:
                start = (r, c)
                break
        if start:
            break
    if start is None:
        # nothing to do
        return grid

    # identify contour nodes (5 or 9)
    contour_nodes = set()
    for r in range(h):
        for c in range(w):
            if grid[r][c] == 5 or grid[r][c] == 9:
                contour_nodes.add((r, c))

    # build adjacency mapping
    directions = [(-1,0),(0,1),(1,0),(0,-1)]
    neighbors = {}
    for (r0, c0) in contour_nodes:
        neigh = []
        for dr, dc in directions:
            nr, nc = r0+dr, c0+dc
            if (nr, nc) in contour_nodes:
                neigh.append((nr, nc))
        neighbors[(r0, c0)] = neigh

    # DFS with deterministic neighbor order
    visited_order = {}
    idx = 0
    def dfs(prev, cur):
        nonlocal idx
        if cur in visited_order:
            return
        visited_order[cur] = idx
        idx += 1
        neighs = neighbors.get(cur, [])[:]
        dir_index = {(-1,0):0,(0,1):1,(1,0):2,(0,-1):3}
        neighs_sorted = sorted(neighs, key=lambda p: dir_index[(p[0]-cur[0], p[1]-cur[1])])
        for nb in neighs_sorted:
            if nb == prev:
                continue
            dfs(cur, nb)
        for nb in neighs_sorted:
            if nb not in visited_order:
                dfs(cur, nb)

    dfs(None, start)

    # create output and paint according to visitation order
    output = [row[:] for row in grid]
    for cell, order_idx in visited_order.items():
        r0, c0 = cell
        output[r0][c0] = dynamic_colors[order_idx % len(dynamic_colors)]

    # apply mirrored symmetry across the start
    sr, sc = start
    INF = 10**9
    for (r0, c0) in list(contour_nodes):
        mr, mc = 2*sr - r0, 2*sc - c0
        if not (0 <= mr < h and 0 <= mc < w):
            continue
        if grid[mr][mc] not in (5, 9):
            continue
        idx_a = visited_order.get((r0, c0), INF)
        idx_b = visited_order.get((mr, mc), INF)
        chosen = min(idx_a, idx_b)
        if chosen < INF:
            col = dynamic_colors[chosen % len(dynamic_colors)]
            output[r0][c0] = col
            output[mr][mc] = col

    return output

