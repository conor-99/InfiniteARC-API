# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 19b59157
Difficulty: mediumâ€“hard

=== Tags ===
- Route switching
- One yes one no

=== Description ===
The input grid contains a continuous path that may branch at certain points,
with each branch segment colored using two distinct colors: one color
representing "yes" (valid path) and the other representing "no" (invalid path).
The background is a neutral color (e.g., 0). At every fork where the path splits
into two directions, one branch is colored "yes" (e.g., color 1) and the other
"no" (e.g., color 2). The output grid must display only the path that follows
all "yes" branches, removing all "no" branches. The transformation requires
identifying each fork, selecting the "yes" branch based on its color, and
reconstructing a continuous path without any "no" segments. The background
remains unchanged, and the path is rendered as a single connected line through
all "yes" choices. The task demands precise color-based decision-making at
multiple forks, making it medium-hard due to the need to track branching choices
across the grid while ignoring irrelevant "no" paths.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random
def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = common.grid(width, height, 0)
    
    r, c = random.randint(0, height-1), 0
    path = [(r, c)]
    while c < width - 1:
        if random.random() > 0.3:
            if r > 0 and random.random() > 0.5:
                r -= 1
            elif r < height - 1:
                r += 1
        c += 1
        path.append((r, c))
    
    for (r, c) in path:
        grid[r][c] = 1
    
    for (r, c) in path:
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0:
                grid[nr][nc] = 2
                for _ in range(random.randint(1, 2)):
                    nr += dr
                    nc += dc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0:
                        grid[nr][nc] = 2
                    else:
                        break
    
    output = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if output[r][c] == 2:
                output[r][c] = 0
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    output = []
    for row in input_grid:
        new_row = []
        for cell in row:
            if cell == 2:
                new_row.append(0)
            else:
                new_row.append(cell)
        output.append(new_row)
    return output
