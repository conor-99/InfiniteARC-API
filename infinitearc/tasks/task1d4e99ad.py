# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 1d4e99ad
Difficulty: hard

=== Tags ===
- Rotating signal
- Mirrored attribute binding

=== Description ===
Task Description: Rotating Signal Mirror Binding  Input grids are 10×10 to 30×30
grids with a single background color (0). Overlaid on this background are
multiple "signal elements" – each represented as a single cell containing a non-
background color (1-9) with an associated directional arrow (up, down, left,
right). The grid exhibits vertical mirror symmetry across its central column (x
= width/2), meaning for every signal element not on the symmetry axis, there
exists a corresponding mirror element on the opposite side of the axis. The
mirror elements maintain identical color and direction in the input grid.  The
transformation rule for output generation involves two key operations applied
simultaneously to all signal elements:  1. **Rotating Signal**: Each signal
element's directional arrow is rotated 90 degrees clockwise (up → right → down →
left → up). This rotation aligns the signal to face the direction of its mirror
axis.  2. **Mirrored Attribute Binding**: Each signal element's color is
replaced with the color of its mirror counterpart. This creates a binding where
all signal elements on one side of the axis share the same color as their mirror
counterparts on the opposite side.  The background and all non-signal elements
remain unchanged. The output grid maintains the same dimensions as the input,
with all signal elements transformed according to these rules. The
transformation ensures that no input grid is identical to its output (since
direction changes and color binding alters at least one signal element), and the
rules are visually consistent without relying on numerical values or sums. The
complexity arises from the dual application of directional rotation and color
binding across multiple symmetric pairs, requiring recognition of mirror
relationships and simultaneous attribute transformation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
def generate():
    while True:
        width = random.choice(range(11, 30, 2))
        height = random.randint(10, 30)
        grid = [[0] * width for _ in range(height)]
        
        for r in range(height):
            for c in range(width // 2):
                if random.random() < 0.3:
                    color = random.randint(1, 4)
                    grid[r][c] = color
                    grid[r][width - 1 - c] = color
        
        has_signal = any(grid[r][c] != 0 for r in range(height) for c in range(width))
        if has_signal:
            break
    
    output = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if grid[r][c] in (1, 2, 3, 4):
                output[r][c] = (grid[r][c] % 4) + 1
            else:
                output[r][c] = grid[r][c]
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            color = grid[r][c]
            if 1 <= color <= 4:
                grid[r][c] = (color % 4) + 1
    return grid
