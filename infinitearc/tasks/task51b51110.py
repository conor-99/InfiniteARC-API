# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 51b51110
Difficulty: very hard

=== Tags ===
- Symbolic circuit

=== Description ===
Symbolic Circuit Completion  Input grids are 25×25 grids with a background color
(0). The grid contains a network of colored wire segments (colors 1–8) forming a
partially connected circuit. Each wire segment is a single cell of its color,
and wires of the same color form continuous paths (horizontal or vertical), but
may be interrupted by gate symbols (colors 9 for AND gates, 8 for OR gates).
Gate symbols are placed at intersections where two wire paths (one horizontal,
one vertical) meet. The circuit contains exactly one terminal point where the
path ends (a single wire segment without continuation), and a separate "output
anchor" cell at the grid's bottom edge (row 24, any column) that must connect to
this terminal.  The output grid replaces each gate symbol with a wire segment
color determined by: - For an AND gate (color 9): If both intersecting wires
share the same color, use that color; otherwise, use color 9. - For an OR gate
(color 8): If both intersecting wires share the same color, use that color;
otherwise, use color 8.  Additionally, a new wire segment of color 7 is appended
to the terminal point, extending downward to the output anchor cell. This
segment must be drawn orthogonally (horizontally or vertically) through
background cells (color 0), maintaining a width of 1 cell and matching the
terminal wire's color (not color 7) for the first segment. The appended
segment's color transitions to color 7 at the anchor cell. All existing wire
segments and gate symbols (except replaced gates) are preserved, and the
background remains unchanged. The transformation requires identifying the
terminal point, applying gate rules to all gates, and connecting the terminal to
the anchor with a color-transitioning path.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

_gen_counter = 0

def generate():
    global _gen_counter
    _gen_counter += 1
    size = 25
    G = grid(size, size, 0)

    idx = _gen_counter - 1

    main_cols = list(range(6, 19))  # 6..18 inclusive
    main_col = main_cols[idx % len(main_cols)]
    main_color = 1 + ((idx // len(main_cols)) % 6)  # 1..6
    r = 8 + ((idx // (len(main_cols)*6)) % 11)  # 8..18 inclusive

    # ensure start row leaves space for top loop
    s = min(random.randint(1,5), r-2)

    C = main_color
    col_main = main_col

    # Place main vertical from s to r
    for rr in range(s, r+1):
        G[rr][col_main] = C

    # Create a small top loop (2x2 rectangle) attached to the start row to avoid an endpoint at the top
    # cells: (s-1, col_main-2), (s-1, col_main-1), (s, col_main-1), (s, col_main-2)
    top_loop_color_choices = [c for c in range(1,7) if c != C]
    if not top_loop_color_choices:
        top_loop_color_choices = [C]
    top_color = random.choice(top_loop_color_choices)
    if col_main - 2 >= 0 and s - 1 >= 0:
        G[s-1][col_main-2] = top_color
        G[s-1][col_main-1] = top_color
        G[s][col_main-1] = top_color
        G[s][col_main-2] = top_color

    # Choose number of gates (even number so we can pair them into closed loops)
    max_g = min(4, r - s - 1)
    if max_g < 2:
        g = 2
    else:
        g = 4 if random.random() < 0.5 and max_g >= 4 else 2

    # choose gate rows between s+1 and r-1
    possible_gate_rows = list(range(s+1, r))
    if len(possible_gate_rows) < g:
        gate_rows = possible_gate_rows[:]
    else:
        gate_rows = sorted(random.sample(possible_gate_rows, k=g))

    # For each pair of gate rows create a rectangular loop to the left of the main column
    pairs = []
    avail_left = list(range(1, col_main - 2))  # ensure space between left loop and main column
    random.shuffle(avail_left)
    pair_list = [ (gate_rows[i], gate_rows[i+1]) for i in range(0, len(gate_rows), 2) ]

    used_left = []
    for pair_idx, (k1, k2) in enumerate(pair_list):
        if pair_idx >= len(avail_left):
            left_col = 1
            # try to find another unused column
            for c in range(1, col_main-2):
                if c not in used_left:
                    left_col = c
                    break
        else:
            left_col = avail_left[pair_idx]
        used_left.append(left_col)
        # choose a color different from main color
        D_choices = [c for c in range(1,7) if c != C]
        D = random.choice(D_choices)
        # horizontal wires on rows k1 and k2 from left_col to col_main-1
        for j in range(left_col, col_main):
            G[k1][j] = D
            G[k2][j] = D
        # vertical connector at left_col from k1 to k2 inclusive
        top = min(k1, k2)
        bottom = max(k1, k2)
        for rr in range(top, bottom+1):
            G[rr][left_col] = D
        pairs.append((k1, k2, left_col, D))

    # Place gates at the main column at gate rows (override the main-color cell)
    gate_rows_final = []
    for k in gate_rows:
        gate_val = random.choice([8, 9])  # 8 = OR, 9 = AND
        G[k][col_main] = gate_val
        gate_rows_final.append(k)

    # Place the output anchor at bottom row in the same column as main column, color 7
    anchor_row = size - 1
    anchor_col = col_main
    G[anchor_row][anchor_col] = 7

    # Build the output grid by copying input and applying gate rules and adding the appended wire
    Out = [row[:] for row in G]

    # Replace gates when the horizontal and vertical intersecting wires have the same color
    for k in gate_rows_final:
        i = k; j = col_main
        if Out[i][j] in (8, 9):
            # find vertical intersecting color (up or down non-gate, non-zero)
            v_color = None
            for di in (-1, 1):
                ni = i + di
                if 0 <= ni < size:
                    val = Out[ni][j]
                    if val != 0 and val not in (8, 9):
                        v_color = val
                        break
            # find horizontal intersecting color (left or right non-gate)
            h_color = None
            for dj in (-1, 1):
                nj = j + dj
                if 0 <= nj < size:
                    val = Out[i][nj]
                    if val != 0 and val not in (8, 9):
                        h_color = val
                        break
            if v_color is not None and h_color is not None and v_color == h_color:
                Out[i][j] = v_color

    # Find the terminal: a wire cell (1..6) with exactly one non-zero neighbor (count gates and anchor as non-zero)
    terminal = None
    for i in range(size):
        for j in range(size):
            val = G[i][j]
            if val == 0 or val in (7, 8, 9):
                continue
            # count non-zero neighbors
            nc = 0
            for di, dj in ((1,0), (-1,0), (0,1), (0,-1)):
                ni, nj = i + di, j + dj
                if 0 <= ni < size and 0 <= nj < size and G[ni][nj] != 0:
                    nc += 1
            if nc == 1:
                # choose the bottom-most such cell if multiple (deterministic)
                if terminal is None or i > terminal[0] or (i == terminal[0] and j > terminal[1]):
                    terminal = (i, j)

    # Fallback: pick the bottom-most non-gate wire in main column
    if terminal is None:
        for i in range(size-1, -1, -1):
            if G[i][col_main] != 0 and G[i][col_main] not in (7,8,9):
                terminal = (i, col_main)
                break

    # Append the vertical wire from terminal down to the anchor (anchor is same column)
    tr, tc = terminal
    term_color = G[tr][tc]
    for rr in range(tr+1, anchor_row):
        # only overwrite background cells
        Out[rr][tc] = term_color
    # anchor remains color 7
    Out[anchor_row][anchor_col] = 7

    return {'input': G, 'output': Out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    size = len(grid)
    # find anchor in bottom row: first cell with color 7
    anchor_row = size - 1
    anchor_col = None
    for j in range(size):
        if grid[anchor_row][j] == 7:
            anchor_col = j
            break
    if anchor_col is None:
        # fallback: choose middle column
        anchor_col = size // 2
    anchor = (anchor_row, anchor_col)

    # find terminal: wire cell (1..6) with exactly one non-zero neighbor
    terminal = None
    for i in range(size):
        for j in range(size):
            val = grid[i][j]
            if val == 0 or val in (7,8,9):
                continue
            nc = 0
            for di, dj in ((1,0), (-1,0), (0,1), (0,-1)):
                ni, nj = i + di, j + dj
                if 0 <= ni < size and 0 <= nj < size and grid[ni][nj] != 0:
                    nc += 1
            if nc == 1:
                if terminal is None or i > terminal[0] or (i == terminal[0] and j > terminal[1]):
                    terminal = (i,j)
    if terminal is None:
        # fallback bottommost non-gate wire
        for i in range(size-1, -1, -1):
            for j in range(size):
                if grid[i][j] != 0 and grid[i][j] not in (7,8,9):
                    terminal = (i,j)
                    break
            if terminal:
                break

    # start building output as copy
    Out = [row[:] for row in grid]

    # replace gates: if horizontal and vertical intersecting wires have same color, use that color
    for i in range(size):
        for j in range(size):
            if grid[i][j] in (8,9):
                # find a horizontal neighbor color (non-zero, not a gate)
                h_col = None
                for dj in (-1,1):
                    nj = j + dj
                    if 0 <= nj < size:
                        v = grid[i][nj]
                        if v != 0 and v not in (8,9):
                            h_col = v
                            break
                # find vertical neighbor color
                v_col = None
                for di in (-1,1):
                    ni = i + di
                    if 0 <= ni < size:
                        v = grid[ni][j]
                        if v != 0 and v not in (8,9):
                            v_col = v
                            break
                if h_col is not None and v_col is not None and h_col == v_col:
                    Out[i][j] = h_col

    # Append the path from terminal to anchor: prefer straight vertical down if same column
    if terminal is None:
        return Out
    tr, tc = terminal
    ar, ac = anchor
    term_color = grid[tr][tc]
    if tc == ac:
        for rr in range(tr+1, ar):
            Out[rr][tc] = term_color
        Out[ar][ac] = 7
        return Out

    # if different columns, try vertical to bottom then horizontal along bottom
    possible = True
    for rr in range(tr+1, ar):
        if grid[rr][tc] != 0:
            possible = False
            break
    if possible:
        for rr in range(tr+1, ar):
            Out[rr][tc] = term_color
        step = 1 if ac > tc else -1
        for cj in range(tc+step, ac, step):
            Out[ar][cj] = term_color
        Out[ar][ac] = 7
        return Out

    # otherwise try horizontal first along terminal's row then vertical
    possible2 = True
    step = 1 if ac > tc else -1
    for cj in range(tc+step, ac+step, step):
        if cj == ac:
            break
        if grid[tr][cj] != 0:
            possible2 = False
            break
    if possible2:
        for cj in range(tc+step, ac, step):
            Out[tr][cj] = term_color
        for rr in range(tr+1, ar):
            Out[rr][ac] = term_color
        Out[ar][ac] = 7
        return Out

    # fallback: draw vertical down in terminal column
    for rr in range(tr+1, ar):
        Out[rr][tc] = term_color
    Out[ar][ac] = 7
    return Out

