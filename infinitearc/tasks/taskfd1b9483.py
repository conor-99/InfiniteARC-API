# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: fd1b9483
Difficulty: medium

=== Tags ===
- Detect vertical symmetry
- Color by distance to edge
- Count shapes

=== Description ===
The task involves transforming an input grid into an output grid through the
following process: First, count the number of connected shapes (4-connected
regions of non-zero values) in the input grid. Next, for each cell in the output
grid, compute its distance to the nearest edge (minimum of the distances to the
top, bottom, left, or right edge of the grid). Finally, assign each cell a color
value equal to (count of shapes + distance) modulo 10. This transformation
ensures the output grid is vertically symmetric due to the distance-based
coloring, inherently satisfies the "Color by distance to edge" rule, and
incorporates the "Count shapes" metric to determine the color offset. The output
grid's dimensions match the input grid's dimensions, with all values between 0
and 9 inclusive.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def count_connected_components(grid):
    h = len(grid)
    w = len(grid[0])
    non_zero = [(r, c) for r in range(h) for c in range(w) if grid[r][c] > 0]
    if not non_zero:
        return 0
    visited = set()
    count = 0
    for pixel in non_zero:
        if pixel not in visited:
            count += 1
            queue = [pixel]
            visited.add(pixel)
            while queue:
                r, c = queue.pop(0)
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < h and 0 <= nc < w and (nr, nc) not in visited and grid[nr][nc] > 0:
                        visited.add((nr, nc))
                        queue.append((nr, nc))
    return count

def generate():
    w = random.randint(1, 30)
    h = random.randint(1, 30)
    input_grid = [[0] * w for _ in range(h)]
    for r in range(h):
        for c in range(w):
            if random.random() > 0.5:
                input_grid[r][c] = random.randint(1, 9)
    if all(input_grid[r][c] == 0 for r in range(h) for c in range(w)):
        input_grid[0][0] = random.randint(1, 9)
    N = count_connected_components(input_grid)
    output_grid = [[0] * w for _ in range(h)]
    for r in range(h):
        for c in range(w):
            d = min(r, h - 1 - r, c, w - 1 - c)
            output_grid[r][c] = (N + d) % 10
    if input_grid == output_grid:
        r, c = random.randint(0, h-1), random.randint(0, w-1)
        if input_grid[r][c] == 0:
            input_grid[r][c] = random.randint(1, 9)
        else:
            new_val = random.randint(1, 9)
            while new_val == input_grid[r][c]:
                new_val = random.randint(1, 9)
            input_grid[r][c] = new_val
        N = count_connected_components(input_grid)
        for r in range(h):
            for c in range(w):
                d = min(r, h - 1 - r, c, w - 1 - c)
                output_grid[r][c] = (N + d) % 10
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random

def count_connected_components(grid):
    h = len(grid)
    w = len(grid[0])
    non_zero = [(r, c) for r in range(h) for c in range(w) if grid[r][c] > 0]
    if not non_zero:
        return 0
    visited = set()
    count = 0
    for pixel in non_zero:
        if pixel not in visited:
            count += 1
            queue = [pixel]
            visited.add(pixel)
            while queue:
                r, c = queue.pop(0)
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < h and 0 <= nc < w and (nr, nc) not in visited and grid[nr][nc] > 0:
                        visited.add((nr, nc))
                        queue.append((nr, nc))
    return count

def p(input_grid):
    N = count_connected_components(input_grid)
    h = len(input_grid)
    w = len(input_grid[0])
    output_grid = [[0] * w for _ in range(h)]
    for r in range(h):
        for c in range(w):
            d = min(r, h - 1 - r, c, w - 1 - c)
            output_grid[r][c] = (N + d) % 10
    return output_grid
