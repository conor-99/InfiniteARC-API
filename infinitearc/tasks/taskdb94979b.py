# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: db94979b
Difficulty: mediumâ€“hard

=== Tags ===
- Rule transfer between regions
- Emergent behavior
- Temporal wave step
- Detect closed curves
- Snap objects to gridlines

=== Description ===
Input grids feature a uniform background color overlaid with multiple disjoint,
non-intersecting closed curves (each formed by a continuous loop of cells in a
single border color) that enclose distinct regions. Each enclosed region
contains a unique color not shared by any border or background. A specific
starting cell on the top edge (aligned with gridlines) initiates a wave moving
downward. The wave travels cell-by-cell along grid-aligned paths
(horizontal/vertical only), changing direction according to the region's color
at each step: red = right, blue = down, green = left, yellow = up. Upon crossing
a border into a new region, the wave immediately adopts the new region's
directional rule. Closed curves are detected as minimal 4-connected loops with
no gaps or intersections, and regions are strictly enclosed by these borders.
The wave reflects off borders (changing direction per the new region's rule)
until exiting the grid. The output grid retains all input elements but draws the
wave's path using the color of the region traversed during each step,
overwriting only background cells without interfering with borders or other
regions. The path exhibits emergent behavior through sequential rule transfers
between regions, with no loops or self-intersections.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid


def generate():
    """Generate an ARC-like pair where a wave travels through a sequence of closed rectangular borders.

    The generator places between 2 and 4 disjoint rectangular 1-cell-thick borders (loops). Each loop
    encloses an interior filled with a unique direction color (chosen from 1..4 mapped to the four
    directions). The first rectangle's top border is placed at row 1 so the wave can start at row 0
    directly above it. Regions are placed sequentially so that the wave, when following the rule of
    each region, will travel along straight grid-aligned segments and encounter the next region.

    Returns:
      A dict with keys 'input' and 'output' containing the two grids as lists of lists of ints.
    """
    # Directions mapping per task description:
    # red=2 -> right (0,1)
    # blue=1 -> down (1,0)
    # green=3 -> left (0,-1)
    # yellow=4 -> up (-1,0)
    direction_map = {2: (0, 1), 1: (1, 0), 3: (0, -1), 4: (-1, 0)}

    # Attempt generation until a valid configuration is built (few retries are cheap)
    for attempt in range(200):
        width = random.randint(12, 20)
        height = random.randint(12, 20)
        bg = 0
        # Use a border color that's distinct from the four direction colors
        border_color = random.choice([6, 7, 8, 9])

        candidate_colors = [2, 1, 3, 4]
        n_regions = random.randint(2, 4)
        colors = random.sample(candidate_colors, n_regions)

        boxes = []  # list of (r0, c0, r1, c1, color)

        def overlaps(proposed, existing_boxes, margin=1):
            r0, c0, r1, c1 = proposed
            for (er0, ec0, er1, ec1, _) in existing_boxes:
                # expand both by margin and check overlap
                if r0 - margin <= er1 + margin and r1 + margin >= er0 - margin and c0 - margin <= ec1 + margin and c1 + margin >= ec0 - margin:
                    return True
            return False

        # Place the first region so that its top border is at row 1 (so start on row 0 above it)
        try:
            w0 = random.randint(3, min(8, width - 4))
            h0 = random.randint(3, min(8, height - 4))
            r0 = 1
            c0 = random.randint(1, width - w0 - 2)
            r1 = r0 + h0 - 1
            c1 = c0 + w0 - 1
            boxes.append((r0, c0, r1, c1, colors[0]))
        except Exception:
            continue

        # starting column is somewhere along the top interior of the first box
        start_col = random.randint(c0 + 1, c1 - 1)
        # entry point inside first region (the cell the wave first steps into inside the region)
        entry = (r0 + 1, start_col)

        good = True
        # Place subsequent regions so that they lie along the ray determined by the previous region's color
        for i in range(1, n_regions):
            prev_box = boxes[-1]
            prev_entry = entry
            color_prev = boxes[-1][4]
            d = direction_map[color_prev]

            placed = False
            # Try a number of attempts to place the next box in that direction
            for _ in range(200):
                w = random.randint(3, min(8, width - 4))
                h = random.randint(3, min(8, height - 4))
                gap = random.randint(1, 3)

                if d == (0, 1):  # right
                    # the cell just outside the previous box on that row
                    row = prev_entry[0]
                    col_out = prev_box[3] + 1
                    c0_new = col_out + gap
                    c1_new = c0_new + w - 1
                    if c1_new >= width - 1:
                        continue
                    r0_min = max(1, row - (h - 1))
                    r0_max = min(row, height - h - 1)
                    if r0_min > r0_max:
                        continue
                    r0_new = random.randint(r0_min, r0_max)
                    r1_new = r0_new + h - 1
                    new_box = (r0_new, c0_new, r1_new, c1_new)
                    if overlaps(new_box, boxes):
                        continue
                    # ensure the row intersects the vertical span
                    if not (r0_new <= row <= r1_new):
                        continue
                    entry = (row, c0_new + 1)
                    boxes.append((r0_new, c0_new, r1_new, c1_new, colors[i]))
                    placed = True
                    break

                if d == (0, -1):  # left
                    row = prev_entry[0]
                    col_out = prev_box[1] - 1
                    c1_new = col_out - gap
                    c0_new = c1_new - w + 1
                    if c0_new <= 0:
                        continue
                    r0_min = max(1, row - (h - 1))
                    r0_max = min(row, height - h - 1)
                    if r0_min > r0_max:
                        continue
                    r0_new = random.randint(r0_min, r0_max)
                    r1_new = r0_new + h - 1
                    new_box = (r0_new, c0_new, r1_new, c1_new)
                    if overlaps(new_box, boxes):
                        continue
                    if not (r0_new <= row <= r1_new):
                        continue
                    entry = (row, c1_new - 1)
                    boxes.append((r0_new, c0_new, r1_new, c1_new, colors[i]))
                    placed = True
                    break

                if d == (1, 0):  # down
                    col = prev_entry[1]
                    row_out = prev_box[2] + 1
                    r0_new = row_out + gap
                    r1_new = r0_new + h - 1
                    if r1_new >= height - 1:
                        continue
                    c0_min = max(1, col - (w - 1))
                    c0_max = min(col, width - w - 1)
                    if c0_min > c0_max:
                        continue
                    c0_new = random.randint(c0_min, c0_max)
                    c1_new = c0_new + w - 1
                    new_box = (r0_new, c0_new, r1_new, c1_new)
                    if overlaps(new_box, boxes):
                        continue
                    if not (c0_new <= col <= c1_new):
                        continue
                    entry = (r0_new + 1, col)
                    boxes.append((r0_new, c0_new, r1_new, c1_new, colors[i]))
                    placed = True
                    break

                if d == (-1, 0):  # up
                    col = prev_entry[1]
                    row_out = prev_box[0] - 1
                    r1_new = row_out - gap
                    r0_new = r1_new - h + 1
                    if r0_new <= 0:
                        continue
                    c0_min = max(1, col - (w - 1))
                    c0_max = min(col, width - w - 1)
                    if c0_min > c0_max:
                        continue
                    c0_new = random.randint(c0_min, c0_max)
                    c1_new = c0_new + w - 1
                    new_box = (r0_new, c0_new, r1_new, c1_new)
                    if overlaps(new_box, boxes):
                        continue
                    if not (c0_new <= col <= c1_new):
                        continue
                    entry = (r1_new - 1, col)
                    boxes.append((r0_new, c0_new, r1_new, c1_new, colors[i]))
                    placed = True
                    break

            if not placed:
                good = False
                break

        if not good:
            continue

        # Build input grid
        input_grid = grid(width, height, bg)
        for (r0, c0, r1, c1, col) in boxes:
            # draw border
            for c in range(c0, c1 + 1):
                input_grid[r0][c] = border_color
                input_grid[r1][c] = border_color
            for r in range(r0, r1 + 1):
                input_grid[r][c0] = border_color
                input_grid[r][c1] = border_color
            # fill interior
            for r in range(r0 + 1, r1):
                for c in range(c0 + 1, c1):
                    input_grid[r][c] = col

        # Simulate the wave to create the output
        # starting at top row above first region
        out_grid = [row[:] for row in input_grid]

        # Find start_col (column in top row directly above a border cell at row 1)
        start_col_found = None
        for c in range(width):
            if input_grid[0][c] == bg and input_grid[1][c] == border_color:
                start_col_found = c
                break
        if start_col_found is None:
            # Should not happen but just in case
            continue

        pos = (0, start_col_found)
        direction = (1, 0)  # initially down
        current_color = None
        path_steps = []  # list of (r, c, color)

        # run until exit
        steps_limit = width * height * 10
        steps = 0
        while True:
            steps += 1
            if steps > steps_limit:
                good = False
                break
            nr = pos[0] + direction[0]
            nc = pos[1] + direction[1]
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                break
            val = input_grid[nr][nc]
            # Border cell
            if val == border_color:
                pos = (nr, nc)
                # stepping onto border does not change current_color until we step into interior
                continue
            # Entering a region interior
            if val in colors:
                pos = (nr, nc)
                current_color = val
                direction = direction_map[current_color]
                continue
            # Background
            if val == bg:
                if current_color is not None:
                    # paint this background cell with the active region's color
                    path_steps.append((nr, nc, current_color))
                pos = (nr, nc)
                continue
            # Any other value, just move
            pos = (nr, nc)

        if not good:
            continue

        # Apply path paints to output grid (only overwrite backgrounds)
        for (r, c, col) in path_steps:
            if out_grid[r][c] == bg:
                out_grid[r][c] = col

        # Sanity: ensure input != output
        if input_grid == out_grid:
            # reject trivial
            continue

        return {'input': input_grid, 'output': out_grid}

    # If all attempts fail, produce a simple fallback (shouldn't be reached normally)
    w, h = 12, 12
    input_grid = grid(w, h, 0)
    output_grid = [row[:] for row in input_grid]
    return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input into mutable list-of-lists
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])
    bg = 0

    # Map from color to direction as per task description
    def get_direction(c):
        if c == 2:  # red -> right
            return (0, 1)
        if c == 1:  # blue -> down
            return (1, 0)
        if c == 3:  # green -> left
            return (0, -1)
        if c == 4:  # yellow -> up
            return (-1, 0)
        return (0, 1)

    # Detect border color by finding a color whose cells frequently touch both background and another non-equal color
    color_candidates = set()
    for r in range(height):
        for c in range(width):
            val = grid_in[r][c]
            if val != bg:
                color_candidates.add(val)
    # For each candidate color count how many of its cells have at least one neighbor==bg and at least one neighbor!=bg and !=self
    def neighbors(r, c):
        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
            rr, cc = r + dr, c + dc
            if 0 <= rr < height and 0 <= cc < width:
                yield grid_in[rr][cc]

    border_scores = {}
    for col in color_candidates:
        score = 0
        for r in range(height):
            for c in range(width):
                if grid_in[r][c] != col:
                    continue
                has_bg = False
                has_other = False
                for nb in neighbors(r, c):
                    if nb == bg:
                        has_bg = True
                    if nb != bg and nb != col:
                        has_other = True
                if has_bg and has_other:
                    score += 1
        border_scores[col] = score

    # Choose border color as the one with largest score (if all zero, pick a color not equal to bg that appears most)
    border_color = None
    if border_scores:
        border_color = max(border_scores.keys(), key=lambda k: border_scores[k])
        if border_scores[border_color] == 0:
            # fallback: choose the most frequent non-background color
            freq = {}
            for r in range(height):
                for c in range(width):
                    v = grid_in[r][c]
                    if v == bg:
                        continue
                    freq[v] = freq.get(v, 0) + 1
            if freq:
                border_color = max(freq.keys(), key=lambda k: freq[k])
    else:
        border_color = None

    # Determine region colors (non-bg, non-border)
    region_colors = set()
    for r in range(height):
        for c in range(width):
            v = grid_in[r][c]
            if v != bg and v != border_color:
                region_colors.add(v)
    region_colors = set(region_colors)

    # Find starting column on top edge: top row position where below is a border cell
    start_col = None
    if height >= 2:
        for c in range(width):
            if grid_in[0][c] == bg and grid_in[1][c] == border_color:
                start_col = c
                break
    if start_col is None:
        # fallback: find any column where row1 is border
        for c in range(width):
            if grid_in[1][c] == border_color:
                start_col = c
                break
    if start_col is None:
        # nothing to do
        return grid_in

    # Simulate wave
    pos = (0, start_col)
    direction = (1, 0)  # initial downward
    out = [row[:] for row in grid_in]
    current_color = None

    steps_limit = width * height * 10
    steps = 0
    while True:
        steps += 1
        if steps > steps_limit:
            break
        nr = pos[0] + direction[0]
        nc = pos[1] + direction[1]
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        val = grid_in[nr][nc]
        # If border cell: step onto it but do not paint; color remains until entering a region
        if val == border_color:
            pos = (nr, nc)
            continue
        # If region interior: adopt its direction/color
        if val in region_colors:
            current_color = val
            direction = get_direction(current_color)
            pos = (nr, nc)
            continue
        # Background: paint with current_color if we have one, otherwise leave
        if val == bg:
            if current_color is not None and out[nr][nc] == bg:
                out[nr][nc] = current_color
            pos = (nr, nc)
            continue
        # Other: just move
        pos = (nr, nc)

    return out

