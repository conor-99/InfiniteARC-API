# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: def6d6e1
Difficulty: insane

=== Tags ===
- Contouring
- Paint on collision

=== Description ===
Input grids feature a background of a single color overlaid with multiple
distinct, contiguous colored regions (each region is a connected group of cells
of the same non-background color). These regions may be adjacent (sharing an
edge) or separated by background cells. The output grid constructs a contour
line around each region, defined as the immediate background cells surrounding
the region. Contour cells adjacent to only one region are painted with a default
contour color (e.g., gray), while contour cells between two adjacent regions are
painted with a color determined by a specific color-mapping rule based on the
colliding regions' colors (e.g., red + blue â†’ purple). In cases where three or
more regions meet at a single cell, the collision color follows a predefined
combinatorial rule derived from the combined region colors. The transformation
requires precise region identification, adjacency detection, and application of
the collision color mapping without altering the original regions or background,
making it exceptionally challenging due to the need to infer the color-mapping
pattern from sparse examples and handle complex multi-region collision
scenarios.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common


def generate():
    """Generate an input/output pair for the contouring + paint-on-collision task.

    Rules used by the generator (and mirrored by the solver):
    - Background color is 0. Regions are contiguous groups of cells with a color in 1..9.
    - For each background cell that is adjacent (4-neighbors) to region cells:
      * If it touches exactly one unique region color -> paint it with color 5 (default contour).
      * If it touches two or more distinct region colors -> paint it with collision color
        computed as (sum_of_unique_adjacent_colors % 9) + 1  (yields 1..9).
    - Original regions and background are not altered.

    The generator creates 2..5 contiguous regions, sometimes forcing a 3-way junction so that
    some background cells touch 3 different regions. Regions are grown from seeds while
    avoiding overwriting reserved seeds for other regions.
    """
    # Grid size
    width = random.randint(5, 20)
    height = random.randint(5, 20)
    grid_input = [[0 for _ in range(width)] for _ in range(height)]

    # Number of regions and colors
    num_regions = random.randint(2, 5)
    region_colors = random.sample(list(range(1, 10)), num_regions)

    # Prepare seeds for all regions. We'll optionally force a 3-way junction.
    seeds = []  # list of (color, (r,c))

    # Helper to find a free cell
    def find_free_cell(avoid_set=None, attempts=300):
        if avoid_set is None:
            avoid_set = set()
        for _ in range(attempts):
            r = random.randint(0, height - 1)
            c = random.randint(0, width - 1)
            if (r, c) in avoid_set: continue
            if grid_input[r][c] == 0:
                return (r, c)
        # fallback: scan
        for r in range(height):
            for c in range(width):
                if (r, c) in avoid_set: continue
                if grid_input[r][c] == 0:
                    return (r, c)
        return None

    # Optionally create a 3-way junction (makes 3+ collision cells)
    do_junction = (num_regions >= 3 and random.random() < 0.45)
    if do_junction:
        # try to find a center cell with at least 3 available 4-neighbors
        attempts = 0
        found = False
        while attempts < 300 and not found:
            attempts += 1
            r = random.randint(1, height - 2)
            c = random.randint(1, width - 2)
            neighbors = [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]
            free = [p for p in neighbors if grid_input[p[0]][p[1]] == 0]
            if len(free) >= 3:
                chosen = random.sample(free, 3)
                # assign seeds for first three region colors
                for i in range(3):
                    seeds.append((region_colors[i], chosen[i]))
                found = True
        if not found:
            do_junction = False

    # Fill remaining seeds
    for idx in range(len(seeds), num_regions):
        color = region_colors[idx]
        # 60% chance to place a seed next to an existing seed/region to encourage adjacency
        if seeds and random.random() < 0.6:
            placed = False
            seed_positions = [pos for (_col, pos) in seeds]
            random.shuffle(seed_positions)
            for base in seed_positions:
                br, bc = base
                nbrs = [(br + 1, bc), (br - 1, bc), (br, bc + 1), (br, bc - 1)]
                random.shuffle(nbrs)
                for nr, nc in nbrs:
                    if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in [p for (_c, p) in seeds]:
                        seeds.append((color, (nr, nc)))
                        placed = True
                        break
                if placed:
                    break
            if not placed:
                free = find_free_cell(avoid_set=set(p for (_c, p) in seeds))
                if free is None:
                    # highly congested, pick any cell
                    free = (random.randint(0, height - 1), random.randint(0, width - 1))
                seeds.append((color, free))
        else:
            free = find_free_cell(avoid_set=set(p for (_c, p) in seeds))
            if free is None:
                free = (random.randint(0, height - 1), random.randint(0, width - 1))
            seeds.append((color, free))

    # Reserve all seed positions so earlier-grown regions do not overwrite them
    reserved = set(p for (_c, p) in seeds)

    # Grow each seed into a contiguous region
    for i, (color, seed_pos) in enumerate(seeds):
        sr, sc = seed_pos
        # target size depends on grid, but at least 2
        max_area = max(3, min(12, (width * height) // 4))
        target_size = random.randint(2, max_area)
        region_cells = set()
        region_cells.add((sr, sc))
        frontier = [(sr, sc)]
        # Prevent other region seeds from being consumed
        reserved_other = reserved.copy()
        if (sr, sc) in reserved_other:
            reserved_other.remove((sr, sc))
        attempts = 0
        while len(region_cells) < target_size and frontier and attempts < width * height * 5:
            attempts += 1
            # pick a random cell from frontier
            pr, pc = random.choice(frontier)
            nbrs = [(pr + 1, pc), (pr - 1, pc), (pr, pc + 1), (pr, pc - 1)]
            random.shuffle(nbrs)
            added = False
            for nr, nc in nbrs:
                if 0 <= nr < height and 0 <= nc < width:
                    if grid_input[nr][nc] != 0:
                        continue
                    if (nr, nc) in reserved_other:
                        continue
                    if (nr, nc) in region_cells:
                        continue
                    # add to this region
                    region_cells.add((nr, nc))
                    frontier.append((nr, nc))
                    added = True
                    break
            if not added:
                # if this frontier cell cannot expand, remove it from consideration
                try:
                    frontier.remove((pr, pc))
                except ValueError:
                    pass
        # commit region to grid_input
        for (r, c) in region_cells:
            grid_input[r][c] = color
        # remove this seed from reserved so later regions may expand into its neighborhood
        if (sr, sc) in reserved:
            reserved.remove((sr, sc))

    # Build output grid according to the contour and collision rules
    grid_output = [row[:] for row in grid_input]
    for r in range(height):
        for c in range(width):
            if grid_input[r][c] != 0:
                continue
            adj_colors = set()
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid_input[nr][nc] != 0:
                    adj_colors.add(grid_input[nr][nc])
            if len(adj_colors) == 0:
                continue
            if len(adj_colors) == 1:
                # single-region contour
                grid_output[r][c] = 5
            else:
                # collision color for two-or-more regions (deterministic, in 1..9)
                grid_output[r][c] = (sum(adj_colors) % 9) + 1

    # Ensure output differs from input (very unlikely to be identical, but safe-guard)
    if grid_input == grid_output:
        placed = False
        for r in range(height):
            for c in range(width):
                if grid_output[r][c] == 0:
                    grid_output[r][c] = 5
                    placed = True
                    break
            if placed:
                break

    return {"input": grid_input, "output": grid_output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input (tuple of tuples) to mutable list of lists
    in_grid = [list(row) for row in input_grid]
    height = len(in_grid)
    width = len(in_grid[0]) if height > 0 else 0
    out_grid = [row[:] for row in in_grid]

    for r in range(height):
        for c in range(width):
            if in_grid[r][c] != 0:
                continue
            adj_colors = set()
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and in_grid[nr][nc] != 0:
                    adj_colors.add(in_grid[nr][nc])
            if len(adj_colors) == 0:
                continue
            if len(adj_colors) == 1:
                out_grid[r][c] = 5
            else:
                out_grid[r][c] = (sum(adj_colors) % 9) + 1

    return out_grid

