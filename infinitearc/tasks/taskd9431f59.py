# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: d9431f59
Difficulty: hard

=== Tags ===
- Mirror pair coordination
- Deterministic reflection
- Even or odd

=== Description ===
The task involves input grids containing a central axis (vertical or horizontal)
with colored cells arranged on one side. The key visual cue determining the
reflection direction is whether the cells on the specified side form adjacent
pairs (indicating even arrangement) or a single isolated cell (indicating odd
arrangement). For even arrangements (paired cells), the entire grid is reflected
horizontally across the central axis. For odd arrangements (single cell), the
grid is reflected vertically across the central axis. The output grid preserves
all original colors and background, adding mirrored cells only in background
positions. The central axis must be visually identified from the input grid's
structure (e.g., a clear gap or pattern alignment), and the reflection direction
is determined solely by the visual pairing of cells without numerical counting.
This requires recognizing spatial patterns and applying a context-dependent
reflection rule, making it challenging due to the need to simultaneously
interpret axis placement, pairing configuration, and directional transformation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Choose odd dimensions between 5 and 29 inclusive so there is a clear central axis
    dim_choices = list(range(5, 30, 2))  # 5,7,...,29
    width = random.choice(dim_choices)
    height = random.choice(dim_choices)

    grid_in = [[0 for _ in range(width)] for _ in range(height)]

    # Decide arrangement: even -> adjacent horizontal pairs on the left and a vertical central axis.
    # odd -> single isolated pixel above a horizontal central axis.
    even = random.choice([True, False])

    if even:
        axis_col = width // 2
        # Place between 1 and min(4, height) non-overlapping horizontal pairs strictly to the left of the axis
        max_pairs = min(4, height)
        pairs = random.randint(1, max_pairs)
        occupied = set()
        attempts = 0
        placed = 0
        while placed < pairs and attempts < pairs * 20:
            attempts += 1
            r = random.randrange(0, height)
            # start so that pair (c, c+1) is strictly to the left of the axis
            max_start = axis_col - 2
            if max_start < 0:
                continue
            c = random.randint(0, max_start)
            if (r, c) in occupied or (r, c + 1) in occupied:
                continue
            color = random.randint(1, 9)
            grid_in[r][c] = color
            grid_in[r][c + 1] = color
            occupied.add((r, c))
            occupied.add((r, c + 1))
            placed += 1

        # Mirror across the central column into background positions only
        grid_out = [row[:] for row in grid_in]
        for r in range(height):
            for c in range(width):
                if c == axis_col:
                    continue
                val = grid_in[r][c]
                if val == 0:
                    continue
                mirror_c = 2 * axis_col - c
                if 0 <= mirror_c < width and grid_out[r][mirror_c] == 0:
                    grid_out[r][mirror_c] = val

        return {"input": grid_in, "output": grid_out}

    else:
        axis_row = height // 2
        # Place exactly one isolated pixel strictly above the axis
        r = random.randint(0, axis_row - 1)
        c = random.randint(0, width - 1)
        color = random.randint(1, 9)
        grid_in[r][c] = color

        grid_out = [row[:] for row in grid_in]
        for rr in range(height):
            for cc in range(width):
                if rr == axis_row:
                    continue
                val = grid_in[rr][cc]
                if val == 0:
                    continue
                mirror_r = 2 * axis_row - rr
                if 0 <= mirror_r < height and grid_out[mirror_r][cc] == 0:
                    grid_out[mirror_r][cc] = val

        return {"input": grid_in, "output": grid_out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])

    central_col = width // 2
    central_row = height // 2

    def is_all_zero_col(c):
        return all(grid_in[r][c] == 0 for r in range(height))

    def is_all_zero_row(r):
        return all(grid_in[r][c] == 0 for c in range(width))

    def has_left_horizontal_pair():
        # Check for a horizontal adjacent pair strictly to the left of the central column
        for r in range(height):
            # range up to central_col-1 so we can check c and c+1 where c+1 < central_col
            for c in range(0, max(0, central_col - 1)):
                if grid_in[r][c] != 0 and grid_in[r][c + 1] == grid_in[r][c]:
                    return True
        return False

    vertical_candidate = is_all_zero_col(central_col)
    horizontal_candidate = is_all_zero_row(central_row)

    use_vertical = False
    use_horizontal = False

    # Decide axis and reflection direction primarily by the visual pairing cue.
    if vertical_candidate and has_left_horizontal_pair():
        use_vertical = True
    elif horizontal_candidate:
        # If there is any nonzero pixel above the horizontal axis, choose horizontal reflection
        has_above = any(grid_in[r][c] != 0 for r in range(0, central_row) for c in range(width))
        if has_above:
            use_horizontal = True
    elif vertical_candidate:
        # Fallback: if vertical axis exists and no other cue, use vertical
        use_vertical = True

    grid_out = [row[:] for row in grid_in]

    if use_vertical:
        for r in range(height):
            for c in range(width):
                if c == central_col:
                    continue
                val = grid_in[r][c]
                if val == 0:
                    continue
                mirror_c = 2 * central_col - c
                if 0 <= mirror_c < width and grid_out[r][mirror_c] == 0:
                    grid_out[r][mirror_c] = val
        return grid_out

    if use_horizontal:
        for r in range(height):
            for c in range(width):
                if r == central_row:
                    continue
                val = grid_in[r][c]
                if val == 0:
                    continue
                mirror_r = 2 * central_row - r
                if 0 <= mirror_r < height and grid_out[mirror_r][c] == 0:
                    grid_out[mirror_r][c] = val
        return grid_out

    # If no axis detected, return the input unchanged
    return grid_in

