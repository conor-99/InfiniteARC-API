# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 9a92afe3
Difficulty: hard

=== Tags ===
- Analogical mapping between pairs
- Border detection

=== Description ===
Input grids feature multiple distinct, non-overlapping regions, each defined by
a continuous border of uniform thickness (1-3 cells) and a unique visual pattern
(e.g., solid, dotted, or alternating segment patterns). The borders are detected
by identifying the outermost connected cells of each region, ignoring internal
patterns. The visual pattern of each border's structure follows a consistent
transformation sequence between consecutive regions: for example, the border
pattern of Region B is a 90-degree rotation of Region A's border, and Region C's
border is a 90-degree rotation of Region B's. The output grid must generate a
new region whose border pattern continues this transformation sequence, placed
in a designated location (e.g., bottom-right corner), while preserving all
existing regions and borders exactly as in the input. The transformation rule
must be deduced from the relationship between the existing border patterns,
requiring the solver to recognize both the border structure and the sequential
visual transformation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def apply_frame_pattern(grid, top, left, size, edge_index, pattern):
    if edge_index == 0:  # top
        for c in range(left, left + size):
            grid[top][c] = pattern[(c - left) % len(pattern)]
    elif edge_index == 1:  # right
        for r in range(top, top + size):
            grid[r][left + size - 1] = pattern[(r - top) % len(pattern)]
    elif edge_index == 2:  # bottom
        for c in range(left + size - 1, left - 1, -1):
            grid[top + size - 1][c] = pattern[(left + size - 1 - c) % len(pattern)]
    elif edge_index == 3:  # left
        for r in range(top + size - 1, top - 1, -1):
            grid[r][left] = pattern[(top + size - 1 - r) % len(pattern)]

def generate():
    N = random.randint(15, 30)
    grid = [[0] * N for _ in range(N)]
    pattern = random.choices([1,2,3,4,5], k=random.randint(2,4))
    for i in range(3):
        top = 2 * i
        left = 2 * i
        size = N - 4 * i
        if size < 3:
            size = 3
        edge_index = i % 4
        apply_frame_pattern(grid, top, left, size, edge_index, pattern)
    output = [row[:] for row in grid]
    top = 2 * 3
    left = 2 * 3
    size = N - 4 * 3
    if size < 3:
        size = 3
    edge_index = 3
    apply_frame_pattern(output, top, left, size, edge_index, pattern)
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    top_row = grid[0]
    pattern = None
    for length in range(2, 5):
        if all(top_row[i] == top_row[i % length] for i in range(len(top_row))):
            pattern = top_row[:length]
            break
    if pattern is None:
        pattern = top_row[:2]
    N = len(grid)
    top = 6
    left = 6
    size = N - 12
    if size < 3:
        size = 3
    for r in range(top + size - 1, top - 1, -1):
        grid[r][left] = pattern[(top + size - 1 - r) % len(pattern)]
    return tuple(tuple(row) for row in grid)
