# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 0e0c4710
Difficulty: very hard

=== Tags ===
- Procedural painting
- Symbolic color algebra
- Count hor lines

=== Description ===
Input grids are medium to large (20×20 or larger) with a single background color
(e.g., 0). Overlaid on this background are horizontal line segments—each
consisting of one or more contiguous cells in a single row, sharing a non-
background color (1-9), with no vertical adjacency between segments of the same
color. Segments may overlap horizontally with background cells but not with
other segments of the same color.  The transformation process follows these
steps: 1. **Count horizontal segments**: For each color C (1-9), count the
number of disjoint horizontal segments of color C in the input grid. This count
is denoted N_C. 2. **Symbolic color mapping**: For each color C, identify all
colors D where N_D equals N_C. If multiple colors share the same count, select
the smallest color D (numerically) as the target color for C. If no other color
shares the count, C maps to itself. 3. **Segment transformation**: Replace every
horizontal segment of color C in the input with segments of the target color
determined in step 2. Existing background cells remain unchanged. 4.
**Procedural painting**: At the top row (row 0), draw a new horizontal segment
for each color C that had at least one segment in the input. The length of each
segment equals N_C (drawn on background cells only), and its color matches the
target color from step 2. Segments are placed sequentially from left to right,
with no overlap.  The output grid retains all original horizontal segments (now
transformed) and adds new top-row segments based on the symbolic color algebra
derived from segment counts. No segments overwrite background cells beyond the
new top-row additions, and the transformation is fully deterministic and
reversible through the described rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    # Grid size: medium to large as specified
    width = random.randint(20, 30)
    height = random.randint(20, 30)
    grid_input = common.grid(width, height, 0)

    # Pick a subset of colors to use (3-5 distinct colors)
    colors = random.sample(list(range(1, 10)), random.randint(3, 5))

    # For each chosen color decide how many horizontal segments it will have (intended)
    intended_counts = {c: random.randint(1, 3) for c in colors}

    # Helper to choose rows for a color ensuring no two rows are the same
    # and avoiding vertical adjacency between segments of the same color when possible
    def pick_rows_for_color(n):
        possible = list(range(1, height))  # avoid top row (0) so new segments go to output only
        random.shuffle(possible)
        chosen = []
        for r in possible:
            # avoid choosing a row adjacent to any already chosen row for this color
            if any(abs(r - x) <= 1 for x in chosen):
                continue
            chosen.append(r)
            if len(chosen) == n:
                break
        # If we didn't find enough non-adjacent rows (very unlikely given sizes), fill remaining
        if len(chosen) < n:
            for r in possible:
                if r in chosen:
                    continue
                chosen.append(r)
                if len(chosen) == n:
                    break
        return chosen

    # Place horizontal segments for each color (may overwrite earlier colors)
    for c in colors:
        n = intended_counts[c]
        rows = pick_rows_for_color(n)
        for r in rows:
            # length between 1 and a modest fraction of the width to create varied segments
            length = random.randint(1, max(1, min(6, width // 3)))
            start_col = random.randint(0, width - length)
            for col in range(start_col, start_col + length):
                grid_input[r][col] = c

    # Now compute the actual horizontal-segment counts from the produced input grid
    observed_counts = {c: 0 for c in range(1, 10)}
    for c in range(1, 10):
        for r in range(height):
            x = 0
            while x < width:
                if grid_input[r][x] == c:
                    observed_counts[c] += 1
                    while x < width and grid_input[r][x] == c:
                        x += 1
                else:
                    x += 1

    # Build mapping from observed counts to smallest color among those that share the count
    count_to_colors = {}
    for c in range(1, 10):
        cnt = observed_counts[c]
        if cnt > 0:
            count_to_colors.setdefault(cnt, []).append(c)
    mapping = {}
    for cnt, cls in count_to_colors.items():
        cls_sorted = sorted(cls)
        smallest = cls_sorted[0]
        for cc in cls:
            mapping[cc] = smallest

    # Create output by applying the mapping to every non-background cell
    grid_output = [row[:] for row in grid_input]
    for r in range(height):
        for col in range(width):
            val = grid_output[r][col]
            if val != 0:
                grid_output[r][col] = mapping.get(val, val)

    # Procedural painting on top row (row 0): one segment for each color that actually appeared
    segments_info = []  # (target_color, original_color, length)
    for orig in range(1, 10):
        cnt = observed_counts[orig]
        if cnt > 0:
            segments_info.append((mapping[orig], orig, cnt))
    # Sort deterministically by target color then by original color so solver can reproduce
    segments_info.sort(key=lambda x: (x[0], x[1]))

    current_col = 0
    for target_color, orig_color, length in segments_info:
        if current_col >= width:
            break
        end_col = min(width, current_col + length)
        for col in range(current_col, end_col):
            # only paint on background cells (top row is background in our generator)
            if grid_output[0][col] == 0:
                grid_output[0][col] = target_color
        current_col = end_col

    return {
        'input': grid_input,
        'output': grid_output
    }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    # Convert to mutable list of lists
    grid_input = [list(row) for row in input_grid]
    height = len(grid_input)
    width = len(grid_input[0]) if height > 0 else 0

    # Count horizontal segments for each color 1-9
    segment_counts = {c: 0 for c in range(1, 10)}
    for c in range(1, 10):
        for r in range(height):
            x = 0
            while x < width:
                if grid_input[r][x] == c:
                    segment_counts[c] += 1
                    # skip this contiguous run
                    while x < width and grid_input[r][x] == c:
                        x += 1
                else:
                    x += 1

    # Build groups of colors by count (only colors that appear at least once)
    count_to_colors = {}
    for c in range(1, 10):
        cnt = segment_counts[c]
        if cnt > 0:
            count_to_colors.setdefault(cnt, []).append(c)

    # For each group, pick the smallest color as the target and map all members to it
    mapping = {}
    for cnt, cls in count_to_colors.items():
        cls_sorted = sorted(cls)
        smallest = cls_sorted[0]
        for cc in cls:
            mapping[cc] = smallest

    # Apply mapping to all non-background cells
    grid_output = [row[:] for row in grid_input]
    for r in range(height):
        for col in range(width):
            v = grid_output[r][col]
            if v != 0:
                grid_output[r][col] = mapping.get(v, v)

    # Now paint the top-row segments: one per original color that appeared, length = count
    colors_with_segments = [c for c in range(1, 10) if segment_counts[c] > 0]
    # Deterministic ordering: by target color then by original color
    colors_with_segments.sort(key=lambda c: (mapping[c], c))

    current_col = 0
    for orig in colors_with_segments:
        length = segment_counts[orig]
        target = mapping[orig]
        if current_col >= width:
            break
        end_col = min(width, current_col + length)
        for col in range(current_col, end_col):
            # only paint on background cells (top row in valid inputs is background)
            if grid_output[0][col] == 0:
                grid_output[0][col] = target
        current_col = end_col

    return tuple(tuple(row) for row in grid_output)

