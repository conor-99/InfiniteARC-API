# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: b23ef2ac
Difficulty: medium–hard

=== Tags ===
- Embedded rule repetition
- Surface unfolding
- Tiled majority vote
- Select every nth column

=== Description ===
The input grids are composed of a repeating 2×2 tile structure, with each tile
containing a unique 2×2 arrangement of colors (0–9, where 0 represents
background). The output grid is generated through two sequential
transformations: (1) each tile is replaced by its majority color (the most
frequent non-background color within the tile, with ties resolved by selecting
the highest numerical color value), forming a smaller grid; (2) from this
smaller grid, every nth column is retained, where n is determined by the
numerical value of the majority color in the top-left tile of the input grid.
For instance, if the top-left tile’s majority color is 5, columns 0, 5, 10,
etc., are preserved while all other columns are removed. This process "unfolds"
the tiled structure by first compressing it via majority voting and then
selectively reducing its width through embedded rule repetition, where the
column selection interval is dynamically derived from the input’s own top-left
tile. The resulting output grid visually reveals a hierarchical compression of
the input’s repeating pattern, requiring recognition of both the tiled structure
and the embedded dependency between the top-left tile and the final column
selection.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = 2 * random.randint(1, 15)
    height = 2 * random.randint(1, 15)
    input_grid = [[0] * width for _ in range(height)]
    
    for i in range(0, height, 2):
        for j in range(0, width, 2):
            tile = []
            for r in range(2):
                row = []
                for c in range(2):
                    if i == 0 and j == 0:
                        color = random.randint(0, 9)
                        while color == 0 and (len(tile) == 0 or all(x == 0 for x in [p for row in tile for p in row])):
                            color = random.randint(0, 9)
                        row.append(color)
                    else:
                        row.append(random.randint(0, 9))
                tile.append(row)
            for r in range(2):
                for c in range(2):
                    input_grid[i + r][j + c] = tile[r][c]
    
    top_left = [
        input_grid[0][0],
        input_grid[0][1],
        input_grid[1][0],
        input_grid[1][1]
    ]
    non_zero = [x for x in top_left if x != 0]
    if non_zero:
        count = {}
        for x in non_zero:
            count[x] = count.get(x, 0) + 1
        n = max(non_zero, key=lambda x: (count[x], x))
    else:
        n = 1
    
    compressed_width = width // 2
    compressed_height = height // 2
    compressed = [[0] * compressed_width for _ in range(compressed_height)]
    
    for i in range(compressed_height):
        for j in range(compressed_width):
            tile = [
                input_grid[2*i][2*j],
                input_grid[2*i][2*j+1],
                input_grid[2*i+1][2*j],
                input_grid[2*i+1][2*j+1]
            ]
            non_zero = [x for x in tile if x != 0]
            if non_zero:
                count = {}
                for x in non_zero:
                    count[x] = count.get(x, 0) + 1
                majority = max(non_zero, key=lambda x: (count[x], x))
            else:
                majority = 1
            compressed[i][j] = majority
    
    output_columns = [j for j in range(compressed_width) if j % n == 0]
    output_grid = []
    for i in range(compressed_height):
        output_grid.append([compressed[i][j] for j in output_columns])
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    height = len(input_list)
    width = len(input_list[0])
    
    top_left = [
        input_list[0][0],
        input_list[0][1],
        input_list[1][0],
        input_list[1][1]
    ]
    non_zero = [x for x in top_left if x != 0]
    if non_zero:
        count = {}
        for x in non_zero:
            count[x] = count.get(x, 0) + 1
        n = max(non_zero, key=lambda x: (count[x], x))
    else:
        n = 1
    
    compressed_width = width // 2
    compressed_height = height // 2
    compressed = [[0] * compressed_width for _ in range(compressed_height)]
    
    for i in range(compressed_height):
        for j in range(compressed_width):
            tile = [
                input_list[2*i][2*j],
                input_list[2*i][2*j+1],
                input_list[2*i+1][2*j],
                input_list[2*i+1][2*j+1]
            ]
            non_zero = [x for x in tile if x != 0]
            if non_zero:
                count = {}
                for x in non_zero:
                    count[x] = count.get(x, 0) + 1
                majority = max(non_zero, key=lambda x: (count[x], x))
            else:
                majority = 1
            compressed[i][j] = majority
    
    output_columns = [j for j in range(compressed_width) if j % n == 0]
    output_grid = []
    for i in range(compressed_height):
        output_grid.append([compressed[i][j] for j in output_columns])
    
    return tuple(tuple(row) for row in output_grid)
