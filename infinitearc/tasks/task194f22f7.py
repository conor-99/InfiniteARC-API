# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 194f22f7
Difficulty: mediumâ€“hard

=== Tags ===
- Analogical goal mapping
- Rule based tiling
- Hollow core detection
- Remove singletons

=== Description ===
Input grids consist of multiple connected regions of colored cells (0 represents
background), including closed loops that enclose hollow cores (maximal
background areas completely surrounded by a single connected region of non-
background cells), and isolated cells that are singletons (cells with no
adjacent neighbors of the same color). The output grid is generated by first
removing all singleton cells (cells with no 4-directional same-color neighbors),
then replacing each hollow core with a checkerboard pattern that alternates
between the color of the enclosing shape and a fixed secondary color (color 1,
blue). The hollow core is defined as the largest background area enclosed by a
single connected component of non-background cells, and the checkerboard pattern
is applied such that cells at positions where (row + column) is even use the
enclosing shape's color, while others use the fixed secondary color. All other
regions remain unchanged, and the transformation maintains the original grid
dimensions without overlapping or extending beyond boundaries.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Generator for ARC task: create grids with rectangular loops that enclose hollow cores,
# some additional shapes, and several singleton cells. The output removes singletons
# and fills each hollow core (background region fully enclosed by a single connected
# non-background component) with a checkerboard between the enclosing color and color 1.

def generate():
    width = random.randint(15, 25)
    height = random.randint(15, 25)
    ing = grid(width, height, 0)

    loops = []  # list of ((top,left,bottom,right), color)
    used_colors = set()

    # Try to place 1-3 rectangular loops that do not touch the outer border
    loop_target = random.randint(1, 3)
    attempts = 0
    while len(loops) < loop_target and attempts < 200:
        attempts += 1
        # choose rectangle bounds leaving at least a 1-cell border around the grid
        top = random.randint(1, max(1, height - 6))
        left = random.randint(1, max(1, width - 6))
        # ensure interior (hole) is at least 3x3 -> bottom >= top+4, right >= left+4
        bottom = random.randint(top + 4, height - 3) if top + 4 <= height - 3 else top + 4
        right = random.randint(left + 4, width - 3) if left + 4 <= width - 3 else left + 4
        if bottom >= height - 1 or right >= width - 1:
            continue
        # ensure candidate rect fits
        conflict = False
        for r in range(top, bottom + 1):
            for c in range(left, right + 1):
                if ing[r][c] != 0:
                    conflict = True
                    break
            if conflict:
                break
        if conflict:
            continue

        # Choose a loop color different from the reserved checker color 1
        possible = [c for c in range(2, 10) if c not in used_colors]
        if not possible:
            possible = [c for c in range(2, 10)]
        color = random.choice(possible)
        used_colors.add(color)

        # draw the loop (1-cell thick border)
        for c in range(left, right + 1):
            ing[top][c] = color
            ing[bottom][c] = color
        for r in range(top + 1, bottom):
            ing[r][left] = color
            ing[r][right] = color

        loops.append(((top, left, bottom, right), color))

    # If no loop was successfully placed (rare), create a central loop
    if not loops:
        top, left = 2, 2
        bottom, right = height - 3, width - 3
        color = random.choice([c for c in range(2, 10)])
        for c in range(left, right + 1):
            ing[top][c] = color
            ing[bottom][c] = color
        for r in range(top + 1, bottom):
            ing[r][left] = color
            ing[r][right] = color
        loops.append(((top, left, bottom, right), color))

    # Place some additional solid blocks/lines (avoid putting anything inside loop interiors)
    extra_shapes = random.randint(2, 6)
    for _ in range(extra_shapes):
        shape_ok = False
        for _try in range(60):
            shape_type = random.choice(['square', 'rect', 'hline', 'vline'])
            coords = []
            if shape_type == 'square':
                rh, rw = 2, 2
                r = random.randint(0, height - rh)
                c = random.randint(0, width - rw)
                coords = [(r + i, c + j) for i in range(rh) for j in range(rw)]
            elif shape_type == 'rect':
                rh = random.randint(2, 4)
                rw = random.randint(2, 4)
                r = random.randint(0, height - rh)
                c = random.randint(0, width - rw)
                coords = [(r + i, c + j) for i in range(rh) for j in range(rw)]
            elif shape_type == 'hline':
                length = random.randint(2, 6)
                r = random.randint(0, height - 1)
                c = random.randint(0, width - length)
                coords = [(r, c + i) for i in range(length)]
            else:  # vline
                length = random.randint(2, 6)
                r = random.randint(0, height - length)
                c = random.randint(0, width - 1)
                coords = [(r + i, c) for i in range(length)]

            bad = False
            for (rr, cc) in coords:
                if ing[rr][cc] != 0:
                    bad = True
                    break
                # avoid placing inside any loop interior
                for rect, _col in loops:
                    t, l, b, ri = rect
                    if rr >= t + 1 and rr <= b - 1 and cc >= l + 1 and cc <= ri - 1:
                        bad = True
                        break
                if bad:
                    break
            if bad:
                continue
            color = random.randint(2, 9)
            for (rr, cc) in coords:
                ing[rr][cc] = color
            shape_ok = True
            break
        # ignore if couldn't place this shape

    # Place multiple singletons (non-background cells without any same-color 4-neighbor)
    singletons = []
    wanted_singletons = random.randint(2, 6)
    for _ in range(wanted_singletons):
        placed = False
        for _try in range(200):
            r = random.randint(0, height - 1)
            c = random.randint(0, width - 1)
            # must be an empty cell and not inside loop interior
            if ing[r][c] != 0:
                continue
            inside_any_loop = False
            for rect, _col in loops:
                t, l, b, ri = rect
                if r >= t + 1 and r <= b - 1 and c >= l + 1 and c <= ri - 1:
                    inside_any_loop = True
                    break
            if inside_any_loop:
                continue
            color = random.randint(2, 9)
            # ensure no neighbor has same color
            ok = True
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and ing[nr][nc] == color:
                    ok = False
                    break
            if not ok:
                continue
            ing[r][c] = color
            singletons.append((r, c))
            placed = True
            break
        # continue even if not placed (we will ensure at least one exists below)

    if not singletons:
        # force at least one singleton somewhere safe
        for rr in range(height):
            for cc in range(width):
                if ing[rr][cc] != 0:
                    continue
                safe = True
                for rect, _col in loops:
                    t, l, b, ri = rect
                    if rr >= t + 1 and rr <= b - 1 and cc >= l + 1 and cc <= ri - 1:
                        safe = False
                        break
                if not safe:
                    continue
                ing[rr][cc] = 2
                singletons.append((rr, cc))
                break
            if singletons:
                break

    # Create input snapshot
    input_grid = [row[:] for row in ing]

    # Now compute the output following the task rules:
    # 1) remove all singleton cells (cells that in the input have no 4-neighbor of same color)
    output = [row[:] for row in input_grid]
    to_remove = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                continue
            color = input_grid[r][c]
            has_neighbor = False
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == color:
                    has_neighbor = True
                    break
            if not has_neighbor:
                to_remove.append((r, c))
    for (r, c) in to_remove:
        output[r][c] = 0

    # 2) detect zero regions (background components) in the grid after removing singletons
    visited = [[False] * width for _ in range(height)]
    zero_regions = []
    for r in range(height):
        for c in range(width):
            if output[r][c] != 0 or visited[r][c]:
                continue
            # BFS this zero-region
            queue = [(r, c)]
            visited[r][c] = True
            region = []
            while queue:
                rr, cc = queue.pop(0)
                region.append((rr, cc))
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and output[nr][nc] == 0:
                        visited[nr][nc] = True
                        queue.append((nr, nc))
            zero_regions.append(region)

    # 3) For each zero-region that does not touch the border and whose neighboring non-zero
    #    cells are all the same color and belong to a single connected component of that color,
    #    fill the zero-region with a checkerboard between that color and color 1.
    for region in zero_regions:
        # skip regions that touch the outer border
        touches_border = any(r == 0 or r == height - 1 or c == 0 or c == width - 1 for (r, c) in region)
        if touches_border:
            continue

        # collect neighboring non-zero cells
        neighbor_coords = set()
        for (r, c) in region:
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and output[nr][nc] != 0:
                    neighbor_coords.add((nr, nc))
        if not neighbor_coords:
            continue

        neighbor_colors = {output[nr][nc] for (nr, nc) in neighbor_coords}
        if len(neighbor_colors) != 1:
            continue
        enclosing_color = next(iter(neighbor_colors))

        # check that all neighbor coords lie in a single connected component of cells with enclosing_color
        start = next(iter(neighbor_coords))
        stack = [start]
        seen = {start}
        while stack:
            rr, cc = stack.pop()
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = rr + dr, cc + dc
                if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in seen and output[nr][nc] == enclosing_color:
                    seen.add((nr, nc))
                    stack.append((nr, nc))
        if not neighbor_coords.issubset(seen):
            continue

        # Fill the region with checkerboard pattern: even parity -> enclosing_color, odd -> 1
        for (r, c) in region:
            if (r + c) % 2 == 0:
                output[r][c] = enclosing_color
            else:
                output[r][c] = 1

    return {"input": input_grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # 1) Identify and remove singletons based on the original input
    to_remove = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0:
                continue
            color = grid[r][c]
            has_neighbor = False
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == color:
                    has_neighbor = True
                    break
            if not has_neighbor:
                to_remove.append((r, c))

    for (r, c) in to_remove:
        grid[r][c] = 0

    # 2) Find all zero-regions (background components) after removal
    visited = [[False] * width for _ in range(height)]
    zero_regions = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 or visited[r][c]:
                continue
            # BFS
            q = deque()
            q.append((r, c))
            visited[r][c] = True
            region = []
            while q:
                rr, cc = q.popleft()
                region.append((rr, cc))
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == 0:
                        visited[nr][nc] = True
                        q.append((nr, nc))
            zero_regions.append(region)

    # 3) For each zero-region that is enclosed by a single connected non-zero component of one color,
    #    fill it with a checkerboard between that color and color 1.
    for region in zero_regions:
        # skip if touches border
        touches_border = any(r == 0 or r == height - 1 or c == 0 or c == width - 1 for (r, c) in region)
        if touches_border:
            continue

        neighbor_coords = set()
        for (r, c) in region:
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                    neighbor_coords.add((nr, nc))
        if not neighbor_coords:
            continue

        neighbor_colors = {grid[nr][nc] for (nr, nc) in neighbor_coords}
        if len(neighbor_colors) != 1:
            continue
        enclosing_color = next(iter(neighbor_colors))

        # check connectivity of neighbor coords within the graph of cells with enclosing_color
        start = next(iter(neighbor_coords))
        stack = [start]
        seen = {start}
        while stack:
            rr, cc = stack.pop()
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = rr + dr, cc + dc
                if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in seen and grid[nr][nc] == enclosing_color:
                    seen.add((nr, nc))
                    stack.append((nr, nc))
        if not neighbor_coords.issubset(seen):
            continue

        # fill checkerboard: even parity -> enclosing_color, odd -> 1
        for (r, c) in region:
            if (r + c) % 2 == 0:
                grid[r][c] = enclosing_color
            else:
                grid[r][c] = 1

    return grid

