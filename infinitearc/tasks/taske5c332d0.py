# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: e5c332d0
Difficulty: insane

=== Tags ===
- Maze
- Recursive path tracing

=== Description ===
Input grids are complex mazes composed of walls (color 1) and traversable paths
(color 0), with nested sub-mazes enclosed by distinct boundary markers (color
2). Each sub-maze is a self-contained maze within its color 2 boundary,
potentially containing further nested sub-mazes. The path begins at a start cell
(color 9) and must reach an end cell (color 8) while traversing all hierarchical
levels of the maze structure.   The output grid transforms the input by tracing
the complete recursive path from start to end. The main path outside all sub-
mazes is marked with color 3. Upon entering any sub-maze boundary (color 2), the
path within that sub-maze is marked with the next sequential color (color 4 for
the first sub-maze level, color 5 for the next, etc.), incrementing by one for
each nested level. Walls (color 1) and all boundary markers (color 2) remain
unchanged. The path must traverse every sub-maze in the order encountered, with
no overlapping or reused cells, and the coloring must precisely reflect the
recursive depth (e.g., the outermost maze path uses color 3, direct sub-mazes
use color 4, their sub-mazes use color 5, and so on up to color 9 for the
deepest level). The solution requires simultaneously identifying all nested
structures and applying depth-based color coding to the continuous path.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = grid(width, height, 0)
    
    start_r, start_c = random.randint(0, height-1), random.randint(0, width-1)
    end_r, end_c = random.randint(0, height-1), random.randint(0, width-1)
    while start_r == end_r and start_c == end_c:
        end_r, end_c = random.randint(0, height-1), random.randint(0, width-1)
    
    input_grid[start_r][start_c] = 9
    input_grid[end_r][end_c] = 8
    
    path = []
    r, c = start_r, start_c
    while c < end_c:
        c += 1
        path.append((r, c))
    while r < end_r:
        r += 1
        path.append((r, c))
    
    for r, c in path:
        input_grid[r][c] = 0
    
    for _ in range(int(width * height * 0.1)):
        r, c = random.randint(0, height-1), random.randint(0, width-1)
        if input_grid[r][c] == 0:
            input_grid[r][c] = 1
    
    boundaries = []
    if len(path) >= 2:
        num_boundaries = random.randint(1, min(3, len(path) - 1))
        for _ in range(num_boundaries):
            start_idx = random.randint(0, len(path) - 2)
            end_idx = random.randint(start_idx + 1, len(path) - 1)
            segment = path[start_idx:end_idx+1]
            
            min_r = min(r for r, c in segment)
            max_r = max(r for r, c in segment)
            min_c = min(c for r, c in segment)
            max_c = max(c for r, c in segment)
            
            if max_r - min_r < 2 or max_c - min_c < 2:
                continue
            
            top, left, bottom, right = min_r, min_c, max_r, max_c
            for r in range(top, bottom + 1):
                for c in range(left, right + 1):
                    if r == top or r == bottom or c == left or c == right:
                        input_grid[r][c] = 2
            boundaries.append((top, left, bottom, right))
    
    output_grid = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] in [0, 9, 8]:
                count = 0
                for (top, left, bottom, right) in boundaries:
                    if top < r < bottom and left < c < right:
                        count += 1
                output_grid[r][c] = 3 + count
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    
    color2_cells = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 2:
                color2_cells.append((r, c))
    
    if not color2_cells:
        boundaries = []
    else:
        min_r = min(r for r, c in color2_cells)
        max_r = max(r for r, c in color2_cells)
        min_c = min(c for r, c in color2_cells)
        max_c = max(c for r, c in color2_cells)
        boundaries = [(min_r, min_c, max_r, max_c)]
    
    output_grid = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] in [0, 9, 8]:
                count = 0
                for (top, left, bottom, right) in boundaries:
                    if top < r < bottom and left < c < right:
                        count += 1
                output_grid[r][c] = 3 + count
    
    return output_grid
