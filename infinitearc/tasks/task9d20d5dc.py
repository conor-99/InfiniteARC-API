# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 9d20d5dc
Difficulty: hard

=== Tags ===
- Shape extrusion

=== Description ===
Shape Extrusion  Input grids contain multiple disconnected, non-overlapping
shapes, each defined by a connected region of a single color (excluding the
background color). Each shape is surrounded by uniform background cells (color 0
or another designated background color). The background is consistent throughout
the grid.  For each shape, compute its bounding box (the smallest rectangle that
contains all cells of the shape). If the bounding box width exceeds its height,
extrude the shape vertically by adding a single layer of the shape's color to
the top and bottom of the bounding box, only on background cells. If the
bounding box height exceeds its width, extrude horizontally by adding a single
layer to the left and right of the bounding box. If width equals height, extrude
horizontally by default.  The extrusion process requires checking cells adjacent
to the bounding box in the specified direction. For vertical extrusion, the top
and bottom rows of the bounding box are expanded outward (above the topmost row
and below the bottommost row), adding cells only where background exists. For
horizontal extrusion, the leftmost and rightmost columns of the bounding box are
expanded outward (to the left of the leftmost column and to the right of the
rightmost column), adding cells only where background exists.  The output grid
retains all original elements except for the extruded shapes. The background
remains unchanged, and extrusions never overwrite other shapes or background.
Shapes positioned near grid edges may have limited extrusion in that direction,
but all inputs are designed to allow full extrusion in the required direction.
The transformation requires identifying each shape's bounding box orientation,
applying the correct extrusion direction, and precisely adding new cells only on
background cells.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    from common import grid, rand_sprite

    # Grid size
    width = random.randint(12, 30)
    height = random.randint(12, 30)
    background = 0

    # Create empty input grid
    inp = grid(width, height, background)

    # Occupancy map to reserve space for sprites plus one-cell border (for extrusion)
    occupancy = [[False for _ in range(width)] for _ in range(height)]

    # Number of shapes and unique colors for them
    num_shapes = random.randint(2, 4)
    colors = random.sample(list(range(1, 10)), num_shapes)

    placed_shapes = []  # store (color)

    for color in colors:
        placed = False
        # Try multiple times to find a non-overlapping placement
        for attempt in range(400):
            sprite_name = random.choice(['el', 'you', 'aitch'])
            sprite_w = random.randint(3, 4)
            sprite_h = random.randint(3, 4)
            pixels = rand_sprite(sprite_name, sprite_w, sprite_h)

            # Determine actual sprite extents
            min_pr = min(p[0] for p in pixels)
            max_pr = max(p[0] for p in pixels)
            min_pc = min(p[1] for p in pixels)
            max_pc = max(p[1] for p in pixels)
            spr_h = max_pr - min_pr + 1
            spr_w = max_pc - min_pc + 1

            # Choose a top-left so that a one-cell border around the bounding box fits
            r0_min = 1
            r0_max = height - spr_h - 1
            c0_min = 1
            c0_max = width - spr_w - 1
            if r0_max < r0_min or c0_max < c0_min:
                continue

            r0 = random.randint(r0_min, r0_max)
            c0 = random.randint(c0_min, c0_max)

            # Check reserved area (bounding box expanded by 1 in all directions)
            conflict = False
            for rr in range(r0 - 1, r0 + spr_h + 1):
                for cc in range(c0 - 1, c0 + spr_w + 1):
                    if occupancy[rr][cc]:
                        conflict = True
                        break
                if conflict:
                    break
            if conflict:
                continue

            # Mark reserved area
            for rr in range(r0 - 1, r0 + spr_h + 1):
                for cc in range(c0 - 1, c0 + spr_w + 1):
                    occupancy[rr][cc] = True

            # Place sprite pixels
            for pr, pc in pixels:
                rr = r0 + pr
                cc = c0 + pc
                inp[rr][cc] = color

            placed_shapes.append(color)
            placed = True
            break

        if not placed:
            # As a fallback (very unlikely), place a single pixel with a reserved neighborhood
            for rr in range(1, height - 1):
                done = False
                for cc in range(1, width - 1):
                    if not occupancy[rr][cc]:
                        inp[rr][cc] = color
                        # reserve 1-cell neighborhood
                        for rrr in range(rr - 1, rr + 2):
                            for ccc in range(cc - 1, cc + 2):
                                occupancy[rrr][ccc] = True
                        placed_shapes.append(color)
                        done = True
                        break
                if done:
                    break

    # Prepare output by applying extrusions based on the ORIGINAL input background
    out = [row[:] for row in inp]
    for color in placed_shapes:
        # find all cells of this color in the original input
        cells = [(r, c) for r in range(height) for c in range(width) if inp[r][c] == color]
        if not cells:
            continue
        min_r = min(r for r, c in cells)
        max_r = max(r for r, c in cells)
        min_c = min(c for r, c in cells)
        max_c = max(c for r, c in cells)
        width_bb = max_c - min_c + 1
        height_bb = max_r - min_r + 1

        # If width > height --> vertical extrusion (top and bottom)
        # Otherwise (width <= height) --> horizontal extrusion (left and right)
        if width_bb > height_bb:
            top = min_r - 1
            if top >= 0:
                for c in range(min_c, max_c + 1):
                    # only add where ORIGINAL input is background
                    if inp[top][c] == background:
                        out[top][c] = color
            bottom = max_r + 1
            if bottom < height:
                for c in range(min_c, max_c + 1):
                    if inp[bottom][c] == background:
                        out[bottom][c] = color
        else:
            left = min_c - 1
            if left >= 0:
                for r in range(min_r, max_r + 1):
                    if inp[r][left] == background:
                        out[r][left] = color
            right = max_c + 1
            if right < width:
                for r in range(min_r, max_r + 1):
                    if inp[r][right] == background:
                        out[r][right] = color

    return {"input": inp, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Generator uses background color 0; use that directly for robustness
    background = 0

    # Prepare output copy
    out = [row[:] for row in grid]

    # Find all non-background colors
    colors = sorted({grid[r][c] for r in range(height) for c in range(width) if grid[r][c] != background})

    # For each color, compute bounding box and apply extrusion based on ORIGINAL input
    for color in colors:
        cells = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == color]
        if not cells:
            continue
        min_r = min(r for r, c in cells)
        max_r = max(r for r, c in cells)
        min_c = min(c for r, c in cells)
        max_c = max(c for r, c in cells)
        width_bb = max_c - min_c + 1
        height_bb = max_r - min_r + 1

        if width_bb > height_bb:
            top = min_r - 1
            if top >= 0:
                for c in range(min_c, max_c + 1):
                    if grid[top][c] == background:
                        out[top][c] = color
            bottom = max_r + 1
            if bottom < height:
                for c in range(min_c, max_c + 1):
                    if grid[bottom][c] == background:
                        out[bottom][c] = color
        else:
            left = min_c - 1
            if left >= 0:
                for r in range(min_r, max_r + 1):
                    if grid[r][left] == background:
                        out[r][left] = color
            right = max_c + 1
            if right < width:
                for r in range(min_r, max_r + 1):
                    if grid[r][right] == background:
                        out[r][right] = color

    return tuple(tuple(row) for row in out)

