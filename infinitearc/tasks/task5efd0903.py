# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 5efd0903
Difficulty: medium

=== Tags ===
- Count ver lines
- Propagate color until boundary
- Outline shapes

=== Description ===
The task involves transforming an input grid containing one or more contiguous
shapes (connected regions of non-zero color) into an output grid where each
shape is represented by its outline. The outline is formed by retaining only the
outermost cells of each shapeâ€”cells that are part of the shape and adjacent to
at least one background cell (color 0) or another shape.   To generate the
output, the model must: 1. **Identify vertical lines** within each shape
(sequences of vertically adjacent cells of the same color). 2. **Propagate color
information** from the edges of the shape inward until encountering background
or another shape, effectively tracing the boundary. 3. **Outline shapes** by
preserving the color of edge cells (those with at least one background neighbor)
and setting all inner cells to background.  This process requires recognizing
the vertical structure of shapes (via vertical line detection), using
propagation to determine boundaries, and rendering the outline as the final
output. The transformation is visual and rule-based, relying on spatial
relationships rather than numerical values or pixel-level matching.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, continuous_creature, random_color

def generate():
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    grid_input = grid(width, height, 0)
    
    num_shapes = random.randint(1, 3)
    colors = []
    used_colors = [0]
    for _ in range(num_shapes):
        color = random_color(exclude=used_colors)
        colors.append(color)
        used_colors.append(color)
    
    for color in colors:
        pixels = continuous_creature(9, width=3, height=3)
        max_r = max(r for r, c in pixels)
        max_c = max(c for r, c in pixels)
        r0 = random.randint(0, height - max_r - 1)
        c0 = random.randint(0, width - max_c - 1)
        for r, c in pixels:
            grid_input[r0 + r][c0 + c] = color
    
    output = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if grid_input[r][c] == 0:
                continue
            color = grid_input[r][c]
            has_boundary = False
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if nr < 0 or nr >= height or nc < 0 or nc >= width:
                    has_boundary = True
                    break
                neighbor = grid_input[nr][nc]
                if neighbor == 0 or neighbor != color:
                    has_boundary = True
                    break
            if has_boundary:
                output[r][c] = color
    return {'input': grid_input, 'output': output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                continue
            color = input_grid[r][c]
            has_boundary = False
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if nr < 0 or nr >= height or nc < 0 or nc >= width:
                    has_boundary = True
                    break
                neighbor = input_grid[nr][nc]
                if neighbor == 0 or neighbor != color:
                    has_boundary = True
                    break
            if has_boundary:
                output[r][c] = color
    return output
