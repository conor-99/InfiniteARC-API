# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: affeabe4
Difficulty: hard

=== Tags ===
- Replace pattern
- Variable binding by color
- Detect closed curves
- Object canonicalization

=== Description ===
The task involves transforming input grids containing closed curves (cycles of
connected cells forming a loop with no endpoints, where each cell in the loop
has exactly two adjacent neighbors within the loop) into output grids. Each
closed curve is defined by a single non-zero color and must be detected as a
distinct cycle. For each detected closed curve, the output replaces the loop
with a 3×3 filled square of a color determined by a fixed, consistent mapping
from the original curve's color (e.g., color 1 → color 2, color 5 → color 7,
etc.). The rest of the grid remains unchanged. The transformation requires first
identifying closed curves (detecting cycles in the grid), then applying variable
binding (mapping the original color to a target color), and canonicalizing the
detected curves into a uniform 3×3 filled square shape. The mapping and curve
detection must be generalized from minimal examples, with no pixel-by-pixel
matching required.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = grid(width, height, 0)
    output_grid = grid(width, height, 0)
    c = random.randint(1, 9)
    w = random.randint(3, width - 2)
    h = random.randint(3, height - 2)
    r = random.randint(0, height - h)
    col = random.randint(0, width - w)
    for i in range(col, col + w):
        input_grid[r][i] = c
        input_grid[r + h - 1][i] = c
    for i in range(r + 1, r + h - 1):
        input_grid[i][col] = c
        input_grid[i][col + w - 1] = c
    output_grid = [row[:] for row in input_grid]
    mapped_color = (c % 9) + 1
    for i in range(min(3, h)):
        for j in range(min(3, w)):
            if r + i < height and col + j < width:
                output_grid[r + i][col + j] = mapped_color
    for i in range(r, r + h):
        for j in range(col, col + w):
            if (i == r or i == r + h - 1 or j == col or j == col + w - 1):
                if not (i < r + 3 and j < col + 3):
                    output_grid[i][j] = 0
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid:
        return input_grid
    height = len(input_grid)
    width = len(input_grid[0])
    visited = [[False] * width for _ in range(height)]
    output_grid = [list(row) for row in input_grid]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] > 0 and not visited[r][c]:
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == input_grid[r][c]:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                color = input_grid[r][c]
                is_loop = True
                for (cr, cc) in component:
                    count = 0
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == color:
                            count += 1
                    if count != 2:
                        is_loop = False
                        break
                if is_loop:
                    min_r = min(cr for cr, cc in component)
                    min_c = min(cc for cr, cc in component)
                    mapped_color = (color % 9) + 1
                    for i in range(min_r, min(min_r + 3, height)):
                        for j in range(min_c, min(min_c + 3, width)):
                            output_grid[i][j] = mapped_color
                    for (cr, cc) in component:
                        if cr >= min_r and cr < min_r + 3 and cc >= min_c and cc < min_c + 3:
                            continue
                        output_grid[cr][cc] = 0
    return output_grid
