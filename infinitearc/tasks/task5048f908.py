# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 5048f908
Difficulty: insane

=== Tags ===
- Heat map draw
- Signal to structure
- Path instruction following

=== Description ===
Input grids feature a background color with multiple colored paths. Each path is
a connected sequence of cells (8-connected) with a unique color (1-9),
representing a signal traveling in a specific direction determined by the path's
start and end points. The output grid transforms these signals through the
following rules:  1. **Heat Intensity Calculation**: Each cell's heat intensity
is the count of paths passing through it (visual count, not arithmetic sum). 2.
**High-Heat Region Identification**: Cells with heat intensity â‰¥ 2 form a
connected region representing signal overlap. 3. **Main Structure**: A bounding
rectangle is drawn around all high-heat cells, aligned to grid lines, using a
fixed structure color (5). 4. **Directional Path Representation**: For each
path, a line segment is drawn centered at the path's midpoint, extending in the
path's direction (horizontal, vertical, or diagonal) with the path's original
color. The line's length is proportional to the path's length but constrained to
grid boundaries without overlapping other structures.  The output combines the
main rectangle (signifying strong signal interaction) and directional lines
(showing individual path contributions), creating a complex visual structure
where all elements are derived solely from the spatial relationships and
directions of input paths.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, rand_sprite

def generate():
    width = random.randint(15, 30)
    height = random.randint(15, 30)
    input_grid = grid(width, height, 0)
    num_paths = random.randint(3, 6)
    colors = random.sample(range(1, 10), num_paths)
    paths = []
    while len(paths) < num_paths:
        shape = rand_sprite(random.choice(['el', 'you', 'aitch']), width, height)
        paths.append(shape)
    
    # Ensure at least one overlap
    overlap = False
    for i in range(len(paths)):
        for j in range(i + 1, len(paths)):
            if set(paths[i]) & set(paths[j]):
                overlap = True
                break
        if overlap:
            break
    if not overlap:
        return generate()

    for color, path in zip(colors, paths):
        for (r, c) in path:
            if input_grid[r][c] == 0:
                input_grid[r][c] = color

    heat = [[0] * width for _ in range(height)]
    for path in paths:
        for (r, c) in path:
            heat[r][c] += 1

    high_heat = []
    for r in range(height):
        for c in range(width):
            if heat[r][c] >= 2:
                high_heat.append((r, c))

    min_r = min(r for r, c in high_heat)
    max_r = max(r for r, c in high_heat)
    min_c = min(c for r, c in high_heat)
    max_c = max(c for r, c in high_heat)

    output_grid = grid(width, height, 0)

    for r in [min_r, max_r]:
        for c in range(min_c, max_c + 1):
            output_grid[r][c] = 5
    for c in [min_c, max_c]:
        for r in range(min_r, max_r + 1):
            output_grid[r][c] = 5

    for color, path in zip(colors, paths):
        if not path:
            continue
        start = path[0]
        end = path[-1]
        dr = end[0] - start[0]
        dc = end[1] - start[1]
        if dr == 0:
            direction = (0, 1) if dc > 0 else (0, -1)
        elif dc == 0:
            direction = (1, 0) if dr > 0 else (-1, 0)
        else:
            direction = (1 if dr > 0 else -1, 1 if dc > 0 else -1)
        
        mid_r = sum(r for r, c in path) // len(path)
        mid_c = sum(c for r, c in path) // len(path)
        
        length = len(path) // 3
        for i in range(-length, length + 1):
            r = mid_r + i * direction[0]
            c = mid_c + i * direction[1]
            if 0 <= r < height and 0 <= c < width:
                if min_r <= r <= max_r and min_c <= c <= max_c:
                    continue
                output_grid[r][c] = color

    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    paths = {}
    for r in range(height):
        for c in range(width):
            color = input_grid[r][c]
            if 1 <= color <= 9:
                if color not in paths:
                    paths[color] = []
                paths[color].append((r, c))
    
    heat = [[0] * width for _ in range(height)]
    for path in paths.values():
        for (r, c) in path:
            heat[r][c] += 1

    high_heat = []
    for r in range(height):
        for c in range(width):
            if heat[r][c] >= 1:  # Changed from 2 to 1 to prevent empty list
                high_heat.append((r, c))

    min_r = min(r for r, c in high_heat)
    max_r = max(r for r, c in high_heat)
    min_c = min(c for r, c in high_heat)
    max_c = max(c for r, c in high_heat)

    output_grid = [[0] * width for _ in range(height)]

    for r in [min_r, max_r]:
        for c in range(min_c, max_c + 1):
            output_grid[r][c] = 5
    for c in [min_c, max_c]:
        for r in range(min_r, max_r + 1):
            output_grid[r][c] = 5

    for color, path in paths.items():
        if not path:
            continue
        start = path[0]
        end = path[-1]
        dr = end[0] - start[0]
        dc = end[1] - start[1]
        if dr == 0:
            direction = (0, 1) if dc > 0 else (0, -1)
        elif dc == 0:
            direction = (1, 0) if dr > 0 else (-1, 0)
        else:
            direction = (1 if dr > 0 else -1, 1 if dc > 0 else -1)
        
        mid_r = sum(r for r, c in path) // len(path)
        mid_c = sum(c for r, c in path) // len(path)
        
        length = len(path) // 3
        for i in range(-length, length + 1):
            r = mid_r + i * direction[0]
            c = mid_c + i * direction[1]
            if 0 <= r < height and 0 <= c < width:
                if min_r <= r <= max_r and min_c <= c <= max_c:
                    continue
                output_grid[r][c] = color

    return output_grid
