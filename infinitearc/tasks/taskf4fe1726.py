# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: f4fe1726
Difficulty: mediumâ€“hard

=== Tags ===
- Spatial signal

=== Description ===
Input grids feature a background color (0), a continuous path of a single non-
background color starting from the top edge and extending downward, and multiple
walls of distinct non-background colors. Walls are either horizontal (spanning
left-right within a single row) or vertical (spanning up-down within a single
column), and are placed such that they do not touch each other or the path. In
the output grid, the signal path is transformed: each segment of the path is
colored according to the signal's current color after each interaction with a
wall. Upon hitting a horizontal wall, the signal reverses its vertical direction
and adopts the wall's color; upon hitting a vertical wall, it reverses its
horizontal direction and adopts the wall's color. The output displays the entire
path with color changes reflecting these interactions, with the signal exiting
the grid after all reflections.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    path_color = random.randint(1, 9)
    wall_color = random.choice([c for c in range(1, 10) if c != path_color])
    
    input_grid = grid(width, height, 0)
    
    start_col = random.randint(2, width - 3)
    path_len = random.randint(5, min(10, height - 1))
    
    for r in range(path_len):
        input_grid[r][start_col] = path_color
    
    wall_row = path_len
    wall_start_col = start_col - 1
    wall_end_col = start_col + 1
    for c in range(wall_start_col, wall_end_col + 1):
        if 0 <= wall_row < height and 0 <= c < width:
            input_grid[wall_row][c] = wall_color
    
    output_grid = [row[:] for row in input_grid]
    for r in range(path_len - 2, -1, -1):
        output_grid[r][start_col] = wall_color
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    start_col = None
    for c in range(width):
        if grid[0][c] != 0:
            start_col = c
            break
    if start_col is None:
        return grid
    
    path_color = grid[0][start_col]
    
    path_cells = []
    stack = [(0, start_col)]
    visited = set()
    while stack:
        r, c = stack.pop()
        if (r, c) in visited or grid[r][c] != path_color:
            continue
        visited.add((r, c))
        path_cells.append((r, c))
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in visited and grid[nr][nc] == path_color:
                stack.append((nr, nc))
    
    if not path_cells:
        return grid
    
    path_cells.sort(key=lambda x: x[0])
    last_row, last_col = path_cells[-1]
    
    if last_row + 1 < height and grid[last_row + 1][last_col] != 0 and grid[last_row + 1][last_col] != path_color:
        wall_color = grid[last_row + 1][last_col]
        for r, c in path_cells:
            if r < last_row:
                grid[r][c] = wall_color
    
    return grid
