# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 233639fa
Difficulty: hard

=== Tags ===
- Color matching
- Color by manhattan distance
- Symmetry breaking choice
- Global consistency enforcement

=== Description ===
The task involves transforming an input grid into an output grid based on a
consistent rule derived from the input's color distribution and spatial
relationships. Input grids contain multiple colors (0–9) arranged in a 2D
pattern, with at least one non-zero color. The key rule is: identify the
smallest non-zero color present in the input (referred to as the *reference
color*), then compute for every cell its Manhattan distance to the nearest cell
of this reference color. The output grid’s color for each cell is determined by
a fixed mapping of this distance (e.g., distance 0 → color 7, distance 1 → color
4, distance 2 → color 9, etc., cycling through a predefined sequence).   The
*symmetry breaking choice* is inherent in selecting the smallest non-zero color
as the reference (e.g., if colors 3 and 5 are present, the reference is 3).
*Global consistency enforcement* ensures all reference color cells are used for
distance calculations, not just a single instance. The output grid forms
concentric rings of colors around reference cells, with ring color determined
solely by distance. This requires the solver to first deduce the reference
color, then map distances to output colors through induction, avoiding reliance
on pixel patterns or arithmetic sums. The complexity arises from the need to
handle varying grid sizes, multiple reference cells, and a non-obvious color-
distance mapping that must be inferred from limited examples.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    grid = [[0] * width for _ in range(height)]
    min_color = random.randint(1, 9)
    grid[random.randint(0, height-1)][random.randint(0, width-1)] = min_color
    for _ in range(random.randint(1, 10)):
        r, c = random.randint(0, height-1), random.randint(0, width-1)
        grid[r][c] = random.randint(1, 9)
    
    non_zero = set()
    for row in grid:
        for cell in row:
            if cell > 0:
                non_zero.add(cell)
    if not non_zero:
        grid[0][0] = 1
        min_color = 1
    else:
        min_color = min(non_zero)
    
    min_cells = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] == min_color:
                min_cells.append((r, c))
    
    distance_grid = [[10**9] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            for (mr, mc) in min_cells:
                d = abs(r - mr) + abs(c - mc)
                if d < distance_grid[r][c]:
                    distance_grid[r][c] = d
    
    seq = [7, 4, 9, 2, 5]
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            d = distance_grid[r][c]
            output_grid[r][c] = seq[d % len(seq)]
    
    if grid == output_grid:
        return generate()
    return {"input": grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    non_zero = set()
    for row in input_grid:
        for cell in row:
            if cell > 0:
                non_zero.add(cell)
    if not non_zero:
        return input_grid
    min_color = min(non_zero)
    min_cells = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == min_color:
                min_cells.append((r, c))
    
    distance_grid = [[10**9] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            for (mr, mc) in min_cells:
                d = abs(r - mr) + abs(c - mc)
                if d < distance_grid[r][c]:
                    distance_grid[r][c] = d
    
    seq = [7, 4, 9, 2, 5]
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            d = distance_grid[r][c]
            output_grid[r][c] = seq[d % len(seq)]
    return output_grid
