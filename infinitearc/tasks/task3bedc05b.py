# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 3bedc05b
Difficulty: very hard

=== Tags ===
- Sand simulation
- Diagonal weaving
- Multi step traversal
- Color modulated logic
- Color the column with fewest dots
- Color by distance to a single point

=== Description ===
Diagonal Sand Weave    Input grids consist of a background (color 0) overlaid
with colored sand particles (colors 1-9), each color representing a fixed
diagonal movement direction (e.g., red moves down-right, blue moves up-left,
green moves down-left, yellow moves up-right). Sand particles move diagonally in
their assigned direction until they exit the grid, collide with another particle
moving in a conflicting direction, or reach a stable position (blocked by grid
edges or other particles).    After all particles stabilize, the grid undergoes
two sequential transformations:   1. **Column Density Coloring**: The number of
non-background particles (dots) is counted in each column. The column with the
smallest count is entirely recolored to background (0), erasing all particles in
that column.   2. **Distance-Based Coloring**: A single reference point (the
grid’s geometric center) is used to determine Manhattan distance for each
remaining cell. Cells are recolored using a predefined gradient: closer
distances (0-2 cells) use color 1, medium distances (3-5 cells) use color 2, and
farther distances (6+ cells) use color 3, ensuring consistent visual mapping
across all grids.    The output grid combines these transformations: the column
with the fewest particles is removed (background), and all other cells are
colored based on their distance from the center, creating a visual pattern that
weaves diagonally through the grid. This task requires simulating multi-
directional particle movement, precise column analysis, and distance-based
coloring—all while adhering to strict non-overwriting rules for the erased
column.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def stabilize_grid(grid):
    H = len(grid)
    W = len(grid[0])
    directions = {
        1: (1, 1),
        2: (-1, -1),
        3: (1, -1),
        4: (-1, 1)
    }
    current = [row[:] for row in grid]
    moved = True
    while moved:
        moved = False
        next_grid = [[0] * W for _ in range(H)]
        for r in range(H):
            for c in range(W):
                if current[r][c] == 0:
                    continue
                color = current[r][c]
                dr, dc = directions.get(color, (0, 0))
                nr, nc = r + dr, c + dc
                if 0 <= nr < H and 0 <= nc < W:
                    if current[nr][nc] == 0:
                        next_grid[nr][nc] = color
                        moved = True
                    else:
                        next_grid[r][c] = color
        current = next_grid
    return current

def generate():
    H = random.randint(5, 30)
    W = random.randint(5, 30)
    input_grid = [[0]*W for _ in range(H)]
    num_particles = random.randint(5, 15)
    for _ in range(num_particles):
        r = random.randint(0, H-1)
        c = random.randint(0, W-1)
        color = random.randint(1, 4)
        input_grid[r][c] = color
    stabilized = stabilize_grid(input_grid)
    col_counts = [sum(1 for r in range(H) if stabilized[r][c] > 0) for c in range(W)]
    min_count = min(col_counts)
    min_col = next(c for c in range(W) if col_counts[c] == min_count)
    for r in range(H):
        stabilized[r][min_col] = 0
    output_grid = [[0]*W for _ in range(H)]
    center_r, center_c = H/2, W/2
    for r in range(H):
        for c in range(W):
            if c == min_col:
                continue
            dist = abs(r - center_r) + abs(c - center_c)
            if dist <= 2:
                output_grid[r][c] = 1
            elif dist <= 5:
                output_grid[r][c] = 2
            else:
                output_grid[r][c] = 3
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random

def stabilize_grid(grid):
    H = len(grid)
    W = len(grid[0])
    directions = {
        1: (1, 1),
        2: (-1, -1),
        3: (1, -1),
        4: (-1, 1)
    }
    current = [row[:] for row in grid]
    moved = True
    while moved:
        moved = False
        next_grid = [[0] * W for _ in range(H)]
        for r in range(H):
            for c in range(W):
                if current[r][c] == 0:
                    continue
                color = current[r][c]
                dr, dc = directions.get(color, (0, 0))
                nr, nc = r + dr, c + dc
                if 0 <= nr < H and 0 <= nc < W:
                    if current[nr][nc] == 0:
                        next_grid[nr][nc] = color
                        moved = True
                    else:
                        next_grid[r][c] = color
        current = next_grid
    return current

def p(input_grid):
    H = len(input_grid)
    W = len(input_grid[0])
    current = [list(row) for row in input_grid]
    stabilized = stabilize_grid(current)
    col_counts = [sum(1 for r in range(H) if stabilized[r][c] > 0) for c in range(W)]
    min_count = min(col_counts)
    min_col = next(c for c in range(W) if col_counts[c] == min_count)
    for r in range(H):
        stabilized[r][min_col] = 0
    output_grid = [[0]*W for _ in range(H)]
    center_r, center_c = H/2, W/2
    for r in range(H):
        for c in range(W):
            if c == min_col:
                continue
            dist = abs(r - center_r) + abs(c - center_c)
            if dist <= 2:
                output_grid[r][c] = 1
            elif dist <= 5:
                output_grid[r][c] = 2
            else:
                output_grid[r][c] = 3
    return output_grid
