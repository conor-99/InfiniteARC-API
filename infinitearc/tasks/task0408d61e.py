# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 0408d61e
Difficulty: easy

=== Tags ===
- Remove noise
- Even or odd
- Project shadow
- Pattern moving

=== Description ===
The input grids contain a contiguous main pattern (a connected group of non-zero
pixels sharing edges) and isolated noise pixels (non-zero pixels with no
adjacent non-zero neighbors in any direction). The output grid is created by
first removing all noise pixels, then shifting the remaining main pattern one
cell to the right. The grid dimensions remain unchanged, with the rightmost
pixels of the pattern shifting out of bounds (resulting in background 0s on the
left side of the grid). This transformation visually projects a "shadow" of the
pattern to the right while eliminating disconnected noise elements.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random
def generate():
    width = random.randint(5, 10)
    height = random.randint(5, 10)
    main_pixels = common.continuous_creature(size=5, width=width, height=height)
    input_grid = common.grid(width, height, 0)
    main_rows = [p[0] for p in main_pixels]
    main_cols = [p[1] for p in main_pixels]
    for r, c in zip(main_rows, main_cols):
        input_grid[r][c] = 1
    noise_positions = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                continue
            is_isolated = True
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0:
                    is_isolated = False
                    break
            if is_isolated:
                noise_positions.append((r, c))
    num_noise = random.randint(2, 3)
    for _ in range(num_noise):
        if noise_positions:
            r, c = random.choice(noise_positions)
            input_grid[r][c] = 2
            noise_positions.remove((r, c))
    output_grid = common.grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 1:
                if c + 1 < width:
                    output_grid[r][c+1] = 1
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    visited = [[False] * width for _ in range(height)]
    components = []
    
    def dfs(r, c, comp):
        visited[r][c] = True
        comp.append((r, c))
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] != 0:
                dfs(nr, nc, comp)
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                comp = []
                dfs(r, c, comp)
                components.append(comp)
    
    main_comp = max(components, key=len)
    output_grid = common.grid(width, height, 0)
    for r, c in main_comp:
        if c + 1 < width:
            output_grid[r][c+1] = input_grid[r][c]
    return output_grid
