# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 2cf4067e
Difficulty: easy

=== Tags ===
- Associate colors to colors
- Count shapes
- Duplicate row pattern
- Measure distance from side

=== Description ===
The input grid contains one or more connected shapes (regions of non-zero cells
connected via edges). The output grid is generated through the following steps:
1. **Count shapes**: Determine the number of connected shapes (N) in the input
grid. Each shape is a contiguous group of non-zero cells (using 4-directional
connectivity).  2. **Measure distance from side**: For each cell in the input
grid, calculate its minimum distance to any grid edge (top, bottom, left,
right). The distance is computed as min(row_index, height-1-row_index,
column_index, width-1-column_index).  3. **Associate colors to colors**: Replace
every cell with a color value > 0 if its distance to the nearest edge is ≤ N.
The replacement color is fixed (e.g., all such cells become color 2).  4.
**Duplicate row pattern**: In the output grid, each row that originally
contained at least one non-zero cell (before color replacement) is duplicated
exactly N times. Rows without any non-zero cells remain unchanged (appearing
once).
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, rand_sprite

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 15)  # Limit height to ensure output height ≤30
    input_grid = grid(width, height, 0)
    
    # Generate two disconnected shapes
    shape1 = rand_sprite('el', width, height)
    shape2 = rand_sprite('you', width, height)
    
    # Shift second shape to bottom-right
    shift_r = height // 2
    shift_c = width // 2
    shape2_shifted = [(r + shift_r, c + shift_c) for r, c in shape2]
    shape2_valid = [(r, c) for r, c in shape2_shifted if 0 <= r < height and 0 <= c < width]
    
    # Place shapes with different colors
    for r, c in shape1:
        input_grid[r][c] = random.randint(1, 9)
    for r, c in shape2_valid:
        input_grid[r][c] = random.randint(1, 9)
        
    # Count connected components (N)
    visited = [[False] * width for _ in range(height)]
    N = 0
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] > 0 and not visited[r][c]:
                N += 1
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] > 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
    
    # Create modified grid
    modified = [[input_grid[r][c] for c in range(width)] for r in range(height)]
    for r in range(height):
        for c in range(width):
            dist = min(r, height - 1 - r, c, width - 1 - c)
            if dist <= N:
                modified[r][c] = 2
    
    # Build output by duplicating rows with non-zero
    output_rows = []
    for r in range(height):
        if any(input_grid[r][c] > 0 for c in range(width)):
            output_rows.extend([modified[r]] * N)
        else:
            output_rows.append(modified[r])
    
    return {"input": input_grid, "output": output_rows}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    if not input_grid or not input_grid[0]:
        return input_grid
    height = len(input_grid)
    width = len(input_grid[0])
    
    # Count connected components (N)
    visited = [[False] * width for _ in range(height)]
    N = 0
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] > 0 and not visited[r][c]:
                N += 1
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] > 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
    
    # Create modified grid
    modified = [[input_grid[r][c] for c in range(width)] for r in range(height)]
    for r in range(height):
        for c in range(width):
            dist = min(r, height - 1 - r, c, width - 1 - c)
            if dist <= N:
                modified[r][c] = 2
    
    # Build output by duplicating rows with non-zero
    output_rows = []
    for r in range(height):
        if any(input_grid[r][c] > 0 for c in range(width)):
            output_rows.extend([modified[r]] * N)
        else:
            output_rows.append(modified[r])
    
    return output_rows
