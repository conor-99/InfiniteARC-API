# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 9ccc2f1c
Difficulty: hard

=== Tags ===
- Relay chain
- Remove noise
- Detect wall

=== Description ===
Input grids feature a background color, a continuous wall structure (composed of
cells in a single distinct color, forming barriers that enclose regions), a
fragmented relay chain (a sequence of connected cells in another color that is
interrupted by noise), and scattered noise (random cells of various colors not
part of walls or chain). The walls form complex, non-rectangular boundaries that
the relay chain must navigate around. The output grid must: (1) completely
remove all noise elements (reverting to background), (2) preserve the walls in
their original positions and colors, and (3) reconstruct the relay chain as a
single continuous path that follows the outer perimeter of the wall structure
without crossing through walls or noise. This requires the solver to identify
the wall boundaries through their contiguous color, distinguish noise from valid
chain segments, and connect the chain segments along the wall's edges while
avoiding any interior wall cells. The challenge lies in recognizing the wall
structure as an obstacle and navigating the chain around it using only the
available edge-aligned paths, with no overlapping or crossing of walls.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, all_pixels

def generate():
    size = random.randint(10, 20)
    grid_size = size
    wall_color = 1
    chain_color = 3
    noise_colors = [2, 4, 5, 6, 7, 8, 9]
    
    # Create empty grid
    ingrid = grid(grid_size, grid_size, 0)
    
    # Generate wall as rectangular perimeter
    r1, r2 = 2, grid_size - 3
    c1, c2 = 2, grid_size - 3
    wall_cells = []
    
    # Top and bottom edges
    for c in range(c1, c2 + 1):
        ingrid[r1][c] = wall_color
        ingrid[r2][c] = wall_color
        wall_cells.append((r1, c))
        wall_cells.append((r2, c))
    
    # Left and right edges (excluding corners)
    for r in range(r1 + 1, r2):
        ingrid[r][c1] = wall_color
        ingrid[r][c2] = wall_color
        wall_cells.append((r, c1))
        wall_cells.append((r, c2))
    
    # Randomly assign chain and noise to wall cells
    random.shuffle(wall_cells)
    num_chain = max(2, len(wall_cells) // 3)
    
    for i, (r, c) in enumerate(wall_cells):
        if i < num_chain:
            ingrid[r][c] = chain_color
        else:
            ingrid[r][c] = random.choice(noise_colors)
    
    # Add scattered noise elsewhere
    for r in range(grid_size):
        for c in range(grid_size):
            if random.random() < 0.05 and ingrid[r][c] != wall_color:
                ingrid[r][c] = random.choice(noise_colors)
    
    # Create output grid by transforming wall cells to chain and noise to background
    output = [row[:] for row in ingrid]
    for r in range(grid_size):
        for c in range(grid_size):
            if output[r][c] == wall_color:
                output[r][c] = chain_color
            elif output[r][c] in noise_colors:
                output[r][c] = 0
    
    return {
        "input": ingrid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable list
    grid = [list(row) for row in input_grid]
    
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            if grid[r][c] == 1:
                grid[r][c] = 3
            elif grid[r][c] in [2, 4, 5, 6, 7, 8, 9]:
                grid[r][c] = 0
    
    return grid
