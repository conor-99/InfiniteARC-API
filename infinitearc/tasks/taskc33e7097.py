# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: c33e7097
Difficulty: hard

=== Tags ===
- Direction guessing

=== Description ===
The input grid contains a straight-line path of consecutive integers starting at
1 and increasing by 1 along a horizontal or vertical direction. The path is
contiguous, with each cell adjacent to the next in the sequence. The output grid
is generated by extending the path by one cell in the direction determined by
the path's orientation: if the sequence progresses rightward (column indices
increase), the path extends right; if downward (row indices increase), it
extends downward; similarly for leftward or upward. The new cell is labeled with
the next integer in the sequence (N+1, where N is the highest number in the
input path). The direction is inferred solely from the relative positions of the
path's start (cell with value 1) and end (cell with value N), requiring the
model to deduce the movement vector without explicit directional indicators. The
transformation is deterministic, requiring the model to identify the path's
direction through spatial reasoning before extending it.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    width = random.randint(2, 30)
    height = random.randint(2, 30)
    direction = random.randint(0, 3)
    dr, dc = 0, 0
    if direction == 0:
        dr, dc = 0, 1
    elif direction == 1:
        dr, dc = 0, -1
    elif direction == 2:
        dr, dc = 1, 0
    elif direction == 3:
        dr, dc = -1, 0
    
    # Ensure grid size is sufficient for all directions
    if direction in [0, 1]:
        width = max(width, 3)
    else:
        height = max(height, 3)
    
    # Calculate max_N based on direction
    if direction in [0, 1]:
        max_N = width - 1
    else:
        max_N = height - 1
    
    N = random.randint(2, min(max_N, 8))
    
    if direction in [0, 1]:
        r = random.randint(0, height - 1)
        if direction == 0:
            c = random.randint(0, width - N - 1)
        else:
            c = random.randint(N, width - 1)
    else:
        c = random.randint(0, width - 1)
        if direction == 2:
            r = random.randint(0, height - N - 1)
        else:
            r = random.randint(N, height - 1)
    
    input_grid = [[0] * width for _ in range(height)]
    for step in range(N):
        nr = r + step * dr
        nc = c + step * dc
        input_grid[nr][nc] = step + 1
    
    output_grid = [row[:] for row in input_grid]
    nr = r + N * dr
    nc = c + N * dc
    output_grid[nr][nc] = N + 1
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Ensure input is list of lists (not tuples)
    if isinstance(input_grid[0], tuple):
        input_grid = [list(row) for row in input_grid]
    
    non_zero = []
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] > 0:
                non_zero.append((r, c, input_grid[r][c]))
    
    non_zero.sort(key=lambda x: x[2])
    
    if len(non_zero) < 2:
        return input_grid
    
    pos1 = (non_zero[0][0], non_zero[0][1])
    pos2 = (non_zero[1][0], non_zero[1][1])
    dr = pos2[0] - pos1[0]
    dc = pos2[1] - pos1[1]
    
    posN = (non_zero[-1][0], non_zero[-1][1])
    nr = posN[0] + dr
    nc = posN[1] + dc
    
    output_grid = [row[:] for row in input_grid]
    output_grid[nr][nc] = non_zero[-1][2] + 1
    return output_grid
