# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: d7e3b0db
Difficulty: medium

=== Tags ===
- Infer step size
- Image expasion

=== Description ===
The task involves transforming an input grid into an output grid by inferring a
step size from the spatial relationship between two identical non-zero color
pixels. The input grid contains exactly two pixels of the same color (e.g.,
red), positioned either horizontally or vertically aligned, with no other
instances of that color. The step size is determined by the absolute difference
in their row or column indices (e.g., two pixels at (0,2) and (0,5) yield a
horizontal step size of 3). The output grid is generated by scaling the input
grid uniformly: each pixel in the input is replaced by a block of size `step x
step` of the same color, resulting in an output grid with dimensions
`input_width * step` Ã— `input_height * step`. This requires identifying the key
feature (the pair of identical pixels), calculating the step size, and applying
a consistent spatial expansion rule to the entire grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

from common import random_color
import random

def generate():
    s = random.randint(2, 5)
    max_dim = 30 // s
    direction = random.choice(['horizontal', 'vertical'])
    
    if direction == 'horizontal':
        width = random.randint(s + 1, max_dim)
        height = random.randint(1, max_dim)
    else:
        height = random.randint(s + 1, max_dim)
        width = random.randint(1, max_dim)
    
    C = random.randint(1, 9)
    input_grid = [[0] * width for _ in range(height)]
    
    if direction == 'horizontal':
        row = random.randint(0, height - 1)
        col1 = random.randint(0, width - 1 - s)
        col2 = col1 + s
        input_grid[row][col1] = C
        input_grid[row][col2] = C
    else:
        col = random.randint(0, width - 1)
        row1 = random.randint(0, height - 1 - s)
        row2 = row1 + s
        input_grid[row1][col] = C
        input_grid[row2][col] = C
    
    output_grid = []
    for row in input_grid:
        scaled_row = []
        for pixel in row:
            scaled_row.extend([pixel] * s)
        output_grid.extend([scaled_row] * s)
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import defaultdict

def p(input_grid):
    count = defaultdict(int)
    for row in input_grid:
        for color in row:
            if color != 0:
                count[color] += 1
    target_color = None
    for color, cnt in count.items():
        if cnt == 2:
            target_color = color
            break
    if target_color is None:
        step = 2
    else:
        positions = []
        for i, row in enumerate(input_grid):
            for j, color in enumerate(row):
                if color == target_color:
                    positions.append((i, j))
        if len(positions) != 2:
            step = 2
        else:
            (r1, c1), (r2, c2) = positions
            if r1 == r2:
                step = abs(c2 - c1)
            elif c1 == c2:
                step = abs(r2 - r1)
            else:
                step = 2
    height = len(input_grid)
    width = len(input_grid[0])
    output_height = height * step
    output_width = width * step
    output_grid = [[0] * output_width for _ in range(output_height)]
    for i in range(height):
        for j in range(width):
            color = input_grid[i][j]
            for di in range(step):
                for dj in range(step):
                    output_grid[i*step + di][j*step + dj] = color
    return output_grid
