# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 6a550e4f
Difficulty: hard

=== Tags ===
- Pressure release
- Spatial signal
- Synchronized bounce
- Move object to first unoccupied space

=== Description ===
Input grids feature a background color (0) and multiple distinct colored objects
(each a contiguous group of non-background cells, 1–9) placed at various
positions. A spatial signal—a straight horizontal or vertical line of a unique
color (e.g., 5) not used by objects or background—is embedded in the grid. The
signal’s orientation (horizontal/vertical) defines the movement direction:
horizontal signals require vertical movement (up/down), vertical signals require
horizontal movement (left/right). Objects move in this direction toward the
signal line until they reach the first unoccupied cell (background) in their
path. Movement is synchronized: all objects shift simultaneously by the maximum
possible steps without overlapping, stopping if the next cell would collide with
another object, the signal, or grid edge. If objects are aligned to move into
the same cell, they resolve by shifting to the next available space in the
direction, preserving the signal line’s position. The output grid retains all
objects in their new positions (moved as far as possible toward the signal
without overlap), with the spatial signal unchanged and background cells
preserved. The transformation ensures no object overlaps, all movement adheres
to the signal’s direction, and the grid size remains constant.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from copy import deepcopy
from common import grid as make_grid


def _place_contiguous_cluster(ingrid, height, width, size, allowed_cells):
    """Try to place a contiguous cluster of given size on grid. Returns a list of cells or None."""
    # allowed_cells is a set of coordinates (r,c) where placement is permitted
    if not allowed_cells:
        return None
    attempts = 0
    while attempts < 250:
        attempts += 1
        start = random.choice(list(allowed_cells))
        if any(start[i] < 0 for i in range(2)):
            continue
        if start not in allowed_cells:
            continue
        group = [start]
        frontier = [start]
        used = {start}
        while len(group) < size and frontier:
            cell = random.choice(frontier)
            r, c = cell
            neighbors = []
            for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)]:
                nr, nc = r + dr, c + dc
                if nr < 0 or nr >= height or nc < 0 or nc >= width:
                    continue
                if (nr, nc) in used:
                    continue
                if (nr, nc) not in allowed_cells:
                    continue
                neighbors.append((nr, nc))
            if not neighbors:
                frontier.remove(cell)
                continue
            nb = random.choice(neighbors)
            group.append(nb)
            frontier.append(nb)
            used.add(nb)
        if len(group) == size:
            return group
    return None


def generate():
    """Generate one input/output pair for the ARC task.

    The generator places a straight signal (color 5) then several colored contiguous
    objects (colors distinct from the signal). Each object is entirely on one side
    of the signal (for horizontal: above or below; for vertical: left or right).
    Then all objects are moved synchronously toward the signal by the maximum
    integer number of steps so that their translated cells do not overlap each
    other, do not land on signal cells, and stay inside the grid. We require at
    least one step of movement (k>=1); otherwise the placement is retried.
    """
    # Try until we find a configuration where at least one movement step is possible.
    global_attempts = 0
    while True:
        global_attempts += 1
        if global_attempts > 800:
            # As a safety, if too many failures, reduce constraints and try again
            width = random.randint(8, 12)
            height = random.randint(8, 12)
        else:
            width = random.randint(10, 20)
            height = random.randint(10, 20)

        ingrid = make_grid(width, height, 0)
        SIGNAL = 5

        orientation = random.choice(['horizontal', 'vertical'])

        if orientation == 'horizontal':
            # choose a row for the signal that's not on the extreme edges
            signal_row = random.randint(1, height - 2)
            length = random.randint(2, max(2, width - 2))
            start_c = random.randint(0, width - length)
            signal_cells = [(signal_row, c) for c in range(start_c, start_c + length)]
            for (r, c) in signal_cells:
                ingrid[r][c] = SIGNAL
        else:
            signal_col = random.randint(1, width - 2)
            length = random.randint(2, max(2, height - 2))
            start_r = random.randint(0, height - length)
            signal_cells = [(r, signal_col) for r in range(start_r, start_r + length)]
            for (r, c) in signal_cells:
                ingrid[r][c] = SIGNAL

        # Choose object colors (distinct and not SIGNAL)
        allowed_colors = [c for c in range(1, 10) if c != SIGNAL]
        num_objects = random.randint(2, 5)
        if num_objects > len(allowed_colors):
            num_objects = len(allowed_colors)
        colors = random.sample(allowed_colors, num_objects)

        objects = []  # list of tuples (color, set_of_cells)
        placement_failed = False

        # Place each object entirely on one side of the signal
        for color in colors:
            size = random.randint(1, 5)
            placed = False
            # Build allowed cells set for this object depending on orientation and chosen side
            attempts_side = 0
            while not placed and attempts_side < 200:
                attempts_side += 1
                if orientation == 'horizontal':
                    side = random.choice(['above', 'below'])
                    if side == 'above':
                        allowed = {(r, c) for r in range(0, signal_row) for c in range(width) if ingrid[r][c] == 0}
                    else:
                        allowed = {(r, c) for r in range(signal_row + 1, height) for c in range(width) if ingrid[r][c] == 0}
                else:
                    side = random.choice(['left', 'right'])
                    if side == 'left':
                        allowed = {(r, c) for r in range(height) for c in range(0, signal_col) if ingrid[r][c] == 0}
                    else:
                        allowed = {(r, c) for r in range(height) for c in range(signal_col + 1, width) if ingrid[r][c] == 0}

                if not allowed:
                    continue

                cluster = _place_contiguous_cluster(ingrid, height, width, size, allowed)
                if cluster is None:
                    continue
                # commit the cluster
                for (r, c) in cluster:
                    ingrid[r][c] = color
                objects.append((color, set(cluster)))
                placed = True
            if not placed:
                placement_failed = True
                break

        if placement_failed or len(objects) == 0:
            # try again
            continue

        # Compute directions per object (toward the signal)
        signal_set = set(signal_cells)
        directions = []  # list of (dr, dc) for each object
        for (color, cells) in objects:
            rows = [r for (r, c) in cells]
            cols = [c for (r, c) in cells]
            if orientation == 'horizontal':
                # If the object is above the signal row (all rows < signal_row) it moves down (dr=1)
                # If below (all rows > signal_row) it moves up (dr=-1)
                if max(rows) < signal_row:
                    directions.append((1, 0))
                elif min(rows) > signal_row:
                    directions.append((-1, 0))
                else:
                    # This object would overlap the signal row; abort and retry
                    placement_failed = True
                    break
            else:
                if max(cols) < signal_col:
                    directions.append((0, 1))
                elif min(cols) > signal_col:
                    directions.append((0, -1))
                else:
                    placement_failed = True
                    break
        if placement_failed:
            continue

        # Find the maximum synchronous shift k such that after translating every object's cells
        # by k*(dr,dc) the new positions are inside bounds, do not land on a signal cell,
        # and do not overlap with each other.
        max_k = 0
        limit = max(height, width)
        for k in range(1, limit + 1):
            new_positions_all = []
            ok = True
            for (color, cells), (dr, dc) in zip(objects, directions):
                new_cells = {(r + dr * k, c + dc * k) for (r, c) in cells}
                # bounds check
                for (nr, nc) in new_cells:
                    if nr < 0 or nr >= height or nc < 0 or nc >= width:
                        ok = False
                        break
                    if (nr, nc) in signal_set:
                        ok = False
                        break
                if not ok:
                    break
                new_positions_all.append(new_cells)
            if not ok:
                break
            # Check pairwise overlaps across all objects
            union_all = set()
            total = 0
            for s in new_positions_all:
                total += len(s)
                union_all |= s
            if total != len(union_all):
                break
            # Valid k
            max_k = k

        if max_k < 1:
            # nothing would move; try again
            continue

        # Build output grid by moving objects by max_k
        output = [row[:] for row in ingrid]
        # clear original object cells
        for (color, cells) in objects:
            for (r, c) in cells:
                output[r][c] = 0
        # paint moved objects
        for (color, cells), (dr, dc) in zip(objects, directions):
            for (r, c) in cells:
                nr, nc = r + dr * max_k, c + dc * max_k
                output[nr][nc] = color

        # ensure input != output
        if output == ingrid:
            continue

        return {"input": ingrid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # If the special signal color 5 exists, use it deterministically as the signal
    colors_present = set()
    for r in range(height):
        for c in range(width):
            val = grid[r][c]
            if val != 0:
                colors_present.add(val)

    signal_color = None
    signal_cells = []
    orientation_flag = None

    if 5 in colors_present:
        signal_color = 5
        signal_cells = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == 5]
        # detect orientation
        if len(signal_cells) > 0:
            if all(r == signal_cells[0][0] for r, c in signal_cells):
                orientation_flag = 'h'
            else:
                orientation_flag = 'v'
    else:
        # Find candidate signal colors: a color that forms a straight horizontal or vertical contiguous line
        candidates = []
        for color in colors_present:
            coords = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == color]
            if len(coords) < 2:
                continue
            rows = [r for (r, c) in coords]
            cols = [c for (r, c) in coords]
            # horizontal candidate
            if all(r == rows[0] for r in rows):
                sorted_cs = sorted(cols)
                if sorted_cs == list(range(sorted_cs[0], sorted_cs[-1] + 1)):
                    candidates.append((len(coords), color, 'h', coords))
            # vertical candidate
            if all(c == cols[0] for c in cols):
                sorted_rs = sorted(rows)
                if sorted_rs == list(range(sorted_rs[0], sorted_rs[-1] + 1)):
                    candidates.append((len(coords), color, 'v', coords))
        if candidates:
            candidates.sort(reverse=True)
            _, signal_color, orientation_flag, signal_cells = candidates[0]
        else:
            # no clear signal found; nothing to do
            return grid

    signal_set = set(signal_cells)

    # Detect objects (connected components by color, excluding background and signal color)
    visited = [[False] * width for _ in range(height)]
    objects = []  # list of (color, set_of_cells)
    for r in range(height):
        for c in range(width):
            if visited[r][c]:
                continue
            val = grid[r][c]
            if val == 0 or val == signal_color:
                visited[r][c] = True
                continue
            # flood fill for this color
            color = val
            queue = [(r, c)]
            visited[r][c] = True
            comp = []
            while queue:
                cr, cc = queue.pop(0)
                comp.append((cr, cc))
                for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)]:
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                        visited[nr][nc] = True
                        queue.append((nr, nc))
            objects.append((color, set(comp)))

    if not objects:
        return grid

    # Determine movement directions for each object (toward the signal)
    directions = []
    if orientation_flag == 'h':
        # find a representative signal row
        signal_row = signal_cells[0][0]
        for color, cells in objects:
            rows = [r for (r, c) in cells]
            if max(rows) < signal_row:
                directions.append((1, 0))
            elif min(rows) > signal_row:
                directions.append((-1, 0))
            else:
                # object overlaps the signal row - it cannot move
                directions.append((0, 0))
    else:
        signal_col = signal_cells[0][1]
        for color, cells in objects:
            cols = [c for (r, c) in cells]
            if max(cols) < signal_col:
                directions.append((0, 1))
            elif min(cols) > signal_col:
                directions.append((0, -1))
            else:
                directions.append((0, 0))

    # Compute maximum synchronous shift k
    max_k = 0
    limit = max(height, width)
    for k in range(1, limit + 1):
        all_new_sets = []
        ok = True
        for (color, cells), (dr, dc) in zip(objects, directions):
            if (dr, dc) == (0, 0):
                ok = False
                break
            new_cells = {(r + dr * k, c + dc * k) for (r, c) in cells}
            for (nr, nc) in new_cells:
                if nr < 0 or nr >= height or nc < 0 or nc >= width:
                    ok = False
                    break
                if (nr, nc) in signal_set:
                    ok = False
                    break
            if not ok:
                break
            all_new_sets.append(new_cells)
        if not ok:
            break
        union = set()
        total = 0
        for s in all_new_sets:
            total += len(s)
            union |= s
        if total != len(union):
            break
        max_k = k

    # Build output grid by moving objects by max_k
    output = [row[:] for row in grid]
    # clear original object cells
    for color, cells in objects:
        for (r, c) in cells:
            output[r][c] = 0
    # paint moved objects
    for (color, cells), (dr, dc) in zip(objects, directions):
        for (r, c) in cells:
            nr, nc = r + dr * max_k, c + dc * max_k
            output[nr][nc] = color

    return output

