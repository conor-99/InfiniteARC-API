# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 7fc89ce7
Difficulty: hard

=== Tags ===
- Teleporter network routing
- Gravity with barriers
- Rule gate simulation
- Inverse rule reconstruction
- Select every nth column
- Count hor lines

=== Description ===
Teleporter Gravity Gates  Input grids depict a vertical environment with gravity
pulling elements downward. The grid contains: - **Barriers** (color 1): Solid
blocks that block vertical movement. - **Teleporter pairs** (color 2): Two
identical color 2 points that form a bidirectional connection; elements hitting
one teleporter instantly move to the other. - **Elements** (color 3): Mobile
entities that fall under gravity until blocked. - **Horizontal line segments**
(color 4): Contiguous horizontal runs of color 4 spanning at least two cells;
each such segment is counted to determine a key parameter. - **Rule gates**
(color 5): Cells that alter the behavior of elements passing through them,
typically reversing their movement direction or changing their color.  The
transformation follows these steps: 1. **Count horizontal line segments (N)**:
Count all contiguous horizontal segments of color 4 (each segment must span ≥2
cells). This count N determines subsequent operations. 2. **Apply gravity**:
Elements (color 3) fall downward until they contact a barrier (color 1) or the
grid bottom. 3. **Teleportation**: Elements now on teleporter (color 2) are
instantly moved to their paired teleporter location. 4. **Rule gate
processing**: Elements now occupying a rule gate (color 5) have their color
inverted (e.g., color 3 becomes color 6) or direction reversed (though direction
is static in the output grid, color inversion is used as the effect). 5.
**Column selection**: The output grid retains only columns whose index is a
multiple of N (0-based). All elements in non-selected columns are removed (set
to background), and the remaining columns are preserved in their original order.
The background remains color 0, and all transformations are applied in sequence.
The output grid must be a valid 2D grid with dimensions ≤30×30, using colors
0–9.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, all_pixels

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = grid(width, height, 0)

    # Place barriers (color 1)
    for _ in range(10):
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        input_grid[r][c] = 1

    # Place teleporter pairs (color 2)
    teleporters = []
    while len(teleporters) < 2:
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        if input_grid[r][c] == 0:
            teleporters.append((r, c))
            input_grid[r][c] = 2
    if len(teleporters) != 2:
        return generate()

    # Place elements (color 3)
    for _ in range(5):
        r = random.randint(0, height-2)
        c = random.randint(0, width-1)
        if input_grid[r][c] == 0:
            input_grid[r][c] = 3

    # Generate horizontal segments (color 4)
    for r in range(height):
        c = 0
        while c < width:
            if random.random() > 0.7:
                if width - c >= 2:
                    length = random.randint(2, min(5, width - c))
                    for dc in range(length):
                        input_grid[r][c + dc] = 4
                    c += length
                else:
                    c += 1
            else:
                c += 1

    # Place rule gates (color 5)
    for _ in range(3):
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        if input_grid[r][c] == 0:
            input_grid[r][c] = 5

    # Compute N (number of horizontal segments of color 4)
    N = 0
    for r in range(height):
        c = 0
        while c < width:
            if input_grid[r][c] == 4:
                start = c
                while c < width and input_grid[r][c] == 4:
                    c += 1
                length = c - start
                if length >= 2:
                    N += 1
            else:
                c += 1
    if N == 0:
        N = 1

    # Apply gravity to elements
    gravity_grid = [row[:] for row in input_grid]
    for c in range(width):
        elements = [r for r in range(height) if gravity_grid[r][c] == 3]
        available = [r for r in range(height-1, -1, -1) if gravity_grid[r][c] == 0]
        for i in range(len(elements)):
            if i < len(available):
                gravity_grid[available[i]][c] = 3
        for r in elements:
            gravity_grid[r][c] = 0

    # Teleportation
    teleport_grid = [row[:] for row in gravity_grid]
    teleporters = [(r, c) for r in range(height) for c in range(width) if input_grid[r][c] == 2]
    if len(teleporters) == 2:
        (r1, c1), (r2, c2) = teleporters
        for r in range(height):
            for c in range(width):
                if teleport_grid[r][c] == 3 and input_grid[r][c] == 2:
                    if (r, c) == (r1, c1):
                        teleport_grid[r1][c1] = 0
                        teleport_grid[r2][c2] = 3
                    else:
                        teleport_grid[r2][c2] = 0
                        teleport_grid[r1][c1] = 3

    # Rule gates
    rule_grid = [row[:] for row in teleport_grid]
    for r in range(height):
        for c in range(width):
            if rule_grid[r][c] == 3 and input_grid[r][c] == 5:
                rule_grid[r][c] = 6

    # Select columns
    selected_cols = [c for c in range(width) if c % N == 0]
    output_grid = []
    for r in range(height):
        output_grid.append([rule_grid[r][c] for c in selected_cols])

    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Ensure input is list of lists
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    
    # Count horizontal segments of color 4
    N = 0
    for r in range(height):
        c = 0
        while c < width:
            if input_grid[r][c] == 4:
                start = c
                while c < width and input_grid[r][c] == 4:
                    c += 1
                length = c - start
                if length >= 2:
                    N += 1
            else:
                c += 1
    if N == 0:
        N = 1

    # Apply gravity
    gravity_grid = [row[:] for row in input_grid]
    for c in range(width):
        elements = [r for r in range(height) if gravity_grid[r][c] == 3]
        available = [r for r in range(height-1, -1, -1) if gravity_grid[r][c] == 0]
        for i in range(len(elements)):
            if i < len(available):
                gravity_grid[available[i]][c] = 3
        for r in elements:
            gravity_grid[r][c] = 0

    # Teleportation
    teleport_grid = [row[:] for row in gravity_grid]
    teleporters = [(r, c) for r in range(height) for c in range(width) if input_grid[r][c] == 2]
    if len(teleporters) == 2:
        (r1, c1), (r2, c2) = teleporters
        for r in range(height):
            for c in range(width):
                if teleport_grid[r][c] == 3 and input_grid[r][c] == 2:
                    if (r, c) == (r1, c1):
                        teleport_grid[r1][c1] = 0
                        teleport_grid[r2][c2] = 3
                    else:
                        teleport_grid[r2][c2] = 0
                        teleport_grid[r1][c1] = 3

    # Rule gates
    rule_grid = [row[:] for row in teleport_grid]
    for r in range(height):
        for c in range(width):
            if rule_grid[r][c] == 3 and input_grid[r][c] == 5:
                rule_grid[r][c] = 6

    # Select columns
    selected_cols = [c for c in range(width) if c % N == 0]
    output_grid = []
    for r in range(height):
        output_grid.append([rule_grid[r][c] for c in selected_cols])
    
    return output_grid
