# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: f6d306b3
Difficulty: very hard

=== Tags ===
- Cut and unfold
- Dependency topological sort
- Momentum conservation path
- Synchronized bounce
- Fill smallest enclosed hole
- Rectangle guessing

=== Description ===
Input grids are large (20×20 to 30×30) with a single background color (0). They
contain multiple axis-aligned rectangular regions, each defined by a distinct
color (1–9) and forming solid blocks with no internal holes (all cells within
their minimal bounding boxes are part of the rectangle). Scattered across the
grid are "cut lines" (diagonal or orthogonal edges) marking where rectangles may
be removed. A token path begins at the left edge (middle row) moving right,
traversing background cells (0) and bouncing off rectangle edges with momentum
conservation: each collision causes a 90° counterclockwise direction change
(right → up → left → down → right). Each rectangle hit by the path is marked for
cutting, but cutting occurs in a topological order determined by containment
dependencies (inner rectangles must be cut before outer ones). After all
rectangles are cut in this order, the token path is redrawn on the modified grid
(with cut rectangles now background). The smallest enclosed hole (a connected
background region completely surrounded by non-background cells) is then filled
with color 9. "Rectangle guessing" requires the solver to infer exact rectangle
boundaries from color clusters before processing dependencies. "Synchronized
bounce" ensures consistent direction changes across all collisions, while "cut
and unfold" refers to the grid modification after cutting rectangles, revealing
hidden path trajectories.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common
from typing import List, Tuple, Dict, Optional


def simulate_path(grid: List[List[int]], rect_colors: Optional[set]=None, colorize_by_start=True) -> Tuple[List[Tuple[int,int]], set]:
    """
    Simulate a token path starting at the left edge middle row moving right.
    The token traverses background cells (0). When the next cell in the
    current direction is non-zero it collides and turns 90 degrees CCW
    (dr,dc) -> (-dc,dr). The token does not enter non-zero cells.

    Returns the list of visited coordinates (including start) and the set
    of non-zero colors that were collided with (if rect_colors is provided,
    only collisions with those colors are recorded as hits).
    """
    height = len(grid)
    width = len(grid[0])
    r = height // 2
    c = 0
    dr, dc = 0, 1
    path = [(r, c)]
    hits = set()
    start_color = grid[r][c]

    seen_states = set()
    steps = 0
    while True:
        if steps > 10000:
            break
        steps += 1
        nr, nc = r + dr, c + dc
        # would exit?
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        if grid[nr][nc] == 0:
            r, c = nr, nc
            path.append((r, c))
            continue
        # collision
        collided_color = grid[nr][nc]
        if rect_colors is None or collided_color in rect_colors:
            hits.add(collided_color)
        # rotate 90 deg CCW
        dr, dc = -dc, dr
        state = (r, c, dr, dc)
        if state in seen_states:
            # stuck in a loop of rotations without progress
            break
        seen_states.add(state)
    return path, hits


def find_smallest_hole(grid: List[List[int]]) -> Optional[List[Tuple[int,int]]]:
    height = len(grid)
    width = len(grid[0])
    visited = [[False]*width for _ in range(height)]
    holes = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 or visited[r][c]:
                continue
            queue = [(r,c)]
            visited[r][c] = True
            region = []
            is_enclosed = True
            qi = 0
            while qi < len(queue):
                rr, cc = queue[qi]
                qi += 1
                region.append((rr, cc))
                for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                    nr, nc = rr + dr, cc + dc
                    if nr < 0 or nr >= height or nc < 0 or nc >= width:
                        is_enclosed = False
                        continue
                    if grid[nr][nc] == 0 and not visited[nr][nc]:
                        visited[nr][nc] = True
                        queue.append((nr, nc))
            if is_enclosed:
                holes.append((len(region), region))
    if not holes:
        return None
    holes.sort(key=lambda x: x[0])
    return holes[0][1]


def topological_sort(nodes: List[int], edges: Dict[int, List[int]], areas: Dict[int,int]) -> List[int]:
    # Kahn's algorithm with deterministic tie-breaking by (area, color)
    indeg = {n: 0 for n in nodes}
    for u in edges:
        for v in edges[u]:
            if v in indeg:
                indeg[v] += 1
    available = sorted([n for n in nodes if indeg[n] == 0], key=lambda x: (areas.get(x,0), x))
    result = []
    while available:
        n = available.pop(0)
        result.append(n)
        for v in edges.get(n, []):
            if v not in indeg:
                continue
            indeg[v] -= 1
            if indeg[v] == 0:
                # insert keeping deterministic order
                available.append(v)
                available.sort(key=lambda x: (areas.get(x,0), x))
    if len(result) != len(nodes):
        # cycle fallback: sort by (area,color)
        return sorted(nodes, key=lambda x: (areas.get(x,0), x))
    return result


def generate() -> dict:
    # Random large grid
    size = random.randint(20, 30)
    grid = common.grid(size, size, 0)

    # Colors: reserve 9 for final hole fill
    reserved_fill = 9
    available_colors = [c for c in range(1, 9)]  # 1..8 available for rectangles / token / ring

    # choose a path token color and a ring (hole) border color
    path_color = random.choice(available_colors)
    available_colors.remove(path_color)
    ring_color = random.choice(available_colors)
    available_colors.remove(ring_color)

    # number of filled rectangles (solid blocks)
    max_rects = min(5, len(available_colors))
    num_rects = random.randint(2, max_rects)
    rect_colors = random.sample(available_colors, num_rects)

    # keep track of occupied cells to avoid overlap
    occupied = [[False]*size for _ in range(size)]

    rectangles = {}  # color -> (min_r, min_c, max_r, max_c)

    mid_row = size // 2

    # helper to check overlap
    def area_free(r0, c0, h, w):
        if r0 < 1 or c0 < 1 or r0+h > size-1 or c0+w > size-1:
            return False
        for rr in range(r0, r0+h):
            for cc in range(c0, c0+w):
                if occupied[rr][cc]:
                    return False
        return True

    def mark_area(r0, c0, h, w, color):
        for rr in range(r0, r0+h):
            for cc in range(c0, c0+w):
                occupied[rr][cc] = True
                grid[rr][cc] = color

    # First, place one rectangle that intersects the middle row to guarantee a hit.
    first_color = rect_colors[0]
    placed = False
    attempts = 0
    while not placed and attempts < 200:
        attempts += 1
        h = random.randint(2, max(2, size//6))
        w = random.randint(2, max(2, size//6))
        min_r = random.randint(max(1, mid_row - h + 1), min(mid_row, size - h - 2))
        min_c = random.randint(3, max(3, size - w - 3))
        if area_free(min_r, min_c, h, w):
            mark_area(min_r, min_c, h, w, first_color)
            rectangles[first_color] = (min_r, min_c, min_r + h - 1, min_c + w - 1)
            placed = True
    # Place remaining rectangles
    for color in rect_colors[1:]:
        placed = False
        attempts = 0
        while not placed and attempts < 400:
            attempts += 1
            h = random.randint(2, max(2, size//8))
            w = random.randint(2, max(2, size//8))
            min_r = random.randint(1, size - h - 2)
            min_c = random.randint(1, size - w - 2)
            if area_free(min_r, min_c, h, w):
                mark_area(min_r, min_c, h, w, color)
                rectangles[color] = (min_r, min_c, min_r + h - 1, min_c + w - 1)
                placed = True
        if not placed:
            # if placement failed, skip this rectangle
            continue

    # Place a hollow ring (border) to create an enclosed hole; do not let it overlap rectangles
    ring_placed = False
    attempts = 0
    while not ring_placed and attempts < 200:
        attempts += 1
        rw = random.randint(5, max(5, size//4))
        rh = random.randint(5, max(5, size//4))
        min_r = random.randint(2, size - rh - 3)
        min_c = random.randint(2, size - rw - 3)
        # check the border cells don't overlap existing rectangles
        ok = True
        for rr in range(min_r, min_r + rh):
            for cc in range(min_c, min_c + rw):
                if rr in (min_r, min_r + rh - 1) or cc in (min_c, min_c + rw - 1):
                    if occupied[rr][cc]:
                        ok = False
                        break
            if not ok:
                break
        if not ok:
            continue
        # draw border
        for rr in range(min_r, min_r + rh):
            for cc in range(min_c, min_c + rw):
                if rr in (min_r, min_r + rh - 1) or cc in (min_c, min_c + rw - 1):
                    grid[rr][cc] = ring_color
                    occupied[rr][cc] = True
        ring_placed = True
        ring_bbox = (min_r, min_c, min_r+rh-1, min_c+rw-1)

    # place the token at left edge middle row
    grid[mid_row][0] = path_color

    # Make an input copy
    input_grid = [row[:] for row in grid]

    # identify solid rectangles by colors (we already have them in rectangles dict)
    rects_info = dict(rectangles)  # color -> bbox

    # simulate path on the original grid and collect hits (only considering solid rectangle colors)
    path1, hits = simulate_path(input_grid, rect_colors=set(rects_info.keys()), colorize_by_start=True)

    # determine dependency edges among rectangles (inner -> outer)
    edges = {}
    areas = {}
    colors_list = list(rects_info.keys())
    for c in colors_list:
        r0, c0, r1, c1 = rects_info[c]
        areas[c] = (r1 - r0 + 1) * (c1 - c0 + 1)
    for a in colors_list:
        ra0, ca0, ra1, ca1 = rects_info[a]
        for b in colors_list:
            if a == b:
                continue
            rb0, cb0, rb1, cb1 = rects_info[b]
            # if a strictly contains b
            if ra0 <= rb0 and ca0 <= cb0 and ra1 >= rb1 and ca1 >= cb1:
                # inner b must be cut before outer a -> edge b -> a
                edges.setdefault(b, []).append(a)

    # Only cut rectangles that were hit by the path
    hit_rects = [c for c in rects_info.keys() if c in hits]
    # topologically sort hit_rects according to dependencies
    order = topological_sort(hit_rects, edges, areas)

    # produce output: start from input copy
    output_grid = [row[:] for row in input_grid]

    # cut rectangles in order
    for col in order:
        r0, c0, r1, c1 = rects_info[col]
        for rr in range(r0, r1+1):
            for cc in range(c0, c1+1):
                if output_grid[rr][cc] == col:
                    output_grid[rr][cc] = 0

    # redraw path on the modified grid
    path2, _ = simulate_path(output_grid, rect_colors=set(rects_info.keys()), colorize_by_start=True)
    # paint the path with the path_color (start token color)
    for rr, cc in path2:
        output_grid[rr][cc] = path_color

    # fill the smallest enclosed hole with color 9
    hole = find_smallest_hole(output_grid)
    if hole:
        for rr, cc in hole:
            output_grid[rr][cc] = reserved_fill

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
from typing import List, Tuple, Dict, Optional


def simulate_path(grid: List[List[int]], rect_colors: Optional[set]=None) -> Tuple[List[Tuple[int,int]], set]:
    height = len(grid)
    width = len(grid[0])
    r = height // 2
    c = 0
    dr, dc = 0, 1
    path = [(r, c)]
    hits = set()
    seen_states = set()
    steps = 0
    while True:
        if steps > 10000:
            break
        steps += 1
        nr, nc = r + dr, c + dc
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        if grid[nr][nc] == 0:
            r, c = nr, nc
            path.append((r, c))
            continue
        collided_color = grid[nr][nc]
        if rect_colors is None or collided_color in rect_colors:
            hits.add(collided_color)
        dr, dc = -dc, dr
        state = (r, c, dr, dc)
        if state in seen_states:
            break
        seen_states.add(state)
    return path, hits


def find_smallest_hole(grid: List[List[int]]):
    height = len(grid)
    width = len(grid[0])
    visited = [[False]*width for _ in range(height)]
    holes = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 or visited[r][c]:
                continue
            queue = [(r,c)]
            visited[r][c] = True
            region = []
            is_enclosed = True
            qi = 0
            while qi < len(queue):
                rr, cc = queue[qi]
                qi += 1
                region.append((rr, cc))
                for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                    nr, nc = rr + dr, cc + dc
                    if nr < 0 or nr >= height or nc < 0 or nc >= width:
                        is_enclosed = False
                        continue
                    if grid[nr][nc] == 0 and not visited[nr][nc]:
                        visited[nr][nc] = True
                        queue.append((nr, nc))
            if is_enclosed:
                holes.append((len(region), region))
    if not holes:
        return None
    holes.sort(key=lambda x: x[0])
    return holes[0][1]


def topological_sort(nodes: List[int], edges: Dict[int, List[int]], areas: Dict[int,int]) -> List[int]:
    indeg = {n: 0 for n in nodes}
    for u in edges:
        for v in edges[u]:
            if v in indeg:
                indeg[v] += 1
    available = sorted([n for n in nodes if indeg[n] == 0], key=lambda x: (areas.get(x,0), x))
    result = []
    while available:
        n = available.pop(0)
        result.append(n)
        for v in edges.get(n, []):
            if v not in indeg:
                continue
            indeg[v] -= 1
            if indeg[v] == 0:
                available.append(v)
                available.sort(key=lambda x: (areas.get(x,0), x))
    if len(result) != len(nodes):
        return sorted(nodes, key=lambda x: (areas.get(x,0), x))
    return result


def p(input_grid: Tuple[Tuple[int]]) -> Tuple[Tuple[int]]:
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # find all colors present (non-zero)
    colors_present = set()
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                colors_present.add(grid[r][c])

    # identify solid filled rectangles: for each color compute bbox and verify filled
    rects = {}
    for color in colors_present:
        if color == 0:
            continue
        min_r = height
        min_c = width
        max_r = -1
        max_c = -1
        coords = []
        for r in range(height):
            for c in range(width):
                if grid[r][c] == color:
                    coords.append((r,c))
                    if r < min_r: min_r = r
                    if r > max_r: max_r = r
                    if c < min_c: min_c = c
                    if c > max_c: max_c = c
        if not coords:
            continue
        # check if all cells in bbox are the same color -> solid rectangle
        is_solid = True
        for rr in range(min_r, max_r+1):
            for cc in range(min_c, max_c+1):
                if grid[rr][cc] != color:
                    is_solid = False
                    break
            if not is_solid:
                break
        if is_solid:
            rects[color] = (min_r, min_c, max_r, max_c)

    # simulate path on original grid to discover which rectangles are hit
    path1, hits = simulate_path(grid, rect_colors=set(rects.keys()))

    # build dependency edges among rectangles (inner -> outer)
    edges = {}
    areas = {}
    colors = list(rects.keys())
    for c in colors:
        r0, c0, r1, c1 = rects[c]
        areas[c] = (r1 - r0 + 1) * (c1 - c0 + 1)
    for a in colors:
        ra0, ca0, ra1, ca1 = rects[a]
        for b in colors:
            if a == b:
                continue
            rb0, cb0, rb1, cb1 = rects[b]
            if ra0 <= rb0 and ca0 <= cb0 and ra1 >= rb1 and ca1 >= cb1:
                edges.setdefault(b, []).append(a)

    # restrict to hit rectangles
    hit_rects = [c for c in rects.keys() if c in hits]
    order = topological_sort(hit_rects, edges, areas)

    # produce output by cutting rectangles in order
    out = [row[:] for row in grid]
    for color in order:
        r0, c0, r1, c1 = rects[color]
        for rr in range(r0, r1+1):
            for cc in range(c0, c1+1):
                if out[rr][cc] == color:
                    out[rr][cc] = 0

    # redraw the path on modified grid
    path2, _ = simulate_path(out, rect_colors=set(rects.keys()))
    # the path color is the original start cell color
    start_color = grid[height//2][0]
    for rr, cc in path2:
        out[rr][cc] = start_color

    # fill smallest enclosed hole with color 9
    hole = find_smallest_hole(out)
    if hole:
        for rr, cc in hole:
            out[rr][cc] = 9

    return tuple(tuple(row) for row in out)

