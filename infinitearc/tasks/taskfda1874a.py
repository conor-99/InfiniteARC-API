# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: fda1874a
Difficulty: insane

=== Tags ===
- Stacked layer alignment
- Recursive mirroring

=== Description ===
Input grids consist of three concentric rectangular layers (frames) within a
large grid (20x20 minimum), each separated by 1-2 background cells. Each layer
contains a complex, non-symmetrical pattern of colored cells (using 1-8 as
symbols), forming a nested hierarchy where each outer layer's pattern is a
precise mirror of the inner layer's pattern. The mirroring direction alternates
sequentially: the outermost layer mirrors the middle layer horizontally, the
middle layer mirrors the innermost layer vertically, and the innermost layer's
pattern would require a horizontal mirror to generate the next layer in the
sequence. The patterns within each layer are geometrically intricate (e.g.,
diagonal lines, nested shapes, or fragmented clusters), with no two layers
sharing identical structures. The background color is uniform (color 0), and all
layers maintain consistent frame thickness (2-3 cells).   The output grid
extends this sequence by adding a new innermost layer. This layer's pattern is
generated by applying the alternating mirroring rule to the current innermost
layer's pattern: since the middle layer mirrored the innermost layer vertically,
the new layer must be horizontally mirrored relative to the innermost layer. The
existing layers remain visually unchanged, with all inter-layer spacing
preserved. The transformation requires identifying the recursive mirroring
sequence across all three layers, applying the next direction in the alternating
pattern, and precisely reconstructing the mirrored structure within the new
inner frame. No color values or numerical properties are usedâ€”only geometric
relationships between the patterns in adjacent layers.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import random_pixels, grid

def generate():
    size = 25
    input_grid = grid(size, size, 0)
    inner_size = 5
    inner_area = (10, 10)

    # Generate inner pattern
    inner_pixels = random_pixels(inner_size, inner_size, 0.5)
    for r, c in inner_pixels:
        input_grid[inner_area[0] + r][inner_area[1] + c] = random.randint(1, 9)

    output_grid = [row[:] for row in input_grid]
    # Copy inner pattern horizontally mirrored to new location
    for r, c in inner_pixels:
        new_r = inner_size - 1 - r
        new_c = c
        if 1 <= new_r <= 3 and 1 <= new_c <= 3:
            output_grid[inner_area[0] + new_r][inner_area[1] + new_c] = input_grid[inner_area[0] + r][inner_area[1] + c]
    return {
        'input': input_grid,
        'output': output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    inner_area = (10, 10)
    inner_size = 5
    inner_pixels = []
    for r in range(inner_size):
        for c in range(inner_size):
            if input_grid[inner_area[0] + r][inner_area[1] + c] != 0:
                inner_pixels.append((r, c))
    # Ensure output_grid is list of lists (not tuples)
    output_grid = [list(row) for row in input_grid]
    for r, c in inner_pixels:
        new_r = inner_size - 1 - r
        new_c = c
        if 1 <= new_r <= 3 and 1 <= new_c <= 3:
            output_grid[inner_area[0] + new_r][inner_area[1] + new_c] = input_grid[inner_area[0] + r][inner_area[1] + c]
    return output_grid
