# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: e4d12d1e
Difficulty: insane

=== Tags ===
- Quine grid
- Nonlocal dependency

=== Description ===
The task involves transforming an input grid into an output grid through a
reflection operation over a unique key cell. The input grid contains exactly one
instance of color 5 (the key cell), positioned at coordinates (r, c). The output
grid is generated by reflecting every cell (i, j) in the input over the key
cell, such that the value at position (i, j) in the output corresponds to the
input value at (2r - i, 2c - j). This reflection creates a nonlocal dependency,
as each output cellâ€™s value is determined by an input cell that may be far from
its position. The transformation is deterministic and based solely on the key
cell's location, requiring the solver to identify the unique color 5 cell and
apply the reflection rule. The input grid must be asymmetric with respect to the
key cell to ensure the output grid differs from the input, and the key cell must
be positioned to keep all reflected coordinates within grid bounds. This task
demands visual pattern recognition of the key cell and precise geometric
reasoning to execute the reflection, making it challenging for human solvers due
to the need to mentally compute nonlocal relationships across the grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def is_symmetric(grid, r, c):
    H = len(grid)
    W = len(grid[0])
    for i in range(H):
        for j in range(W):
            if grid[i][j] != grid[2*r - i][2*c - j]:
                return False
    return True

def generate():
    while True:
        H = random.choice([h for h in range(3, 30, 2)])
        W = random.choice([w for w in range(3, 30, 2)])
        r = (H-1)//2
        c = (W-1)//2
        input_grid = common.grid(W, H, 0)
        colors = [i for i in range(10) if i != 5]
        for i in range(H):
            for j in range(W):
                if i == r and j == c:
                    input_grid[i][j] = 5
                else:
                    input_grid[i][j] = random.choice(colors)
        if not is_symmetric(input_grid, r, c):
            break
    output_grid = common.grid(W, H, 0)
    for i in range(H):
        for j in range(W):
            output_grid[i][j] = input_grid[2*r - i][2*c - j]
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
def p(input_grid):
    r, c = -1, -1
    for i in range(len(input_grid)):
        for j in range(len(input_grid[0])):
            if input_grid[i][j] == 5:
                r, c = i, j
    H = len(input_grid)
    W = len(input_grid[0])
    output_grid = common.grid(W, H, 0)
    for i in range(H):
        for j in range(W):
            output_grid[i][j] = input_grid[2*r - i][2*c - j]
    return output_grid
