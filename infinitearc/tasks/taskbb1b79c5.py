# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: bb1b79c5
Difficulty: medium–hard

=== Tags ===
- Pattern guided construction
- Compositional reflection
- Collapse duplicates

=== Description ===
Input grids consist of a uniform background color (0) with multiple distinct,
non-overlapping colored regions (each region is a contiguous block of identical
non-zero colors). Each region is a rectangle of size at least 1×1, and all
regions are separated by at least one background cell. The grid dimensions range
from 5×5 to 30×30, with regions distributed such that their vertical reflection
over the grid's midline would cause some regions to overlap with other regions
or their own reflections.  The output grid is constructed by reflecting the
input grid across its vertical midline (left-right flip). For any cell that,
after reflection, would contain a non-background color overlapping with a non-
background color from the original grid (i.e., the cell and its mirror position
both contain non-background colors), the output retains the color from the
reflected position (effectively "collapsing" the overlap by prioritizing the
reflected color). Regions that do not overlap with their reflected counterparts
are simply mirrored. Background cells remain unchanged, and the reflection
process does not alter the grid's dimensions. The transformation ensures that
all reflected regions are visually distinct in the output, with overlapping
regions resolving to a single color via the reflection priority rule.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = common.grid(width, height, 0)
    
    num_regions = random.randint(2, 5)
    colors = common.random_colors(num_regions, exclude=[0])
    
    for color in colors:
        r = random.randint(0, height - 1)
        c = random.randint(0, width - 1)
        h = random.randint(1, min(5, height - r))
        w = random.randint(1, min(5, width - c))
        
        all_bg = True
        for dr in range(h):
            for dc in range(w):
                if grid[r + dr][c + dc] != 0:
                    all_bg = False
                    break
            if not all_bg:
                break
        
        if all_bg:
            for dr in range(h):
                for dc in range(w):
                    grid[r + dr][c + dc] = color
    
    # Check symmetry and break if symmetric
    is_symmetric = True
    for r in range(height):
        for c in range(width // 2):
            if grid[r][c] != grid[r][width - 1 - c]:
                is_symmetric = False
                break
        if not is_symmetric:
            break
    
    if is_symmetric:
        r = random.randint(0, height - 1)
        c = random.randint(0, width // 2 - 1)
        if grid[r][c] != 0:
            new_color = (grid[r][c] % 9) + 1
            grid[r][c] = new_color
        else:
            grid[r][c] = random.choice([1, 2, 3, 4, 5, 6, 7, 8, 9])
    
    output = [row[::-1] for row in grid]
    
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    flipped = [row[::-1] for row in grid]
    return tuple(tuple(row) for row in flipped)
