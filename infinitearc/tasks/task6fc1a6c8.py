# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 6fc1a6c8
Difficulty: hard

=== Tags ===
- Directed field
- Directional routing
- Multi layer projection
- Background filling

=== Description ===
The input grid consists of a 2D array where color 0 represents background cells,
and non-zero colors represent directional arrows (e.g., red for right-pointing,
blue for up-pointing) arranged as visual symbols within the grid. These
directional arrows are distributed across distinct, non-overlapping regions
separated by background cells, with each region containing a single consistent
arrow direction. The grid may include multiple layers of directional fields,
where layers are defined by nested rectangular bands (e.g., outer layer, middle
layer, inner layer) that each contain a unique directional pattern.  The output
grid must fill all background cells with a continuous path that follows these
directional constraints through multi-layer projection. The path is constructed
by: 1. Starting from the grid's perimeter and moving inward, with each step
directed by the nearest directional arrow in the current layer. 2. For cells
equidistant to arrows in multiple layers, prioritizing the direction from the
highest layer (outermost to innermost) with the strongest directional alignment.
3. Resolving conflicts between layers by projecting the directional influence of
higher layers onto lower layers (e.g., an outer layer's right-pointing arrow
overrides a lower layer's up-pointing arrow for cells in the overlapping
region). 4. Ensuring the path covers all background cells without gaps or
overlaps, maintaining a single continuous route from the perimeter to the grid's
center.  The background filling must respect the layered directional hierarchy,
with the path dynamically adapting to directional shifts between layers. The
solution requires simultaneously analyzing layer boundaries, directional
priorities, and path continuity across multiple overlapping directional fields
to produce a visually coherent, non-branching path that adheres to all layered
constraints.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Generator for ARC task 452: layered directional bands with a continuous path filling the background.
# The generator produces nested rectangular bands (layers) filled with direction codes 1..4
# and leaves an inner background region of zeros. One opening is created in the outermost band
# so the path can start from the perimeter. The background cells are filled by a single
# continuous snake-like path (color 9) starting at that opening.

def generate():
    # size must be large enough to host the requested number of layers
    size = random.randint(7, 20)
    num_layers = random.randint(2, 3)
    # directions: 1..4 represent four cardinal arrow directions
    directions = random.sample([1, 2, 3, 4], num_layers)

    # Create input grid with background 0
    input_grid = grid(size, size, 0)

    # Draw each rectangular band for the layers with the same direction value
    for i in range(num_layers):
        val = directions[i]
        top = i
        bottom = size - 1 - i
        left = i
        right = size - 1 - i
        # top and bottom rows
        for c in range(left, right + 1):
            input_grid[top][c] = val
            input_grid[bottom][c] = val
        # left and right columns (exclude corners already written)
        for r in range(top + 1, bottom):
            input_grid[r][left] = val
            input_grid[r][right] = val

    # Make a single opening in the outermost band so the background connects to the perimeter
    # Choose a side and put a zero there (overriding the arrow briefly)
    side = random.choice([0, 1, 2, 3])  # 0=top,1=right,2=bottom,3=left
    if side == 0:
        oc = size // 2
        input_grid[0][oc] = 0
    elif side == 1:
        orow = size // 2
        input_grid[orow][size - 1] = 0
    elif side == 2:
        oc = size // 2
        input_grid[size - 1][oc] = 0
    else:
        orow = size // 2
        input_grid[orow][0] = 0

    # Find bounding rectangle of background zeros
    min_r, max_r = size, -1
    min_c, max_c = size, -1
    zero_cells = []
    for r in range(size):
        for c in range(size):
            if input_grid[r][c] == 0:
                zero_cells.append((r, c))
                if r < min_r: min_r = r
                if r > max_r: max_r = r
                if c < min_c: min_c = c
                if c > max_c: max_c = c

    # If there are no background cells for some reason, create a single central background cell
    if max_r == -1:
        mid = size // 2
        input_grid[mid][mid] = 0
        min_r = max_r = min_c = max_c = mid
        zero_cells = [(mid, mid)]

    # Build a snake-order list of all cells inside the bounding rectangle that are background
    path_cells = []
    for rr_idx, r in enumerate(range(min_r, max_r + 1)):
        if rr_idx % 2 == 0:
            rng = range(min_c, max_c + 1)
        else:
            rng = range(max_c, min_c - 1, -1)
        for c in rng:
            if input_grid[r][c] == 0:
                path_cells.append((r, c))

    # Ensure we start the path at the perimeter opening if it exists
    start = None
    for (r, c) in path_cells:
        if r == 0 or c == 0 or r == size - 1 or c == size - 1:
            start = (r, c)
            break
    if start is not None and start in path_cells:
        idx = path_cells.index(start)
        path_cells = path_cells[idx:] + path_cells[:idx]

    # Fill the output grid: copy input and replace background cells with a single path color (9)
    output_grid = [row[:] for row in input_grid]
    PATH_COLOR = 9
    for (r, c) in path_cells:
        output_grid[r][c] = PATH_COLOR

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid_in = [list(row) for row in input_grid]
    h = len(grid_in)
    w = len(grid_in[0]) if h > 0 else 0

    # Locate background zeros and their bounding rectangle
    min_r, max_r = h, -1
    min_c, max_c = w, -1
    zeros = set()
    for r in range(h):
        for c in range(w):
            if grid_in[r][c] == 0:
                zeros.add((r, c))
                if r < min_r: min_r = r
                if r > max_r: max_r = r
                if c < min_c: min_c = c
                if c > max_c: max_c = c

    # If no zeros, return input as-is
    if max_r == -1:
        return grid_in

    # Construct snake-order list of background cells within the bounding rectangle
    path_cells = []
    for rr_idx, r in enumerate(range(min_r, max_r + 1)):
        if rr_idx % 2 == 0:
            rng = range(min_c, max_c + 1)
        else:
            rng = range(max_c, min_c - 1, -1)
        for c in rng:
            if (r, c) in zeros:
                path_cells.append((r, c))

    # Find a perimeter start (the opening) if present
    start = None
    for (r, c) in path_cells:
        if r == 0 or c == 0 or r == h - 1 or c == w - 1:
            start = (r, c)
            break
    if start is not None and start in path_cells:
        idx = path_cells.index(start)
        path_cells = path_cells[idx:] + path_cells[:idx]

    # Fill path using the same PATH_COLOR used by the generator
    PATH_COLOR = 9
    output = [row[:] for row in grid_in]
    for (r, c) in path_cells:
        output[r][c] = PATH_COLOR

    return output

