# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: ddcb5959
Difficulty: insane

=== Tags ===
- Simulate gravity with obstacles
- Topological invariance
- Beam splitter
- Dual grid translation
- Background filling
- Pairwise analogy

=== Description ===
Input grids are large (up to 30×30) with a background color (0), containing four
distinct element types: fixed obstacles (horizontal/vertical lines of non-zero
color), gravity elements (small colored blocks that fall vertically), beam
splitters (cross-shaped markers), and directional beams (diagonal lines
traveling in fixed directions). The obstacles are stationary and prevent falling
elements from passing through.   The transformation process involves four
sequential steps:  1. **Gravity simulation**: All gravity elements fall
vertically until they rest directly above an obstacle or the grid bottom,
maintaining their horizontal position. 2. **Beam splitting**: When a beam
intersects a beam splitter, it splits into two new beams traveling in
perpendicular directions (e.g., a southeast-moving beam becomes northeast and
southwest beams). 3. **Topological invariance**: The structural relationships
between beams and splitters are preserved—each beam splitter's output directions
are determined by the beam's incoming angle relative to the splitter's
orientation. 4. **Background filling**: All remaining empty cells (background)
are filled with the color that appears most frequently among non-background
elements in the input (determined through pairwise comparison of element color
distributions).  The output grid must reflect all transformations while
maintaining strict adherence to the rules: no overlapping elements, beams never
interact with obstacles or splitters except at designated points, and the
background color is replaced uniformly based on the most common non-background
color in the input. The complexity arises from simultaneously tracking falling
elements, beam splitting geometry, and topological relationships across a dense,
multi-layered grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    w = random.randint(5, 30)
    h = random.randint(5, 30)
    grid = common.grid(w, h, 0)
    
    num_h_obstacles = random.randint(2, 3)
    for _ in range(num_h_obstacles):
        row = random.randint(0, h-1)
        start = random.randint(0, w-2)
        end = random.randint(start+1, w-1)
        for col in range(start, end+1):
            grid[row][col] = 1
    
    num_v_obstacles = random.randint(2, 3)
    for _ in range(num_v_obstacles):
        col = random.randint(0, w-1)
        start = random.randint(0, h-2)
        end = random.randint(start+1, h-1)
        for row in range(start, end+1):
            grid[row][col] = 2
    
    num_gravity = random.randint(2, 3)
    for _ in range(num_gravity):
        col = random.randint(0, w-1)
        for r in range(h-2, -1, -1):
            if grid[r+1][col] != 0 and grid[r+1][col] != 3:
                grid[r][col] = 3
                break
            elif r+1 == h-1:
                grid[r][col] = 3
                break
        else:
            grid[0][col] = 3
    
    num_splitters = random.randint(1, 2)
    splitters = []
    for _ in range(num_splitters):
        r = random.randint(1, h-2)
        c = random.randint(1, w-2)
        grid[r][c] = 5
        splitters.append((r, c))
    
    for (r, c) in splitters:
        for k in range(1, min(r, c) + 1):
            if r - k >= 0 and c - k >= 0:
                grid[r - k][c - k] = 4
            else:
                break
    
    output = [row[:] for row in grid]
    
    for col in range(w):
        positions = []
        for row in range(h):
            if output[row][col] == 3:
                positions.append(row)
        for row in reversed(positions):
            new_row = row
            while new_row < h - 1 and output[new_row + 1][col] == 0:
                new_row += 1
            if new_row != row:
                output[row][col] = 0
                output[new_row][col] = 3
    
    for (r, c) in splitters:
        if r > 0 and c > 0 and output[r-1][c-1] == 4:
            nr, nc = r-1, c+1
            while nr >= 0 and nc < w and output[nr][nc] == 0:
                output[nr][nc] = 4
                nr -= 1
                nc += 1
            nr, nc = r+1, c-1
            while nr < h and nc >= 0 and output[nr][nc] == 0:
                output[nr][nc] = 4
                nr += 1
                nc -= 1
    
    input_colors = [color for row in grid for color in row if color != 0]
    most_common = max(set(input_colors), key=input_colors.count) if input_colors else 1
    for r in range(h):
        for c in range(w):
            if output[r][c] == 0:
                output[r][c] = most_common
    
    return {
        'input': grid,
        'output': output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])
    
    for col in range(w):
        positions = []
        for row in range(h):
            if grid[row][col] == 3:
                positions.append(row)
        for row in reversed(positions):
            new_row = row
            while new_row < h - 1 and grid[new_row + 1][col] == 0:
                new_row += 1
            if new_row != row:
                grid[row][col] = 0
                grid[new_row][col] = 3
    
    splitters = []
    for r in range(h):
        for c in range(w):
            if grid[r][c] == 5:
                splitters.append((r, c))
    
    for (r, c) in splitters:
        if r > 0 and c > 0 and grid[r-1][c-1] == 4:
            nr, nc = r-1, c+1
            while nr >= 0 and nc < w and grid[nr][nc] == 0:
                grid[nr][nc] = 4
                nr -= 1
                nc += 1
            nr, nc = r+1, c-1
            while nr < h and nc >= 0 and grid[nr][nc] == 0:
                grid[nr][nc] = 4
                nr += 1
                nc -= 1
    
    input_colors = [color for row in input_grid for color in row if color != 0]
    most_common = max(set(input_colors), key=input_colors.count) if input_colors else 1
    for r in range(h):
        for c in range(w):
            if grid[r][c] == 0:
                grid[r][c] = most_common
    
    return grid
