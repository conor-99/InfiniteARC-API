# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 97be1d2b
Difficulty: insane

=== Tags ===
- Lava flow

=== Description ===
Input grids consist of a 2D grid with four distinct color categories: background
(0), lava source (5), path markers (3 and 4), and barriers (1 and 2). The lava
source appears as a single cell of color 5, while path markers form a contiguous
network of cells that allow lava propagation. Barriers (colors 1 and 2) block
lava flow and remain unchanged. The grid layout includes complex, maze-like
pathways with multiple intersecting paths, dead ends, and barriers arranged to
challenge pattern recognition.  The transformation rule requires identifying all
cells connected to the lava source (5) via contiguous paths of path markers (3
or 4) in the four cardinal directions. All such path markers (3 and 4) along the
connected network are converted to lava (5), and any background cells (0)
adjacent to these converted path markers are also converted to lava (5).
Barriers (1 and 2) remain unchanged, as they block propagation. This results in
a visually distinct output where the lava flow forms a continuous, non-
overlapping region extending from the source through all accessible path markers
and surrounding background cells, while barriers and disconnected elements
remain unaffected. The complexity arises from the need to trace multi-
directional paths through non-uniform color sequences and handle overlapping
path networks.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque

def generate():
    # grid size
    w = random.randint(6, 20)
    h = random.randint(6, 20)
    grid = [[0 for _ in range(w)] for _ in range(h)]

    # place barriers first (colors 1 and 2) with a moderate probability
    barrier_prob = random.uniform(0.06, 0.18)
    for r in range(h):
        for c in range(w):
            if random.random() < barrier_prob:
                grid[r][c] = random.choice([1, 2])

    # choose a source cell (color 5) that is not a barrier
    attempts = 0
    while True:
        sr = random.randint(0, h - 1)
        sc = random.randint(0, w - 1)
        if grid[sr][sc] == 0:
            grid[sr][sc] = 5
            break
        attempts += 1
        if attempts > 1000:
            # fallback: clear the center
            sr, sc = h // 2, w // 2
            grid[sr][sc] = 5
            break

    # grow a contiguous path-network of markers (3 and 4) from the source
    occupied = set([(sr, sc)])
    frontier = [(sr, sc)]
    # target number of path cells (not counting the source)
    max_path = random.randint(6, max(6, (w * h) // 8))
    path_count = 0
    loop_guard = 0
    while path_count < max_path and frontier and loop_guard < w * h * 10:
        cell = random.choice(frontier)
        r, c = cell
        dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        random.shuffle(dirs)
        expanded = False
        for dr, dc in dirs:
            nr, nc = r + dr, c + dc
            if not (0 <= nr < h and 0 <= nc < w):
                continue
            if (nr, nc) in occupied:
                continue
            if grid[nr][nc] != 0:
                continue
            # create a path marker here
            grid[nr][nc] = random.choice([3, 4])
            occupied.add((nr, nc))
            frontier.append((nr, nc))
            path_count += 1
            expanded = True
            break
        if not expanded:
            # occasionally prune the frontier to encourage branching
            if random.random() < 0.5:
                try:
                    frontier.remove(cell)
                except ValueError:
                    pass
        loop_guard += 1

    # add a few disconnected clusters of path markers (3/4) that should remain unaffected
    main_path = set((r, c) for r in range(h) for c in range(w) if grid[r][c] in (3, 4) or grid[r][c] == 5)
    num_clusters = random.randint(1, 4)
    clusters_made = 0
    attempts = 0
    while clusters_made < num_clusters and attempts < 200:
        attempts += 1
        cr = random.randint(0, h - 1)
        cc = random.randint(0, w - 1)
        if grid[cr][cc] != 0:
            continue
        # ensure cluster is not too close to the main path to keep it disconnected
        if main_path:
            min_dist = min(abs(cr - x) + abs(cc - y) for x, y in main_path)
        else:
            min_dist = float('inf')
        if min_dist <= 3:
            continue
        cluster_size = random.randint(1, 5)
        cluster_cells = [(cr, cc)]
        grid[cr][cc] = random.choice([3, 4])
        for _ in range(cluster_size - 1):
            base = random.choice(cluster_cells)
            br, bc = base
            neighs = [(br + 1, bc), (br - 1, bc), (br, bc + 1), (br, bc - 1)]
            random.shuffle(neighs)
            placed = False
            for nr, nc in neighs:
                if 0 <= nr < h and 0 <= nc < w and grid[nr][nc] == 0:
                    grid[nr][nc] = random.choice([3, 4])
                    cluster_cells.append((nr, nc))
                    placed = True
                    break
            if not placed:
                break
        clusters_made += 1
        main_path.update(cluster_cells)

    # ensure there's at least one path marker adjacent to source so the lava can flow
    has_adjacent = False
    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
        nr, nc = sr + dr, sc + dc
        if 0 <= nr < h and 0 <= nc < w and grid[nr][nc] in (3, 4):
            has_adjacent = True
            break
    if not has_adjacent:
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = sr + dr, sc + dc
            if 0 <= nr < h and 0 <= nc < w and grid[nr][nc] == 0:
                grid[nr][nc] = random.choice([3, 4])
                break

    # build the output by converting only the path markers connected to the source and
    # then converting background zeros adjacent to the lava (source + those converted path markers)
    output = [row[:] for row in grid]

    # BFS to find all path markers (3 or 4) connected to the source (via 3/4 only)
    connected = set()
    q = deque()
    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
        nr, nc = sr + dr, sc + dc
        if 0 <= nr < h and 0 <= nc < w and grid[nr][nc] in (3, 4):
            connected.add((nr, nc))
            q.append((nr, nc))
    while q:
        r, c = q.popleft()
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < h and 0 <= nc < w and (nr, nc) not in connected and grid[nr][nc] in (3, 4):
                connected.add((nr, nc))
                q.append((nr, nc))

    # convert the connected path markers to lava
    for (r, c) in connected:
        output[r][c] = 5

    # determine the set of lava cells (source plus converted path markers)
    lava_cells = set(connected)
    lava_cells.add((sr, sc))

    # convert background zeros adjacent to any lava cell (single-step, non-cascading)
    to_convert = set()
    for (r, c) in lava_cells:
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < h and 0 <= nc < w and output[nr][nc] == 0:
                to_convert.add((nr, nc))
    for (r, c) in to_convert:
        output[r][c] = 5

    # ensure input and output are not identical
    if grid == output:
        # force at least one conversion
        for r in range(h):
            for c in range(w):
                if grid[r][c] in (3, 4):
                    output[r][c] = 5
                    break
            else:
                continue
            break

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    # convert input to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    rows = len(grid)
    cols = len(grid[0]) if rows > 0 else 0

    # find the lava source (color 5); if multiple, use the first
    source = None
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 5:
                source = (r, c)
                break
        if source:
            break
    if not source:
        return grid

    sr, sc = source

    # BFS to find all path markers (3 or 4) connected to the source via 3/4 only
    connected = set()
    q = deque()
    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
        nr, nc = sr + dr, sc + dc
        if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] in (3, 4):
            connected.add((nr, nc))
            q.append((nr, nc))
    while q:
        r, c = q.popleft()
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in connected and grid[nr][nc] in (3, 4):
                connected.add((nr, nc))
                q.append((nr, nc))

    # build the output grid
    out = [row[:] for row in grid]

    # convert the connected path markers to lava
    for (r, c) in connected:
        out[r][c] = 5

    # include source in lava set and convert zeros adjacent to any lava cell (single-step)
    lava_cells = set(connected)
    lava_cells.add((sr, sc))

    to_convert = set()
    for (r, c) in lava_cells:
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols and out[nr][nc] == 0:
                to_convert.add((nr, nc))
    for (r, c) in to_convert:
        out[r][c] = 5

    return out

