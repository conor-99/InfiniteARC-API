# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 05c7c85b
Difficulty: medium

=== Tags ===
- Select every nth column
- Image within image
- Move object to first unoccupied space

=== Description ===
The task involves transforming an input grid into an output grid through two
consistent visual operations. First, every nth column of the input grid is
selected (where n is a fixed integer determined for the task, such as 2),
forming a smaller grid that represents the "image within image." This selection
process preserves the row order while removing non-selected columns. Second, the
first occurrence of a distinct object color (any color other than the background
color 0) within this new grid is moved to the first background (0) cell in row-
major order. The original position of the object color becomes background (0),
while the target cell adopts the object color. The background color remains
unchanged throughout, and the transformation ensures the output grid differs
from the input by both column selection and object repositioning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    n = 2
    while True:
        width = common.randint(1, 30)
        height = common.randint(1, 30)
        input_grid = common.grid(width, height, 0)
        for r in range(height):
            for c in range(width):
                if common.random.random() > 0.5:
                    input_grid[r][c] = common.random.randint(1, 9)
        S = []
        for r in range(height):
            new_row = []
            for c in range(0, width, n):
                new_row.append(input_grid[r][c])
            S.append(new_row)
        has_non_zero = False
        has_zero = False
        for r in range(height):
            for c in range(len(S[0])):
                if S[r][c] > 0:
                    has_non_zero = True
                else:
                    has_zero = True
        if has_non_zero and has_zero:
            break
    for r in range(height):
        for c in range(len(S[0])):
            if S[r][c] > 0:
                obj_r, obj_c = r, c
                break
        else:
            continue
        break
    for r in range(height):
        for c in range(len(S[0])):
            if S[r][c] == 0:
                zero_r, zero_c = r, c
                break
        else:
            continue
        break
    output_grid = [row[:] for row in S]
    output_grid[zero_r][zero_c] = output_grid[obj_r][obj_c]
    output_grid[obj_r][obj_c] = 0
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    n = 2
    height = len(input_grid)
    width = len(input_grid[0])
    S = []
    for r in range(height):
        new_row = []
        for c in range(0, width, n):
            new_row.append(input_grid[r][c])
        S.append(new_row)
    for r in range(height):
        for c in range(len(S[0])):
            if S[r][c] > 0:
                obj_r, obj_c = r, c
                break
        else:
            continue
        break
    for r in range(height):
        for c in range(len(S[0])):
            if S[r][c] == 0:
                zero_r, zero_c = r, c
                break
        else:
            continue
        break
    output = [row[:] for row in S]
    output[zero_r][zero_c] = output[obj_r][obj_c]
    output[obj_r][obj_c] = 0
    return output
