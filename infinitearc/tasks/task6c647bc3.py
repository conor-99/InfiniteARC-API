# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 6c647bc3
Difficulty: medium

=== Tags ===
- Local convolution rule
- Connect the dots

=== Description ===
The input grid features scattered dots (cells with a specific color, e.g., color
1) arranged in straight horizontal, vertical, or diagonal lines, with exactly
one empty cell between each pair of dots. The output grid connects these dots by
filling the empty cells between them with a consistent connecting color (e.g.,
color 2). This transformation follows a local rule: for any cell in the input,
if it is horizontally, vertically, or diagonally flanked by two dots (one on
each side), the corresponding cell in the output is set to the connecting color.
The rule is applied uniformly across the grid, ensuring all gaps between aligned
dots are bridged without altering other grid elements. The task requires
recognizing these aligned dot pairs and applying the local neighbor-based fill
rule to generate the connected pattern.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

from common import grid, randint

def generate():
    width = randint(5, 20)
    height = randint(5, 20)
    input_grid = grid(width, height, 0)
    directions = [(0, 1), (1, 0), (1, 1), (1, -1)]
    num_lines = randint(2, 3)
    for _ in range(num_lines):
        index = randint(0, 3)
        dr, dc = directions[index]
        r = randint(0, height - 1)
        c = randint(0, width - 1)
        num_dots = randint(3, 5)
        end_r = r + (num_dots - 1) * 2 * dr
        end_c = c + (num_dots - 1) * 2 * dc
        if end_r < 0 or end_r >= height or end_c < 0 or end_c >= width:
            r = max(0, height - 1 - (num_dots - 1) * 2 * dr)
            c = max(0, width - 1 - (num_dots - 1) * 2 * dc)
        for k in range(num_dots):
            r_pos = r + k * 2 * dr
            c_pos = c + k * 2 * dc
            if 0 <= r_pos < height and 0 <= c_pos < width:
                input_grid[r_pos][c_pos] = 1
    output_grid = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                if c > 0 and c < width - 1 and input_grid[r][c-1] == 1 and input_grid[r][c+1] == 1:
                    output_grid[r][c] = 2
                elif r > 0 and r < height - 1 and input_grid[r-1][c] == 1 and input_grid[r+1][c] == 1:
                    output_grid[r][c] = 2
                elif r > 0 and c > 0 and r < height - 1 and c < width - 1 and input_grid[r-1][c-1] == 1 and input_grid[r+1][c+1] == 1:
                    output_grid[r][c] = 2
                elif r > 0 and c < width - 1 and r < height - 1 and c > 0 and input_grid[r-1][c+1] == 1 and input_grid[r+1][c-1] == 1:
                    output_grid[r][c] = 2
    if input_grid == output_grid:
        return generate()
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                if c > 0 and c < width - 1 and input_grid[r][c-1] == 1 and input_grid[r][c+1] == 1:
                    output_grid[r][c] = 2
                elif r > 0 and r < height - 1 and input_grid[r-1][c] == 1 and input_grid[r+1][c] == 1:
                    output_grid[r][c] = 2
                elif r > 0 and c > 0 and r < height - 1 and c < width - 1 and input_grid[r-1][c-1] == 1 and input_grid[r+1][c+1] == 1:
                    output_grid[r][c] = 2
                elif r > 0 and c < width - 1 and r < height - 1 and c > 0 and input_grid[r-1][c+1] == 1 and input_grid[r+1][c-1] == 1:
                    output_grid[r][c] = 2
    return output_grid
