# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: d2fdcb2f
Difficulty: insane

=== Tags ===
- Rotational pattern mapping
- Permute columns by length

=== Description ===
Input grids feature a background color (0) with multiple distinct, non-
background connected components (4-connected regions of colors 1-9). Each
component must be rotated 90 degrees clockwise around its top-left boundary,
which alters the distribution of colored cells across columns. Following
rotation, the columns are permuted in descending order based on the number of
non-background cells they contain (i.e., columns with the most colored cells
appear first, followed by fewer, and empty columns last). The transformation
preserves all non-background colors, only changing their spatial arrangement
through rotation and column reordering. The output grid must reflect both the
rotated patterns and the sorted column order, with no cells added, removed, or
altered beyond the described operations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    import common
    from common import continuous_creature, grid
    
    width = random.randint(5, 20)
    height = random.randint(5, 20)
    input_grid = grid(width, height, 0)
    
    colors = random.sample(range(1, 10), k=random.randint(2, 3))
    
    for color in colors:
        size = random.randint(3, 5)
        pixels = continuous_creature(size, 3, 3)
        start_r = random.randint(2, height - 3)
        start_c = random.randint(2, width - 3)
        for (r, c) in pixels:
            if start_r + r < height and start_c + c < width:
                input_grid[start_r + r][start_c + c] = color
    
    rotated_grid = grid(width, height, 0)
    visited = [[False] * width for _ in range(height)]
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == input_grid[r][c] and not visited[nr][nc]:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                min_r = min(cr for cr, cc in component)
                max_r = max(cr for cr, cc in component)
                min_c = min(cc for cr, cc in component)
                max_c = max(cc for cr, cc in component)
                for (cr, cc) in component:
                    new_r = min_r + (cc - min_c)
                    new_c = min_c + (max_r - cr)
                    if 0 <= new_r < height and 0 <= new_c < width:
                        rotated_grid[new_r][new_c] = input_grid[cr][cc]
    
    col_counts = [sum(1 for r in range(height) if rotated_grid[r][c] != 0) for c in range(width)]
    sorted_cols = sorted(range(width), key=lambda c: (-col_counts[c], c))
    output_grid = [[rotated_grid[r][c] for c in sorted_cols] for r in range(height)]
    
    if input_grid == output_grid:
        return generate()
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    import common
    from common import grid
    
    height = len(input_grid)
    width = len(input_grid[0])
    rotated_grid = grid(width, height, 0)
    visited = [[False] * width for _ in range(height)]
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == input_grid[r][c] and not visited[nr][nc]:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                min_r = min(cr for cr, cc in component)
                max_r = max(cr for cr, cc in component)
                min_c = min(cc for cr, cc in component)
                max_c = max(cc for cr, cc in component)
                for (cr, cc) in component:
                    new_r = min_r + (cc - min_c)
                    new_c = min_c + (max_r - cr)
                    if 0 <= new_r < height and 0 <= new_c < width:
                        rotated_grid[new_r][new_c] = input_grid[cr][cc]
    
    col_counts = [sum(1 for r in range(height) if rotated_grid[r][c] != 0) for c in range(width)]
    sorted_cols = sorted(range(width), key=lambda c: (-col_counts[c], c))
    output_grid = [[rotated_grid[r][c] for c in sorted_cols] for r in range(height)]
    
    return output_grid
