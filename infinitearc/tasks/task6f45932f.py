# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 6f45932f
Difficulty: hard

=== Tags ===
- Bring patterns close
- Count tiles
- Take intersection

=== Description ===
The input grid contains two distinct connected patterns (each a group of
adjacent non-zero cells forming a contiguous shape). The task requires
identifying these two patterns, counting the number of tiles (cells) in each
pattern, and shifting them toward each other: the left pattern is shifted right
by its tile count, and the right pattern is shifted left by its tile count. The
output grid is formed by taking the intersection of the two shifted patterns,
where a cell appears only if it belongs to both shifted patterns. All other
cells in the output grid are set to zero. This transformation demands precise
pattern recognition, accurate tile counting, directional shifting, and
intersection calculation, making it a challenging task requiring multi-step
reasoning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = random.randint(15, 21)
    height = random.randint(5, 15)
    left_size = random.randint(3, 6)
    right_size = random.randint(3, 6)
    
    while True:
        left_pixels = common.continuous_creature(left_size, width=5, height=height)
        right_pixels = common.continuous_creature(right_size, width=5, height=height)
        
        left_max_col = max(c for r, c in left_pixels)
        right_min_col = width - 5  # right blob placed at columns [width-5, width-1]
        gap = right_min_col - left_max_col - 1
        
        if left_size + right_size > gap:
            break
        
        left_size = random.randint(3, 6)
        right_size = random.randint(3, 6)
    
    input_grid = common.grid(width, height, 0)
    for r, c in left_pixels:
        input_grid[r][c] = 1
    for r, c in right_pixels:
        input_grid[r][c + (width - 5)] = 2
    
    count_left = len(left_pixels)
    count_right = len(right_pixels)
    
    shifted_left = set((r, c + count_left) for r, c in left_pixels)
    shifted_right = set((r, c + (width - 5) - count_right) for r, c in right_pixels)
    
    intersection = shifted_left & shifted_right
    output_grid = common.grid(width, height, 0)
    for r, c in intersection:
        if 0 <= r < height and 0 <= c < width:
            output_grid[r][c] = 1
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    visited = [[False] * width for _ in range(height)]
    components = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] > 0 and not visited[r][c]:
                component = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] > 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append(component)
    
    if len(components) != 2:
        components = components[:2]
    
    left_component = min(components, key=lambda comp: min(c for r, c in comp))
    right_component = max(components, key=lambda comp: min(c for r, c in comp))
    
    count_left = len(left_component)
    count_right = len(right_component)
    
    shifted_left = set((r, c + count_left) for r, c in left_component)
    shifted_right = set((r, c - count_right) for r, c in right_component)
    
    intersection = shifted_left & shifted_right
    output_grid = common.grid(width, height, 0)
    for r, c in intersection:
        if 0 <= r < height and 0 <= c < width:
            output_grid[r][c] = 1
    return output_grid
