# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: f536f99a
Difficulty: hard

=== Tags ===
- Pocket fill
- Rectangle guessing
- Layered occlusion unfolding

=== Description ===
The input grid contains a shape formed by non-zero values with internal pockets
(holes) enclosed by the shape's boundary. The task requires identifying the
minimal axis-aligned rectangle that contains all non-zero cells (rectangle
guessing). Within this rectangle, all enclosed pockets—regions not connected to
the rectangle's border—are filled with the shape's color, removing the holes.
Layered occlusion refers to nested pockets where one pocket exists within
another, requiring recursive filling during the unfolding process. The output
grid is the input grid transformed by filling all such pockets while maintaining
the original shape's outer boundary.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque

def generate():
    size = random.randint(5, 30)
    grid = [[0] * size for _ in range(size)]
    color = random.randint(1, 9)

    # Create outer frame
    for r in range(size):
        grid[0][r] = color
        grid[size-1][r] = color
    for c in range(size):
        grid[c][0] = color
        grid[c][size-1] = color

    # Create middle frame
    mid_start = 2
    mid_end = size - 2
    for r in range(mid_start, mid_end):
        grid[r][mid_start] = color
        grid[r][mid_end-1] = color
    for c in range(mid_start, mid_end):
        grid[mid_start][c] = color
        grid[mid_end-1][c] = color

    # Create inner frame for layered occlusion
    inner_start = mid_start + 2
    inner_end = mid_end - 2
    if inner_end > inner_start:
        for r in range(inner_start, inner_end):
            grid[r][inner_start] = color
            grid[r][inner_end-1] = color
        for c in range(inner_start, inner_end):
            grid[inner_start][c] = color
            grid[inner_end-1][c] = color

    # Generate output by filling pockets
    output = [row[:] for row in grid]
    non_zero = [(r, c) for r in range(size) for c in range(size) if grid[r][c] != 0]
    if not non_zero:
        return {'input': grid, 'output': grid}
    
    min_row = min(r for r, c in non_zero)
    max_row = max(r for r, c in non_zero)
    min_col = min(c for r, c in non_zero)
    max_col = max(c for r, c in non_zero)

    visited = [[False] * (max_col - min_col + 1) for _ in range(max_row - min_row + 1)]
    queue = deque()

    # Mark border-connected zeros
    for r in [min_row, max_row]:
        for c in range(min_col, max_col + 1):
            if grid[r][c] == 0 and not visited[r - min_row][c - min_col]:
                visited[r - min_row][c - min_col] = True
                queue.append((r, c))
    for c in [min_col, max_col]:
        for r in range(min_row, max_row + 1):
            if grid[r][c] == 0 and not visited[r - min_row][c - min_col]:
                visited[r - min_row][c - min_col] = True
                queue.append((r, c))

    while queue:
        r, c = queue.popleft()
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if min_row <= nr <= max_row and min_col <= nc <= max_col:
                if grid[nr][nc] == 0 and not visited[nr - min_row][nc - min_col]:
                    visited[nr - min_row][nc - min_col] = True
                    queue.append((nr, nc))

    # Fill pockets
    for r in range(min_row, max_row + 1):
        for c in range(min_col, max_col + 1):
            if grid[r][c] == 0 and not visited[r - min_row][c - min_col]:
                output[r][c] = color

    return {'input': grid, 'output': output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    rows = len(input_grid)
    cols = len(input_grid[0]) if rows > 0 else 0
    non_zero = [(r, c) for r in range(rows) for c in range(cols) if input_grid[r][c] != 0]
    
    if not non_zero:
        return input_grid
    
    min_row = min(r for r, c in non_zero)
    max_row = max(r for r, c in non_zero)
    min_col = min(c for r, c in non_zero)
    max_col = max(c for r, c in non_zero)
    shape_color = input_grid[non_zero[0][0]][non_zero[0][1]]

    visited = [[False] * (max_col - min_col + 1) for _ in range(max_row - min_row + 1)]
    queue = deque()

    for r in [min_row, max_row]:
        for c in range(min_col, max_col + 1):
            if input_grid[r][c] == 0 and not visited[r - min_row][c - min_col]:
                visited[r - min_row][c - min_col] = True
                queue.append((r, c))
    for c in [min_col, max_col]:
        for r in range(min_row, max_row + 1):
            if input_grid[r][c] == 0 and not visited[r - min_row][c - min_col]:
                visited[r - min_row][c - min_col] = True
                queue.append((r, c))

    while queue:
        r, c = queue.popleft()
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if min_row <= nr <= max_row and min_col <= nc <= max_col:
                if input_grid[nr][nc] == 0 and not visited[nr - min_row][nc - min_col]:
                    visited[nr - min_row][nc - min_col] = True
                    queue.append((nr, nc))

    output = [row[:] for row in input_grid]
    for r in range(min_row, max_row + 1):
        for c in range(min_col, max_col + 1):
            if input_grid[r][c] == 0 and not visited[r - min_row][c - min_col]:
                output[r][c] = shape_color
    return output
