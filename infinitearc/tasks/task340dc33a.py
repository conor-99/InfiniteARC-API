# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 340dc33a
Difficulty: medium–hard

=== Tags ===
- Grid topology inference
- Beam reflection
- Measure distance from side
- Recolor object based on its size

=== Description ===
Input grids consist of a single background color (0) and multiple non-
overlapping axis-aligned rectangular objects (solid, single color 1-9), each
with width and height between 1 and 5 cells. Objects are separated by at least
one background cell and positioned such that their minimum distance to any grid
edge (left, right, top, bottom) varies. The background remains uniform across
the grid.  The output grid requires two sequential transformations:   1.
**Recoloring based on object size:** For each rectangle, compute its area (width
× height). Recolor the entire object as follows:      - Area ≤ 3 → color 1
- 4 ≤ Area ≤ 6 → color 2      - Area ≥ 7 → color 3   2. **Beam reflection
simulation:** After recoloring, simulate a single diagonal beam originating from
the top-left grid cell (0,0), traveling right and down (slope 1). The beam moves
cell-by-cell until it hits a recolored object. Upon impact, the beam reflects
based on the object’s **distance to the nearest grid edge** (measured in cells):
- Distance ≤ 2 (object near edge) → reflect at 90° (e.g., right-down direction
becomes down-right)      - Distance > 2 (object centrally located) → reflect at
45° (e.g., right-down direction becomes right-up)      The beam continues
reflecting until exiting the grid. The path is drawn using color 4, with
reflection points marked by the object’s new color. The background remains
unchanged except for the beam path.    All transformations are deterministic,
visually grounded, and require sequential application of size-based recoloring
followed by distance-dependent reflection logic.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    input_grid = [[0] * width for _ in range(height)]
    
    rectangles = []
    max_rects = random.randint(3, 5)
    for _ in range(max_rects):
        r = random.randint(0, height - 5)
        c = random.randint(0, width - 5)
        w = random.randint(1, 5)
        h = random.randint(1, 5)
        
        # Ensure rectangle doesn't cover (0,0)
        if (0 >= r and 0 < r + h and 0 >= c and 0 < c + w):
            continue
            
        # Check for overlap with existing rectangles
        valid = True
        for (r0, c0, w0, h0) in rectangles:
            if (r < r0 + h0 + 1 and r + h > r0 - 1 and 
                c < c0 + w0 + 1 and c + w > c0 - 1):
                valid = False
                break
        if not valid:
            continue
            
        color = random.randint(1, 9)
        for i in range(r, r + h):
            for j in range(c, c + w):
                input_grid[i][j] = color
        rectangles.append((r, c, w, h))
    
    output_grid = [row[:] for row in input_grid]
    
    # Recolor rectangles based on area
    for (r, c, w, h) in rectangles:
        area = w * h
        new_color = 1 if area <= 3 else (2 if 4 <= area <= 6 else 3)
        for i in range(r, r + h):
            for j in range(c, c + w):
                output_grid[i][j] = new_color
    
    # Simulate beam path
    r, c = 0, 0
    dr, dc = 1, 1
    while True:
        nr, nc = r + dr, c + dc
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        if output_grid[nr][nc] == 0:
            output_grid[nr][nc] = 4
            r, c = nr, nc
        else:
            # Find rectangle containing (nr, nc)
            for (r0, c0, w0, h0) in rectangles:
                if r0 <= nr < r0 + h0 and c0 <= nc < c0 + w0:
                    min_distance = min(r0, height - 1 - (r0 + h0 - 1), c0, width - 1 - (c0 + w0 - 1))
                    if min_distance <= 2:
                        dr, dc = -dr, dc
                    else:
                        dr, dc = dr, -dc
                    break
            r, c = nr, nc
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    visited = [[False] * width for _ in range(height)]
    rectangles = []
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and not visited[r][c]:
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                color = grid[r][c]
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                
                min_r = min(cr for cr, cc in component)
                max_r = max(cr for cr, cc in component)
                min_c = min(cc for cr, cc in component)
                max_c = max(cc for cr, cc in component)
                
                valid = True
                for cr in range(min_r, max_r + 1):
                    for cc in range(min_c, max_c + 1):
                        if grid[cr][cc] != color:
                            valid = False
                            break
                    if not valid:
                        break
                if valid:
                    rectangles.append((min_r, max_r, min_c, max_c, color))
    
    # Recolor rectangles
    for (min_r, max_r, min_c, max_c, color) in rectangles:
        area = (max_r - min_r + 1) * (max_c - min_c + 1)
        new_color = 1 if area <= 3 else (2 if 4 <= area <= 6 else 3)
        for cr in range(min_r, max_r + 1):
            for cc in range(min_c, max_c + 1):
                grid[cr][cc] = new_color
    
    # Simulate beam path
    r, c = 0, 0
    dr, dc = 1, 1
    while True:
        nr, nc = r + dr, c + dc
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        if grid[nr][nc] == 0:
            grid[nr][nc] = 4
            r, c = nr, nc
        else:
            for (min_r, max_r, min_c, max_c, color) in rectangles:
                if min_r <= nr <= max_r and min_c <= nc <= max_c:
                    min_distance = min(min_r, height - 1 - max_r, min_c, width - 1 - max_c)
                    if min_distance <= 2:
                        dr, dc = -dr, dc
                    else:
                        dr, dc = dr, -dc
                    break
            r, c = nr, nc
    
    return tuple(tuple(row) for row in grid)
