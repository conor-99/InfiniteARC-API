# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 4ec59877
Difficulty: hard

=== Tags ===
- Take half
- Associate images to numbers

=== Description ===
The task involves input grids that are vertically divided into left and right
halves, each containing distinct visual patterns represented by unique colors.
The output grid requires replacing each pattern in the left half with a specific
color based on a hidden left-half association rule, while patterns in the right
half are replaced using a separate hidden right-half association rule. The
patterns are connected regions of a single color (e.g., squares, triangles, or
L-shapes), and the associations are not directly visible from the input alone.
The solver must deduce two distinct mappings: one for the left half (e.g., a
square pattern always maps to color 4) and another for the right half (e.g., the
same square pattern maps to color 8). This requires analyzing multiple input-
output pairs to identify the positional-dependent rules, as the same visual
pattern can correspond to different colors based on its half. The complexity is
heightened by the presence of multiple overlapping patterns and the need to
distinguish between the two association systems without explicit clues.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
def generate():
    width = common.choice([i for i in range(4, 31) if i % 2 == 0])
    height = common.randint(1, 30)
    input_grid = [[0] * width for _ in range(height)]
    left_width = width // 2
    
    left_colors = []
    for _ in range(common.randint(2, 3)):
        size = common.randint(2, 4)
        pixels = common.continuous_creature(size, left_width, height)
        if not pixels:
            continue
        rows = [p[0] for p in pixels]
        cols = [p[1] for p in pixels]
        color = common.random_color(exclude=left_colors + [0])
        left_colors.append(color)
        for r, c in zip(rows, cols):
            input_grid[r][c] = color
    
    right_colors = []
    for _ in range(len(left_colors)):
        size = common.randint(2, 4)
        pixels = common.continuous_creature(size, left_width, height)
        if not pixels:
            continue
        rows = [p[0] for p in pixels]
        cols = [p[1] for p in pixels]
        cols = [c + left_width for c in cols]
        color = common.random_color(exclude=right_colors + left_colors + [0])
        right_colors.append(color)
        for r, c in zip(rows, cols):
            if c < width:
                input_grid[r][c] = color
    
    output_grid = [[0] * width for _ in range(height)]
    left_mapping = {}
    for color in left_colors:
        new_color = (color + 3) % 9
        left_mapping[color] = new_color if new_color != 0 else 9
    
    right_mapping = {}
    for color in right_colors:
        new_color = (color + 5) % 9
        right_mapping[color] = new_color if new_color != 0 else 9
    
    for r in range(height):
        for c in range(width):
            if c < left_width and input_grid[r][c] in left_mapping:
                output_grid[r][c] = left_mapping[input_grid[r][c]]
            elif c >= left_width and input_grid[r][c] in right_mapping:
                output_grid[r][c] = right_mapping[input_grid[r][c]]
            else:
                output_grid[r][c] = input_grid[r][c]
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid or not input_grid[0]:
        return input_grid
    width = len(input_grid[0])
    height = len(input_grid)
    left_width = width // 2
    output_grid = [[0] * width for _ in range(height)]
    
    for r in range(height):
        for c in range(width):
            color = input_grid[r][c]
            if color == 0:
                output_grid[r][c] = 0
                continue
            if c < left_width:
                new_color = (color + 3) % 9
                output_grid[r][c] = new_color if new_color != 0 else 9
            else:
                new_color = (color + 5) % 9
                output_grid[r][c] = new_color if new_color != 0 else 9
    return output_grid
