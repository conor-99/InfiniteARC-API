# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 595f8d5c
Difficulty: insane

=== Tags ===
- Collision marking
- Color by distance to center

=== Description ===
Input grids feature a background color (0) and multiple distinct colored
objects, each forming a connected region of a single non-zero color (e.g., 1-9),
arranged such that no two objects touch each other or the grid boundary. Objects
are positioned at varying distances from the grid's center, with their shapes
and colors distributed non-uniformly across the canvas.  Output grids transform
the input through two interdependent rules:   1. **Distance-based coloring**:
Each cell's output color is determined by its Manhattan distance from the grid
center, using a consistent radial color progression (e.g., center cell → color
1, next ring → color 2, etc.).   2. **Collision marking**: For any distance
value *d*, if two or more *different* input colors have at least one cell at
distance *d*, all cells at distance *d* in the output are recolored to a fixed
collision color (e.g., color 9), overriding the distance-based color.
Background cells (input color 0) remain unchanged. The transformation requires
identifying overlapping color distributions across distance layers while
maintaining the radial color pattern for non-overlapping distances. This creates
a visually complex output where collision markers appear as irregular, high-
contrast rings within the radial color scheme, demanding precise spatial
analysis of both color distribution and geometric distance.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import math
    import random
    import common

    def compute_output(inp):
        """Compute the output grid from an input grid according to the task rules.
        - Manhattan distance from center determines radial color (1..8)
        - If two or more different non-zero input colors appear at the same distance d,
          then all non-zero cells at distance d are recolored to collision color 9.
        - Background (0) stays 0.
        """
        height = len(inp)
        width = len(inp[0])
        cy = height // 2
        cx = width // 2
        d_map = {}
        for r in range(height):
            for c in range(width):
                d = abs(r - cy) + abs(c - cx)
                d_map.setdefault(d, []).append(inp[r][c])

        collision_d = set()
        for d, colors in d_map.items():
            non_zero = set(col for col in colors if col != 0)
            if len(non_zero) > 1:
                collision_d.add(d)

        out = [[0] * width for _ in range(height)]
        for r in range(height):
            for c in range(width):
                if inp[r][c] == 0:
                    out[r][c] = 0
                else:
                    d = abs(r - cy) + abs(c - cx)
                    if d in collision_d:
                        out[r][c] = 9
                    else:
                        # radial colors use 1..8; reserve 9 for collision marker
                        out[r][c] = (d % 8) + 1
        return out

    # Try until a valid configuration is produced
    while True:
        # Choose a reasonably large canvas so there are many distances/rings
        width = common.randint(9, 25)
        height = common.randint(9, 25)
        ingrid = common.grid(width, height, 0)

        # Number of distinct colored objects
        num_regions = common.randint(3, 5)
        # Reserve color 9 for collisions; choose object colors from 1..8
        colors = common.random_colors(num_regions, exclude=[0, 9])

        reserved = set()  # cells we cannot place new objects into (occupied or adjacent)
        shapes = []
        success = True

        for color in colors:
            placed = False
            # Try multiple times to place a connected blob of this color
            for _ in range(300):
                # size of the creature
                size = common.randint(3, min(12, max(3, (width * height) // 30)))
                # small bounding box for the creature
                box_w = common.randint(2, min(6, width - 2))
                box_h = common.randint(2, min(6, height - 2))
                if box_w * box_h < size:
                    box_w = min(width - 2, max(2, int(math.ceil(math.sqrt(size)))))
                    box_h = min(height - 2, max(2, int(math.ceil(size / box_w))))
                    if box_w * box_h < size:
                        continue

                # Build a contiguous creature inside the small box
                pixels_local = common.continuous_creature(size, box_w, box_h)

                # Choose a top-left offset keeping at least 1-cell boundary from grid edges
                max_r0 = height - box_h - 1
                max_c0 = width - box_w - 1
                if max_r0 < 1 or max_c0 < 1:
                    continue
                r0 = common.randint(1, max_r0)
                c0 = common.randint(1, max_c0)

                abs_positions = set((r0 + pr, c0 + pc) for pr, pc in pixels_local)

                # Ensure none of the shape's pixels touch the outer boundary (must be at least 1 cell away)
                if any(r <= 0 or r >= height - 1 or c <= 0 or c >= width - 1 for r, c in abs_positions):
                    continue

                # Ensure no overlap or adjacency with previously placed shapes
                if any(pos in reserved for pos in abs_positions):
                    continue

                # Place the shape
                for (r, c) in abs_positions:
                    ingrid[r][c] = color

                shapes.append(abs_positions)

                # Mark occupied cells and their 4-neighbors as reserved to prevent touching
                for (r, c) in abs_positions:
                    reserved.add((r, c))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < height and 0 <= nc < width:
                            reserved.add((nr, nc))
                placed = True
                break

            if not placed:
                success = False
                break

        if not success:
            # restart generation
            continue

        # Ensure placed shapes are at varying distances from the center (not all on same ring)
        cy = height // 2
        cx = width // 2
        medians = []
        for s in shapes:
            ds = sorted(abs(r - cy) + abs(c - cx) for (r, c) in s)
            medians.append(ds[len(ds) // 2])
        if len(set(medians)) < min(2, len(medians)):
            # try again to get more varied placements
            continue

        output = compute_output(ingrid)
        # Ensure transformation actually changes something
        if ingrid != output:
            return {"input": ingrid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input (tuple of tuples) to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    cy = height // 2
    cx = width // 2

    # Map distances to the set of input colors that appear at that distance
    d_map = {}
    for r in range(height):
        for c in range(width):
            d = abs(r - cy) + abs(c - cx)
            d_map.setdefault(d, []).append(grid[r][c])

    # Distances where two or more different non-zero colors appear -> collisions
    collision_d = set()
    for d, colors in d_map.items():
        non_zero = set(col for col in colors if col != 0)
        if len(non_zero) > 1:
            collision_d.add(d)

    # Build the output grid
    output = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0:
                output[r][c] = 0
            else:
                d = abs(r - cy) + abs(c - cx)
                if d in collision_d:
                    output[r][c] = 9
                else:
                    # radial colors 1..8 (reserve 9 for collisions)
                    output[r][c] = (d % 8) + 1

    # Return as immutable tuple-of-tuples
    return tuple(tuple(row) for row in output)

