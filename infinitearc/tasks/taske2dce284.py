# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: e2dce284
Difficulty: very hard

=== Tags ===
- Kinetic collision
- Color matching

=== Description ===
Input grids consist of a background (0) with multiple colored particles (1-9)
and a directional arrow glyph formed by two adjacent cells of a distinct color,
indicating the movement direction (e.g., horizontal for right, vertical for
down). All particles move one cell in the glyph's direction. Upon collision,
particles of identical color merge into a new color via a fixed cyclic
transformation rule (e.g., red → blue → green → red), while particles of
differing colors are removed. The output grid shows the final positions after
all collisions are resolved, with merged particles reflecting the cyclic
transformation. The glyph's orientation and color must be distinguished from
particle colors, and the cyclic rule must be deduced from examples through
observation of collision outcomes across multiple color pairs.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import defaultdict

def generate():
    """Generate an input/output pair for the ARC task.

    - Places a two-cell arrow glyph (right or down) with a color not used by particles.
    - Places several multi-cell or single-cell particle objects (each a unique color) made
      from cells that are diagonal neighbors (to avoid creating orthogonally adjacent
      identical pairs that could be confused with the arrow glyph).
    - All non-arrow cells move one cell in the arrow direction; multiple incoming
      colors to the same target cell produce collisions. If all incoming colors are
      identical they merge into the next color according to the cycle formed by the
      sorted set of particle colors. If incoming colors differ the cell becomes empty.

    The function retries until it produces a valid pair where input != output.
    """
    attempts = 0
    while True:
        attempts += 1
        # Dimensions: keep some room for shapes and arrow
        width = random.randint(4, 14)
        height = random.randint(4, 14)

        all_colors = list(range(1, 10))
        # Choose how many distinct particle colors / objects to place (leave >=1 color for arrow)
        max_objs = min(6, len(all_colors) - 1)
        num_objs = random.randint(2, max_objs)

        # Pick unique colors for objects (each object will use a distinct color)
        obj_colors = random.sample(all_colors, num_objs)
        # Arrow color must be distinct from object colors
        arrow_color = random.choice([c for c in all_colors if c not in obj_colors])

        # Create blank grid and place arrow
        grid = [[0 for _ in range(width)] for _ in range(height)]
        arrow_dir = random.choice(['right', 'down'])
        if arrow_dir == 'right':
            ar = random.randint(0, height - 1)
            ac = random.randint(0, width - 2)
            arrow_cells = [(ar, ac), (ar, ac + 1)]
        else:
            ar = random.randint(0, height - 2)
            ac = random.randint(0, width - 1)
            arrow_cells = [(ar, ac), (ar + 1, ac)]
        grid[arrow_cells[0][0]][arrow_cells[0][1]] = arrow_color
        grid[arrow_cells[1][0]][arrow_cells[1][1]] = arrow_color

        dr, dc = (0, 1) if arrow_dir == 'right' else (1, 0)

        # Place objects (each object is a small set of cells). Use diagonal patterns so
        # there are no orthogonally adjacent identical color pairs except the arrow.
        occupied = set(arrow_cells)
        objects = []  # list of tuples (color, [cells])

        failed = False
        for color in obj_colors:
            placed = False
            for _ in range(120):  # try several times to place this object
                size = random.choice([1, 2, 3])
                # diagonal orientations avoid orthogonal adjacency
                orient = random.choice(['dr', 'dl', 'ur', 'ul'])
                offsets = []
                if size == 1:
                    offsets = [(0, 0)]
                else:
                    offsets = []
                    for k in range(size):
                        if orient == 'dr':
                            offsets.append((k, k))
                        elif orient == 'dl':
                            offsets.append((k, -k))
                        elif orient == 'ur':
                            offsets.append((-k, k))
                        else:
                            offsets.append((-k, -k))
                # compute anchor bounds so all offsets fit
                min_r = -min(o[0] for o in offsets)
                max_r = height - 1 - max(o[0] for o in offsets)
                min_c = -min(o[1] for o in offsets)
                max_c = width - 1 - max(o[1] for o in offsets)
                if min_r > max_r or min_c > max_c:
                    continue
                ar_anchor = random.randint(min_r, max_r)
                ac_anchor = random.randint(min_c, max_c)
                cells = [(ar_anchor + o[0], ac_anchor + o[1]) for o in offsets]
                # Ensure no overlap with arrow or previous objects
                bad = False
                for cell in cells:
                    if cell in occupied:
                        bad = True
                        break
                if bad:
                    continue
                # Place object
                for (r, c) in cells:
                    grid[r][c] = color
                for cell in cells:
                    occupied.add(cell)
                objects.append((color, cells))
                placed = True
                break
            if not placed:
                failed = True
                break

        if failed:
            # Try a fresh configuration
            if attempts > 1000:
                # extremely unlikely; give up and shrink requirements
                break
            continue

        # Compute movement: each non-arrow colored cell moves by (dr,dc)
        new_positions = defaultdict(list)
        for color, cells in objects:
            for (r, c) in cells:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in arrow_cells:
                    new_positions[(nr, nc)].append(color)

        # Build cyclic mapping from the sorted set of object colors (this is deducible from input)
        palette_used = sorted({color for color, _ in objects})
        if len(palette_used) == 0:
            # nothing moved; try again
            continue
        cycle = {palette_used[i]: palette_used[(i + 1) % len(palette_used)] for i in range(len(palette_used))}

        # Build output grid
        output = [[0 for _ in range(width)] for _ in range(height)]
        for (r, c) in arrow_cells:
            output[r][c] = arrow_color

        for (r, c), cols in new_positions.items():
            if len(cols) == 1:
                output[r][c] = cols[0]
            else:
                if len(set(cols)) == 1:
                    # all identical -> merge into next color in cycle
                    output[r][c] = cycle[cols[0]]
                else:
                    # differing colors annihilate
                    output[r][c] = 0

        # Reject trivial case where nothing changed
        if output == grid:
            if attempts > 1000:
                # fallback: small guaranteed change: move the first object's first cell if possible
                # but extremely unlikely; continue looping
                pass
            continue

        return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import defaultdict

def p(input_grid):
    # Convert input to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Detect the arrow glyph: find two orthogonally adjacent identical non-zero cells.
    arrow_color = None
    arrow_dir = None
    # Search horizontal adjacency first
    for r in range(height):
        for c in range(width - 1):
            if grid[r][c] != 0 and grid[r][c] == grid[r][c + 1]:
                arrow_color = grid[r][c]
                arrow_dir = 'right'
                break
        if arrow_color is not None:
            break
    # If not found, search vertical adjacency
    if arrow_color is None:
        for c in range(width):
            for r in range(height - 1):
                if grid[r][c] != 0 and grid[r][c] == grid[r + 1][c]:
                    arrow_color = grid[r][c]
                    arrow_dir = 'down'
                    break
            if arrow_color is not None:
                break

    # Collect particle colors (non-zero, excluding arrow color)
    particle_colors = sorted({grid[r][c] for r in range(height) for c in range(width)
                              if grid[r][c] != 0 and grid[r][c] != arrow_color})

    # Build cycle mapping from the sorted unique particle colors (deducible from input)
    cycle = {}
    if particle_colors:
        for i, col in enumerate(particle_colors):
            cycle[col] = particle_colors[(i + 1) % len(particle_colors)]

    # Movement vector
    dr, dc = (0, 1) if arrow_dir == 'right' else (1, 0)

    # Compute incoming colors at each destination cell
    incoming = defaultdict(list)
    for r in range(height):
        for c in range(width):
            val = grid[r][c]
            if val == 0 or val == arrow_color:
                continue
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and (nr, nc) != (None, None):
                # We also mimic the generator's behavior of not allowing landing on arrow cells
                if (nr, nc) in [(rr, cc) for rr in range(height) for cc in range(width) if grid[rr][cc] == arrow_color]:
                    # landing on arrow cell is disallowed (generator avoided such placements)
                    continue
                incoming[(nr, nc)].append(val)

    # Build output grid with arrow preserved
    output = [[0 for _ in range(width)] for _ in range(height)]
    # mark arrow cells explicitly
    for r in range(height):
        for c in range(width - 1):
            if grid[r][c] != 0 and grid[r][c] == grid[r][c + 1]:
                output[r][c] = grid[r][c]
                output[r][c + 1] = grid[r][c]
                break
        if any(output[r][c] != 0 for c in range(width)):
            break
    if all(output[r][c] == 0 for r in range(height) for c in range(width)):
        # fallback: vertical search
        for c in range(width):
            for r in range(height - 1):
                if grid[r][c] != 0 and grid[r][c] == grid[r + 1][c]:
                    output[r][c] = grid[r][c]
                    output[r + 1][c] = grid[r][c]
                    break
            if any(output[r][c] != 0 for r in range(height)):
                break

    # Apply collision rules to incoming lists
    for (r, c), cols in incoming.items():
        if len(cols) == 1:
            output[r][c] = cols[0]
        else:
            if len(set(cols)) == 1:
                # all identical -> merge via cycle
                output[r][c] = cycle.get(cols[0], cols[0])
            else:
                # differing colors annihilate -> remain 0
                output[r][c] = 0

    return tuple(tuple(row) for row in output)

