# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 00b45bde
Difficulty: hard

=== Tags ===
- Signal to structure
- Path following
- Detect connectedness

=== Description ===
Input grids feature a background color (0) and two distinct visual elements: a
primary connected structure (all cells of color 1) and a continuous signal path
(all cells of color 2). The signal path is a sequence of cells forming a
connected path (4-neighborhood) that may intersect the primary structure or
extend into disconnected regions. The primary structure is always fully
connected (4-neighborhood), while the signal path may contain branches or loops
that traverse both connected and disconnected areas relative to the primary
structure.  The output grid transforms the input by: 1. Detecting all segments
of the signal path that share 4-neighborhood adjacency with the primary
structure (color 1). These are "connected segments". 2. Replacing all connected
segments of the signal path (color 2) with a new structural color (color 3). 3.
Leaving disconnected segments of the signal path (color 2) unchanged. 4.
Expanding the primary structure to include all connected segments (now color 3),
ensuring the entire structure (original color 1 + new color 3) remains a single
connected region (4-neighborhood).  The key challenge requires distinguishing
between connected and disconnected segments of the signal path through visual
analysis of adjacency to the primary structure, then applying the transformation
only to connected segments while maintaining the integrity of the expanded
structure. The output must preserve all original primary structure cells (color
1), replace connected path segments with color 3, and leave disconnected path
segments as color 2.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    size = random.randint(15, 30)
    width = size
    height = size
    bg = 0
    primary = 1
    signal = 2
    new_struct = 3
    
    primary_size = random.randint(10, 20)
    primary_pixels = common.continuous_creature(primary_size, width, height)
    input_grid = common.grid(width, height, bg)
    for r, c in primary_pixels:
        input_grid[r][c] = primary
    
    adjacent_cells = []
    for r, c in primary_pixels:
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == bg:
                adjacent_cells.append((nr, nc))
    
    if not adjacent_cells:
        return generate()
    
    start = random.choice(adjacent_cells)
    path = [start]
    path_length = random.randint(15, 30)
    for _ in range(path_length - 1):
        r, c = path[-1]
        directions = [(1,0), (-1,0), (0,1), (0,-1)]
        random.shuffle(directions)
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == bg:
                path.append((nr, nc))
                break
        else:
            break
    
    for r, c in path:
        input_grid[r][c] = signal
    
    output_grid = [row[:] for row in input_grid]
    for r, c in path:
        if input_grid[r][c] == signal:
            adjacent_to_primary = False
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == primary:
                    adjacent_to_primary = True
                    break
            if adjacent_to_primary:
                output_grid[r][c] = new_struct
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 2:
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 1:
                        grid[r][c] = 3
                        break
    return tuple(tuple(row) for row in grid)
