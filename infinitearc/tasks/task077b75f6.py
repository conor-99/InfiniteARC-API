# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 077b75f6
Difficulty: insane

=== Tags ===
- Symmetry completion

=== Description ===
Symmetric Echoes  Input grids feature a large, complex arrangement of colored
elements (0-9) on a grid with dimensions ranging from 15×15 to 30×30. The
background color (0) is absent in all non-background regions. The grid contains
multiple disconnected regions of distinct colors, each forming an asymmetric
shape that requires completion to achieve full symmetry. The symmetry axis for
the entire grid is determined by its geometric properties: the vertical midline
(for grids with even width, the axis lies between columns; for odd width, it
passes through the central column).  The output grid completes the symmetry by
mirroring every non-background element across the vertical midline. For each
cell (r, c) containing a non-zero color, the corresponding mirrored cell (r,
width - 1 - c) must match its color. If the mirrored cell contains a different
non-zero color, it is overwritten to match the original cell's color. Background
cells (0) are never mirrored and remain unchanged. The transformation must be
applied to all non-background elements simultaneously, with no exceptions or
priority rules. The completed grid must exhibit perfect vertical symmetry, with
every non-background element having a matching counterpart on the opposite side
of the axis.  Insane difficulty arises from the following challenges: the grid
contains up to 20 distinct colors, with elements distributed across all
quadrants of the grid; many regions overlap or are adjacent, creating complex
spatial relationships; the vertical midline creates ambiguity for even-width
grids due to the axis lying between columns; and the presence of numerous
missing elements requires careful spatial reasoning to identify all necessary
mirror positions. The task demands precise pattern recognition of mirrored
positions across the entire grid, with no visual cues indicating the symmetry
axis—only the geometric properties of the grid itself. The solution requires
resolving all symmetry conflicts through consistent application of the vertical
mirroring rule, with no room for interpretation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(15, 30)
    height = random.randint(15, 30)
    output = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range((width + 1) // 2):
            color = random.randint(1, 9)
            output[r][c] = color
            output[r][width - 1 - c] = color
    input_grid = [row[:] for row in output]
    for r in range(height):
        for c in range((width + 1) // 2):
            mirror_c = width - 1 - c
            if width % 2 == 1 and c == width // 2:
                continue
            if random.random() < 0.3:
                if random.random() < 0.5:
                    input_grid[r][mirror_c] = 0
                else:
                    new_color = random.choice([x for x in range(1, 10) if x != output[r][c]])
                    input_grid[r][mirror_c] = new_color
    if input_grid == output:
        r = random.randint(0, height - 1)
        c = random.randint(0, (width + 1) // 2 - 1)
        if width % 2 == 1 and c == width // 2:
            c = 0
        mirror_c = width - 1 - c
        input_grid[r][mirror_c] = 0
    return {
        'input': input_grid,
        'output': output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    output = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range((width + 1) // 2):
            if input_grid[r][c] != 0:
                output[r][c] = input_grid[r][c]
                output[r][width - 1 - c] = input_grid[r][c]
    return output
