# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: b5451194
Difficulty: hard

=== Tags ===
- Spatial signal
- Bidirectional mapping
- Hierarchical logic composition

=== Description ===
# Hierarchical Signal Pathway  Input grids feature a single background color
(0), with three distinct non-background colors: Signal (S), Mapping (M), and
Hierarchical (H). Signals (S) are isolated single cells not adjacent to other S
or M. Mappings (M) are isolated single cells. Hierarchical (H) elements form a
regular grid structure (e.g., H cells appear at positions (3i, 3j) for integers
i, j, creating a 3×3 lattice of regions).  The transformation to the output grid
follows hierarchical logic composition:  1. **Hierarchical Region
Identification:** Each cell belongs to a hierarchical region defined by the H
grid. The region for a cell (r, c) is determined by floor(r/3) and floor(c/3),
creating a grid of 3×3 blocks.  2. **Bidirectional Signal Mapping:** For each
Signal S, find the Mapping M within the same hierarchical region. If multiple M
exist, select the one with the smallest row index, then column index. If no M
exists in the region, find the nearest M in adjacent regions (horizontally or
vertically), again selecting the closest by row/column order.  3. **Path
Drawing:** Draw the shortest orthogonal path (only moving horizontally or
vertically) between S and M, passing only through Hierarchical (H) cells. The
path must not pass through non-H cells (background or other elements).  4.
**Color Transformation:** Replace all cells along the path (including S and M)
with a color determined by the path's primary direction: horizontal (left/right)
paths use color 1, vertical (up/down) paths use color 2. All H cells along the
path are replaced with this color.  5. **Hierarchical Composition:** If two
Signals map to the same M, the Signal with the shorter path length is
prioritized, and the other Signal maps to the next closest M in hierarchical
order.  The output grid retains all non-path elements unchanged except for the
transformed path, S, M, and H cells along the path.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Grid size
    width = random.randint(5, 25)
    height = random.randint(5, 25)
    grid = [[0 for _ in range(width)] for _ in range(height)]

    # Place Hierarchical H cells at (3i, 3j)
    h_positions = []
    for r in range(0, height, 3):
        for c in range(0, width, 3):
            grid[r][c] = 3
            h_positions.append((r, c))

    # Ensure enough positions
    if len(h_positions) < 2:
        # fallback: make a slightly larger grid (deterministic fallback)
        width = max(5, width + 1)
        height = max(5, height + 1)
        grid = [[0 for _ in range(width)] for _ in range(height)]
        h_positions = []
        for r in range(0, height, 3):
            for c in range(0, width, 3):
                grid[r][c] = 3
                h_positions.append((r, c))

    # Choose total number of special cells (S + M)
    max_total = min(8, len(h_positions))
    total = random.randint(2, max_total)
    num_s = random.randint(1, total - 1)
    num_m = total - num_s

    # Sample positions for S and M on H positions (so path uses only H cells)
    chosen = random.sample(h_positions, total)
    s_positions = chosen[:num_s]
    m_positions = chosen[num_s:]

    # Place S (color 1) and M (color 2) on the grid (overwrites H there)
    for (r, c) in s_positions:
        grid[r][c] = 1
    for (r, c) in m_positions:
        grid[r][c] = 2

    # Helper: region coordinates
    def region(pos):
        return (pos[0] // 3, pos[1] // 3)

    # Build candidate lists for each signal S: Ms sorted by region-distance then row then col
    candidates = {}
    m_regions = {m: region(m) for m in m_positions}
    for s in s_positions:
        sr, sc = region(s)
        def key(m):
            mr, mc = m_regions[m]
            dist = abs(mr - sr) + abs(mc - sc)
            return (dist, m[0], m[1])
        sorted_ms = sorted(m_positions, key=key)
        candidates[s] = sorted_ms

    # Greedy assignment: signals with shorter first-choice distance get priority
    # Prepare order by first candidate distance then signal position
    def first_dist(s):
        m = candidates[s][0]
        mr, mc = m_regions[m]
        sr, sc = region(s)
        return (abs(mr - sr) + abs(mc - sc), s[0], s[1])

    signals_order = sorted(s_positions, key=first_dist)
    assigned_m = set()
    s_to_m = {}
    for s in signals_order:
        for m in candidates[s]:
            if m in assigned_m:
                continue
            s_to_m[s] = m
            assigned_m.add(m)
            break
        # If no unassigned m left (shouldn't happen because num_m >=1), leave unassigned

    # Create output copy and draw paths along H cells (steps of 3)
    output = [row[:] for row in grid]

    def inclusive_step(a, b, step):
        if a == b:
            return [a]
        if step > 0:
            return list(range(a, b + 1, step))
        else:
            return list(range(a, b - 1, step))

    for s, m in s_to_m.items():
        r1, c1 = s
        r2, c2 = m
        # Horizontal-first L-shaped route along H nodes (step = 3)
        crow_step = 3 if c2 >= c1 else -3
        rrow_step = 3 if r2 >= r1 else -3
        path = []
        for c in inclusive_step(c1, c2, crow_step):
            path.append((r1, c))
        for r in inclusive_step(r1, r2, rrow_step):
            if (r, c2) not in path:
                path.append((r, c2))

        horizontal = abs(c2 - c1)
        vertical = abs(r2 - r1)
        color = 1 if horizontal > vertical else 2

        for (r, c) in path:
            output[r][c] = color

    return {'input': grid, 'output': output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height else 0

    # Detect S (color 1), M (color 2) and H (other non-zero colors like 3)
    s_positions = []
    m_positions = []
    for r in range(height):
        for c in range(width):
            val = grid[r][c]
            if val == 1:
                s_positions.append((r, c))
            elif val == 2:
                m_positions.append((r, c))

    # If there are no signals or no mappings, return grid unchanged
    if not s_positions or not m_positions:
        return grid

    # Helper: region coordinate and region-distance based sorting
    def region(pos):
        return (pos[0] // 3, pos[1] // 3)

    m_regions = {m: region(m) for m in m_positions}

    # Build candidate lists for each S: Ms sorted by region-distance then row then col
    candidates = {}
    for s in s_positions:
        sr, sc = region(s)
        def key(m):
            mr, mc = m_regions[m]
            dist = abs(mr - sr) + abs(mc - sc)
            return (dist, m[0], m[1])
        sorted_ms = sorted(m_positions, key=key)
        candidates[s] = sorted_ms

    # Greedy assignment: signals with shorter first-choice distance get priority
    def first_dist(s):
        m = candidates[s][0]
        mr, mc = m_regions[m]
        sr, sc = region(s)
        return (abs(mr - sr) + abs(mc - sc), s[0], s[1])

    signals_order = sorted(s_positions, key=first_dist)
    assigned_m = set()
    s_to_m = {}
    for s in signals_order:
        for m in candidates[s]:
            if m in assigned_m:
                continue
            s_to_m[s] = m
            assigned_m.add(m)
            break

    # Draw paths on a copy of the input
    output = [row[:] for row in grid]

    def inclusive_step(a, b, step):
        if a == b:
            return [a]
        if step > 0:
            return list(range(a, b + 1, step))
        else:
            return list(range(a, b - 1, step))

    for s, m in s_to_m.items():
        r1, c1 = s
        r2, c2 = m
        crow_step = 3 if c2 >= c1 else -3
        rrow_step = 3 if r2 >= r1 else -3
        path = []
        for c in inclusive_step(c1, c2, crow_step):
            path.append((r1, c))
        for r in inclusive_step(r1, r2, rrow_step):
            if (r, c2) not in path:
                path.append((r, c2))

        horizontal = abs(c2 - c1)
        vertical = abs(r2 - r1)
        color = 1 if horizontal > vertical else 2

        for (r, c) in path:
            output[r][c] = color

    return output

