# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: c4068130
Difficulty: medium–hard

=== Tags ===
- State machine grid
- Enclosure completion

=== Description ===
Input grids contain multiple disjoint open enclosures (U-shaped, L-shaped, or
partial rectangles) formed by a single boundary color (e.g., red), each missing
exactly one side (top, bottom, left, or right). The background is a neutral
color (e.g., gray). Each enclosure is accompanied by a state marker (a small dot
of a distinct color, e.g., blue) positioned adjacent to the missing side—north,
south, east, or west of the enclosure's boundary. The state markers do not
overlap with the boundary or background.   The output grid completes each
enclosure by filling the missing side with the boundary color, forming a closed
shape. The state markers remain visible in the output but are not part of the
completed boundary. The completion rule requires identifying the directional
relationship between each state marker's position and the enclosure's
orientation (e.g., a marker north of the enclosure implies the top side is
missing, so the top row of boundary cells is added). This transformation must be
applied consistently across all enclosures, even when multiple enclosures are
nested, overlapping in proximity, or oriented differently. The medium-hard
difficulty arises from the need to correctly interpret the spatial relationship
between markers and enclosures amid varying shapes, sizes, and grid layouts,
without relying on numerical properties or memorizing patterns.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import copy
import common

def generate():
    # Grid size (leave a 1-cell margin so markers can be placed outside enclosures)
    width = random.randint(8, 20)
    height = random.randint(8, 20)

    background = 5
    grid_input = common.grid(width, height, background)
    grid_output = [row[:] for row in grid_input]

    # Choose distinct colors for boundary and marker
    boundary_color = common.random_color(exclude=[background])
    marker_color = common.random_color(exclude=[background, boundary_color])

    # Number of enclosures
    num_enclosures = random.randint(2, 4)

    # Keep track of expanded bounding boxes (with a 1-cell margin) to ensure enclosures are disjoint
    ext_boxes = []  # list of (top, left, bottom, right) inclusive

    placed = 0
    attempts = 0
    max_attempts = 1000

    while placed < num_enclosures and attempts < max_attempts:
        attempts += 1
        # Choose enclosure size (require at least 3x3 so the side-detection is unambiguous)
        max_h = min(6, height - 4)
        max_w = min(6, width - 4)
        if max_h < 3 or max_w < 3:
            break
        h = random.randint(3, max_h)
        w = random.randint(3, max_w)

        # Choose top-left inside a 1-cell margin so markers can be placed outside
        r = random.randint(1, height - h - 1)
        c = random.randint(1, width - w - 1)

        missing_side = random.choice(['top', 'bottom', 'left', 'right'])

        # Expanded box to reserve space for the enclosure plus one-cell margin (so markers won't collide)
        ext_top = r - 1
        ext_left = c - 1
        ext_bottom = r + h
        ext_right = c + w

        # Check for overlap with previously placed expanded boxes
        overlap = False
        for (bt, bl, bb, br) in ext_boxes:
            if not (ext_right < bl or ext_left > br or ext_bottom < bt or ext_top > bb):
                overlap = True
                break
        if overlap:
            continue

        # Compute marker position (outside the missing side, centered)
        if missing_side == 'top':
            marker_r = r - 1
            marker_c = c + (w // 2)
        elif missing_side == 'bottom':
            marker_r = r + h
            marker_c = c + (w // 2)
        elif missing_side == 'left':
            marker_r = r + (h // 2)
            marker_c = c - 1
        else:  # right
            marker_r = r + (h // 2)
            marker_c = c + w

        # Marker must be inside the grid and currently on background
        if not (0 <= marker_r < height and 0 <= marker_c < width):
            continue
        if grid_input[marker_r][marker_c] != background:
            continue

        # Draw the three sides (leave out the missing side) on the input grid
        # Top row is r, bottom row is r+h-1, left col is c, right col is c+w-1
        if missing_side != 'top':
            for j in range(c, c + w):
                grid_input[r][j] = boundary_color
        if missing_side != 'bottom':
            for j in range(c, c + w):
                grid_input[r + h - 1][j] = boundary_color
        if missing_side != 'left':
            for i in range(r, r + h):
                grid_input[i][c] = boundary_color
        if missing_side != 'right':
            for i in range(r, r + h):
                grid_input[i][c + w - 1] = boundary_color

        # Place marker on the input grid
        grid_input[marker_r][marker_c] = marker_color

        # On the output grid we must show the enclosure completed (all four sides), and keep the marker visible
        # Draw the full rectangle on the output grid (overwrite background or prior background)
        for j in range(c, c + w):
            grid_output[r][j] = boundary_color
            grid_output[r + h - 1][j] = boundary_color
        for i in range(r, r + h):
            grid_output[i][c] = boundary_color
            grid_output[i][c + w - 1] = boundary_color

        # Place the marker on the output (marker must remain visible and should not be considered part of the boundary)
        grid_output[marker_r][marker_c] = marker_color

        # Reserve the expanded box and count this enclosure as placed
        ext_boxes.append((ext_top, ext_left, ext_bottom, ext_right))
        placed += 1

    # If for some reason we couldn't place enough enclosures, try again (rare)
    if placed < 2:
        return generate()

    return {
        'input': grid_input,
        'output': grid_output
    }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    from collections import deque
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Count colors to identify background and other colors
    counts = {}
    for r in range(height):
        for c in range(width):
            counts[grid[r][c]] = counts.get(grid[r][c], 0) + 1

    # Background is the most frequent color
    background = max(counts.items(), key=lambda kv: kv[1])[0]

    # Choose the boundary color as the most frequent non-background color
    non_bg = [(counts[col], col) for col in counts if col != background]
    if not non_bg:
        return tuple(tuple(row) for row in grid)
    non_bg.sort(reverse=True)
    boundary_color = non_bg[0][1]

    # Marker color is any other non-background, non-boundary color (may be None)
    marker_color = None
    for col in counts:
        if col != background and col != boundary_color:
            marker_color = col
            break

    # Find connected components of the boundary color (4-connected)
    visited = [[False] * width for _ in range(height)]
    components = []
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and grid[r][c] == boundary_color:
                comp = []
                q = deque([(r, c)])
                visited[r][c] = True
                while q:
                    cr, cc = q.popleft()
                    comp.append((cr, cc))
                    for dr, dc in [(-1, 0), (0, 1), (1, 0), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == boundary_color:
                            visited[nr][nc] = True
                            q.append((nr, nc))
                components.append(comp)

    out = [row[:] for row in grid]

    for comp in components:
        rs = [p[0] for p in comp]
        cs = [p[1] for p in comp]
        min_r, max_r = min(rs), max(rs)
        min_c, max_c = min(cs), max(cs)

        # Check for the presence of the interior of each side (exclude corners)
        # Our generator ensures enclosures are at least 3x3 so these interior ranges are non-empty
        top_present = any(grid[min_r][j] == boundary_color for j in range(min_c + 1, max_c)) if max_c - min_c >= 2 else any(grid[min_r][j] == boundary_color for j in range(min_c, max_c + 1))
        bottom_present = any(grid[max_r][j] == boundary_color for j in range(min_c + 1, max_c)) if max_c - min_c >= 2 else any(grid[max_r][j] == boundary_color for j in range(min_c, max_c + 1))
        left_present = any(grid[i][min_c] == boundary_color for i in range(min_r + 1, max_r)) if max_r - min_r >= 2 else any(grid[i][min_c] == boundary_color for i in range(min_r, max_r + 1))
        right_present = any(grid[i][max_c] == boundary_color for i in range(min_r + 1, max_r)) if max_r - min_r >= 2 else any(grid[i][max_c] == boundary_color for i in range(min_r, max_r + 1))

        sides = {'top': top_present, 'bottom': bottom_present, 'left': left_present, 'right': right_present}
        missing = [s for s, present in sides.items() if not present]

        if not missing:
            # Fallback: choose the side with the fewest boundary cells (inclusive of corners)
            counts_side = {
                'top': sum(1 for j in range(min_c, max_c + 1) if grid[min_r][j] == boundary_color),
                'bottom': sum(1 for j in range(min_c, max_c + 1) if grid[max_r][j] == boundary_color),
                'left': sum(1 for i in range(min_r, max_r + 1) if grid[i][min_c] == boundary_color),
                'right': sum(1 for i in range(min_r, max_r + 1) if grid[i][max_c] == boundary_color)
            }
            missing = [min(counts_side, key=lambda k: counts_side[k])]

        side = missing[0]

        # Fill the missing side in the output, but do not overwrite the marker if present there
        if side == 'top':
            rfill = min_r
            for j in range(min_c, max_c + 1):
                if marker_color is not None and out[rfill][j] == marker_color:
                    continue
                out[rfill][j] = boundary_color
        elif side == 'bottom':
            rfill = max_r
            for j in range(min_c, max_c + 1):
                if marker_color is not None and out[rfill][j] == marker_color:
                    continue
                out[rfill][j] = boundary_color
        elif side == 'left':
            cfill = min_c
            for i in range(min_r, max_r + 1):
                if marker_color is not None and out[i][cfill] == marker_color:
                    continue
                out[i][cfill] = boundary_color
        elif side == 'right':
            cfill = max_c
            for i in range(min_r, max_r + 1):
                if marker_color is not None and out[i][cfill] == marker_color:
                    continue
                out[i][cfill] = boundary_color

    return tuple(tuple(row) for row in out)
