# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: f281a4dd
Difficulty: medium

=== Tags ===
- Lattice completion
- Concentric

=== Description ===
The task involves transforming an input grid into an output grid by completing
concentric lattice patterns. Each input grid features a central cell with
concentric rings (layers) of cells, where each ring corresponds to a specific
Manhattan distance from the grid's center (calculated as the midpoint of the
grid dimensions). Cells within a ring may be filled with a non-zero color or
empty (value 0). The output grid completes each ring by replacing all empty
cells (0) within the ring with the non-zero color present in that ring. Rings
without any non-zero cells are left unchanged, but valid inputs ensure at least
one non-zero cell exists per ring requiring completion, guaranteeing a
transformation. The rule relies on identifying concentric layers based on
distance from the center and propagating the dominant color within each layer to
fill gaps.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random
from collections import defaultdict

def generate():
    h = random.choice([3,5,7,9,11,13,15,17,19,21,23,25,27,29])
    w = random.choice([3,5,7,9,11,13,15,17,19,21,23,25,27,29])
    center_r = (h-1)//2
    center_c = (w-1)//2
    input_grid = common.grid(w, h, 0)
    groups = defaultdict(list)
    for r in range(h):
        for c in range(w):
            d = abs(r - center_r) + abs(c - center_c)
            groups[d].append((r, c))
    colors = {}
    for d, pixels in groups.items():
        color = random.randint(1,9)
        colors[d] = color
        if len(pixels) == 1:
            r, c = pixels[0]
            input_grid[r][c] = color
        else:
            num_to_color = random.randint(1, len(pixels) - 1)
            chosen = random.sample(pixels, num_to_color)
            for r, c in chosen:
                input_grid[r][c] = color
    output_grid = [row[:] for row in input_grid]
    for d, pixels in groups.items():
        for r, c in pixels:
            if output_grid[r][c] == 0:
                output_grid[r][c] = colors[d]
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
import random
from collections import defaultdict

def p(input_grid):
    h = len(input_grid)
    w = len(input_grid[0])
    center_r = (h-1)//2
    center_c = (w-1)//2
    groups = defaultdict(list)
    for r in range(h):
        for c in range(w):
            d = abs(r - center_r) + abs(c - center_c)
            groups[d].append((r, c))
    output_grid = [list(row) for row in input_grid]
    for d, pixels in groups.items():
        color = None
        for r, c in pixels:
            if input_grid[r][c] != 0:
                color = input_grid[r][c]
                break
        if color is not None:
            for r, c in pixels:
                if output_grid[r][c] == 0:
                    output_grid[r][c] = color
    return output_grid
