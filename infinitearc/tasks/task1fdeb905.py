# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 1fdeb905
Difficulty: insane

=== Tags ===
- Cooperative beams
- Portal momentum pathing
- Add corner markers

=== Description ===
Input grids consist of a single background color with multiple colored beams
(each a continuous straight line of uniform color, either horizontal or
vertical) traveling through the grid. These beams intersect at various points,
and the grid contains specific portal symbols (distinct from beams and
background) that redirect beam paths. Existing corner markers (small, distinct
symbols at grid intersections) indicate where beams may need to turn. Beams
travel in their initial direction until colliding with a wall (background),
another beam, or a portal.  The transformation requires adding new corner
markers at critical turning points where beams must change direction to continue
without overlapping walls or other beams. Each portal redirects beams according
to its orientation (e.g., a portal with a right-angle symbol turns beams 90
degrees clockwise). When a beam's path is blocked by a wall, a new corner marker
is placed at the turning point, and the beam continues in the new direction.
Beams must cooperate to avoid collisions: if two beams intersect at a point
where a turn is required, a single new corner marker is added to coordinate both
beams' redirections. The output grid retains all original elements (background,
beams, portals, existing markers) while adding precisely the necessary corner
markers to enable all beams to reach the grid's edge without overlap, with paths
adjusted to follow portal rules and turning logic.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    """
    Generate an ARC style input-output pair for the corner-marker task.

    Strategy:
    - Create a grid with background 0.
    - Place several beams (colors 1..6) as polylines made of straight horizontal/vertical segments.
      Consecutive segments are separated by a single empty corner cell (a diagonal gap).
      That empty cell is considered the turning point where a corner marker (9) is required.
    - Compute all required corner cells by detecting diagonal pairs of same-colored beam cells
      that correspond to the end of one segment and the start of the next. This uses the same
      local-orientation heuristic the solver will use so they match exactly.
    - Randomly include some of the required corners in the input (color 9). The output
      includes all required corner markers.
    - Place a few portal symbols (8) at empty locations that do not collide with beams or corners.

    The output keeps all original elements and adds precisely the missing corner markers.
    """
    # Keep trying until we produce at least one required corner (ensures input != output)
    for attempt in range(50):
        width = random.randint(10, 20)
        height = random.randint(10, 20)
        ingrid = grid(width, height, 0)

        # helper
        def inside(r, c):
            return 0 <= r < height and 0 <= c < width

        # directions
        D = {
            'E': (0, 1),
            'W': (0, -1),
            'S': (1, 0),
            'N': (-1, 0)
        }
        LEFT = {'E': 'N', 'N': 'W', 'W': 'S', 'S': 'E'}
        RIGHT = {'E': 'S', 'S': 'W', 'W': 'N', 'N': 'E'}

        used = set()  # occupied by beams
        beams_by_color = {}

        beam_colors = [1, 2, 3, 4, 5, 6]
        random.shuffle(beam_colors)
        nbeams = random.randint(2, 5)

        # ensure at least one beam has a turn
        must_have_turn_for = random.randrange(nbeams)

        for bi in range(nbeams):
            color = beam_colors[bi % len(beam_colors)]
            placed = False
            tries = 0
            while not placed and tries < 200:
                tries += 1
                # number of straight segments for this beam
                if bi == must_have_turn_for:
                    segments = random.choice([2, 3])
                else:
                    segments = random.choice([1, 2, 3])

                # pick a random start cell
                sr = random.randint(0, height - 1)
                sc = random.randint(0, width - 1)
                start = (sr, sc)
                cur_dir = random.choice(['E', 'W', 'N', 'S'])

                local_cells = []  # cells for this beam build
                ok = True
                cur_start = start

                for si in range(segments):
                    dr, dc = D[cur_dir]
                    # determine how many cells we can place from cur_start in cur_dir
                    rtest, ctest = cur_start
                    maxlen = 0
                    while inside(rtest, ctest) and (rtest, ctest) not in used and (rtest, ctest) not in local_cells:
                        maxlen += 1
                        rtest += dr
                        ctest += dc
                    if maxlen < 2:
                        ok = False
                        break
                    length = random.randint(2, maxlen)
                    seg = [(cur_start[0] + dr * i, cur_start[1] + dc * i) for i in range(length)]
                    # verify again (should be ok)
                    conflict = False
                    for cell in seg:
                        if not inside(cell[0], cell[1]) or cell in used or cell in local_cells:
                            conflict = True
                            break
                    if conflict:
                        ok = False
                        break

                    local_cells.extend(seg)
                    end = seg[-1]

                    if si < segments - 1:
                        # choose a left or right turn
                        turn = random.choice(['L', 'R'])
                        nxt_dir = LEFT[cur_dir] if turn == 'L' else RIGHT[cur_dir]
                        dr2, dc2 = D[nxt_dir]
                        corner = (end[0] + dr2, end[1] + dc2)
                        next_start = (end[0] + dr + dr2, end[1] + dc + dc2)
                        # next_start and corner must be valid and not collide
                        if not inside(next_start[0], next_start[1]) or not inside(corner[0], corner[1]):
                            ok = False
                            break
                        if next_start in used or next_start in local_cells or corner in used or corner in local_cells:
                            ok = False
                            break
                        # ensure next segment would be at least length 2
                        r2, c2 = next_start
                        maxlen2 = 0
                        rtmp, ctmp = r2, c2
                        while inside(rtmp, ctmp) and (rtmp, ctmp) not in used and (rtmp, ctmp) not in local_cells:
                            maxlen2 += 1
                            rtmp += dr2
                            ctmp += dc2
                        if maxlen2 < 2:
                            ok = False
                            break

                        # accept and move on
                        cur_start = next_start
                        cur_dir = nxt_dir

                if ok:
                    # commit cells
                    for (r, c) in local_cells:
                        used.add((r, c))
                        ingrid[r][c] = color
                    beams_by_color.setdefault(color, set()).update(local_cells)
                    placed = True

            # end tries for a beam

        # compute required corner markers using the same heuristic the solver will use
        required_corners = set()

        for color, cells in beams_by_color.items():
            cellset = set(cells)
            for (r, c) in list(cellset):
                for dr, dc in [(1, 1), (1, -1), (-1, 1), (-1, -1)]:
                    rr, cc = r + dr, c + dc
                    if not inside(rr, cc):
                        continue
                    if (rr, cc) not in cellset:
                        continue
                    a = (r, c)
                    b = (rr, cc)

                    def orientation(cell):
                        rr, cc = cell
                        if (rr, cc - 1) in cellset or (rr, cc + 1) in cellset:
                            return 'H'
                        if (rr - 1, cc) in cellset or (rr + 1, cc) in cellset:
                            return 'V'
                        return None

                    oa = orientation(a)
                    ob = orientation(b)
                    # prefer the candidate that lies in the direction of the segment that ends
                    if oa == 'H' and ob == 'V':
                        candidate = (b[0], a[1])
                    elif oa == 'V' and ob == 'H':
                        candidate = (a[0], b[1])
                    elif oa is None and ob is not None:
                        # favor the oriented one
                        if ob == 'H':
                            candidate = (a[0], b[1])
                        else:
                            candidate = (b[0], a[1])
                    elif ob is None and oa is not None:
                        if oa == 'H':
                            candidate = (b[0], a[1])
                        else:
                            candidate = (a[0], b[1])
                    else:
                        # ambiguous or both None -- skip
                        continue

                    cr, cc = candidate
                    if not inside(cr, cc):
                        continue
                    # do not overwrite beams/portals/markers
                    if (cr, cc) in used:
                        continue
                    # candidate must be empty in the grid
                    if ingrid[cr][cc] != 0:
                        continue
                    required_corners.add(candidate)

        # ensure we found at least one required corner marker
        if len(required_corners) == 0:
            continue

        # Randomly include some subset of the required corners in the input
        corners = list(required_corners)
        # ensure at least one required corner is missing from the input
        include_count = random.randint(0, max(0, len(corners) - 1))
        included = set(random.sample(corners, include_count)) if include_count > 0 else set()

        input_grid = [row[:] for row in ingrid]
        output_grid = [row[:] for row in ingrid]

        # put included corners in input
        for (r, c) in included:
            input_grid[r][c] = 9
        # put all required corners in output
        for (r, c) in required_corners:
            output_grid[r][c] = 9

        # add a few portals (color 8) at empty locations that do not interfere
        empty_cells = [(r, c) for r in range(height) for c in range(width) if (r, c) not in used and (r, c) not in required_corners and input_grid[r][c] == 0]
        random.shuffle(empty_cells)
        pcount = random.randint(0, min(3, len(empty_cells)))
        for i in range(pcount):
            pr, pc = empty_cells[i]
            input_grid[pr][pc] = 8
            output_grid[pr][pc] = 8

        # final check: make sure input != output
        if input_grid != output_grid:
            return {"input": input_grid, "output": output_grid}

    # if we reach here it's unlikely but in case generation failed many times, fall back to simple deterministic construction
    # build a tiny guaranteed example
    width = 10
    height = 10
    ingrid = grid(width, height, 0)
    # horizontal beam color 1
    for c in range(1, 6):
        ingrid[4][c] = 1
    # vertical beam color 2
    for r in range(6, 9):
        ingrid[r][6] = 2
    # required corner at (5,6)
    input_grid = [row[:] for row in ingrid]
    output_grid = [row[:] for row in ingrid]
    input_grid[5][6] = 0
    output_grid[5][6] = 9
    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    def inside(r, c):
        return 0 <= r < height and 0 <= c < width

    # find beam colors (anything that is not background(0), portal(8), or marker(9))
    beam_colors = set()
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if v not in (0, 8, 9):
                beam_colors.add(v)

    # build per-color cell sets
    cells_by_color = {}
    for color in beam_colors:
        cells_by_color[color] = set()
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if v in cells_by_color:
                cells_by_color[v].add((r, c))

    required = set()

    for color, cellset in cells_by_color.items():
        for (r, c) in list(cellset):
            for dr, dc in [(1, 1), (1, -1), (-1, 1), (-1, -1)]:
                rr, cc = r + dr, c + dc
                if not inside(rr, cc):
                    continue
                if (rr, cc) not in cellset:
                    continue
                a = (r, c)
                b = (rr, cc)

                def orientation(cell):
                    rr, cc = cell
                    if (rr, cc - 1) in cellset or (rr, cc + 1) in cellset:
                        return 'H'
                    if (rr - 1, cc) in cellset or (rr + 1, cc) in cellset:
                        return 'V'
                    return None

                oa = orientation(a)
                ob = orientation(b)

                if oa == 'H' and ob == 'V':
                    candidate = (b[0], a[1])
                elif oa == 'V' and ob == 'H':
                    candidate = (a[0], b[1])
                elif oa is None and ob is not None:
                    if ob == 'H':
                        candidate = (a[0], b[1])
                    else:
                        candidate = (b[0], a[1])
                elif ob is None and oa is not None:
                    if oa == 'H':
                        candidate = (b[0], a[1])
                    else:
                        candidate = (a[0], b[1])
                else:
                    continue

                cr, cc = candidate
                if not inside(cr, cc):
                    continue
                # do not overwrite beams/portals/markers
                if grid[cr][cc] != 0:
                    continue
                required.add(candidate)

    # set all required markers to 9 in the output copy
    out = [row[:] for row in grid]
    for (r, c) in required:
        out[r][c] = 9
    return out

