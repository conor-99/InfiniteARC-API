# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 6503c388
Difficulty: medium

=== Tags ===
- Take minimum
- Orthogonal path planning
- Take half

=== Description ===
The input grid contains multiple orthogonal pathsâ€”connected regions of a single
color where adjacent cells share a color and are connected horizontally or
vertically (not diagonally). The transformation rule identifies the shortest
such path (minimum length) among all paths in the grid, then retains only the
first half of its cells (using integer division to handle odd lengths), setting
all other cells to 0. The output grid preserves the color of the retained path
cells while clearing all other cells, resulting in a grid where only the first
half of the shortest path remains visible.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    from common import grid
    W = random.randint(5, 30)
    H = random.randint(5, 30)
    input_grid = grid(W, H, 0)
    colors = list(range(1, 10))
    color1 = random.choice(colors)
    colors.remove(color1)
    color2 = random.choice(colors)
    L_min = random.choice([2, 3, 4])
    direction = random.choice(['horizontal', 'vertical'])
    if direction == 'horizontal':
        r = random.randint(0, H-1)
        c_start = random.randint(0, W - L_min)
        for i in range(L_min):
            input_grid[r][c_start + i] = color1
    else:
        c = random.randint(0, W-1)
        r_start = random.randint(0, H - L_min)
        for i in range(L_min):
            input_grid[r_start + i][c] = color1
    max_length = W if direction == 'horizontal' else H
    L_max = random.randint(L_min + 1, min(10, max_length))
    while True:
        direction2 = random.choice(['horizontal', 'vertical'])
        max_length2 = W if direction2 == 'horizontal' else H
        L_max2 = min(10, max_length2)
        L_max2 = random.randint(L_min + 1, L_max2)
        if direction2 == 'horizontal':
            r2 = random.randint(0, H-1)
            c_start2 = random.randint(0, W - L_max2)
            overlap = False
            for i in range(L_max2):
                if input_grid[r2][c_start2 + i] != 0:
                    overlap = True
                    break
            if not overlap:
                for i in range(L_max2):
                    input_grid[r2][c_start2 + i] = color2
                break
        else:
            c2 = random.randint(0, W-1)
            r_start2 = random.randint(0, H - L_max2)
            overlap = False
            for i in range(L_max2):
                if input_grid[r_start2 + i][c2] != 0:
                    overlap = True
                    break
            if not overlap:
                for i in range(L_max2):
                    input_grid[r_start2 + i][c2] = color2
                break
    colors_present = set()
    for r in range(H):
        for c in range(W):
            if input_grid[r][c] != 0:
                colors_present.add(input_grid[r][c])
    components = {}
    for color in colors_present:
        visited = [[False] * W for _ in range(H)]
        component = []
        queue = []
        for r in range(H):
            for c in range(W):
                if input_grid[r][c] == color and not visited[r][c]:
                    queue.append((r, c))
                    visited[r][c] = True
                    component.append((r, c))
                    while queue:
                        cr, cc = queue.pop(0)
                        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc] and input_grid[nr][nc] == color:
                                visited[nr][nc] = True
                                queue.append((nr, nc))
                                component.append((nr, nc))
                    components[color] = component
                    break
    shortest_color = None
    shortest_size = float('inf')
    for color, comp in components.items():
        if len(comp) < shortest_size:
            shortest_size = len(comp)
            shortest_color = color
    cells = components[shortest_color]
    cells_sorted = sorted(cells, key=lambda x: (x[0], x[1]))
    num_to_keep = shortest_size // 2
    kept_cells = cells_sorted[:num_to_keep]
    output_grid = grid(W, H, 0)
    for r, c in kept_cells:
        output_grid[r][c] = shortest_color
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    W = len(input_grid[0])
    H = len(input_grid)
    colors_present = set()
    for r in range(H):
        for c in range(W):
            if input_grid[r][c] != 0:
                colors_present.add(input_grid[r][c])
    components = {}
    for color in colors_present:
        visited = [[False] * W for _ in range(H)]
        component = []
        queue = []
        for r in range(H):
            for c in range(W):
                if input_grid[r][c] == color and not visited[r][c]:
                    queue.append((r, c))
                    visited[r][c] = True
                    component.append((r, c))
                    while queue:
                        cr, cc = queue.pop(0)
                        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc] and input_grid[nr][nc] == color:
                                visited[nr][nc] = True
                                queue.append((nr, nc))
                                component.append((nr, nc))
                    components[color] = component
                    break
    shortest_color = None
    shortest_size = float('inf')
    for color, comp in components.items():
        if len(comp) < shortest_size:
            shortest_size = len(comp)
            shortest_color = color
    cells = components[shortest_color]
    cells_sorted = sorted(cells, key=lambda x: (x[0], x[1]))
    num_to_keep = shortest_size // 2
    kept_cells = cells_sorted[:num_to_keep]
    output_grid = grid(W, H, 0)
    for r, c in kept_cells:
        output_grid[r][c] = shortest_color
    return output_grid
