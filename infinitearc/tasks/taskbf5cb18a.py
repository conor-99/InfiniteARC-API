# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: bf5cb18a
Difficulty: medium–hard

=== Tags ===
- Reflect by color

=== Description ===
Input grids are 15×15 to 30×30 grids with a single background color (0).
Scattered throughout are colored cells (1-9), including one designated source
cell (typically color 5) positioned in the upper-left quadrant, and multiple
reflective cells (colors 1-9) arranged to form a path requiring multiple
reflections. The source cell is not part of the background and serves as the
beam's origin. The beam originates at the source cell and travels rightward
across the grid.  In the output grid, the beam's path is drawn by filling all
background cells (0) traversed by the beam with the source color (5). The beam
travels in a straight line until it encounters a reflective cell. Upon impact,
the beam reflects according to the cell's color: color 1 reflects 90° clockwise
(e.g., right → down), color 2 reflects 90° counterclockwise (e.g., right → up),
color 3 reflects 180° (e.g., right → left), and colors 4-9 continue straight
without reflection. The beam's direction updates immediately after reflection
and continues until exiting the grid. The path never overlaps with reflective
cells or the source cell, and all reflective cells remain unchanged in the
output. The task requires identifying reflection rules based on color, tracking
directional changes through multiple reflections, and simulating the beam's
trajectory across the grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    # Try a few times to construct a valid grid that contains multiple reflections
    for attempt in range(300):
        w = random.randint(15, 30)
        h = random.randint(15, 30)
        grid = [[0 for _ in range(w)] for _ in range(h)]

        # Place the source (color 5) somewhere in the upper-left quadrant
        src_r = random.randint(0, (h - 1) // 2)
        src_c = random.randint(0, (w - 1) // 2)
        # Make sure the source is not on the far right (so the beam can start moving)
        src_c = min(src_c, w - 2)
        grid[src_r][src_c] = 5

        # Beam state
        cur_r, cur_c = src_r, src_c
        dr, dc = 0, 1  # starts moving right

        reflectors = set()
        path_cells = []

        # Try to place multiple reflectors (colors 1-9, avoid using 5 for reflectors)
        target_reflections = random.randint(2, min(7, (w + h) // 4))
        ok = True
        for _ in range(target_reflections):
            # compute maximum distance (in cells) from current position to the edge in current direction
            if dr == 0 and dc == 1:
                dmax = w - 1 - cur_c
            elif dr == 0 and dc == -1:
                dmax = cur_c
            elif dr == 1 and dc == 0:
                dmax = h - 1 - cur_r
            elif dr == -1 and dc == 0:
                dmax = cur_r
            else:
                dmax = 0

            # We want at least one background cell between current position and the reflector
            # and then the reflector itself, so reflector distance must be >=2
            if dmax < 2:
                ok = False
                break

            # Collect candidate reflector distances that don't collide with existing objects
            candidates = []
            for d in range(2, dmax + 1):
                rr = cur_r + dr * d
                cc = cur_c + dc * d
                if (rr, cc) == (src_r, src_c):
                    continue
                if (rr, cc) in reflectors:
                    continue
                # ensure the path cells (1..d-1) are free (not the source or a reflector)
                bad = False
                for step in range(1, d):
                    pr = cur_r + dr * step
                    pc = cur_c + dc * step
                    if not (0 <= pr < h and 0 <= pc < w):
                        bad = True
                        break
                    if (pr, pc) == (src_r, src_c) or (pr, pc) in reflectors:
                        bad = True
                        break
                if bad:
                    continue
                candidates.append(d)

            if not candidates:
                ok = False
                break

            d = random.choice(candidates)
            reflect_r = cur_r + dr * d
            reflect_c = cur_c + dc * d

            # Choose a reflector color in 1..9 but avoid 5 (source color) for clarity
            color = random.choice([c for c in range(1, 10) if c != 5])
            grid[reflect_r][reflect_c] = color
            reflectors.add((reflect_r, reflect_c))

            # record the background path cells leading up to the reflector
            for step in range(1, d):
                pr = cur_r + dr * step
                pc = cur_c + dc * step
                path_cells.append((pr, pc))

            # move the beam to the reflector and update direction immediately
            cur_r, cur_c = reflect_r, reflect_c
            if color == 1:
                dr, dc = dc, -dr
            elif color == 2:
                dr, dc = -dc, dr
            elif color == 3:
                dr, dc = -dr, -dc
            else:
                # colors 4-9: no change in direction
                pass

        if not ok:
            continue

        # After the last reflector, travel simulating interactions with any reflectors until the beam exits the grid
        visited = set()
        loop_detected = False
        while True:
            state = (cur_r, cur_c, dr, dc)
            if state in visited:
                loop_detected = True
                break
            visited.add(state)

            nr = cur_r + dr
            nc = cur_c + dc
            if not (0 <= nr < h and 0 <= nc < w):
                break
            if grid[nr][nc] == 0:
                path_cells.append((nr, nc))
                cur_r, cur_c = nr, nc
                continue
            else:
                # hit an existing reflector in the grid: update direction and continue (do not paint the reflector)
                color = grid[nr][nc]
                if color == 1:
                    dr, dc = dc, -dr
                elif color == 2:
                    dr, dc = -dc, dr
                elif color == 3:
                    dr, dc = -dr, -dc
                else:
                    # 4-9: continue straight
                    pass
                # move beam onto the reflector cell (but we don't add the reflector to path_cells)
                cur_r, cur_c = nr, nc
                continue

        if loop_detected:
            # avoid layouts that create endless cycles
            continue

        # Ensure we actually created a multi-reflection path and that input != output
        if len(reflectors) < 2:
            continue
        if not path_cells:
            continue

        # Make sure path cells do not include any reflectors or the source
        conflict = False
        for pr, pc in path_cells:
            if (pr, pc) in reflectors or (pr, pc) == (src_r, src_c):
                conflict = True
                break
        if conflict:
            continue

        # Build the output grid by painting path cells with the source color (5)
        output = [row[:] for row in grid]
        for pr, pc in path_cells:
            if output[pr][pc] == 0:
                output[pr][pc] = 5

        # final sanity check: input must not equal output
        if output == grid:
            continue

        return {"input": grid, "output": output}

    # If we fail to make a valid multi-reflection layout after many attempts, fall back to a simple valid instance
    w = 15
    h = 15
    grid = [[0 for _ in range(w)] for _ in range(h)]
    grid[1][1] = 5
    grid[1][4] = 1
    grid[4][4] = 2
    grid[4][1] = 4
    output = [row[:] for row in grid]
    # path: (1,2),(1,3),(1,4) hits reflector at (1,4) etc. Paint path cells (but not reflectors)
    for (r, c) in [(1,2),(1,3),(2,3),(3,3),(3,2)]:
        output[r][c] = 5
    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert immutable input (tuple of tuples) into mutable lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0]) if h > 0 else 0

    # Find the source cell. Prefer color 5; otherwise pick a color that occurs exactly once.
    source_color = None
    counts = {}
    for r in range(h):
        for c in range(w):
            val = grid[r][c]
            if val > 0:
                counts[val] = counts.get(val, 0) + 1
    # Prefer 5 explicitly if present
    if 5 in counts:
        source_color = 5
    else:
        # Prefer a uniquely occurring non-zero color
        for color, cnt in counts.items():
            if cnt == 1 and color != 0:
                source_color = color
                break
        if source_color is None:
            # fallback to the first non-zero found
            found = False
            for r in range(h):
                for c in range(w):
                    if grid[r][c] > 0:
                        source_color = grid[r][c]
                        found = True
                        break
                if found:
                    break

    if source_color is None:
        # No colored source; return the grid unchanged
        return [row[:] for row in grid]

    # locate source position (top-leftmost occurrence of the chosen source color)
    src = None
    for r in range(h):
        for c in range(w):
            if grid[r][c] == source_color:
                src = (r, c)
                break
        if src is not None:
            break
    if src is None:
        return [row[:] for row in grid]

    r, c = src
    dr, dc = 0, 1  # beam starts moving right
    path = []

    # Simulate the beam until it leaves the grid or a loop is detected
    visited = set()
    while True:
        state = (r, c, dr, dc)
        if state in visited:
            break
        visited.add(state)

        r += dr
        c += dc
        if r < 0 or r >= h or c < 0 or c >= w:
            break
        val = grid[r][c]
        if val == 0:
            path.append((r, c))
        else:
            # Reflect according to color: 1 clockwise, 2 counterclockwise, 3 reverse, 4-9 straight
            if val == 1:
                dr, dc = dc, -dr
            elif val == 2:
                dr, dc = -dc, dr
            elif val == 3:
                dr, dc = -dr, -dc
            else:
                # colors 4-9: continue straight (no change)
                pass

    # Build the output by painting traversed background cells with the source color
    output = [row[:] for row in grid]
    for (pr, pc) in path:
        if 0 <= pr < h and 0 <= pc < w and output[pr][pc] == 0:
            output[pr][pc] = source_color
    return output

