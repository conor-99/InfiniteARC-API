# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: b0b232a1
Difficulty: hard

=== Tags ===
- Multi stage rule chain
- Rule transfer between regions
- Elastic wave
- Bouncing

=== Description ===
**Task Name:** Elastic Wave Propagation    **Description:**    Input grids are
large (15×15 to 30×30) with a single background color (0). Over this background,
multiple disjoint regions exist, each a contiguous block of a unique non-
background color (1–9). Each region has an entry point on its top-left boundary
(a background cell adjacent to the region). The regions are arranged in a path
from the grid’s top-left to bottom-right, separated by at least one background
cell.    The wave starts at the entry point of the top-left region, moving
right. Upon colliding with a region (i.e., entering a cell of that region’s
color), it bounces according to the region’s color:   - **Color 1**: 90°
clockwise bounce (right → down, down → left, left → up, up → right)   - **Color
2**: 90° counterclockwise bounce (right → up, up → left, left → down, down →
right)   - **Color 3**: Reverse direction (right → left, down → up, etc.)   -
**Color 4**: Continue straight (no bounce)   - **Colors 5–9**: Additional
directional rules (e.g., color 5: alternate between two perpendicular directions
per bounce)    The wave continues bouncing until it exits the grid (reaches an
edge). The output grid is identical to the input, except the wave’s path (all
background cells traversed) is drawn in **cyan (color 9)**. The transformation
requires:   1. Tracing the wave path using the bounce rules from each region.
2. Drawing the path in cyan without overwriting regions or the starting entry
point.   3. Handling multi-stage rule chains (e.g., a bounce off color 1
followed by color 5).    This task is hard due to the interplay of rule transfer
between regions (bouncing direction depends on the current region’s color),
elastic wave propagation (path shape changes dynamically), and the need to track
direction shifts through multiple bounces. The wave’s path must be reconstructed
from the input’s region colors, with no explicit visual cues for the bounce
rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    # Grid size
    width = random.randint(15, 30)
    height = random.randint(15, 30)
    # Background grid
    grid = [[0 for _ in range(width)] for _ in range(height)]

    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # 0=right,1=down,2=left,3=up

    def bounce_rule(color, direction, region_top):
        r0, c0 = region_top
        if color == 1:
            return (direction + 1) % 4
        elif color == 2:
            return (direction - 1) % 4
        elif color == 3:
            return (direction + 2) % 4
        elif color == 4:
            return direction
        elif color == 5:
            # alternate effect determined by region top-left parity (stateless but region-dependent)
            return (direction + 1) % 4 if ((r0 + c0) % 2) == 0 else (direction - 1) % 4
        elif color == 6:
            # if incoming is horizontal => go up, else go right
            return 3 if (direction % 2) == 0 else 0
        elif color == 7:
            # orthogonal mirror mapping
            return {0: 3, 1: 2, 2: 1, 3: 0}[direction]
        elif color == 8:
            # reflect horizontally (right<->left), verticals unchanged
            return {0: 2, 2: 0, 1: 1, 3: 3}[direction]
        else:
            # fallback (shouldn't be used since we avoid color 9 for regions)
            return (direction + 1) % 4

    # We will try to place a chain of rectangular regions monotically increasing towards bottom-right
    max_place_attempts = 200
    for attempt in range(max_place_attempts):
        n_regions = random.randint(3, 6)
        sizes = [(random.randint(2, 4), random.randint(2, 4)) for _ in range(n_regions)]  # (height, width)
        gaps_r = [random.randint(1, 3) for _ in range(n_regions - 1)]
        gaps_c = [random.randint(1, 3) for _ in range(n_regions - 1)]

        total_h = sum(h for h, w in sizes) + sum(gaps_r)
        total_w = sum(w for h, w in sizes) + sum(gaps_c)

        # Need some margin so the first region has a left entry cell
        if total_h + 2 >= height or total_w + 2 >= width:
            continue

        start_r = random.randint(1, height - total_h - 1)
        start_c = random.randint(1, width - total_w - 1)

        positions = [(start_r, start_c)]
        ok = True
        for i in range(1, n_regions):
            pr, pc = positions[i - 1]
            ph, pw = sizes[i - 1]
            nr = pr + ph + gaps_r[i - 1]
            nc = pc + pw + gaps_c[i - 1]
            h_i, w_i = sizes[i]
            if nr + h_i > height or nc + w_i > width:
                ok = False
                break
            positions.append((nr, nc))
        if ok:
            break
    else:
        # fallback small fixed layout (should rarely be used)
        n_regions = 3
        sizes = [(2, 2), (2, 2), (2, 2)]
        positions = [(1, 1), (4, 4), (7, 7)]

    # choose unique colors from 1..8 (reserve 9 for the path)
    colors = random.sample(list(range(1, 9)), len(positions))
    # ensure the first region is not color 4 (which would make the wave continue straight into the region and get stuck)
    if colors[0] == 4:
        # swap with a later color if possible
        for i in range(1, len(colors)):
            if colors[i] != 4:
                colors[0], colors[i] = colors[i], colors[0]
                break

    regions = []
    for (r0, c0), (h, w), col in zip(positions, sizes, colors):
        regions.append({'r': r0, 'c': c0, 'h': h, 'w': w, 'color': col})
        for rr in range(r0, r0 + h):
            for cc in range(c0, c0 + w):
                grid[rr][cc] = col

    # mapping from color to the region top-left (used by bounce rules)
    color_to_top = {reg['color']: (reg['r'], reg['c']) for reg in regions}

    # Starting entry is the background cell immediately left of the first region's top-left
    start_region = regions[0]
    start_r = start_region['r']
    start_c = start_region['c'] - 1
    if start_c < 0:
        start_c = 0

    # Simulate the elastic wave
    sr, sc = start_r, start_c
    r, c = sr, sc
    direction = 0  # start moving right

    path = []
    visited_states = set()
    steps = 0
    max_steps = width * height * 4

    while True:
        state = (r, c, direction)
        if state in visited_states:
            break
        visited_states.add(state)

        dr, dc = dirs[direction]
        nr, nc = r + dr, c + dc

        # If leaving grid, finish
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break

        # If next cell is a region, apply bounce rules (allow chain of bounces)
        bounce_iterations = 0
        while 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
            col = grid[nr][nc]
            top = color_to_top[col]
            new_dir = bounce_rule(col, direction, top)
            # If bounce doesn't change direction we consider it a block and stop (prevents immediate infinite loops)
            if new_dir == direction:
                break
            direction = new_dir
            dr, dc = dirs[direction]
            nr, nc = r + dr, c + dc
            bounce_iterations += 1
            if bounce_iterations > 50:
                break

        # If out of bounds after bounce, finish
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break

        # Move into the next background cell (if it is background)
        if grid[nr][nc] == 0:
            # don't mark the starting entry cell itself
            if not (nr == sr and nc == sc):
                path.append((nr, nc))
            r, c = nr, nc
            steps += 1
            if steps > max_steps:
                break
            continue

        # If still on a region cell (no movement possible), stop
        break

    # If the path ended up empty (rare), regenerate to ensure output differs from input
    if len(path) == 0:
        # Try a single quick retry by flipping first region's color away from 4 if necessary
        # (this keeps the generator fast but avoids trivial identical grids)
        for reg in regions:
            if reg['color'] == 4:
                # swap with some other color
                for i in range(len(colors)):
                    if colors[i] != 4:
                        reg['color'], colors[i] = colors[i], reg['color']
                        break
        # rebuild grid quickly
        grid = [[0 for _ in range(width)] for _ in range(height)]
        for reg in regions:
            for rr in range(reg['r'], reg['r'] + reg['h']):
                for cc in range(reg['c'], reg['c'] + reg['w']):
                    grid[rr][cc] = reg['color']
        # re-run a short simulation (guaranteed to terminate)
        r, c = sr, sc
        direction = 0
        path = []
        visited_states.clear()
        steps = 0
        while True:
            state = (r, c, direction)
            if state in visited_states:
                break
            visited_states.add(state)
            dr, dc = dirs[direction]
            nr, nc = r + dr, c + dc
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                break
            if grid[nr][nc] != 0:
                col = grid[nr][nc]
                top = color_to_top[col]
                new_dir = bounce_rule(col, direction, top)
                if new_dir == direction:
                    break
                direction = new_dir
                dr, dc = dirs[direction]
                nr, nc = r + dr, c + dc
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                break
            if grid[nr][nc] == 0:
                if not (nr == sr and nc == sc):
                    path.append((nr, nc))
                r, c = nr, nc
                steps += 1
                if steps > max_steps:
                    break
                continue
            break

    # Build output grid with the path drawn in cyan (9), without overwriting regions or the starting entry cell
    output = [row[:] for row in grid]
    for (rr, cc) in path:
        if output[rr][cc] == 0 and not (rr == sr and cc == sc):
            output[rr][cc] = 9

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # 0=right,1=down,2=left,3=up

    # Find top-left coordinate for each non-background color (region)
    top_left = {}
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if v == 0:
                continue
            if v not in top_left:
                top_left[v] = (r, c)
            else:
                pr, pc = top_left[v]
                # smaller row or tie-breaker smaller column
                if r < pr or (r == pr and c < pc):
                    top_left[v] = (r, c)

    if not top_left:
        return tuple(tuple(row) for row in grid)

    # Determine starting region: the one with the smallest top-left coordinate (top-leftmost)
    start_color = min(top_left.items(), key=lambda kv: (kv[1][0], kv[1][1]))[0]
    sr, sc = top_left[start_color][0], top_left[start_color][1] - 1
    if sc < 0:
        sc = 0

    def bounce_rule(color, direction, region_top):
        r0, c0 = region_top
        if color == 1:
            return (direction + 1) % 4
        elif color == 2:
            return (direction - 1) % 4
        elif color == 3:
            return (direction + 2) % 4
        elif color == 4:
            return direction
        elif color == 5:
            return (direction + 1) % 4 if ((r0 + c0) % 2) == 0 else (direction - 1) % 4
        elif color == 6:
            return 3 if (direction % 2) == 0 else 0
        elif color == 7:
            return {0: 3, 1: 2, 2: 1, 3: 0}[direction]
        elif color == 8:
            return {0: 2, 2: 0, 1: 1, 3: 3}[direction]
        else:
            return (direction + 1) % 4

    # Simulate wave exactly as in generator
    r, c = sr, sc
    direction = 0
    path = []
    visited_states = set()
    max_steps = width * height * 4
    steps = 0

    while True:
        state = (r, c, direction)
        if state in visited_states:
            break
        visited_states.add(state)

        dr, dc = dirs[direction]
        nr, nc = r + dr, c + dc

        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break

        bounce_iterations = 0
        while 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
            col = grid[nr][nc]
            top = top_left.get(col, (nr, nc))
            new_dir = bounce_rule(col, direction, top)
            if new_dir == direction:
                break
            direction = new_dir
            dr, dc = dirs[direction]
            nr, nc = r + dr, c + dc
            bounce_iterations += 1
            if bounce_iterations > 50:
                break

        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break

        if grid[nr][nc] == 0:
            if not (nr == sr and nc == sc):
                path.append((nr, nc))
            r, c = nr, nc
            steps += 1
            if steps > max_steps:
                break
            continue

        break

    output = [row[:] for row in grid]
    for rr, cc in path:
        if output[rr][cc] == 0 and not (rr == sr and cc == sc):
            output[rr][cc] = 9
    return tuple(tuple(row) for row in output)

