# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 1a26dc8d
Difficulty: hard

=== Tags ===
- Field based motion
- Transformation stack
- Spacing
- Find shape in negative space

=== Description ===
**Task Name: Negative Space Motion Cascade**  **Description:**  Input grids
feature a 2D arrangement of colored elements (1–8) on a uniform background (0),
with the background forming a complex, closed negative space shape (e.g., a
spiral, nested polygons, or abstract geometric pattern) that is not immediately
obvious due to the foreground elements. This hidden shape is the central focus
of the transformation.  The transformation process consists of a sequence of
three field-based operations applied in order:  1. **Shape Identification**: The
negative space shape (background pattern) is analyzed to determine its primary
geometric orientation (e.g., spiral, triangle, or square). This orientation
dictates the direction of the next motion field. The shape must be identified by
tracing the boundary of the background region (0s) and recognizing its visual
structure.  2. **Motion Field Application**: A directional field is generated
based on the shape's orientation. Foreground elements move one cell at a time in
the direction of the field (e.g., inward for spirals, toward vertices for
triangles), traversing only background cells (0s). This motion stops when
elements reach a foreground cell or grid boundary. Motion paths are not visible
in the output; only the final positions of elements are retained.  3. **Spacing
Adjustment**: The spacing between adjacent foreground elements is modified to
match the geometric spacing of the negative space shape (e.g., elements align to
the 3×3 grid spacing of a square shape). This adjustment is applied iteratively
until all elements adhere to the spacing pattern defined by the negative space
shape's structure.  The output grid reflects the final positions of foreground
elements after all three steps, with the negative space shape now visually
echoed by the arrangement of elements. The background remains unchanged except
for the paths traversed during motion (which are not visible in the output). The
transformation requires recognizing the hidden shape, applying multi-step motion
based on its geometry, and adjusting spacing to match its structural
properties—all through visual reasoning without numerical analysis.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    
    # Create grid with all foreground colors first
    input_grid = grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            input_grid[r][c] = random.randint(1, 8)
    
    # Create frame (background 0s)
    frame_size = random.randint(5, 8)
    center_x = width // 2
    center_y = height // 2
    r1 = max(0, center_y - frame_size // 2)
    r2 = min(height - 1, center_y + frame_size // 2)
    c1 = max(0, center_x - frame_size // 2)
    c2 = min(width - 1, center_x + frame_size // 2)
    
    # Create frame border
    for r in [r1, r2]:
        for c in range(c1, c2 + 1):
            input_grid[r][c] = 0
    for c in [c1, c2]:
        for r in range(r1 + 1, r2):
            input_grid[r][c] = 0
    
    # Create output by moving elements toward frame center
    output_grid = [row[:] for row in input_grid]
    center_x = (c1 + c2) // 2
    center_y = (r1 + r2) // 2
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                dr = 1 if r < center_y else -1
                dc = 1 if c < center_x else -1
                nr, nc = r, c
                while True:
                    new_r = nr + dr
                    new_c = nc + dc
                    if not (0 <= new_r < height and 0 <= new_c < width):
                        break
                    if input_grid[new_r][new_c] == 0:
                        nr, nc = new_r, new_c
                    else:
                        break
                output_grid[nr][nc] = input_grid[r][c]
                output_grid[r][c] = 0
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    
    # Find frame bounding box
    min_r, max_r = height, -1
    min_c, max_c = width, -1
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                min_r = min(min_r, r)
                max_r = max(max_r, r)
                min_c = min(min_c, c)
                max_c = max(max_c, c)
    
    # Calculate frame center
    center_x = (min_c + max_c) // 2
    center_y = (min_r + max_r) // 2
    
    output_grid = [row[:] for row in input_grid]
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                dr = 1 if r < center_y else -1
                dc = 1 if c < center_x else -1
                nr, nc = r, c
                while True:
                    new_r = nr + dr
                    new_c = nc + dc
                    if not (0 <= new_r < height and 0 <= new_c < width):
                        break
                    if input_grid[new_r][new_c] == 0:
                        nr, nc = new_r, new_c
                    else:
                        break
                output_grid[nr][nc] = input_grid[r][c]
                output_grid[r][c] = 0
    
    return output_grid
