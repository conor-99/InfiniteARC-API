# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 97f67760
Difficulty: insane

=== Tags ===
- Simulate billiards shot
- Cyclic coloring
- Path scarring
- Reflect by color
- Column parity coloring

=== Description ===
Input grids consist of a background (color 0), walls (horizontal or vertical
lines of a single non-zero color), and a single ball (a cell of a distinct
color) positioned at the start of a path. The ball moves east in a straight line
until it encounters a wall, at which point it reflects based on the wall's
orientation (horizontal walls reverse vertical direction, vertical walls reverse
horizontal direction). The path the ball traverses leaves a "scarring" trail on
the background, where each segment between reflections is colored. The initial
scarring color is determined by the parity of the ball's starting column (even
columns start with color 0, odd columns with color 1). After each reflection,
the scarring color cycles through a sequence starting from the wall's color
(e.g., a wall of color 5 begins the next segment with color 5, then 6, 7, etc.,
modulo 10). The scarring is drawn only on background cells, never over walls or
the original ball position. Walls remain unchanged, and the ball's path
continues until it exits the grid. The output grid displays the original walls,
the scarring path with colors following the described rules, and no other
elements.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid


def _simulate_trail(ingrid, ball_r, ball_c):
    """Simulate the billiard-style movement on ingrid starting from (ball_r, ball_c).
    Returns the output grid (with scars and walls) if the ball exits the grid, otherwise None.

    Rules implemented:
    - Ball starts moving east (dr,dc)=(0,1).
    - If the next cell is a wall (non-zero in the original ingrid), the ball reflects:
        - If the wall cell has same-color neighbor left/right -> horizontal wall -> reverse vertical component (dr = -dr)
        - If the wall cell has same-color neighbor up/down -> vertical wall -> reverse horizontal component (dc = -dc)
        - Both can be true at intersections -> both components reversed.
      After reflection, the ball does not step into the wall; it changes direction and will attempt the next step.
    - Scarring is only drawn on background cells (where original ingrid is 0) and never on the original ball cell.
    - The initial scarring color is 0 if the ball's starting column is even, else 1. After each step along a segment the color increments modulo 10.
    - Immediately after a reflection, the next segment's color sequence starts from the wall's color (the wall cell's value).
    - Walls remain unchanged; the output removes the original ball cell (sets it to 0) and contains the scars.
    """

    height = len(ingrid)
    width = len(ingrid[0])
    # start output as a copy of input and remove the original ball
    out = [row[:] for row in ingrid]
    out[ball_r][ball_c] = 0

    dr, dc = 0, 1  # start moving east
    r, c = ball_r, ball_c

    current_color = 0 if (ball_c % 2 == 0) else 1

    seen = set()
    steps = 0
    max_steps = 10000

    while steps < max_steps:
        state = (r, c, dr, dc, current_color)
        if state in seen:
            return None
        seen.add(state)

        nr, nc = r + dr, c + dc
        # if it leaves the grid we're done
        if not (0 <= nr < height and 0 <= nc < width):
            return out

        cell = ingrid[nr][nc]
        if cell != 0:
            # wall encountered -> determine orientation by checking same-colored neighbors
            wcol = cell
            is_h = False
            is_v = False
            if nc - 1 >= 0 and ingrid[nr][nc - 1] == wcol:
                is_h = True
            if nc + 1 < width and ingrid[nr][nc + 1] == wcol:
                is_h = True
            if nr - 1 >= 0 and ingrid[nr - 1][nc] == wcol:
                is_v = True
            if nr + 1 < height and ingrid[nr + 1][nc] == wcol:
                is_v = True

            # reflect components
            if is_v:
                dc = -dc
            if is_h:
                dr = -dr

            # next segment uses sequence starting from wall's color
            current_color = wcol

            steps += 1
            continue

        # background cell -> scar it (but never over the original ball position)
        if not (nr == ball_r and nc == ball_c):
            out[nr][nc] = current_color

        # cycle color for the next cell in this segment
        current_color = (current_color + 1) % 10

        r, c = nr, nc
        steps += 1

    return None


def generate():
    # Try multiple times to create a configuration where the ball eventually exits the grid
    for attempt in range(400):
        width = random.randint(8, 20)
        height = random.randint(8, 20)
        ingrid = grid(width, height, 0)

        # Place the ball ensuring at least one column to the east
        ball_r = random.randint(0, height - 1)
        ball_c = random.randint(0, width - 2)
        ball_color = random.randint(1, 9)
        ingrid[ball_r][ball_c] = ball_color

        # Place one guaranteed vertical wall somewhere to the east of the ball so the ball will reflect at least once
        wall_col = random.randint(ball_c + 1, width - 1)
        wall_color = random.choice([c for c in range(1, 10) if c != ball_color])

        # Choose a length >= 2 and a start row so the vertical wall includes the ball's row
        length = random.randint(2, min(6, height))
        start_min = max(0, ball_r - length + 1)
        start_max = min(ball_r, height - length)
        if start_min > start_max:
            start_row = max(0, min(ball_r, height - length))
        else:
            start_row = random.randint(start_min, start_max)

        for r in range(start_row, start_row + length):
            ingrid[r][wall_col] = wall_color

        # Add a small number of additional random walls (horizontal or vertical), avoid overlapping existing walls or the ball
        extra_walls = random.randint(0, 3)
        tries = 0
        while extra_walls > 0 and tries < 80:
            tries += 1
            orient = random.choice(["H", "V"])
            wcol = random.choice([c for c in range(1, 10) if c != ball_color])
            if orient == "H":
                wlen = random.randint(2, min(6, width))
                row = random.randint(0, height - 1)
                startc = random.randint(0, width - wlen)
                overlap = False
                for cc in range(startc, startc + wlen):
                    if ingrid[row][cc] != 0:
                        overlap = True
                        break
                    if row == ball_r and cc == ball_c:
                        overlap = True
                        break
                if overlap:
                    continue
                for cc in range(startc, startc + wlen):
                    ingrid[row][cc] = wcol
                extra_walls -= 1
            else:
                wlen = random.randint(2, min(6, height))
                col = random.randint(0, width - 1)
                startr = random.randint(0, height - wlen)
                overlap = False
                for rr in range(startr, startr + wlen):
                    if ingrid[rr][col] != 0:
                        overlap = True
                        break
                    if rr == ball_r and col == ball_c:
                        overlap = True
                        break
                if overlap:
                    continue
                for rr in range(startr, startr + wlen):
                    ingrid[rr][col] = wcol
                extra_walls -= 1

        # Simulate the ball path; require it to exit the grid and produce an output different from the input
        out = _simulate_trail(ingrid, ball_r, ball_c)
        if out is not None and out != ingrid:
            return {"input": ingrid, "output": out}

    # If generation repeatedly fails (very unlikely), construct a simple guaranteed case deterministically
    # Build a narrow corridor with a vertical wall to the east that causes at least one reflection
    width = 12
    height = 10
    ingrid = grid(width, height, 0)
    ball_r, ball_c = height // 2, 2
    ball_color = 9
    ingrid[ball_r][ball_c] = ball_color
    wall_col = 6
    wall_color = 5
    for r in range(ball_r - 1, ball_r + 2):
        ingrid[r][wall_col] = wall_color
    out = _simulate_trail(ingrid, ball_r, ball_c)
    if out is None:
        # As an absolute fallback, remove the ball and return the input as output (should not happen in normal cases)
        out = [row[:] for row in ingrid]
        out[ball_r][ball_c] = 0
    return {"input": ingrid, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])

    # Find the ball color: it's the non-zero color that appears exactly once (generator ensures this)
    counts = {}
    for r in range(height):
        for c in range(width):
            v = grid_in[r][c]
            if v == 0:
                continue
            counts[v] = counts.get(v, 0) + 1

    ball_color = None
    for color, cnt in counts.items():
        if cnt == 1:
            ball_color = color
            break

    # Fallback: if none found, pick a non-zero cell that is not part of a same-color run
    if ball_color is None:
        found = False
        for r in range(height):
            for c in range(width):
                v = grid_in[r][c]
                if v == 0:
                    continue
                left_same = (c - 1 >= 0 and grid_in[r][c - 1] == v)
                right_same = (c + 1 < width and grid_in[r][c + 1] == v)
                up_same = (r - 1 >= 0 and grid_in[r - 1][c] == v)
                down_same = (r + 1 < height and grid_in[r + 1][c] == v)
                if not (left_same or right_same or up_same or down_same):
                    ball_color = v
                    found = True
                    break
            if found:
                break

    # Locate the ball position
    ball_r = ball_c = -1
    for r in range(height):
        for c in range(width):
            if grid_in[r][c] == ball_color:
                ball_r, ball_c = r, c
                break
        if ball_r != -1:
            break

    # Prepare output: copy walls from input, remove the ball
    out = [row[:] for row in grid_in]
    if 0 <= ball_r < height and 0 <= ball_c < width:
        out[ball_r][ball_c] = 0

    # Simulate the ball path using the same rules as the generator
    dr, dc = 0, 1  # initial direction east
    r, c = ball_r, ball_c
    current_color = 0 if (ball_c % 2 == 0) else 1

    seen = set()
    steps = 0
    max_steps = 10000

    while steps < max_steps:
        state = (r, c, dr, dc, current_color)
        if state in seen:
            break
        seen.add(state)

        nr, nc = r + dr, c + dc
        if not (0 <= nr < height and 0 <= nc < width):
            break

        cell = grid_in[nr][nc]
        if cell != 0:
            # wall encountered -> determine orientation
            wcol = cell
            is_h = False
            is_v = False
            if nc - 1 >= 0 and grid_in[nr][nc - 1] == wcol:
                is_h = True
            if nc + 1 < width and grid_in[nr][nc + 1] == wcol:
                is_h = True
            if nr - 1 >= 0 and grid_in[nr - 1][nc] == wcol:
                is_v = True
            if nr + 1 < height and grid_in[nr + 1][nc] == wcol:
                is_v = True

            if is_v:
                dc = -dc
            if is_h:
                dr = -dr

            # next segment starts with wall color
            current_color = wcol
            steps += 1
            continue

        # background cell -> scar it unless it's the original ball position
        if not (nr == ball_r and nc == ball_c):
            out[nr][nc] = current_color

        current_color = (current_color + 1) % 10
        r, c = nr, nc
        steps += 1

    return out

