# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 242859d6
Difficulty: hard

=== Tags ===
- Pattern concatenation
- Column parity coloring

=== Description ===
**Task Name: Parity-Driven Pattern Concatenation**    **Description:**    Input
grids are rectangular (width ≥ 5, height ≥ 5) with a uniform background color
(0). Each column contains a vertical sequence of non-background colors (1–9)
forming a repeating pattern of length 2–4, separated by background cells. The
patterns are visually distinct and non-overlapping within each column.    The
transformation rule operates in two sequential phases:    1. **Pattern Direction
Adjustment:** For each column at index `c` (0-based), if `c` is even, the
pattern is preserved in top-to-bottom order; if `c` is odd, the pattern is
reversed (bottom-to-top).   2. **Column Concatenation via Parity Ordering:**
Columns are reordered such that all even-indexed columns (0, 2, 4, ...) appear
first in their original left-to-right sequence, followed by all odd-indexed
columns (1, 3, 5, ...) in their original order. The output grid’s column
structure reflects this concatenation, with each column’s pattern transformed as
per Phase 1.    The output grid retains the same dimensions as the input.
Background cells remain unchanged, and non-background patterns are strictly
preserved in direction and position within their transformed columns. No
patterns overlap or overwrite each other.    **Key Complexity Elements:**   -
**Structural Parity:** Relies solely on column index parity (not pixel values),
requiring abstract recognition of grid geometry.   - **Multi-Step
Transformation:** Requires both directional reversal *and* global reordering of
columns, with no overlap between phases.   - **Pattern Integrity:** Patterns
must be identified independently per column before concatenation, avoiding
pixel-by-pixel matching.   - **Visual Consistency:** Patterns remain visually
distinct in the output, with direction reversal and reordering creating a new
spatial arrangement.    This task demands combinatorial reasoning about grid
structure, parity-based operations, and sequential pattern management—hallmarks
of a hard-level ARC task.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid_in = [[0] * width for _ in range(height)]
    
    for c in range(width):
        L = random.randint(2, 4)
        start_row = random.randint(0, height - L)
        colors = [random.randint(1, 9) for _ in range(L)]
        for r in range(start_row, start_row + L):
            grid_in[r][c] = colors[r - start_row]
    
    grid_out = [row[:] for row in grid_in]
    
    for c in range(width):
        if c % 2 == 1:
            start, end = None, None
            for r in range(height):
                if grid_in[r][c] != 0:
                    start = r
                    break
            for r in range(height-1, -1, -1):
                if grid_in[r][c] != 0:
                    end = r
                    break
            if start is not None and end is not None:
                segment = [grid_in[r][c] for r in range(start, end+1)]
                segment.reverse()
                for r in range(start, end+1):
                    grid_out[r][c] = segment[r - start]
    
    even_cols = [c for c in range(width) if c % 2 == 0]
    odd_cols = [c for c in range(width) if c % 2 == 1]
    new_cols = even_cols + odd_cols
    
    grid_out = [[grid_out[r][c] for c in new_cols] for r in range(height)]
    
    return {"input": grid_in, "output": grid_out}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])
    
    grid_out = [row[:] for row in grid_in]
    
    for c in range(width):
        if c % 2 == 1:
            start, end = None, None
            for r in range(height):
                if grid_in[r][c] != 0:
                    start = r
                    break
            for r in range(height-1, -1, -1):
                if grid_in[r][c] != 0:
                    end = r
                    break
            if start is not None and end is not None:
                segment = [grid_in[r][c] for r in range(start, end+1)]
                segment.reverse()
                for r in range(start, end+1):
                    grid_out[r][c] = segment[r - start]
    
    even_cols = [c for c in range(width) if c % 2 == 0]
    odd_cols = [c for c in range(width) if c % 2 == 1]
    new_cols = even_cols + odd_cols
    
    grid_out = [[grid_out[r][c] for c in new_cols] for r in range(height)]
    
    return tuple(tuple(row) for row in grid_out)
