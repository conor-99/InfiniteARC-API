# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 6ab0ecdb
Difficulty: hard

=== Tags ===
- Context sensitive recolor
- Rotating signal
- Shape attribute projection
- Signal to structure
- Detect enclosure

=== Description ===
# Enclosure Signal Mapping  Input grids feature a background (color 0) overlaid
with multiple disjoint, non-overlapping shapes (each a contiguous region of a
single non-zero color, 1–9). Each shape contains exactly one "signal" cell—a
small cell within the shape (not on its boundary) with a color distinct from the
shape's color, indicating a cardinal direction (N, S, E, W) through its relative
position to the shape's center. The grid may contain enclosed regions—maximal
connected components of background cells (0) completely surrounded by non-
background cells (shapes), forming bounded cavities within the overall
structure.  In the output grid: 1. **Enclosure detection**: All enclosed regions
are identified as connected background areas fully bounded by non-background
cells (including grid edges). 2. **Signal analysis**: For each enclosed region,
signals within it (positioned inside the region) are analyzed. If no signals
exist inside a region, it remains background (color 0). 3. **Context-sensitive
recolor**: For enclosed regions with signals, the dominant direction (most
frequent among signals inside) determines the recoloring:    - North → color 7
- South → color 8    - East → color 9    - West → color 6 4. **Rotating signal
effect**: Signals themselves remain unchanged in position and color. Their
direction dictates the recoloring of the enclosed region they occupy. 5. **Shape
attribute projection**: The main shape's color is irrelevant to the output; only
the signal's direction and enclosure context determine the recoloring. The
output preserves all shapes, signals, and non-enclosed background, altering only
enclosed regions per the dominant direction rule.  The task requires precise
enclosure detection, signal direction interpretation, and context-driven color
mapping, with no visual cues beyond color values. Hard difficulty arises from
the need to simultaneously track multiple enclosures, analyze signal directions
within them, and apply the color mapping rules without relying on numerical
operations or memorization.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid


def generate():
    # Grid size
    rows = random.randint(10, 20)
    cols = rows
    g = grid(cols, rows, 0)

    shapes = []  # list of placed rectangular frames
    occupied = set()  # cells already used by shape borders

    # Decide how many frames to attempt
    max_frames = random.randint(1, min(4, max(1, rows // 4)))

    attempts = 0
    # Place up to max_frames non-overlapping rectangular frames (borders only)
    while len(shapes) < max_frames and attempts < 300:
        attempts += 1
        # Frame outer dimensions (must leave at least one-cell margin to grid edges)
        h = random.randint(5, max(5, min(10, rows - 2)))
        w = random.randint(5, max(5, min(10, cols - 2)))
        if h >= rows - 2:
            h = rows - 2
        if w >= cols - 2:
            w = cols - 2
        r0 = random.randint(1, rows - h - 1)
        c0 = random.randint(1, cols - w - 1)

        # Compute border coordinates for this rectangle
        border_coords = set()
        for r in range(r0, r0 + h):
            for c in range(c0, c0 + w):
                if r == r0 or r == r0 + h - 1 or c == c0 or c == c0 + w - 1:
                    border_coords.add((r, c))

        # Reject if this border would overlap or touch an existing border (keep shapes disjoint)
        bad = False
        for (r, c) in border_coords:
            if (r, c) in occupied:
                bad = True
                break
            # also avoid touching previous borders (1-cell margin)
            for dr, dc in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) in occupied:
                    bad = True
                    break
            if bad:
                break
        if bad:
            continue

        # Choose a color for this shape (non-zero)
        color = random.randint(1, 9)

        # Draw the border
        for (r, c) in border_coords:
            g[r][c] = color
            occupied.add((r, c))

        shapes.append({
            'r0': r0,
            'c0': c0,
            'h': h,
            'w': w,
            'color': color,
            'border': border_coords
        })

    # Place isolated signal cells inside some interiors (they are single-cell non-zero components)
    signals = []  # (r,c,color)
    chosen_shapes = []
    for i in range(len(shapes)):
        if random.random() < 0.6:
            chosen_shapes.append(i)
    # Ensure at least one shape receives a signal
    if not chosen_shapes and shapes:
        chosen_shapes.append(random.randrange(len(shapes)))

    for idx in chosen_shapes:
        s = shapes[idx]
        interior_positions = []
        for r in range(s['r0'] + 1, s['r0'] + s['h'] - 1):
            for c in range(s['c0'] + 1, s['c0'] + s['w'] - 1):
                # ensure this cell and its 4-neighbors are currently zero -> isolated when set
                if g[r][c] != 0:
                    continue
                ok = True
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = r + dr, c + dc
                    if not (0 <= nr < rows and 0 <= nc < cols) or g[nr][nc] != 0:
                        ok = False
                        break
                if ok:
                    interior_positions.append((r, c))
        if not interior_positions:
            continue
        # Choose positions iteratively to avoid placing two signals adjacent (4-connected)
        max_signals = min(3, len(interior_positions))
        num_signals = random.randint(1, max_signals)
        available = set(interior_positions)
        chosen = []
        for _ in range(num_signals):
            if not available:
                break
            pos = random.choice(list(available))
            chosen.append(pos)
            # remove pos and any 4-neighbors from available to keep singletons
            r, c = pos
            to_remove = {(r, c)}
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                to_remove.add((r + dr, c + dc))
            available -= to_remove
        for (r, c) in chosen:
            sig_color = random.randint(1, 9)
            while sig_color == s['color']:
                sig_color = random.randint(1, 9)
            g[r][c] = sig_color
            signals.append((r, c, sig_color))

    # If no signals were placed (very unlikely), place one in a random shape interior
    if not signals and shapes:
        random.shuffle(shapes)
        placed = False
        for s in shapes:
            interior = []
            for r in range(s['r0'] + 1, s['r0'] + s['h'] - 1):
                for c in range(s['c0'] + 1, s['c0'] + s['w'] - 1):
                    if g[r][c] == 0:
                        # require isolation
                        ok = True
                        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                            nr, nc = r + dr, c + dc
                            if not (0 <= nr < rows and 0 <= nc < cols) or g[nr][nc] != 0:
                                ok = False
                                break
                        if ok:
                            interior.append((r, c))
            if interior:
                r, c = random.choice(interior)
                sig_color = random.randint(1, 9)
                while sig_color == s['color']:
                    sig_color = random.randint(1, 9)
                g[r][c] = sig_color
                signals.append((r, c, sig_color))
                placed = True
                break
        # if still not placed, fall back to overwriting the center cell if it's safe
        if not placed and shapes:
            s = shapes[0]
            r = s['r0'] + s['h'] // 2
            c = s['c0'] + s['w'] // 2
            if g[r][c] == 0:
                sig_color = random.randint(1, 9)
                while sig_color == s['color']:
                    sig_color = random.randint(1, 9)
                g[r][c] = sig_color
                signals.append((r, c, sig_color))

    # Build output by detecting enclosed zero regions (zeros not reachable from edges)
    from collections import deque, Counter

    rows = len(g)
    cols = len(g[0])
    outside = [[False] * cols for _ in range(rows)]
    dq = deque()
    # start BFS from border zeros
    for r in range(rows):
        for c in (0, cols - 1):
            if g[r][c] == 0 and not outside[r][c]:
                outside[r][c] = True
                dq.append((r, c))
    for c in range(cols):
        for r in (0, rows - 1):
            if g[r][c] == 0 and not outside[r][c]:
                outside[r][c] = True
                dq.append((r, c))
    while dq:
        cr, cc = dq.popleft()
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = cr + dr, cc + dc
            if 0 <= nr < rows and 0 <= nc < cols and not outside[nr][nc] and g[nr][nc] == 0:
                outside[nr][nc] = True
                dq.append((nr, nc))

    enclosed_cells = set()
    for r in range(rows):
        for c in range(cols):
            if g[r][c] == 0 and not outside[r][c]:
                enclosed_cells.add((r, c))

    # Group enclosed zeros into connected components
    enclosed_components = []
    seen = set()
    for cell in enclosed_cells:
        if cell in seen:
            continue
        comp = []
        dq = deque([cell])
        seen.add(cell)
        while dq:
            cr, cc = dq.popleft()
            comp.append((cr, cc))
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = cr + dr, cc + dc
                if (nr, nc) in enclosed_cells and (nr, nc) not in seen:
                    seen.add((nr, nc))
                    dq.append((nr, nc))
        enclosed_components.append(comp)

    # Find singleton non-zero components (likely signals)
    nonzero_seen = set()
    singletons = []
    for r in range(rows):
        for c in range(cols):
            if g[r][c] != 0 and (r, c) not in nonzero_seen:
                comp = []
                dq = deque([(r, c)])
                nonzero_seen.add((r, c))
                while dq:
                    cr, cc = dq.popleft()
                    comp.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < rows and 0 <= nc < cols and g[nr][nc] != 0 and (nr, nc) not in nonzero_seen:
                            nonzero_seen.add((nr, nc))
                            dq.append((nr, nc))
                if len(comp) == 1:
                    singletons.append(comp[0])

    output = [row[:] for row in g]
    color_map = {'N': 7, 'S': 8, 'E': 9, 'W': 6}

    # For each enclosed zero component, find signals (singleton non-zero cells) adjacent to it
    for comp in enclosed_components:
        comp_set = set(comp)
        region_signals = []
        for (sr, sc) in singletons:
            # if any 4-neighbor of the singleton is part of this zero component, treat it as a signal in the region
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                if (sr + dr, sc + dc) in comp_set:
                    region_signals.append((sr, sc))
                    break
        if not region_signals:
            continue
        # Compute a floating center for the zero component
        cr = sum(r for r, c in comp) / len(comp)
        cc = sum(c for r, c in comp) / len(comp)
        dirs = []
        for (sr, sc) in region_signals:
            dr = sr - cr
            dc = sc - cc
            if abs(dr) > abs(dc):
                dirs.append('N' if dr < 0 else 'S')
            else:
                dirs.append('W' if dc < 0 else 'E')
        # dominant direction
        dominant = Counter(dirs).most_common(1)[0][0]
        color = color_map[dominant]
        # recolor the enclosed zero component
        for (zr, zc) in comp:
            output[zr][zc] = color

    return {'input': g, 'output': output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque, Counter

def p(input_grid):
    grid = [list(row) for row in input_grid]
    rows, cols = len(grid), len(grid[0])
    # find zero cells reachable from outside
    visited = [[False]*cols for _ in range(rows)]
    dq = deque()
    for r in range(rows):
        for c in [0, cols-1]:
            if grid[r][c] == 0 and not visited[r][c]:
                visited[r][c] = True
                dq.append((r,c))
    for c in range(cols):
        for r in [0, rows-1]:
            if grid[r][c] == 0 and not visited[r][c]:
                visited[r][c] = True
                dq.append((r,c))
    while dq:
        r,c = dq.popleft()
        for dr,dc in [(1,0),(-1,0),(0,1),(0,-1)]:
            nr, nc = r+dr, c+dc
            if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and grid[nr][nc] == 0:
                visited[nr][nc] = True
                dq.append((nr,nc))
    enclosed = set()
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 0 and not visited[r][c]:
                enclosed.add((r,c))
    # group enclosed zeros into components
    enclosed_components = []
    seen = set()
    for cell in enclosed:
        if cell in seen: continue
        comp = []
        dq = deque([cell])
        seen.add(cell)
        while dq:
            cr, cc = dq.popleft()
            comp.append((cr,cc))
            for dr,dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                nr, nc = cr+dr, cc+dc
                if (nr,nc) in enclosed and (nr,nc) not in seen:
                    seen.add((nr,nc))
                    dq.append((nr,nc))
        enclosed_components.append(comp)
    # find singleton non-zero components -> signals
    nonzero_seen = set()
    singletons = []
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] != 0 and (r,c) not in nonzero_seen:
                comp = []
                dq = deque([(r,c)])
                nonzero_seen.add((r,c))
                while dq:
                    cr,cc = dq.popleft()
                    comp.append((cr,cc))
                    for dr,dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                        nr, nc = cr+dr, cc+dc
                        if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] != 0 and (nr,nc) not in nonzero_seen:
                            nonzero_seen.add((nr,nc))
                            dq.append((nr,nc))
                if len(comp) == 1:
                    singletons.append(comp[0])
    output = [row[:] for row in grid]
    color_map = {'N':7,'S':8,'E':9,'W':6}
    for comp in enclosed_components:
        comp_set = set(comp)
        region_signals = []
        for (sr,sc) in singletons:
            for dr,dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                if (sr+dr, sc+dc) in comp_set:
                    region_signals.append((sr,sc))
                    break
        if not region_signals:
            continue
        cr = sum(r for r,c in comp)/len(comp)
        cc = sum(c for r,c in comp)/len(comp)
        dirs = []
        for (sr,sc) in region_signals:
            dr = sr - cr
            dc = sc - cc
            if abs(dr) > abs(dc):
                dirs.append('N' if dr < 0 else 'S')
            else:
                dirs.append('W' if dc < 0 else 'E')
        dominant = Counter(dirs).most_common(1)[0][0]
        color = color_map[dominant]
        for (zr,zc) in comp:
            output[zr][zc] = color
    return tuple(tuple(row) for row in output)
