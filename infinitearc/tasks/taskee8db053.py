# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: ee8db053
Difficulty: hard

=== Tags ===
- Shape attribute projection
- Color modulated logic
- Reflect by color
- Analogical mapping between pairs

=== Description ===
Input grids contain multiple disconnected colored shapes (each shape is a
contiguous region of a single non-zero color, surrounded by background 0). Each
shape's color is a number from 1 to 9. The transformation requires reflecting
each shape across a specific axis determined by its color:  - Color 1: Vertical
reflection (across grid's vertical midline) - Color 2: Horizontal reflection
(across grid's horizontal midline) - Color 3: Main diagonal reflection (top-left
to bottom-right) - Color 4: Anti-diagonal reflection (top-right to bottom-left)
- Colors 5–9: Repeat the reflection axes of colors 1–4 in order (color 5 = color
1, color 6 = color 2, etc.)  Reflection axes are defined mathematically as: -
Vertical: (r, c) → (r, W-1-c) - Horizontal: (r, c) → (H-1-r, c) - Main diagonal:
(r, c) → (c, r) - Anti-diagonal: (r, c) → (H-1-c, W-1-r)  Each shape is replaced
with its reflected version while maintaining its original color. Background
remains unchanged. The output grid contains all reflected shapes without
overlaps (reflections are computed to avoid overlap in valid examples). This
task requires identifying color-based reflection rules, applying multi-step
spatial transformations, and handling diagonal reflections which require
coordinate swapping. The complexity arises from correctly mapping each color to
its axis, performing accurate coordinate transformations, and ensuring spatial
consistency across varying grid dimensions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from typing import List, Dict, Set, Tuple

def generate() -> Dict[str, List[List[int]]]:
    """
    Generates an input/output pair where each colored connected shape in the input
    is replaced in the output by its reflection determined by its color.

    Colors 1..9 map to axes as described in the task.
    The generator ensures diagonal reflections are only created for shapes placed
    inside a square region so that swapping coordinates stays inside bounds.
    """
    # Small helper: attempt generation multiple times in case of conflicts
    for global_try in range(200):
        H = random.randint(5, 30)
        W = random.randint(5, 30)
        # grids
        input_grid = [[0 for _ in range(W)] for __ in range(H)]
        output_grid = [[0 for _ in range(W)] for __ in range(H)]

        occupied_in: Set[Tuple[int, int]] = set()
        occupied_out: Set[Tuple[int, int]] = set()

        num_shapes = random.randint(2, 4)
        # use unique colors for clarity and to avoid accidental overlaps
        colors = random.sample(list(range(1, 10)), num_shapes)

        S = min(H, W)  # square limit for diagonal-safe placement

        def generate_connected_shape(size: int, bbox: Tuple[int,int,int,int], occupied: Set[Tuple[int,int]]) -> Set[Tuple[int,int]]:
            rmin, rmax, cmin, cmax = bbox
            # All candidate starting cells inside bbox not currently occupied
            candidates = [(r, c) for r in range(rmin, rmax + 1) for c in range(cmin, cmax + 1) if (r, c) not in occupied]
            if not candidates:
                return None
            # Try a few times to grow a connected shape
            for attempt in range(100):
                start = random.choice(candidates)
                shape = [start]
                tries = 0
                # Grow the shape by adding neighboring cells
                while len(shape) < size and tries < 1000:
                    base = random.choice(shape)
                    nbrs = [(base[0] + 1, base[1]), (base[0] - 1, base[1]), (base[0], base[1] + 1), (base[0], base[1] - 1)]
                    random.shuffle(nbrs)
                    added = False
                    for nr, nc in nbrs:
                        if nr < rmin or nr > rmax or nc < cmin or nc > cmax:
                            continue
                        if (nr, nc) in occupied or (nr, nc) in shape:
                            continue
                        shape.append((nr, nc))
                        added = True
                        break
                    if not added:
                        tries += 1
                        # Occasionally restart growth from a new seed inside bbox
                        if tries % 30 == 0:
                            remaining = [p for p in candidates if p not in shape]
                            if remaining:
                                shape = [random.choice(remaining)]
                if len(shape) == size:
                    return set(shape)
            return None

        failed = False
        for color in colors:
            axis = (color - 1) % 4 + 1
            placed = False
            # Try several times to place this shape without conflicts
            for attempt in range(200):
                # pick a reasonable shape size relative to grid
                max_size = min(12, max(3, (H * W) // 30))
                size = random.randint(3, max_size)
                if axis in (3, 4):
                    # restrict to a square region in top-left so swaps stay in-bound
                    bbox = (0, S - 1, 0, S - 1)
                    # If bbox smaller than shape size, fail quickly
                    if (S * S) < size:
                        continue
                else:
                    bbox = (0, H - 1, 0, W - 1)
                shape = generate_connected_shape(size, bbox, occupied_in)
                if not shape:
                    continue
                # compute reflection and validate it fits and does not collide with existing outputs
                reflected = set()
                ok = True
                for (r, c) in shape:
                    if axis == 1:  # vertical
                        nr, nc = r, W - 1 - c
                    elif axis == 2:  # horizontal
                        nr, nc = H - 1 - r, c
                    elif axis == 3:  # main diagonal
                        nr, nc = c, r
                    else:  # axis == 4 anti-diagonal
                        nr, nc = H - 1 - c, W - 1 - r
                    if not (0 <= nr < H and 0 <= nc < W):
                        ok = False
                        break
                    if (nr, nc) in occupied_out:
                        ok = False
                        break
                    reflected.add((nr, nc))
                if not ok:
                    continue
                # ensure the input shape itself doesn't collide with already placed input shapes
                if any(p in occupied_in for p in shape):
                    continue
                # place it
                for (r, c) in shape:
                    input_grid[r][c] = color
                    occupied_in.add((r, c))
                for (r, c) in reflected:
                    output_grid[r][c] = color
                    occupied_out.add((r, c))
                placed = True
                break
            if not placed:
                failed = True
                break
        if failed:
            continue
        # Make sure input and output are not identical (practically impossible but check)
        if input_grid == output_grid:
            continue
        return {"input": input_grid, "output": output_grid}
    # If we reach here, fallback: produce a trivial safe example
    H, W = 6, 6
    input_grid = [[0] * W for _ in range(H)]
    output_grid = [[0] * W for _ in range(H)]
    # simple two-shape fallback: one vertical, one horizontal
    input_grid[1][1] = 1
    input_grid[1][2] = 1
    input_grid[2][1] = 1
    output_grid[1][W-1-1] = 1
    output_grid[1][W-1-2] = 1
    output_grid[2][W-1-1] = 1
    input_grid[3][3] = 2
    input_grid[4][3] = 2
    input_grid[4][4] = 2
    output_grid[H-1-3][3] = 2
    output_grid[H-1-4][3] = 2
    output_grid[H-1-4][4] = 2
    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Normalize input to a list-of-lists
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0])
    output = [[0] * W for _ in range(H)]

    from collections import deque

    visited = [[False] * W for _ in range(H)]
    for r in range(H):
        for c in range(W):
            if grid[r][c] == 0 or visited[r][c]:
                continue
            color = grid[r][c]
            # BFS to collect the connected component of this color
            q = deque()
            q.append((r, c))
            visited[r][c] = True
            comp = []
            while q:
                cr, cc = q.popleft()
                comp.append((cr, cc))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc] and grid[nr][nc] == color:
                        visited[nr][nc] = True
                        q.append((nr, nc))

            axis = (color - 1) % 4 + 1
            for (cr, cc) in comp:
                if axis == 1:
                    nr, nc = cr, W - 1 - cc
                elif axis == 2:
                    nr, nc = H - 1 - cr, cc
                elif axis == 3:
                    nr, nc = cc, cr
                else:
                    nr, nc = H - 1 - cc, W - 1 - cr
                if 0 <= nr < H and 0 <= nc < W:
                    output[nr][nc] = color
    return output

