# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 2e455dc5
Difficulty: very hard

=== Tags ===
- Enclosure completion

=== Description ===
Input grids feature multiple disjoint, axis-aligned rectangular enclosures (each
a contiguous region of a single color) that are missing exactly one edge (top,
bottom, left, or right). The background color is uniform and distinct from all
enclosure colors. Each enclosure contains a single "key" cell of a unique color
that does not appear anywhere else in the grid. The key cell is positioned in
the interior of the enclosure and serves as the sole indicator for completing
the enclosure.  The output grid completes each enclosure by adding the missing
edge with the enclosure's color. The direction of completion (top, bottom, left,
or right) is determined by comparing the key cell's color to the colors of the
four grid corners. Specifically: - If the key cell's color matches the top-left
corner color, the enclosure's top edge is completed. - If it matches the top-
right corner color, the right edge is completed. - If it matches the bottom-left
corner color, the bottom edge is completed. - If it matches the bottom-right
corner color, the left edge is completed.  No enclosure shares a key cell color
with another enclosure, and the grid corners always contain colors distinct from
the background but may match enclosure colors. Enclosures are designed such that
no two enclosures have key cells matching the same corner color, ensuring
unambiguous completion. The background remains unchanged except for the newly
filled edges, and all filled edges maintain perfect alignment with the
enclosure's original boundaries.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Choose reasonable grid size to allow enclosures with interior
    width = random.randint(6, 20)
    height = random.randint(6, 20)
    # Choose background color B such that it's likely the most common
    B = random.randint(0, 9)
    # Choose 4 distinct corner colors different from background
    colors = [c for c in range(0, 10) if c != B]
    corner_colors = random.sample(colors, 4)
    C_tl, C_tr, C_bl, C_br = corner_colors
    # Initialize grid with background
    grid_input = grid(width, height, B)
    # Set corners
    grid_input[0][0] = C_tl
    grid_input[0][width-1] = C_tr
    grid_input[height-1][0] = C_bl
    grid_input[height-1][width-1] = C_br
    # Setup enclosures
    missing_edges_all = ['top', 'right', 'bottom', 'left']
    num_enclosures = random.randint(1, min(4, len(missing_edges_all)))
    # Choose unique missing edges to ensure unique corner-key mapping
    chosen_edges = random.sample(missing_edges_all, num_enclosures)
    enclosures = []
    used_border_colors = set([B] + corner_colors)
    # Attempt to place each enclosure without overlapping
    for missing_edge in chosen_edges:
        placed = False
        for attempt in range(200):
            # pick rectangle coordinates with at least 3x3 size and not touching outer border
            # r1 must be at most height-4 so that r1+2 <= height-2
            if height - 4 < 1 or width - 4 < 1:
                break
            r1 = random.randint(1, height - 4)
            r2 = random.randint(r1 + 2, height - 2)
            c1 = random.randint(1, width - 4)
            c2 = random.randint(c1 + 2, width - 2)
            # Check overlap with existing enclosures
            overlap = False
            for (or1, oc1, or2, oc2, _, _) in enclosures:
                if not (r2 < or1 or r1 > or2 or c2 < oc1 or c1 > oc2):
                    overlap = True
                    break
            if overlap:
                continue
            # Choose a border color E distinct from background, corner colors and other enclosure colors
            choices = [c for c in range(0, 10) if c not in used_border_colors]
            if not choices:
                continue
            E = random.choice(choices)
            used_border_colors.add(E)
            # Determine the key color from the missing edge -> corner mapping
            edge_to_corner = {'top': C_tl, 'right': C_tr, 'bottom': C_bl, 'left': C_br}
            key_color = edge_to_corner[missing_edge]
            # Draw the three sides (leave the missing side empty)
            if missing_edge == 'top':
                # left and right verticals, bottom horizontal
                for r in range(r1, r2 + 1):
                    grid_input[r][c1] = E
                    grid_input[r][c2] = E
                for c in range(c1, c2 + 1):
                    grid_input[r2][c] = E
            elif missing_edge == 'right':
                # left vertical and top & bottom horizontals
                for r in range(r1, r2 + 1):
                    grid_input[r][c1] = E
                for c in range(c1, c2 + 1):
                    grid_input[r1][c] = E
                    grid_input[r2][c] = E
            elif missing_edge == 'bottom':
                # left and right verticals and top horizontal
                for r in range(r1, r2 + 1):
                    grid_input[r][c1] = E
                    grid_input[r][c2] = E
                for c in range(c1, c2 + 1):
                    grid_input[r1][c] = E
            elif missing_edge == 'left':
                # right vertical and top & bottom horizontals
                for r in range(r1, r2 + 1):
                    grid_input[r][c2] = E
                for c in range(c1, c2 + 1):
                    grid_input[r1][c] = E
                    grid_input[r2][c] = E
            # Place the key cell inside the interior; ensure it is not on borders (interior)
            r_key = random.randint(r1 + 1, r2 - 1)
            c_key = random.randint(c1 + 1, c2 - 1)
            # To maintain the property that the key color is unique except at the corner,
            # ensure we don't accidentally place another cell of that corner color elsewhere.
            # Since corners already contain that color, we only ensure interior key is set here.
            grid_input[r_key][c_key] = key_color
            enclosures.append((r1, c1, r2, c2, missing_edge, E))
            placed = True
            break
        if not placed:
            # If we couldn't place this enclosure (rare), skip it
            continue
    # Build output by completing the missing edges
    grid_output = [row[:] for row in grid_input]
    for (r1, c1, r2, c2, missing_edge, E) in enclosures:
        if missing_edge == 'top':
            for c in range(c1, c2 + 1):
                grid_output[r1][c] = E
        elif missing_edge == 'right':
            for r in range(r1, r2 + 1):
                grid_output[r][c2] = E
        elif missing_edge == 'bottom':
            for c in range(c1, c2 + 1):
                grid_output[r2][c] = E
        elif missing_edge == 'left':
            for r in range(r1, r2 + 1):
                grid_output[r][c1] = E
    return {'input': grid_input, 'output': grid_output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import Counter

def p(input_grid):
    # Convert to mutable list of lists
    grid_input = [list(row) for row in input_grid]
    height = len(grid_input)
    width = len(grid_input[0]) if height > 0 else 0
    # Corner colors
    C_tl = grid_input[0][0]
    C_tr = grid_input[0][width - 1]
    C_bl = grid_input[height - 1][0]
    C_br = grid_input[height - 1][width - 1]
    corner_colors = {C_tl, C_tr, C_bl, C_br}
    # Determine background color as the most common color
    all_colors = [c for row in grid_input for c in row]
    B = Counter(all_colors).most_common(1)[0][0]
    # Candidate enclosure colors are colors that are not background and not corner colors
    enclosure_colors = set(all_colors) - {B, C_tl, C_tr, C_bl, C_br}
    grid_output = [row[:] for row in grid_input]
    # For each enclosure color, find its bounding rectangle and the key color inside
    for E in enclosure_colors:
        e_cells = [(r, c) for r in range(height) for c in range(width) if grid_input[r][c] == E]
        if not e_cells:
            continue
        min_r = min(r for r, c in e_cells)
        max_r = max(r for r, c in e_cells)
        min_c = min(c for r, c in e_cells)
        max_c = max(c for r, c in e_cells)
        # Search for a key color inside the interior (one of the corner colors)
        key_color = None
        for r in range(min_r + 1, max_r):
            for c in range(min_c + 1, max_c):
                if grid_input[r][c] in corner_colors:
                    key_color = grid_input[r][c]
                    break
            if key_color is not None:
                break
        if key_color is None:
            # If no corner-colored key is found inside, skip this region
            continue
        # Map key color to the missing edge direction
        if key_color == C_tl:
            missing_edge = 'top'
        elif key_color == C_tr:
            missing_edge = 'right'
        elif key_color == C_bl:
            missing_edge = 'bottom'
        else:
            missing_edge = 'left'
        # Fill the missing edge in the output
        if missing_edge == 'top':
            for c in range(min_c, max_c + 1):
                grid_output[min_r][c] = E
        elif missing_edge == 'right':
            for r in range(min_r, max_r + 1):
                grid_output[r][max_c] = E
        elif missing_edge == 'bottom':
            for c in range(min_c, max_c + 1):
                grid_output[max_r][c] = E
        elif missing_edge == 'left':
            for r in range(min_r, max_r + 1):
                grid_output[r][min_c] = E
    return grid_output

