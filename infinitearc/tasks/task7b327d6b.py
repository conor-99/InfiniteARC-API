# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 7b327d6b
Difficulty: medium

=== Tags ===
- Divide by n
- Rotate each quadrant

=== Description ===
The input grid is a 2D array of integers between 0 and 9, with dimensions
ranging from 1×1 to 30×30. The task requires dividing the grid into four
quadrants (top-left, top-right, bottom-left, bottom-right) based on the grid's
dimensions. For grids with even width and height, the quadrants are equal in
size; for grids with odd dimensions, quadrants are divided as evenly as
possible. Each quadrant is then rotated 90 degrees clockwise (using a standard
matrix rotation: transpose followed by reversing each row). The rotated
quadrants are reassembled into their original positions to form the output grid.
This transformation requires understanding spatial division, matrix rotation
mechanics, and precise reassembly, making it a medium-difficulty task that tests
compositional reasoning about grid manipulation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    size = random.choice(range(4, 31, 2))
    width = height = size
    input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
    mid = width // 2
    
    tl = [row[:mid] for row in input_grid[:mid]]
    tr = [row[mid:] for row in input_grid[:mid]]
    bl = [row[:mid] for row in input_grid[mid:]]
    br = [row[mid:] for row in input_grid[mid:]]
    
    def rotate_90(g):
        return [list(x)[::-1] for x in zip(*g)]
    
    rotated_tl = rotate_90(tl)
    rotated_tr = rotate_90(tr)
    rotated_bl = rotate_90(bl)
    rotated_br = rotate_90(br)
    
    output_grid = []
    for i in range(mid):
        output_grid.append(rotated_tl[i] + rotated_tr[i])
    for i in range(mid):
        output_grid.append(rotated_bl[i] + rotated_br[i])
    
    if input_grid != output_grid:
        return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random

def p(input_grid):
    if not input_grid or not input_grid[0]:
        return input_grid
    size = min(len(input_grid), len(input_grid[0]))
    mid = size // 2
    
    def rotate_90(g):
        return [list(x)[::-1] for x in zip(*g)]
    
    tl = [row[:mid] for row in input_grid[:mid]]
    tr = [row[mid:] for row in input_grid[:mid]]
    bl = [row[:mid] for row in input_grid[mid:]]
    br = [row[mid:] for row in input_grid[mid:]]
    
    rotated_tl = rotate_90(tl)
    rotated_tr = rotate_90(tr)
    rotated_bl = rotate_90(bl)
    rotated_br = rotate_90(br)
    
    output = []
    for i in range(mid):
        output.append(rotated_tl[i] + rotated_tr[i])
    for i in range(mid):
        output.append(rotated_bl[i] + rotated_br[i])
    return output
