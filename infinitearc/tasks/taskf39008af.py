# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: f39008af
Difficulty: hard

=== Tags ===
- Create image from info
- Periodic boundary conditions

=== Description ===
The task involves transforming an input grid into an output grid using periodic
boundary conditions. The input grid contains colored pixels (values 0-9, where 0
represents empty space), and the output grid is generated by shifting each non-
zero pixel to the right by its color value (mod the grid width), with the grid
wrapping around at the edges. For example, a pixel with color 3 in column 5 of a
10-column grid shifts to column (5 + 3) % 10 = 8. Pixels that wrap past the
right edge reappear at the left edge. The transformation is applied uniformly
across all non-zero pixels, with no overlaps in the input grid to ensure
determinism. The output grid is derived solely from this shift operation,
creating a new visual pattern that encodes the input's color information through
periodic movement. This requires recognizing both the color-based shift rule and
the wrap-around behavior to reconstruct the output from the input.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    W = random.randint(2, 30)
    H = random.randint(1, 30)
    N = min(random.randint(2, 9), W)
    r = 0
    input_grid = common.grid(W, H, 0)
    output_grid = common.grid(W, H, 0)
    used_ci = set()
    for i in range(N):
        while True:
            k = random.randint(1, 9)
            if W <= 9 and k == W:
                continue
            ci = (i - k) % W
            if ci not in used_ci:
                used_ci.add(ci)
                input_grid[r][ci] = k
                output_grid[r][i] = k
                break
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    if not input_grid:
        return []
    W = len(input_grid[0])
    H = len(input_grid)
    output_grid = common.grid(W, H, 0)
    for r in range(H):
        for c in range(W):
            color = input_grid[r][c]
            if color > 0:
                new_c = (c + color) % W
                output_grid[r][new_c] = color
    return output_grid
