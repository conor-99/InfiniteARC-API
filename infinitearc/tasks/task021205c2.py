# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 021205c2
Difficulty: very hard

=== Tags ===
- Mirror pair coordination
- Diagonal weaving
- Agent memory trace
- Pairwise rule matching
- Connect equal color components
- Associate patterns to patterns

=== Description ===
Input grids are large (15Ã—15 or larger) with a uniform background color (0). The
grid contains multiple distinct colored components (colors 1-9), each appearing
exactly twice as mirror-image pairs across the grid's vertical axis. Each
component is a contiguous region of its color, not overlapping with other
components or the background. The output grid connects each pair of components
with a diagonal path of the same color, weaving through the background using
alternating diagonal directions (e.g., northeast then northwest). The path must
start at the topmost cell of the left component and end at the topmost cell of
the right component, weaving to avoid all other components and existing paths.
The weaving direction alternates consistently (e.g., NE, NW, NE, NW...) and is
determined by the component's vertical position: pairs in the upper half of the
grid weave upward (alternating NE/NW), while pairs in the lower half weave
downward (alternating SE/SW). Paths must not cross, overlap, or pass through
non-background cells, and must connect each pair without looping. The weaving
pattern creates a diagonal "weave" where paths interlace like threads in a
fabric, with each pair's path maintaining symmetry relative to the grid's
vertical midline while dynamically adjusting direction to navigate around
obstacles.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Choose an odd width between 15 and 29 inclusive to ensure an even column-distance
    width = random.choice(list(range(15, 31, 2)))
    height = random.randint(15, 30)
    mid = (width - 1) // 2

    input_grid = grid(width, height, 0)

    # Determine number of mirrored color pairs. Keep it modest so we can space rows.
    max_pairs = min(5, mid, (height - 2) // 3)
    if max_pairs < 3:
        num_pairs = max(1, max_pairs)
    else:
        num_pairs = random.randint(3, max_pairs)

    # Choose top rows with spacing >= 3 so their weave rows (r and r+/-1) don't collide.
    candidate_rows = list(range(1, height - 1))
    random.shuffle(candidate_rows)
    selected_rows = []
    for r in candidate_rows:
        if all(abs(r - sr) >= 3 for sr in selected_rows):
            selected_rows.append(r)
            if len(selected_rows) == num_pairs:
                break
    # If we didn't find enough spaced rows, reduce the number of pairs.
    num_pairs = min(num_pairs, len(selected_rows))
    selected_rows = selected_rows[:num_pairs]

    # Choose distinct left anchor columns (strictly left of the vertical midline)
    candidate_cols = list(range(0, mid))
    random.shuffle(candidate_cols)
    selected_cols = candidate_cols[:num_pairs]

    colors = random.sample(list(range(1, 10)), num_pairs)

    # Place mirrored, contiguous vertical components (simple bars) so each appears exactly twice
    for color, r_top, c_left in zip(colors, selected_rows, selected_cols):
        size_max = min(3, height - r_top)
        size = random.randint(1, size_max)
        for k in range(size):
            input_grid[r_top + k][c_left] = color
            input_grid[r_top + k][width - 1 - c_left] = color

    # Build the output grid by drawing the diagonal weaving paths (over a copy of the input)
    output_grid = [row[:] for row in input_grid]

    for color in colors:
        # collect all cells of this color
        cells = [(r, c) for r in range(height) for c in range(width) if input_grid[r][c] == color]
        if not cells:
            continue
        # split into orthogonally connected components
        cells_set = set(cells)
        comps = []
        while cells_set:
            start = next(iter(cells_set))
            stack = [start]
            comp = set()
            while stack:
                cr, cc = stack.pop()
                if (cr, cc) not in cells_set:
                    continue
                cells_set.remove((cr, cc))
                comp.add((cr, cc))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = cr + dr, cc + dc
                    if (nr, nc) in cells_set:
                        stack.append((nr, nc))
            comps.append(comp)
        # we expect exactly two mirrored components; skip if not
        if len(comps) != 2:
            continue
        # left component is the one with the smaller column index
        comp_left = min(comps, key=lambda comp: min(c for (_, c) in comp))
        top_left = min(comp_left, key=lambda x: (x[0], x[1]))
        r_start, c_start = top_left
        c_end = width - 1 - c_start

        # Determine weaving direction: upper half weave upward (start with -1), lower half downward (+1)
        initial_dir = -1 if r_start < height // 2 else 1

        cr = r_start
        # Step from left top cell across to the right mirror, alternating vertical direction every column
        for i in range(1, c_end - c_start + 1):
            d = initial_dir if (i % 2) == 1 else -initial_dir
            cr = cr + d
            cc = c_start + i
            # Draw only through background cells so we don't overwrite components
            if 0 <= cr < height and 0 <= cc < width and input_grid[cr][cc] == 0:
                output_grid[cr][cc] = color

    return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    output = [row[:] for row in grid]

    # For each color, find its two mirrored components and reconstruct the same weave
    for color in range(1, 10):
        # collect all cells of this color
        cells = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == color]
        if not cells:
            continue
        # find orthogonally connected components
        cells_set = set(cells)
        comps = []
        while cells_set:
            start = next(iter(cells_set))
            stack = [start]
            comp = set()
            while stack:
                cr, cc = stack.pop()
                if (cr, cc) not in cells_set:
                    continue
                cells_set.remove((cr, cc))
                comp.add((cr, cc))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = cr + dr, cc + dc
                    if (nr, nc) in cells_set:
                        stack.append((nr, nc))
            comps.append(comp)
        # expect two mirrored components
        if len(comps) != 2:
            continue
        # left component is the one with the smaller column
        comp_left = min(comps, key=lambda comp: min(c for (_, c) in comp))
        top_left = min(comp_left, key=lambda x: (x[0], x[1]))
        r_start, c_start = top_left
        c_end = width - 1 - c_start

        # determine weaving orientation
        initial_dir = -1 if r_start < height // 2 else 1

        cr = r_start
        for i in range(1, c_end - c_start + 1):
            d = initial_dir if (i % 2) == 1 else -initial_dir
            cr = cr + d
            cc = c_start + i
            if 0 <= cr < height and 0 <= cc < width and output[cr][cc] == 0:
                output[cr][cc] = color

    return output

