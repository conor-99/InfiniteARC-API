# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 68c58c9f
Difficulty: insane

=== Tags ===
- Path scarring
- Coordinate warp
- Color modulated logic
- Detect background color
- Remove border

=== Description ===
The input grid features a background color (detected as the most frequent color
across the entire grid) surrounded by multiple non-background paths. Each path
consists of connected cells of a single non-background color, forming continuous
sequences that may intersect or branch. The output grid is generated through the
following steps:  1. **Background Detection**: Identify the background color as
the most frequent color in the grid (excluding edge cases where multiple colors
tie for frequency).  2. **Border Removal**: Remove all outermost perimeter cells
(top, bottom, left, and right edges) from the input grid, creating a smaller
internal grid.  3. **Coordinate Warp**: For each path in the internal grid,
apply a coordinate warp proportional to the path’s color value. Each cell in the
path is shifted diagonally (right and down) by its color value (e.g., a path of
color 4 shifts each cell 4 units right and 4 units down, wrapping around grid
boundaries if necessary).  4. **Path Scarring**: The warped path cells are
marked with their original color in the output grid, forming a "scarring" trail.
Non-path cells retain their original colors, and any cells that warp to
overlapping positions are resolved by prioritizing the path with the highest
color value.  5. **Color Modulated Logic**: The warp magnitude is strictly
determined by the path’s color (0-9), with color 0 causing no warp. Paths of
higher color values warp more significantly, causing complex spatial
rearrangements that must be tracked through multiple steps.  The transformation
requires simultaneous application of border removal, background detection,
coordinate warping, and path scarring logic, with no overlapping path resolution
ambiguity. The output grid must maintain all original path colors while visually
representing the warped path trails, with all border cells excluded.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import continuous_creature, randint

def generate():
    width = randint(3, 30)
    height = randint(3, 30)
    bg = randint(0, 9)
    grid = [[bg] * width for _ in range(height)]
    
    # Generate up to 5 paths
    for _ in range(5):
        color = randint(0, 9)
        while color == bg:
            color = randint(0, 9)
        size = randint(3, 10)
        try:
            pixels = continuous_creature(size, width, height)
        except:
            continue
        valid = True
        for r, c in pixels:
            if grid[r][c] != bg:
                valid = False
                break
        if not valid:
            continue
        for r, c in pixels:
            grid[r][c] = color
    
    # Compute internal grid
    internal = [row[1:-1] for row in grid[1:-1]]
    internal_height = len(internal)
    internal_width = len(internal[0])
    
    # Create output grid
    output = [[bg] * internal_width for _ in range(internal_height)]
    # Track max colors
    max_color = [[bg] * internal_width for _ in range(internal_height)]
    
    for r in range(internal_height):
        for c in range(internal_width):
            if internal[r][c] != bg:
                new_r = (r + internal[r][c]) % internal_height
                new_c = (c + internal[r][c]) % internal_width
                if internal[r][c] > max_color[new_r][new_c]:
                    max_color[new_r][new_c] = internal[r][c]
    
    for r in range(internal_height):
        for c in range(internal_width):
            output[r][c] = max_color[r][c]
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid or not input_grid[0]:
        return []
    
    all_vals = [val for row in input_grid for val in row]
    bg = max(set(all_vals), key=all_vals.count)
    
    height = len(input_grid)
    width = len(input_grid[0])
    
    if width < 3 or height < 3:
        # For grids too small, fallback (though shouldn't happen)
        return input_grid
    
    # Internal grid is rows 1 to -2, cols 1 to -2
    internal = [row[1:-1] for row in input_grid[1:-1]]
    h, w = len(internal), len(internal[0])
    
    # Initialize output with bg
    output = [[bg] * w for _ in range(h)]
    
    # For each cell in internal, if not bg, warp
    for r in range(h):
        for c in range(w):
            color_val = internal[r][c]
            if color_val == bg:
                continue
            new_r = (r + color_val) % h
            new_c = (c + color_val) % w
            if color_val > output[new_r][new_c]:
                output[new_r][new_c] = color_val
    
    return output
