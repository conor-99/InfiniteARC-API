# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 8a82d0c7
Difficulty: medium

=== Tags ===
- Associate colors to numbers
- X marks the spot

=== Description ===
The task involves transforming an input grid into an output grid by creating an
"X" shape using the color from the top-left cell of the input. The input grid is
a 2D array of colors (represented by numbers 0-9), where each cell contains a
color value. The output grid is generated by modifying all cells along both main
diagonals (from top-left to bottom-right and top-right to bottom-left) to match
the color value of the input's top-left cell (position [0][0]). All other cells
in the output grid remain identical to their corresponding input cells. This
transformation results in a visible "X" pattern, where the color of the X is
directly associated with the top-left color of the input. The task requires
recognizing that the top-left color dictates the X's color and applying this
rule consistently across the grid, without relying on numerical operations or
pixel-level analysis. The difficulty is medium as it requires identifying
diagonal patterns and mapping a single cell's value to a structural feature,
while avoiding common pitfalls like overcomplicating the rule with additional
transformations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
def generate():
    width = random.randint(2, 30)
    height = random.randint(2, 30)
    input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
    top_left = input_grid[0][0]
    diag_cells = []
    for i in range(1, min(width, height)):
        diag_cells.append((i, i))
    for i in range(1, min(height, width)):
        if i < height and (width - 1 - i) < width:
            diag_cells.append((i, width - 1 - i))
    all_same = True
    for (r, c) in diag_cells:
        if input_grid[r][c] != top_left:
            all_same = False
            break
    if all_same and diag_cells:
        r, c = diag_cells[0]
        new_color = random.randint(0, 9)
        while new_color == top_left:
            new_color = random.randint(0, 9)
        input_grid[r][c] = new_color
    output_grid = [row[:] for row in input_grid]
    for i in range(min(width, height)):
        output_grid[i][i] = top_left
    for i in range(min(height, width)):
        j = width - 1 - i
        if 0 <= j < width and i < height:
            output_grid[i][j] = top_left
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid or not input_grid[0]:
        return []
    top_left = input_grid[0][0]
    height = len(input_grid)
    width = len(input_grid[0])
    output = [list(row) for row in input_grid]
    for i in range(min(width, height)):
        output[i][i] = top_left
    for i in range(min(height, width)):
        j = width - 1 - i
        if 0 <= j < width and i < height:
            output[i][j] = top_left
    return output
