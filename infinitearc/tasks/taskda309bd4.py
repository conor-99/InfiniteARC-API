# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: da309bd4
Difficulty: hard

=== Tags ===
- Connect components by property
- Dependency topological sort
- Constraint satisfaction coloring
- Context sensitive recolor

=== Description ===
Input grids consist of a background color (0) and multiple disconnected,
contiguous regions of colors 1-9. Each region's color encodes a dependency
relationship: for example, a region of color 2 must connect to a region of color
3 before color 3 can connect to color 4. The dependency relationships form a
directed acyclic graph (DAG) where edges indicate that the target color must be
connected before the source color can be connected to its dependencies.   The
output grid must connect all regions following the topological order of the
dependency DAG. For each connection between a region of color A and color B, a
path is drawn using a predefined color C (determined by the pair (A,B), e.g.,
(1,2) → 5, (2,3) → 6). This path must traverse only background cells (0), avoid
overlapping with existing regions or other paths, and use color C such that no
cell in the path is adjacent to a cell of color C in the original grid (ensuring
constraint satisfaction).   The task requires identifying connected components,
inferring the dependency graph from color relationships, performing a
topological sort, and solving a constrained pathfinding problem for each
connection while adhering to adjacency constraints. Paths must be the shortest
possible and avoid conflicts, making the solution require multi-step reasoning
and careful constraint management.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque
from common import grid

def generate():
    # Grid size
    width = random.randint(15, 20)
    height = random.randint(15, 20)
    input_grid = grid(width, height, 0)

    # Choose number of regions (nodes in the dependency graph)
    num_regions = random.randint(3, 5)
    # Reserve color 1 for potential path colors; choose region colors from 2..9
    region_colors = random.sample(list(range(2, 10)), num_regions)

    # We'll enforce a minimum spacing between regions so that paths can be routed.
    occupancy = [[0 for _ in range(width)] for _ in range(height)]  # 0 = free, >0 = occupied by region or later by paths
    regions = {}  # color -> list of (r,c) pixels

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    def in_bounds(r, c):
        return 0 <= r < height and 0 <= c < width

    # Place one connected region per chosen color.
    for color in region_colors:
        placed = False
        # try a few sizes and placement attempts
        for size_attempt in range(5):
            size = random.randint(3, 6)
            for attempt in range(300):
                # pick a random seed cell away from the edges to leave room
                r0 = random.randint(1, height - 2)
                c0 = random.randint(1, width - 2)
                pixels = {(r0, c0)}
                fail = False
                # grow the connected shape
                for _ in range(size - 1):
                    frontier = []
                    for (r, c) in list(pixels):
                        for dr, dc in directions:
                            nr, nc = r + dr, c + dc
                            if not in_bounds(nr, nc):
                                continue
                            if (nr, nc) in pixels:
                                continue
                            if occupancy[nr][nc] != 0:
                                continue
                            # Do not allow placing a pixel that is adjacent to an existing region
                            too_close = False
                            for dr2, dc2 in directions:
                                ar, ac = nr + dr2, nc + dc2
                                if in_bounds(ar, ac) and occupancy[ar][ac] != 0 and (ar, ac) not in pixels:
                                    too_close = True
                                    break
                            if too_close:
                                continue
                            if (nr, nc) not in frontier:
                                frontier.append((nr, nc))
                    if not frontier:
                        fail = True
                        break
                    nr, nc = random.choice(frontier)
                    pixels.add((nr, nc))
                if fail:
                    continue
                # ensure the new shape does not touch existing shapes
                touches_existing = False
                for (r, c) in pixels:
                    for dr, dc in directions:
                        ar, ac = r + dr, c + dc
                        if in_bounds(ar, ac) and occupancy[ar][ac] != 0 and (ar, ac) not in pixels:
                            touches_existing = True
                            break
                    if touches_existing:
                        break
                if touches_existing:
                    continue
                # ensure there is at least one free neighbor cell (background) adjacent to the shape
                has_free_adj = False
                for (r, c) in pixels:
                    for dr, dc in directions:
                        ar, ac = r + dr, c + dc
                        if in_bounds(ar, ac) and occupancy[ar][ac] == 0 and (ar, ac) not in pixels:
                            has_free_adj = True
                            break
                    if has_free_adj:
                        break
                if not has_free_adj:
                    continue
                # accept placement
                for (r, c) in pixels:
                    input_grid[r][c] = color
                    occupancy[r][c] = color
                regions[color] = sorted(list(pixels))
                placed = True
                break
            if placed:
                break
        if not placed:
            # fallback: force place a single pixel (rare)
            for attempt in range(1000):
                r0 = random.randint(0, height - 1)
                c0 = random.randint(0, width - 1)
                if occupancy[r0][c0] == 0:
                    input_grid[r0][c0] = color
                    occupancy[r0][c0] = color
                    regions[color] = [(r0, c0)]
                    placed = True
                    break
        if not placed:
            raise RuntimeError("Could not place region")

    # Build the dependency chain as a simple topological order: highest color -> next highest -> ...
    topo_order = sorted(region_colors, reverse=True)

    # Output grid starts as a copy of the input
    output_grid = [row[:] for row in input_grid]

    # Colors available for drawing paths: any colors not used by regions
    available_colors = sorted([c for c in range(1, 10) if c not in region_colors])
    if not available_colors:
        available_colors = [1]

    # We'll mark blocked cells for pathfinding (1 = blocked by region or already-drawn path, 0 = free)
    blocked = [[1 if input_grid[r][c] != 0 else 0 for c in range(width)] for r in range(height)]

    # Use deterministic neighbor expansion order
    nbrs = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    # Connect regions following topological order, connecting adjacent-background cells
    for idx in range(len(topo_order) - 1):
        src = topo_order[idx]
        dst = topo_order[idx + 1]
        path_color = available_colors[idx % len(available_colors)]

        # find free background cells adjacent to src and dst regions
        src_adj = set()
        dst_adj = set()
        for (r, c) in regions[src]:
            for dr, dc in nbrs:
                nr, nc = r + dr, c + dc
                if in_bounds(nr, nc) and blocked[nr][nc] == 0:
                    src_adj.add((nr, nc))
        for (r, c) in regions[dst]:
            for dr, dc in nbrs:
                nr, nc = r + dr, c + dc
                if in_bounds(nr, nc) and blocked[nr][nc] == 0:
                    dst_adj.add((nr, nc))

        src_list = sorted(src_adj)
        dst_set = set(dst_adj)

        # BFS from all src_adj positions to any dst_adj position
        q = deque()
        visited = set()
        for s in src_list:
            q.append((s, [s]))
            visited.add(s)
        found_path = None
        while q:
            (r, c), path = q.popleft()
            if (r, c) in dst_set:
                found_path = path
                break
            for dr, dc in nbrs:
                nr, nc = r + dr, c + dc
                if not in_bounds(nr, nc):
                    continue
                if (nr, nc) in visited:
                    continue
                if blocked[nr][nc] != 0:
                    continue
                visited.add((nr, nc))
                q.append(((nr, nc), path + [(nr, nc)]))

        if found_path is None:
            # If no path found (should be rare due to spacing), skip this connection
            continue

        # Draw the path and mark blocked cells so future paths don't overlap
        for (r, c) in found_path:
            output_grid[r][c] = path_color
            blocked[r][c] = 1

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Helper functions
    def in_bounds(r, c):
        return 0 <= r < height and 0 <= c < width

    nbrs = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    # Find connected regions (components) by color
    visited = [[False] * width for _ in range(height)]
    regions = {}  # color -> list of pixels

    def dfs(r, c, color, pixels):
        stack = [(r, c)]
        visited[r][c] = True
        while stack:
            rr, cc = stack.pop()
            pixels.append((rr, cc))
            for dr, dc in nbrs:
                nr, nc = rr + dr, cc + dc
                if not in_bounds(nr, nc):
                    continue
                if visited[nr][nc]:
                    continue
                if grid[nr][nc] != color:
                    continue
                visited[nr][nc] = True
                stack.append((nr, nc))

    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and not visited[r][c]:
                color = grid[r][c]
                pixels = []
                dfs(r, c, color, pixels)
                regions[color] = sorted(pixels)

    # Determine topological order (generator uses descending color order)
    region_colors = sorted(regions.keys(), reverse=True)

    # Determine available path colors (colors not used by regions)
    available_colors = sorted([c for c in range(1, 10) if c not in region_colors])
    if not available_colors:
        available_colors = [1]

    # Prepare blocked grid (1 = blocked by region or by already drawn path)
    blocked = [[1 if grid[r][c] != 0 else 0 for c in range(width)] for r in range(height)]

    output = [row[:] for row in grid]

    # Connect regions in topological order using shortest paths between adjacent background cells
    for idx in range(len(region_colors) - 1):
        src = region_colors[idx]
        dst = region_colors[idx + 1]
        path_color = available_colors[idx % len(available_colors)]

        # find free background cells adjacent to src and dst
        src_adj = set()
        dst_adj = set()
        for (r, c) in regions[src]:
            for dr, dc in nbrs:
                nr, nc = r + dr, c + dc
                if in_bounds(nr, nc) and blocked[nr][nc] == 0:
                    src_adj.add((nr, nc))
        for (r, c) in regions[dst]:
            for dr, dc in nbrs:
                nr, nc = r + dr, c + dc
                if in_bounds(nr, nc) and blocked[nr][nc] == 0:
                    dst_adj.add((nr, nc))

        src_list = sorted(src_adj)
        dst_set = set(dst_adj)

        # BFS search
        q = deque()
        visited_bfs = set()
        for s in src_list:
            q.append((s, [s]))
            visited_bfs.add(s)
        found_path = None
        while q:
            (r, c), path = q.popleft()
            if (r, c) in dst_set:
                found_path = path
                break
            for dr, dc in nbrs:
                nr, nc = r + dr, c + dc
                if not in_bounds(nr, nc):
                    continue
                if (nr, nc) in visited_bfs:
                    continue
                if blocked[nr][nc] != 0:
                    continue
                visited_bfs.add((nr, nc))
                q.append(((nr, nc), path + [(nr, nc)]))

        if found_path is None:
            # no path found, skip
            continue

        # Draw path and block cells for subsequent connections
        for (r, c) in found_path:
            output[r][c] = path_color
            blocked[r][c] = 1

    return tuple(tuple(row) for row in output)

