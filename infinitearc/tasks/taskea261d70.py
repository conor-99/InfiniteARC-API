# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: ea261d70
Difficulty: hard

=== Tags ===
- Color by distance to edge

=== Description ===
The task involves transforming an input grid into an output grid based on the
distance of each cell to the nearest grid edge. Input grids contain a background
color (0) and multiple distinct foreground colors (1-9) arranged in non-
overlapping regions. The output grid is generated by replacing each cell's color
with the color found at the diagonal position (d, d) in the input grid, where d
represents the cell's distance to the nearest edge. The distance d is calculated
as the minimum of the cell's row index, height minus one minus the row index,
column index, and width minus one minus the column index. For example, in a 7x7
grid, the center cell (3,3) has d=3, so its output color is taken from the input
grid's (3,3) cell. The transformation creates concentric color rings in the
output, with each ring's color corresponding to the input's diagonal color at
that distance layer. This requires identifying the input's diagonal pattern and
mapping it to the concentric distance structure, making it challenging due to
the need to simultaneously recognize both the edge-distance geometry and the
diagonal color mapping.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    while True:
        H = random.randint(1, 30)
        W = random.randint(1, 30)
        input_grid = [[random.randint(0, 9) for _ in range(W)] for _ in range(H)]
        max_d = min(H-1, W-1) // 2
        for d in range(max_d + 1):
            input_grid[d][d] = random.randint(0, 9)
        output_grid = [[0] * W for _ in range(H)]
        for r in range(H):
            for c in range(W):
                d = min(r, H-1-r, c, W-1-c)
                output_grid[r][c] = input_grid[d][d]
        if input_grid != output_grid:
            return {
                "input": input_grid,
                "output": output_grid
            }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    H = len(input_grid)
    W = len(input_grid[0])
    output_grid = [[0] * W for _ in range(H)]
    for r in range(H):
        for c in range(W):
            d = min(r, H-1-r, c, W-1-c)
            output_grid[r][c] = input_grid[d][d]
    return output_grid
