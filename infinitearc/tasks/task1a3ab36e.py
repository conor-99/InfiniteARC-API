# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 1a3ab36e
Difficulty: very hard

=== Tags ===
- Layered occlusion unfolding
- Momentum conservation path

=== Description ===
Input grids are large (width and height exceeding 20) with a uniform background
color. Overlaid on this background are multiple overlapping, contiguous regions
of distinct colors, each representing a separate layer. These layers form
complex occlusions where regions of one color partially obscure regions of
another, creating a maze-like structure of visible boundaries between layers. A
path begins at a designated starting point on the grid's left edge within a
background cell, moving initially in a fixed direction (e.g., rightward). The
path traverses background cells until it encounters a boundary between two
distinct layers. At each boundary, the path reflects according to the boundary's
orientation: vertical boundaries reverse the horizontal direction of travel,
while horizontal boundaries reverse the vertical direction. This reflection
follows a strict conservation of directional momentum, ensuring the angle of
incidence equals the angle of reflection relative to the boundary. The path
continues in the new direction, reflecting at subsequent boundaries until it
exits the grid. The path's color cycles through a predefined sequence (e.g., red
→ green → blue → red) with each step along its trajectory, never overwriting
layer regions or other path segments. The output grid preserves all original
layer regions and their occlusions while displaying the fully reflected path
with its color sequence intact. The complexity arises from navigating multiple
overlapping layers with irregular boundary orientations, requiring precise
tracking of reflection logic and color progression through a non-linear path.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, continuous_creature

def generate():
    width = 25
    height = 25
    grid_in = grid(width, height, 0)
    n_layers = random.randint(3, 5)
    for _ in range(n_layers):
        size = random.randint(10, 20)
        color = random.randint(1, 9)
        pixels = continuous_creature(size, width, height)
        for r, c in pixels:
            grid_in[r][c] = color
    start_row = None
    for r in range(height):
        if grid_in[r][0] == 0 and grid_in[r][1] == 0:
            start_row = r
            break
    if start_row is None:
        start_row = height // 2
    grid_out = [row[:] for row in grid_in]
    color_seq = [1, 2, 3]
    dx, dy = 0, 1
    r, c = start_row, 0
    color_idx = 0
    while 0 <= r < height and 0 <= c < width:
        nr, nc = r + dx, c + dy
        if not (0 <= nr < height and 0 <= nc < width):
            break
        if grid_in[nr][nc] != 0:
            if dy != 0:
                dy = -dy
            else:
                dx = -dx
        else:
            r, c = nr, nc
            grid_out[r][c] = color_seq[color_idx]
            color_idx = (color_idx + 1) % len(color_seq)
    return {
        "input": grid_in,
        "output": grid_out
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    start_row = None
    for r in range(height):
        if input_grid[r][0] == 0 and input_grid[r][1] == 0:
            start_row = r
            break
    if start_row is None:
        start_row = height // 2
    output_grid = [row[:] for row in input_grid]
    color_seq = [1, 2, 3]
    dx, dy = 0, 1
    r, c = start_row, 0
    color_idx = 0
    while 0 <= r < height and 0 <= c < width:
        nr, nc = r + dx, c + dy
        if not (0 <= nr < height and 0 <= nc < width):
            break
        if input_grid[nr][nc] != 0:
            if dy != 0:
                dy = -dy
            else:
                dx = -dx
        else:
            r, c = nr, nc
            output_grid[r][c] = color_seq[color_idx]
            color_idx = (color_idx + 1) % len(color_seq)
    return output_grid
