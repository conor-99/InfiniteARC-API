# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: dbc89121
Difficulty: easy

=== Tags ===
- Separate image
- Find the two identical shapes
- Size guessing
- Snap to grid

=== Description ===
The task involves transforming an input grid containing two identical shapes
into an output grid that represents the minimal bounding box of one of the
shapes. The input grid features two distinct, non-overlapping shapes of the same
size, pattern, and color, separated by empty space (value 0). The shapes are
aligned to grid coordinates, with no diagonal or irregular positioning. The
output grid is generated by identifying the smallest rectangle that fully
encloses one of the identical shapes (determined by the maximum and minimum row
and column indices of the shape's pixels) and filling this rectangle with the
shape's pattern. The transformation does not require color changes or complex
operations—only extracting the shape's spatial dimensions and content. For
example, if the input contains two 3×2 rectangles of color 5 at opposite
corners, the output will be a 3×2 grid filled with 5s. The "size guessing"
aspect arises because the output grid's dimensions are inferred solely from the
shape's bounding box, and "snap to grid" ensures the shape's pixels align with
integer coordinates, making the bounding box calculation straightforward. The
task is designed for easy visual recognition, as the two identical shapes are
clearly distinguishable by their arrangement and color.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    c = common.random.randint(1, 9)
    w = common.random.randint(1, 5)
    h = common.random.randint(1, 5)
    
    input_width = max(2 * w + 3, 1)
    input_height = max(2 * h + 3, 1)
    input_width = min(input_width, 30)
    input_height = min(input_height, 30)
    
    input_grid = common.grid(input_width, input_height, 0)
    
    for r in range(h):
        for c_col in range(w):
            input_grid[r][c_col] = c
    
    start_r = input_height - h
    start_c = input_width - w
    for r in range(start_r, start_r + h):
        for c_col in range(start_c, start_c + w):
            input_grid[r][c_col] = c
    
    output_grid = common.grid(h, w, c)
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
from collections import deque

def p(input_grid):
    color = None
    start_r, start_c = -1, -1
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] != 0:
                color = input_grid[r][c]
                start_r, start_c = r, c
                break
        if color is not None:
            break
    if color is None:
        return common.grid(1, 1, 0)
    
    visited = set()
    queue = deque([(start_r, start_c)])
    visited.add((start_r, start_c))
    component = []
    
    while queue:
        r, c = queue.popleft()
        component.append((r, c))
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < len(input_grid) and 0 <= nc < len(input_grid[0]) and input_grid[nr][nc] == color and (nr, nc) not in visited:
                visited.add((nr, nc))
                queue.append((nr, nc))
    
    rows = [p[0] for p in component]
    cols = [p[1] for p in component]
    min_r, max_r = min(rows), max(rows)
    min_c, max_c = min(cols), max(cols)
    height = max_r - min_r + 1
    width = max_c - min_c + 1
    
    return common.grid(height, width, color)
