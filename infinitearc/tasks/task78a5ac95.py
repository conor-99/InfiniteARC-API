# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 78a5ac95
Difficulty: medium–hard

=== Tags ===
- Wavefront timing
- Local symmetry matching
- Beam reflection
- Local state machine

=== Description ===
Reflective Wavefront Propagation  Input grids feature a background (color 0), a
single beam (color 1) moving in a specific direction (evident through adjacent
color 1 cells), and reflective surfaces (color 2) arranged as contiguous
vertical or horizontal lines. The beam moves one cell per step in its current
direction. Upon contacting a vertical reflective surface (color 2 in a column),
horizontal movement reverses (e.g., right → left). Upon contacting a horizontal
reflective surface (color 2 in a row), vertical movement reverses (e.g., down →
up). Obstacles (color 3) permanently halt beam movement. The output grid shows
the beam's new position after one step of propagation, with all reflective
surfaces and obstacles preserved. The transformation requires identifying
surface orientation from grid patterns and applying direction reversal rules
while maintaining the beam's path consistency.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    while True:
        width = random.randint(1, 30)
        height = random.randint(1, 30)
        if width >= 4 or height >= 4:
            break
    
    direction = 'H' if width >= 4 else 'V'
    
    if direction == 'H':
        L = random.randint(2, min(5, width - 2))
        c = random.randint(1, width - L - 1)
        row = random.randint(0, height - 1)
        grid_input = [[0] * width for _ in range(height)]
        for i in range(L):
            grid_input[row][c + i] = 1
        grid_input[row][c + L] = 2
        grid_output = [row[:] for row in grid_input]
        for i in range(L):
            grid_output[row][c + i] = 0
        for i in range(L):
            grid_output[row][c - 1 + i] = 1
    else:
        L = random.randint(2, min(5, height - 2))
        row = random.randint(1, height - L - 1)
        col = random.randint(0, width - 1)
        grid_input = [[0] * width for _ in range(height)]
        for i in range(L):
            grid_input[row + i][col] = 1
        grid_input[row + L][col] = 2
        grid_output = [row[:] for row in grid_input]
        for i in range(L):
            grid_output[row + i][col] = 0
        for i in range(L):
            grid_output[row - 1 + i][col] = 1
    
    return {'input': grid_input, 'output': grid_output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    
    beam_cells = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 1:
                beam_cells.append((r, c))
    
    if not beam_cells:
        return tuple(tuple(row) for row in grid)
    
    rows = [r for r, c in beam_cells]
    cols = [c for r, c in beam_cells]
    is_horizontal = len(set(rows)) == 1
    is_vertical = len(set(cols)) == 1
    
    if is_horizontal:
        r = rows[0]
        c_min = min(cols)
        c_max = max(cols)
        L = c_max - c_min + 1
        next_col = c_max + 1
        
        if next_col >= width:
            return tuple(tuple(row) for row in grid)
        
        next_color = grid[r][next_col]
        
        if next_color == 2:
            for i in range(L):
                grid[r][c_min + i] = 0
            for i in range(L):
                grid[r][c_min - 1 + i] = 1
        elif next_color != 3:
            for i in range(L):
                grid[r][c_min + i] = 0
            for i in range(L):
                grid[r][c_min + 1 + i] = 1
    else:
        c = cols[0]
        r_min = min(rows)
        r_max = max(rows)
        L = r_max - r_min + 1
        next_row = r_max + 1
        
        if next_row >= height:
            return tuple(tuple(row) for row in grid)
        
        next_color = grid[next_row][c]
        
        if next_color == 2:
            for i in range(L):
                grid[r_min + i][c] = 0
            for i in range(L):
                grid[r_min - 1 + i][c] = 1
        elif next_color != 3:
            for i in range(L):
                grid[r_min + i][c] = 0
            for i in range(L):
                grid[r_min + 1 + i][c] = 1
    
    return tuple(tuple(row) for row in grid)
