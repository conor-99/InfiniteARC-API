# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: adaac555
Difficulty: medium–hard

=== Tags ===
- Mark wall impact
- Laser diffusion
- Periodic tiling
- Rotate to canonical

=== Description ===
Input grids feature a maze of walls (single-color lines forming interconnected
paths and barriers) and laser sources (small L-shaped clusters of connected
cells oriented in diagonal directions). The grid may be rotated arbitrarily,
causing walls to appear at non-axis-aligned angles. A periodic color sequence is
displayed as a horizontal strip of 2×2 color blocks in the top-left corner,
defining a repeating cycle (e.g., red → green → blue → red).   The output grid
is generated by first rotating the input to a canonical orientation (aligning
the primary wall structure to horizontal), then simulating laser diffusion: each
laser emits a beam traveling diagonally in its orientation until hitting a wall.
At each wall impact, the beam's color cycles to the next in the periodic
sequence, and the path is drawn with the current color. Beams reflect off walls
without overlapping or altering the original wall structure, continuing until
exiting the grid. Walls, laser sources, and the periodic pattern remain
unchanged, while background cells along beam paths display the current color
from the sequence. The output shows the canonical-rotated grid with beam paths
marked by the periodic color transitions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = random.randint(11, 30)
    height = random.randint(10, 30)
    base = common.grid(width, height, 0)
    
    # Place walls
    for r in range(3, 8):
        for c in range(2, 8):
            base[r][c] = 1
    for c in range(5, 10):
        for r in range(2, 9):
            base[r][c] = 1
    
    # Place laser
    base[2][2] = 2
    base[2][3] = 2
    base[3][2] = 2
    
    # Place periodic strip
    colors = [3, 4, 5, 6]
    for i in range(4):
        start_col = i * 3
        for r in range(2):
            for c in range(2):
                if start_col + c < width and r < height:
                    base[r][start_col + c] = colors[i % len(colors)]
    
    # Rotate base for input
    rotation = random.randint(0, 3)
    input_grid = base
    for _ in range(rotation):
        input_grid = [list(x)[::-1] for x in zip(*input_grid)]
    
    # Create output by simulating beams on base
    output_grid = [row[:] for row in base]
    tip_r, tip_c = 3, 3
    dr, dc = 1, 1
    color_seq = [3, 4, 5, 6]
    idx = 0
    r, c = tip_r, tip_c
    while True:
        nr, nc = r + dr, c + dc
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        if base[nr][nc] != 0:
            output_grid[r][c] = color_seq[idx]
            idx = (idx + 1) % len(color_seq)
            dr, dc = -dr, dc
            r, c = nr, nc
        else:
            output_grid[r][c] = color_seq[idx]
            idx = (idx + 1) % len(color_seq)
            r, c = nr, nc
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to list of lists to avoid tuple errors
    input_grid = [list(row) for row in input_grid]
    
    colors = [3, 4, 5, 6]
    base = None
    for rotation in range(4):
        rotated = [row[:] for row in input_grid]
        for _ in range(rotation):
            rotated = [list(x)[::-1] for x in zip(*rotated)]
        
        # Check for periodic strip pattern with sufficient width
        if len(rotated[0]) >= 11:
            if (rotated[0][0] == colors[0] and rotated[0][1] == colors[0] and
                rotated[0][3] == colors[1] and rotated[0][4] == colors[1] and
                rotated[0][6] == colors[2] and rotated[0][7] == colors[2] and
                rotated[0][9] == colors[3] and rotated[0][10] == colors[3]):
                base = rotated
                break
    if base is None:
        base = input_grid
    
    output_grid = [row[:] for row in base]
    tip_r, tip_c = 3, 3
    dr, dc = 1, 1
    color_seq = [3, 4, 5, 6]
    idx = 0
    r, c = tip_r, tip_c
    height = len(base)
    width = len(base[0])
    
    while True:
        nr, nc = r + dr, c + dc
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        if base[nr][nc] != 0:
            output_grid[r][c] = color_seq[idx]
            idx = (idx + 1) % len(color_seq)
            dr, dc = -dr, dc
            r, c = nr, nc
        else:
            output_grid[r][c] = color_seq[idx]
            idx = (idx + 1) % len(color_seq)
            r, c = nr, nc
    return output_grid
