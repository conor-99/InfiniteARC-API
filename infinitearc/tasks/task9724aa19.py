# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 9724aa19
Difficulty: mediumâ€“hard

=== Tags ===
- Rule transfer between regions
- Gate chain construction
- Bridges
- Connect two dots with a line
- Mark centroid

=== Description ===
Input grids feature two distinct regions (each a contiguous block of a single
non-background color), each containing a centroid marker (a single cell of a
unique color, such as pink, positioned at the region's geometric center). Within
each region, a start (red) and end (blue) dot are placed, with the start dot
located in the first region and the end dot in the second region. The output
grid must draw a straight line (using a specific color, such as yellow)
connecting the start dot to the end dot, passing through both centroid markers.
The line is drawn exclusively on background cells, and all markers (dots and
centroids) remain visible in the output. The line's direction (horizontal,
vertical, or diagonal) is determined by the colinear alignment of the start dot,
both centroids, and the end dot as present in the input.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    grid = [[0] * width for _ in range(height)]
    
    r = random.randint(2, height - 3)
    c = random.randint(2, width - 7)
    
    # Generate region1 (top row of centroid1)
    for dc in range(-1, 2):
        nr, nc = r - 1, c + 2 + dc
        if 0 <= nr < height and 0 <= nc < width:
            grid[nr][nc] = 3
    
    # Generate region2 (bottom row of centroid2)
    for dc in range(-1, 2):
        nr, nc = r + 1, c + 4 + dc
        if 0 <= nr < height and 0 <= nc < width:
            grid[nr][nc] = 4
    
    # Set points
    grid[r][c] = 2  # start
    grid[r][c + 2] = 6  # centroid1
    grid[r][c + 4] = 6  # centroid2
    grid[r][c + 6] = 1  # end
    
    output = [row[:] for row in grid]
    for col in [c + 1, c + 3, c + 5]:
        output[r][col] = 4
    
    return {
        'input': grid,
        'output': output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    red_pos = None
    blue_pos = None
    pink_positions = []
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 2:
                red_pos = (r, c)
            elif grid[r][c] == 1:
                blue_pos = (r, c)
            elif grid[r][c] == 6:
                pink_positions.append((r, c))
    
    if len(pink_positions) != 2:
        return grid
    
    centroid1, centroid2 = pink_positions
    
    # Determine order along the line from red to blue
    dr = blue_pos[0] - red_pos[0]
    dc = blue_pos[1] - red_pos[1]
    
    if dr == 0:
        if dc > 0:
            if centroid1[1] < centroid2[1]:
                order = [red_pos, centroid1, centroid2, blue_pos]
            else:
                order = [red_pos, centroid2, centroid1, blue_pos]
        else:
            if centroid1[1] > centroid2[1]:
                order = [red_pos, centroid1, centroid2, blue_pos]
            else:
                order = [red_pos, centroid2, centroid1, blue_pos]
    elif dc == 0:
        if dr > 0:
            if centroid1[0] < centroid2[0]:
                order = [red_pos, centroid1, centroid2, blue_pos]
            else:
                order = [red_pos, centroid2, centroid1, blue_pos]
        else:
            if centroid1[0] > centroid2[0]:
                order = [red_pos, centroid1, centroid2, blue_pos]
            else:
                order = [red_pos, centroid2, centroid1, blue_pos]
    else:
        # Diagonal case: sort by distance from red
        dist1 = abs(centroid1[0] - red_pos[0]) + abs(centroid1[1] - red_pos[1])
        dist2 = abs(centroid2[0] - red_pos[0]) + abs(centroid2[1] - red_pos[1])
        if dist1 < dist2:
            order = [red_pos, centroid1, centroid2, blue_pos]
        else:
            order = [red_pos, centroid2, centroid1, blue_pos]
    
    # Draw line segments between consecutive points
    for i in range(1, len(order)):
        start = order[i-1]
        end = order[i]
        
        if start[0] == end[0]:  # Horizontal
            for c in range(min(start[1], end[1]) + 1, max(start[1], end[1])):
                if grid[start[0]][c] == 0:
                    grid[start[0]][c] = 4
        elif start[1] == end[1]:  # Vertical
            for r in range(min(start[0], end[0]) + 1, max(start[0], end[0])):
                if grid[r][start[1]] == 0:
                    grid[r][start[1]] = 4
        else:  # Diagonal (slope 1 or -1)
            dr = 1 if end[0] > start[0] else -1
            dc = 1 if end[1] > start[1] else -1
            r, c = start[0] + dr, start[1] + dc
            while (r, c) != end:
                if grid[r][c] == 0:
                    grid[r][c] = 4
                r += dr
                c += dc
    
    return grid
