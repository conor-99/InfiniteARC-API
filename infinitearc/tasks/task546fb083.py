# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 546fb083
Difficulty: very hard

=== Tags ===
- Draw pattern from point
- Connect equal color components

=== Description ===
The input grid features a background color (0) with multiple disjoint regions of
colors 1-9, each region being a maximal connected component (4-connected) of a
single non-background color. Each region has a designated "start" cell, defined
as the topmost-leftmost cell within that region. The output grid must connect
all regions of the same color by drawing horizontal or vertical lines through
background cells (0) between their start cells. For each color, the lines must
form a single connected spanning structure that links all start points, adhering
to these rules: lines must follow the shortest Manhattan path (avoiding non-
background cells), detour around obstacles (other regions) using the minimal
possible path around them, and remain entirely within background cells. The line
color must match the region color, and no lines may overlap with existing
regions or with lines from other colors. The pattern is drawn exclusively on
background cells, preserving all original regions and their positions. The
transformation requires identifying connected components, determining start
cells, computing obstacle-avoiding paths, and drawing the lines without
conflictsâ€”combining spatial reasoning, pathfinding, and constraint satisfaction
in a single cohesive process.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque

# neighbor order consistent for generator and solver
NEIGHBORS = [(0,1),(1,0),(0,-1),(-1,0)]

def find_path(start, end, grid):
    h = len(grid)
    w = len(grid[0])
    sr, sc = start
    er, ec = end
    # BFS that can start from a non-zero start cell and may step into end even if it's non-zero,
    # but otherwise only traverses background cells (0).
    queue = deque()
    queue.append((sr, sc))
    visited = set()
    visited.add((sr, sc))
    parent = {}
    while queue:
        r, c = queue.popleft()
        if (r, c) == (er, ec):
            break
        for dr, dc in NEIGHBORS:
            nr, nc = r + dr, c + dc
            if not (0 <= nr < h and 0 <= nc < w): 
                continue
            if (nr, nc) in visited:
                continue
            # can move into background cells, or into the end cell even if non-background
            if grid[nr][nc] == 0 or (nr, nc) == (er, ec):
                visited.add((nr, nc))
                parent[(nr, nc)] = (r, c)
                queue.append((nr, nc))
    if (er, ec) not in visited:
        return None
    # reconstruct path from end to start
    path = []
    cur = (er, ec)
    while True:
        path.append(cur)
        if cur == (sr, sc):
            break
        cur = parent.get(cur)
        if cur is None:
            return None
    path.reverse()
    return path

def generate():
    # Try generating until a valid configuration is created
    for attempt in range(1000):
        width = random.randint(8, 20)
        height = random.randint(8, 20)
        grid = [[0 for _ in range(width)] for _ in range(height)]
        occupied = set()  # cells taken by regions (non-background)
        # choose how many colors to include
        num_colors = random.randint(3, min(7, 9))
        colors = random.sample(list(range(1, 10)), num_colors)
        # choose connector rows for each color (distinct)
        possible_rows = list(range(1, height - 1))
        if len(possible_rows) < num_colors:
            continue
        connector_rows = random.sample(possible_rows, num_colors)
        color_to_row = {c: r for c, r in zip(colors, connector_rows)}
        regions = []  # list of (color, pixels_list)
        generation_failed = False

        # ensure at least one color will have multiple regions
        must_force_multi = True

        for color in colors:
            # decide number of separate regions for this color
            if must_force_multi:
                # give a good chance the first chosen color will have multiple regions
                num_regions = random.choice([2, 2, 3])
                must_force_multi = False
            else:
                num_regions = random.choices([1, 2, 3], weights=[0.6, 0.3, 0.1])[0]
            # limit by width to make spacing possible
            max_regions_supported = max(1, width // 4)
            num_regions = min(num_regions, max_regions_supported)
            row = color_to_row[color]

            # pick anchor columns for the regions on that row, ensuring separation
            chosen_cols = []
            tries = 0
            while len(chosen_cols) < num_regions and tries < 300:
                tries += 1
                col = random.randint(1, width - 2)  # avoid edges to leave breathing room
                # ensure not too close to other anchors of same color
                if any(abs(col - c) < 3 for c in chosen_cols):
                    continue
                # ensure that the 3x3 neighborhood around the anchor is free of other regions
                conflict = False
                for rr in range(row - 1, row + 2):
                    for cc in range(col - 1, col + 2):
                        if 0 <= rr < height and 0 <= cc < width and (rr, cc) in occupied:
                            conflict = True
                            break
                    if conflict:
                        break
                if conflict:
                    continue
                chosen_cols.append(col)
            if len(chosen_cols) < num_regions:
                generation_failed = True
                break

            # create small connected region for each anchor; expansions only go down so
            # that the anchor remains the topmost-leftmost pixel (the designated start cell)
            # and the horizontal corridor on that row remains free for drawing straight lines.
            for col in chosen_cols:
                size = random.randint(1, 4)
                pixels = set()
                pixels.add((row, col))
                expansion_tries = 0
                while len(pixels) < size and expansion_tries < 50:
                    expansion_tries += 1
                    base = random.choice(list(pixels))
                    # only expand down to preserve the anchor as top-leftmost and keep row clear
                    dr, dc = (1, 0)
                    nr, nc = base[0] + dr, base[1] + dc
                    if not (0 <= nr < height and 0 <= nc < width):
                        continue
                    # ensure candidate's 3x3 neighborhood does not touch already occupied cells
                    conflict = False
                    for rr in range(nr - 1, nr + 2):
                        for cc in range(nc - 1, nc + 2):
                            if 0 <= rr < height and 0 <= cc < width and (rr, cc) in occupied:
                                conflict = True
                                break
                        if conflict:
                            break
                    if conflict:
                        continue
                    pixels.add((nr, nc))
                # commit pixels to grid
                for (rr, cc) in pixels:
                    grid[rr][cc] = color
                    occupied.add((rr, cc))
                regions.append((color, list(pixels)))
        if generation_failed:
            continue

        # compute top-leftmost start cell for each region
        start_cells = {}
        for color, pixels in regions:
            st = min(pixels, key=lambda x: (x[0], x[1]))
            start_cells.setdefault(color, []).append(st)

        # require at least one color with multiple regions (so a connection is needed)
        if not any(len(v) > 1 for v in start_cells.values()):
            continue

        # build the output by connecting start cells for each color (in sorted color order)
        output = [row[:] for row in grid]
        ok = True
        for color in sorted(start_cells.keys()):
            starts = sorted(start_cells[color], key=lambda x: (x[0], x[1]))
            if len(starts) < 2:
                continue
            for i in range(len(starts) - 1):
                s = starts[i]
                e = starts[i + 1]
                path = find_path(s, e, output)
                if path is None:
                    ok = False
                    break
                for (rr, cc) in path:
                    # only paint background cells
                    if output[rr][cc] == 0:
                        output[rr][cc] = color
            if not ok:
                break
        if not ok:
            continue

        # ensure the output is different from the input
        if all(output[r][c] == grid[r][c] for r in range(height) for c in range(width)):
            continue

        return {"input": [row[:] for row in grid], "output": output}
    # fallback - should not normally happen
    raise RuntimeError("Failed to generate a valid task after many attempts")



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

NEIGHBORS = [(0,1),(1,0),(0,-1),(-1,0)]

def find_path(start, end, grid):
    h = len(grid)
    w = len(grid[0])
    sr, sc = start
    er, ec = end
    queue = deque()
    queue.append((sr, sc))
    visited = set()
    visited.add((sr, sc))
    parent = {}
    while queue:
        r, c = queue.popleft()
        if (r, c) == (er, ec):
            break
        for dr, dc in NEIGHBORS:
            nr, nc = r + dr, c + dc
            if not (0 <= nr < h and 0 <= nc < w):
                continue
            if (nr, nc) in visited:
                continue
            if grid[nr][nc] == 0 or (nr, nc) == (er, ec):
                visited.add((nr, nc))
                parent[(nr, nc)] = (r, c)
                queue.append((nr, nc))
    if (er, ec) not in visited:
        return None
    path = []
    cur = (er, ec)
    while True:
        path.append(cur)
        if cur == (sr, sc):
            break
        cur = parent.get(cur)
        if cur is None:
            return None
    path.reverse()
    return path

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    visited = [[False] * width for _ in range(height)]
    components = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and not visited[r][c]:
                color = grid[r][c]
                # BFS to collect the full connected component (4-connected)
                queue = [(r, c)]
                visited[r][c] = True
                pixels = []
                qi = 0
                while qi < len(queue):
                    cr, cc = queue[qi]
                    qi += 1
                    pixels.append((cr, cc))
                    for dr, dc in NEIGHBORS:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                components.append((color, pixels))
    # determine the topmost-leftmost start cell for each component
    start_cells = {}
    for color, pixels in components:
        start = min(pixels, key=lambda x: (x[0], x[1]))
        start_cells.setdefault(color, []).append(start)
    # draw connecting lines on a copy of the grid, avoiding non-background cells and previously drawn lines
    output = [row[:] for row in grid]
    for color in sorted(start_cells.keys()):
        starts = sorted(start_cells[color], key=lambda x: (x[0], x[1]))
        if len(starts) < 2:
            continue
        for i in range(len(starts) - 1):
            s = starts[i]
            e = starts[i + 1]
            path = find_path(s, e, output)
            if path is None:
                # if no path exists, skip (generator ensures path exists)
                continue
            for rr, cc in path:
                if output[rr][cc] == 0:
                    output[rr][cc] = color
    return tuple(tuple(row) for row in output)

