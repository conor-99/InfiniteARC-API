# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 3375603a
Difficulty: hard

=== Tags ===
- Pairwise rule matching
- Pattern expansion
- Permute columns by length
- Draw line from border

=== Description ===
**Task Name:** Segmented Column Alignment    **Input Grid Characteristics:**
Input grids are rectangular (width 3–30, height 5–30) with a single background
color (0). Each column contains one or more contiguous vertical segments of non-
background colors (1–9), separated by background (0). Segments are non-
overlapping and separated by at least one background cell. The topmost segment
in each column is the first non-background segment encountered when scanning
from the top of the column.    **Transformation Rules:**   1. **Column
Permutation:** Columns are reordered based on the length of their *longest
contiguous vertical segment* (e.g., a segment of color 3 spanning 4 rows has
length 4). Columns are sorted in *descending order* of this length. If two
columns share the same longest segment length, their original left-to-right
order is preserved.   2. **Line Drawing:** After permutation, for each column:
- The *number of segments* (k) in the column is determined (e.g., a column with
two segments has k=2).      - The *line color* is the color of the topmost
segment in the column.      - For columns positioned in the *left half* of the
grid (columns 0 to floor(width/2)−1), a horizontal line is drawn from the *left
border* (left edge of the grid) to the right, spanning *k cells* in the *top
row* (row 0). The line is drawn *only on background cells (0)* and uses the
topmost segment color.      - For columns positioned in the *right half*
(columns floor(width/2) to width−1), a horizontal line is drawn from the *right
border* (right edge of the grid) to the left, spanning *k cells* in the *top
row* (row 0), over background cells only.      - Lines *do not overwrite*
existing non-background segments or other lines.    **Output Grid:**   -
Identical to the input except for the reordered columns and the added horizontal
lines in the top row.   - The top row (row 0) may contain new non-background
values (matching the top segment color) where background cells were overwritten
by the lines.   - All non-background segments in the input (except those in row
0) remain unchanged.   - No lines overlap with existing segments or other lines.
**Key Complexity:**   - Requires identifying segments, comparing segment lengths
across columns, reordering columns, and precisely drawing lines in the top row
based on segment counts and colors.   - The line-drawing step depends on the
grid’s width (left/right half division) and must avoid overwriting non-
background cells.   - Multiple rules interact sequentially (permutation → line
drawing), demanding compositional reasoning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(3, 30)
    height = random.randint(5, 30)
    grid = [[0] * width for _ in range(height)]

    for c in range(width):
        num_segments = random.randint(1, 3)
        current_row = 1
        segments = []
        for _ in range(num_segments):
            color = random.randint(1, 9)
            length = random.randint(1, 3)
            if current_row + length > height:
                length = height - current_row
            for r in range(current_row, current_row + length):
                grid[r][c] = color
            segments.append((color, length))
            current_row += length + 1
            if current_row >= height:
                break

    col_info = []
    for c in range(width):
        top_color = None
        max_length = 0
        current_length = 0
        for r in range(height):
            if grid[r][c] != 0:
                if top_color is None:
                    top_color = grid[r][c]
                current_length += 1
            else:
                if current_length > max_length:
                    max_length = current_length
                current_length = 0
        if current_length > max_length:
            max_length = current_length
        num_segments = 0
        in_segment = False
        for r in range(height):
            if grid[r][c] != 0:
                if not in_segment:
                    num_segments += 1
                    in_segment = True
            else:
                in_segment = False
        col_info.append((max_length, num_segments, top_color))

    sorted_indices = sorted(range(width), key=lambda c: -col_info[c][0])
    sorted_grid = [[0] * width for _ in range(height)]
    for new_col, old_col in enumerate(sorted_indices):
        for r in range(height):
            sorted_grid[r][new_col] = grid[r][old_col]

    for new_col in range(width):
        max_length, num_segments, top_color = col_info[sorted_indices[new_col]]
        k = num_segments
        if new_col < width // 2:
            start_col = new_col
            end_col = new_col + k - 1
        else:
            start_col = new_col - k + 1
            end_col = new_col
        start_col = max(0, start_col)
        end_col = min(width - 1, end_col)
        for c in range(start_col, end_col + 1):
            if sorted_grid[0][c] == 0:
                sorted_grid[0][c] = top_color

    return {
        "input": grid,
        "output": sorted_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    col_info = []
    for c in range(width):
        top_color = None
        max_length = 0
        current_length = 0
        for r in range(height):
            if grid[r][c] != 0:
                if top_color is None:
                    top_color = grid[r][c]
                current_length += 1
            else:
                if current_length > max_length:
                    max_length = current_length
                current_length = 0
        if current_length > max_length:
            max_length = current_length
        num_segments = 0
        in_segment = False
        for r in range(height):
            if grid[r][c] != 0:
                if not in_segment:
                    num_segments += 1
                    in_segment = True
            else:
                in_segment = False
        col_info.append((max_length, num_segments, top_color))

    sorted_indices = sorted(range(width), key=lambda c: -col_info[c][0])
    sorted_grid = [[0] * width for _ in range(height)]
    for new_col, old_col in enumerate(sorted_indices):
        for r in range(height):
            sorted_grid[r][new_col] = grid[r][old_col]

    for new_col in range(width):
        max_length, num_segments, top_color = col_info[sorted_indices[new_col]]
        k = num_segments
        if new_col < width // 2:
            start_col = new_col
            end_col = new_col + k - 1
        else:
            start_col = new_col - k + 1
            end_col = new_col
        start_col = max(0, start_col)
        end_col = min(width - 1, end_col)
        for c in range(start_col, end_col + 1):
            if sorted_grid[0][c] == 0:
                sorted_grid[0][c] = top_color

    return sorted_grid
