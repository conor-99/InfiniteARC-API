# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: cea8b05b
Difficulty: hard

=== Tags ===
- Obstacles
- Token following
- Associate colors to colors
- Staircase construction

=== Description ===
Input grids consist of a 2D grid with a background color (0), colored obstacles
(1-9) arranged as vertical or horizontal walls, and a single token (color 4)
starting at the left edge moving right. Obstacles are solid blocks of uniform
color with no gaps, never touching each other or the token. The token follows a
deterministic path: it moves orthogonally in its current direction until hitting
an obstacle cell. Upon collision:  1. **Obstacle orientation determines
direction change**: Vertical obstacles (cells spanning multiple rows in a
column) cause a 90° turn toward the top (e.g., right → up), while horizontal
obstacles (cells spanning multiple columns in a row) cause a 90° turn toward the
right (e.g., up → right). 2. **Color association updates the token's color**:
Each obstacle color (C) maps to a unique output color (D) via a fixed, hidden
rule (e.g., obstacle color 2 → output color 7). 3. **Path drawing**: The token's
path is drawn over the background as a continuous line in its current color,
with each segment between obstacles drawn in the mapped color (D) corresponding
to the obstacle that caused the turn.  The output grid retains all original
obstacles and displays the token's path as a staircase pattern, where: - Each
"step" corresponds to a segment of the path between two consecutive obstacle
collisions. - The color of each step matches the mapped color (D) of the
obstacle that triggered the direction change. - The staircase forms a visually
distinct pattern due to alternating direction changes and color mappings, with
no overlapping paths or self-intersections.  - Unused colors (e.g., background,
token's original color) are never used for the path, and all obstacles remain
unchanged in the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    grid = common.grid(width, height, 0)
    
    # Token start (color 4) at left edge, not on top/bottom edges
    start_row = random.randint(1, height-2)
    grid[start_row][0] = 4
    
    # Obstacle colors (exclude 0 and 4)
    obstacle_colors = [1, 2, 3, 5, 6, 7, 8, 9]
    mapping = {1: 5, 2: 7, 3: 9, 5: 2, 6: 4, 7: 1, 8: 3, 9: 6}
    
    # Place 3-5 obstacles
    for _ in range(random.randint(3, 5)):
        is_vertical = random.choice([True, False])
        color = random.choice(obstacle_colors)
        
        if is_vertical:
            c = random.randint(2, width-2)
            r_start = random.randint(1, height-3)
            r_end = r_start + random.randint(1, 2)
            for r in range(r_start, r_end+1):
                grid[r][c] = color
        else:
            r = random.randint(2, height-2)
            c_start = random.randint(2, width-3)
            c_end = c_start + random.randint(1, 2)
            for c in range(c_start, c_end+1):
                grid[r][c] = color
    
    # Simulate token path
    output_grid = [row[:] for row in grid]
    pos = (start_row, 0)
    dir = (0, 1)  # right
    current_color = 4
    
    while True:
        next_pos = (pos[0] + dir[0], pos[1] + dir[1])
        if not (0 <= next_pos[0] < height and 0 <= next_pos[1] < width):
            break
        
        if grid[next_pos[0]][next_pos[1]] != 0:
            # Hit obstacle
            obstacle_color = grid[next_pos[0]][next_pos[1]]
            # Determine orientation
            is_vertical = (next_pos[0] > 0 and grid[next_pos[0]-1][next_pos[1]] != 0) or (next_pos[0] < height-1 and grid[next_pos[0]+1][next_pos[1]] != 0)
            
            # Update direction
            if is_vertical:
                if dir == (0, 1): dir = (-1, 0)
                elif dir == (-1, 0): dir = (0, -1)
                elif dir == (0, -1): dir = (1, 0)
                elif dir == (1, 0): dir = (0, 1)
            else:
                if dir == (0, 1): dir = (1, 0)
                elif dir == (1, 0): dir = (0, -1)
                elif dir == (0, -1): dir = (-1, 0)
                elif dir == (-1, 0): dir = (0, 1)
            
            # Update color
            current_color = mapping[obstacle_color]
            
        else:
            # Draw path in current color
            output_grid[next_pos[0]][next_pos[1]] = current_color
            pos = next_pos
    
    return {
        'input': grid,
        'output': output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    grid = [list(row) for row in input_grid]
    
    # Find token position (color 4) on left edge
    start_row = None
    for r in range(height):
        if grid[r][0] == 4:
            start_row = r
            break
    
    if start_row is None:
        return grid
    
    # Fixed mapping
    mapping = {1: 5, 2: 7, 3: 9, 5: 2, 6: 4, 7: 1, 8: 3, 9: 6}
    
    # Simulate path
    pos = (start_row, 0)
    dir = (0, 1)  # right
    current_color = 4
    output_grid = [row[:] for row in grid]
    
    while True:
        next_pos = (pos[0] + dir[0], pos[1] + dir[1])
        if not (0 <= next_pos[0] < height and 0 <= next_pos[1] < width):
            break
        
        if grid[next_pos[0]][next_pos[1]] != 0:
            obstacle_color = grid[next_pos[0]][next_pos[1]]
            is_vertical = (next_pos[0] > 0 and grid[next_pos[0]-1][next_pos[1]] != 0) or (next_pos[0] < height-1 and grid[next_pos[0]+1][next_pos[1]] != 0)
            
            if is_vertical:
                if dir == (0, 1): dir = (-1, 0)
                elif dir == (-1, 0): dir = (0, -1)
                elif dir == (0, -1): dir = (1, 0)
                elif dir == (1, 0): dir = (0, 1)
            else:
                if dir == (0, 1): dir = (1, 0)
                elif dir == (1, 0): dir = (0, -1)
                elif dir == (0, -1): dir = (-1, 0)
                elif dir == (-1, 0): dir = (0, 1)
            
            current_color = mapping[obstacle_color]
        else:
            output_grid[next_pos[0]][next_pos[1]] = current_color
            pos = next_pos
    
    return output_grid
