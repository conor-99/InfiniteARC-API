# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: a2f0769e
Difficulty: medium

=== Tags ===
- Associate images to bools
- Color palette
- Carve negative space
- Contour thickening

=== Description ===
The task transforms input grids by identifying the background (color 0), carving
this negative space into a new foreground shape, and thickening its contour. The
transformation applies a consistent rule: for every cell in the input grid, if
the cell is background (0) or adjacent (up/down/left/right) to a background
cell, it is replaced with color 5 (blue). All other cells retain their original
color. This creates a thickened boundary around the negative space, where the
background region expands to include its immediate neighbors. The color palette
uses 5 to represent the carved negative space, and the rule is discoverable
through visual pattern recognition of background adjacency and expansion. For
example, a single non-background cell surrounded by background becomes entirely
blue (color 5) in the output, while inner regions not adjacent to background
remain unchanged.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    width = common.randint(1, 30)
    height = common.randint(1, 30)
    input_grid = common.grid(width, height, 0)
    pixels = []
    while not pixels:
        pixels = common.random_pixels(width, height, 0.5)
    for r, c in pixels:
        input_grid[r][c] = common.random_color(exclude=[0])
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                output_grid[r][c] = 5
            else:
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 0:
                        output_grid[r][c] = 5
                        break
                else:
                    output_grid[r][c] = input_grid[r][c]
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                output_grid[r][c] = 5
            else:
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 0:
                        output_grid[r][c] = 5
                        break
                else:
                    output_grid[r][c] = input_grid[r][c]
    return output_grid
