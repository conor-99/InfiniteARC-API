# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: cafc9cc3
Difficulty: insane

=== Tags ===
- Loopless feedback
- Detect connectedness
- Select every nth row

=== Description ===
Input grids are large (20×20 to 30×30) with a background color (0). Non-
background cells (1–9) form multiple 4-connected regions of uniform color, where
each region consists of adjacent cells sharing the same color (4-adjacency
only). The task requires detecting the largest connected region in terms of cell
count (ignoring background). The size of this region, denoted L, determines the
row selection interval for the output grid. The output consists of every L-th
row from the input grid (starting at row 0), preserving all columns and colors.
For example, if L=7, the output includes rows 0, 7, 14, 21, etc. The output grid
is always visually distinct from the input due to the reduced row count, with no
overlapping regions or background cells in the selected rows. This
transformation requires precise connected component analysis followed by
deterministic row selection based on a visual property (region size), making it
challenging to identify the correct L without exhaustive region scanning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_color

def generate():
    """
    Generate a grid (width w, height h) with background 0 and several 4-connected
    regions (each region uniform in color 1-9). The largest connected region by
    cell count determines L (the number of rows to skip). The output grid is
    every L-th row from the input (rows 0, L, 2L, ...).

    Constraints enforced:
    - h and w are between 20 and 30
    - at least one region has size >= 2 (so L >= 2 and output is different from input)
    - regions are 4-connected and non-overlapping
    - regions use colors 1..9 (unique per region until exhausted)
    """
    h = random.randint(20, 30)
    w = random.randint(20, 30)

    # Target number of regions (keep <= 9 so we can use distinct colors easily)
    region_count = random.randint(3, 7)
    region_count = min(region_count, 9)

    # Initial blank grid
    ingrid = grid(w, h, 0)

    # Helper: neighbors (4-adjacency)
    def neigh(r, c):
        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
            nr, nc = r + dr, c + dc
            if 0 <= nr < h and 0 <= nc < w:
                yield (nr, nc)

    # Grow a connected region starting from a random free seed up to target_size
    def grow_region(target_size, occupied):
        all_free = [(r, c) for r in range(h) for c in range(w) if (r, c) not in occupied]
        if not all_free:
            return set()
        # Try a few different seeds if a particular seed gets stuck
        tries = 0
        while tries < 50:
            tries += 1
            seed = random.choice(all_free)
            region = {seed}
            frontier = set(n for n in neigh(*seed) if n not in occupied)
            # Expand until we reach target_size or run out of frontier
            while len(region) < target_size and frontier:
                cell = random.choice(list(frontier))
                frontier.remove(cell)
                region.add(cell)
                # add new neighbors to frontier
                for n in neigh(*cell):
                    if n in occupied or n in region:
                        continue
                    frontier.add(n)
            # If we got at least 1 pixel it's a valid connected region
            if len(region) > 0:
                return region
        return set()

    occupied = set()
    used_colors = []

    # Choose a desired size for the largest region (at least 2 to ensure L>=2)
    desired_L = random.randint(2, max(2, min(h - 1, 12)))

    # Build the largest region first to avoid collisions
    largest_region = grow_region(desired_L, occupied)
    # If for some reason growth failed to reach desired_L, accept what we got
    # (we will recompute the actual largest size before slicing)
    if not largest_region:
        # fallback: force a tiny region of size 2 somewhere
        for r in range(h):
            for c in range(w):
                if (r, c) not in occupied:
                    largest_region = {(r, c)}
                    break
            if largest_region:
                break

    color = random_color(exclude=[0])
    used_colors.append(color)
    for (r, c) in largest_region:
        ingrid[r][c] = color
        occupied.add((r, c))

    # Create other regions with sizes strictly smaller than the desired_L (so largest is unique)
    for _ in range(region_count - 1):
        max_size = max(1, (desired_L - 1))
        size = random.randint(1, max_size)
        region = grow_region(size, occupied)
        if not region:
            continue
        # pick a color not used yet if possible
        choices = [col for col in range(1, 10) if col not in used_colors]
        if not choices:
            choices = list(range(1, 10))
        col = random.choice(choices)
        used_colors.append(col)
        for (r, c) in region:
            ingrid[r][c] = col
            occupied.add((r, c))

    # After placement, compute the actual largest connected component size
    # (4-connected, same color) to determine the true L used for slicing.
    from collections import deque
    visited = [[False] * w for _ in range(h)]
    def actual_max_component():
        max_sz = 0
        for r in range(h):
            for c in range(w):
                if ingrid[r][c] == 0 or visited[r][c]:
                    continue
                color_here = ingrid[r][c]
                q = deque([(r, c)])
                visited[r][c] = True
                cnt = 0
                while q:
                    cr, cc = q.popleft()
                    cnt += 1
                    for nr, nc in neigh(cr, cc):
                        if not visited[nr][nc] and ingrid[nr][nc] == color_here:
                            visited[nr][nc] = True
                            q.append((nr, nc))
                if cnt > max_sz:
                    max_sz = cnt
        return max_sz

    L = actual_max_component()
    # Ensure L >= 2 (if something went wrong and L==1, try to enlarge the largest region)
    if L < 2:
        # Find a pixel and add one neighbor of same color
        found = False
        for r in range(h):
            for c in range(w):
                if ingrid[r][c] != 0:
                    for nr, nc in neigh(r, c):
                        if ingrid[nr][nc] == 0:
                            ingrid[nr][nc] = ingrid[r][c]
                            found = True
                            break
                if found:
                    break
            if found:
                break
        # recompute L
        visited = [[False] * w for _ in range(h)]
        L = actual_max_component()
        if L < 2:
            # As a last resort set L = 2
            L = 2

    # Build the output as every L-th row (0, L, 2L ...)
    output_grid = [row[:] for row in ingrid[::L]]

    return {
        "input": ingrid,
        "output": output_grid
    }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    # Convert tuple-of-tuples (or other immutables) to a mutable list-of-lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0]) if h > 0 else 0

    visited = [[False] * w for _ in range(h)]
    max_size = 0

    # 4-adjacency neighbors
    def neighbors(r, c):
        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
            nr, nc = r + dr, c + dc
            if 0 <= nr < h and 0 <= nc < w:
                yield nr, nc

    for r in range(h):
        for c in range(w):
            if grid[r][c] == 0 or visited[r][c]:
                continue
            color = grid[r][c]
            q = deque([(r, c)])
            visited[r][c] = True
            cnt = 0
            while q:
                cr, cc = q.popleft()
                cnt += 1
                for nr, nc in neighbors(cr, cc):
                    if not visited[nr][nc] and grid[nr][nc] == color:
                        visited[nr][nc] = True
                        q.append((nr, nc))
            if cnt > max_size:
                max_size = cnt

    # If no non-zero pixels, default to 1 to avoid step of 0 (but such input shouldn't occur)
    if max_size <= 0:
        max_size = 1

    L = max_size
    # Return every L-th row starting at 0
    output = [row[:] for row in grid[::L]]
    return output

