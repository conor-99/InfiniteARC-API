# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: aec28ebc
Difficulty: hard

=== Tags ===
- Constraint satisfaction coloring
- Line decay

=== Description ===
Input grids consist of a single background color (0) and multiple colored lines
(each line is a contiguous path of a single color, 1-9), extending across the
grid from boundary start points to endpoints. Lines may cross but do not
overlap; adjacent cells of different lines may share the same color in the
input. Each line has a clear directional start point (e.g., left edge for
horizontal lines, top edge for vertical lines).  The output grid transforms each
line through a dual-process rule: 1. **Line decay**: Each cell along a line is
assigned a color decreasing by 1 for each step from the start point (e.g., start
color C → C-1 → C-2), clamped to a minimum of 1 (never reaching background color
0). 2. **Constraint satisfaction**: If assigning a color would cause adjacency
conflict (same color as horizontal/vertical neighbor, including other lines or
background), the color is decremented further until a valid color (non-
conflicting with all adjacent cells) is found.  The transformation applies
simultaneously to all lines, ensuring the output grid satisfies strict adjacency
constraints: no two horizontally or vertically adjacent cells share the same
color (background remains color 0). This requires careful parallel evaluation of
decay steps and conflict resolution at all intersection points, with the output
reflecting the minimal valid color sequence for each line under the decay rule.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])
    output = [[0] * w for _ in range(h)]
    
    visited = [[False] * w for _ in range(h)]
    lines = []
    
    for r in range(h):
        for c in range(w):
            if grid[r][c] != 0 and not visited[r][c]:
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < h and 0 <= nc < w and grid[nr][nc] != 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                edge_cells = [cell for cell in component if cell[0] == 0 or cell[0] == h-1 or cell[1] == 0 or cell[1] == w-1]
                if not edge_cells:
                    continue
                start_cell = min(edge_cells, key=lambda x: (x[0], x[1]))
                dist = {}
                queue = [start_cell]
                dist[start_cell] = 0
                while queue:
                    cr, cc = queue.pop(0)
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if (nr, nc) in component and (nr, nc) not in dist:
                            dist[(nr, nc)] = dist[(cr, cc)] + 1
                            queue.append((nr, nc))
                color = grid[start_cell[0]][start_cell[1]]
                lines.append((start_cell, color, dist))
    
    for r in range(h):
        for c in range(w):
            if grid[r][c] != 0:
                for start_cell, color, dist in lines:
                    if (r, c) in dist:
                        steps = dist[(r, c)]
                        initial_color = color - steps
                        if initial_color < 1:
                            initial_color = 1
                        current_color = initial_color
                        while current_color >= 1:
                            conflict = False
                            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                                nr, nc = r + dr, c + dc
                                if 0 <= nr < h and 0 <= nc < w and output[nr][nc] == current_color:
                                    conflict = True
                                    break
                            if not conflict:
                                output[r][c] = current_color
                                break
                            current_color -= 1
                        if current_color < 1:
                            output[r][c] = 1
                        break
    return output

def generate():
    import random
    w = random.randint(1, 30)
    h = random.randint(1, 30)
    grid = [[0] * w for _ in range(h)]
    
    for _ in range(random.randint(1, 5)):
        edge = random.choice(['left', 'right', 'top', 'bottom'])
        if edge == 'left':
            r = random.randint(0, h-1)
            L = random.randint(1, min(w, 9))
            C = L
            for c in range(L):
                if grid[r][c] != 0:
                    continue
                grid[r][c] = C
        elif edge == 'right':
            r = random.randint(0, h-1)
            L = random.randint(1, min(w, 9))
            C = L
            start_col = w - L
            for c in range(start_col, w):
                if grid[r][c] != 0:
                    continue
                grid[r][c] = C
        elif edge == 'top':
            c = random.randint(0, w-1)
            L = random.randint(1, min(h, 9))
            C = L
            for r in range(L):
                if grid[r][c] != 0:
                    continue
                grid[r][c] = C
        elif edge == 'bottom':
            c = random.randint(0, w-1)
            L = random.randint(1, min(h, 9))
            C = L
            start_row = h - L
            for r in range(start_row, h):
                if grid[r][c] != 0:
                    continue
                grid[r][c] = C
    
    output_grid = p(grid)
    return {"input": grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])
    output = [[0] * w for _ in range(h)]
    
    visited = [[False] * w for _ in range(h)]
    lines = []
    
    for r in range(h):
        for c in range(w):
            if grid[r][c] != 0 and not visited[r][c]:
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < h and 0 <= nc < w and grid[nr][nc] != 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                edge_cells = [cell for cell in component if cell[0] == 0 or cell[0] == h-1 or cell[1] == 0 or cell[1] == w-1]
                if not edge_cells:
                    continue
                start_cell = min(edge_cells, key=lambda x: (x[0], x[1]))
                dist = {}
                queue = [start_cell]
                dist[start_cell] = 0
                while queue:
                    cr, cc = queue.pop(0)
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if (nr, nc) in component and (nr, nc) not in dist:
                            dist[(nr, nc)] = dist[(cr, cc)] + 1
                            queue.append((nr, nc))
                color = grid[start_cell[0]][start_cell[1]]
                lines.append((start_cell, color, dist))
    
    for r in range(h):
        for c in range(w):
            if grid[r][c] != 0:
                for start_cell, color, dist in lines:
                    if (r, c) in dist:
                        steps = dist[(r, c)]
                        initial_color = color - steps
                        if initial_color < 1:
                            initial_color = 1
                        current_color = initial_color
                        while current_color >= 1:
                            conflict = False
                            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                                nr, nc = r + dr, c + dc
                                if 0 <= nr < h and 0 <= nc < w and output[nr][nc] == current_color:
                                    conflict = True
                                    break
                            if not conflict:
                                output[r][c] = current_color
                                break
                            current_color -= 1
                        if current_color < 1:
                            output[r][c] = 1
                        break
    return output
