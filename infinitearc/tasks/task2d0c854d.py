# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 2d0c854d
Difficulty: medium

=== Tags ===
- Detect enclosure
- Image resizing
- Bridge gaps
- Shape guessing

=== Description ===
The input grids contain a single, distinct closed shape (enclosure) formed by
connected non-zero pixels, with some interior pixels set to zero representing
gaps within the enclosure. The task requires two key operations: first,
detecting the largest enclosed area and filling all interior gaps (bridging
them) to create a solid shape; second, resizing the grid to the minimal bounding
box that contains only this solid shape, effectively cropping out any
surrounding empty space. The output grid will always be smaller than or equal to
the input grid, with dimensions matching the exact size of the solidified
enclosure. This transformation requires the solver to recognize the shape's
boundary, complete its interior, and adjust the grid size accordingly without
altering the shape's proportions or content.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common
def generate():
    color = random.randint(1, 9)
    h = random.randint(3, 10)
    w = random.randint(3, 10)
    
    base = common.grid(w, h, 0)
    for i in range(h):
        for j in range(w):
            if i == 0 or i == h-1 or j == 0 or j == w-1:
                base[i][j] = color
    
    inner = []
    for i in range(1, h-1):
        for j in range(1, w-1):
            inner.append((i, j))
    
    if all(base[i][j] == color for i, j in inner):
        i, j = random.choice(inner)
        base[i][j] = 0
    else:
        for i, j in inner:
            if random.random() < 0.3:
                base[i][j] = 0
    
    min_size = max(h, w) + 2
    H = random.randint(min_size, 30)
    W = random.randint(min_size, 30)
    
    input_grid = common.grid(W, H, 0)
    start_h = (H - h) // 2
    start_w = (W - w) // 2
    for i in range(h):
        for j in range(w):
            input_grid[start_h + i][start_w + j] = base[i][j]
    
    output_grid = common.grid(w, h, color)
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    non_zero = []
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] != 0:
                non_zero.append((r, c))
    
    if not non_zero:
        return input_grid
    
    color = input_grid[non_zero[0][0]][non_zero[0][1]]
    
    min_row = min(r for r, c in non_zero)
    max_row = max(r for r, c in non_zero)
    min_col = min(c for r, c in non_zero)
    max_col = max(c for r, c in non_zero)
    
    cropped = []
    for r in range(min_row, max_row + 1):
        # Ensure slice is converted to list
        cropped.append(list(input_grid[r][min_col:max_col + 1]))
    
    for r in range(len(cropped)):
        for c in range(len(cropped[0])):
            if cropped[r][c] == 0:
                cropped[r][c] = color
    
    return cropped
