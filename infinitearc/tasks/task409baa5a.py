# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 409baa5a
Difficulty: hard

=== Tags ===
- Rule gate simulation
- Source target routing
- Hollow core detection
- Layered occlusion unfolding

=== Description ===
Input grids feature a complex arrangement of overlapping shapes (layers) on a
background, with each shape represented by a distinct color. Some shapes enclose
background "hollow cores"â€”completely surrounded background regions. Additional
occluded layers (overlapping shapes) cover parts of the grid, including some
hollow cores. Sources (single cells of color 1) are positioned along grid edges,
while targets (color 2 cells) are placed within the grid interior.  The
transformation process involves four key steps:   1. **Hollow core detection**:
Identify all background regions fully enclosed by a single shape (no adjacent
background cells outside the shape boundary).   2. **Layered occlusion
unfolding**: Remove any occluded layers (overlapping shapes) covering hollow
cores, revealing the hollow cores as passageways.   3. **Rule-based routing**:
For each source, trace the shortest orthogonal path (no diagonals) to the
nearest target using only revealed hollow cores as passageways. Paths must enter
and exit hollow cores through adjacent edges (e.g., enter top edge, exit bottom
edge).   4. **Path rendering**: Draw the path using the source color, with all
non-path elements (original occlusions, solid shapes, and background) set to
background color.  The output grid displays only the routed paths from sources
to targets through unfolded hollow cores, with all other elements removed. The
task requires simultaneous detection of spatial relationships (hollow core
enclosure), hierarchical layer management (occlusion unfolding), and constrained
pathfinding (orthogonal routing through specific passageways), making it
challenging due to the interplay of multiple spatial rules and the need to
resolve layered occlusions before routing.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    size = random.randint(10, 30)
    grid = [[0]*size for _ in range(size)]
    
    hollow_size = random.randint(2, 5)
    hollow_r = random.randint(2, size - 2 - hollow_size)
    hollow_c = random.randint(2, size - 2 - hollow_size)
    color_enclosing = 3
    color_cover = 4
    
    for r in range(hollow_r - 1, hollow_r + hollow_size + 1):
        for c in range(hollow_c - 1, hollow_c + hollow_size + 1):
            if r == hollow_r - 1 or r == hollow_r + hollow_size or c == hollow_c - 1 or c == hollow_c + hollow_size:
                grid[r][c] = color_enclosing
    
    for r in range(hollow_r, hollow_r + hollow_size):
        for c in range(hollow_c, hollow_c + hollow_size):
            grid[r][c] = color_cover
    
    edge = random.choice(['top', 'bottom', 'left', 'right'])
    if edge == 'top':
        r = 0
        c = random.randint(0, size-1)
        grid[r][c] = 1
        source = (r, c)
    elif edge == 'bottom':
        r = size-1
        c = random.randint(0, size-1)
        grid[r][c] = 1
        source = (r, c)
    elif edge == 'left':
        c = 0
        r = random.randint(0, size-1)
        grid[r][c] = 1
        source = (r, c)
    else:  # right
        c = size-1
        r = random.randint(0, size-1)
        grid[r][c] = 1
        source = (r, c)
    
    target_r = random.randint(1, size-2)
    target_c = random.randint(1, size-2)
    grid[target_r][target_c] = 2
    target = (target_r, target_c)
    
    temp_grid = [row[:] for row in grid]
    for r in range(size):
        for c in range(size):
            if temp_grid[r][c] == 4:
                temp_grid[r][c] = 0
    
    visited = [[False]*size for _ in range(size)]
    parent = [[None]*size for _ in range(size)]
    queue = [source]
    visited[source[0]][source[1]] = True
    found = False
    while queue:
        r, c = queue.pop(0)
        if (r, c) == target:
            found = True
            break
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < size and 0 <= nc < size and not visited[nr][nc] and temp_grid[nr][nc] == 0:
                visited[nr][nc] = True
                parent[nr][nc] = (r, c)
                queue.append((nr, nc))
    
    if not found:
        path = [source, target]
    else:
        path = []
        r, c = target
        while (r, c) != source:
            path.append((r, c))
            r, c = parent[r][c]
        path.append(source)
        path.reverse()
    
    output = [[0]*size for _ in range(size)]
    for r, c in path:
        output[r][c] = 1
    
    return {'input': grid, 'output': output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    size = len(input_grid)
    temp_grid = [list(row) for row in input_grid]
    
    for r in range(size):
        for c in range(size):
            if temp_grid[r][c] == 4:
                temp_grid[r][c] = 0
    
    sources = []
    targets = []
    for r in range(size):
        for c in range(size):
            if temp_grid[r][c] == 1:
                sources.append((r, c))
            elif temp_grid[r][c] == 2:
                targets.append((r, c))
    
    if not sources or not targets:
        return [[0] * size for _ in range(size)]
    source = sources[0]
    target = targets[0]
    
    visited = [[False] * size for _ in range(size)]
    parent = [[None] * size for _ in range(size)]
    queue = [source]
    visited[source[0]][source[1]] = True
    found = False
    
    while queue:
        r, c = queue.pop(0)
        if (r, c) == target:
            found = True
            break
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < size and 0 <= nc < size and not visited[nr][nc] and temp_grid[nr][nc] == 0:
                visited[nr][nc] = True
                parent[nr][nc] = (r, c)
                queue.append((nr, nc))
    
    if not found:
        # Fallback to direct path
        path = [source, target]
    else:
        path = []
        r, c = target
        while (r, c) != source:
            path.append((r, c))
            r, c = parent[r][c]
        path.append(source)
        path.reverse()
    
    output = [[0] * size for _ in range(size)]
    for r, c in path:
        output[r][c] = 1
    
    return output
