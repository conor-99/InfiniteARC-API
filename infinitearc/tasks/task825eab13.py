# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 825eab13
Difficulty: medium

=== Tags ===
- Pattern alignment

=== Description ===
The input grid contains a single connected region of non-zero cells (a
contiguous block where adjacent cells share a common non-zero value). The output
grid is derived by shifting this region so that its topmost and leftmost cell is
positioned at the grid's top-left corner (0,0). The shift preserves the internal
structure of the region, while all other cells in the grid remain zero. This
transformation aligns the pattern to the grid's origin without altering the
relative positions of cells within the pattern.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    width = common.randint(3, 30)
    height = common.randint(3, 30)
    s = common.randint(2, min(15, width * height - 1))
    pixels = common.continuous_creature(s, width, height)
    max_r = max(r for r, c in pixels)
    max_c = max(c for r, c in pixels)
    dx = common.randint(0, height - max_r - 1)
    dy = common.randint(0, width - max_c - 1)
    if dx == 0 and dy == 0:
        if height - max_r - 1 > 0:
            dx = 1
        elif width - max_c - 1 > 0:
            dy = 1
        else:
            dx = 1
    color = common.randint(1, 9)
    input_grid = common.grid(width, height, 0)
    for r, c in pixels:
        input_grid[r + dx][c + dy] = color
    output_grid = common.grid(width, height, 0)
    for r, c in pixels:
        output_grid[r][c] = color
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    non_zero = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                non_zero.append((r, c))
    if not non_zero:
        return input_grid
    min_row = min(r for r, c in non_zero)
    min_col = min(c for r, c in non_zero)
    output = common.grid(width, height, 0)
    for r, c in non_zero:
        output[r - min_row][c - min_col] = input_grid[r][c]
    return output
