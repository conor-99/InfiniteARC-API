# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 4e9ce12b
Difficulty: medium–hard

=== Tags ===
- Blockwise rule application
- Symbolic spatial binding
- Sort objects in row by size
- Detect symmetry

=== Description ===
The input grid consists of multiple rows, each containing contiguous blocks of
non-zero color values (0 represents background) separated by background cells.
Each block is a connected region of identical color, and its size is defined by
the number of cells it occupies. The output grid is generated through two
deterministic steps:  1. **Block Sorting**: Within each row, sort all blocks by
their size (number of cells) in ascending order, maintaining left-to-right block
sequence. Blocks of equal size retain their relative order from the input.  2.
**Symmetry Enforcement**: After sorting blocks per row, rearrange blocks *within
each row* to form a palindromic sequence of block sizes (i.e., the sequence
reads the same forwards and backwards). This ensures the entire grid achieves
vertical symmetry, where for every cell (r, c), the color matches the color at
(r, width - 1 - c). The rearrangement strictly preserves the sorted size order
while satisfying the palindrome constraint.  For example, a row with sorted
block sizes [2, 2, 3] becomes [2, 3, 2] (palindrome), and a row with [1, 3, 3,
4] becomes [1, 3, 3, 4] → [1, 4, 3, 3] (invalid) → [1, 3, 3, 4] cannot form a
palindrome, so the rule requires the input to be designed such that sorted
blocks *can* form a palindrome. The grid dimensions remain unchanged, and all
colors stay within 0–9.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    input_grid = grid(width, height, 0)
    output_grid = grid(width, height, 0)

    def get_blocks(row):
        blocks = []
        current_color = None
        current_size = 0
        for i, color in enumerate(row):
            if color == 0:
                if current_size > 0:
                    blocks.append((current_color, current_size))
                    current_color = None
                    current_size = 0
            else:
                if current_color is None:
                    current_color = color
                    current_size = 1
                elif current_color == color:
                    current_size += 1
                else:
                    blocks.append((current_color, current_size))
                    current_color = color
                    current_size = 1
        if current_size > 0:
            blocks.append((current_color, current_size))
        return blocks

    def sort_and_palindrome(blocks):
        blocks_sorted = sorted(blocks, key=lambda x: x[1])
        sizes = [size for _, size in blocks_sorted]
        palindrome_blocks = []
        n = len(sizes)
        for i in range(n // 2):
            palindrome_blocks.append(blocks_sorted[i])
            palindrome_blocks.append(blocks_sorted[n - 1 - i])
        if n % 2 == 1:
            palindrome_blocks.append(blocks_sorted[n // 2])
        return palindrome_blocks

    for r in range(height):
        num_blocks = random.randint(1, 5)
        sizes = []
        if num_blocks % 2 == 0:
            for _ in range(num_blocks // 2):
                size = random.randint(1, 5)
                sizes.append(size)
                sizes.append(size)
        else:
            for _ in range(num_blocks // 2):
                size = random.randint(1, 5)
                sizes.append(size)
                sizes.append(size)
            sizes.append(random.randint(1, 5))
        colors = [random.randint(1, 9) for _ in range(num_blocks)]
        row = [0] * width
        idx = 0
        for i in range(num_blocks):
            size = sizes[i]
            color = colors[i]
            for j in range(size):
                if idx < width:
                    row[idx] = color
                    idx += 1
            if i < num_blocks - 1 and idx < width:
                row[idx] = 0
                idx += 1
        input_grid[r] = row
        blocks = get_blocks(row)
        blocks_palindrome = sort_and_palindrome(blocks)
        output_row = [0] * width
        idx = 0
        for color, size in blocks_palindrome:
            for j in range(size):
                if idx < width:
                    output_row[idx] = color
                    idx += 1
            if idx < width and color != blocks_palindrome[-1][0]:
                output_row[idx] = 0
                idx += 1
        output_grid[r] = output_row

    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = grid(width, height, 0)

    def get_blocks(row):
        blocks = []
        current_color = None
        current_size = 0
        for i, color in enumerate(row):
            if color == 0:
                if current_size > 0:
                    blocks.append((current_color, current_size))
                    current_color = None
                    current_size = 0
            else:
                if current_color is None:
                    current_color = color
                    current_size = 1
                elif current_color == color:
                    current_size += 1
                else:
                    blocks.append((current_color, current_size))
                    current_color = color
                    current_size = 1
        if current_size > 0:
            blocks.append((current_color, current_size))
        return blocks

    def sort_and_palindrome(blocks):
        blocks_sorted = sorted(blocks, key=lambda x: x[1])
        sizes = [size for _, size in blocks_sorted]
        palindrome_blocks = []
        n = len(sizes)
        for i in range(n // 2):
            palindrome_blocks.append(blocks_sorted[i])
            palindrome_blocks.append(blocks_sorted[n - 1 - i])
        if n % 2 == 1:
            palindrome_blocks.append(blocks_sorted[n // 2])
        return palindrome_blocks

    for r in range(height):
        row = input_grid[r]
        blocks = get_blocks(row)
        blocks_palindrome = sort_and_palindrome(blocks)
        idx = 0
        for color, size in blocks_palindrome:
            for _ in range(size):
                if idx < width:
                    output_grid[r][idx] = color
                    idx += 1
            if idx < width and color != blocks_palindrome[-1][0]:
                output_grid[r][idx] = 0
                idx += 1
    return output_grid
