# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 418df778
Difficulty: hard

=== Tags ===
- Variable binding by color
- Motif extraction
- Infer step size
- Maze

=== Description ===
The input grids are 15×15 or larger mazes where the background is color 0 and
walls are color 1. The maze contains a path formed by cells of colors 2-5, each
color representing a direction: 2 = right, 3 = up, 4 = left, 5 = down. A motif—a
maximal rectangular region of a single color (not 0-5)—is embedded within the
maze. The width of this motif determines the step size for path traversal. The
output grid reproduces the input maze with the path highlighted in color 6. The
path starts at the top-left cell of the maze's entrance (a cell of color 2),
moves step size cells in the direction of the current cell's color, and
continues to the next cell's direction, stopping when a step would exceed grid
boundaries or hit a wall (color 1). The highlighted path is drawn by changing
the traversed cells to color 6, preserving all walls and original path colors.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    width = height = 15
    W = common.randint(2, 5)
    C = common.randint(6, 9)
    grid = common.grid(width, height, 0)
    
    for r in range(5, 10):
        grid[r][7] = 1
    
    path_cells = []
    c = 0
    while c < width:
        if grid[0][c] == 1:
            break
        path_cells.append((0, c))
        c += W
    for (r, c) in path_cells:
        grid[r][c] = 2
    
    h = common.randint(3, 5)
    start_r = common.randint(3, height - h - 1)
    start_c = common.randint(3, width - W - 1)
    for r in range(start_r, start_r + h):
        for c in range(start_c, start_c + W):
            grid[r][c] = C
    
    output_grid = [row[:] for row in grid]
    for (r, c) in path_cells:
        output_grid[r][c] = 6
    
    return {"input": grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    colors = [6,7,8,9]
    color_cells = {}
    for c in colors:
        color_cells[c] = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] in colors:
                color_cells[grid[r][c]].append((r, c))
    
    max_rect = None
    max_width = 0
    for c, cells in color_cells.items():
        if not cells:
            continue
        min_r = min(r for r, _ in cells)
        max_r = max(r for r, _ in cells)
        min_c = min(c for _, c in cells)
        max_c = max(c for _, c in cells)
        rect_width = max_c - min_c + 1
        if rect_width > max_width:
            max_width = rect_width
            max_rect = (min_r, max_r, min_c, max_c)
    
    if max_rect is None:
        W = 2
    else:
        W = max_rect[3] - max_rect[2] + 1
    
    directions = {
        2: (0, 1),  # right
        3: (-1, 0), # up
        4: (0, -1), # left
        5: (1, 0)   # down
    }
    
    path_cells = []
    r, c = 0, 0
    while 0 <= r < height and 0 <= c < width:
        if grid[r][c] == 1:
            break
        path_cells.append((r, c))
        d = grid[r][c]
        if d not in directions:
            break
        dr, dc = directions[d]
        r += dr * W
        c += dc * W
    
    output_grid = [row[:] for row in grid]
    for (r, c) in path_cells:
        output_grid[r][c] = 6
    
    return output_grid
