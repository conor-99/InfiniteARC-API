# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 461e70a3
Difficulty: very hard

=== Tags ===
- Substitution rule discovery
- Rule transfer between regions
- Pattern expansion
- Reflect by color

=== Description ===
Input grids feature a large background of color 0 with multiple contiguous
regions separated by borders of color 5. Each region contains a compact 2Ã—2
pattern of colors (excluding 0 and 5), with a unique key color at the top-left
corner of the pattern. The key color determines a substitution rule based on a
reference pattern located in the region immediately adjacent to the grid's
rightmost border (the reference region).   To discover the substitution rule,
the solver must map the key color to the reference pattern's structure. For
example, if the key color is 3, the substitution shifts each color in the
pattern by 3 positions within the reference pattern's row-major sequence (mod
9), but the exact mapping is non-arithmetic and requires identifying the
relative color positions.   After applying the substitution rule to all patterns
in the grid, each pattern is reflected across the border color 5 that separates
it from the reference region. The reflection direction is determined by the key
color: key color 1 reflects vertically, 2 reflects horizontally, 3 reflects
diagonally top-left to bottom-right, and 4 reflects diagonally top-right to
bottom-left. The reflected pattern is placed in the region opposite the
original, using the substituted colors.   The output grid contains the
substituted original patterns and their reflected counterparts, with all border
color 5 lines preserved. The complexity arises from the need to: (1) identify
the reference pattern, (2) deduce the substitution rule from the key color's
relationship to the reference, (3) apply the rule consistently across all
regions, and (4) correctly orient the reflection based on the key color's value.
No two regions share the same key color, and the reference pattern is the only
one not requiring reflection.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid


def generate():
    """
    Generate a grid pair according to the task specification.
    Layout summary:
      - A single full-height vertical border of color 5 at column b separates left area and right (reference) area.
      - The left area is split into M horizontal regions (by horizontal border segments that meet the vertical border).
      - Each left region contains one 2x2 pattern whose top-left is a unique key color (1..4). Other 3 cells are colors drawn from the reference pattern's 2x2 colors.
      - The reference pattern (2x2) is placed somewhere in the right area. Its 4 colors include all the keys used on the left.
    The output is produced by substituting each left pattern using a mapping derived from the reference pattern, and then placing a reflected copy across the vertical border into the reference area.
    """
    for attempt in range(200):
        W = random.randint(8, 14)
        H = random.randint(6, 12)

        # choose vertical border column b so that mirroring across it stays inside grid
        b_upper = max(2, (W - 1) // 2)
        if b_upper < 2:
            continue
        b = random.randint(2, b_upper)

        # number of left regions (each must be at least 2 rows tall)
        max_regions = min(4, H // 2)
        if max_regions < 1:
            continue
        M = random.randint(1, max_regions)

        # pick horizontal split points to create M segments on the left (ensure each segment height >=2)
        valid_splits = False
        for _ in range(60):
            if M == 1:
                points = []
            else:
                points = sorted(random.sample(range(1, H), M - 1))
            rows = [0] + points + [H]
            segments = [(rows[i], rows[i + 1]) for i in range(len(rows) - 1)]
            if all(end - start >= 2 for start, end in segments):
                valid_splits = True
                break
        if not valid_splits:
            continue

        # choose unique key colors (1..4) for each left region
        keys = random.sample([1, 2, 3, 4], M)

        # build reference colors: must include all keys and be 4 unique colors (exclude color 5)
        pool = [c for c in range(1, 10) if c != 5]
        ref_set = set(keys)
        while len(ref_set) < 4:
            c = random.choice(pool)
            ref_set.add(c)
        ref_seq = list(ref_set)
        random.shuffle(ref_seq)

        # try to place each left pattern so that the mirrored cells do not collide
        mm_coords = set()
        left_patterns = []  # list of tuples (r0, c0, key)
        success = True
        for seg_index, (r_start, r_end) in enumerate(segments):
            placed = False
            # allowable left columns for 2x2: must fit inside columns 0..b-1
            left_min = max(0, b - 4)
            left_max = max(0, b - 2)
            if left_min > left_max:
                left_min = left_max
            for _try in range(40):
                r0 = random.randint(r_start, r_end - 2)
                c0 = random.randint(left_min, left_max)
                # compute mirrored coordinates across vertical border column b
                this_mm = {(r0 + dr, 2 * b - (c0 + dc)) for dr in (0, 1) for dc in (0, 1)}
                # ensure mirrored coords are in reference area and inside grid
                valid_mm = all((b + 1) <= cc <= (W - 1) and 0 <= rr <= H - 1 for rr, cc in this_mm)
                if not valid_mm:
                    continue
                # ensure no conflict with previously planned mirrored cells
                if any(coord in mm_coords for coord in this_mm):
                    continue
                # accept placement
                mm_coords.update(this_mm)
                left_patterns.append((r0, c0, keys[seg_index]))
                placed = True
                break
            if not placed:
                success = False
                break
        if not success:
            continue

        # pick a location for reference 2x2 that doesn't collide with mirrored cells
        ref_placed = False
        for _try in range(80):
            r_ref = random.randint(0, H - 2)
            c_ref = random.randint(b + 1, W - 2)
            ref_cells = {(r_ref + dr, c_ref + dc) for dr in (0, 1) for dc in (0, 1)}
            if mm_coords & ref_cells:
                continue
            # also ensure no overlap with left original pattern cells
            overlap_with_left = False
            for (r0, c0, _) in left_patterns:
                left_cells = {(r0 + dr, c0 + dc) for dr in (0, 1) for dc in (0, 1)}
                if left_cells & ref_cells:
                    overlap_with_left = True
                    break
            if overlap_with_left:
                continue
            ref_placed = True
            break
        if not ref_placed:
            continue

        # Build input grid
        ingrid = grid(W, H, 0)
        # vertical border
        for r in range(H):
            ingrid[r][b] = 5
        # horizontal border segments on left that meet the vertical border (to carve regions)
        for split in rows[1:-1]:
            for c in range(0, b + 1):
                ingrid[split][c] = 5

        # place reference pattern using ref_seq in row-major order
        ingrid[r_ref][c_ref] = ref_seq[0]
        ingrid[r_ref][c_ref + 1] = ref_seq[1]
        ingrid[r_ref + 1][c_ref] = ref_seq[2]
        ingrid[r_ref + 1][c_ref + 1] = ref_seq[3]

        # place left patterns: top-left is the key, other entries chosen from ref_seq
        for (r0, c0, key) in left_patterns:
            ingrid[r0][c0] = key
            ingrid[r0][c0 + 1] = random.choice(ref_seq)
            ingrid[r0 + 1][c0] = random.choice(ref_seq)
            ingrid[r0 + 1][c0 + 1] = random.choice(ref_seq)

        # create output grid by applying substitution and reflection for each left pattern
        output = [row[:] for row in ingrid]

        def reflect_2x2(mat, key):
            # mat is 2x2 list
            if key == 1:
                # vertical reflection (flip top-bottom)
                return [mat[1][:], mat[0][:]]
            if key == 2:
                # horizontal reflection (flip left-right)
                return [mat[0][::-1], mat[1][::-1]]
            if key == 3:
                # diagonal TL-BR (transpose)
                return [[mat[0][0], mat[1][0]], [mat[0][1], mat[1][1]]]
            if key == 4:
                # diagonal TR-BL (reflect across anti-diagonal)
                return [[mat[1][1], mat[0][1]], [mat[1][0], mat[0][0]]]
            # default: no change
            return [mat[0][:], mat[1][:]]

        # apply substitution and placement
        for (r0, c0, key) in left_patterns:
            # extract original pattern
            pat = [[ingrid[r0][c0], ingrid[r0][c0 + 1]], [ingrid[r0 + 1][c0], ingrid[r0 + 1][c0 + 1]]]
            # compute shift as the index of the key in ref_seq
            try:
                shift = ref_seq.index(key)
            except ValueError:
                # safety: if key not in ref_seq (shouldn't happen) skip
                shift = 0
            # substitute each color according to ref_seq cyclical mapping
            substituted = [[0, 0], [0, 0]]
            for i in (0, 1):
                for j in (0, 1):
                    col = pat[i][j]
                    idx = ref_seq.index(col)
                    new_idx = (idx + shift) % 4
                    substituted[i][j] = ref_seq[new_idx]
            # overwrite original pattern in its region with substituted pattern
            for i in (0, 1):
                for j in (0, 1):
                    output[r0 + i][c0 + j] = substituted[i][j]
            # reflect substituted pattern according to key and place mirrored across vertical border
            refl = reflect_2x2(substituted, key)
            for i in (0, 1):
                for j in (0, 1):
                    mm_r = r0 + i
                    mm_c = 2 * b - (c0 + j)
                    output[mm_r][mm_c] = refl[i][j]

        # final sanity checks
        # ensure input and output are not identical
        if ingrid == output:
            continue

        return {"input": ingrid, "output": output}

    # fallback (should not usually be reached)
    W, H = 8, 6
    b = 3
    ingrid = grid(W, H, 0)
    for r in range(H):
        ingrid[r][b] = 5
    ingrid[1][1] = 1
    ingrid[1][2] = 2
    ingrid[2][1] = 3
    ingrid[2][2] = 4
    ingrid[1][5] = 1
    ingrid[1][6] = 2
    ingrid[2][5] = 3
    ingrid[2][6] = 4
    output = [row[:] for row in ingrid]
    return {"input": ingrid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0])

    # find the full-height vertical border column of color 5 (choose the rightmost full column)
    full_5_cols = [c for c in range(W) if all(grid[r][c] == 5 for r in range(H))]
    if full_5_cols:
        b = max(full_5_cols)
    else:
        # fallback: choose column with most 5s
        counts = [sum(1 for r in range(H) if grid[r][c] == 5) for c in range(W)]
        b = max(range(W), key=lambda c: counts[c])

    # locate the reference 2x2 pattern in the right area (columns >= b+1)
    candidates = []
    for r in range(H - 1):
        for c in range(b + 1, W - 1):
            vals = [grid[r][c], grid[r][c + 1], grid[r + 1][c], grid[r + 1][c + 1]]
            if all(v != 0 and v != 5 for v in vals):
                candidates.append((c, r, vals))
    if not candidates:
        return grid
    # pick the rightmost candidate (largest column), tie-break by topmost
    candidates.sort(key=lambda x: (x[0], -x[1]), reverse=True)
    _, r_ref, ref_vals = candidates[0]
    ref_seq = ref_vals[:]

    # helper for reflections
    def reflect_2x2(mat, key):
        if key == 1:
            return [mat[1][:], mat[0][:]]
        if key == 2:
            return [mat[0][::-1], mat[1][::-1]]
        if key == 3:
            return [[mat[0][0], mat[1][0]], [mat[0][1], mat[1][1]]]
        if key == 4:
            return [[mat[1][1], mat[0][1]], [mat[1][0], mat[0][0]]]
        return [mat[0][:], mat[1][:]]

    output = [row[:] for row in grid]

    # find all 2x2 patterns on the left side (columns < b)
    patterns = []
    seen = set()
    for r in range(H - 1):
        for c in range(0, b):
            if (r, c) in seen:
                continue
            vals = [grid[r][c], grid[r][c + 1], grid[r + 1][c], grid[r + 1][c + 1]]
            if all(v != 0 and v != 5 for v in vals):
                key = grid[r][c]
                if key in (1, 2, 3, 4):
                    patterns.append((r, c, key))
                    # mark these 4 cells as seen (avoid overlapping detections)
                    seen.update({(r, c), (r, c + 1), (r + 1, c), (r + 1, c + 1)})

    # apply substitution and place reflections
    for (r0, c0, key) in patterns:
        pat = [[grid[r0][c0], grid[r0][c0 + 1]], [grid[r0 + 1][c0], grid[r0 + 1][c0 + 1]]]
        try:
            shift = ref_seq.index(key)
        except ValueError:
            shift = 0
        substituted = [[0, 0], [0, 0]]
        for i in (0, 1):
            for j in (0, 1):
                col = pat[i][j]
                idx = ref_seq.index(col)
                new_idx = (idx + shift) % 4
                substituted[i][j] = ref_seq[new_idx]
        # write substituted into original location
        for i in (0, 1):
            for j in (0, 1):
                output[r0 + i][c0 + j] = substituted[i][j]
        # reflect and place across vertical border
        refl = reflect_2x2(substituted, key)
        for i in (0, 1):
            for j in (0, 1):
                mm_r = r0 + i
                mm_c = 2 * b - (c0 + j)
                output[mm_r][mm_c] = refl[i][j]

    return output

