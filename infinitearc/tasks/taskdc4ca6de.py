# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: dc4ca6de
Difficulty: insane

=== Tags ===
- Portal momentum pathing
- State machine grid
- Gradient flood
- Analogical goal mapping
- Associate colors to numbers
- Ex nihilo

=== Description ===
Input grids are 30×30 grids with a single background color (0). Overlaid on this
background are: (1) a top-left pattern strip consisting of 2×2 color blocks
arranged horizontally (e.g., [7, 3, 9, 2]), where the first block matches the
starting cell's color; (2) a single starting cell (color A) positioned along the
left edge (not adjacent to walls); (3) multiple portal pairs—each pair consists
of two identical-colored cells (e.g., color 5) placed at least two cells apart;
(4) wall segments (color 6) forming non-orthogonal barriers that do not touch
portals or the pattern strip. Walls are arranged to create a single continuous
cave-like path from the start to the grid boundary.  Output grids retain all
input elements unchanged, except for a newly generated path. The path begins at
the starting cell, moving right (initial direction). Each step adopts the next
color in the cyclic pattern strip (e.g., 7 → 3 → 9 → 2 → 7...), replacing
background cells with the current path color. Upon encountering a portal cell,
the path instantly teleports to the matching portal cell, and direction changes
based on the portal color's fixed mapping (color 1 → right, 2 → up, 3 → left, 4
→ down, 5 → right, 6 → up, etc., with colors >4 modulo 4). The path continues in
the new direction without overlapping walls, portals, or the pattern strip,
exiting the grid when it reaches any boundary. The path is drawn exclusively
over background cells, creating a "gradient flood" effect that cycles through
the pattern strip while respecting portal momentum redirection. No two paths
intersect, and all paths terminate within 50 steps. The "ex nihilo" aspect
arises as the path is entirely generated from the background with no pre-
existing structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid as make_grid, random_color


def generate():
    W, H = 30, 30
    # base grid with background 0
    g = make_grid(W, H, 0)

    # Pattern strip: 2x2 blocks horizontally in top-left
    num_blocks = random.randint(2, 4)
    # First block color must match the starting cell's color
    start_color = random_color(exclude=[0, 6])
    pattern_colors = [start_color]
    # choose distinct other colors for the pattern (avoid 0 and wall color 6)
    avail = [c for c in range(1, 10) if c not in (6, start_color)]
    if num_blocks - 1 <= len(avail):
        others = random.sample(avail, num_blocks - 1)
    else:
        # fallback (shouldn't happen) - allow repeats
        others = [random.choice(avail) for _ in range(num_blocks - 1)]
    pattern_colors.extend(others)

    # Paint the 2x2 blocks
    for i, color in enumerate(pattern_colors):
        base_c = 2 * i
        for r in (0, 1):
            for c in (base_c, base_c + 1):
                if 0 <= r < H and 0 <= c < W:
                    g[r][c] = color

    # Create a wavy pair of walls (top and bottom) that leave a continuous corridor
    # Choose a fixed corridor center so a straight rightward path is possible across the grid
    center = random.randint(6, 23)
    half = random.randint(2, 4)  # half-width of corridor
    base_top = center - half
    base_bottom = center + half

    top_rows = []
    bottom_rows = []
    for c in range(W):
        tr = base_top + random.choice((-1, 0, 1))
        br = base_bottom + random.choice((-1, 0, 1))
        tr = max(2, min(tr, H - 6))
        # ensure a minimum gap of 3 (top, corridor, bottom)
        br = max(tr + 3, min(br, H - 3))
        top_rows.append(tr)
        bottom_rows.append(br)

    # Paint wall pixels for each column and connect vertical jumps to make continuous barriers
    for c in range(W):
        g[top_rows[c]][c] = 6
        g[bottom_rows[c]][c] = 6

    for c in range(W - 1):
        # connect top wall if there's a vertical jump
        if top_rows[c + 1] > top_rows[c] + 1:
            for r in range(top_rows[c] + 1, top_rows[c + 1]):
                g[r][c + 1] = 6
        elif top_rows[c + 1] < top_rows[c] - 1:
            for r in range(top_rows[c + 1] + 1, top_rows[c]):
                g[r][c + 1] = 6
        # connect bottom wall if there's a vertical jump
        if bottom_rows[c + 1] > bottom_rows[c] + 1:
            for r in range(bottom_rows[c], bottom_rows[c + 1]):
                g[r][c + 1] = 6
        elif bottom_rows[c + 1] < bottom_rows[c] - 1:
            for r in range(bottom_rows[c + 1] + 1, bottom_rows[c]):
                g[r][c + 1] = 6

    # Place the starting cell on the left edge (not in the top pattern rows)
    start_row = center
    start_row = max(2, min(H - 3, start_row))
    g[start_row][0] = start_color

    # Helper to check adjacency to walls or to the pattern strip
    def adj_has_wall_or_pattern(r, c):
        for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):
            rr, cc = r + dr, c + dc
            if 0 <= rr < H and 0 <= cc < W:
                if g[rr][cc] == 6:
                    return True
                if rr in (0, 1) and cc < 2 * num_blocks:
                    return True
        return False

    # Place portal pairs (2-4 pairs) avoiding walls, pattern, and start
    num_pairs = random.randint(2, 4)
    used_colors = set(pattern_colors + [6])
    candidate_colors = [c for c in range(1, 10) if c not in used_colors]
    if len(candidate_colors) == 0:
        candidate_colors = [1]
    if num_pairs > len(candidate_colors):
        num_pairs = len(candidate_colors)
    chosen_colors = random.sample(candidate_colors, num_pairs)

    portal_map = {}

    for color in chosen_colors:
        placed = False
        attempts = 0
        while not placed and attempts < 1000:
            attempts += 1
            c1 = random.randint(2, W - 3)
            r1 = random.randint(top_rows[c1] + 1, bottom_rows[c1] - 1)
            c2 = random.randint(2, W - 3)
            r2 = random.randint(top_rows[c2] + 1, bottom_rows[c2] - 1)
            if (r1, c1) == (r2, c2):
                continue
            if abs(r1 - r2) + abs(c1 - c2) < 4:
                continue
            if g[r1][c1] != 0 or g[r2][c2] != 0:
                continue
            if adj_has_wall_or_pattern(r1, c1) or adj_has_wall_or_pattern(r2, c2):
                continue
            if (r1, c1) == (start_row, 0) or (r2, c2) == (start_row, 0):
                continue
            # place portals
            g[r1][c1] = color
            g[r2][c2] = color
            portal_map[color] = ((r1, c1), (r2, c2))
            placed = True

    # Occasionally ensure there's a portal on the corridor center row so the path may use portals
    if random.random() < 0.7:
        # choose a color not already used by walls/pattern and not already used for portals
        extras = [c for c in range(1, 10) if c not in set(pattern_colors + [6]) and c not in portal_map]
        if extras:
            forced = random.choice(extras)
            cA = random.randint(2, W // 2)
            cB = random.randint(W - 4, W - 2)
            if g[center][cA] == 0 and g[center][cB] == 0 and not adj_has_wall_or_pattern(center, cA) and not adj_has_wall_or_pattern(center, cB):
                g[center][cA] = forced
                g[center][cB] = forced
                portal_map[forced] = ((center, cA), (center, cB))

    # Simulate the path according to the rules
    # direction indices: 0:right, 1:up, 2:left, 3:down
    dr = [0, -1, 0, 1]
    dc = [1, 0, -1, 0]

    pos = (start_row, 0)
    direction = 0
    color_index = 0  # points to the block that matches the start cell
    steps = 0
    path = []  # list of tuples (r, c, color_index_at_step)

    while steps < 50:
        r, c = pos
        nr, nc = r + dr[direction], c + dc[direction]
        if not (0 <= nr < H and 0 <= nc < W):
            # exited the grid
            break
        val = g[nr][nc]
        if val in portal_map:
            # teleport instantly to the matching portal cell and change direction
            pair = portal_map[val]
            other = pair[0] if pair[1] == (nr, nc) else pair[1]
            direction = (val - 1) % 4
            pos = other
            continue
        if val == 0:
            # color this background cell with the next color in the cyclic pattern
            color_index = (color_index + 1) % len(pattern_colors)
            path.append((nr, nc, color_index))
            pos = (nr, nc)
            steps += 1
            continue
        # if we hit a wall, pattern block, start cell, or any non-background and non-portal cell, stop
        break

    # Build output
    out = [row[:] for row in g]
    for r, c, ci in path:
        out[r][c] = pattern_colors[ci]

    return {"input": g, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert tuple-grid to list of lists
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0]) if H else 0

    # Find the pattern strip in the top-left: consecutive 2x2 same-color blocks
    pattern_colors = []
    max_blocks = W // 2
    for i in range(max_blocks):
        c0 = 2 * i
        c1 = c0 + 1
        if c1 >= W or 1 >= H:
            break
        v = grid[0][c0]
        if v != 0 and v != 6 and grid[0][c1] == v and grid[1][c0] == v and grid[1][c1] == v:
            pattern_colors.append(v)
        else:
            break
    if not pattern_colors:
        # fallback in unlikely case
        pattern_colors = [1, 2, 3]

    # Find start cell along left edge whose color matches the first pattern color
    start_color = pattern_colors[0]
    start_pos = None
    for r in range(2, H - 1):
        if grid[r][0] == start_color:
            start_pos = (r, 0)
            break
    if start_pos is None:
        # fallback: pick any non-background non-wall on left edge
        for r in range(H):
            if grid[r][0] != 0 and grid[r][0] != 6:
                start_pos = (r, 0)
                break
        if start_pos is None:
            start_pos = (H // 2, 0)

    # Identify portal colors and their two positions
    portals = {}
    for r in range(H):
        for c in range(W):
            v = grid[r][c]
            if v == 0 or v == 6:
                continue
            # exclude pattern strip area (top-left 2x2 blocks)
            if r in (0, 1) and c < 2 * len(pattern_colors):
                continue
            # exclude the start cell
            if (r, c) == start_pos:
                continue
            portals.setdefault(v, []).append((r, c))

    portal_map = {}
    for k, v in portals.items():
        if len(v) == 2:
            portal_map[k] = (v[0], v[1])

    # Simulate the path using the same rules as the generator
    dr = [0, -1, 0, 1]
    dc = [1, 0, -1, 0]

    pos = start_pos
    direction = 0
    color_index = 0
    steps = 0
    path = []

    while steps < 50:
        r, c = pos
        nr, nc = r + dr[direction], c + dc[direction]
        if not (0 <= nr < H and 0 <= nc < W):
            break
        val = grid[nr][nc]
        if val in portal_map:
            p0, p1 = portal_map[val]
            other = p1 if p0 == (nr, nc) else p0
            direction = (val - 1) % 4
            pos = other
            continue
        if val == 0:
            color_index = (color_index + 1) % len(pattern_colors)
            path.append((nr, nc, color_index))
            pos = (nr, nc)
            steps += 1
            continue
        # blocked
        break

    # Apply path to output copy
    output = [row[:] for row in grid]
    for r, c, ci in path:
        output[r][c] = pattern_colors[ci]

    return output

