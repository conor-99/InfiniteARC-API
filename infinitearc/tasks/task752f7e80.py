# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 752f7e80
Difficulty: mediumâ€“hard

=== Tags ===
- Local state machine
- Associate colors to ranks

=== Description ===
Input grids are composed of a background color (0) and colored cells (1-9),
where each color directly represents a rank (1 = lowest, 9 = highest). For each
cell in the grid, the output cell is determined by the highest rank present
among its four orthogonal neighbors (up, down, left, right). If all neighbors
are background (0), the output cell remains background (0). If the highest
neighbor rank is 9, the output cell is set to 0 (background); otherwise, the
output cell is set to the next higher rank (e.g., rank 5 becomes 6, rank 8
becomes 9). This transformation requires recognizing the color-rank association
and applying a deterministic successor function based on immediate neighboring
ranks, creating a local state machine where each cell's output depends solely on
its neighbors' ranks. The task demands identifying the rank hierarchy,
processing neighbor relationships, and executing the successor transition rule
across the entire grid, making it medium-hard due to the need for multi-step
reasoning about rank relationships and state transitions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def compute_output(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output = [[0] * width for _ in range(height)]
    for i in range(height):
        for j in range(width):
            neighbors = []
            if i > 0:
                neighbors.append(input_grid[i-1][j])
            if i < height - 1:
                neighbors.append(input_grid[i+1][j])
            if j > 0:
                neighbors.append(input_grid[i][j-1])
            if j < width - 1:
                neighbors.append(input_grid[i][j+1])
            if not neighbors or all(n == 0 for n in neighbors):
                output[i][j] = 0
            else:
                h = max(neighbors)
                if h == 9:
                    output[i][j] = 0
                else:
                    output[i][j] = h + 1
    return output

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    input_grid = common.grid(width, height, 0)
    non_zero_found = False
    for i in range(height):
        for j in range(width):
            if random.random() > 0.5:
                input_grid[i][j] = random.randint(1, 9)
                non_zero_found = True
    if not non_zero_found:
        i, j = random.randint(0, height-1), random.randint(0, width-1)
        input_grid[i][j] = random.randint(1, 9)
    output_grid = compute_output(input_grid)
    if input_grid == output_grid:
        for _ in range(10):
            width = random.randint(1, 30)
            height = random.randint(1, 30)
            input_grid = common.grid(width, height, 0)
            non_zero_found = False
            for i in range(height):
                for j in range(width):
                    if random.random() > 0.5:
                        input_grid[i][j] = random.randint(1, 9)
                        non_zero_found = True
            if not non_zero_found:
                i, j = random.randint(0, height-1), random.randint(0, width-1)
                input_grid[i][j] = random.randint(1, 9)
            output_grid = compute_output(input_grid)
            if input_grid != output_grid:
                return {"input": input_grid, "output": output_grid}
        return {"input": input_grid, "output": output_grid}
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def compute_output(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output = [[0] * width for _ in range(height)]
    for i in range(height):
        for j in range(width):
            neighbors = []
            if i > 0:
                neighbors.append(input_grid[i-1][j])
            if i < height - 1:
                neighbors.append(input_grid[i+1][j])
            if j > 0:
                neighbors.append(input_grid[i][j-1])
            if j < width - 1:
                neighbors.append(input_grid[i][j+1])
            if not neighbors or all(n == 0 for n in neighbors):
                output[i][j] = 0
            else:
                h = max(neighbors)
                if h == 9:
                    output[i][j] = 0
                else:
                    output[i][j] = h + 1
    return output

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    output_list = compute_output(input_list)
    return tuple(tuple(row) for row in output_list)
