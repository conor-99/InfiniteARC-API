# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 6a1cc0e8
Difficulty: medium–hard

=== Tags ===
- Dynamic channel painting

=== Description ===
The input grid features a complex network of interconnected channels, each
represented by a distinct color (e.g., red, blue, green). These channels may
branch, cross, and form intersections. At certain intersection points, there are
special nodes—cells colored with a distinct, unique hue (e.g., yellow,
purple)—that dictate how the intersecting channels should transform. The output
grid reflects the channels after all such transformations have been applied:
wherever two channels of different colors intersect at a node, the intersection
is replaced by a single channel of the node's color, and the paths are smoothly
merged to maintain continuity. Channels of the same color that intersect remain
unchanged. The background color (typically 0) remains unaffected, and all
channel segments are extended to form a seamless, continuous network in the
output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    input_grid = [[0] * width for _ in range(height)]
    
    channel_colors = random.sample(range(1, 6), 2)
    node_color = random.choice(range(6, 10))
    
    mid_col = width // 2
    for r in range(height):
        input_grid[r][mid_col] = channel_colors[0]
    
    mid_row = height // 2
    for c in range(width):
        if input_grid[mid_row][c] == 0:
            input_grid[mid_row][c] = channel_colors[1]
    
    input_grid[mid_row][mid_col] = node_color
    
    output_grid = [row[:] for row in input_grid]
    
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] == node_color:
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        if output_grid[nr][nc] != 0 and output_grid[nr][nc] != node_color:
                            output_grid[nr][nc] = node_color
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    node_colors = {6, 7, 8, 9}
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] in node_colors:
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        if grid[nr][nc] != 0 and grid[nr][nc] not in node_colors:
                            grid[nr][nc] = grid[r][c]
    
    return tuple(tuple(row) for row in grid)
