# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 18722904
Difficulty: hard

=== Tags ===
- Transformation stack
- Fractal growth
- Elastic wave

=== Description ===
Input grids feature a central "wave core" pattern (a small 3×3 arrangement of
colored cells forming a sine wave) positioned at the grid's center, surrounded
by background. The topmost cell of the wave core (e.g., the cell at (0,1) in the
3×3 core) determines the transformation sequence for wave propagation: red =
rotate 90° clockwise, blue = mirror vertically, green = scale by 0.9. The grid
also includes a single pre-existing wave layer surrounding the core, transformed
using the first operation in the sequence.  The output grid extends the wave
pattern by generating a new outer layer, applying the next transformation in the
sequence to the outermost existing layer. The elastic wave effect is achieved
through smooth, continuous scaling and rotation, where each new layer's pattern
seamlessly connects to the previous layer via the transformation. For example,
if the existing layer was rotated 90°, the new layer is mirrored vertically,
followed by scaling, and so on. The background remains unchanged, and the new
layer is positioned to fill the space between the outermost layer and the grid
boundary without overlapping.  For a hard task, the input may contain multiple
wave cores with distinct colors (each indicating a different sequence),
requiring the solver to deduce the correct sequence from the core's color and
apply it to generate the output layer. The transformation must be applied
iteratively, with each layer's transformation determined by its position in the
sequence.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid as make_grid


def rotate90(mat):
    return [list(row) for row in zip(*mat[::-1])]


def mirror_vertical(mat):
    return [row[::-1] for row in mat]


def scale_shrink(mat):
    # approximate a 0.9 scale by "shrinking" corners toward the center
    new = [row[:] for row in mat]
    center = mat[1][1]
    new[0][0] = center
    new[0][2] = center
    new[2][0] = center
    new[2][2] = center
    return new


def generate():
    # Choose an odd size at least 5 so there's room for core + one layer
    sizes = [5, 7, 9, 11, 13, 15]
    size = random.choice(sizes)
    grid_in = make_grid(size, size, 0)
    center = size // 2

    # Indicator colors: 2 (red) -> rotate, 1 (blue) -> mirror vertically, 3 (green) -> scale
    indicator = random.choice([2, 1, 3])

    # Pick two other colors for the body of the core (avoid 0 and the indicator color)
    pool = [c for c in range(1, 10) if c != indicator]
    a = random.choice(pool)
    pool2 = [c for c in pool if c != a]
    b = random.choice(pool2) if pool2 else a

    # Build a small "sine wave" core (3x3)
    core = [
        [0, indicator, 0],
        [a, b, a],
        [0, a, 0]
    ]

    op_map = {2: rotate90, 1: mirror_vertical, 3: scale_shrink}
    order = [rotate90, mirror_vertical, scale_shrink]
    start_idx = {2: 0, 1: 1, 3: 2}[indicator]

    # First surrounding layer is the first operation applied to the core
    first_layer = op_map[indicator](core)

    # Place the core at the center of the input grid
    for r in range(3):
        for c in range(3):
            grid_in[center - 1 + r][center - 1 + c] = core[r][c]

    # Place the first_layer around the core (distance = 2)
    for c in range(3):
        grid_in[center - 2][center - 1 + c] = first_layer[0][c]
        grid_in[center + 2][center - 1 + c] = first_layer[2][c]
    for r in range(3):
        grid_in[center - 1 + r][center - 2] = first_layer[r][0]
        grid_in[center - 1 + r][center + 2] = first_layer[r][2]

    # Next operation in the cyclic sequence is applied to the outermost existing layer
    next_idx = (start_idx + 1) % 3
    second_layer = order[next_idx](first_layer)

    # Build the output grid by padding the input by one-cell border (so nothing overlaps)
    size_out = size + 2
    grid_out = make_grid(size_out, size_out, 0)
    for r in range(size):
        for c in range(size):
            grid_out[r + 1][c + 1] = grid_in[r][c]

    center_out = center + 1
    # Place the new (second) layer at distance = 3 around the new center
    for c in range(3):
        grid_out[center_out - 3][center_out - 1 + c] = second_layer[0][c]
        grid_out[center_out + 3][center_out - 1 + c] = second_layer[2][c]
    for r in range(3):
        grid_out[center_out - 1 + r][center_out - 3] = second_layer[r][0]
        grid_out[center_out - 1 + r][center_out + 3] = second_layer[r][2]

    return {
        'input': grid_in,
        'output': grid_out
    }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid_in = [list(row) for row in input_grid]
    n = len(grid_in)
    center = n // 2

    def rotate90(mat):
        return [list(row) for row in zip(*mat[::-1])]

    def mirror_vertical(mat):
        return [row[::-1] for row in mat]

    def scale_shrink(mat):
        new = [row[:] for row in mat]
        center_val = mat[1][1]
        new[0][0] = center_val
        new[0][2] = center_val
        new[2][0] = center_val
        new[2][2] = center_val
        return new

    # Extract the 3x3 core at the grid center
    core = [[grid_in[center - 1 + r][center - 1 + c] for c in range(3)] for r in range(3)]

    top_color = core[0][1]
    op_map = {2: rotate90, 1: mirror_vertical, 3: scale_shrink}
    order = [rotate90, mirror_vertical, scale_shrink]
    start_idx = {2: 0, 1: 1, 3: 2}[top_color]

    # Reconstruct the first surrounding layer by applying the first operation to the core
    first_layer = op_map[top_color](core)

    # Compute the next layer by applying the next operation in the cycle
    next_layer = order[(start_idx + 1) % 3](first_layer)

    # Build the output by padding the input by one cell on each side and then placing the new layer
    out_n = n + 2
    out = [[0 for _ in range(out_n)] for __ in range(out_n)]
    for r in range(n):
        for c in range(n):
            out[r + 1][c + 1] = grid_in[r][c]

    center_out = center + 1
    # Place the computed next_layer at distance = 3 around the new center
    for c in range(3):
        out[center_out - 3][center_out - 1 + c] = next_layer[0][c]
        out[center_out + 3][center_out - 1 + c] = next_layer[2][c]
    for r in range(3):
        out[center_out - 1 + r][center_out - 3] = next_layer[r][0]
        out[center_out - 1 + r][center_out + 3] = next_layer[r][2]

    return out

