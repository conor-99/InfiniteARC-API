# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 77492a3d
Difficulty: insane

=== Tags ===
- Line collision
- Heat map draw
- Detect rotational symmetry

=== Description ===
The input grid consists of a complex arrangement of colored line segments (each
line represented by a continuous sequence of connected cells with identical non-
zero values on a background of value 0) that form intersecting paths. These
lines may originate from grid boundaries or form closed loops, with
intersections occurring only at orthogonal crossings (not diagonal). The output
grid must transform the input through three sequential processes: first,
identifying all collision points (where two or more lines intersect
orthogonally); second, determining for each collision point whether it has a
symmetric counterpart under 180-degree rotational symmetry about the grid's
center (i.e., collision at position (r,c) pairs with collision at (height-1-r,
width-1-c)); and third, generating a heat map where each collision point is
replaced with a color value proportional to the number of intersecting lines
multiplied by an additional factor of 2 if it has a symmetric counterpart. The
heat map uses a predefined intensity scale (e.g., 1=low intensity, 9=high
intensity) such that collision points with symmetric counterparts receive higher
values. Non-collision cells retain their original line colors, while all other
background cells remain unchanged. The transformation requires simultaneous
detection of line intersections, symmetry relationships, and intensity mapping,
with no explicit numerical calculations or memorization-based rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    grid = [[0] * width for _ in range(height)]
    colors = random.sample(range(1, 10), random.randint(2, 4))
    
    for color in colors:
        r = random.randint(0, height-1)
        c1 = random.randint(0, width-2)
        c2 = random.randint(c1+1, width-1)
        for c in range(c1, c2+1):
            grid[r][c] = color
        
        c = random.randint(c1, c2)
        r1 = random.randint(0, r)
        r2 = random.randint(r, height-1)
        for r_val in range(r1, r2+1):
            grid[r_val][c] = color

    collision_points = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                color_val = grid[r][c]
                has_h = (c > 0 and grid[r][c-1] == color_val) or (c < width-1 and grid[r][c+1] == color_val)
                has_v = (r > 0 and grid[r-1][c] == color_val) or (r < height-1 and grid[r+1][c] == color_val)
                if has_h and has_v:
                    collision_points.append((r, c))

    if not collision_points:
        r, c = random.randint(0, height-1), random.randint(0, width-1)
        color_val = random.choice(colors)
        grid[r][c] = color_val
        if c > 0: grid[r][c-1] = color_val
        if c < width-1: grid[r][c+1] = color_val
        if r > 0: grid[r-1][c] = color_val
        if r < height-1: grid[r+1][c] = color_val
        collision_points = [(r, c)]

    r, c = random.choice(collision_points)
    r_sym, c_sym = height-1-r, width-1-c
    if 0 <= r_sym < height and 0 <= c_sym < width and (r_sym, c_sym) not in collision_points:
        color_val = grid[r][c]
        grid[r_sym][c_sym] = color_val
        if c_sym > 0: grid[r_sym][c_sym-1] = color_val
        if c_sym < width-1: grid[r_sym][c_sym+1] = color_val
        if r_sym > 0: grid[r_sym-1][c_sym] = color_val
        if r_sym < height-1: grid[r_sym+1][c_sym] = color_val
        collision_points.append((r_sym, c_sym))

    output = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                color_val = grid[r][c]
                has_h = (c > 0 and grid[r][c-1] == color_val) or (c < width-1 and grid[r][c+1] == color_val)
                has_v = (r > 0 and grid[r-1][c] == color_val) or (r < height-1 and grid[r+1][c] == color_val)
                if has_h and has_v:
                    r_sym, c_sym = height-1-r, width-1-c
                    symmetric = False
                    if 0 <= r_sym < height and 0 <= c_sym < width:
                        if grid[r_sym][c_sym] == color_val:
                            sym_has_h = (c_sym > 0 and grid[r_sym][c_sym-1] == color_val) or (c_sym < width-1 and grid[r_sym][c_sym+1] == color_val)
                            sym_has_v = (r_sym > 0 and grid[r_sym-1][c_sym] == color_val) or (r_sym < height-1 and grid[r_sym+1][c_sym] == color_val)
                            if sym_has_h and sym_has_v:
                                symmetric = True
                    new_color = 2 * (2 if symmetric else 1)
                    if new_color > 9:
                        new_color = 9
                    output[r][c] = new_color

    if grid == output:
        r, c = random.randint(0, height-1), random.randint(0, width-1)
        output[r][c] = (output[r][c] + 1) % 10
        if output[r][c] == 0:
            output[r][c] = 1

    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    output = [row[:] for row in grid]
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                color_val = grid[r][c]
                has_h = (c > 0 and grid[r][c-1] == color_val) or (c < width-1 and grid[r][c+1] == color_val)
                has_v = (r > 0 and grid[r-1][c] == color_val) or (r < height-1 and grid[r+1][c] == color_val)
                if has_h and has_v:
                    r_sym, c_sym = height-1-r, width-1-c
                    symmetric = False
                    if 0 <= r_sym < height and 0 <= c_sym < width:
                        if grid[r_sym][c_sym] == color_val:
                            sym_has_h = (c_sym > 0 and grid[r_sym][c_sym-1] == color_val) or (c_sym < width-1 and grid[r_sym][c_sym+1] == color_val)
                            sym_has_v = (r_sym > 0 and grid[r_sym-1][c_sym] == color_val) or (r_sym < height-1 and grid[r_sym+1][c_sym] == color_val)
                            if sym_has_h and sym_has_v:
                                symmetric = True
                    new_color = 2 * (2 if symmetric else 1)
                    if new_color > 9:
                        new_color = 9
                    output[r][c] = new_color
    return output
