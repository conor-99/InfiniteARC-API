# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 454a4a4e
Difficulty: medium–hard

=== Tags ===
- Symmetry axis completion

=== Description ===
Input grids feature a single background color (e.g., 0) with non-background
elements arranged asymmetrically. The pattern is symmetric with respect to a
vertical axis, but only one side of the axis is populated with non-background
elements—the other side is entirely background. The output grid completes the
symmetry by reflecting all non-background elements over the determined axis to
the empty side, preserving colors and background. The axis must be deduced from
the input: it is the unique vertical line where each non-background element's
mirror position (determined by 2k - c for column c) is background in the input.
The solver must identify this axis by verifying that all mirror positions for
existing elements are background, then reflect the elements to complete the
symmetric pattern. The background remains unchanged, and no elements are
overwritten. This requires analyzing the spatial arrangement to determine the
axis, making the task medium-hard as the axis is not aligned with the grid's
natural symmetry and must be inferred from the pattern's structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
def generate():
    W = random.randint(3, 30)
    H = random.randint(3, 30)
    m = (W - 1) // 2  # Use maximum possible m for uniqueness
    input_grid = [[0] * W for _ in range(H)]
    for r in range(H):
        for c in range(m):
            if random.random() < 0.3:
                input_grid[r][c] = random.randint(1, 9)
    if all(input_grid[r][c] == 0 for r in range(H) for c in range(m)):
        r, c = random.randint(0, H-1), random.randint(0, m-1)
        input_grid[r][c] = random.randint(1, 9)
    output_grid = [row[:] for row in input_grid]
    for r in range(H):
        for c in range(m):
            if input_grid[r][c] != 0:
                mirror_c = 2 * m - c
                if 0 <= mirror_c < W:
                    output_grid[r][mirror_c] = input_grid[r][c]
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    H = len(input_grid)
    W = len(input_grid[0])
    non_background = []
    for r in range(H):
        for c in range(W):
            if input_grid[r][c] != 0:
                non_background.append((r, c))
    if not non_background:
        return input_grid
    correct_m = None
    for m in range((W - 1) // 2, 0, -1):
        left_side = True
        for (r, c) in non_background:
            if c >= m:
                left_side = False
                break
        if not left_side:
            continue
        mirror_ok = True
        for (r, c) in non_background:
            mirror_c = 2 * m - c
            if mirror_c < 0 or mirror_c >= W:
                continue
            if input_grid[r][mirror_c] != 0:
                mirror_ok = False
                break
        if mirror_ok:
            correct_m = m
            break
    if correct_m is None:
        for m in range(1, W - 1):
            right_side = True
            for (r, c) in non_background:
                if c <= m:
                    right_side = False
                    break
            if not right_side:
                continue
            mirror_ok = True
            for (r, c) in non_background:
                mirror_c = 2 * m - c
                if mirror_c < 0 or mirror_c >= W:
                    continue
                if input_grid[r][mirror_c] != 0:
                    mirror_ok = False
                    break
            if mirror_ok:
                correct_m = m
                break
    if correct_m is None:
        correct_m = 1
    output_grid = [list(row) for row in input_grid]
    for r in range(H):
        for c in range(correct_m):
            if input_grid[r][c] != 0:
                mirror_c = 2 * correct_m - c
                if 0 <= mirror_c < W:
                    output_grid[r][mirror_c] = input_grid[r][c]
    return output_grid
