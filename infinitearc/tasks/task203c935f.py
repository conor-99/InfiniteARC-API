# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 203c935f
Difficulty: easy

=== Tags ===
- Take minimum
- Size guessing
- Fill single gap
- Remove intruder

=== Description ===
The input grid consists of a single contiguous region of a base color
(represented by the minimum non-zero value present in the grid), with exactly
one empty cell (0) and exactly one intruder pixel of a different color. The
output grid is formed by replacing the intruder pixel with the base color and
filling the single empty cell with the same base color, resulting in a uniform
region of the minimum non-zero color throughout the grid. All other pixels
outside the region remain unchanged. The transformation requires identifying the
minimum non-zero color present (excluding 0), recognizing the single gap and
single intruder, and applying the color replacement rules consistently.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
def generate():
    width = random.randint(3, 10)
    height = random.randint(3, 10)
    base_color = random.randint(1, 8)
    intruder_color = random.randint(base_color + 1, 9)
    grid = [[base_color] * width for _ in range(height)]
    positions = [(i, j) for i in range(height) for j in range(width)]
    pos1, pos2 = random.sample(positions, 2)
    i1, j1 = pos1
    i2, j2 = pos2
    grid[i1][j1] = 0
    grid[i2][j2] = intruder_color
    output = [[base_color if cell == 0 or cell == intruder_color else cell for cell in row] for row in grid]
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    non_zero = set()
    for row in input_grid:
        for val in row:
            if val != 0:
                non_zero.add(val)
    base_color = min(non_zero)
    zero_pos = None
    intruder_pos = None
    for i in range(len(input_grid)):
        for j in range(len(input_grid[0])):
            if input_grid[i][j] == 0:
                zero_pos = (i, j)
            elif input_grid[i][j] != base_color:
                intruder_pos = (i, j)
    output = [row[:] for row in input_grid]
    output[zero_pos[0]][zero_pos[1]] = base_color
    output[intruder_pos[0]][intruder_pos[1]] = base_color
    return output
