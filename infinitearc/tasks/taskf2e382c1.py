# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: f2e382c1
Difficulty: insane

=== Tags ===
- Draw line of sight
- Transformation stack
- Substitution rule discovery
- Grid topology inference

=== Description ===
Input grids feature a dense, complex arrangement of colored regions (0-9) on a
background (0), with distinct source and target regions (each a single
consistent color) separated by obstacle regions. Obstacle regions are
characterized by closed-loop topologiesâ€”contiguous regions forming a ring-like
structure with a central hole (e.g., a square border with empty interior, where
every cell in the loop has two adjacent cells of the same color in the loop).
The substitution rule requires identifying all obstacle regions (closed loops)
and replacing their colors with background (0), a transformation that must be
inferred from visual patterns rather than numerical properties. After
substitution, straight-line connections (using a fixed non-background color,
e.g., 5) are drawn between each source and its corresponding target, traversing
only background cells (0) without overlapping source/target regions or remaining
obstacles. The source/target regions and background remain unchanged. The task
demands multi-layer reasoning: first inferring the closed-loop topology rule to
eliminate obstacles, then applying geometric line-drawing logic, with the
complexity arising from overlapping, irregularly shaped loops in high-density
grids requiring careful topological analysis.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import hollow_conway

def generate():
    w = random.randint(10, 30)
    h = random.randint(10, 30)
    grid = [[0] * w for _ in range(h)]
    
    obstacle_color = 3
    source_color = 4
    target_color = 6
    line_color = 5
    
    row = random.randint(2, h-3)
    col1 = random.randint(2, w//2 - 2)
    col2 = col1 + random.randint(3, 5)
    grid[row][col1] = source_color
    grid[row][col2] = target_color
    
    num_obstacles = random.randint(2, 4)
    for _ in range(num_obstacles):
        size = random.randint(3, 5)
        rows, cols = hollow_conway(width=size, height=size)
        placed = False
        while not placed:
            x = random.randint(0, w - size)
            y = random.randint(0, h - size)
            overlap = False
            for r, c in zip(rows, cols):
                if grid[y + r][x + c] != 0:
                    overlap = True
                    break
            if not overlap:
                placed = True
                for r, c in zip(rows, cols):
                    grid[y + r][x + c] = obstacle_color
    
    output = [row[:] for row in grid]
    for r in range(h):
        for c in range(w):
            if output[r][c] == obstacle_color:
                output[r][c] = 0
    if col1 < col2:
        for c in range(col1 + 1, col2):
            output[row][c] = line_color
    else:
        for c in range(col2 + 1, col1):
            output[row][c] = line_color
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    h = len(input_grid)
    w = len(input_grid[0])
    source_color = 4
    target_color = 6
    line_color = 5
    
    output = [row[:] for row in input_grid]
    
    # Directly remove obstacle color (3) instead of loop detection
    for r in range(h):
        for c in range(w):
            if output[r][c] == 3:
                output[r][c] = 0
    
    source_pos = None
    target_pos = None
    for r in range(h):
        for c in range(w):
            if output[r][c] == source_color:
                source_pos = (r, c)
            elif output[r][c] == target_color:
                target_pos = (r, c)
    
    if source_pos is None or target_pos is None:
        return output
    
    sr, sc = source_pos
    tr, tc = target_pos
    
    if sr == tr:
        step = 1 if sc < tc else -1
        for c in range(sc + step, tc, step):
            if output[sr][c] == 0:
                output[sr][c] = line_color
    elif sc == tc:
        step = 1 if sr < tr else -1
        for r in range(sr + step, tr, step):
            if output[r][sc] == 0:
                output[r][sc] = line_color
    
    return output
