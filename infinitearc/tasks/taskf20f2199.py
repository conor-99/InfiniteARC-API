# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: f20f2199
Difficulty: easy

=== Tags ===
- Detect closed curves
- Rectangle guessing
- Threshold by area
- Two color checkerboard

=== Description ===
The task involves identifying closed rectangular curves in the input grid, which
are continuous loops forming perfect rectangles with no gaps or endpoints. For
each such rectangle, the area enclosed by the loop (the number of cells inside
the rectangle's boundary) is calculated. If this area exceeds a fixed threshold
(e.g., greater than 4), the interior of the rectangle is replaced with a two-
color checkerboard pattern, alternating between two distinct colors. The output
grid retains all original elements except for the interiors of qualifying
rectangles, which are transformed into the checkerboard pattern. The threshold
value and the specific colors used for the checkerboard are consistent across
all examples, enabling solvers to infer the rule through observation of input-
output pairs. The transformation focuses purely on geometric structure and area
thresholds, avoiding reliance on numerical properties or specific color values.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid_in = grid(width, height, 0)
    
    h = random.randint(3, 30)
    w = random.randint(3, 30)
    while (h - 2) * (w - 2) <= 4 or h > height or w > width:
        h = random.randint(3, 30)
        w = random.randint(3, 30)
    
    r = random.randint(0, height - h)
    c = random.randint(0, width - w)
    
    for col in range(c, c + w):
        grid_in[r][col] = 1
    for col in range(c, c + w):
        grid_in[r + h - 1][col] = 1
    for row in range(r + 1, r + h - 1):
        grid_in[row][c] = 1
    for row in range(r + 1, r + h - 1):
        grid_in[row][c + w - 1] = 1
    
    grid_out = [row[:] for row in grid_in]
    for row in range(r + 1, r + h - 1):
        for col in range(c + 1, c + w - 1):
            if (row - r - 1 + col - c - 1) % 2 == 0:
                grid_out[row][col] = 2
            else:
                grid_out[row][col] = 3
    
    return {"input": grid_in, "output": grid_out}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to list of lists if it's a tuple
    input_grid = [list(row) for row in input_grid]
    
    positions = [(i, j) for i in range(len(input_grid)) for j in range(len(input_grid[0])) if input_grid[i][j] == 1]
    if not positions:
        return input_grid
    
    rows = [pos[0] for pos in positions]
    cols = [pos[1] for pos in positions]
    min_row, max_row = min(rows), max(rows)
    min_col, max_col = min(cols), max(cols)
    
    top_ok = all(input_grid[min_row][j] == 1 for j in range(min_col, max_col + 1))
    bottom_ok = all(input_grid[max_row][j] == 1 for j in range(min_col, max_col + 1))
    left_ok = all(input_grid[i][min_col] == 1 for i in range(min_row, max_row + 1))
    right_ok = all(input_grid[i][max_col] == 1 for i in range(min_row, max_row + 1))
    
    if top_ok and bottom_ok and left_ok and right_ok:
        interior_h = max_row - min_row - 1
        interior_w = max_col - min_col - 1
        area = interior_h * interior_w
        if area > 4:
            output = [row[:] for row in input_grid]
            for i in range(min_row + 1, max_row):
                for j in range(min_col + 1, max_col):
                    if (i - min_row - 1 + j - min_col - 1) % 2 == 0:
                        output[i][j] = 2
                    else:
                        output[i][j] = 3
            return output
    return input_grid
