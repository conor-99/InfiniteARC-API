# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: d3f51470
Difficulty: hard

=== Tags ===
- Image juxtaposition
- Skeletonization

=== Description ===
The input grids consist of multiple distinct, non-overlapping shapes (connected
regions of non-zero values) arranged in juxtaposition—typically placed side by
side horizontally or stacked vertically within the grid. Each shape is a filled
region with varying complexity, including irregular polygons, letters, or
geometric forms with thickness greater than one pixel. The output grids are
generated by applying skeletonization to each individual shape, reducing it to a
single-pixel-thick medial axis that preserves the shape's core structure and
connectivity. Skeletonization is performed through iterative edge thinning,
removing outer pixels while maintaining the central path of the shape. The
skeletons are positioned exactly where the original shapes were located,
maintaining their relative spatial arrangement in the grid. For hard difficulty,
input grids feature 3–5 complex shapes with intricate details (e.g., filled
letters like 'B' or 'E', overlapping curves, or multi-branching structures),
requiring precise identification of each shape's medial axis without distortion
or overlap in the output. The transformation is purely visual, relying on the
spatial arrangement and structural properties of the shapes rather than
numerical or positional parity.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import rand_sprite

def skeletonize_shape(shape, width, height):
    shape_grid = [[0] * width for _ in range(height)]
    for r, c in shape:
        shape_grid[r][c] = 1
    changed = True
    while changed:
        changed = False
        new_shape = [row[:] for row in shape_grid]
        for r in range(height):
            for c in range(width):
                if shape_grid[r][c] == 1:
                    neighbors = 0
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < height and 0 <= nc < width and shape_grid[nr][nc] == 1:
                            neighbors += 1
                    if neighbors < 3:
                        new_shape[r][c] = 0
                        changed = True
        shape_grid = new_shape
    skeleton = []
    for r in range(height):
        for c in range(width):
            if shape_grid[r][c] == 1:
                skeleton.append((r, c))
    return skeleton

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    input_grid = [[0] * width for _ in range(height)]
    output_grid = [[0] * width for _ in range(height)]
    num_shapes = random.randint(3, 5)
    shape_names = ['el', 'you', 'aitch']
    colors = [random.randint(1, 9) for _ in range(num_shapes)]
    
    for idx in range(num_shapes):
        name = random.choice(shape_names)
        shape = rand_sprite(name, width, height)
        color = colors[idx]
        placed = False
        for _ in range(100):
            x = random.randint(0, width - 1)
            y = random.randint(0, height - 1)
            shifted_shape = [(r + y, c + x) for r, c in shape]
            valid = all(0 <= r < height and 0 <= c < width for r, c in shifted_shape)
            if not valid:
                continue
            overlap = any(input_grid[r][c] != 0 for r, c in shifted_shape)
            if not overlap:
                for r, c in shifted_shape:
                    input_grid[r][c] = color
                placed = True
                break
        if not placed:
            x, y = 0, 0
            shifted_shape = [(r + y, c + x) for r, c in shape]
            for r, c in shifted_shape:
                if 0 <= r < height and 0 <= c < width:
                    input_grid[r][c] = color
    
    visited = [[False] * width for _ in range(height)]
    for i in range(height):
        for j in range(width):
            if input_grid[i][j] != 0 and not visited[i][j]:
                shape = []
                stack = [(i, j)]
                visited[i][j] = True
                while stack:
                    r, c = stack.pop()
                    shape.append((r, c))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                skeleton = skeletonize_shape(shape, width, height)
                color = input_grid[i][j]
                for r, c in skeleton:
                    output_grid[r][c] = color
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    def skeletonize_shape(shape, width, height):
        shape_grid = [[0] * width for _ in range(height)]
        for r, c in shape:
            shape_grid[r][c] = 1
        changed = True
        while changed:
            changed = False
            new_shape = [row[:] for row in shape_grid]
            for r in range(height):
                for c in range(width):
                    if shape_grid[r][c] == 1:
                        neighbors = 0
                        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                            nr, nc = r + dr, c + dc
                            if 0 <= nr < height and 0 <= nc < width and shape_grid[nr][nc] == 1:
                                neighbors += 1
                        if neighbors < 3:
                            new_shape[r][c] = 0
                            changed = True
            shape_grid = new_shape
        skeleton = []
        for r in range(height):
            for c in range(width):
                if shape_grid[r][c] == 1:
                    skeleton.append((r, c))
        return skeleton

    height = len(input_grid)
    width = len(input_grid[0])
    visited = [[False] * width for _ in range(height)]
    output_grid = [[0] * width for _ in range(height)]
    
    for i in range(height):
        for j in range(width):
            if input_grid[i][j] != 0 and not visited[i][j]:
                shape = []
                stack = [(i, j)]
                visited[i][j] = True
                while stack:
                    r, c = stack.pop()
                    shape.append((r, c))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                skeleton = skeletonize_shape(shape, width, height)
                color = input_grid[i][j]
                for r, c in skeleton:
                    output_grid[r][c] = color
    return output_grid
