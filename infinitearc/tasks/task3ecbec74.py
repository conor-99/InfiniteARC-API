# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 3ecbec74
Difficulty: hard

=== Tags ===
- Phase shift
- Alternating agents
- Non rectangular tiling

=== Description ===
Input grids feature a complex arrangement of non-rectangular, connected tiles
(each tile being a contiguous region of uniform color 1-9) arranged without
adjacency (separated by background color 0). Each tile's color determines its
movement direction in a cyclic phase pattern: color 1 moves right, color 2 moves
down, color 3 moves left, color 4 moves up, color 5 moves right, and so on,
cycling every four colors. The "phase shift" refers to the directional cycle
governed by color, while "alternating agents" means adjacent tiles in the grid
alternate between two movement phases (e.g., tiles of color 1 and 3 move right,
tiles of color 2 and 4 move down, with the pattern shifting per grid row or
column).   The output grid is generated by shifting all tiles' cells in their
assigned direction by one cell, with wrap-around at grid boundaries (moving off
the top edge reappears at the bottom, etc.). When multiple tiles shift into the
same cell, the cell adopts the color of the tile with the highest numeric value
(e.g., color 9 overrides color 5). Tiles that would overlap with background or
other tiles retain their color only if no collision occurs; overlapping cells
are resolved by the priority rule. Non-rectangular tile shapes (e.g., diamonds,
T-shapes, or irregular clusters) maintain connectivity during movement, and no
tile may shrink, expand, or rotateâ€”only translate.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import continuous_creature, grid

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    grid = [[0] * width for _ in range(height)]
    max_tiles = random.randint(3, 8)
    
    for _ in range(max_tiles):
        color = random.randint(1, 9)
        size = random.randint(3, 5)
        pixels = continuous_creature(size, 5, 5)
        r_shift = random.randint(0, height - 5)
        c_shift = random.randint(0, width - 5)
        shifted_pixels = [(r + r_shift, c + c_shift) for r, c in pixels]
        
        if any(r < 0 or r >= height or c < 0 or c >= width for r, c in shifted_pixels):
            continue
        
        valid = True
        for r, c in shifted_pixels:
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] > 0:
                    valid = False
                    break
            if not valid:
                break
        if not valid:
            continue
        
        for r, c in shifted_pixels:
            grid[r][c] = color
    
    if not any(grid[r][c] > 0 for r in range(height) for c in range(width)):
        return generate()
    
    output = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if grid[r][c] > 0:
                color = grid[r][c]
                dir = (color - 1) % 4
                dr, dc = [(0, 1), (1, 0), (0, -1), (-1, 0)][dir]
                nr = (r + dr) % height
                nc = (c + dc) % width
                if color > output[nr][nc]:
                    output[nr][nc] = color
    
    if grid == output:
        return generate()
    
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    output = [[0] * width for _ in range(height)]
    
    for r in range(height):
        for c in range(width):
            color = grid[r][c]
            if color > 0:
                dir = (color - 1) % 4
                dr, dc = [(0, 1), (1, 0), (0, -1), (-1, 0)][dir]
                nr = (r + dr) % height
                nc = (c + dc) % width
                if color > output[nr][nc]:
                    output[nr][nc] = color
    return output
