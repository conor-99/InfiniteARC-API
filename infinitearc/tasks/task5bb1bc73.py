# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 5bb1bc73
Difficulty: very hard

=== Tags ===
- Hollow shape detection
- Pattern rotation
- Color wavefront
- Route switching

=== Description ===
Input grids feature multiple disjoint hollow rectangles (each defined by a
closed border of a single color with empty interior), each containing a distinct
inner pattern of colored cells. The output grid transforms each hollow rectangle
through four sequential operations: (1) **Hollow Shape Detection** identifies
all closed borders with empty interiors; (2) **Pattern Rotation** rotates the
inner pattern (all cells inside the border) 90Â° clockwise while preserving the
border; (3) **Color Wavefront** propagates a color incrementing wave (mod 9)
from the top-left interior cell, filling the entire interior by moving through
adjacent cells (up/down/left/right) that were part of the original inner
pattern; (4) **Route Switching** modifies the wave's trajectory at each cell,
turning left for even color values and right for odd values relative to the
current propagation direction. Non-hollow regions and border positions remain
unchanged, with all transformations applied independently to each hollow
rectangle.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Generator for ARC task 494: create grids with disjoint hollow square borders
# Each border encloses an N x N interior. Inside the interior we place a connected
# pattern of colored cells (colors != border color). The output rotates the entire
# interior 90 deg clockwise and then performs a wave-fill over the rotated positions
# that correspond to the original (pre-rotation) nonzero pattern cells.


def _rotate_square(square):
    # square: list of N rows each of length N
    # rotate 90 degrees clockwise
    return [list(row) for row in zip(*square[::-1])]


def _generate_connected_pattern(N, size):
    # Generate a connected 4-neighbor pattern of 'size' cells inside an N x N grid.
    if size <= 0:
        return set()
    all_coords = [(r, c) for r in range(N) for c in range(N)]
    # start in a random cell
    start = (random.randint(0, N - 1), random.randint(0, N - 1))
    pattern = [start]
    pattern_set = set(pattern)
    # frontier of candidate neighbors
    frontier = set()
    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
        nr, nc = start[0] + dr, start[1] + dc
        if 0 <= nr < N and 0 <= nc < N:
            frontier.add((nr, nc))
    while len(pattern_set) < size:
        if frontier:
            nxt = random.choice(list(frontier))
            frontier.discard(nxt)
        else:
            # As a fallback, pick any neighbor of the pattern that isn't already used
            choices = []
            for (pr, pc) in list(pattern_set):
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = pr + dr, pc + dc
                    if 0 <= nr < N and 0 <= nc < N and (nr, nc) not in pattern_set:
                        choices.append((nr, nc))
            if not choices:
                break
            nxt = random.choice(choices)
        pattern_set.add(nxt)
        # add its neighbors to the frontier
        r, c = nxt
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < N and 0 <= nc < N and (nr, nc) not in pattern_set:
                frontier.add((nr, nc))
    return pattern_set


def generate():
    # Grid size
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    inp = grid(width, height, 0)

    rectangles = []  # store (r, c, size, border_color)
    used_border_colors = set()
    attempts = 0
    num_rects = random.randint(1, 3)
    max_attempts = 500
    while len(rectangles) < num_rects and attempts < max_attempts:
        attempts += 1
        # choose an interior square size (N x N) between 2 and 6 but bounded by grid
        max_inner = min(6, height - 2, width - 2)
        if max_inner < 2:
            break
        inner_n = random.randint(2, max_inner)
        h = inner_n + 2
        w = inner_n + 2
        r = random.randint(0, height - h)
        c = random.randint(0, width - w)
        # check non-overlap: entire rectangle area must be 0
        ok = True
        for rr in range(r, r + h):
            for cc in range(c, c + w):
                if inp[rr][cc] != 0:
                    ok = False
                    break
            if not ok:
                break
        if not ok:
            continue
        # pick a border color not used previously to make detection unambiguous
        choices = [col for col in range(1, 10) if col not in used_border_colors]
        if not choices:
            choices = list(range(1, 10))
        border_color = random.choice(choices)
        used_border_colors.add(border_color)
        # draw border
        for cc in range(c, c + w):
            inp[r][cc] = border_color
            inp[r + h - 1][cc] = border_color
        for rr in range(r, r + h):
            inp[rr][c] = border_color
            inp[rr][c + w - 1] = border_color

        # create a connected inner pattern (nonzero cells inside the interior)
        inner_coords = [(r + 1 + i, c + 1 + j) for i in range(inner_n) for j in range(inner_n)]
        # choose pattern size at least 1
        pattern_size = random.randint(1, inner_n * inner_n)
        rel_pattern = _generate_connected_pattern(inner_n, pattern_size)
        # assign random colors (not equal to border color)
        colors_pool = [col for col in range(1, 10) if col != border_color]
        for (ir, ic) in rel_pattern:
            ar = r + 1 + ir
            ac = c + 1 + ic
            inp[ar][ac] = random.choice(colors_pool)

        rectangles.append((r, c, inner_n, border_color))

    # Build output by applying the described transformation to each rectangle
    out = [row[:] for row in inp]

    for (r, c, inner_n, border_color) in rectangles:
        # extract interior square
        interior = [inp[r + 1 + i][c + 1:c + 1 + inner_n] for i in range(inner_n)]
        # rotate interior 90 deg clockwise
        rotated = _rotate_square(interior)
        # place rotated into output
        for i in range(inner_n):
            for j in range(inner_n):
                out[r + 1 + i][c + 1 + j] = rotated[i][j]

        # collect original pattern positions (nonzero in original interior)
        orig_positions = []
        for i in range(inner_n):
            for j in range(inner_n):
                if interior[i][j] != 0:
                    # absolute position of this cell in the original interior
                    orig_positions.append((r + 1 + i, c + 1 + j))
        if not orig_positions:
            continue
        # map original pattern positions to their rotated absolute positions
        allowed = set()
        for (ar, ac) in orig_positions:
            rel_r = ar - (r + 1)
            rel_c = ac - (c + 1)
            new_rel_r = rel_c
            new_rel_c = inner_n - 1 - rel_r
            new_abs = (r + 1 + new_rel_r, c + 1 + new_rel_c)
            allowed.add(new_abs)

        # perform a DFS-like visit ordering. The neighbor order depends on the parity of
        # the wave color assigned at the current cell: even -> prefer left, odd -> prefer right.
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up
        # start at top-leftmost allowed cell
        start = min(allowed)
        visited_order = {}
        counter = 0

        def dfs(pos, dir_idx):
            nonlocal counter
            if pos in visited_order:
                return
            counter += 1
            # colors cycle 1..9
            visited_order[pos] = ((counter - 1) % 9) + 1
            wave_color = visited_order[pos]
            # determine neighbor preference
            if wave_color % 2 == 0:
                order = [ (dir_idx - 1) % 4, dir_idx, (dir_idx + 1) % 4, (dir_idx + 2) % 4 ]
            else:
                order = [ (dir_idx + 1) % 4, dir_idx, (dir_idx - 1) % 4, (dir_idx + 2) % 4 ]
            for d2 in order:
                nr = pos[0] + directions[d2][0]
                nc = pos[1] + directions[d2][1]
                if (nr, nc) in allowed and (nr, nc) not in visited_order:
                    dfs((nr, nc), d2)

        dfs(start, 0)

        # write colors into output for the visited allowed positions
        for (pr, pc), val in visited_order.items():
            out[pr][pc] = val

    return {"input": inp, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable grid
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    rectangles = []  # list of (top, left, inner_n, border_color)

    # Scan for square hollow borders by treating each cell as a potential top-left corner
    for r in range(height):
        for c in range(width):
            col = grid[r][c]
            if col == 0:
                continue
            # try sizes (square) from 3 up to fit
            max_s = min(height - r, width - c)
            found = False
            for s in range(3, max_s + 1):
                # check perimeter all equal to col
                ok = True
                for cc in range(c, c + s):
                    if grid[r][cc] != col or grid[r + s - 1][cc] != col:
                        ok = False
                        break
                if not ok:
                    continue
                for rr in range(r, r + s):
                    if grid[rr][c] != col or grid[rr][c + s - 1] != col:
                        ok = False
                        break
                if not ok:
                    continue
                # interior should not contain border color and must contain at least one non-zero
                interior_has_nonzero = False
                interior_ok = True
                for rr in range(r + 1, r + s - 1):
                    for cc in range(c + 1, c + s - 1):
                        if grid[rr][cc] == col:
                            interior_ok = False
                            break
                        if grid[rr][cc] != 0:
                            interior_has_nonzero = True
                    if not interior_ok:
                        break
                if not interior_ok or not interior_has_nonzero:
                    continue
                # record this rectangle (square interior size s-2)
                rectangles.append((r, c, s - 2, col))
                found = True
                break
            # continue scanning; we don't zero-out cells because rectangles are disjoint in the generator

    # produce output
    out = [row[:] for row in grid]

    def rotate_square(square):
        return [list(row) for row in zip(*square[::-1])]

    for (r, c, inner_n, border_color) in rectangles:
        # extract interior
        interior = [grid[r + 1 + i][c + 1:c + 1 + inner_n] for i in range(inner_n)]
        # rotate 90 degrees clockwise
        rotated = rotate_square(interior)
        # place rotated into out
        for i in range(inner_n):
            for j in range(inner_n):
                out[r + 1 + i][c + 1 + j] = rotated[i][j]
        # find original pattern cells (nonzero in original interior)
        orig_positions = []
        for i in range(inner_n):
            for j in range(inner_n):
                if interior[i][j] != 0:
                    orig_positions.append((r + 1 + i, c + 1 + j))
        if not orig_positions:
            continue
        # map original positions to rotated absolute positions
        allowed = set()
        for (ar, ac) in orig_positions:
            rel_r = ar - (r + 1)
            rel_c = ac - (c + 1)
            new_rel_r = rel_c
            new_rel_c = inner_n - 1 - rel_r
            allowed.add((r + 1 + new_rel_r, c + 1 + new_rel_c))

        # DFS visit ordering with turning preference
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        start = min(allowed)
        visited_order = {}
        counter = 0

        def dfs(pos, dir_idx):
            nonlocal counter
            if pos in visited_order:
                return
            counter += 1
            visited_order[pos] = ((counter - 1) % 9) + 1
            wave_color = visited_order[pos]
            if wave_color % 2 == 0:
                order = [ (dir_idx - 1) % 4, dir_idx, (dir_idx + 1) % 4, (dir_idx + 2) % 4 ]
            else:
                order = [ (dir_idx + 1) % 4, dir_idx, (dir_idx - 1) % 4, (dir_idx + 2) % 4 ]
            for d2 in order:
                nr = pos[0] + directions[d2][0]
                nc = pos[1] + directions[d2][1]
                if (nr, nc) in allowed and (nr, nc) not in visited_order:
                    dfs((nr, nc), d2)

        dfs(start, 0)
        # write assigned colors into out
        for (pr, pc), val in visited_order.items():
            out[pr][pc] = val

    return tuple(tuple(row) for row in out)

