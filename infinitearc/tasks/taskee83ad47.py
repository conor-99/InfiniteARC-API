# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: ee83ad47
Difficulty: hard

=== Tags ===
- Meta rule learning
- Terrain erosion
- Place dot in object center

=== Description ===
Input grids feature multiple disconnected colored objects (each a connected
region of a single non-background color) on a uniform background. The
transformation applies two key processes: first, each object undergoes terrain
erosion based on a hidden meta rule that requires visual symmetry detection;
second, a distinct marker is placed at the original object's geometric center.
For the erosion step, objects exhibiting visual symmetry (reflection symmetry
across horizontal/vertical axes or rotational symmetry) are eroded twice (each
step removes boundary pixels adjacent to background), while asymmetric objects
are eroded once. The geometric center is calculated as the average of all
coordinates in the original object (rounded to nearest grid cell). After
erosion, a marker (color 9) is placed at this center position, regardless of the
object's post-erosion shape. The meta rule (symmetry → 2 steps, asymmetry → 1
step) must be inferred from input-output examples, as it is not explicitly
visible in the grids. The output grid retains all background elements unchanged,
with only the eroded objects and center markers modified.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    import common
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = common.grid(width, height, 0)
    num_objects = random.randint(2, 5)
    colors = common.random_colors(num_objects, exclude=[0])
    used_colors = set()
    for i in range(num_objects):
        color = colors[i]
        used_colors.add(color)
        symmetric = random.choice([True, False])
        if symmetric:
            sprite_name = 'you'
        else:
            sprite_name = 'el'
        pixels = common.rand_sprite(sprite_name, width, height)
        for (r, c) in pixels:
            if r < height and c < width:
                grid[r][c] = color
    output_grid = common.grid(width, height, 0)
    for color in used_colors:
        object_pixels = []
        for r in range(height):
            for c in range(width):
                if grid[r][c] == color:
                    object_pixels.append((r, c))
        if not object_pixels:
            continue
        H, W = height, width
        horizontal_sym = all((r, W-1 - c) in object_pixels for (r, c) in object_pixels)
        vertical_sym = all((H-1 - r, c) in object_pixels for (r, c) in object_pixels)
        rotational_sym = all((H-1 - r, W-1 - c) in object_pixels for (r, c) in object_pixels)
        symmetric = horizontal_sym or vertical_sym or rotational_sym
        steps = 2 if symmetric else 1
        total_r = sum(r for r, c in object_pixels)
        total_c = sum(c for r, c in object_pixels)
        center_r = round(total_r / len(object_pixels))
        center_c = round(total_c / len(object_pixels))
        center_r = max(0, min(center_r, height - 1))
        center_c = max(0, min(center_c, width - 1))
        current_object = object_pixels[:]
        for _ in range(steps):
            to_remove = []
            for (r, c) in current_object:
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0:
                        to_remove.append((r, c))
                        break
            current_object = [p for p in current_object if p not in to_remove]
        for (r, c) in current_object:
            output_grid[r][c] = color
        output_grid[int(center_r)][int(center_c)] = 9
    return {"input": grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    import common
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = common.grid(width, height, 0)
    visited = [[False] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and input_grid[r][c] != 0:
                color = input_grid[r][c]
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                H, W = height, width
                horizontal_sym = all((cr, W-1 - cc) in component for (cr, cc) in component)
                vertical_sym = all((H-1 - cr, cc) in component for (cr, cc) in component)
                rotational_sym = all((H-1 - cr, W-1 - cc) in component for (cr, cc) in component)
                symmetric = horizontal_sym or vertical_sym or rotational_sym
                steps = 2 if symmetric else 1
                total_r = sum(cr for cr, cc in component)
                total_c = sum(cc for cr, cc in component)
                center_r = round(total_r / len(component))
                center_c = round(total_c / len(component))
                center_r = max(0, min(center_r, height - 1))
                center_c = max(0, min(center_c, width - 1))
                current_component = component[:]
                for _ in range(steps):
                    to_remove = []
                    for (cr, cc) in current_component:
                        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 0:
                                to_remove.append((cr, cc))
                                break
                    current_component = [p for p in current_component if p not in to_remove]
                for (cr, cc) in current_component:
                    output_grid[cr][cc] = color
                output_grid[int(center_r)][int(center_c)] = 9
    return output_grid
