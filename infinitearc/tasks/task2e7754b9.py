# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 2e7754b9
Difficulty: insane

=== Tags ===
- Local rule cascade
- Encircle all pixels of one color
- Project shadow

=== Description ===
Input grids consist of a background color and a single non-background color
arranged in a complex, disconnected pattern. The output grid must encircle all
pixels of the non-background color with a shadow border. This is achieved by
converting all background pixels adjacent (horizontally or vertically) to any
non-background pixel into a distinct shadow color, forming a continuous border
around every cluster of the non-background color. The shadow border merges
seamlessly where clusters are close, creating a single encircling effect that
precisely surrounds all non-background pixels without gaps or overlaps. The
transformation requires a cascade of local rules: identifying the non-background
color, checking adjacent pixels, and applying the shadow conversion consistently
across the grid, demanding careful attention to the intricate spatial
relationships between the non-background pixels.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_pixels

def generate():
    while True:
        width = random.randint(2, 30)
        height = random.randint(2, 30)
        input_grid = grid(width, height, 0)
        pixels = random_pixels(width, height, prob=0.3)
        for r, c in pixels:
            input_grid[r][c] = 1
        has_zero = any(0 in row for row in input_grid)
        has_adjacent = False
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == 0:
                    if (r > 0 and input_grid[r-1][c] == 1) or \
                       (r < height-1 and input_grid[r+1][c] == 1) or \
                       (c > 0 and input_grid[r][c-1] == 1) or \
                       (c < width-1 and input_grid[r][c+1] == 1):
                        has_adjacent = True
                        break
            if has_adjacent:
                break
        if has_zero and has_adjacent:
            break
    output_grid = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                if (r > 0 and input_grid[r-1][c] == 1) or \
                   (r < height-1 and input_grid[r+1][c] == 1) or \
                   (c > 0 and input_grid[r][c-1] == 1) or \
                   (c < width-1 and input_grid[r][c+1] == 1):
                    output_grid[r][c] = 9
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    rows = len(grid)
    cols = len(grid[0])
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 0:
                if (r > 0 and grid[r-1][c] == 1) or \
                   (r < rows-1 and grid[r+1][c] == 1) or \
                   (c > 0 and grid[r][c-1] == 1) or \
                   (c < cols-1 and grid[r][c+1] == 1):
                    grid[r][c] = 9
    return tuple(tuple(row) for row in grid)
