# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 404653b9
Difficulty: insane

=== Tags ===
- Gravity
- Ex nihilo
- Pattern completion
- Image resizing

=== Description ===
The input grids depict partial geometric patterns composed of distinct colors on
a 0-background. Each input grid undergoes a sequence of deterministic
transformations to generate the output. First, the grid is vertically flipped
(gravity effect), creating a mirrored arrangement of the pattern. Next, the grid
is scaled up by a factor of two in both dimensions (image resizing), where each
input cell expands into a 2×2 block of identical color. The scaled grid then
undergoes pattern completion: missing segments of the geometric shape are
inferred and filled in to form a symmetric whole (e.g., completing a diagonal
line into a cross or a partial circle into a full circle). Crucially, the newly
added segments use a color not present in the original input (ex nihilo),
ensuring the output contains novel visual elements not derived from the input’s
color palette. For instance, an input with a single diagonal line of color 1
becomes a cross in the output, with the second diagonal rendered in a new color
(e.g., 4), while all other elements maintain their original colors and symmetry.
This task demands recognition of geometric symmetry, precise scaling, and
creative color introduction to complete the pattern.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_color

def generate():
    size = random.randint(3, 15)
    base_color = random_color(exclude=[0])
    pattern_type = random.choice(["main", "anti"])
    input_grid = grid(size, size, 0)
    if pattern_type == "main":
        for i in range(size):
            input_grid[i][i] = base_color
    else:
        for i in range(size):
            input_grid[i][size - 1 - i] = base_color
    flipped = input_grid[::-1]
    output_size = size * 2
    scaled = grid(output_size, output_size, 0)
    for r in range(size):
        for c in range(size):
            color = flipped[r][c]
            for dr in range(2):
                for dc in range(2):
                    scaled[r*2 + dr][c*2 + dc] = color
    new_color = 1
    while new_color == base_color:
        new_color += 1
    for i in range(0, output_size, 2):
        if all(scaled[i + dr][i + dc] == 0 for dr in range(2) for dc in range(2)):
            for dr in range(2):
                for dc in range(2):
                    scaled[i + dr][i + dc] = new_color
    return {
        "input": input_grid,
        "output": scaled
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    size = len(input_grid)
    flipped = input_grid[::-1]
    output_size = size * 2
    scaled = grid(output_size, output_size, 0)
    for r in range(size):
        for c in range(size):
            color = flipped[r][c]
            for dr in range(2):
                for dc in range(2):
                    scaled[r*2 + dr][c*2 + dc] = color
    input_colors = set()
    for row in input_grid:
        for color in row:
            if color != 0:
                input_colors.add(color)
    new_color = 1
    while new_color <= 9:
        if new_color not in input_colors:
            break
        new_color += 1
    for i in range(0, output_size, 2):
        if all(scaled[i + dr][i + dc] == 0 for dr in range(2) for dc in range(2)):
            for dr in range(2):
                for dc in range(2):
                    scaled[i + dr][i + dc] = new_color
    return scaled
