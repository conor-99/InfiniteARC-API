# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 586decb7
Difficulty: medium–hard

=== Tags ===
- Impact highlight
- Detect enclosure
- Gravity with barriers

=== Description ===
The input grid features a background, barriers (solid lines or blocks), and
particles (small colored markers). Particles are subject to gravity, moving
downward until they collide with a barrier. Upon collision, the barrier cell is
highlighted with a distinct color. Additionally, the grid contains enclosed
regions—background areas completely surrounded by barriers with no connection to
the grid's edges. The barriers forming the boundary of each enclosed region are
highlighted with a second distinct color. The output grid reflects these two
types of highlights: collision points (where particles hit barriers) and
enclosure boundaries (barriers surrounding enclosed background areas), while all
other elements remain unchanged. The transformation requires identifying both
particle trajectories under gravity and connected background regions to
determine enclosure boundaries, making it a medium-hard task that combines
dynamic movement with topological analysis.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random
def generate():
    width = random.randint(6, 30)
    height = random.randint(6, 30)
    grid = common.grid(width, height, 0)
    
    r1 = random.randint(2, height - 4)
    r2 = random.randint(r1 + 2, height - 2)
    c1 = random.randint(2, width - 4)
    c2 = random.randint(c1 + 2, width - 2)
    
    for c in range(c1, c2 + 1):
        grid[r1][c] = 2
        grid[r2][c] = 2
    for r in range(r1 + 1, r2):
        grid[r][c1] = 2
        grid[r][c2] = 2
    
    num_particles = random.randint(1, 3)
    for _ in range(num_particles):
        c = random.randint(c1, c2)
        r = random.randint(0, r1 - 1)
        grid[r][c] = 1
    
    output = [row[:] for row in grid]
    
    # Find collision cells
    collision_cells = set()
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 1:
                for down in range(r, height):
                    if grid[down][c] == 2:
                        collision_cells.add((down, c))
                        break
    
    # Find enclosure boundaries (correctly)
    enclosure_boundaries = set()
    for r in range(r1 + 1, r2):
        for c in range(c1 + 1, c2):
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 2:
                    enclosure_boundaries.add((nr, nc))
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 1:
                output[r][c] = 0
            if grid[r][c] == 2:
                if (r, c) in collision_cells:
                    output[r][c] = 4
                elif (r, c) in enclosure_boundaries:
                    output[r][c] = 5
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    
    width = len(input_grid[0])
    height = len(input_grid)
    
    visited = [[False] * width for _ in range(height)]
    from collections import deque
    queue = deque()
    
    for r in range(height):
        for c in [0, width - 1]:
            if input_grid[r][c] == 0 and not visited[r][c]:
                visited[r][c] = True
                queue.append((r, c))
    for c in range(width):
        for r in [0, height - 1]:
            if input_grid[r][c] == 0 and not visited[r][c]:
                visited[r][c] = True
                queue.append((r, c))
    
    while queue:
        r, c = queue.popleft()
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width:
                if input_grid[nr][nc] == 0 and not visited[nr][nc]:
                    visited[nr][nc] = True
                    queue.append((nr, nc))
    
    enclosed_background = set()
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0 and not visited[r][c]:
                enclosed_background.add((r, c))
    
    enclosure_boundaries = set()
    for r, c in enclosed_background:
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 2:
                enclosure_boundaries.add((nr, nc))
    
    collision_cells = set()
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 1:
                for down in range(r, height):
                    if input_grid[down][c] == 2:
                        collision_cells.add((down, c))
                        break
    
    output = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 1:
                output[r][c] = 0
            if input_grid[r][c] == 2:
                if (r, c) in collision_cells:
                    output[r][c] = 4
                elif (r, c) in enclosure_boundaries:
                    output[r][c] = 5
    return output
