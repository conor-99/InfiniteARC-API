# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 0fb29cb2
Difficulty: mediumâ€“hard

=== Tags ===
- Periodic reflection
- Surface unfolding
- Sequence interpolation
- Gate chain construction
- Cluster by shape

=== Description ===
Input grids contain a sequence of distinct, shape-based clusters (connected
regions of uniform color) arranged in a compact, folded pattern along a central
axis. Each cluster represents a "gate" with a unique geometric shape (e.g., L,
T, or square), and the clusters are positioned such that the sequence folds back
on itself, creating a nested or layered arrangement. The output grid must
"unfold" this sequence into a linear chain by applying periodic reflections:
each subsequent cluster is reflected across the previous cluster's orientation,
with the reflection direction alternating between horizontal and vertical every
two clusters (e.g., first reflection horizontal, second vertical, third
horizontal, etc.). The unfolding process interpolates between cluster shapes
through reflection (e.g., an L-shaped cluster transitions to a T-shaped cluster
via a vertical reflection), ensuring seamless continuity in the chain. Clusters
are grouped by their original shape in the output (all L-shapes adjacent, all
T-shapes adjacent, etc.), maintaining the unfolded sequence without overlaps or
gaps. The final output displays a continuous, non-overlapping chain where each
cluster's orientation and position are determined by the periodic reflection
pattern, and shape transitions follow the interpolation rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

# Generator for ARC task 471 (folded gate chain -> unfolded chain)
# Creates n (3..5) gate clusters using common.rand_sprite with tile size 5.
# Places them in a folded stack: rows increase with clusters alternating left/right
# around a central axis. The output is an unfolded linear chain: clusters are
# grouped by their shape (order of first appearance) and placed left-to-right.
# Each cluster after the first is reflected alternately: first reflection is
# horizontal, second vertical, third horizontal, etc.

def generate():
    tile = 5
    n = random.randint(3, 5)
    shape_names = ["el", "aitch", "you"]

    # pick unique colors for the clusters (non-zero)
    colors = common.random_colors(n, exclude=[0])

    clusters = []
    for i in range(n):
        shape = common.choice(shape_names)
        # rand_sprite returns a list of (r,c) coordinates inside a tile x tile box
        pixels = common.rand_sprite(shape, tile, tile)
        # deduplicate and sort for stability
        pixels = sorted(set(pixels))
        clusters.append({
            'shape': shape,
            'pixels': pixels,
            'color': colors[i]
        })

    # Build input grid: folded stack with alternating left/right placement
    in_w = 3 * tile
    in_h = tile * n
    input_grid = common.grid(in_w, in_h, 0)

    for i, cl in enumerate(clusters):
        top = i * tile
        # alternate left (0) and right (2*tile) columns around central axis (tile)
        leftcol = 0
        rightcol = 2 * tile
        col = leftcol if (i % 2 == 0) else rightcol
        for pr, pc in cl['pixels']:
            input_grid[top + pr][col + pc] = cl['color']

    # Build output grid: group clusters by shape (order of first appearance),
    # then lay them out left-to-right with periodic reflections
    groups = []
    group_map = {}
    for idx, cl in enumerate(clusters):
        s = cl['shape']
        if s not in group_map:
            group_map[s] = []
            groups.append(s)
        group_map[s].append(idx)

    cluster_order = []
    for s in groups:
        cluster_order.extend(group_map[s])

    out_w = tile * n
    out_h = tile
    output_grid = common.grid(out_w, out_h, 0)

    for j, idx in enumerate(cluster_order):
        cl = clusters[idx]
        pixels = cl['pixels']
        color = cl['color']
        # normalize pixels to their local bounding box (top-left = 0,0)
        minr = min(p[0] for p in pixels)
        minc = min(p[1] for p in pixels)
        maxr = max(p[0] for p in pixels)
        maxc = max(p[1] for p in pixels)
        bbox_h = maxr - minr + 1
        bbox_w = maxc - minc + 1
        norm = [(p[0] - minr, p[1] - minc) for p in pixels]

        if j == 0:
            new_pixels = norm
        else:
            # alternate: odd j -> horizontal reflection; even j -> vertical reflection
            if j % 2 == 1:
                # horizontal: mirror left-right inside bounding box
                new_pixels = [(r, (bbox_w - 1) - c) for (r, c) in norm]
            else:
                # vertical: mirror top-bottom inside bounding box
                new_pixels = [((bbox_h - 1) - r, c) for (r, c) in norm]
        # ensure anchored at 0,0 (should already be), but normalize just in case
        minr2 = min(r for r, c in new_pixels)
        minc2 = min(c for r, c in new_pixels)
        new_pixels = [(r - minr2, c - minc2) for (r, c) in new_pixels]

        col_off = j * tile
        for r, c in new_pixels:
            # place into output tile row r and column col_off + c
            output_grid[r][col_off + c] = color

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    import common
    # convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0])

    # extract connected components (clusters) by color
    visited = [[False] * W for _ in range(H)]
    clusters = []  # each: dict with color and pixels (absolute coords)
    for r in range(H):
        for c in range(W):
            if grid[r][c] != 0 and not visited[r][c]:
                color = grid[r][c]
                q = [(r, c)]
                visited[r][c] = True
                comp = []
                while q:
                    pr, pc = q.pop(0)
                    comp.append((pr, pc))
                    for dr, dc in ((1,0), (-1,0), (0,1), (0,-1)):
                        nr, nc = pr + dr, pc + dc
                        if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            q.append((nr, nc))
                clusters.append({'color': color, 'pixels': comp})

    # sort clusters by their top-left (min row, min col) to recover original input order
    clusters.sort(key=lambda cl: (min(p[0] for p in cl['pixels']), min(p[1] for p in cl['pixels'])))

    n = len(clusters)
    tile = 5

    # build canonical templates for the three shapes and precompute all normalized transforms
    el_template = set(common.random_el(tile, tile))
    you_template = set(common.random_you(tile, tile))
    aitch_template = set(common.random_aitch(tile, tile))

    def all_normalized_transforms(pixels):
        # pixels: set of (r,c) inside tile x tile
        res = set()
        size = tile
        for flip in (False, True):
            for rot in range(4):
                pts = []
                for r, c in pixels:
                    rr, cc = r, c
                    if flip:
                        cc = size - 1 - cc
                    # apply rotation rot times (90 degrees each)
                    for _ in range(rot):
                        rr, cc = cc, size - 1 - rr
                    pts.append((rr, cc))
                # normalize top-left -> (0,0)
                minr = min(p[0] for p in pts)
                minc = min(p[1] for p in pts)
                norm = frozenset(((p[0] - minr, p[1] - minc) for p in pts))
                res.add(norm)
        return res

    el_transforms = all_normalized_transforms(el_template)
    you_transforms = all_normalized_transforms(you_template)
    aitch_transforms = all_normalized_transforms(aitch_template)

    # classify each cluster by matching normalized pixel pattern to templates
    shapes = []
    for cl in clusters:
        pixels = cl['pixels']
        minr = min(p[0] for p in pixels)
        minc = min(p[1] for p in pixels)
        norm = frozenset(((p[0] - minr, p[1] - minc) for p in pixels))
        if norm in el_transforms:
            shapes.append('el')
        elif norm in you_transforms:
            shapes.append('you')
        elif norm in aitch_transforms:
            shapes.append('aitch')
        else:
            # fallback: decide by simple heuristic (shouldn't be needed)
            # use distinct counts of columns or rows
            rows = set(p[0] for p in pixels)
            cols = set(p[1] for p in pixels)
            if len(cols) <= 2:
                shapes.append('you')
            else:
                shapes.append('el')

    # group clusters by shape in order of first appearance
    group_map = {}
    order_shapes = []
    for i, s in enumerate(shapes):
        if s not in group_map:
            group_map[s] = []
            order_shapes.append(s)
        group_map[s].append(i)

    cluster_order = []
    for s in order_shapes:
        cluster_order.extend(group_map[s])

    # build output grid: tile height, n * tile width
    out_h = tile
    out_w = tile * n
    out = [[0] * out_w for _ in range(out_h)]

    for j, idx in enumerate(cluster_order):
        cl = clusters[idx]
        color = cl['color']
        pixels = cl['pixels']
        # normalize to local bounding box
        minr = min(p[0] for p in pixels)
        minc = min(p[1] for p in pixels)
        norm = [(p[0] - minr, p[1] - minc) for p in pixels]
        maxr = max(p[0] for p in norm)
        maxc = max(p[1] for p in norm)
        bbox_h = maxr + 1
        bbox_w = maxc + 1

        if j == 0:
            new_pixels = norm
        else:
            if j % 2 == 1:
                # horizontal reflection inside bounding box
                new_pixels = [(r, (bbox_w - 1) - c) for (r, c) in norm]
            else:
                # vertical reflection inside bounding box
                new_pixels = [((bbox_h - 1) - r, c) for (r, c) in norm]
        # anchor
        minr2 = min(r for r, c in new_pixels)
        minc2 = min(c for r, c in new_pixels)
        new_pixels = [(r - minr2, c - minc2) for (r, c) in new_pixels]

        col_off = j * tile
        for r, c in new_pixels:
            out[r][col_off + c] = color

    # return as tuple of tuples
    return tuple(tuple(row) for row in out)

