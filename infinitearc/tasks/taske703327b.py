# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: e703327b
Difficulty: mediumâ€“hard

=== Tags ===
- Beam reflection
- Hierarchical reasoning

=== Description ===
**Task Name: Beam Reflection Hierarchy**   **Tags:** Beam reflection,
Hierarchical reasoning    **Description:**    Input grids feature a single
background color, with beams of distinct colors emanating from the grid's edges
as straight lines. These beams travel inward until encountering surface
elements, each represented by a unique color that determines the beam's behavior
upon contact. The surface types are:    - **Mirror surfaces (green)**: Reflect
beams at a 90-degree angle (e.g., a horizontal beam becomes vertical after
reflection).   - **Corner surfaces (yellow)**: Reflect beams at 180 degrees
(e.g., a horizontal beam continues horizontally but in the opposite direction).
- **Absorbing surfaces (purple)**: Terminate beams immediately; no further path
is drawn.   - **Transparent surfaces (cyan)**: Allow beams to pass through
unchanged, continuing their path without modification.    The output grid must
depict the complete path of each beam after all reflections, with beams
maintaining their original color throughout their trajectory. Beams that
encounter an absorbing surface are shown only up to the point of absorption.
Transparent surfaces do not alter the beam's path or color. Beams originating
from different edges interact only with surfaces, passing through each other
without interference.    Hierarchical reasoning is required to process the
sequence of surface interactions for each beam. For example, a beam reflecting
off a mirror surface (green) may subsequently encounter a corner surface
(yellow), which requires applying two reflection rules in sequence. The
complexity increases with the number of sequential reflections and the
arrangement of surface types. The task demands careful step-by-step tracking of
beam direction changes at each surface, ensuring all reflections are accurately
represented in the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Grid size
    width = random.randint(8, 20)
    height = random.randint(8, 20)
    input_grid = grid(width, height, 0)
    output_grid = grid(width, height, 0)

    # Surface color mapping (chosen to match the task description semantics)
    MIRROR = 3        # green-like
    CORNER = 4        # yellow-like
    ABSORB = 6        # purple/pink-like
    TRANSPARENT = 8   # cyan-like
    surface_colors = {MIRROR, CORNER, ABSORB, TRANSPARENT}

    # Choose beam colors distinct from surfaces and background
    possible_beam_colors = [c for c in range(1, 10) if c not in surface_colors]
    num_beams = random.randint(2, 4)
    beam_colors = random.sample(possible_beam_colors, num_beams)

    occupied_surfaces = set()
    beam_origins = []  # store tuples (r, c, dr, dc, color)

    for i in range(num_beams):
        # Pick a unique origin on an edge (avoid corners to keep direction unambiguous)
        attempts = 0
        while True:
            attempts += 1
            if attempts > 200:
                break
            side = random.choice(['top', 'bottom', 'left', 'right'])
            if side == 'top':
                r = 0
                c = random.randint(1, max(1, width - 2))
                dr, dc = 1, 0
            elif side == 'bottom':
                r = height - 1
                c = random.randint(1, max(1, width - 2))
                dr, dc = -1, 0
            elif side == 'left':
                c = 0
                r = random.randint(1, max(1, height - 2))
                dr, dc = 0, 1
            else:  # right
                c = width - 1
                r = random.randint(1, max(1, height - 2))
                dr, dc = 0, -1

            # Make sure we don't reuse an origin
            if any(r == bo[0] and c == bo[1] for bo in beam_origins):
                continue
            # Don't start on a surface
            if (r, c) in occupied_surfaces:
                continue
            break

        color = beam_colors[i]
        beam_origins.append((r, c, dr, dc, color))

        # Build a sequence of surfaces that this beam will encounter. We place them
        # explicitly so that the beam will reflect according to the rules.
        cur_r, cur_c, cur_dr, cur_dc = r, c, dr, dc
        seq_len = random.randint(1, 3)
        for _ in range(seq_len):
            # Maximum distance from current position to a legal interior surface (not on edge)
            if cur_dr == 1:
                max_dist = height - cur_r - 2
            elif cur_dr == -1:
                max_dist = cur_r - 1
            elif cur_dc == 1:
                max_dist = width - cur_c - 2
            else:  # cur_dc == -1
                max_dist = cur_c - 1

            if max_dist < 1:
                break

            # Try a few times to pick a free interior cell on this ray
            placed = False
            for _try in range(40):
                dist = random.randint(1, max_dist)
                new_r = cur_r + cur_dr * dist
                new_c = cur_c + cur_dc * dist
                # Ensure interior (not on edge) and not already a surface
                if new_r == 0 or new_r == height - 1 or new_c == 0 or new_c == width - 1:
                    continue
                if (new_r, new_c) in occupied_surfaces:
                    continue
                placed = True
                break
            if not placed:
                break

            # Choose surface type with some weighting so mirrors/corners are common
            surface_type = random.choices([MIRROR, CORNER, ABSORB, TRANSPARENT], weights=[3, 3, 2, 2])[0]
            input_grid[new_r][new_c] = surface_type
            occupied_surfaces.add((new_r, new_c))

            # Update direction according to the encountered surface
            if surface_type == ABSORB:
                # Beam stops here; no further surfaces for this beam
                cur_r, cur_c = new_r, new_c
                break
            elif surface_type == MIRROR:
                # Rotate direction clockwise: (dr,dc) -> (dc, -dr)
                nd_r, nd_c = cur_dc, -cur_dr
            elif surface_type == CORNER:
                # Reverse direction 180 degrees
                nd_r, nd_c = -cur_dr, -cur_dc
            else:  # TRANSPARENT
                nd_r, nd_c = cur_dr, cur_dc

            cur_r, cur_c, cur_dr, cur_dc = new_r, new_c, nd_r, nd_c

        # Paint the visible initial straight beam segment in the input (up to but not including a surface)
        pr, pc = r, c
        while 0 <= pr < height and 0 <= pc < width:
            if input_grid[pr][pc] in surface_colors:
                break
            input_grid[pr][pc] = color
            pr += dr
            pc += dc

    # Now simulate the full paths to produce the output grid (beams overwrite surfaces in the
    # output representation; surfaces are only shown in the input). When multiple beams pass
    # through a cell we choose the numerically smaller color to make the result deterministic.
    for (r, c, dr, dc, color) in beam_origins:
        cur_r, cur_c, cur_dr, cur_dc = r, c, dr, dc
        seen = set()
        while 0 <= cur_r < height and 0 <= cur_c < width:
            prev = output_grid[cur_r][cur_c]
            if prev == 0 or color < prev:
                output_grid[cur_r][cur_c] = color
            cell = input_grid[cur_r][cur_c]
            if cell == ABSORB:
                break
            if cell == MIRROR:
                cur_dr, cur_dc = cur_dc, -cur_dr
            elif cell == CORNER:
                cur_dr, cur_dc = -cur_dr, -cur_dc
            elif cell == TRANSPARENT:
                pass

            state = (cur_r, cur_c, cur_dr, cur_dc)
            if state in seen:
                # Protection against accidental cycles
                break
            seen.add(state)
            cur_r += cur_dr
            cur_c += cur_dc

    return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable lists
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])

    # Same color mapping as the generator
    MIRROR = 3
    CORNER = 4
    ABSORB = 6
    TRANSPARENT = 8
    surface_colors = {MIRROR, CORNER, ABSORB, TRANSPARENT}

    output = [[0 for _ in range(width)] for __ in range(height)]

    origins = []  # list of (r, c, dr, dc, color)

    # Top and bottom rows (include corners here)
    for c in range(width):
        vtop = grid_in[0][c]
        if vtop != 0 and vtop not in surface_colors:
            origins.append((0, c, 1, 0, vtop))
        vbot = grid_in[height - 1][c]
        if vbot != 0 and vbot not in surface_colors:
            origins.append((height - 1, c, -1, 0, vbot))

    # Left and right columns excluding corners (to avoid duplicates)
    for r in range(1, height - 1):
        vleft = grid_in[r][0]
        if vleft != 0 and vleft not in surface_colors:
            origins.append((r, 0, 0, 1, vleft))
        vright = grid_in[r][width - 1]
        if vright != 0 and vright not in surface_colors:
            origins.append((r, width - 1, 0, -1, vright))

    # Simulate each beam fully. When multiple beams visit a cell, choose the numerically
    # smaller color to make the result deterministic (same tie-break as the generator).
    for (r, c, dr, dc, color) in origins:
        cur_r, cur_c, cur_dr, cur_dc = r, c, dr, dc
        seen = set()
        while 0 <= cur_r < height and 0 <= cur_c < width:
            prev = output[cur_r][cur_c]
            if prev == 0 or color < prev:
                output[cur_r][cur_c] = color
            cell = grid_in[cur_r][cur_c]
            if cell == ABSORB:
                break
            if cell == MIRROR:
                cur_dr, cur_dc = cur_dc, -cur_dr
            elif cell == CORNER:
                cur_dr, cur_dc = -cur_dr, -cur_dc
            elif cell == TRANSPARENT:
                pass

            state = (cur_r, cur_c, cur_dr, cur_dc)
            if state in seen:
                break
            seen.add(state)
            cur_r += cur_dr
            cur_c += cur_dc

    return output

