# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: a11787af
Difficulty: medium–hard

=== Tags ===
- If then color switch
- Color wavefront

=== Description ===
Input grids are 2D grids with dimensions between 5×5 and 20×20, featuring a
background color (0) and a single source cell (color 1) located at the top-left
corner (0,0). Scattered throughout the grid are obstacle cells (colors 2–9) that
block propagation. The wavefront begins at the source and propagates through
background cells (0), with each cell along the path changing color sequentially
(1 → 2 → 3 → ... → 9 → 1) as it is reached. The direction of propagation is
determined by the current cell's color: color C moves in the direction
corresponding to (C mod 4), where 0 = right, 1 = down, 2 = left, 3 = up. If the
next cell in the direction is an obstacle or out of bounds, propagation
terminates at the current cell. The output grid displays the wavefront path with
all cells colored according to their step in the sequence, while obstacle cells
remain unchanged. The wavefront follows a spiral-like path due to the direction
cycling, requiring the solver to recognize the color-direction relationship and
propagation rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    while True:
        w = random.randint(5, 20)
        h = random.randint(5, 20)
        grid_input = [[0] * w for _ in range(h)]
        grid_input[0][0] = 1
        
        path = [(0, 0)]
        current_color = 1
        current_pos = (0, 0)
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        while True:
            next_dir = current_color % 4
            dr, dc = directions[next_dir]
            r, c = current_pos
            nr, nc = r + dr, c + dc
            if nr < 0 or nr >= h or nc < 0 or nc >= w:
                break
            if grid_input[nr][nc] != 0:
                break
            current_color = (current_color % 9) + 1
            path.append((nr, nc))
            current_pos = (nr, nc)
        
        if len(path) >= 2:
            break
    
    input_grid = [[0] * w for _ in range(h)]
    input_grid[0][0] = 1
    for r, c in path[1:]:
        input_grid[r][c] = 0
    
    for r in range(h):
        for c in range(w):
            if (r, c) not in path:
                input_grid[r][c] = random.randint(2, 9)
    
    output_grid = [row[:] for row in input_grid]
    for idx, (r, c) in enumerate(path):
        color = (idx + 1) % 9
        if color == 0:
            color = 9
        output_grid[r][c] = color
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
    current_color = 1
    current_pos = (0, 0)
    
    while True:
        next_dir = current_color % 4
        dr, dc = directions[next_dir]
        r, c = current_pos
        nr, nc = r + dr, c + dc
        if nr < 0 or nr >= h or nc < 0 or nc >= w:
            break
        if grid[nr][nc] != 0:
            break
        current_color = (current_color % 9) + 1
        grid[nr][nc] = current_color
        current_pos = (nr, nc)
    
    return tuple(tuple(row) for row in grid)
