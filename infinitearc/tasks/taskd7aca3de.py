# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: d7aca3de
Difficulty: medium

=== Tags ===
- Associate patterns to patterns
- Measure length
- One yes one no
- Wraparound copy

=== Description ===
The input grid contains exactly one horizontal sequence of contiguous non-zero
values (the "pattern") in a single row, while all other cells are zero. The
output grid is generated by repeating this pattern across every row, wrapping
around the grid's width. For each row in the output, the value at column c is
determined by the pattern's value at index (c mod L), where L is the length of
the pattern. This transformation requires measuring the pattern's length (L) and
applying a wraparound copy to each row, ensuring the pattern cycles continuously
without gaps or overlaps. The "one yes" refers to the single pattern-containing
row in the input, while "one no" indicates all other cells are zero (non-
pattern).
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_color
def generate():
    W = random.randint(1, 30)
    H = random.randint(2, 30)
    input_grid = grid(W, H, 0)
    r = random.randint(0, H-1)
    s = random.randint(0, W-1)
    L = random.randint(1, W - s)
    pattern = [random_color() for _ in range(L)]
    for c in range(s, s + L):
        input_grid[r][c] = pattern[c - s]
    output_grid = grid(W, H, 0)
    for r_out in range(H):
        for c in range(W):
            output_grid[r_out][c] = pattern[c % L]
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    H = len(input_grid)
    W = len(input_grid[0])
    pattern_row = None
    for r in range(H):
        if any(val != 0 for val in input_grid[r]):
            pattern_row = r
            break
    if pattern_row is None:
        return input_grid
    row = input_grid[pattern_row]
    start = 0
    while start < W and row[start] == 0:
        start += 1
    end = start
    while end < W and row[end] != 0:
        end += 1
    pattern = row[start:end]
    L = len(pattern)
    output_grid = []
    for _ in range(H):
        new_row = [pattern[c % L] for c in range(W)]
        output_grid.append(new_row)
    return output_grid
