# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: c68e2ba5
Difficulty: insane

=== Tags ===
- Conditional draw
- Color modulated motion
- Size guessing
- Recolor object based on neighbor count

=== Description ===
Input grids consist of multiple distinct colored objects (connected regions of
the same color, 4-connected) on a uniform background (color 0). Each object's
visual size (number of cells) and perimeter (total number of adjacent cells
bordering non-object regions, including background and other objects) are
visually discernible through edge detection.   To generate the output grid,
apply the following rules sequentially to each object:  1. **Recolor based on
perimeter count**: For each object, count its total perimeter (visual edge count
between the object and non-object regions). Recolor the entire object to a new
color using the mapping: (perimeter count mod 9) + 1 (e.g., perimeter 5 → color
6, perimeter 9 → color 1).  2. **Color-modulated motion**: Move the recolored
object in a direction determined by its new color:    - Color 1: Move up    -
Color 2: Move right    - Color 3: Move down    - Color 4: Move left    - Color
5: Move up-right    - Color 6: Move down-right    - Color 7: Move down-left    -
Color 8: Move up-left    - Color 9: Move up  3. **Size-guessing motion
distance**: The movement distance equals the object's original size (number of
cells in the object). All movements occur simultaneously with grid wraparound
(moving off one edge reappears on the opposite edge).  The output grid reflects
these transformations, with objects relocated, recolored, and background
unchanged. No two objects may overlap in the output, and all movements must be
computed relative to their original positions before any movement occurs.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Generator for ARC task c68e2ba5 (Task 406)
# Produces grids where several non-touching objects are placed; each object is recolored
# according to its perimeter: new_color = (perimeter % 9) + 1, and then moved by
# a vector determined by that new_color. The move distance equals the object's size
# and wraparound is applied. Objects are placed so that their final positions do not overlap.

DIR_MAP = {
    1: (-1, 0),  # up
    2: (0, 1),   # right
    3: (1, 0),   # down
    4: (0, -1),  # left
    5: (-1, 1),  # up-right
    6: (1, 1),   # down-right
    7: (1, -1),  # down-left
    8: (-1, -1), # up-left
    9: (-1, 0),  # up (same as 1)
}


def _place_rectangles(width, height, num_objects):
    input_grid = grid(width, height, 0)
    reserved_input = set()   # cells and padding reserved to avoid touching objects
    reserved_final = set()   # final positions reserved to avoid overlaps after move
    objects = []             # list of dicts: pixels, init_color, new_color, final_pixels

    colors = list(range(1, 10))
    random.shuffle(colors)
    color_iter = iter(colors)

    for _ in range(num_objects):
        placed = False
        # Try multiple times to place an object that doesn't collide with others' padded region
        for attempt in range(200):
            # Choose a rectangle size with area between 3 and 12
            max_w = min(6, width)
            max_h = min(6, height)
            w = random.randint(1, max_w)
            h = random.randint(1, max_h)
            area = w * h
            if area < 3 or area > 12:
                continue
            # Random top-left position
            r0 = random.randint(0, height - h)
            c0 = random.randint(0, width - w)
            # Padded bounding box to avoid adjacency (1-cell padding)
            pad_r0 = max(0, r0 - 1)
            pad_r1 = min(height - 1, r0 + h)
            pad_c0 = max(0, c0 - 1)
            pad_c1 = min(width - 1, c0 + w)

            conflict = False
            for rr in range(pad_r0, pad_r1 + 1):
                for cc in range(pad_c0, pad_c1 + 1):
                    if (rr, cc) in reserved_input:
                        conflict = True
                        break
                if conflict:
                    break
            if conflict:
                continue

            # Create pixel list for rectangle
            pixels = [(rr, cc) for rr in range(r0, r0 + h) for cc in range(c0, c0 + w)]
            pixel_set = set(pixels)

            # Compute perimeter (count edges between object pixel and non-object area)
            perimeter = 0
            for (rr, cc) in pixels:
                for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                    nr, nc = rr + dr, cc + dc
                    if nr < 0 or nr >= height or nc < 0 or nc >= width:
                        perimeter += 1
                    elif (nr, nc) not in pixel_set:
                        perimeter += 1

            new_color = (perimeter % 9) + 1
            dr, dc = DIR_MAP[new_color]
            S = len(pixels)

            # Compute final positions with wraparound
            final_pixels = [((rr + dr * S) % height, (cc + dc * S) % width) for (rr, cc) in pixels]

            # Ensure final positions don't overlap previously reserved final positions
            if any(p in reserved_final for p in final_pixels):
                continue

            # Accept placement
            init_color = next(color_iter)
            for (rr, cc) in pixels:
                input_grid[rr][cc] = init_color

            # Reserve padded input region to prevent touching other objects
            for rr in range(pad_r0, pad_r1 + 1):
                for cc in range(pad_c0, pad_c1 + 1):
                    reserved_input.add((rr, cc))

            for p in final_pixels:
                reserved_final.add(p)

            objects.append({
                "pixels": pixels,
                "init_color": init_color,
                "new_color": new_color,
                "final_pixels": final_pixels,
            })

            placed = True
            break

        if not placed:
            # Failed to place one object after many attempts; abort and signal failure
            return None

    # Build output grid from final pixels and their new colors
    output_grid = grid(width, height, 0)
    for obj in objects:
        col = obj["new_color"]
        for (rr, cc) in obj["final_pixels"]:
            output_grid[rr][cc] = col

    # Ensure input and output are not identical
    if input_grid == output_grid:
        return None

    return {"input": input_grid, "output": output_grid}


def generate():
    # Try repeatedly until we get a valid placement. Usually this succeeds quickly.
    for _ in range(50):
        width = random.randint(12, 20)
        height = random.randint(12, 20)
        num_objects = random.randint(3, 5)
        res = _place_rectangles(width, height, num_objects)
        if res is not None:
            return res
    # As a fallback (very unlikely), produce a deterministic small example
    width, height = 12, 12
    res = _place_rectangles(width, height, 3)
    if res is None:
        # If even fallback fails (shouldn't), create a trivial example to avoid crashing
        ig = grid(width, height, 0)
        og = grid(width, height, 0)
        ig[1][1] = 1
        og[2][1] = 2
        return {"input": ig, "output": og}
    return res



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

# Solver for ARC task c68e2ba5 (Task 406)
# Identifies 4-connected colored objects, computes their perimeter, recolors them,
# then moves them by (object_size) cells in the direction determined by the recolored color.

DIR_MAP = {
    1: (-1, 0),
    2: (0, 1),
    3: (1, 0),
    4: (0, -1),
    5: (-1, 1),
    6: (1, 1),
    7: (1, -1),
    8: (-1, -1),
    9: (-1, 0),
}


def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    visited = [[False] * width for _ in range(height)]
    components = []  # list of lists of (r,c)

    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 or visited[r][c]:
                continue
            color = grid[r][c]
            q = deque()
            q.append((r, c))
            visited[r][c] = True
            pixels = []
            while q:
                rr, cc = q.popleft()
                pixels.append((rr, cc))
                for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                        visited[nr][nc] = True
                        q.append((nr, nc))
            components.append(pixels)

    output = [[0] * width for _ in range(height)]

    for pixels in components:
        pixel_set = set(pixels)
        # Perimeter: count edges where neighbor is out of bounds or not in the same component
        perimeter = 0
        for (r, c) in pixels:
            for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                nr, nc = r + dr, c + dc
                if nr < 0 or nr >= height or nc < 0 or nc >= width:
                    perimeter += 1
                elif (nr, nc) not in pixel_set:
                    perimeter += 1
        new_color = (perimeter % 9) + 1
        dr, dc = DIR_MAP[new_color]
        S = len(pixels)
        for (r, c) in pixels:
            nr = (r + dr * S) % height
            nc = (c + dc * S) % width
            output[nr][nc] = new_color

    return output

