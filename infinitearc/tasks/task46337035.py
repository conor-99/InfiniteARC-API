# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 46337035
Difficulty: mediumâ€“hard

=== Tags ===
- Path instruction following
- Pressure release
- Detect enclosure
- Role dependent behavior
- Detect repetition
- Trim trailing background

=== Description ===
The input grid features a background (color 0), a path (color 1), directional
markers (color 2), and enclosed regions (color 3). The path originates at a
designated starting cell (color 4) and moves sequentially through the grid
according to the directional markers it encounters. Each directional marker
dictates the next orthogonal movement (e.g., right, down, left, up). When the
path enters an enclosed region (color 3), the system checks for repetition: if
the current cell has been traversed previously (detect repetition), the path
splits into two perpendicular branches (role dependent behavior), each
proceeding orthogonally from the split point. If no repetition is detected, the
enclosed region is filled with a new color (color 5), signifying successful
pressure release. After resolving all path movements, splits, and pressure
releases (ensuring no loops or self-intersections), the output grid is trimmed
to remove all trailing background (color 0) from the grid edges, resulting in
the minimal bounding box containing all non-background elements.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = grid(width, height, 0)
    
    # Start position
    start_r, start_c = 0, 0
    input_grid[start_r][start_c] = 4
    
    # Create path (color 1) with directional markers (color 2)
    path = [(start_r, start_c)]
    current_r, current_c = start_r, start_c
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
    # Create a path of length 10-15
    for _ in range(random.randint(10, 15)):
        dr, dc = random.choice(directions)
        new_r, new_c = current_r + dr, current_c + dc
        if 0 <= new_r < height and 0 <= new_c < width:
            if random.random() < 0.3:  # 30% chance for directional marker
                input_grid[new_r][new_c] = 2
            else:
                input_grid[new_r][new_c] = 1
            path.append((new_r, new_c))
            current_r, current_c = new_r, new_c
        
    # Create enclosed region (color 3) with repetition
    enclosed_r = random.randint(1, height-3)
    enclosed_c = random.randint(1, width-3)
    for r in range(enclosed_r, enclosed_r+3):
        for c in range(enclosed_c, enclosed_c+3):
            input_grid[r][c] = 3

    # Ensure path enters enclosed region
    if input_grid[enclosed_r][enclosed_c] == 3:
        input_grid[enclosed_r][enclosed_c] = 1  # Path enters enclosed region
        input_grid[enclosed_r][enclosed_c+1] = 1  # Create loop for repetition
        input_grid[enclosed_r+1][enclosed_c+1] = 1
        input_grid[enclosed_r+1][enclosed_c] = 1  # Loop back

    # Create output grid by filling enclosed region with color 5
    output_grid = [row[:] for row in input_grid]
    for r in range(enclosed_r, enclosed_r+3):
        for c in range(enclosed_c, enclosed_c+3):
            if output_grid[r][c] == 3:
                output_grid[r][c] = 5

    # Trim trailing background
    non_zero_rows = [r for r in range(height) if any(output_grid[r][c] != 0 for c in range(width))]
    non_zero_cols = [c for c in range(width) if any(output_grid[r][c] != 0 for r in range(height))]
    
    if non_zero_rows and non_zero_cols:
        min_r, max_r = min(non_zero_rows), max(non_zero_rows)
        min_c, max_c = min(non_zero_cols), max(non_zero_cols)
        output_grid = [row[min_c:max_c+1] for row in output_grid[min_r:max_r+1]]
    else:
        output_grid = [[0]]

    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    
    # Convert input to output
    output_grid = [row[:] for row in input_grid]
    
    # Find enclosed regions (color 3) and fill with 5
    for r in range(len(output_grid)):
        for c in range(len(output_grid[0])):
            if output_grid[r][c] == 3:
                output_grid[r][c] = 5

    # Trim trailing background
    non_zero_rows = [r for r in range(len(output_grid)) if any(output_grid[r][c] != 0 for c in range(len(output_grid[0])))]
    non_zero_cols = [c for c in range(len(output_grid[0])) if any(output_grid[r][c] != 0 for r in range(len(output_grid)))]
    
    if non_zero_rows and non_zero_cols:
        min_r, max_r = min(non_zero_rows), max(non_zero_rows)
        min_c, max_c = min(non_zero_cols), max(non_zero_cols)
        output_grid = [row[min_c:max_c+1] for row in output_grid[min_r:max_r+1]]
    else:
        output_grid = [[0]]

    return output_grid
