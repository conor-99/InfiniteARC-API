# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 5dfcb942
Difficulty: medium

=== Tags ===
- Measure length
- Separate shapes

=== Description ===
The task involves transforming an input grid where each connected component
(shape) of non-zero color is replaced by a color corresponding to the number of
cells in that component. Shapes are identified using 4-connectivity (up, down,
left, right), ignoring background color (0). For each shape, the output grid
replaces every cell of that shape with a color equal to the shape's size (number
of cells). This process effectively "separates" shapes by using unique colors
based on their measured length (size), making the size visually apparent. For
example, a shape composed of 4 cells becomes entirely color 4, while a 7-cell
shape becomes color 7. The transformation requires identifying all connected
components, measuring their sizes, and applying the size-based color
replacement. The output grid will always differ from the input, as colors change
to reflect component sizes rather than original colors.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = random.randint(5, 20)
    height = random.randint(5, 20)
    input_grid = common.grid(width, height)
    
    num_components = random.randint(2, 4)
    for _ in range(num_components):
        size = random.randint(1, 9)
        pixels = common.continuous_creature(size, 5, 5)
        r_coords = [p[0] for p in pixels]
        c_coords = [p[1] for p in pixels]
        min_r, max_r = min(r_coords), max(r_coords)
        min_c, max_c = min(c_coords), max(c_coords)
        max_r_offset = height - (max_r - min_r + 1)
        max_c_offset = width - (max_c - min_c + 1)
        if max_r_offset < 0 or max_c_offset < 0:
            continue
        r_offset = random.randint(0, max_r_offset)
        c_offset = random.randint(0, max_c_offset)
        shifted_pixels = [(r + r_offset, c + c_offset) for r, c in pixels]
        for r, c in shifted_pixels:
            input_grid[r][c] = random.randint(1, 9)
    
    output_grid = common.grid(width, height)
    visited = [[False] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                stack = [(r, c)]
                visited[r][c] = True
                component = []
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                size_val = len(component)
                size_val = min(size_val, 9)  # Ensure size doesn't exceed 9
                for cr, cc in component:
                    output_grid[cr][cc] = size_val
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid:
        return []
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = [[0] * width for _ in range(height)]
    visited = [[False] * width for _ in range(height)]
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                stack = [(r, c)]
                visited[r][c] = True
                component = []
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                size_val = len(component)
                size_val = min(size_val, 9)  # Ensure size doesn't exceed 9
                for cr, cc in component:
                    output_grid[cr][cc] = size_val
    return output_grid
