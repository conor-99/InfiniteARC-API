# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 1fd495b0
Difficulty: very hard

=== Tags ===
- Field interference pattern

=== Description ===
Input grids are 20×20 or larger with a uniform background color (0). Scattered
across the grid are multiple non-overlapping, connected regions (fields) of
distinct colors (1–9), each forming a unique shape with no two fields sharing
the same color. Fields are placed such that their axis-aligned bounding boxes do
not overlap, but may be adjacent or separated by background cells. The output
grid must transform the input by generating a new "interference pattern" through
the following rules: For every pair of fields whose bounding boxes are
horizontally aligned (same vertical span) and separated by exactly three
background cells between their edges, draw a horizontal line of the left field's
color spanning the gap. Similarly, for vertically aligned fields (same
horizontal span) separated by exactly three background cells, draw a vertical
line of the top field's color spanning the gap. Lines are drawn only in
background cells (0), never over existing fields or other lines. The
interference pattern is the minimal set of such lines that satisfies all
alignment and spacing constraints. No two lines may share a cell, and all fields
remain visible unchanged in the output. The task requires identifying all field
bounding boxes, verifying exact 3-cell spacing in alignment, and precisely
drawing the pattern without overwriting.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import continuous_creature

def generate():
    # Try to build a valid configuration; if something fails, retry a few times
    for _attempt in range(100):
        width = random.randint(20, 30)
        height = random.randint(20, 30)
        grid = [[0 for _ in range(width)] for _ in range(height)]

        # We'll create between 2 and 7 fields in total (keeps colors unique within 1..9)
        orientation = random.choice(["horizontal", "vertical"])  # which orientation will contain the guaranteed gap-3 pair

        bboxes = []  # placed bounding boxes (dicts with top,bottom,left,right,color)

        try:
            # Decide how many boxes in the main band (that will contain at least one gap-3 pair)
            if orientation == "horizontal":
                band_h = random.randint(2, 6)
                band_top = random.randint(0, height - band_h)

                max_boxes = min(5, max(2, width // 4))
                n_boxes = random.randint(2, max_boxes)

                # generate widths and a gaps list with exactly one gap equal to 3
                def make_layout():
                    widths = [random.randint(2, min(8, width // 2)) for _ in range(n_boxes)]
                    gap_idx = random.randint(0, n_boxes - 2)
                    gaps = []
                    for i in range(n_boxes - 1):
                        if i == gap_idx:
                            gaps.append(3)
                        else:
                            gaps.append(random.randint(0, 4))
                    total_len = sum(widths) + sum(gaps)
                    return widths, gaps, gap_idx, total_len

                widths, gaps, gap_idx, total_len = make_layout()

                # If it doesn't fit, try a few times to alter widths/gaps
                tries = 0
                while total_len > width and tries < 120:
                    widths, gaps, gap_idx, total_len = make_layout()
                    tries += 1

                if total_len > width:
                    # fallback to a minimal two-box layout ensuring a gap of 3
                    n_boxes = 2
                    widths = [random.randint(2, max(2, width // 4)) for _ in range(n_boxes)]
                    gaps = [3]
                    gap_idx = 0
                    total_len = sum(widths) + 3

                left_start = random.randint(0, width - total_len)
                cur_left = left_start

                # Reserve colors for these and possible extra fields
                extra_count = random.randint(0, min(4, 9 - n_boxes))
                color_pool = random.sample(list(range(1, 10)), k=n_boxes + extra_count)
                color_i = 0

                # Place the band boxes and fill them as solid rectangles so the bounding boxes are exact
                for i in range(n_boxes):
                    bw = widths[i]
                    top = band_top
                    left = cur_left
                    bottom = top + band_h - 1
                    right = left + bw - 1
                    color = color_pool[color_i]
                    color_i += 1
                    for r in range(top, bottom + 1):
                        for c in range(left, right + 1):
                            grid[r][c] = color
                    bboxes.append({"top": top, "bottom": bottom, "left": left, "right": right, "color": color})
                    if i < n_boxes - 1:
                        cur_left += bw + gaps[i]

                # Add a few extra fields elsewhere (avoid overlapping the band rows to keep gaps intact)
                extra = extra_count
                place_attempts = 0
                while extra > 0 and place_attempts < 500:
                    place_attempts += 1
                    bw = random.randint(2, 6)
                    bh = random.randint(2, 6)
                    top_candidate = random.randint(0, height - bh)
                    # avoid band rows
                    if not (top_candidate + bh - 1 < band_top or top_candidate > band_top + band_h - 1):
                        continue
                    left_candidate = random.randint(0, width - bw)
                    # check overlap with existing bboxes (no sharing of cells)
                    newbbox = {"top": top_candidate, "bottom": top_candidate + bh - 1, "left": left_candidate, "right": left_candidate + bw - 1}
                    overlap = False
                    for ex in bboxes:
                        if not (ex["right"] < newbbox["left"] or ex["left"] > newbbox["right"] or ex["bottom"] < newbbox["top"] or ex["top"] > newbbox["bottom"]):
                            overlap = True
                            break
                    if overlap:
                        continue
                    # create a connected creature inside the box
                    color = color_pool[color_i]
                    color_i += 1
                    size = random.randint(1, bw * bh)
                    pixels = continuous_creature(size, bw, bh)
                    for (pr, pc) in pixels:
                        grid[newbbox["top"] + pr][newbbox["left"] + pc] = color
                    newbbox["color"] = color
                    bboxes.append(newbbox)
                    extra -= 1

            else:
                # vertical orientation: analogous but stacked vertically
                band_w = random.randint(2, 6)
                band_left = random.randint(0, width - band_w)

                max_boxes = min(5, max(2, height // 4))
                n_boxes = random.randint(2, max_boxes)

                def make_layout_v():
                    heights = [random.randint(2, min(8, height // 2)) for _ in range(n_boxes)]
                    gap_idx = random.randint(0, n_boxes - 2)
                    gaps = []
                    for i in range(n_boxes - 1):
                        if i == gap_idx:
                            gaps.append(3)
                        else:
                            gaps.append(random.randint(0, 4))
                    total_len = sum(heights) + sum(gaps)
                    return heights, gaps, gap_idx, total_len

                heights, gaps, gap_idx, total_len = make_layout_v()
                tries = 0
                while total_len > height and tries < 120:
                    heights, gaps, gap_idx, total_len = make_layout_v()
                    tries += 1

                if total_len > height:
                    n_boxes = 2
                    heights = [random.randint(2, max(2, height // 4)) for _ in range(n_boxes)]
                    gaps = [3]
                    gap_idx = 0
                    total_len = sum(heights) + 3

                top_start = random.randint(0, height - total_len)
                cur_top = top_start

                extra_count = random.randint(0, min(4, 9 - n_boxes))
                color_pool = random.sample(list(range(1, 10)), k=n_boxes + extra_count)
                color_i = 0

                # Place band boxes as solid rectangles so vertical bounding boxes are exact
                for i in range(n_boxes):
                    bh = heights[i]
                    left = band_left
                    top = cur_top
                    right = left + band_w - 1
                    bottom = top + bh - 1
                    color = color_pool[color_i]
                    color_i += 1
                    for r in range(top, bottom + 1):
                        for c in range(left, right + 1):
                            grid[r][c] = color
                    bboxes.append({"top": top, "bottom": bottom, "left": left, "right": right, "color": color})
                    if i < n_boxes - 1:
                        cur_top += bh + gaps[i]

                # Extra fields avoid band columns
                extra = extra_count
                place_attempts = 0
                while extra > 0 and place_attempts < 500:
                    place_attempts += 1
                    bw = random.randint(2, 6)
                    bh = random.randint(2, 6)
                    left_candidate = random.randint(0, width - bw)
                    # avoid band columns
                    if not (left_candidate + bw - 1 < band_left or left_candidate > band_left + band_w - 1):
                        continue
                    top_candidate = random.randint(0, height - bh)
                    newbbox = {"top": top_candidate, "bottom": top_candidate + bh - 1, "left": left_candidate, "right": left_candidate + bw - 1}
                    overlap = False
                    for ex in bboxes:
                        if not (ex["right"] < newbbox["left"] or ex["left"] > newbbox["right"] or ex["bottom"] < newbbox["top"] or ex["top"] > newbbox["bottom"]):
                            overlap = True
                            break
                    if overlap:
                        continue
                    color = color_pool[color_i]
                    color_i += 1
                    size = random.randint(1, bw * bh)
                    pixels = continuous_creature(size, bw, bh)
                    for (pr, pc) in pixels:
                        grid[newbbox["top"] + pr][newbbox["left"] + pc] = color
                    newbbox["color"] = color
                    bboxes.append(newbbox)
                    extra -= 1

            # Now compute fields from the actual grid (connected components) to get real bounding boxes
            height0 = height
            width0 = width
            visited = [[False] * width0 for _ in range(height0)]
            fields = {}
            fields_order = []
            for r in range(height0):
                for c in range(width0):
                    if grid[r][c] != 0 and not visited[r][c]:
                        col = grid[r][c]
                        stack = [(r, c)]
                        visited[r][c] = True
                        cells = []
                        while stack:
                            cr, cc = stack.pop()
                            cells.append((cr, cc))
                            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                                nr, nc = cr + dr, cc + dc
                                if 0 <= nr < height0 and 0 <= nc < width0 and not visited[nr][nc] and grid[nr][nc] == col:
                                    visited[nr][nc] = True
                                    stack.append((nr, nc))
                        top = min(cr for cr, cc in cells)
                        bottom = max(cr for cr, cc in cells)
                        left = min(cc for cr, cc in cells)
                        right = max(cc for cr, cc in cells)
                        fields[col] = (top, bottom, left, right)
                        fields_order.append(col)

            # Create the output by drawing lines for every qualifying pair using the same deterministic order
            output = [row[:] for row in grid]
            colors = fields_order
            for i in range(len(colors)):
                for j in range(i + 1, len(colors)):
                    color1 = colors[i]
                    color2 = colors[j]
                    top1, bottom1, left1, right1 = fields[color1]
                    top2, bottom2, left2, right2 = fields[color2]

                    # Horizontal alignment
                    if top1 == top2 and bottom1 == bottom2:
                        # color1 is left of color2
                        if right1 + 4 == left2:
                            can_draw = True
                            for r in range(top1, bottom1 + 1):
                                for c in range(right1 + 1, left2):
                                    if grid[r][c] != 0 or output[r][c] != 0:
                                        can_draw = False
                                        break
                                if not can_draw:
                                    break
                            if can_draw:
                                for r in range(top1, bottom1 + 1):
                                    for c in range(right1 + 1, left2):
                                        output[r][c] = color1
                        # color2 is left of color1
                        elif right2 + 4 == left1:
                            can_draw = True
                            for r in range(top2, bottom2 + 1):
                                for c in range(right2 + 1, left1):
                                    if grid[r][c] != 0 or output[r][c] != 0:
                                        can_draw = False
                                        break
                                if not can_draw:
                                    break
                            if can_draw:
                                for r in range(top2, bottom2 + 1):
                                    for c in range(right2 + 1, left1):
                                        output[r][c] = color2

                    # Vertical alignment
                    if left1 == left2 and right1 == right2:
                        # color1 is above color2
                        if bottom1 + 4 == top2:
                            can_draw = True
                            for c in range(left1, right1 + 1):
                                for r in range(bottom1 + 1, top2):
                                    if grid[r][c] != 0 or output[r][c] != 0:
                                        can_draw = False
                                        break
                                if not can_draw:
                                    break
                            if can_draw:
                                for c in range(left1, right1 + 1):
                                    for r in range(bottom1 + 1, top2):
                                        output[r][c] = color1
                        # color2 is above color1
                        elif bottom2 + 4 == top1:
                            can_draw = True
                            for c in range(left2, right2 + 1):
                                for r in range(bottom2 + 1, top1):
                                    if grid[r][c] != 0 or output[r][c] != 0:
                                        can_draw = False
                                        break
                                if not can_draw:
                                    break
                            if can_draw:
                                for c in range(left2, right2 + 1):
                                    for r in range(bottom2 + 1, top1):
                                        output[r][c] = color2

            # Ensure output differs from input (there should be at least one guaranteed line because we forced one gap-3 pair)
            if output != grid:
                return {"input": grid, "output": output}
        except Exception:
            # If anything failed, try a fresh generation
            continue

    # As a fallback (should not happen), return a simple guaranteed difference case
    width = 20
    height = 20
    grid = [[0] * width for _ in range(height)]
    # two solid boxes with gap 3
    for r in range(2, 6):
        for c in range(2, 6):
            grid[r][c] = 1
    for r in range(2, 6):
        for c in range(10, 14):
            grid[r][c] = 2
    output = [row[:] for row in grid]
    for r in range(2, 6):
        for c in range(6, 10):
            output[r][c] = 1
    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input tuple-of-tuples to a mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # Find connected fields (scanning top-to-bottom, left-to-right -> deterministic order)
    visited = [[False] * width for _ in range(height)]
    fields = {}
    fields_order = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and not visited[r][c]:
                color = grid[r][c]
                stack = [(r, c)]
                visited[r][c] = True
                cells = []
                while stack:
                    cr, cc = stack.pop()
                    cells.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                top = min(rr for rr, cc in cells)
                bottom = max(rr for rr, cc in cells)
                left = min(cc for rr, cc in cells)
                right = max(cc for rr, cc in cells)
                fields[color] = (top, bottom, left, right)
                fields_order.append(color)

    # Copy input to output and draw lines according to the same deterministic rules
    output = [row[:] for row in grid]
    colors = fields_order
    for i in range(len(colors)):
        for j in range(i + 1, len(colors)):
            color1 = colors[i]
            color2 = colors[j]
            top1, bottom1, left1, right1 = fields[color1]
            top2, bottom2, left2, right2 = fields[color2]

            # Horizontal alignment: identical vertical span and exactly 3 background cols between
            if top1 == top2 and bottom1 == bottom2:
                if right1 + 4 == left2:
                    # Ensure all gap cells are background and not already used by a line
                    can_draw = True
                    for r in range(top1, bottom1 + 1):
                        for c in range(right1 + 1, left2):
                            if grid[r][c] != 0 or output[r][c] != 0:
                                can_draw = False
                                break
                        if not can_draw:
                            break
                    if can_draw:
                        for r in range(top1, bottom1 + 1):
                            for c in range(right1 + 1, left2):
                                output[r][c] = color1
                elif right2 + 4 == left1:
                    can_draw = True
                    for r in range(top2, bottom2 + 1):
                        for c in range(right2 + 1, left1):
                            if grid[r][c] != 0 or output[r][c] != 0:
                                can_draw = False
                                break
                        if not can_draw:
                            break
                    if can_draw:
                        for r in range(top2, bottom2 + 1):
                            for c in range(right2 + 1, left1):
                                output[r][c] = color2

            # Vertical alignment: identical horizontal span and exactly 3 background rows between
            if left1 == left2 and right1 == right2:
                if bottom1 + 4 == top2:
                    can_draw = True
                    for c in range(left1, right1 + 1):
                        for r in range(bottom1 + 1, top2):
                            if grid[r][c] != 0 or output[r][c] != 0:
                                can_draw = False
                                break
                        if not can_draw:
                            break
                    if can_draw:
                        for c in range(left1, right1 + 1):
                            for r in range(bottom1 + 1, top2):
                                output[r][c] = color1
                elif bottom2 + 4 == top1:
                    can_draw = True
                    for c in range(left2, right2 + 1):
                        for r in range(bottom2 + 1, top1):
                            if grid[r][c] != 0 or output[r][c] != 0:
                                can_draw = False
                                break
                        if not can_draw:
                            break
                    if can_draw:
                        for c in range(left2, right2 + 1):
                            for r in range(bottom2 + 1, top1):
                                output[r][c] = color2

    return output

