# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 1dd9c7d1
Difficulty: hard

=== Tags ===
- Size guessing
- Out of boundary
- Palette compression

=== Description ===
The task requires transforming an input grid by first identifying the largest
connected region (by cell count) using 4-connectivity. The output grid's
dimensions are determined by the bounding box of this region (size guessing),
which inherently aligns with the grid's edges when the region touches them (out
of boundary). Within this bounding box, the colors are compressed to the two
most frequent colors in the region, with all other colors replaced by the most
frequent of the two (palette compression). The transformation demands precise
identification of the largest region, accurate bounding box calculation, and
deterministic color mapping, making it challenging due to the need to balance
connectivity analysis, spatial reasoning, and color distribution rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import continuous_creature

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    grid = [[0] * width for _ in range(height)]
    
    # Ensure main region is nearly the entire grid
    main_region_size = width * height - 10
    main_region_pixels = continuous_creature(main_region_size, width, height)
    
    # Calculate color distribution proportional to region size
    color_count_1 = int(main_region_size * 0.6)
    color_count_2 = main_region_size - color_count_1
    colors = [1] * color_count_1 + [2] * color_count_2
    random.shuffle(colors)
    
    # Assign colors to main region
    for idx, (r, c) in enumerate(main_region_pixels):
        if idx < len(colors):
            grid[r][c] = colors[idx]
    
    # Fragment background (0) to ensure main region is largest
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 and random.random() < 0.85:
                grid[r][c] = random.randint(3, 9)
    
    # Compute bounding box of main region
    rows = [p[0] for p in main_region_pixels]
    cols = [p[1] for p in main_region_pixels]
    min_row, max_row = min(rows), max(rows)
    min_col, max_col = min(cols), max(cols)
    bounding_width = max_col - min_col + 1
    bounding_height = max_row - min_row + 1
    
    # Get top two colors in main region
    color_counts = {}
    for (r, c) in main_region_pixels:
        color = grid[r][c]
        color_counts[color] = color_counts.get(color, 0) + 1
    sorted_colors = sorted(color_counts.items(), key=lambda x: x[1], reverse=True)
    top2 = [color for color, _ in sorted_colors[:2]]
    
    # Determine top color
    if len(top2) < 2:
        top_color = top2[0] if top2 else 0
    else:
        top_color = top2[0] if color_counts[top2[0]] >= color_counts[top2[1]] else top2[1]
    
    # Create output grid
    output_grid = [[0] * bounding_width for _ in range(bounding_height)]
    for r_idx in range(bounding_height):
        for c_idx in range(bounding_width):
            r = min_row + r_idx
            c = min_col + c_idx
            input_color = grid[r][c]
            if input_color in top2:
                output_grid[r_idx][c_idx] = input_color
            else:
                output_grid[r_idx][c_idx] = top_color
    
    return {"input": grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid or not input_grid[0]:
        return []
    
    visited = [[False] * len(input_grid[0]) for _ in range(len(input_grid))]
    regions = []
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if not visited[r][c]:
                region = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    region.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < len(input_grid) and 0 <= nc < len(input_grid[0]) and not visited[nr][nc]:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                regions.append(region)
    
    largest_region = max(regions, key=len)
    
    rows = [p[0] for p in largest_region]
    cols = [p[1] for p in largest_region]
    min_row, max_row = min(rows), max(rows)
    min_col, max_col = min(cols), max(cols)
    bounding_width = max_col - min_col + 1
    bounding_height = max_row - min_row + 1
    
    color_counts = {}
    for (r, c) in largest_region:
        color = input_grid[r][c]
        color_counts[color] = color_counts.get(color, 0) + 1
    sorted_colors = sorted(color_counts.items(), key=lambda x: x[1], reverse=True)
    top2 = [color for color, _ in sorted_colors[:2]]
    
    if len(top2) < 2:
        top_color = top2[0] if top2 else 0
    else:
        top_color = top2[0] if color_counts[top2[0]] >= color_counts[top2[1]] else top2[1]
    
    output = [[0] * bounding_width for _ in range(bounding_height)]
    for r_idx in range(bounding_height):
        for c_idx in range(bounding_width):
            r = min_row + r_idx
            c = min_col + c_idx
            input_color = input_grid[r][c]
            if input_color in top2:
                output[r_idx][c_idx] = input_color
            else:
                output[r_idx][c_idx] = top_color
    
    return output
