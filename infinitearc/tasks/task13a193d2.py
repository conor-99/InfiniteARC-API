# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 13a193d2
Difficulty: easy

=== Tags ===
- Place dot in object center
- Take half
- Swap rows
- Color pixels at line intersections

=== Description ===
The task involves transforming an input grid into an output grid through a
sequence of visual operations. The input grid contains a single solid
rectangular object (a contiguous block of a single non-background color) on a
uniform background. The transformation applies four consistent rules:  1. **Take
half**: Reduce the grid height by halving it (keeping only the top half of rows,
rounding down for odd dimensions). 2. **Swap rows**: Exchange the first and
second rows of the resulting grid. 3. **Place dot in object center**: Locate the
center of the rectangular object (midpoint of its bounding box) and place a
small dot (color 1) at that position. 4. **Color pixels at line intersections**:
Identify the four corner pixels of the rectangular object (where its edges
intersect) and color them with a distinct color (color 2).  The rules are
applied sequentially to the input grid. The object's center is determined by the
midpoint of its top-left and bottom-right coordinates. For example, a 3x3
rectangle from (row 1, col 1) to (row 3, col 3) has a center at (row 2, col 2).
The corner intersections are the four corner pixels of the rectangle's bounding
box. The transformation is purely visual, relying on spatial relationships
rather than numerical properties. The output grid will always differ from the
input, with all operations applied in the specified order.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(2, 30)
    height = random.randint(4, 30)
    bg = 0
    obj_color = random.randint(1, 9)
    input_grid = [[bg] * width for _ in range(height)]
    r_start = 0
    h = random.randint(2, height//2)
    h = h if h % 2 == 1 else h-1
    if h < 1:
        h = 1
    w = random.randint(2, width)
    w = w if w % 2 == 1 else w-1
    if w < 1:
        w = 1
    c_start = random.randint(0, width - w)
    for r in range(r_start, r_start + h):
        for c in range(c_start, c_start + w):
            input_grid[r][c] = obj_color
    top_half = input_grid[:height//2]
    if len(top_half) >= 2:
        top_half[0], top_half[1] = top_half[1], top_half[0]
    non_bg = []
    for r in range(len(top_half)):
        for c in range(width):
            if top_half[r][c] != 0:
                non_bg.append((r, c))
    if not non_bg:
        return {"input": input_grid, "output": input_grid}
    min_r = min(r for r, c in non_bg)
    max_r = max(r for r, c in non_bg)
    min_c = min(c for r, c in non_bg)
    max_c = max(c for r, c in non_bg)
    center_r = (min_r + max_r) // 2
    center_c = (min_c + max_c) // 2
    top_half[center_r][center_c] = 1
    corners = [(min_r, min_c), (min_r, max_c), (max_r, min_c), (max_r, max_c)]
    for r, c in corners:
        top_half[r][c] = 2
    return {"input": input_grid, "output": top_half}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    top_half = input_grid[:height//2]
    top_half = [list(row) for row in top_half]
    if len(top_half) >= 2:
        top_half[0], top_half[1] = top_half[1], top_half[0]
    non_bg = []
    for r in range(len(top_half)):
        for c in range(width):
            if top_half[r][c] != 0:
                non_bg.append((r, c))
    if not non_bg:
        return top_half
    min_r = min(r for r, c in non_bg)
    max_r = max(r for r, c in non_bg)
    min_c = min(c for r, c in non_bg)
    max_c = max(c for r, c in non_bg)
    center_r = (min_r + max_r) // 2
    center_c = (min_c + max_c) // 2
    top_half[center_r][center_c] = 1
    corners = [(min_r, min_c), (min_r, max_c), (max_r, min_c), (max_r, max_c)]
    for r, c in corners:
        top_half[r][c] = 2
    return top_half
