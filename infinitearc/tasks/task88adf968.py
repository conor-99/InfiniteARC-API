# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 88adf968
Difficulty: hard

=== Tags ===
- Recursive partition
- Color modulated logic
- Background filling
- Remove noise

=== Description ===
# Recursive Partition: Modulated Background Filling  Input grids feature a
background color (0) overlaid with a complex recursive partition structure
formed by colored boundary lines. The partition consists of nested rectangular
regions where each region is subdivided into smaller regions, continuing
recursively until a minimum size (2x2) is reached. Boundary lines are always
solid color lines (1-9), with vertical lines having a distinct color from
horizontal lines (e.g., vertical lines are color 1, horizontal lines are color
2). The interior of each partitioned region contains background color (0), while
the boundary lines themselves remain visible.  The grid also contains isolated
noise elements: small, disconnected clusters of color (typically color 5-9) that
are not connected to the main recursive structure. These noise elements range
from single cells to small 2x2 blocks, always isolated from the partition
structure.  To generate the output grid, apply these rules sequentially:  1.
**Noise Removal**: Identify and remove all disconnected noise clusters (any
colored region not connected to the main recursive partition via boundary
lines). This is done by traversing all boundary lines to form the main connected
structure, then removing any colored cells outside this structure.  2.
**Boundary Color Analysis**: For each partitioned region (defined by the
boundary lines), determine the dominant boundary color type:    - Regions
bounded primarily by vertical lines (color 1) should have their interior
background filled with color 3    - Regions bounded primarily by horizontal
lines (color 2) should have their interior background filled with color 4    -
Regions bounded by both types (e.g., at intersections) should use the more
dominant boundary type (based on line length)  3. **Background Filling**:
Replace all background color (0) cells within each partitioned region with the
modulated fill color determined by the boundary analysis. Boundary lines
themselves remain unchanged.  The output grid maintains the original boundary
lines and recursive structure while removing noise and filling the interior
regions with color-conditional background patterns. The task requires
recognizing the recursive partition structure, distinguishing it from noise, and
applying color-dependent fill rules across multiple hierarchical levels of the
partition.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate_recursive_boundaries(grid, top, bottom, left, right, depth):
    if depth <= 0 or (bottom - top <= 2) or (right - left <= 2):
        return
    if random.choice([True, False]):
        split_col = random.randint(left + 1, right - 1)
        for r in range(top, bottom):
            grid[r][split_col] = 1
        generate_recursive_boundaries(grid, top, bottom, left, split_col, depth - 1)
        generate_recursive_boundaries(grid, top, bottom, split_col, right, depth - 1)
    else:
        split_row = random.randint(top + 1, bottom - 1)
        for c in range(left, right):
            grid[split_row][c] = 2
        generate_recursive_boundaries(grid, top, split_row, left, right, depth - 1)
        generate_recursive_boundaries(grid, split_row, bottom, left, right, depth - 1)

def find_noise_positions(grid):
    height = len(grid)
    width = len(grid[0])
    noise_positions = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                continue
            adjacent_to_main = False
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] in [1, 2]:
                    adjacent_to_main = True
                    break
            if not adjacent_to_main:
                noise_positions.append((r, c))
    return noise_positions

def place_noise(grid, noise_positions):
    height = len(grid)
    width = len(grid[0])
    while noise_positions:
        r, c = random.choice(noise_positions)
        size = random.randint(1, 2)
        if size == 2:
            if r + 1 < height and c + 1 < width and (r+1, c) in noise_positions and (r, c+1) in noise_positions and (r+1, c+1) in noise_positions:
                color = random.randint(5, 9)
                for dr in range(2):
                    for dc in range(2):
                        grid[r+dr][c+dc] = color
                for dr in range(2):
                    for dc in range(2):
                        if (r+dr, c+dc) in noise_positions:
                            noise_positions.remove((r+dr, c+dc))
            else:
                color = random.randint(5, 9)
                grid[r][c] = color
                noise_positions.remove((r, c))
        else:
            color = random.randint(5, 9)
            grid[r][c] = color
            noise_positions.remove((r, c))

def generate():
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    grid_input = grid(width, height, 0)
    generate_recursive_boundaries(grid_input, 0, height, 0, width, 3)
    noise_positions = find_noise_positions(grid_input)
    place_noise(grid_input, noise_positions)
    grid_output = [row[:] for row in grid_input]
    main_structure = set()
    for r in range(height):
        for c in range(width):
            if grid_input[r][c] in [1, 2]:
                main_structure.add((r, c))
    for r in range(height):
        for c in range(width):
            if grid_output[r][c] in [5, 6, 7, 8, 9]:
                adj_to_main = False
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and (nr, nc) in main_structure:
                        adj_to_main = True
                        break
                if not adj_to_main:
                    grid_output[r][c] = 0
    visited = [[False] * width for _ in range(height)]
    from collections import deque
    for r in range(height):
        for c in range(width):
            if grid_output[r][c] == 0 and not visited[r][c]:
                queue = deque([(r, c)])
                visited[r][c] = True
                region_cells = []
                while queue:
                    cr, cc = queue.popleft()
                    region_cells.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and grid_output[nr][nc] == 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                min_r = min(cr for cr, cc in region_cells)
                max_r = max(cr for cr, cc in region_cells)
                min_c = min(cc for cr, cc in region_cells)
                max_c = max(cc for cr, cc in region_cells)
                height_region = max_r - min_r + 1
                width_region = max_c - min_c + 1
                fill_color = 3 if height_region > width_region else 4
                for cr, cc in region_cells:
                    grid_output[cr][cc] = fill_color
    return {
        "input": grid_input,
        "output": grid_output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    main_structure = set()
    for r in range(height):
        for c in range(width):
            if grid[r][c] in [1, 2]:
                main_structure.add((r, c))
    for r in range(height):
        for c in range(width):
            if grid[r][c] in [5, 6, 7, 8, 9]:
                adj_to_main = False
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and (nr, nc) in main_structure:
                        adj_to_main = True
                        break
                if not adj_to_main:
                    grid[r][c] = 0
    visited = [[False] * width for _ in range(height)]
    from collections import deque
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 and not visited[r][c]:
                queue = deque([(r, c)])
                visited[r][c] = True
                region_cells = []
                while queue:
                    cr, cc = queue.popleft()
                    region_cells.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                min_r = min(cr for cr, cc in region_cells)
                max_r = max(cr for cr, cc in region_cells)
                min_c = min(cc for cr, cc in region_cells)
                max_c = max(cc for cr, cc in region_cells)
                height_region = max_r - min_r + 1
                width_region = max_c - min_c + 1
                fill_color = 3 if height_region > width_region else 4
                for cr, cc in region_cells:
                    grid[cr][cc] = fill_color
    return tuple(tuple(row) for row in grid)
