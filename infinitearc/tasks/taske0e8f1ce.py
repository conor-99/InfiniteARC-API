# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: e0e8f1ce
Difficulty: hard

=== Tags ===
- Goal conditioned path
- Pattern repetition with offset
- Draw diagonal line
- Color the row with most dots

=== Description ===
# Task Description: Diagonal Pattern Target  Input grids are large (width and
height both greater than 20) with a uniform background color (0). Over this
background, colored cells (1–9) form dense arrangements where each row contains
a variable number of non-background cells. A single "goal" cell (a distinct
color, e.g., 9) is positioned within the grid, and a "pattern strip" appears
along the top edge as a repeating sequence of 2×2 color blocks (e.g., [3, 5, 7]
repeating cyclically).  The output grid transformation involves four key rules
applied in sequence: 1. **Target Row Identification**: The row with the highest
count of non-background cells is identified as the target row. 2. **Pattern
Offset Determination**: The starting position of the pattern sequence is offset
by the goal cell's column index modulo the pattern length. 3. **Diagonal Path
Drawing**: From the top-left corner (0,0), a diagonal line is drawn toward the
goal cell. The line segments alternate between two diagonal directions (top-left
to bottom-right and top-right to bottom-left) based on the current pattern
offset, with each segment colored using the next color in the cyclic pattern
sequence. 4. **Target Row Coloring**: The entire target row is recolored using
the last color applied during the diagonal path drawing.  The diagonal line is
drawn exclusively over background cells, never overlapping existing colored
cells or the pattern strip. The pattern strip and goal cell remain visible and
unchanged in the output. The target row's coloring uses a single solid color
derived from the pattern sequence, not a repeating pattern. The transformation
requires simultaneous identification of the target row, pattern offset
calculation, path direction determination, and color application—all critical
for the correct output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    from common import randint, random_colors, random_color

    # Size must be greater than 20
    size = randint(21, 30)

    # Create empty grid
    inp = [[0 for _ in range(size)] for _ in range(size)]

    # Create a repeating pattern of 2x2 blocks on the top edge.
    pattern_length = randint(2, 4)
    pattern_colors = random_colors(pattern_length, exclude=[9])

    # Ensure the pattern does not cover the top-left corner so the diagonal can start at (0,0)
    start_offset = randint(1, 2)

    # Place 2x2 blocks with a spacing of 1 column between blocks (block width 2, step 3)
    col = start_offset
    block_idx = 0
    while col + 1 < size:
        color = pattern_colors[block_idx % pattern_length]
        inp[0][col] = color
        inp[0][col + 1] = color
        inp[1][col] = color
        inp[1][col + 1] = color
        block_idx += 1
        col += 3

    # Place the goal cell (color 9) somewhere below the pattern rows
    goal_row = randint(2, size - 1)
    goal_col = randint(0, size - 1)
    inp[goal_row][goal_col] = 9

    # Simulate the diagonal path (on the empty/background-only cells) to reserve it so we don't
    # place other colored cells on the path. Use the same rule the solver will use:
    # offset = goal_col % pattern_length, start direction = offset % 2
    offset = goal_col % pattern_length
    current_idx = offset
    current_color = pattern_colors[current_idx]
    current_dir = offset % 2  # 0 -> (1,1), 1 -> (1,-1)
    directions = [(1, 1), (1, -1)]
    dr, dc = directions[current_dir]

    # Compute path positions and colors (but do NOT write them into the input grid)
    path = []  # list of (r, c, color)
    r, c = 0, 0
    # Ensure starting cell is background; start_offset guarantees inp[0][0] == 0
    while 0 <= r < size and 0 <= c < size and inp[r][c] == 0:
        path.append((r, c, current_color))
        # next tentative step
        rn, cn = r + dr, c + dc
        if not (0 <= rn < size and 0 <= cn < size) or inp[rn][cn] != 0:
            # switch direction and color
            current_dir = 1 - current_dir
            current_idx = (current_idx + 1) % pattern_length
            current_color = pattern_colors[current_idx]
            dr, dc = directions[current_dir]
            rn, cn = r + dr, c + dc
            if not (0 <= rn < size and 0 <= cn < size) or inp[rn][cn] != 0:
                break
        r, c = rn, cn

    # Build a set of reserved positions (pattern cells, goal, and the reserved path)
    reserved = set()
    for rr in (0, 1):
        for cc in range(size):
            if inp[rr][cc] != 0:
                reserved.add((rr, cc))
    reserved.add((goal_row, goal_col))
    for (pr, pc, _) in path:
        reserved.add((pr, pc))

    # Choose a target row candidate (not top two rows) that we will ensure ends up with the most non-background cells
    candidate_row = randint(2, max(2, size - 3))

    # Place other colored cells in the input, avoiding reserved positions
    for rr in range(size):
        if rr in (0, 1):
            continue
        # More cells for the candidate row so it tends to become the maximal row
        if rr == candidate_row:
            num_cells = randint(max(1, size // 2), max(1, size - 2))
        else:
            num_cells = randint(0, size // 2)
        # Find available columns on this row
        available = [cc for cc in range(size) if (rr, cc) not in reserved]
        if num_cells > len(available):
            num_cells = len(available)
        chosen_cols = random.sample(available, num_cells) if num_cells > 0 else []
        for cc in chosen_cols:
            inp[rr][cc] = random_color(exclude=[0, 9])
            reserved.add((rr, cc))

    # Ensure the chosen candidate_row is actually the unique maximum (and not row 0 or 1).
    counts = [sum(1 for x in row if x != 0) for row in inp]
    # If the top two rows accidentally have the maximum, boost candidate_row until it exceeds them
    if counts[candidate_row] <= max(counts[0], counts[1]):
        available = [cc for cc in range(size) if (candidate_row, cc) not in reserved]
        while available and counts[candidate_row] <= max(counts[0], counts[1]):
            cc = available.pop()
            inp[candidate_row][cc] = random_color(exclude=[0, 9])
            reserved.add((candidate_row, cc))
            counts[candidate_row] += 1
    # Recompute final target_row (first index of maximum)
    counts = [sum(1 for x in row if x != 0) for row in inp]
    target_row = counts.index(max(counts))
    # Safety: target_row should not be 0 or 1; if it is (extremely unlikely) pick another row
    if target_row in (0, 1):
        for rr in range(2, size):
            if rr not in (0, 1):
                target_row = rr
                break

    # Build the output grid: copy input then draw the path and finally recolor the target_row
    out = [row[:] for row in inp]

    # Draw the path using the same logic to obtain the last color used
    offset = goal_col % pattern_length
    current_idx = offset
    current_color = pattern_colors[current_idx]
    current_dir = offset % 2
    dr, dc = directions[current_dir]

    r, c = 0, 0
    last_color = current_color
    # Draw only on background cells and never touch pattern or the goal
    while 0 <= r < size and 0 <= c < size and inp[r][c] == 0 and out[r][c] == 0:
        out[r][c] = current_color
        last_color = current_color
        rn, cn = r + dr, c + dc
        if not (0 <= rn < size and 0 <= cn < size) or inp[rn][cn] != 0 or out[rn][cn] != 0:
            current_dir = 1 - current_dir
            current_idx = (current_idx + 1) % pattern_length
            current_color = pattern_colors[current_idx]
            dr, dc = directions[current_dir]
            rn, cn = r + dr, c + dc
            if not (0 <= rn < size and 0 <= cn < size) or inp[rn][cn] != 0 or out[rn][cn] != 0:
                break
        r, c = rn, cn

    # Recolor the entire target_row with the last color used, but do not overwrite the goal cell if it's on that row
    for cc in range(size):
        if (target_row, cc) == (goal_row, goal_col):
            continue
        out[target_row][cc] = last_color

    return {"input": inp, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to a mutable list of lists
    grid = [list(row) for row in input_grid]
    size = len(grid)

    # Find the goal cell (color 9)
    goal_row = None
    goal_col = None
    for r in range(size):
        for c in range(size):
            if grid[r][c] == 9:
                goal_row, goal_col = r, c
                break
        if goal_row is not None:
            break
    if goal_row is None:
        # Shouldn't happen for valid inputs, but safe fallback
        goal_row, goal_col = 0, 0

    # 1) Identify the target row from the input (row with the most non-background cells)
    counts = [sum(1 for x in row if x != 0) for row in grid]
    target_row = counts.index(max(counts))

    # 2) Extract the repeating 2x2 pattern from the top two rows. Look for 2x2 equal non-zero blocks.
    blocks = []
    c = 0
    while c < size - 1:
        if grid[0][c] != 0 and grid[0][c] == grid[0][c + 1] == grid[1][c] == grid[1][c + 1]:
            blocks.append(grid[0][c])
            c += 3
        else:
            c += 1
    if not blocks:
        pattern = [1, 2]
    else:
        # Find the minimal repeating period of blocks
        period = 1
        for p in range(1, len(blocks) + 1):
            ok = True
            for i in range(len(blocks)):
                if blocks[i] != blocks[i % p]:
                    ok = False
                    break
            if ok:
                period = p
                break
        pattern = blocks[:period]

    pattern_length = len(pattern)

    # 3) Determine offset by goal column modulo pattern length
    offset = goal_col % pattern_length

    # 4) Draw the diagonal path from (0,0) following the same rule as the generator
    out = [row[:] for row in grid]
    current_idx = offset
    current_color = pattern[current_idx]
    current_dir = offset % 2
    directions = [(1, 1), (1, -1)]
    dr, dc = directions[current_dir]

    r, c = 0, 0
    last_color = current_color
    # Draw only over background cells and never overwrite existing non-background cells (including pattern and goal)
    while 0 <= r < size and 0 <= c < size and grid[r][c] == 0 and out[r][c] == 0:
        out[r][c] = current_color
        last_color = current_color
        rn, cn = r + dr, c + dc
        if not (0 <= rn < size and 0 <= cn < size) or grid[rn][cn] != 0 or out[rn][cn] != 0:
            current_dir = 1 - current_dir
            current_idx = (current_idx + 1) % pattern_length
            current_color = pattern[current_idx]
            dr, dc = directions[current_dir]
            rn, cn = r + dr, c + dc
            if not (0 <= rn < size and 0 <= cn < size) or grid[rn][cn] != 0 or out[rn][cn] != 0:
                break
        r, c = rn, cn

    # 5) Recolor the entire target row with the last color used, but preserve the goal cell
    for cc in range(size):
        if (target_row, cc) == (goal_row, goal_col):
            continue
        out[target_row][cc] = last_color

    # Return as a tuple of tuples
    return tuple(tuple(row) for row in out)

