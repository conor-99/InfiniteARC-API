# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 513df0af
Difficulty: medium

=== Tags ===
- Outline shapes
- Pattern alignment

=== Description ===
The input grid contains multiple shapes defined as connected regions of non-zero
values, each potentially of a different color. The output grid is formed by
preserving only the boundary of each shape. A cell in the output retains its
input value if it is part of a shape and is adjacent (horizontally or
vertically) to either a background cell (0) or a cell belonging to a different
shape; otherwise, the cell is set to 0. This transformation results in the outer
perimeter of each shape being maintained while inner cells of the shapes are
removed, creating a clear outline effect for all shapes in the grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_pixels, random_colors
def get_components(pixels):
    visited = set()
    components = []
    for p in pixels:
        if p not in visited:
            comp = []
            stack = [p]
            visited.add(p)
            while stack:
                r, c = stack.pop()
                comp.append((r, c))
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    neighbor = (nr, nc)
                    if neighbor in pixels and neighbor not in visited:
                        visited.add(neighbor)
                        stack.append(neighbor)
            components.append(comp)
    return components
def compute_outline(grid):
    height = len(grid)
    width = len(grid[0])
    output = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0:
                output[r][c] = 0
                continue
            has_background_or_other = False
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if nr < 0 or nr >= height or nc < 0 or nc >= width:
                    has_background_or_other = True
                    break
                if grid[nr][nc] == 0 or grid[nr][nc] != grid[r][c]:
                    has_background_or_other = True
                    break
            if not has_background_or_other:
                output[r][c] = 0
    return output
def generate():
    while True:
        width = random.randint(5, 20)
        height = random.randint(5, 20)
        pixels = random_pixels(width, height, prob=0.7)
        components = get_components(pixels)
        if len(components) == 0 or not all(len(comp) >= 5 for comp in components):
            continue
        colors = random_colors(len(components), exclude=[0])
        input_grid = grid(width, height, 0)
        for i, comp in enumerate(components):
            for r, c in comp:
                input_grid[r][c] = colors[i]
        output_grid = compute_outline(input_grid)
        if input_grid != output_grid:
            return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    output = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                output[r][c] = 0
                continue
            has_background_or_other = False
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if nr < 0 or nr >= height or nc < 0 or nc >= width:
                    has_background_or_other = True
                    break
                if input_grid[nr][nc] == 0 or input_grid[nr][nc] != input_grid[r][c]:
                    has_background_or_other = True
                    break
            if not has_background_or_other:
                output[r][c] = 0
    return output
