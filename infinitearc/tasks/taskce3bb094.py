# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: ce3bb094
Difficulty: very hard

=== Tags ===
- Non overwriting draw
- Progressive rule shift
- Color by rank in row

=== Description ===
Input grids are 2D color grids (1×1 to 30×30) with colors 0-9, where 0
represents background. Each row contains multiple non-background colors (1-9),
with possible duplicates. The transformation requires identifying unique non-
background colors in each row, sorting them numerically (ascending order), and
assigning each a rank (1-based). For each rank *k* in the sorted list, a line is
drawn from the leftmost occurrence of that color's value in the row. The line
direction progresses cyclically per row index *i*: right (0 mod 4), down (1 mod
4), left (2 mod 4), up (3 mod 4), repeating. The line spans *k* cells in the
direction, using color *k* (not the original cell color), only on background (0)
cells—never overwriting existing non-background elements. The output grid
retains all original non-background elements and adds these new lines
exclusively on background cells. The progression of line directions (right →
down → left → up) and the use of rank-based color for lines create layered, non-
obvious rules requiring multi-step reasoning to discover.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Choose a moderately sized grid to allow placements in all four directions
    width = random.randint(4, 12)
    height = random.randint(4, 12)

    # Initialize input grid with background (0)
    input_grid = [[0 for _ in range(width)] for _ in range(height)]

    def find_columns_for_row(width, m, d):
        """Find a feasible list of distinct column indices for ranks 1..m in a row
        following the directional constraints. Returns a list of length m or None.
        """
        allowed = []
        for k in range(1, m + 1):
            if d == 0:  # right: j <= width-1-k
                j_max = width - 1 - k
                if j_max < 0:
                    return None
                allowed.append(list(range(0, j_max + 1)))
            elif d == 2:  # left: j >= k
                j_min = k
                if j_min > width - 1:
                    return None
                allowed.append(list(range(j_min, width)))
            else:
                # vertical directions: any column is fine for placement
                allowed.append(list(range(0, width)))

        assignment = [None] * m
        used = set()

        def dfs(idx):
            if idx == m:
                return True
            opts = allowed[idx][:]
            random.shuffle(opts)
            rank = idx + 1
            for c in opts:
                if c in used:
                    continue
                # Avoid placing a token inside the path of any already-placed token in the same row
                conflict = False
                for prev_idx in range(idx):
                    p_col = assignment[prev_idx]
                    p_rank = prev_idx + 1
                    if d == 0:
                        # prev's path: p_col+1 .. p_col+p_rank
                        if c > p_col and c <= p_col + p_rank:
                            conflict = True
                            break
                        # this's path: c+1 .. c+rank should not include p_col
                        if p_col > c and p_col <= c + rank:
                            conflict = True
                            break
                    elif d == 2:
                        # prev's path: p_col-p_rank .. p_col-1
                        if c < p_col and c >= p_col - p_rank:
                            conflict = True
                            break
                        if p_col < c and p_col >= c - rank:
                            conflict = True
                            break
                    else:
                        # For vertical directions we do not enforce horizontal path conflicts
                        # (vertical paths extend across different rows), to keep variety.
                        pass
                if conflict:
                    continue
                assignment[idx] = c
                used.add(c)
                if dfs(idx + 1):
                    return True
                used.remove(c)
                assignment[idx] = None
            return False

        if dfs(0):
            return assignment
        return None

    # Ensure there's at least one row that will produce visible drawing; pick row 0
    guarantee_row = 0

    for i in range(height):
        d = i % 4
        # Maximum distinct colors we'll try to place in a row
        m_max = min(4, width)
        if d == 1:
            cap = height - 1 - i
            if cap < 1:
                m_max = 0
            else:
                m_max = min(m_max, cap)
        elif d == 3:
            cap = i
            if cap < 1:
                m_max = 0
            else:
                m_max = min(m_max, cap)

        if m_max <= 0:
            # No feasible rank > 0 for this row in its direction; leave row blank
            continue

        # Pick number of unique colors for this row
        if i == guarantee_row:
            # force at least one color in guarantee row so output differs from input
            m = random.randint(1, m_max)
        else:
            m = random.randint(1, m_max)

        # Choose m distinct non-background colors and sort them to determine rank order
        colors = sorted(random.sample(range(1, 10), m))

        cols = find_columns_for_row(width, m, d)
        if cols is None:
            # Try reducing m until feasible
            placed = False
            for new_m in range(m - 1, 0, -1):
                cols_try = find_columns_for_row(width, new_m, d)
                if cols_try is not None:
                    m = new_m
                    colors = colors[:m]
                    cols = cols_try
                    placed = True
                    break
            if not placed:
                # give up on this row
                continue

        # Place the leftmost occurrences (we place exactly one instance per unique color)
        for k, col in enumerate(cols):
            input_grid[i][col] = colors[k]

    # Produce output by drawing rank-colored segments without overwriting non-background
    output_grid = [row[:] for row in input_grid]
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    for i in range(height):
        row = input_grid[i]
        unique_colors = sorted(set(x for x in row if x != 0))
        for k, color_val in enumerate(unique_colors):
            # leftmost occurrence
            j = next(idx for idx, v in enumerate(row) if v == color_val)
            d = i % 4
            dr, dc = directions[d]
            rank = k + 1
            for step in range(1, rank + 1):
                ni = i + dr * step
                nj = j + dc * step
                if 0 <= ni < height and 0 <= nj < width and input_grid[ni][nj] == 0:
                    output_grid[ni][nj] = rank

    # Sanity: ensure the output differs from input (guarantee_row logic should make this true)
    if output_grid == input_grid:
        # extremely unlikely, but if it happens, retry generation once
        return generate()

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable list of lists
    inp = [list(row) for row in input_grid]
    height = len(inp)
    width = len(inp[0]) if height > 0 else 0
    output = [row[:] for row in inp]
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    for i in range(height):
        row = inp[i]
        # unique non-background colors sorted ascending
        unique_colors = sorted(set(x for x in row if x != 0))
        for k, color_val in enumerate(unique_colors):
            # leftmost occurrence
            j = next(idx for idx, v in enumerate(row) if v == color_val)
            d = i % 4
            dr, dc = directions[d]
            rank = k + 1
            for step in range(1, rank + 1):
                ni = i + dr * step
                nj = j + dc * step
                if 0 <= ni < height and 0 <= nj < width and inp[ni][nj] == 0:
                    output[ni][nj] = rank
    # Return as immutable tuple of tuples
    return tuple(tuple(r) for r in output)

