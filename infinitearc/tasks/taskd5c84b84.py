# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: d5c84b84
Difficulty: hard

=== Tags ===
- Rule priority resolution
- Color modulated logic
- Guided flow
- Relational projection

=== Description ===
Input grids feature a background (value 0) overlaid with multiple colored
regions (values 1–9), each representing a distinct logic state with an inherent
direction (e.g., color 1 = right, color 2 = down, color 3 = left, color 4 = up)
and a fixed priority order (higher color values = higher priority). The grid
contains a designated starting point (typically a color 5 cell at the top-left
corner).   The output grid is generated through a multi-step process: First, a
guided flow originates from the starting cell and propagates orthogonally
according to the current cell's direction. At each step, the flow checks the
priority of the next cell's color—if it has higher priority than the current
direction's priority, the flow direction updates to the new cell's direction.
This rule priority resolution determines the path's curvature. The flow path is
visualized in the output using a dedicated "flow" color (e.g., color 9), while
all original colors remain intact. Crucially, cells that influenced the flow
direction (via priority resolution) are marked with a secondary color (e.g.,
color 8) proportional to their priority level, creating a layered relational
projection. This projection reveals how higher-priority colors modulated the
flow's trajectory across the grid, with the final output displaying both the
active flow path and the underlying priority-driven relational structure. The
process terminates when the flow exits the grid boundary, ensuring no loops or
overlaps, and all transformations adhere strictly to the color-modulated logic
rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Faster generator variant for ARC task d5c84b84
# Create a monotone path from (0,0) to the right border and assign colors greedily.

def generate():
    # smaller sizes to guarantee fast generation
    width = random.randint(6, 12)
    height = random.randint(6, 12)
    if width < 2:
        width = 2

    input_grid = grid(width, height, 0)
    start = (0, 0)
    input_grid[0][0] = 5

    DIRS = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up
    color_groups = {
        (0, 1): [1, 5, 9],
        (1, 0): [2, 6],
        (0, -1): [3, 7],
        (-1, 0): [4, 8]
    }

    def dir_of(color):
        return DIRS[(color - 1) % 4]

    # Choose an end on the right border (ensures first step is right)
    end_row = random.randint(1, height - 1) if height > 1 else 0
    horizontal_steps = width - 1
    vertical_steps = end_row

    # Build randomized move sequence with first move guaranteed R
    tail = ['R'] * (horizontal_steps - 1) + ['D'] * vertical_steps
    random.shuffle(tail)
    moves = ['R'] + tail

    # Build the path coordinates
    path = [start]
    r, c = start
    for m in moves:
        if m == 'R':
            c += 1
        else:
            r += 1
        path.append((r, c))

    n = len(path)
    if n < 3:
        # fallback: simple straight line to the right
        path = [start]
        for cc in range(1, width):
            path.append((0, cc))
        n = len(path)

    # Greedy color assignment from left to right along the path
    colors = [None] * n
    colors[0] = 5
    for i in range(1, n):
        if i < n - 1:
            desired = (path[i + 1][0] - path[i][0], path[i + 1][1] - path[i][1])
        else:
            # last - point outward to the right (since we ended on right border)
            desired = (0, 1)
        grp = sorted(color_groups.get(desired, [1]))
        prev = colors[i - 1]
        # pick smallest allowed color >= prev if possible, otherwise smallest allowed
        cand = None
        for v in grp:
            if v >= prev:
                cand = v
                break
        if cand is None:
            cand = grp[0]
        colors[i] = cand

    # Paint the path into the input grid
    for (pr, pc), col in zip(path, colors):
        input_grid[pr][pc] = col

    # Add a few small colored blobs (avoid color 5) to create other regions
    remaining = [(rr, cc) for rr in range(height) for cc in range(width) if (rr, cc) not in set(path)]
    random.shuffle(remaining)
    num_blobs = random.randint(1, 3)
    used = set(path)
    for _ in range(num_blobs):
        if not remaining:
            break
        br, bc = remaining.pop()
        blob_color = random.choice([x for x in range(1, 10) if x != 5])
        input_grid[br][bc] = blob_color
        used.add((br, bc))
        blob_cells = [(br, bc)]
        blob_size = random.randint(1, 3)
        for __ in range(blob_size - 1):
            candidates = []
            for (ar, ac) in blob_cells:
                for dr, dc in DIRS:
                    nr, nc = ar + dr, ac + dc
                    if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in used:
                        candidates.append((nr, nc))
            if not candidates:
                break
            nr, nc = random.choice(candidates)
            input_grid[nr][nc] = blob_color
            used.add((nr, nc))
            blob_cells.append((nr, nc))

    # Simulate flow to create output
    output_grid = [row[:] for row in input_grid]
    r, c = start
    current_priority = input_grid[r][c]
    direction = dir_of(current_priority)
    flow_path = [(r, c)]
    influencing = set()
    while True:
        nr, nc = r + direction[0], c + direction[1]
        if not (0 <= nr < height and 0 <= nc < width):
            break
        if input_grid[nr][nc] == 0:
            break
        next_color = input_grid[nr][nc]
        if next_color > current_priority:
            influencing.add((nr, nc))
            current_priority = next_color
            direction = dir_of(next_color)
        r, c = nr, nc
        flow_path.append((r, c))

    for (pr, pc) in flow_path:
        if (pr, pc) in influencing:
            output_grid[pr][pc] = 8
        else:
            output_grid[pr][pc] = 9

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert tuple-of-tuples to list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    DIRS = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up
    def dir_of(color):
        return DIRS[(color - 1) % 4]

    # find start
    start = None
    if height > 0 and width > 0 and grid[0][0] == 5:
        start = (0, 0)
    else:
        for r in range(height):
            for c in range(width):
                if grid[r][c] == 5:
                    start = (r, c)
                    break
            if start:
                break
    if not start:
        return [row[:] for row in grid]

    r, c = start
    current_priority = grid[r][c]
    direction = dir_of(current_priority)
    flow_path = [(r, c)]
    influencing = set()

    while True:
        nr, nc = r + direction[0], c + direction[1]
        if not (0 <= nr < height and 0 <= nc < width):
            break
        if grid[nr][nc] == 0:
            break
        next_color = grid[nr][nc]
        if next_color > current_priority:
            influencing.add((nr, nc))
            current_priority = next_color
            direction = dir_of(next_color)
        r, c = nr, nc
        flow_path.append((r, c))

    output = [row[:] for row in grid]
    for (rr, cc) in flow_path:
        if (rr, cc) in influencing:
            output[rr][cc] = 8
        else:
            output[rr][cc] = 9
    return output

