# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: ab35dec7
Difficulty: mediumâ€“hard

=== Tags ===
- Pattern intersection
- Momentum transfer

=== Description ===
**Task Name: Momentum Intersection Paths**  **Description:**    Input grids
feature a background color (0) and two types of directional patterns: horizontal
patterns (color 1, represented as right-pointing arrows) and vertical patterns
(color 2, represented as up-pointing arrows). These patterns may intersect at
right angles, creating cross-shaped cells where both horizontal and vertical
patterns overlap. Scattered on the background are moving elements (color 3),
each with an initial movement direction (left, right, up, or down).    The
output grid is generated by tracing the complete path of each moving element as
it traverses the grid. Elements move in their initial direction until they
encounter a pattern cell. Upon entering a horizontal pattern cell (color 1), the
element immediately changes direction to move right (regardless of its initial
direction). Upon entering a vertical pattern cell (color 2), the element
immediately changes direction to move up. At intersection cells (color 1 and
color 2), the element prioritizes the horizontal pattern's direction (right)
over the vertical pattern's direction (up).    The path of each element is drawn
as color 3, starting from its original position and continuing until the element
exits the grid boundary. Elements that exit the grid are not drawn beyond the
boundary. The original patterns (colors 1 and 2) remain unchanged in the output
grid, and no other elements or features are added or modified.    This task
requires recognizing the pattern types, their intersections, and applying the
momentum transfer rule (direction change) at each pattern encounter, resulting
in a transformed grid that visualizes the elements' paths.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    input_grid = grid(width, height, 0)
    
    for _ in range(random.randint(2, 4)):
        row = random.randint(1, height - 2)
        start_col = random.randint(2, width - 3)
        end_col = random.randint(start_col + 1, width - 2)
        for c in range(start_col, end_col + 1):
            input_grid[row][c] = 1
    
    for _ in range(random.randint(2, 4)):
        col = random.randint(1, width - 2)
        start_row = random.randint(2, height - 3)
        end_row = random.randint(start_row + 1, height - 2)
        for r in range(start_row, end_row + 1):
            if input_grid[r][col] == 0:
                input_grid[r][col] = 2
    
    for r in range(height):
        if input_grid[r][0] == 0:
            input_grid[r][0] = 3
    
    output_grid = [row[:] for row in input_grid]
    
    for r in range(height):
        if input_grid[r][0] == 3:
            current_r, current_c = r, 0
            direction = (0, 1)
            while True:
                next_r = current_r + direction[0]
                next_c = current_c + direction[1]
                if next_r < 0 or next_r >= height or next_c < 0 or next_c >= width:
                    break
                cell_color = input_grid[next_r][next_c]
                if cell_color == 1:
                    direction = (0, 1)
                elif cell_color == 2:
                    direction = (-1, 0)
                if cell_color == 0:
                    output_grid[next_r][next_c] = 3
                current_r, current_c = next_r, next_c
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = [row[:] for row in input_grid]
    
    for r in range(height):
        if input_grid[r][0] == 3:
            current_r, current_c = r, 0
            direction = (0, 1)
            while True:
                next_r = current_r + direction[0]
                next_c = current_c + direction[1]
                if next_r < 0 or next_r >= height or next_c < 0 or next_c >= width:
                    break
                cell_color = input_grid[next_r][next_c]
                if cell_color == 1:
                    direction = (0, 1)
                elif cell_color == 2:
                    direction = (-1, 0)
                if cell_color == 0:
                    output_grid[next_r][next_c] = 3
                current_r, current_c = next_r, next_c
    return output_grid
