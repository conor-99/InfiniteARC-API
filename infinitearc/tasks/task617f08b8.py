# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 617f08b8
Difficulty: hard

=== Tags ===
- Multi object alignment
- Recursive partition
- Viewpoint normalization

=== Description ===
The task involves transforming input grids containing multiple disconnected
colored objects (connected components of non-zero values) into output grids
through a sequence of abstract visual operations. Each input grid features
objects of distinct colors arranged in arbitrary orientations and positions,
with the background represented by 0.   The transformation requires three core
operations applied in sequence:  1. **Viewpoint normalization**: For each
object, determine its dominant orientation (e.g., the direction where its
bounding box is most axis-aligned) and rotate the object to align with the
grid's vertical/horizontal axes. This eliminates rotational variations while
preserving object shape. 2. **Multi-object alignment**: After normalization,
position all objects such that their lowest points (bases) align to a common
horizontal line within their current grid partition. Objects are shifted
vertically to share this base line while maintaining their relative horizontal
spacing. 3. **Recursive partition**: The grid is hierarchically divided into
quadrants (e.g., top-left, top-right, bottom-left, bottom-right), with each
quadrant recursively subdivided until regions reach a minimal size (e.g., 2Ã—2).
Within each partition, the normalization and alignment steps are reapplied to
objects contained within that region, creating a nested alignment pattern across
all hierarchical levels.  The output grid reflects this hierarchical alignment:
objects are consistently oriented, their bases are aligned to partition-specific
reference lines, and the recursive partitioning creates a fractal-like structure
where alignment rules propagate from the largest grid scale down to the smallest
subdivisions. The complexity arises from requiring simultaneous application of
orientation correction, spatial repositioning, and hierarchical partitioning
across all object groupings.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_el, random_you

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    output_grid = grid(width, height, 0)
    colors = random.sample(range(1, 10), 2)
    obj1 = random_el(width, height)
    for r, c in obj1:
        output_grid[r][c] = colors[0]
    obj2 = random_you(width, height)
    for r, c in obj2:
        output_grid[r][c] = colors[1]
    input_grid = [list(x) for x in zip(*output_grid)]
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    return [list(x) for x in zip(*input_grid)]
