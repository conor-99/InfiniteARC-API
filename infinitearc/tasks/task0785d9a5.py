# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 0785d9a5
Difficulty: very hard

=== Tags ===
- State transfer chain
- Flow with decay
- Layered path system
- Even or odd

=== Description ===
**Task Name: Layered State Transfer Flow**    **Description:**   Input grids
depict a complex network of non-overlapping, straight-line paths (each path is a
sequence of connected cells of a single color) that originate from unique source
cells (marked by a color distinct from all others) and terminate at sink cells
(another distinct color). Paths move in cardinal directions (up/down/left/right)
and may cross over other paths at intersections without sharing cells. The grid
also contains **state transition markers** (specific colors) placed along paths
at regular intervals. These markers trigger a **state transfer chain** where the
path’s color alternates between two predefined colors (e.g., `red` ↔ `blue`)
*whenever a marker is traversed*.    The **flow with decay** rule dictates that
after three consecutive state transitions (i.e., traversing three markers), the
path decays to the background color for all subsequent cells. The **layered path
system** ensures that each path’s transitions occur independently, creating
overlapping visual layers where adjacent segments of the same path alternate
between colors in a cascading pattern. The **even or odd** aspect is embedded in
the transition sequence: the *first* marker triggers a transition to the *odd
layer* color, the *second* to the *even layer* color, the *third* to the *odd
layer* color again, and the fourth transition (if it occurred) would decay the
path.    In the output grid:   - All paths retain their original structure and
marker positions.   - Each cell in a path is recolored based on the *parity of
the number of markers traversed up to that cell* (odd count = odd layer color,
even count = even layer color).   - Paths that traverse ≥3 markers decay to
background color beyond the third marker.   - The background color remains
unchanged except for decayed segments.   - **No two paths
interact**—transitions, decay, and layering are path-specific.    The task
requires identifying the state transition sequence for each path, applying the
parity-based color alternation, and enforcing decay rules without visual overlap
or interaction between paths. The output visually manifests the layered flow as
alternating bands of color along each path, with decayed segments fading into
the background.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    # Colors (must be consistent with solver)
    BG = 0
    ODD = 2
    EVEN = 3
    MARKER = 5
    BASE = 1  # base color used for path body in the input

    # pool of unique source colors (one unique color per path)
    SOURCE_POOL = [4, 6, 7, 8, 9]

    # Grid size
    width = random.randint(6, 20)
    height = random.randint(6, 20)
    grid = common.grid(width, height, BG)

    paths = []

    # number of paths to place
    num_paths = random.randint(2, min(5, len(SOURCE_POOL)))
    src_colors = random.sample(SOURCE_POOL, num_paths)

    placed = 0
    attempts = 0
    max_attempts = num_paths * 60

    while placed < num_paths and attempts < max_attempts:
        attempts += 1
        orientation = random.choice(["h", "v"])  # horizontal or vertical
        if orientation == "h":
            length = random.randint(5, min(12, width))
            r = random.randint(0, height - 1)
            c0 = random.randint(0, width - length)
            candidate = [(r, c0 + i) for i in range(length)]
        else:
            length = random.randint(5, min(12, height))
            c = random.randint(0, width - 1)
            r0 = random.randint(0, height - length)
            candidate = [(r0 + i, c) for i in range(length)]

        # Check cells are free and not adjacent (edge-adjacent) to other paths
        ok = True
        for (cr, cc) in candidate:
            if grid[cr][cc] != BG:
                ok = False
                break
            # orthogonal neighbors must be empty unless they are part of this candidate
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = cr + dr, cc + dc
                if 0 <= nr < height and 0 <= nc < width:
                    if (nr, nc) in candidate:
                        continue
                    if grid[nr][nc] != BG:
                        ok = False
                        break
            if not ok:
                break
        if not ok:
            continue

        # Place base color
        for (cr, cc) in candidate:
            grid[cr][cc] = BASE

        # Place markers at a regular interval; ensure first cell (index 0) is not turned into a marker
        interval = random.choice([3, 4])
        offset = random.randint(1, interval)  # start at least at index 1 so source isn't overwritten
        marker_indices = [i for i in range(offset, length, interval)]
        if len(marker_indices) == 0:
            # ensure at least one marker exists on this path
            marker_indices = [length // 2]
        for i in marker_indices:
            if 0 <= i < length:
                mr, mc = candidate[i]
                grid[mr][mc] = MARKER

        # Assign a unique source color to the first cell of the path
        src_color = src_colors[placed]
        sr, sc = candidate[0]
        grid[sr][sc] = src_color

        paths.append({"cells": candidate, "src": src_color})
        placed += 1

    # Build the output by applying the parity/decay rules per path
    output = [row[:] for row in grid]

    for path in paths:
        count = 0
        for (r, c) in path["cells"]:
            if grid[r][c] == MARKER:
                count += 1
            if count <= 3:
                output[r][c] = ODD if (count % 2 == 1) else EVEN
            else:
                output[r][c] = BG

    # Guarantee at least one marker somewhere in the grid (safer for solver expectations)
    any_marker = any(grid[r][c] == MARKER for r in range(height) for c in range(width))
    if not any_marker and paths:
        # force a marker into the first path (not at index 0)
        p = paths[0]["cells"]
        idx = min(2, len(p) - 1)
        r, c = p[idx]
        grid[r][c] = MARKER
        # recompute output for that path
        count = 0
        for (rr, cc) in p:
            if grid[rr][cc] == MARKER:
                count += 1
            if count <= 3:
                output[rr][cc] = ODD if (count % 2 == 1) else EVEN
            else:
                output[rr][cc] = BG

    # Ensure input != output (force at least one difference)
    if output == grid:
        # flip one non-source non-marker cell on first path into a marker
        for path in paths:
            for (r, c) in path["cells"]:
                if grid[r][c] != MARKER and grid[r][c] != path["src"]:
                    grid[r][c] = MARKER
                    # recompute the whole output
                    output = [row[:] for row in grid]
                    for path2 in paths:
                        count = 0
                        for (rr, cc) in path2["cells"]:
                            if grid[rr][cc] == MARKER:
                                count += 1
                            if count <= 3:
                                output[rr][cc] = ODD if (count % 2 == 1) else EVEN
                            else:
                                output[rr][cc] = BG
                    break
            if output != grid:
                break

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    BG = 0
    ODD = 2
    EVEN = 3
    MARKER = 5

    # Count occurrences of each color to detect unique source markers
    counts = {}
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            counts[v] = counts.get(v, 0) + 1

    # Cells that appear exactly once (and are not background/marker/odd/even) are treated as path sources
    unique_starts = []
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if v != BG and v != MARKER and v != ODD and v != EVEN and counts.get(v, 0) == 1:
                unique_starts.append((r, c))

    visited = [[False] * width for _ in range(height)]
    output = [row[:] for row in grid]

    def collect_component(sr, sc):
        # collect all orthogonally connected non-background cells
        stack = [(sr, sc)]
        comp = set()
        while stack:
            r, c = stack.pop()
            if (r, c) in comp:
                continue
            if grid[r][c] == BG:
                continue
            comp.add((r, c))
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != BG and (nr, nc) not in comp:
                    stack.append((nr, nc))
        return comp

    def order_path_from_start(comp_set, start):
        # Build neighbor map for the component
        neigh = {cell: [] for cell in comp_set}
        for (r, c) in comp_set:
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if (nr, nc) in comp_set:
                    neigh[(r, c)].append((nr, nc))
        # Walk from the given start along the chain
        ordered = [start]
        prev = None
        cur = start
        while True:
            candidates = [n for n in neigh[cur] if n != prev]
            if not candidates:
                break
            # deterministic: sort candidate list so solver is deterministic (though should be only one)
            candidates.sort()
            nxt = candidates[0]
            ordered.append(nxt)
            prev, cur = cur, nxt
        return ordered

    # First handle components that have an identified unique source
    for (sr, sc) in unique_starts:
        if visited[sr][sc] or grid[sr][sc] == BG:
            continue
        comp = collect_component(sr, sc)
        ordered = order_path_from_start(comp, (sr, sc))
        # apply parity/decay rules along this ordered path
        count = 0
        for (r, c) in ordered:
            visited[r][c] = True
            if grid[r][c] == MARKER:
                count += 1
            if count <= 3:
                output[r][c] = ODD if (count % 2 == 1) else EVEN
            else:
                output[r][c] = BG

    # Then handle any remaining unvisited non-background components
    for r in range(height):
        for c in range(width):
            if visited[r][c] or grid[r][c] == BG:
                continue
            comp = collect_component(r, c)
            # build neighbor map and find endpoints (degree <= 1)
            neigh = {cell: [] for cell in comp}
            for (rr, cc) in comp:
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = rr + dr, cc + dc
                    if (nr, nc) in comp:
                        neigh[(rr, cc)].append((nr, nc))
            endpoints = [cell for cell, nbs in neigh.items() if len(nbs) <= 1]
            if endpoints:
                start = sorted(endpoints)[0]
            else:
                start = sorted(comp)[0]
            ordered = order_path_from_start(comp, start)
            count = 0
            for (rr, cc) in ordered:
                visited[rr][cc] = True
                if grid[rr][cc] == MARKER:
                    count += 1
                if count <= 3:
                    output[rr][cc] = ODD if (count % 2 == 1) else EVEN
                else:
                    output[rr][cc] = BG

    return output

