# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 2d3f3a1c
Difficulty: medium–hard

=== Tags ===
- Field based motion
- Rotating signal
- Multi exit routes
- Ex nihilo

=== Description ===
# Task Description: Rotating Signal Pathways  Input grids are medium to large
(10×10 to 25×25) with a single background color (0). Within this grid, scattered
obstacles appear as walls (color 1), and the grid contains a single starting
signal cell (color 2) positioned along the left edge (not adjacent to walls).
The grid also features scattered rotator cells (color 3), which are the only
cells affecting signal direction.   The signal begins moving rightward from its
starting position. Upon encountering a rotator cell (color 3), the signal turns
90 degrees clockwise (right → down → left → up → right) while continuing its
path. The signal traverses only background cells (0) and rotator cells (3),
avoiding walls (1) entirely. As the signal moves, it leaves a visible trail of
its path using color 2. The signal continues moving until it exits the grid
through one of its edges.  Upon exiting, the signal "ex nihilo" creates a new
visual structure within the grid based on the exit direction: - Exiting right
(rightmost column): A vertical line of 3 cells (color 5) extends upward from the
exit cell. - Exiting upward (top row): A horizontal line of 3 cells (color 6)
extends rightward from the exit cell. - Exiting downward (bottom row): A
horizontal line of 3 cells (color 7) extends leftward from the exit cell. -
Exiting left (leftmost column): Not possible due to starting position.  The
output grid retains all original elements (walls, rotators, starting cell) but
replaces the signal path with color 2 and adds the appropriate exit structure
based on the exit direction. The exit structure is drawn entirely within the
grid boundaries, never overlapping walls, rotators, or the signal path. No two
signals exist, and all exit structures are generated exclusively from the
signal's final exit direction.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random


def generate():
    # Create a grid with a guaranteed valid signal path that obeys clockwise-only rotators
    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up

    def check_exit_fits(w, h, path_set, rot_set, exit_dir, exit_cell):
        r, c = exit_cell
        # right exit: vertical line of 3 cells upwards from exit cell
        if exit_dir == 0:
            if c != w - 1:
                return False
            for i in range(1, 4):
                rr = r - i
                if rr < 0:
                    return False
                if (rr, c) in path_set or (rr, c) in rot_set:
                    return False
            return True
        # down exit: horizontal line of 3 cells leftward from exit cell
        if exit_dir == 1:
            if r != h - 1:
                return False
            for i in range(1, 4):
                cc = c - i
                if cc < 0:
                    return False
                if (r, cc) in path_set or (r, cc) in rot_set:
                    return False
            return True
        # left (idx 2) should not be allowed
        if exit_dir == 2:
            return False
        # up exit: horizontal line of 3 cells rightward from exit cell
        if exit_dir == 3:
            if r != 0:
                return False
            for i in range(1, 4):
                cc = c + i
                if cc >= w:
                    return False
                if (r, cc) in path_set or (r, cc) in rot_set:
                    return False
            return True
        return False

    def try_build_path(w, h, start_r, max_steps=2000):
        dir_idx = 0
        path = [(start_r, 0)]
        visited = {path[0]}
        rotators = set()
        # we'll try to build until exit or until a dead-end
        for step in range(max_steps):
            r, c = path[-1]
            dr, dc = dirs[dir_idx]
            nr, nc = r + dr, c + dc
            # exit check
            if not (0 <= nr < h and 0 <= nc < w):
                exit_dir = dir_idx
                # left exit forbidden
                if exit_dir == 2:
                    return None
                # check exit structure fits
                if not check_exit_fits(w, h, set(path), rotators, exit_dir, (r, c)):
                    return None
                # require at least one rotator on the path to match "rotating signal" tag
                if len(rotators) == 0:
                    return None
                return path, rotators, exit_dir, (r, c)
            # next cell inside grid
            if (nr, nc) in visited:
                return None
            # Decide whether the next cell will be a rotator (which causes a clockwise turn after stepping on it)
            # We bias to sometimes create rotators but ensure at least one appears by forcing one after a while
            force_rotator = (step > max(6, (w + h) // 4) and len(rotators) == 0)
            make_rotator = force_rotator or (random.random() < 0.25)
            path.append((nr, nc))
            visited.add((nr, nc))
            if make_rotator:
                rotators.add((nr, nc))
                dir_idx = (dir_idx + 1) % 4
            # continue until exit
        return None

    # Try several attempts to build a valid path; if we fail, retry with different sizes
    attempts = 0
    while attempts < 500:
        attempts += 1
        width = random.randint(10, 25)
        height = random.randint(10, 25)
        # pick start row with some margin so exit-structures have space more often
        start_row = random.randint(3, height - 4)
        result = try_build_path(width, height, start_row)
        if result is None:
            continue
        path, rotators_on_path, exit_dir_idx, exit_cell = result
        path_set = set(path)
        # Build an empty grid (background 0)
        grid = [[0 for _ in range(width)] for _ in range(height)]
        # Place some additional scattered rotators not on the path
        additional_rot_count = random.randint(0, max(0, (width * height) // 150))
        extra_rotators = set()
        free_cells = [(r, c) for r in range(height) for c in range(width) if (r, c) not in path_set and not (r, c) == (start_row, 0)]
        random.shuffle(free_cells)
        for (rr, cc) in free_cells[:additional_rot_count]:
            extra_rotators.add((rr, cc))
        # Place walls randomly, but never on the path, exit-structure cells, or adjacent to the start
        wall_prob = 0.12
        walls = set()
        # compute reserved cells we must not place walls on: path and rotators and a small neighborhood of start
        reserved = set(path_set) | rotators_on_path | extra_rotators | {exit_cell}
        sr, sc = path[0]
        for dr, dc in [(0, 0), (1, 0), (-1, 0), (0, 1)]:
            rr, cc = sr + dr, sc + dc
            if 0 <= rr < height and 0 <= cc < width:
                reserved.add((rr, cc))
        for r in range(height):
            for c in range(width):
                if (r, c) in reserved:
                    continue
                if random.random() < wall_prob:
                    walls.add((r, c))
        # Ensure there's at least one wall to satisfy "scattered obstacles" in description
        if len(walls) == 0:
            # add a wall somewhere not reserved
            for r in range(height):
                added = False
                for c in range(width):
                    if (r, c) not in reserved and (r, c) != (start_row, 0):
                        walls.add((r, c))
                        added = True
                        break
                if added:
                    break
        # Now place the components into the input grid
        for (r, c) in walls:
            grid[r][c] = 1
        for (r, c) in extra_rotators:
            grid[r][c] = 3
        for (r, c) in rotators_on_path:
            grid[r][c] = 3
        # Place a single starting signal cell (color 2) on the left edge
        grid[start_row][0] = 2
        # Double-check the start isn't adjacent to walls
        for dr, dc in [(-1, 0), (1, 0), (0, 1)]:
            rr, cc = start_row + dr, 0 + dc
            if 0 <= rr < height and 0 <= cc < width and grid[rr][cc] == 1:
                grid[rr][cc] = 0
        # Build the output grid by copying input and painting the traversed path with color 2
        output = [row[:] for row in grid]
        for (r, c) in path:
            output[r][c] = 2
        # Add the exit structure according to the exit direction
        exit_r, exit_c = exit_cell
        if exit_dir_idx == 0:  # exited to the right
            # vertical line of 3 cells upward from the exit cell
            for i in range(1, 4):
                rr = exit_r - i
                if 0 <= rr < height:
                    output[rr][exit_c] = 5
        elif exit_dir_idx == 1:  # exited downward
            # horizontal line of 3 cells leftward from the exit cell
            for i in range(1, 4):
                cc = exit_c - i
                if 0 <= cc < width:
                    output[exit_r][cc] = 7
        elif exit_dir_idx == 3:  # exited upward
            # horizontal line of 3 cells rightward from the exit cell
            for i in range(1, 4):
                cc = exit_c + i
                if 0 <= cc < width:
                    output[exit_r][cc] = 6
        # Make sure input != output
        if grid == output:
            continue
        return {"input": grid, "output": output}
    # If we failed to build a path after many attempts, create a simple guaranteed-case
    # Straight path to the right with one rotator in the middle
    width = random.randint(10, 25)
    height = random.randint(10, 25)
    start_row = random.randint(3, height - 4)
    grid = [[0 for _ in range(width)] for _ in range(height)]
    path = []
    r, c = start_row, 0
    path.append((r, c))
    # place a rotator a bit into the grid to ensure there's at least one rotator
    rotators_on_path = set()
    mid = min(width - 2, 3)
    for step in range(1, width):
        c = step
        path.append((r, c))
        if step == mid:
            rotators_on_path.add((r, c))
    # place a wall somewhere off the path
    walls = set()
    for rr in range(height):
        for cc in range(width):
            if (rr, cc) not in path:
                walls.add((rr, cc))
                break
        if len(walls) > 0:
            break
    for (rr, cc) in walls:
        grid[rr][cc] = 1
    for (rr, cc) in rotators_on_path:
        grid[rr][cc] = 3
    grid[start_row][0] = 2
    output = [row[:] for row in grid]
    for (rr, cc) in path:
        output[rr][cc] = 2
    exit_cell = path[-1]
    exit_r, exit_c = exit_cell
    # draw upward 3-cells (most likely the path reached the right border)
    for i in range(1, 4):
        rr = exit_r - i
        if 0 <= rr < height:
            output[rr][exit_c] = 5
    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0
    # Directions: right, down, left, up
    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    # Find the starting cell (color 2). Prefer the left edge, but fall back to any 2.
    start = None
    for r in range(height):
        if grid[r][0] == 2:
            start = (r, 0)
            break
    if start is None:
        # fallback: search whole grid
        for r in range(height):
            for c in range(width):
                if grid[r][c] == 2:
                    start = (r, c)
                    break
            if start is not None:
                break
    if start is None:
        raise ValueError("No start cell found")

    path = [start]
    dir_idx = 0  # initially moving right
    visited = {start}
    max_steps = width * height * 2
    steps = 0
    while steps < max_steps:
        steps += 1
        r, c = path[-1]
        dr, dc = dirs[dir_idx]
        nr, nc = r + dr, c + dc
        # Check for exit
        if not (0 <= nr < height and 0 <= nc < width):
            exit_cell = (r, c)
            exit_dir_idx = dir_idx
            break
        # If the next cell is a wall (1), the signal cannot pass; but generator avoids walls on the path
        if grid[nr][nc] == 1:
            # treat current as exit (shouldn't happen in well-formed inputs)
            exit_cell = (r, c)
            exit_dir_idx = dir_idx
            break
        # Step into the next cell
        path.append((nr, nc))
        # If we revisit the same cell in the same run, break to avoid infinite loops
        if (nr, nc) in visited:
            # Stop and treat as exit at current cell
            exit_cell = (nr, nc)
            exit_dir_idx = dir_idx
            break
        visited.add((nr, nc))
        # If the cell is a rotator (3), rotate clockwise for the next move
        if grid[nr][nc] == 3:
            dir_idx = (dir_idx + 1) % 4
        # continue loop
    else:
        # safety fallback: if we ran too many steps
        raise RuntimeError("Exceeded step limit while tracing signal")

    # Build the output grid: copy the input and paint the path with color 2
    out = [row[:] for row in grid]
    for (r, c) in path:
        out[r][c] = 2

    # Add exit structure depending on exit direction
    er, ec = exit_cell
    if exit_dir_idx == 0:  # exited to the right: vertical line of 3 cells upward (color 5)
        for i in range(1, 4):
            rr = er - i
            if 0 <= rr < height:
                out[rr][ec] = 5
    elif exit_dir_idx == 1:  # exited downward: horizontal line of 3 cells leftward (color 7)
        for i in range(1, 4):
            cc = ec - i
            if 0 <= cc < width:
                out[er][cc] = 7
    elif exit_dir_idx == 3:  # exited upward: horizontal line of 3 cells rightward (color 6)
        for i in range(1, 4):
            cc = ec + i
            if 0 <= cc < width:
                out[er][cc] = 6

    return out

