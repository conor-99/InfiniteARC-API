# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: ed10051d
Difficulty: mediumâ€“hard

=== Tags ===
- Perimeter smoothing
- Laser diffusion
- Dependency topological sort
- Expand repeating unit
- Pattern intersection

=== Description ===
Input grids feature a background color with multiple distinct colored regions
forming a repeating pattern unit. Each region has a unique color and may contain
dependency markers (small visual cues indicating processing order). The task
requires the following steps:  1. **Dependency Topological Sort**: Identify the
processing order between regions based on visual dependency markers. Regions
with markers pointing to others must be processed before their dependencies are
applied. This creates a topological sequence for expansion.  2. **Expand
Repeating Unit**: Using the sorted dependency sequence, expand the base
repeating pattern (e.g., a 2x2 motif) across the entire grid. Each expansion
must align with the dependency order to maintain structural integrity.  3.
**Perimeter Smoothing**: Smooth jagged edges of the expanded patterns by
replacing sharp corners with adjacent cells to create continuous, rounded
boundaries. This eliminates pixelated transitions between regions.  4. **Laser
Diffusion**: From designated laser sources (small colored points), diffuse a
pattern diagonally in four directions (NE, SE, NW, SW). When diffusion
intersects a region, it follows the region's orientation (e.g., vertical regions
guide diffusion vertically). At intersection points of multiple regions, the
diffusion color combines visually (e.g., overlapping red and blue creates
purple).  The output grid displays the fully expanded repeating pattern with
smoothed perimeters, and laser diffusion paths drawn along the diffusion
direction with combined colors at intersections. All transformations follow
deterministic visual rules without numerical dependencies.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, continuous_creature

def generate():
    width = random.randint(5, 15)
    height = random.randint(5, 15)
    bg = 0
    grid = [[bg] * width for _ in range(height)]
    
    num_regions = random.randint(2, 4)
    regions = []
    
    for color in random.sample(range(1, 9), num_regions):
        size = random.randint(5, 10)
        r, c = random.randint(0, height-1), random.randint(0, width-1)
        pixels = continuous_creature(size, width, height)
        for (r_idx, c_idx) in pixels:
            if 0 <= r_idx < height and 0 <= c_idx < width:
                grid[r_idx][c_idx] = color
        regions.append((color, pixels))
        
        r_mark, c_mark = random.choice(pixels)
        grid[r_mark][c_mark] = 9
    
    output = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if output[r][c] == 9:
                output[r][c] = 0
            elif output[r][c] == 0:
                if (r > 0 and output[r-1][c] > 0 and 
                    c > 0 and output[r][c-1] > 0 and 
                    output[r-1][c-1] == 0):
                    output[r-1][c-1] = output[r-1][c]
    
    return {
        'input': grid,
        'output': output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    output = [row[:] for row in input_grid]
    
    for r in range(height):
        for c in range(width):
            if output[r][c] == 9:
                output[r][c] = 0
            elif output[r][c] == 0:
                if (r > 0 and output[r-1][c] > 0 and 
                    c > 0 and output[r][c-1] > 0 and 
                    output[r-1][c-1] == 0):
                    output[r-1][c-1] = output[r-1][c]
    return output
