# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 43be6a20
Difficulty: hard

=== Tags ===
- Connect the dots
- Topological invariance
- Interpolate between frames
- Out of boundary

=== Description ===
The task involves input grids containing two distinct color-coded clusters
(representing two consecutive frames of a moving object) that must be connected
via interpolated paths. The output grid generates paths between corresponding
clusters by calculating the midpoint between their geometric centers. If the
midpoint lies outside the grid boundaries, the path bends to conform to the
nearest edge while maintaining connectivity. Topological invariance is preserved
by ensuring the original clusters remain disjoint and unmerged, with new paths
only forming between explicitly paired clusters. The interpolation follows a
consistent directional rule (e.g., left-to-right, top-to-bottom ordering of
clusters) to avoid ambiguous pairings. "Out of boundary" scenarios require paths
to navigate around grid edges, resulting in non-straight routes that strictly
stay within the grid dimensions. The complexity arises from handling multiple
overlapping clusters, ensuring no path intersections with existing structures,
and correctly resolving boundary adjustments for all cluster pairs.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    input_grid = [[0] * width for _ in range(height)]
    
    # Generate cluster A (color 1)
    cluster_a = common.continuous_creature(5, width, height)
    for r, c in cluster_a:
        input_grid[r][c] = 1
    
    # Generate cluster B (color 2), shifted
    cluster_b = common.continuous_creature(5, width, height)
    shift_x = width - 6
    shift_y = height - 6
    cluster_b = [(r + shift_y, c + shift_x) for r, c in cluster_b]
    for r, c in cluster_b:
        if 0 <= r < height and 0 <= c < width:
            input_grid[r][c] = 2
    
    # Compute centroids
    def compute_centroid(pixels):
        if not pixels:
            return (0, 0)
        total_x = sum(c for r, c in pixels)
        total_y = sum(r for r, c in pixels)
        return (total_x / len(pixels), total_y / len(pixels))
    
    centroid_a = compute_centroid(cluster_a)
    centroid_b = compute_centroid(cluster_b)
    
    # Compute midpoint and clamp
    mx = (centroid_a[0] + centroid_b[0]) / 2
    my = (centroid_a[1] + centroid_b[1]) / 2
    mx = max(0, min(mx, width - 1))
    my = max(0, min(my, height - 1))
    
    # Draw line on output grid
    output_grid = [row[:] for row in input_grid]
    
    # Draw line between centroids
    x1, y1 = round(centroid_a[0]), round(centroid_a[1])
    x2, y2 = round(centroid_b[0]), round(centroid_b[1])
    
    # Draw horizontal then vertical path
    for x in range(min(x1, x2), max(x1, x2) + 1):
        y = y1
        if 0 <= x < width and 0 <= y < height and output_grid[y][x] == 0:
            output_grid[y][x] = 3
    for y in range(min(y1, y2), max(y1, y2) + 1):
        x = x2
        if 0 <= x < width and 0 <= y < height and output_grid[y][x] == 0:
            output_grid[y][x] = 3
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    color1_pixels = []
    color2_pixels = []
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] == 1:
                color1_pixels.append((r, c))
            elif input_grid[r][c] == 2:
                color2_pixels.append((r, c))
    
    def compute_centroid(pixels):
        if not pixels:
            return (0, 0)
        total_x = sum(c for r, c in pixels)
        total_y = sum(r for r, c in pixels)
        return (total_x / len(pixels), total_y / len(pixels))
    
    centroid_a = compute_centroid(color1_pixels)
    centroid_b = compute_centroid(color2_pixels)
    
    width = len(input_grid[0])
    height = len(input_grid)
    
    x1, y1 = round(centroid_a[0]), round(centroid_a[1])
    x2, y2 = round(centroid_b[0]), round(centroid_b[1])
    
    # Convert input to mutable list of lists
    output_grid = [list(row) for row in input_grid]
    
    for x in range(min(x1, x2), max(x1, x2) + 1):
        y = y1
        if 0 <= x < width and 0 <= y < height and output_grid[y][x] == 0:
            output_grid[y][x] = 3
    for y in range(min(y1, y2), max(y1, y2) + 1):
        x = x2
        if 0 <= x < width and 0 <= y < height and output_grid[y][x] == 0:
            output_grid[y][x] = 3
    
    return output_grid
