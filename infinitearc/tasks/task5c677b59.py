# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 5c677b59
Difficulty: insane

=== Tags ===
- Transformational equivalence
- Image repetition
- Remove intruder
- Pattern modification

=== Description ===
The input grids are square (odd dimensions, e.g., 5×5, 13×13, or 29×29) where
all cells form a rotationally symmetric pattern around the center, except for a
single "intruder" cell that disrupts the symmetry. The intruder is the only cell
whose value does not match its 180-degree rotational counterpart. The output
grid is generated by removing this intruder cell (setting it to 0, the
background color) while preserving all other values, thereby restoring perfect
rotational symmetry. The transformation requires identifying the asymmetric
pair, determining which cell is the intruder (based on visual pattern
consistency), and eliminating it. The task involves recognizing rotational
equivalence as the core rule, with the intruder removal and pattern restoration
constituting the transformation. The complexity arises from the large grid size,
subtle visual patterns, and the need to distinguish the single intruder among
many consistent symmetric pairs.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    n = random.choice([3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29])
    center = (n // 2, n // 2)
    grid = [[0] * n for _ in range(n)]
    
    # Create symmetric grid
    for r in range(n):
        for c in range(n):
            if r <= n - 1 - r and c <= n - 1 - c:
                color = random.randint(1, 9)
                grid[r][c] = color
                grid[n - 1 - r][n - 1 - c] = color
    
    # Select cell in upper-left half (excluding center)
    while True:
        r = random.randint(0, n // 2)
        c = random.randint(0, n // 2)
        if (r, c) == center:
            continue
        break
    
    current_color = grid[r][c]
    while True:
        new_color = random.randint(1, 9)
        if new_color != current_color:
            break
    grid[r][c] = new_color
    
    output = [row[:] for row in grid]
    output[r][c] = 0
    
    return {
        'input': grid,
        'output': output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to list of lists if it's a tuple
    input_grid = [list(row) for row in input_grid]
    n = len(input_grid)
    min_r, min_c = n, n
    
    for r in range(n):
        for c in range(n):
            r2 = n - 1 - r
            c2 = n - 1 - c
            if input_grid[r][c] != input_grid[r2][c2]:
                if r < r2 or (r == r2 and c < c2):
                    if r < min_r or (r == min_r and c < min_c):
                        min_r, min_c = r, c
    
    output = [row[:] for row in input_grid]
    output[min_r][min_c] = 0
    return output
