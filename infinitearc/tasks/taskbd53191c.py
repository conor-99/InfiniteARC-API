# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: bd53191c
Difficulty: hard

=== Tags ===
- Transformation stack
- Alternating agents
- Propagate label

=== Description ===
# Alternating Agent Propagation  Input grids feature a background color (0) and
two or more distinct agent colors (e.g., 1 and 2) arranged across the grid. Each
agent color has a fixed, consistent movement direction (e.g., color 1 always
moves right, color 2 always moves down). The transformation stack applies a
sequence of movement steps: first all agents of color 1 move one cell right (if
the target cell is background), then all agents of color 2 move one cell down
(if the target cell is background). This sequence repeats for a number of steps
equal to the number of agent types present (e.g., two steps for two agent
types). After all movement steps, the "propagate label" phase occurs: every cell
occupied by an agent after movement causes its color to propagate to all four
adjacent background cells (up, down, left, right), replacing those background
cells with the agent's color. Propagation is simultaneous for all agents, with
priority given to earlier agent types (color 1 overrides color 2 for overlapping
propagation). The background remains unchanged for cells not affected by
movement or propagation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

# Deterministic call counter to make each generated example distinct across calls
GEN_CALL = 0


def generate():
    """
    Generate an input/output pair for the Alternating Agent Propagation task.
    The input contains background (0) and two agent colors: 1 (moves right) and 2 (moves down).
    Movement is applied in sequence: first all 1s move simultaneously one cell to the right (if the
    destination cell is background at the start of that movement step), then all 2s move
    simultaneously one cell down (again using the grid state at the start of that step).
    After movement steps, colors propagate from occupied agent cells to their 4-adjacent background
    neighbors simultaneously; ties are resolved by processing colors in ascending order (1 before 2).

    The generator uses a local RNG seeded by the call count so each call produces a distinct example.
    """
    global GEN_CALL
    idx = GEN_CALL
    GEN_CALL += 1
    rng = random.Random(idx)

    # Choose moderate grid sizes to make tasks non-trivial but fast
    width = rng.randint(6, 12)
    height = rng.randint(6, 12)

    # Start with empty background
    grid = [[0 for _ in range(width)] for _ in range(height)]

    # Allowed placement cells for color 1: cannot be in the rightmost column if we want them to be able to move
    allowed_ones = [(r, c) for r in range(height) for c in range(width - 1)]
    # Allowed placement cells for color 2: cannot be in the bottom row
    allowed_twos = [(r, c) for r in range(height - 1) for c in range(width)]

    # At least one of each agent; pick up to 5 of each but not more than available cells
    max_ones = min(5, len(allowed_ones))
    max_twos = min(5, len(allowed_twos))
    num_ones = rng.randint(1, max_ones)
    num_twos = rng.randint(1, max_twos)

    # Sample positions without overlap
    ones = rng.sample(allowed_ones, num_ones)
    occupied = set(ones)

    # For twos, avoid positions already taken by ones
    twos_pool = [p for p in allowed_twos if p not in occupied]
    if len(twos_pool) < num_twos:
        # If there's not enough free cells in the constrained pool, allow more flexibility but still avoid overlapping
        twos_pool = [p for p in ((r, c) for r in range(height) for c in range(width)) if p not in occupied]
    twos = rng.sample(twos_pool, num_twos)
    for (r, c) in ones:
        grid[r][c] = 1
    for (r, c) in twos:
        grid[r][c] = 2

    # Helper to perform a simultaneous move for a single color based on a snapshot
    def move_simultaneous(current, color, dr, dc):
        before = [row[:] for row in current]
        after = [row[:] for row in current]
        for r in range(len(before)):
            for c in range(len(before[0])):
                if before[r][c] == color:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < len(before) and 0 <= nc < len(before[0]) and before[nr][nc] == 0:
                        after[nr][nc] = color
                        after[r][c] = 0
        return after

    # Apply movement sequence: color 1 -> right, then color 2 -> down (each uses snapshot semantics)
    current = [row[:] for row in grid]
    current = move_simultaneous(current, 1, 0, 1)
    current = move_simultaneous(current, 2, 1, 0)

    # Propagation: simultaneous propagation from all agent cells; priority given to lower color values
    final = [row[:] for row in current]
    for color in [1, 2]:
        for r in range(height):
            for c in range(width):
                if current[r][c] == color:
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < height and 0 <= nc < width and final[nr][nc] == 0:
                            final[nr][nc] = color

    return {"input": grid, "output": final}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # Identify agent colors present (exclude background 0), keep ascending order for priority
    colors = sorted({cell for row in grid for cell in row if cell != 0})

    # Map agent colors to directions. For this task generator we expect colors 1->right, 2->down.
    # To be robust, we cycle directions in the order: right, down, left, up.
    dir_cycle = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    color_to_dir = {}
    for i, color in enumerate(colors):
        color_to_dir[color] = dir_cycle[i % len(dir_cycle)]

    # Perform movement steps in ascending color order; each color's movement is simultaneous
    def move_simultaneous(current, color, dr, dc):
        before = [row[:] for row in current]
        after = [row[:] for row in current]
        for r in range(height):
            for c in range(width):
                if before[r][c] == color:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and before[nr][nc] == 0:
                        after[nr][nc] = color
                        after[r][c] = 0
        return after

    current = [row[:] for row in grid]
    for color in colors:
        dr, dc = color_to_dir[color]
        current = move_simultaneous(current, color, dr, dc)

    # Propagation: simultaneous from all agent cells; earlier colors (ascending) have priority
    final = [row[:] for row in current]
    for color in colors:
        for r in range(height):
            for c in range(width):
                if current[r][c] == color:
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < height and 0 <= nc < width and final[nr][nc] == 0:
                            final[nr][nc] = color

    # Return as immutable tuple-of-tuples
    return tuple(tuple(row) for row in final)

