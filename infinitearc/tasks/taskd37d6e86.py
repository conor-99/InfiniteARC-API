# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: d37d6e86
Difficulty: insane

=== Tags ===
- Local state machine
- Directed cave maze

=== Description ===
Input grids are large (25×25) with a single background color. The maze consists
of walls (a single wall color) and corridors (background). A start cell
(distinct color) is positioned on the left edge, and an exit cell (another
distinct color) appears on the right or top edge. Corridors contain directional
cells (four distinct colors representing fixed movement directions: e.g., red =
right, green = up, blue = left, yellow = down) and state cells (two distinct
colors triggering directional changes upon entry: e.g., purple = rotate 90°
clockwise, orange = rotate 90° counterclockwise). The path begins at the start
cell, following the direction of each cell traversed. When entering a state
cell, the direction is altered per the cell's color. The path continues until
reaching the exit cell, drawing a line over background corridors with a color
cycling through a fixed sequence (e.g., red → green → blue → red → ...) at each
step. All input elements (walls, directional cells, state cells) remain visible
in the output, with path cells colored according to the sequence, and no path
overlaps or wall crossings.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = 25
    height = 25
    # Colors
    bg = 0
    wall = 1
    start_color = 2
    exit_color = 3
    dir_right = 4
    dir_up = 5
    dir_left = 6
    dir_down = 7
    state_cw = 8
    state_ccw = 9

    # Create empty grid
    input_grid = [[bg for _ in range(width)] for _ in range(height)]

    # Place start on left edge (avoid corners)
    start_row = random.randint(1, height - 2)
    input_grid[start_row][0] = start_color

    # Place exit on right edge or top edge (avoid corners and the start cell)
    if random.choice([True, False]):
        exit_row = random.randint(1, height - 2)
        exit_col = width - 1
    else:
        exit_col = random.randint(1, width - 2)
        exit_row = 0
    if (exit_row, exit_col) == (start_row, 0):
        # adjust slightly to avoid collision
        if exit_col < width - 1:
            exit_col = width - 1
        else:
            exit_col = max(1, exit_col - 1)
    input_grid[exit_row][exit_col] = exit_color

    # Build a simple monotonic path from start to exit that never moves left
    path = [(start_row, 0)]
    cur_r, cur_c = start_row, 0

    # First step must go right off the left edge
    cur_c += 1
    path.append((cur_r, cur_c))

    target_col = exit_col
    if target_col < cur_c:
        target_col = cur_c

    # Advance column by column, occasionally performing vertical excursions
    for col in range(cur_c + 1, target_col + 1):
        cur_c = col
        path.append((cur_r, cur_c))
        if col == target_col:
            break
        # With some probability, move vertically at this column to create turns
        if random.random() < 0.6:
            # choose an intermediate row away from the very top/bottom to avoid accidental exits
            new_r = random.randint(1, height - 2)
            if new_r != cur_r:
                step = 1 if new_r > cur_r else -1
                while cur_r != new_r:
                    cur_r += step
                    path.append((cur_r, cur_c))

    # Finally move vertically to the exit row (this allows reaching top-edge exits)
    while cur_r != exit_row:
        step = 1 if exit_row > cur_r else -1
        cur_r += step
        path.append((cur_r, cur_c))

    # Ensure last path cell is the exit
    if path[-1] != (exit_row, exit_col):
        path.append((exit_row, exit_col))

    # Precompute for quick checks
    path_set = set(path)

    # Direction maps and rotation helpers
    dir_map = {(0, 1): dir_right, (-1, 0): dir_up, (0, -1): dir_left, (1, 0): dir_down}
    def rotate_cw(d):
        dr, dc = d
        return (dc, -dr)
    def rotate_ccw(d):
        dr, dc = d
        return (-dc, dr)

    # Place directional/state cells on the path. Leave many straight corridor cells as background.
    for i in range(1, len(path) - 1):
        pr = path[i - 1]
        cr = path[i]
        nx = path[i + 1]
        prev_dir = (cr[0] - pr[0], cr[1] - pr[1])
        next_dir = (nx[0] - cr[0], nx[1] - cr[1])
        r, c = cr
        # If moving straight, most of the time leave it as background corridor
        if next_dir == prev_dir:
            if random.random() < 0.22:
                input_grid[r][c] = dir_map.get(next_dir, bg)
            else:
                input_grid[r][c] = bg
        else:
            # It's a turn: prefer a rotation-state cell, sometimes place a direct directional cell
            if next_dir == rotate_cw(prev_dir):
                if random.random() < 0.65:
                    input_grid[r][c] = state_cw
                else:
                    input_grid[r][c] = dir_map.get(next_dir, bg)
            elif next_dir == rotate_ccw(prev_dir):
                if random.random() < 0.65:
                    input_grid[r][c] = state_ccw
                else:
                    input_grid[r][c] = dir_map.get(next_dir, bg)
            else:
                input_grid[r][c] = dir_map.get(next_dir, bg)

    # Ensure start and exit keep their special colors
    sr, sc = path[0]
    input_grid[sr][sc] = start_color
    er, ec = path[-1]
    input_grid[er][ec] = exit_color

    # Occasionally sprinkle a few extra directional markers on straight runs for variety
    for i in range(1, len(path) - 2):
        r, c = path[i]
        if input_grid[r][c] == bg and random.random() < 0.08:
            d = (path[i + 1][0] - r, path[i + 1][1] - c)
            input_grid[r][c] = dir_map.get(d, bg)

    # Place random walls but never on the path
    for r in range(height):
        for c in range(width):
            if (r, c) in path_set:  # never put walls on the path
                continue
            if input_grid[r][c] != bg:
                continue
            if random.random() < 0.18:
                input_grid[r][c] = wall

    # Guarantee at least one wall exists
    if all(input_grid[r][c] != wall for r in range(height) for c in range(width)):
        wr = random.randint(0, height - 1)
        wc = random.randint(0, width - 1)
        if (wr, wc) not in path_set:
            input_grid[wr][wc] = wall

    # Construct output by drawing the colored path on top of background corridors
    output_grid = [row[:] for row in input_grid]
    sequence = [4, 5, 6, 7]
    for idx, (r, c) in enumerate(path):
        if input_grid[r][c] == bg:
            output_grid[r][c] = sequence[idx % len(sequence)]

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Find start (color 2) on left edge (fallback: anywhere)
    start = None
    for r in range(height):
        if grid[r][0] == 2:
            start = (r, 0)
            break
    if start is None:
        for r in range(height):
            for c in range(width):
                if grid[r][c] == 2:
                    start = (r, c)
                    break
            if start is not None:
                break
    if start is None:
        raise ValueError("Start not found")

    # Find exit (color 3) on right or top edge (fallback: anywhere)
    exit_pos = None
    for r in range(height):
        if grid[r][width - 1] == 3:
            exit_pos = (r, width - 1)
            break
    if exit_pos is None:
        for c in range(width):
            if grid[0][c] == 3:
                exit_pos = (0, c)
                break
    if exit_pos is None:
        for r in range(height):
            for c in range(width):
                if grid[r][c] == 3:
                    exit_pos = (r, c)
                    break
            if exit_pos is not None:
                break
    if exit_pos is None:
        raise ValueError("Exit not found")

    # Direction map and traversal
    dir_map = {4: (0, 1), 5: (-1, 0), 6: (0, -1), 7: (1, 0)}
    path = [start]
    current = start
    current_dir = (0, 1)  # always start moving right off the left edge
    visited = set([start])

    max_steps = height * width * 3
    steps = 0
    while current != exit_pos and steps < max_steps:
        steps += 1
        r, c = current
        dr, dc = current_dir
        nr, nc = r + dr, c + dc
        if not (0 <= nr < height and 0 <= nc < width):
            break
        color = grid[nr][nc]
        # Update direction based on the cell we will enter
        if color in dir_map:
            new_dir = dir_map[color]
        elif color == 8:
            dr0, dc0 = current_dir
            new_dir = (dc0, -dr0)
        elif color == 9:
            dr0, dc0 = current_dir
            new_dir = (-dc0, dr0)
        else:
            new_dir = current_dir
        current = (nr, nc)
        path.append(current)
        if current in visited:
            break
        visited.add(current)
        current_dir = new_dir

    # Color the background path cells with the repeating sequence
    output = [row[:] for row in grid]
    sequence = [4, 5, 6, 7]
    for idx, (r, c) in enumerate(path):
        if grid[r][c] == 0:
            output[r][c] = sequence[idx % len(sequence)]
    return output

