# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 15e8f9f9
Difficulty: medium–hard

=== Tags ===
- Deterministic update
- Multi condition recolor
- Friction path

=== Description ===
The input grid features a single continuous path composed of connected cells in
a uniform color, positioned on a plain background. Scattered across the grid are
friction markers—cells colored red (indicating left turns) and blue (indicating
right turns)—placed adjacent to the path at strategic intervals. The path begins
moving in the direction of its initial segment (e.g., horizontally left-to-right
or vertically top-to-bottom).  In the output grid, the path is dynamically
updated through deterministic traversal: as the path progresses, each segment is
recolored to match the friction marker color encountered at its turning point.
If the next cell in the current direction is adjacent to a red marker, the path
turns 90° counterclockwise (left); if adjacent to a blue marker, it turns 90°
clockwise (right). The path continues moving in the new direction until it exits
the grid, encounters no further markers, or reaches a dead end. All friction
markers are removed from the output, and only the recolored path segments remain
visible. The transformation requires simultaneous tracking of path direction,
adjacency checks for markers, and conditional recoloring—ensuring the output
reflects a complex, multi-step evolution of the input path governed by friction-
based directional rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import continuous_creature

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = [[0] * width for _ in range(height)]
    
    path_length = random.randint(5, 20)
    pixels = continuous_creature(path_length, width, height)
    rows = [p[0] for p in pixels]
    cols = [p[1] for p in pixels]
    
    for r, c in zip(rows, cols):
        grid[r][c] = 3
    
    for r, c in zip(rows, cols):
        for dr, dc in [(0,1), (1,0), (0,-1), (-1,0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0:
                if random.random() < 0.5:
                    color = random.choice([1, 2])
                    grid[nr][nc] = color
                    break
    
    has_marker = False
    for r, c in zip(rows, cols):
        for dr, dc in [(0,1), (1,0), (0,-1), (-1,0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] in [1, 2]:
                has_marker = True
                break
        if has_marker:
            break
    if not has_marker:
        r, c = rows[0], cols[0]
        for dr, dc in [(0,1), (1,0), (0,-1), (-1,0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0:
                grid[nr][nc] = random.choice([1, 2])
                break
    
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 3:
                for dr, dc in [(0,1), (1,0), (0,-1), (-1,0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] in [1, 2]:
                        output_grid[r][c] = grid[nr][nc]
                        break
                else:
                    output_grid[r][c] = 3
            elif grid[r][c] in [1, 2]:
                output_grid[r][c] = 0
            else:
                output_grid[r][c] = 0
    
    return {
        "input": grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    output = [[0] * width for _ in range(height)]
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 3:
                for dr, dc in [(0,1), (1,0), (0,-1), (-1,0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        if grid[nr][nc] == 1 or grid[nr][nc] == 2:
                            output[r][c] = grid[nr][nc]
                            break
                else:
                    output[r][c] = 3
            elif grid[r][c] == 1 or grid[r][c] == 2:
                output[r][c] = 0
            else:
                output[r][c] = 0
    return tuple(tuple(row) for row in output)
