# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: e66b487c
Difficulty: hard

=== Tags ===
- Connect all dots of same color
- Hierarchical agent routing
- Bidirectional mapping
- Beam reflection
- Path following

=== Description ===
Input grids are large (20×20 or larger) with a background color (0). Scattered
across the grid are colored dots (non-zero colors 1–9) where each color appears
at least twice. Walls, represented as horizontal or vertical lines of a distinct
color (not background or dot colors), form barriers that paths must reflect off.
Each dot of a given color must be connected through a continuous path of
background cells (0) to all other dots of the same color. The path moves in
straight lines until encountering a wall, where it reflects: horizontal walls
reverse vertical movement (up/down → down/up), and vertical walls reverse
horizontal movement (left/right → right/left). Paths must not overlap walls,
other paths, or dots. The output grid displays these paths using the dot color,
with reflections at wall intersections. Hierarchical routing requires that
higher-priority colors (lower numerical values) connect first, influencing the
path layout for lower-priority colors. Bidirectional mapping ensures that
connections between dots are symmetric (path from A to B is identical to B to
A), and all paths exit the grid without crossing. The task demands precise path
planning through complex wall arrangements while respecting reflection rules and
priority constraints.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import *

def find_beam_path(grid, start, goal, reserved, wall=9):
    from collections import deque
    height = len(grid)
    width = len(grid[0])
    dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)]  # up, right, down, left

    queue = deque()
    visited = set()
    parent = {}

    for dr, dc in dirs:
        state = (start[0], start[1], dr, dc)
        visited.add(state)
        parent[state] = None
        queue.append(state)

    while queue:
        r, c, dr, dc = queue.popleft()
        if (r, c) == goal:
            seq = []
            cur = (r, c, dr, dc)
            while cur is not None:
                seq.append((cur[0], cur[1]))
                cur = parent[cur]
            seq.reverse()
            path = []
            last = None
            for cell in seq:
                if cell != last:
                    path.append(cell)
                last = cell
            return path

        nr = r + dr
        nc = c + dc
        forward_blocked = False
        if not (0 <= nr < height and 0 <= nc < width):
            forward_blocked = True
        else:
            if grid[nr][nc] == wall or (nr, nc) in reserved:
                forward_blocked = True

        if not forward_blocked:
            new_state = (nr, nc, dr, dc)
            if new_state not in visited:
                visited.add(new_state)
                parent[new_state] = (r, c, dr, dc)
                queue.append(new_state)

        if forward_blocked:
            if dr == 0:
                ortho_dirs = [(1, 0), (-1, 0)]
            else:
                ortho_dirs = [(0, 1), (0, -1)]
            for odr, odc in ortho_dirs:
                nr2 = r + odr
                nc2 = c + odc
                if not (0 <= nr2 < height and 0 <= nc2 < width):
                    continue
                if grid[nr2][nc2] == wall or (nr2, nc2) in reserved:
                    continue
                new_state = (nr2, nc2, odr, odc)
                if new_state not in visited:
                    visited.add(new_state)
                    parent[new_state] = (r, c, dr, dc)
                    queue.append(new_state)

    return None


def generate():
    attempts = 0
    while True:
        attempts += 1
        if attempts > 30:
            random.seed()
            attempts = 0

        width = random.randint(20, 30)
        height = random.randint(20, 30)
        wall = 9

        # Initialize blank grid
        ingrid = [[0 for _ in range(width)] for _ in range(height)]

        # Place a moderate number of short random wall segments
        v_segments = random.randint(4, 8)
        for _ in range(v_segments):
            c = random.randint(0, width - 1)
            start = random.randint(0, max(0, height - 4))
            length = random.randint(3, min(6, height - start))
            for r in range(start, min(height, start + length)):
                ingrid[r][c] = wall

        h_segments = random.randint(4, 8)
        for _ in range(h_segments):
            r = random.randint(0, height - 1)
            start = random.randint(0, max(0, width - 4))
            length = random.randint(3, min(6, width - start))
            for c in range(start, min(width, start + length)):
                ingrid[r][c] = wall

        # Avoid overly dense walls
        wall_count = sum(row.count(wall) for row in ingrid)
        if wall_count > (width * height) // 3:
            continue

        # Compute horizontal zero spans (contiguous background cells by row)
        spans = []  # list of (row, start_col, end_col, length)
        for r in range(height):
            c = 0
            while c < width:
                # skip walls
                while c < width and ingrid[r][c] == wall:
                    c += 1
                if c >= width:
                    break
                start = c
                while c < width and ingrid[r][c] != wall:
                    c += 1
                end = c - 1
                length = end - start + 1
                if length >= 2:
                    spans.append((r, start, end, length))

        if not spans:
            continue

        # Choose colors and counts
        num_colors = random.randint(2, 4)
        colors = random.sample(range(1, 9), num_colors)
        counts = {color: random.randint(2, 3) for color in colors}

        # Try to assign each color to a span that can hold its dots
        available_spans = spans[:]
        random.shuffle(available_spans)
        dots_map = {}
        ok_assign = True
        used_cells = set()
        for color in sorted(colors):
            needed = counts[color]
            found = False
            # find a span with enough free cells
            for (r, s, e, ln) in available_spans:
                # build list of free cols in this span
                free_cols = [c for c in range(s, e + 1) if ingrid[r][c] == 0 and (r, c) not in used_cells]
                if len(free_cols) >= needed:
                    chosen_cols = random.sample(free_cols, needed)
                    chosen = sorted((r, c) for c in chosen_cols)
                    dots_map[color] = chosen
                    for cell in chosen:
                        used_cells.add(cell)
                    # remove this span from available_spans to avoid reuse
                    available_spans.remove((r, s, e, ln))
                    found = True
                    break
            if not found:
                ok_assign = False
                break

        if not ok_assign:
            continue

        # Commit dots to ingrid
        for color in dots_map:
            for (dr, dc) in dots_map[color]:
                ingrid[dr][dc] = color

        # Prepare output and perform routing using beam rules
        output = [row[:] for row in ingrid]
        reserved = set()
        success = True
        for color in sorted(colors):
            # reserved_prev: earlier reserved plus all other dots present in grid
            reserved_prev = set(reserved)
            otherdots = set()
            for r in range(height):
                for c in range(width):
                    v = ingrid[r][c]
                    if v != 0 and v != wall and v != color:
                        otherdots.add((r, c))
            reserved_prev |= otherdots

            positions = dots_map[color]
            positions = sorted(positions)
            for i in range(len(positions) - 1):
                a = positions[i]
                b = positions[i + 1]
                path = find_beam_path(ingrid, a, b, reserved_prev, wall)
                if path is None:
                    success = False
                    break
                for (pr, pc) in path:
                    if ingrid[pr][pc] == wall:
                        continue
                    output[pr][pc] = color
                    reserved.add((pr, pc))
            if not success:
                break
            for d in positions:
                reserved.add(d)

        if not success:
            continue

        if ingrid == output:
            continue

        return {"input": ingrid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import *

def find_beam_path(grid, start, goal, reserved, wall=9):
    from collections import deque
    height = len(grid)
    width = len(grid[0])
    dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)]

    queue = deque()
    visited = set()
    parent = {}

    for dr, dc in dirs:
        state = (start[0], start[1], dr, dc)
        visited.add(state)
        parent[state] = None
        queue.append(state)

    while queue:
        r, c, dr, dc = queue.popleft()
        if (r, c) == goal:
            seq = []
            cur = (r, c, dr, dc)
            while cur is not None:
                seq.append((cur[0], cur[1]))
                cur = parent[cur]
            seq.reverse()
            path = []
            last = None
            for cell in seq:
                if cell != last:
                    path.append(cell)
                last = cell
            return path

        nr = r + dr
        nc = c + dc
        forward_blocked = False
        if not (0 <= nr < height and 0 <= nc < width):
            forward_blocked = True
        else:
            if grid[nr][nc] == wall or (nr, nc) in reserved:
                forward_blocked = True

        if not forward_blocked:
            new_state = (nr, nc, dr, dc)
            if new_state not in visited:
                visited.add(new_state)
                parent[new_state] = (r, c, dr, dc)
                queue.append(new_state)

        if forward_blocked:
            if dr == 0:
                ortho_dirs = [(1, 0), (-1, 0)]
            else:
                ortho_dirs = [(0, 1), (0, -1)]
            for odr, odc in ortho_dirs:
                nr2 = r + odr
                nc2 = c + odc
                if not (0 <= nr2 < height and 0 <= nc2 < width):
                    continue
                if grid[nr2][nc2] == wall or (nr2, nc2) in reserved:
                    continue
                new_state = (nr2, nc2, odr, odc)
                if new_state not in visited:
                    visited.add(new_state)
                    parent[new_state] = (r, c, dr, dc)
                    queue.append(new_state)

    return None


def p(input_grid):
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])
    wall = 9

    dots = {}
    for r in range(height):
        for c in range(width):
            v = grid_in[r][c]
            if v != 0 and v != wall:
                dots.setdefault(v, []).append((r, c))

    output = [row[:] for row in grid_in]
    reserved = set()

    for color in sorted(dots.keys()):
        positions = sorted(dots[color])
        reserved_prev = set(reserved)
        otherdots = set()
        for rr in range(height):
            for cc in range(width):
                v = grid_in[rr][cc]
                if v != 0 and v != wall and v != color:
                    otherdots.add((rr, cc))
        reserved_prev |= otherdots

        for i in range(len(positions) - 1):
            a = positions[i]
            b = positions[i + 1]
            path = find_beam_path(grid_in, a, b, reserved_prev, wall)
            if path is None:
                from collections import deque
                prev = {}
                q = deque([a])
                found = False
                blocked = set(reserved_prev)
                blocked.add(a)
                while q:
                    cur = q.popleft()
                    if cur == b:
                        found = True
                        break
                    for dr, dc in [(-1, 0), (0, 1), (1, 0), (0, -1)]:
                        nr = cur[0] + dr
                        nc = cur[1] + dc
                        if not (0 <= nr < height and 0 <= nc < width):
                            continue
                        if grid_in[nr][nc] == wall:
                            continue
                        if (nr, nc) in blocked:
                            continue
                        if (nr, nc) in prev:
                            continue
                        prev[(nr, nc)] = cur
                        q.append((nr, nc))
                if not found:
                    continue
                path_cells = []
                cur = b
                while cur != a:
                    path_cells.append(cur)
                    cur = prev[cur]
                path_cells.append(a)
                path_cells.reverse()
            else:
                path_cells = path

            for (pr, pc) in path_cells:
                if grid_in[pr][pc] == wall:
                    continue
                output[pr][pc] = color
                reserved.add((pr, pc))
        for d in positions:
            reserved.add(d)

    return output

