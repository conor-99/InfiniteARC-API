# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: a6f87e70
Difficulty: medium–hard

=== Tags ===
- Topological invariance
- Rule priority resolution
- Token following
- Maze

=== Description ===
Input grids consist of mazes with walls (represented by color 1) and
interconnected path segments (colors 2–5). Each path color encodes a movement
rule: color 2 (highest priority) forces a right turn at intersections, color 3
mandates a left turn, color 4 continues straight, and color 5 reverses
direction. The token starts at a distinct color 6 marker positioned along the
maze's perimeter, initially moving rightward. At cells where multiple path
colors overlap (e.g., a crossroads), the highest-priority color determines the
movement direction. The token traverses the maze by applying the rule of the
path segment it enters, changing direction accordingly at each intersection. The
output grid preserves all original walls and paths, with the token's route drawn
as a continuous sequence of cells colored according to the path segment that
dictated the movement at each step (starting with color 6 at the origin, then
transitioning to the path color for subsequent cells). The token exits the grid
when it reaches a boundary, and no loops or self-intersections occur. The task
requires resolving rule priorities at junctions while maintaining direction
consistency relative to the maze's orientation, testing both topological
reasoning (via relative turns) and sequence-based rule application.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid


def generate():
    """
    Generates a maze-like grid with walls (1), path cells (2-5) and a start marker (6) on the left perimeter.
    The main path is a self-avoiding walk from the start into the grid and terminating at a boundary.
    Each visited path cell has a "governing" color (2=right,3=left,4=straight,5=reverse) that, when the token
    enters the cell, determines the next relative turn. The input grid stores path colors but one interior
    path cell is intentionally masked (changed to a color >= governing color) so that input != output while
    the solver can still deduce the governing color by looking at neighbors. The output grid is produced
    by simulating the token traversal using the priority rule (2 > 3 > 4 > 5) and painting the visited
    route: start remains 6 and each subsequently visited cell is set to the governing color that dictated
    the token's outgoing move from that cell.
    """
    # Grid size
    size_tries = 0
    while True:
        size_tries += 1
        if size_tries > 200:
            # fallback if unlucky: pick a fixed size
            size = 12
        else:
            size = random.randint(9, 16)

        # Create grid filled with walls
        in_grid = grid(size, size, 1)

        # Choose a start row on the left perimeter (avoid corners to keep room)
        start_r = random.randint(1, size - 2)
        start_c = 0
        in_grid[start_r][start_c] = 6

        # We will build a self-avoiding path starting at (start_r,1)
        start_pos = (start_r, 1)

        # Helper to get cardinal neighbors
        def neighbors(pos):
            r, c = pos
            cand = [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]
            return [(nr, nc) for nr, nc in cand if 0 <= nr < size and 0 <= nc < size]

        max_dfs_steps = size * size
        visited = set([start_pos, (start_r, start_c)])
        path = [start_pos]

        success = False

        # Depth-first search with backtracking to find a path to the boundary (excluding the left border start)
        def dfs(pos):
            nonlocal visited, path, success
            # If pos is on any boundary other than the start column left (c == 0), finish
            r, c = pos
            if (r == 0 or r == size - 1 or c == size - 1) and len(path) >= max(3, size // 2):
                return True

            # Randomize neighbor order
            nbrs = neighbors(pos)
            random.shuffle(nbrs)
            for nb in nbrs:
                if nb in visited:  # do not revisit
                    continue
                # don't step back onto the start marker cell at column 0
                if nb[1] == 0:
                    continue
                # Avoid immediate adjacency that would trap (optional heuristic):
                # ensure nb has at least one free space to continue (otherwise could create short dead-ends)
                visited.add(nb)
                path.append(nb)
                if dfs(nb):
                    return True
                # backtrack
                visited.remove(nb)
                path.pop()
            return False

        if not dfs(start_pos):
            # try again with new size/start
            continue

        # Build full path including the start marker cell at the front
        full_path = [(start_r, start_c)] + path

        # Compute governing colors for each visited cell except the start
        # Mapping: 2 = right, 3 = left, 4 = straight, 5 = reverse
        gov_colors = {}

        for i in range(1, len(full_path)):
            prev = full_path[i - 1]
            cur = full_path[i]
            # Determine next cell: if there is a next in path use it; otherwise the next step goes out of bounds
            if i + 1 < len(full_path):
                nxt = full_path[i + 1]
            else:
                # compute the outgoing vector which goes outside the grid from cur
                r, c = cur
                if r == 0:
                    nxt = (r - 1, c)
                elif r == size - 1:
                    nxt = (r + 1, c)
                elif c == 0:
                    nxt = (r, c - 1)
                elif c == size - 1:
                    nxt = (r, c + 1)
                else:
                    # Shouldn't happen (we stop at boundary)
                    # As a fallback, make the next be the previous to indicate reverse
                    nxt = (prev[0] - (cur[0] - prev[0]), prev[1] - (cur[1] - prev[1]))

            dr_in = cur[0] - prev[0]
            dc_in = cur[1] - prev[1]
            dr_out = nxt[0] - cur[0]
            dc_out = nxt[1] - cur[1]

            # Right rotation: (dr,dc) -> (dc, -dr)
            if (dr_out, dc_out) == (dr_in, dc_in):
                col = 4
            elif (dr_out, dc_out) == (-dr_in, -dc_in):
                col = 5
            elif (dr_out, dc_out) == (dc_in, -dr_in):
                col = 2
            elif (dr_out, dc_out) == (-dc_in, dr_in):
                col = 3
            else:
                # Defensive fallback to straight if something unexpected occurs
                col = 4
            gov_colors[cur] = col

        # Ensure there is at least one position where a neighbor shares the same governing color (so masking is safe)
        maskable = []
        path_positions = full_path[1:]  # exclude the start marker cell at index 0
        for idx, pos in enumerate(path_positions):
            cur = pos
            gc = gov_colors[cur]
            # check previous or next in the path for same governing color
            neighbors_same = False
            # previous in full_path is at offset idx (because full_path has the start prefixed)
            if idx + 1 < len(path_positions):
                nxt = path_positions[idx + 1]
                if gov_colors.get(nxt) == gc:
                    neighbors_same = True
            if idx - 1 >= 0:
                prev = path_positions[idx - 1]
                if gov_colors.get(prev) == gc:
                    neighbors_same = True
            if neighbors_same:
                maskable.append(cur)

        if not maskable:
            # no safe mask position found; try a different maze
            continue

        # Prepare the input grid: paint the path cells with their governing colors by default
        for pos, col in gov_colors.items():
            r, c = pos
            in_grid[r][c] = col

        # Ensure at least one visited cell differs between input and output by masking one maskable position
        masked_pos = random.choice(maskable)
        gc = gov_colors[masked_pos]
        # choose an input color that is >= gc (lower or equal priority) but not equal to gc to ensure difference
        candidates = [c for c in [2, 3, 4, 5] if c >= gc and c != gc]
        if candidates:
            in_r, in_c = masked_pos
            in_grid[in_r][in_c] = random.choice(candidates)
        # else it means gc == 5 and no greater color exists; since masked positions were chosen where neighbor shares same gc,
        # we can simply leave everything as-is (no masking possible). But we should avoid producing identical input/output.
        # In practice this is unlikely for an entire path; if it happens restart.
        else:
            # try again to guarantee a difference
            continue

        # Now we have an input grid. Compute the output by simulating the token traversal.
        out_grid = [row[:] for row in in_grid]

        # Find start
        start = (start_r, start_c)
        r, c = start
        dr, dc = 0, 1  # initial movement is to the right

        # Helper to get present path colors at a cell (itself + 4-neighborhood)
        def present_colors_at(cell_r, cell_c):
            cols = set()
            for nr, nc in [(cell_r, cell_c), (cell_r - 1, cell_c), (cell_r + 1, cell_c), (cell_r, cell_c - 1), (cell_r, cell_c + 1)]:
                if 0 <= nr < size and 0 <= nc < size:
                    v = in_grid[nr][nc]
                    if 2 <= v <= 5:
                        cols.add(v)
            return cols

        # Traverse until exit
        cr, cc = r, c
        visited_route = set()
        visited_route.add((cr, cc))
        while True:
            nr, nc = cr + dr, cc + dc
            # exit if next position is outside
            if not (0 <= nr < size and 0 <= nc < size):
                break
            # move into the next cell
            cr, cc = nr, nc
            visited_route.add((cr, cc))

            # Determine present colors and choose highest-priority (smallest number)
            pcs = present_colors_at(cr, cc)
            if not pcs:
                # If there are no path colors present, stop traversal (shouldn't happen for valid generation)
                break
            chosen = min(pcs)

            # Paint the route cell with the governing color used at that step
            out_grid[cr][cc] = chosen

            # Update direction according to chosen color relative to incoming direction (dr,dc)
            if chosen == 4:  # straight
                pass
            elif chosen == 5:  # reverse
                dr, dc = -dr, -dc
            elif chosen == 2:  # right turn
                dr, dc = dc, -dr
            elif chosen == 3:  # left turn
                dr, dc = -dc, dr

        # Return the pair of grids
        return {
            "input": in_grid,
            "output": out_grid
        }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid_in = [list(row) for row in input_grid]
    h = len(grid_in)
    w = len(grid_in[0]) if h else 0

    # Find start cell (color 6)
    start = None
    for r in range(h):
        for c in range(w):
            if grid_in[r][c] == 6:
                start = (r, c)
                break
        if start:
            break
    if not start:
        return grid_in

    # Copy input to output and we will overwrite the route
    out = [row[:] for row in grid_in]

    # Initial direction is right
    dr, dc = 0, 1
    cr, cc = start

    # Helper to get present path colors at a cell (itself + 4-neighborhood)
    def present_colors_at(cell_r, cell_c):
        cols = set()
        for nr, nc in [(cell_r, cell_c), (cell_r - 1, cell_c), (cell_r + 1, cell_c), (cell_r, cell_c - 1), (cell_r, cell_c + 1)]:
            if 0 <= nr < h and 0 <= nc < w:
                v = grid_in[nr][nc]
                if 2 <= v <= 5:
                    cols.add(v)
        return cols

    # Traverse until exit
    while True:
        nr, nc = cr + dr, cc + dc
        # if next step is outside the grid, traversal is complete
        if not (0 <= nr < h and 0 <= nc < w):
            break
        # move into next cell
        cr, cc = nr, nc

        # Determine present colors and choose highest-priority (smallest numeric value)
        pcs = present_colors_at(cr, cc)
        if not pcs:
            break
        chosen = min(pcs)

        # Paint the route cell with chosen color (start remains 6)
        out[cr][cc] = chosen

        # Update direction according to chosen color relative to incoming direction (dr,dc)
        if chosen == 4:  # straight
            pass
        elif chosen == 5:  # reverse
            dr, dc = -dr, -dc
        elif chosen == 2:  # right turn
            dr, dc = dc, -dr
        elif chosen == 3:  # left turn
            dr, dc = -dc, dr

    return out

