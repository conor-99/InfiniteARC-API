# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 1fdf66ec
Difficulty: hard

=== Tags ===
- Spring chain
- Signal tracing
- One yes one no

=== Description ===
Spring Chain Signal Tracing  Input grids feature a continuous, non-linear
"spring chain" path composed of connected cells (colors 1-9) forming a complex
sequence with multiple turns and apparent decision points. The chain starts at a
designated point (e.g., top-left corner) and ends at another (e.g., bottom-right
corner), but contains numerous locations where the path appears to branch into
two possible directions. At each decision point, the cell's color determines the
valid path direction: one color signifies a "yes" (the path must continue in
this direction), while another color signifies a "no" (the path must not follow
this direction). The rule for "yes" versus "no" is consistent but not explicitly
stated; it must be deduced from the relationship between cell colors and path
choices across multiple input-output examples.  The output grid is identical to
the input except that the path follows all "yes" directions at every decision
point, forming a single continuous path from start to end. All cells along this
valid path are recolored to a distinct "signal" color (e.g., color 5), while all
other cells (including invalid path branches and background) remain unchanged.
The background color (typically 0) remains consistent, and the decision points
are resolved to show only the correct path. The task requires recognizing the
color-based decision rule, resolving all branching points, and tracing the
single valid path through the spring chain structure. The complexity arises from
the need to infer the color-based rule from limited examples, resolve multiple
overlapping decision points simultaneously, and ensure the path remains
continuous without crossing itself or violating the "one yes one no" constraint
at each junction.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque

# Faster generator for ARC task 471: Spring Chain Signal Tracing (monotonic main path + dead-end branches)
# Input colors: 0 background, 1 path candidate, 3 marker that indicates the allowed continuation.
# Output color: 5 for the true traced path.

DIRS = [(1,0),(-1,0),(0,1),(0,-1)]

def _neighs(coord, size):
    r,c = coord
    for dr,dc in DIRS:
        nr,nc = r+dr, c+dc
        if 0 <= nr < size and 0 <= nc < size:
            yield (nr,nc)


def _resolve_signal_path(grid):
    size = len(grid)
    start = (0,0)
    end = (size-1, size-1)

    def neighbors_of(cell):
        return [nb for nb in _neighs(cell, size) if grid[nb[0]][nb[1]] > 0]

    cur = start
    prev = None
    path = [cur]
    max_steps = size*size*4
    steps = 0
    while cur != end and steps < max_steps:
        steps += 1
        neighs = neighbors_of(cur)
        if prev is not None:
            neighs = [n for n in neighs if n != prev]
        if not neighs:
            break
        chosen = None
        for n in neighs:
            if grid[n[0]][n[1]] == 3:
                chosen = n
                break
        if chosen is None:
            chosen = neighs[0]
        path.append(chosen)
        prev, cur = cur, chosen
    return path


def generate():
    size = random.randint(10, 18)
    grid = [[0 for _ in range(size)] for _ in range(size)]

    # Build a monotonic random main path from (0,0) to (size-1,size-1) consisting of rights and downs
    moves = [(0,1)] * (size - 1) + [(1,0)] * (size - 1)
    random.shuffle(moves)
    r,c = 0,0
    main_path = [(r,c)]
    for dr,dc in moves:
        r += dr; c += dc
        main_path.append((r,c))

    # Paint main path
    for (rr,cc) in main_path:
        grid[rr][cc] = 1

    # Add several single-cell dead-end branches to create decision points
    possible_indices = list(range(1, len(main_path)-1))
    random.shuffle(possible_indices)
    branch_count = random.randint(2, max(2, len(main_path)//6))
    used_branch_cells = set()
    branches_added = 0
    for idx in possible_indices:
        if branches_added >= branch_count:
            break
        pr, pc = main_path[idx]
        # candidate neighbors for the dead-end branch: not part of main_path and empty
        candidates = [n for n in _neighs((pr,pc), size) if n not in main_path and grid[n[0]][n[1]] == 0]
        if not candidates:
            continue
        nb = random.choice(candidates)
        # lay down the branch single cell
        grid[nb[0]][nb[1]] = 1
        used_branch_cells.add(nb)
        # Mark the allowed continuation at the junction: mark the main forward cell as 3 so solver picks it
        # forward neighbor is main_path[idx+1]
        fwd = main_path[idx+1]
        grid[fwd[0]][fwd[1]] = 3
        branches_added += 1

    # Ensure start and end are path-colored
    sr, sc = main_path[0]
    grid[sr][sc] = 1
    er, ec = main_path[-1]
    grid[er][ec] = 1

    # Compute output by following markers
    in_grid = [list(row) for row in grid]
    path_cells = _resolve_signal_path(in_grid)
    output = [list(row) for row in grid]
    for (rr,cc) in path_cells:
        output[rr][cc] = 5

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

DIRS = [(1,0),(-1,0),(0,1),(0,-1)]

def _neighs(coord, size):
    r,c = coord
    for dr,dc in DIRS:
        nr,nc = r+dr, c+dc
        if 0 <= nr < size and 0 <= nc < size:
            yield (nr,nc)


def _bfs_with_markers(grid, start_cell, prev_cell, goal):
    size = len(grid)
    dq = deque()
    dq.append((start_cell, prev_cell))
    parents = {(start_cell, prev_cell): None}
    while dq:
        cur, prev = dq.popleft()
        if cur == goal:
            out = []
            key = (cur, prev)
            while key is not None:
                out.append(key[0])
                key = parents.get(key, None)
            out.reverse()
            return out
        neighs = [n for n in _neighs(cur, size) if grid[n[0]][n[1]] > 0 and n != prev]
        marked = [n for n in neighs if grid[n[0]][n[1]] == 3]
        candidates = marked if marked else neighs
        for n in candidates:
            state = (n, cur)
            if state in parents: continue
            parents[state] = (cur, prev)
            dq.append(state)
    return None


def _resolve_signal_path(grid):
    size = len(grid)
    start = (0,0)
    end = (size-1, size-1)
    def neighbors_of(cell):
        return [nb for nb in _neighs(cell, size) if grid[nb[0]][nb[1]] > 0]
    cur = start
    prev = None
    path = [cur]
    max_steps = size*size*4
    steps = 0
    while cur != end and steps < max_steps:
        steps += 1
        neighs = neighbors_of(cur)
        if prev is not None:
            neighs = [n for n in neighs if n != prev]
        if not neighs:
            tail = _bfs_with_markers(grid, cur, prev, end)
            if not tail:
                break
            for cell in tail[1:]:
                path.append(cell)
            cur = path[-1]
            prev = path[-2] if len(path) >= 2 else None
            break
        chosen = None
        for n in neighs:
            if grid[n[0]][n[1]] == 3:
                chosen = n
                break
        if chosen is None:
            chosen = neighs[0]
        path.append(chosen)
        prev, cur = cur, chosen
    return path


def p(input_grid):
    grid = [list(row) for row in input_grid]
    size = len(grid)
    if size == 0:
        return input_grid
    path = _resolve_signal_path(grid)
    out = [list(row) for row in grid]
    for (r,c) in path:
        out[r][c] = 5
    return tuple(tuple(row) for row in out)

