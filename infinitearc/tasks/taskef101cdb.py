# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: ef101cdb
Difficulty: hard

=== Tags ===
- Draw pattern from point
- Local physics rule
- Reconstruct checkerboard from hint
- Color transfer on contact
- Detect repetition
- Grid coloring

=== Description ===
Input grids consist of a 10×10 to 30×30 grid with a single background color (0)
and scattered colored cells (1–9) that form a repeating 2×2 pattern across the
grid. These colored cells serve as "hints" for the checkerboard structure. The
output grid must reconstruct a full checkerboard pattern where each cell's color
alternates according to the detected repeating pattern in the hints. To
determine the correct color for each cell, the solver must first detect the
periodicity and color arrangement of the hints (e.g., identifying that a red
cell at (i,j) implies a specific color for all (i+2k, j+2m) positions). The
color of each output cell is determined by the nearest hint cell using Manhattan
distance, with ties resolved by prioritizing the earliest hint in row-major
order. Color transfer on contact ensures adjacent cells adopt colors consistent
with the checkerboard pattern, avoiding conflicts through the detected
repetition. The task requires detecting the underlying periodic structure from
sparse hints and applying it systematically to the entire grid, with no cell
being equidistant to conflicting hints due to the pattern's consistency.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    size = random.randint(10, 30)
    c1 = random.randint(1, 9)
    c2 = random.randint(1, 9)
    while c2 == c1:
        c2 = random.randint(1, 9)
    input_grid = [[0] * size for _ in range(size)]
    for i in range(size):
        for j in range(size):
            a = i % 2
            b = j % 2
            if a == 0 and b == 0:
                color = c1
            elif a == 0 and b == 1:
                color = c2
            elif a == 1 and b == 0:
                color = c2
            else:
                color = c1
            if random.random() < 0.1:
                input_grid[i][j] = color
    has_c1 = any(c1 in row for row in input_grid)
    has_c2 = any(c2 in row for row in input_grid)
    if not has_c1:
        for i in range(size):
            for j in range(size):
                if (i % 2 == 0 and j % 2 == 0) or (i % 2 == 1 and j % 2 == 1):
                    input_grid[i][j] = c1
                    break
            if has_c1:
                break
    if not has_c2:
        for i in range(size):
            for j in range(size):
                if (i % 2 == 0 and j % 2 == 1) or (i % 2 == 1 and j % 2 == 0):
                    input_grid[i][j] = c2
                    break
            if has_c2:
                break
    output_grid = [[c1 if (i + j) % 2 == 0 else c2 for j in range(size)] for i in range(size)]
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    size = len(input_list)
    hints = []
    for i in range(size):
        for j in range(size):
            if input_list[i][j] != 0:
                hints.append((i, j, input_list[i][j]))
    colors = set()
    for (i, j, color) in hints:
        colors.add(color)
    if len(colors) < 2:
        c1, c2 = 1, 2
    else:
        c1 = None
        for (i, j, color) in hints:
            if (i + j) % 2 == 0:
                c1 = color
                break
        c2 = next(iter(colors - {c1})) if c1 is not None else next(iter(colors))
        if c1 is None:
            c1 = next(iter(colors))
            c2 = next(iter(colors - {c1}))
    output = [[c1 if (i + j) % 2 == 0 else c2 for j in range(size)] for i in range(size)]
    return output
