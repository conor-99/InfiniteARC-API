# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 556ada7e
Difficulty: easy

=== Tags ===
- Pattern reflection
- Fill smallest enclosed hole
- Draw line from border
- Separate images

=== Description ===
The input grid contains a single connected shape with at least one enclosed
hole. The smallest enclosed hole (the one with the fewest cells, typically a
single cell) is filled with color 1. The entire grid is then reflected
vertically (left-right mirror). A straight line of color 2 is drawn from the top
border's center point to the newly filled hole. The output grid demonstrates
these transformations: the filled hole, vertical symmetry, and the connecting
line, which separates the original shape from its mirrored counterpart.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    width = random.choice(range(3, 16, 2))
    height = random.choice(range(3, 16, 2))
    grid = [[3] * width for _ in range(height)]
    center_col = (width - 1) // 2
    r = random.randint(1, height - 2)
    c = center_col
    grid[r][c] = 0
    grid_filled = [row[:] for row in grid]
    grid_filled[r][c] = 1
    grid_reflected = [row[::-1] for row in grid_filled]
    for i in range(r):
        grid_reflected[i][center_col] = 2
    return {
        "input": grid,
        "output": grid_reflected
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    hole_pos = None
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                if (r == 0 or input_grid[r-1][c] != 0) and \
                   (r == height-1 or input_grid[r+1][c] != 0) and \
                   (c == 0 or input_grid[r][c-1] != 0) and \
                   (c == width-1 or input_grid[r][c+1] != 0):
                    hole_pos = (r, c)
                    break
        if hole_pos is not None:
            break
    if hole_pos is None:
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == 0:
                    hole_pos = (r, c)
                    break
            if hole_pos is not None:
                break
    r, c = hole_pos
    grid_filled = [row[:] for row in input_grid]
    grid_filled[r][c] = 1
    grid_reflected = [row[::-1] for row in grid_filled]
    center_col = (width - 1) // 2
    hole_r, hole_c = r, width - 1 - c
    for i in range(hole_r):
        grid_reflected[i][center_col] = 2
    return grid_reflected
