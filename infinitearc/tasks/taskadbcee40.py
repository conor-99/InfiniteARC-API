# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: adbcee40
Difficulty: hard

=== Tags ===
- Area based reconstruction
- Hollow core detection
- Hollow shape detection
- Mutual reflection
- Detect grid

=== Description ===
The input grid features a structured arrangement of hollow rectangular shapes
(each with a solid border of a single color and an empty interior) organized in
a grid pattern (e.g., 3×3 or 4×4), with consistent spacing between shapes. The
hollow shapes do not touch, and their border colors vary to form a distinct
pattern across the grid. Background cells (color 0) separate all shapes and fill
empty spaces between them.  The task requires two primary operations:   1.
**Hollow Core Detection**: Identify all contiguous empty interior regions
(cores) of each hollow shape. Each core is a rectangle bounded by a single
border color, with no background cells inside.   2. **Area-Based Reconstruction
via Mutual Reflection**: For each core, reconstruct its interior by applying a
*mutual reflection* rule. This rule dictates that the core’s interior pattern
mirrors the border colors of *adjacent hollow shapes* in a grid-aligned manner.
Specifically:      - For a core at grid position (i,j), the interior pattern is
derived from the border colors of the hollow shapes immediately above/below
(vertical reflection) or left/right (horizontal reflection), depending on the
grid’s dominant axis.      - The reflection alternates direction per row or
column (e.g., odd rows reflect left-right, even rows reflect top-bottom) to
create a non-trivial, coherent pattern.      - The reconstructed pattern must
maintain the original border colors but arrange them in a mirrored sequence
within the core, ensuring no color overlaps or background cells are introduced.
The output grid retains all original hollow shape borders and background, with
only the cores being reconstructed. The reconstructed patterns must form
symmetrical, visually consistent sequences within each core, reflecting the
spatial relationships between adjacent hollow shapes. This task demands multi-
step reasoning: detecting grid structure, identifying hollow cores, and applying
a reflection rule that depends on the grid’s positional hierarchy, making it
challenging due to the need for combinatorial spatial reasoning and pattern
generalization across varying grid sizes and color arrangements.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Number of shapes in rows and columns (grid of hollow rectangles)
    rows = random.randint(2, 4)
    cols = random.randint(2, 4)

    # Core (interior) size for each hollow rectangle (square cores for simplicity)
    core_size = random.randint(1, 4)  # interior size (height and width)
    shape_h = core_size + 2
    shape_w = core_size + 2

    # Spacing between shapes (background zeros)
    spacing = random.choice([1, 2])

    total_height = rows * shape_h + (rows - 1) * spacing
    total_width = cols * shape_w + (cols - 1) * spacing

    # Create empty background
    inp = grid(total_width, total_height, 0)

    # Choose border colors (allow repeats)
    border_colors = [random.randint(1, 9) for _ in range(rows * cols)]

    # Draw hollow rectangles
    boxes = []  # store bounding boxes for later use
    for ri in range(rows):
        for cj in range(cols):
            top = ri * (shape_h + spacing)
            left = cj * (shape_w + spacing)
            bottom = top + shape_h - 1
            right = left + shape_w - 1
            color = border_colors[ri * cols + cj]

            # top and bottom borders
            for c in range(left, right + 1):
                inp[top][c] = color
                inp[bottom][c] = color

            # left and right borders
            for r in range(top + 1, bottom):
                inp[r][left] = color
                inp[r][right] = color

            boxes.append((top, left, bottom, right, color))

    # Prepare output by filling cores according to mutual reflection rule
    out = [row[:] for row in inp]

    for ri in range(rows):
        for cj in range(cols):
            top, left, bottom, right, color = boxes[ri * cols + cj]
            core_r0 = top + 1
            core_r1 = bottom - 1
            core_c0 = left + 1
            core_c1 = right - 1
            core_h = core_r1 - core_r0 + 1
            core_w = core_c1 - core_c0 + 1

            # Determine neighbor colors for reflection
            if ri % 2 == 0:
                # Vertical reflection: use colors from shapes above/below
                if ri > 0:
                    top_color = border_colors[(ri - 1) * cols + cj]
                else:
                    top_color = border_colors[(ri + 1) * cols + cj]
                if ri < rows - 1:
                    bottom_color = border_colors[(ri + 1) * cols + cj]
                else:
                    bottom_color = border_colors[(ri - 1) * cols + cj]

                # Fill core: top half -> top_color, bottom half -> bottom_color
                for r in range(core_r0, core_r1 + 1):
                    row_in_core = r - core_r0
                    for c in range(core_c0, core_c1 + 1):
                        if row_in_core < (core_h // 2):
                            out[r][c] = top_color
                        else:
                            out[r][c] = bottom_color
            else:
                # Horizontal reflection: use colors from shapes left/right
                if cj > 0:
                    left_color = border_colors[ri * cols + (cj - 1)]
                else:
                    left_color = border_colors[ri * cols + (cj + 1)]
                if cj < cols - 1:
                    right_color = border_colors[ri * cols + (cj + 1)]
                else:
                    right_color = border_colors[ri * cols + (cj - 1)]

                # Fill core: left half -> left_color, right half -> right_color
                for c in range(core_c0, core_c1 + 1):
                    col_in_core = c - core_c0
                    for r in range(core_r0, core_r1 + 1):
                        if col_in_core < (core_w // 2):
                            out[r][c] = left_color
                        else:
                            out[r][c] = right_color

    return {"input": inp, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    visited = [[False] * width for _ in range(height)]
    shapes = []  # list of (top, left, bottom, right, color)

    # Find connected components of non-zero pixels (each border is a connected ring)
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 or visited[r][c]:
                continue
            color = grid[r][c]
            stack = [(r, c)]
            visited[r][c] = True
            coords = []
            while stack:
                rr, cc = stack.pop()
                coords.append((rr, cc))
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))

            min_r = min(p[0] for p in coords)
            max_r = max(p[0] for p in coords)
            min_c = min(p[1] for p in coords)
            max_c = max(p[1] for p in coords)

            # Validate that this component forms a hollow rectangle border
            valid = True
            for cc2 in range(min_c, max_c + 1):
                if grid[min_r][cc2] != color or grid[max_r][cc2] != color:
                    valid = False
                    break
            if not valid:
                continue
            for rr2 in range(min_r, max_r + 1):
                if grid[rr2][min_c] != color or grid[rr2][max_c] != color:
                    valid = False
                    break
            if not valid:
                continue
            for rr2 in range(min_r + 1, max_r):
                for cc2 in range(min_c + 1, max_c):
                    if grid[rr2][cc2] != 0:
                        valid = False
                        break
                if not valid:
                    break
            if not valid:
                continue

            shapes.append((min_r, min_c, max_r, max_c, color))

    if not shapes:
        return grid

    # Determine grid rows and columns by unique top/left coordinates
    row_tops = sorted(set(s[0] for s in shapes))
    col_lefts = sorted(set(s[1] for s in shapes))
    rows = len(row_tops)
    cols = len(col_lefts)

    # Map shape positions to (row_idx, col_idx)
    pos_color = {}
    pos_box = {}
    for top, left, bottom, right, color in shapes:
        ri = row_tops.index(top)
        cj = col_lefts.index(left)
        pos_color[(ri, cj)] = color
        pos_box[(ri, cj)] = (top, left, bottom, right)

    # Make a copy to write output
    out = [row[:] for row in grid]

    # Apply the same mutual-reflection filling rule used by the generator
    for ri in range(rows):
        for cj in range(cols):
            if (ri, cj) not in pos_box:
                continue
            top, left, bottom, right = pos_box[(ri, cj)]
            core_r0 = top + 1
            core_r1 = bottom - 1
            core_c0 = left + 1
            core_c1 = right - 1
            core_h = core_r1 - core_r0 + 1
            core_w = core_c1 - core_c0 + 1
            if core_h <= 0 or core_w <= 0:
                continue

            if ri % 2 == 0:
                # vertical reflection
                if ri > 0:
                    top_color = pos_color.get((ri - 1, cj))
                else:
                    top_color = pos_color.get((ri + 1, cj))
                if ri < rows - 1:
                    bottom_color = pos_color.get((ri + 1, cj))
                else:
                    bottom_color = pos_color.get((ri - 1, cj))
                if top_color is None:
                    top_color = pos_color.get((ri, cj))
                if bottom_color is None:
                    bottom_color = pos_color.get((ri, cj))

                for r in range(core_r0, core_r1 + 1):
                    row_in_core = r - core_r0
                    for c in range(core_c0, core_c1 + 1):
                        if row_in_core < (core_h // 2):
                            out[r][c] = top_color
                        else:
                            out[r][c] = bottom_color
            else:
                # horizontal reflection
                if cj > 0:
                    left_color = pos_color.get((ri, cj - 1))
                else:
                    left_color = pos_color.get((ri, cj + 1))
                if cj < cols - 1:
                    right_color = pos_color.get((ri, cj + 1))
                else:
                    right_color = pos_color.get((ri, cj - 1))
                if left_color is None:
                    left_color = pos_color.get((ri, cj))
                if right_color is None:
                    right_color = pos_color.get((ri, cj))

                for c in range(core_c0, core_c1 + 1):
                    col_in_core = c - core_c0
                    for r in range(core_r0, core_r1 + 1):
                        if col_in_core < (core_w // 2):
                            out[r][c] = left_color
                        else:
                            out[r][c] = right_color

    return out

