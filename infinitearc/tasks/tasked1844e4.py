# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: ed1844e4
Difficulty: hard

=== Tags ===
- Symbolic circuit

=== Description ===
# Symbolic Circuit  Input grids feature a background of color 0 with multiple
colored symbols (colors 1-9) arranged across a 15×15 to 30×30 grid. Each symbol
is a compact cluster of 2-4 connected cells forming a distinct shape (e.g.,
L-shapes, T-shapes, or cross patterns), with one side of the cluster displaying
a directional interface color. The interface color is a single cell adjacent to
the symbol's perimeter (e.g., a red cell extending left from an L-shaped symbol
indicates a left-facing interface).  The output grid must complete a closed
circuit by adding straight-line "wires" between matching interface colors. Each
wire must: 1. Connect exactly two interfaces of identical color 2. Follow
straight horizontal or vertical paths 3. Pass only through background cells
(never overlapping symbols) 4. Form a single continuous loop connecting all
symbols  Critical constraints include: - No wires may cross existing symbols or
other wires - All symbols must be incorporated into the circuit - The circuit
must form a single closed loop with no branches - Interface colors must match
exactly for connections to be valid  The input shows partial connections
(background cells), while the output completes the circuit by adding the missing
segments. The complexity arises from needing to identify all interface colors,
determine valid connections without crossing, and ensure the final configuration
forms a single closed loop through multiple interdependent reasoning steps.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    # Grid size
    width = random.randint(15, 30)
    height = random.randint(15, 30)
    grid = common.grid(width, height, 0)

    # Choose rectangle bounds with safe margins so there's room for symbols outside the wires
    min_gap = 4  # minimum distance between left and right (and top and bottom)
    left = random.randint(2, max(2, width - min_gap - 3))
    right = random.randint(left + min_gap, width - 3)
    top = random.randint(2, max(2, height - min_gap - 3))
    bottom = random.randint(top + min_gap, height - 3)

    # Choose distinct colors: 4 for wires, 4 for symbols (8 distinct colors total)
    colors = random.sample(list(range(1, 10)), 8)
    top_color, right_color, bottom_color, left_color = colors[0:4]
    sym_colors = colors[4:8]

    # Place symbol clusters at the four rectangle corners (each cluster 2-3 cells)
    corners = [
        (top, left),    # top-left
        (top, right),   # top-right
        (bottom, right),# bottom-right
        (bottom, left)  # bottom-left
    ]

    for idx, (r, c) in enumerate(corners):
        scol = sym_colors[idx]
        # Place center cell (this cell is guaranteed to not be on the wire path)
        grid[r][c] = scol
        # Add one or two extra cells to make the cluster size 2-3 (L-shape or straight)
        extra_cells = []
        if idx == 0:  # top-left: try above and left
            if r - 1 >= 0:
                extra_cells.append((r - 1, c))
            if c - 1 >= 0 and random.choice([True, False]):
                extra_cells.append((r, c - 1))
        elif idx == 1:  # top-right: try above and right
            if r - 1 >= 0:
                extra_cells.append((r - 1, c))
            if c + 1 < width and random.choice([True, False]):
                extra_cells.append((r, c + 1))
        elif idx == 2:  # bottom-right: try below and right
            if r + 1 < height:
                extra_cells.append((r + 1, c))
            if c + 1 < width and random.choice([True, False]):
                extra_cells.append((r, c + 1))
        else:  # bottom-left: try below and left
            if r + 1 < height:
                extra_cells.append((r + 1, c))
            if c - 1 >= 0 and random.choice([True, False]):
                extra_cells.append((r, c - 1))

        # Keep at most 2 extras so cluster size is between 2 and 3
        extra_cells = extra_cells[:2]
        for (er, ec) in extra_cells:
            # Avoid overwriting a wire cell (shouldn't happen) or another symbol
            if grid[er][ec] == 0:
                grid[er][ec] = scol

    # Prepare the full (correct) output grid by drawing the closed rectangular loop
    output = [row[:] for row in grid]

    # Top edge: row = top, columns left+1 .. right-1
    for c in range(left + 1, right):
        # Do not overwrite symbol cells (there shouldn't be any on these coordinates)
        output[top][c] = top_color
    # Bottom edge
    for c in range(left + 1, right):
        output[bottom][c] = bottom_color
    # Left edge
    for r in range(top + 1, bottom):
        output[r][left] = left_color
    # Right edge
    for r in range(top + 1, bottom):
        output[r][right] = right_color

    # Place interface cells (stubs) at the ends of each edge; these are part of the wire
    # Top-left corner stubs
    output[top][left + 1] = top_color
    output[top + 1][left] = left_color
    # Top-right
    output[top][right - 1] = top_color
    output[top + 1][right] = right_color
    # Bottom-right
    output[bottom][right - 1] = bottom_color
    output[bottom - 1][right] = right_color
    # Bottom-left
    output[bottom][left + 1] = bottom_color
    output[bottom - 1][left] = left_color

    # Now create the input grid by removing some interior segments while keeping the interface stubs
    inp = [row[:] for row in output]

    # Decide which edges to show in the input (at least one edge must be missing so input != output)
    edges = ['top', 'right', 'bottom', 'left']
    show = {edge: random.choice([True, False]) for edge in edges}
    if all(show.values()):
        # Ensure at least one missing
        show[random.choice(edges)] = False

    # For any edge that is not shown, clear the interior (but keep the stub endpoints)
    # Top edge interior: columns left+2 .. right-2 (keep stubs at left+1 and right-1)
    if not show['top']:
        for c in range(left + 2, right - 1):
            if 0 <= top < height and 0 <= c < width:
                inp[top][c] = 0
    if not show['bottom']:
        for c in range(left + 2, right - 1):
            if 0 <= bottom < height and 0 <= c < width:
                inp[bottom][c] = 0
    if not show['left']:
        for r in range(top + 2, bottom - 1):
            if 0 <= r < height and 0 <= left < width:
                inp[r][left] = 0
    if not show['right']:
        for r in range(top + 2, bottom - 1):
            if 0 <= r < height and 0 <= right < width:
                inp[r][right] = 0

    # Return input and full correct output
    return {"input": inp, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height>0 else 0

    # For every color present, if its occurrences lie on a single row or a single column,
    # fill the straight interval between the min and max coordinates with that color.
    colors_positions = {}
    for r in range(height):
        for c in range(width):
            val = grid[r][c]
            if val == 0:
                continue
            colors_positions.setdefault(val, []).append((r, c))

    for val, positions in colors_positions.items():
        rows = [p[0] for p in positions]
        cols = [p[1] for p in positions]
        min_r, max_r = min(rows), max(rows)
        min_c, max_c = min(cols), max(cols)
        # If all positions are on a single row, fill that row interval
        if min_r == max_r:
            r = min_r
            for c in range(min_c, max_c + 1):
                if grid[r][c] == 0:
                    grid[r][c] = val
        # If all positions are on a single column, fill that column interval
        elif min_c == max_c:
            c = min_c
            for r in range(min_r, max_r + 1):
                if grid[r][c] == 0:
                    grid[r][c] = val

    return tuple(tuple(row) for row in grid)

