# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 11c3784c
Difficulty: insane

=== Tags ===
- Stepwise color transition
- Rule based tiling
- Find shape in negative space
- Count touches

=== Description ===
Input grids feature a background color (0) with multiple distinct colored
regions (1–9), each forming a contiguous shape (edge-connected). The background
cells form a hidden shape that is a contiguous region enclosed by colored
regions (not touching grid edges), recognizable by its geometric structure
(e.g., a square, circle, or triangle) through symmetry and edge alignment. The
hidden shape’s size and orientation are determined by the input grid’s
arrangement of colored regions.  To generate the output grid: 1. **Identify the
hidden shape in negative space**: Locate the largest enclosed background region
with consistent geometric properties (e.g., uniform side lengths for a square,
symmetric curves for a circle). This shape must be fully surrounded by colored
regions and not intersect grid boundaries. 2. **Count touches**: For each
colored region, count edge-adjacent background cells that belong to the hidden
shape (C = number of bordering edges between the region and the hidden shape).
3. **Apply stepwise color transition**: Each region’s color (X) transitions to a
new color via (X + C) mod 9, with colors mapped to 1–9 (0 excluded). For
example, color 7 with C=3 becomes 1 (7+3=10 → 10 mod 9 = 1). 4. **Apply rule-
based tiling**: Divide the grid into tiles aligned with the hidden shape’s
geometric properties (e.g., tiles match the hidden shape’s edges or sections).
Within each tile, transform all colored regions using the stepwise transition
rule, preserving the hidden shape’s integrity as background.  The output grid
retains the hidden shape’s structure (background), updates all colored regions
per the transition rule, and ensures tiles maintain alignment with the hidden
shape’s geometry. No grid boundaries or background cells are altered.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    # Grid size
    width = random.randint(12, 28)
    height = random.randint(12, 28)

    # margin so the hidden shape doesn't touch the grid edges
    margin = 3

    # Choose hidden rectangular shape size (kept small so adjacency counts < 9)
    max_w = max(3, min(8, width - 2 * margin))
    max_h = max(3, min(8, height - 2 * margin))
    w = random.randint(3, max_w)
    h = random.randint(3, max_h)

    # top-left of hidden rectangle (interior)
    r0 = random.randint(margin, height - h - margin)
    c0 = random.randint(margin, width - w - margin)

    # Start with all background (0)
    input_grid = common.grid(width, height, 0)

    # Thickness of the colored strips surrounding the hidden rectangle
    t_top = random.randint(1, min(3, r0))
    t_bottom = random.randint(1, max(1, min(3, height - (r0 + h))))
    t_left = random.randint(1, min(3, c0))
    t_right = random.randint(1, max(1, min(3, width - (c0 + w))))

    # Choose distinct colors for the four side regions
    side_colors = common.random_colors(4)

    # Top strip (above the hidden rectangle)
    for rr in range(r0 - t_top, r0):
        for cc in range(c0, c0 + w):
            input_grid[rr][cc] = side_colors[0]

    # Bottom strip (below the hidden rectangle)
    for rr in range(r0 + h, r0 + h + t_bottom):
        for cc in range(c0, c0 + w):
            input_grid[rr][cc] = side_colors[1]

    # Left strip (left of the hidden rectangle)
    for cc in range(c0 - t_left, c0):
        for rr in range(r0, r0 + h):
            input_grid[rr][cc] = side_colors[2]

    # Right strip (right of the hidden rectangle)
    for cc in range(c0 + w, c0 + w + t_right):
        for rr in range(r0, r0 + h):
            input_grid[rr][cc] = side_colors[3]

    # Add a few extra colored rectangular blobs elsewhere (do not overwrite hidden interior or existing colored cells)
    extra_count = random.randint(0, 3)
    used = set(side_colors)
    candidates = [c for c in range(1, 10) if c not in used]
    random.shuffle(candidates)
    extras = candidates[:extra_count]

    for color in extras:
        placed = False
        tries = 0
        while not placed and tries < 200:
            tries += 1
            ew = random.randint(2, min(6, width - 1))
            eh = random.randint(2, min(6, height - 1))
            rr0 = random.randint(0, height - eh)
            cc0 = random.randint(0, width - ew)

            overlap = False
            for rr in range(rr0, rr0 + eh):
                for cc in range(cc0, cc0 + ew):
                    # don't place inside the hidden rectangle interior
                    if r0 <= rr < r0 + h and c0 <= cc < c0 + w:
                        overlap = True
                        break
                    if input_grid[rr][cc] != 0:
                        overlap = True
                        break
                if overlap:
                    break
            if overlap:
                continue

            # place the rectangle
            for rr in range(rr0, rr0 + eh):
                for cc in range(cc0, cc0 + ew):
                    input_grid[rr][cc] = color
            placed = True

    # Now compute the corresponding output by the task rules
    # 1) find background regions, pick the largest enclosed background region as hidden shape
    H = height
    W = width
    visited = [[False] * W for _ in range(H)]
    bg_regions = []
    for i in range(H):
        for j in range(W):
            if input_grid[i][j] == 0 and not visited[i][j]:
                q = [(i, j)]
                visited[i][j] = True
                region = []
                while q:
                    x, y = q.pop()
                    region.append((x, y))
                    for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nx, ny = x + dx, y + dy
                        if 0 <= nx < H and 0 <= ny < W and not visited[nx][ny] and input_grid[nx][ny] == 0:
                            visited[nx][ny] = True
                            q.append((nx, ny))
                bg_regions.append(region)

    enclosed = []
    for reg in bg_regions:
        touches_edge = any(r == 0 or r == H - 1 or c == 0 or c == W - 1 for (r, c) in reg)
        if not touches_edge:
            enclosed.append(reg)

    if enclosed:
        hidden = max(enclosed, key=len)
    else:
        # fallback: choose the largest background region
        hidden = max(bg_regions, key=len)
    hidden_set = set(hidden)

    # 2) find colored regions (contiguous areas of the same color)
    visited = [[False] * W for _ in range(H)]
    regions = []
    region_colors = []
    for i in range(H):
        for j in range(W):
            if input_grid[i][j] != 0 and not visited[i][j]:
                color = input_grid[i][j]
                q = [(i, j)]
                visited[i][j] = True
                region = []
                while q:
                    x, y = q.pop()
                    region.append((x, y))
                    for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nx, ny = x + dx, y + dy
                        if 0 <= nx < H and 0 <= ny < W and not visited[nx][ny] and input_grid[nx][ny] == color:
                            visited[nx][ny] = True
                            q.append((nx, ny))
                regions.append(region)
                region_colors.append(color)

    # 3) count touches for each region to the hidden shape
    region_counts = []
    for region in regions:
        cnt = 0
        for (x, y) in region:
            for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nx, ny = x + dx, y + dy
                if (nx, ny) in hidden_set:
                    cnt += 1
        region_counts.append(cnt)

    # 4) apply color transition: new = (old + C) mod 9 mapped into 1..9
    output_grid = [[0] * W for _ in range(H)]
    for idx, region in enumerate(regions):
        old = region_colors[idx]
        C = region_counts[idx]
        newc = (old + C) % 9
        if newc == 0:
            newc = 9
        for (x, y) in region:
            output_grid[x][y] = newc

    # background stays 0 and any leftover zeros remain
    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0])

    # 1) find all background (0) regions
    visited = [[False] * W for _ in range(H)]
    bg_regions = []
    for i in range(H):
        for j in range(W):
            if grid[i][j] == 0 and not visited[i][j]:
                q = [(i, j)]
                visited[i][j] = True
                region = []
                while q:
                    x, y = q.pop()
                    region.append((x, y))
                    for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nx, ny = x + dx, y + dy
                        if 0 <= nx < H and 0 <= ny < W and not visited[nx][ny] and grid[nx][ny] == 0:
                            visited[nx][ny] = True
                            q.append((nx, ny))
                bg_regions.append(region)

    # 2) choose the largest enclosed background region as the hidden shape (if any)
    enclosed = []
    for reg in bg_regions:
        touches_edge = any(r == 0 or r == H - 1 or c == 0 or c == W - 1 for (r, c) in reg)
        if not touches_edge:
            enclosed.append(reg)
    if enclosed:
        hidden = max(enclosed, key=len)
    else:
        hidden = max(bg_regions, key=len)
    hidden_set = set(hidden)

    # 3) find colored regions (contiguous areas of the same non-zero color)
    visited = [[False] * W for _ in range(H)]
    regions = []
    region_colors = []
    for i in range(H):
        for j in range(W):
            if grid[i][j] != 0 and not visited[i][j]:
                color = grid[i][j]
                q = [(i, j)]
                visited[i][j] = True
                region = []
                while q:
                    x, y = q.pop()
                    region.append((x, y))
                    for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nx, ny = x + dx, y + dy
                        if 0 <= nx < H and 0 <= ny < W and not visited[nx][ny] and grid[nx][ny] == color:
                            visited[nx][ny] = True
                            q.append((nx, ny))
                regions.append(region)
                region_colors.append(color)

    # 4) count touches to the hidden shape for each region
    region_counts = []
    for region in regions:
        cnt = 0
        for (x, y) in region:
            for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nx, ny = x + dx, y + dy
                if (nx, ny) in hidden_set:
                    cnt += 1
        region_counts.append(cnt)

    # 5) apply the color transform and build output
    output = [[0] * W for _ in range(H)]
    for idx, region in enumerate(regions):
        old = region_colors[idx]
        C = region_counts[idx]
        newc = (old + C) % 9
        if newc == 0:
            newc = 9
        for (x, y) in region:
            output[x][y] = newc

    # background stays 0
    return output

