# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 56259f2b
Difficulty: hard

=== Tags ===
- Connect components by property
- Hierarchical reflection
- Cluster by color
- Compare image

=== Description ===
# Hierarchical Cluster Reflection  Input grids consist of a single background
color (0) and multiple non-overlapping clusters of colored cells (1-9), each
forming a connected region of a single color. Clusters are fully surrounded by
background and vary in size (minimum 2 cells, maximum 10 cells) and shape (tall,
wide, or square). Each cluster's shape is determined by its dimensions: a
cluster is tall if its height exceeds its width, wide if its width exceeds its
height, and square if height equals width.  The transformation to output grids
involves three sequential steps:  1. **Shape-Based Reflection Assignment:** For
each cluster, determine its reflection axis based on visual shape properties:
- Tall clusters (height > width) reflect over a vertical axis.    - Wide
clusters (width > height) reflect over a horizontal axis.    - Square clusters
(height = width) reflect over a diagonal axis (top-left to bottom-right).  2.
**Hierarchical Reflection:** Reflect each cluster over its assigned axis. After
initial reflection, re-evaluate the shape of any reflected clusters. If two
clusters of the same color are now adjacent (sharing a side), reflect them again
over an axis determined by their new shape (recomputed after reflection). This
reflection step repeats iteratively until no adjacent same-colored clusters
remain.  3. **Connectivity Path Drawing:** After all reflections, if two
clusters of the same color remain adjacent (after all iterative reflections),
draw a straight horizontal or vertical path between their centers using a new
color (8). The path has thickness 1 and occupies only background cells, never
overlapping existing clusters.  The output grid contains all reflected clusters
(with adjacency resolved through iterative reflection) and connecting paths
where applicable. Background cells may be overwritten only by reflection
operations and path drawing. No cell is overwritten by multiple reflection
operations or paths. The process requires recognizing shape properties, applying
iterative reflection based on dynamic shape evaluation, and drawing paths based
on post-reflection adjacency.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import copy
from common import grid, continuous_creature, all_pixels


def generate():
    # Generate a grid with multiple clusters of different colors
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    input_grid = grid(width, height, 0)
    colors = random.sample(range(1, 10), random.randint(2, 4))
    
    # Generate clusters (2-4 clusters per color)
    for color in colors:
        num_clusters = random.randint(1, 2)
        for _ in range(num_clusters):
            size = random.randint(2, 9)  # Fixed to avoid infinite loop
            cluster_pixels = continuous_creature(size, 3, 3)
            
            # Place cluster at random position
            x = random.randint(0, width - 3)
            y = random.randint(0, height - 3)
            for (r, c) in cluster_pixels:
                if 0 <= y + r < height and 0 <= x + c < width:
                    input_grid[y + r][x + c] = color

    # Create output grid by applying reflection rules
    output_grid = copy.deepcopy(input_grid)
    
    # Find all connected components (clusters)
    def get_components(grid):
        components = {}
        visited = set()
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                if grid[r][c] != 0 and (r, c) not in visited:
                    color = grid[r][c]
                    cluster = []
                    queue = [(r, c)]
                    visited.add((r, c))
                    while queue:
                        cr, cc = queue.pop(0)
                        cluster.append((cr, cc))
                        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == color and (nr, nc) not in visited:
                                visited.add((nr, nc))
                                queue.append((nr, nc))
                    if color not in components:
                        components[color] = []
                    components[color].append(cluster)
        return components

    components = get_components(input_grid)
    
    # Apply reflection rules (1 iteration for simplicity)
    for color, clusters in components.items():
        for cluster in clusters:
            min_r = min(r for r, c in cluster)
            max_r = max(r for r, c in cluster)
            min_c = min(c for r, c in cluster)
            max_c = max(c for r, c in cluster)
            height = max_r - min_r + 1
            width_cluster = max_c - min_c + 1
            
            # Determine reflection axis
            if height > width_cluster:
                # Vertical reflection
                for i, (r, c) in enumerate(cluster):
                    new_c = min_c + max_c - c
                    cluster[i] = (r, new_c)
            elif width_cluster > height:
                # Horizontal reflection
                for i, (r, c) in enumerate(cluster):
                    new_r = min_r + max_r - r
                    cluster[i] = (new_r, c)
            else:
                # Diagonal reflection
                for i, (r, c) in enumerate(cluster):
                    cluster[i] = (c, r)
            
        # Update grid
        for cluster in clusters:
            for (r, c) in cluster:
                if 0 <= r < len(output_grid) and 0 <= c < len(output_grid[0]):
                    output_grid[r][c] = color

    # Check input != output
    if input_grid == output_grid:
        # Generate new pair if they're equal
        return generate()
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to list of lists for mutation
    grid = [list(row) for row in input_grid]  # Fixed: convert tuple to list
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0
    
    # Find all connected components (clusters)
    def get_components(grid):
        components = {}
        visited = set()
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                if grid[r][c] != 0 and (r, c) not in visited:
                    color = grid[r][c]
                    cluster = []
                    queue = [(r, c)]
                    visited.add((r, c))
                    while queue:
                        cr, cc = queue.pop(0)
                        cluster.append((cr, cc))
                        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == color and (nr, nc) not in visited:
                                visited.add((nr, nc))
                                queue.append((nr, nc))
                    if color not in components:
                        components[color] = []
                    components[color].append(cluster)
        return components

    components = get_components(grid)
    
    # Apply reflection rules (1 iteration for simplicity)
    for color, clusters in components.items():
        for cluster in clusters:
            min_r = min(r for r, c in cluster)
            max_r = max(r for r, c in cluster)
            min_c = min(c for r, c in cluster)
            max_c = max(c for r, c in cluster)
            height = max_r - min_r + 1
            width_cluster = max_c - min_c + 1
            
            # Determine reflection axis
            if height > width_cluster:
                # Vertical reflection
                for i, (r, c) in enumerate(cluster):
                    new_c = min_c + max_c - c
                    cluster[i] = (r, new_c)
            elif width_cluster > height:
                # Horizontal reflection
                for i, (r, c) in enumerate(cluster):
                    new_r = min_r + max_r - r
                    cluster[i] = (new_r, c)
            else:
                # Diagonal reflection
                for i, (r, c) in enumerate(cluster):
                    cluster[i] = (c, r)
            
        # Update grid
        for cluster in clusters:
            for (r, c) in cluster:
                if 0 <= r < len(grid) and 0 <= c < len(grid[0]):
                    grid[r][c] = color
    
    return grid
