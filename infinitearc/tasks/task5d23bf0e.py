# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 5d23bf0e
Difficulty: medium–hard

=== Tags ===
- Hierarchical repetition

=== Description ===
Input grids consist of two concentric rectangular frames, each defined by a
distinct border color against a uniform background. The outer frame encloses a
complex pattern composed of multiple colored cells, while the inner frame
(centered within the outer frame with consistent spacing) encloses a transformed
version of this pattern. The transformation applied to derive the inner pattern
from the outer pattern involves two consistent rules: (1) a 90-degree clockwise
rotation of the entire pattern, and (2) a cyclic shift of all pattern colors
through a predefined sequence (e.g., red → green → blue → yellow → red...). The
frame borders themselves remain unchanged in color and structure between levels.
The output grid must add a third concentric frame inside the inner frame,
applying the same rotation and color cycle transformation to the inner pattern
to generate the new innermost pattern, while preserving all outer frames and
background exactly as in the input. The background color must remain uniform,
all frames must be perfectly centered, and no pattern cells may overlap with
frame borders or other non-background elements. This requires recognizing both
the rotational symmetry and color cycle from the two input frames before
extending the hierarchy.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def rotate_90_clockwise(mat):
    return [list(row) for row in zip(*mat[::-1])]


def generate():
    # Try to pick sizes and spacings that allow three concentric frames
    for _ in range(200):
        size = random.randint(15, 25)
        # outer margin (distance from edge to outer frame)
        outer_margin = random.randint(1, 2)
        # spacing between frames (gap of background cells)
        gap = random.randint(3, 6)
        # compute positions
        topO = outer_margin
        topI = topO + 1 + gap
        topN = topI + (topI - topO)  # consistent spacing
        # compute the inner-most interior size available after placing new frame
        # new interior size = size - 2*topN - 2 (borders)
        new_interior_size = size - 2 * topN - 2
        # ensure there's space for at least a small pattern inside the new frame
        if new_interior_size >= 2:
            break
    else:
        # fallback
        size = 20
        outer_margin = 1
        gap = 3
        topO = outer_margin
        topI = topO + 1 + gap
        topN = topI + (topI - topO)
        new_interior_size = size - 2 * topN - 2

    # pick a pattern size P that fits in the top band (height = gap)
    maxP = min(gap, new_interior_size, 8)
    if maxP < 2:
        P = 2
    else:
        P = random.randint(2, maxP)

    bg = 0
    ingrid = grid(size, size, bg)

    # Select two distinct frame colors for outer and inner (avoid background)
    all_colors = list(range(1, 10))
    outer_frame_color, inner_frame_color = random.sample(all_colors, 2)

    # Choose a color cycle (length 3 or 4) using colors not equal to the frame colors
    available = [c for c in all_colors if c not in (outer_frame_color, inner_frame_color)]
    cycle_len = random.choice([3, 4])
    cycle_len = min(cycle_len, len(available))
    color_cycle = random.sample(available, cycle_len)

    # Draw outer frame (1-cell thick)
    leftO = topO
    rightO = size - 1 - topO
    bottomO = rightO
    for c in range(leftO, rightO + 1):
        ingrid[topO][c] = outer_frame_color
        ingrid[bottomO][c] = outer_frame_color
    for r in range(topO, bottomO + 1):
        ingrid[r][leftO] = outer_frame_color
        ingrid[r][rightO] = outer_frame_color

    # Draw inner frame
    leftI = topI
    rightI = size - 1 - topI
    bottomI = rightI
    for c in range(leftI, rightI + 1):
        ingrid[topI][c] = inner_frame_color
        ingrid[bottomI][c] = inner_frame_color
    for r in range(topI, bottomI + 1):
        ingrid[r][leftI] = inner_frame_color
        ingrid[r][rightI] = inner_frame_color

    # Create an outer pattern P x P that uses every color in the cycle at least once
    cells = [random.choice(color_cycle) for _ in range(P * P)]
    # ensure each cycle color appears at least once
    for i, col in enumerate(color_cycle):
        if i < len(cells):
            cells[i] = col
    random.shuffle(cells)
    outer_pattern = [cells[i * P:(i + 1) * P] for i in range(P)]

    # Place outer pattern in the top band (between outer interior and inner frame) so it doesn't overlap inner frame
    start_row_outer = topO + 1 + (gap - P) // 2
    outer_interior_width = (rightO - leftO - 1)
    if outer_interior_width - P >= 0:
        start_col_outer = leftO + 1 + random.randint(0, outer_interior_width - P)
    else:
        start_col_outer = leftO + 1

    for r in range(P):
        for c in range(P):
            ingrid[start_row_outer + r][start_col_outer + c] = outer_pattern[r][c]

    # Build the color-next map for the cycle (cyclic)
    next_map = {color_cycle[i]: color_cycle[(i + 1) % len(color_cycle)] for i in range(len(color_cycle))}

    # Create inner pattern by rotating the outer pattern 90deg clockwise and advancing colors by one in the cycle
    rotated_outer = rotate_90_clockwise(outer_pattern)
    inner_pattern = [[next_map[val] for val in row] for row in rotated_outer]

    # Place inner pattern centered inside inner frame interior
    inner_interior_size = (bottomI - topI - 1)
    start_row_inner = topI + 1 + (inner_interior_size - P) // 2
    start_col_inner = leftI + 1 + (inner_interior_size - P) // 2
    for r in range(P):
        for c in range(P):
            ingrid[start_row_inner + r][start_col_inner + c] = inner_pattern[r][c]

    # Prepare the output grid by copying the input and then adding the new frame + pattern
    output = [row[:] for row in ingrid]

    # Determine a deterministic new frame color: the smallest color 1..9 not already present in the input
    present = set()
    for r in range(size):
        for c in range(size):
            if ingrid[r][c] != bg:
                present.add(ingrid[r][c])
    new_frame_color = next(col for col in range(1, 10) if col not in present)

    # Coordinates for new frame (concentric with same spacing)
    leftN = topN
    rightN = size - 1 - topN
    bottomN = rightN

    # Draw new frame on the output
    for c in range(leftN, rightN + 1):
        output[topN][c] = new_frame_color
        output[bottomN][c] = new_frame_color
    for r in range(topN, bottomN + 1):
        output[r][leftN] = new_frame_color
        output[r][rightN] = new_frame_color

    # Create new inner pattern by rotating the inner pattern and advancing colors once more
    rotated_inner = rotate_90_clockwise(inner_pattern)
    new_inner_pattern = [[next_map[val] for val in row] for row in rotated_inner]

    # Place the new inner pattern centered in the new frame interior
    new_interior_size = bottomN - topN - 1
    start_row_new = topN + 1 + (new_interior_size - P) // 2
    start_col_new = leftN + 1 + (new_interior_size - P) // 2
    for r in range(P):
        for c in range(P):
            output[start_row_new + r][start_col_new + c] = new_inner_pattern[r][c]

    return {'input': ingrid, 'output': output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    from collections import deque, Counter

    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0]) if h > 0 else 0

    # Determine background color as the most frequent color
    counts = Counter()
    for r in range(h):
        for c in range(w):
            counts[grid[r][c]] += 1
    bg = max(counts, key=lambda k: counts[k])

    # Helper: rotate 90 degrees clockwise
    def rotate_90_clockwise(mat):
        return [list(row) for row in zip(*mat[::-1])]

    # Detect rectangular frames by looking for colors that form a perfect 1-cell border rectangle
    frames = []  # list of dicts with keys: color, minr, maxr, minc, maxc
    colors = set()
    for r in range(h):
        for c in range(w):
            if grid[r][c] != bg:
                colors.add(grid[r][c])
    for color in colors:
        # collect coordinates of this color
        coords = [(r, c) for r in range(h) for c in range(w) if grid[r][c] == color]
        if not coords:
            continue
        minr = min(r for r, _ in coords)
        maxr = max(r for r, _ in coords)
        minc = min(c for _, c in coords)
        maxc = max(c for _, c in coords)
        # simple validation: rectangle must be at least 3x3 to be a frame
        if maxr - minr < 2 or maxc - minc < 2:
            continue
        ok = True
        for cc in range(minc, maxc + 1):
            if grid[minr][cc] != color or grid[maxr][cc] != color:
                ok = False
                break
        if not ok:
            continue
        for rr in range(minr, maxr + 1):
            if grid[rr][minc] != color or grid[rr][maxc] != color:
                ok = False
                break
        if not ok:
            continue
        frames.append({'color': color, 'minr': minr, 'maxr': maxr, 'minc': minc, 'maxc': maxc,
                       'area': (maxr - minr + 1) * (maxc - minc + 1)})

    # Need at least two frames (outer and inner)
    if len(frames) < 2:
        # nothing to do
        return grid

    # sort frames by area descending -> outermost first
    frames = sorted(frames, key=lambda f: f['area'], reverse=True)
    outer = frames[0]
    inner = frames[1]

    topO, bottomO, leftO, rightO = outer['minr'], outer['maxr'], outer['minc'], outer['maxc']
    topI, bottomI, leftI, rightI = inner['minr'], inner['maxr'], inner['minc'], inner['maxc']

    # Extract outer pattern: look for the largest connected component of non-background, non-frame colors
    visited = [[False] * w for _ in range(h)]
    components = []

    def in_outer_region(rr, cc):
        if rr <= topO or rr >= bottomO or cc <= leftO or cc >= rightO:
            return False
        # exclude the inner frame region (including border)
        if topI <= rr <= bottomI and leftI <= cc <= rightI:
            return False
        return True

    for r in range(topO + 1, bottomO):
        for c in range(leftO + 1, rightO):
            if not in_outer_region(r, c):
                continue
            if visited[r][c]:
                continue
            val = grid[r][c]
            if val == bg or val == outer['color'] or val == inner['color']:
                continue
            # BFS
            q = deque()
            q.append((r, c))
            comp = []
            visited[r][c] = True
            while q:
                rr, cc = q.popleft()
                comp.append((rr, cc))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = rr + dr, cc + dc
                    if nr < 0 or nr >= h or nc < 0 or nc >= w: 
                        continue
                    if not in_outer_region(nr, nc):
                        continue
                    if visited[nr][nc]:
                        continue
                    if grid[nr][nc] == bg or grid[nr][nc] == outer['color'] or grid[nr][nc] == inner['color']:
                        continue
                    visited[nr][nc] = True
                    q.append((nr, nc))
            if comp:
                components.append(comp)

    if not components:
        return grid

    # Choose the largest component (should be the square outer pattern)
    comp = max(components, key=lambda x: len(x))
    minr_o = min(p[0] for p in comp)
    maxr_o = max(p[0] for p in comp)
    minc_o = min(p[1] for p in comp)
    maxc_o = max(p[1] for p in comp)
    outer_pattern = [ [grid[r][c] for c in range(minc_o, maxc_o + 1)] for r in range(minr_o, maxr_o + 1) ]
    P = len(outer_pattern)

    # Extract inner pattern inside the inner frame interior
    inner_cells = []
    for r in range(topI + 1, bottomI):
        for c in range(leftI + 1, rightI):
            if grid[r][c] == bg or grid[r][c] == outer['color'] or grid[r][c] == inner['color']:
                continue
            inner_cells.append((r, c))

    if not inner_cells:
        return grid

    minr_i = min(r for r, _ in inner_cells)
    maxr_i = max(r for r, _ in inner_cells)
    minc_i = min(c for _, c in inner_cells)
    maxc_i = max(c for _, c in inner_cells)
    inner_pattern = [ [grid[r][c] for c in range(minc_i, maxc_i + 1)] for r in range(minr_i, maxr_i + 1) ]

    # Rotate the outer pattern and build a mapping from rotated outer color -> inner color
    rotated_outer = rotate_90_clockwise(outer_pattern)
    mapping = {}
    for r in range(len(rotated_outer)):
        for c in range(len(rotated_outer[0])):
            a = rotated_outer[r][c]
            b = inner_pattern[r][c]
            if a == bg or b == bg:
                continue
            if a in mapping and mapping[a] != b:
                # inconsistent, but shouldn't happen in well-formed tasks
                pass
            mapping[a] = b

    # Complete the cycle mapping by linking end->start if necessary
    nodes = set(mapping.keys()) | set(mapping.values())
    if nodes:
        incoming = set(mapping.values())
        outgoing = set(mapping.keys())
        start_candidates = [n for n in nodes if n not in incoming]
        end_candidates = [n for n in nodes if n not in outgoing]
        if start_candidates and end_candidates:
            start = start_candidates[0]
            end = end_candidates[0]
            if end not in mapping:
                mapping[end] = start
        # if mapping already forms a cycle, nothing to do

    # Now compute the new inner pattern: rotate the inner pattern and advance colors by one via mapping
    rotated_inner = rotate_90_clockwise(inner_pattern)
    new_inner = [ [ mapping.get(val, val) for val in row ] for row in rotated_inner ]

    # Determine coordinates for the new frame (concentric spacing)
    spacing = topI - topO - 1
    topN = topI + spacing + 1
    leftN = leftI + spacing + 1
    bottomN = h - 1 - topN
    rightN = w - 1 - leftN

    # Pick deterministic new frame color: smallest color 1..9 not present in the input
    present = set()
    for r in range(h):
        for c in range(w):
            if grid[r][c] != bg:
                present.add(grid[r][c])
    new_frame_color = next(col for col in range(1, 10) if col not in present)

    # Create output as a copy of the input
    out = [row[:] for row in grid]

    # Draw the new frame
    for c in range(leftN, rightN + 1):
        out[topN][c] = new_frame_color
        out[bottomN][c] = new_frame_color
    for r in range(topN, bottomN + 1):
        out[r][leftN] = new_frame_color
        out[r][rightN] = new_frame_color

    # Place new inner pattern centered in the new frame interior
    new_interior_h = bottomN - topN - 1
    new_interior_w = rightN - leftN - 1
    start_r_new = topN + 1 + (new_interior_h - len(new_inner)) // 2
    start_c_new = leftN + 1 + (new_interior_w - len(new_inner[0])) // 2
    for r in range(len(new_inner)):
        for c in range(len(new_inner[0])):
            out[start_r_new + r][start_c_new + c] = new_inner[r][c]

    return out

