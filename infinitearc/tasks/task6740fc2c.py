# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 6740fc2c
Difficulty: hard

=== Tags ===
- Discover grid scale
- Associate colors to images
- Minimal path fill
- Pattern expansion

=== Description ===
The task involves transforming input grids into output grids through a multi-
step process that requires discovering the grid's scaling factor, associating
colors with geometric patterns, filling minimal paths between designated points,
and expanding patterns. Input grids contain colored cells (0–9), where non-zero
colors represent distinct geometric shapes (e.g., color 1 = circle, color 2 =
square, color 3 = triangle), with color 8 marking the start point and color 9
marking the end point. The output grid is generated by: (1) determining the
scale factor as the count of distinct non-zero colors in the input (e.g., 4
distinct colors → scale factor 4); (2) replacing each input cell with a scaled
block (size = scale factor × scale factor) filled with its corresponding shape,
centered or tiled within the block; (3) computing the minimal Manhattan path
between the start (color 8) and end (color 9) points in the input grid
(prioritizing right/down moves for tie-breaking), then filling all cells along
this path in the output grid with a new color (e.g., color 5), overriding the
shape fill in those regions. The task demands careful abstraction to identify
scaling patterns, map color-shape associations, and apply path-filling rules
consistently.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    k = random.randint(1, 7)
    max_size = 30 // k
    rows = random.randint(3, min(15, max_size))
    cols = random.randint(3, min(15, max_size))
    colors = random.sample(range(1, 8), k)
    input_grid = grid(cols, rows, 0)
    input_grid[0][0] = 8
    input_grid[rows-1][cols-1] = 9
    positions = []
    for r in range(rows):
        for c in range(cols):
            if (r, c) != (0, 0) and (r, c) != (rows-1, cols-1):
                positions.append((r, c))
    random.shuffle(positions)
    for i in range(k):
        r, c = positions[i]
        input_grid[r][c] = colors[i]
    for i in range(k, len(positions)):
        r, c = positions[i]
        input_grid[r][c] = random.choice(colors)
    path = []
    for c in range(cols):
        path.append((0, c))
    for r in range(1, rows):
        path.append((r, cols-1))
    output_grid = grid(cols * k, rows * k, 0)
    for r in range(rows):
        for c in range(cols):
            start_r = r * k
            start_c = c * k
            if (r, c) in path:
                for dr in range(k):
                    for dc in range(k):
                        output_grid[start_r + dr][start_c + dc] = 5
            else:
                color = input_grid[r][c]
                for dr in range(k):
                    for dc in range(k):
                        output_grid[start_r + dr][start_c + dc] = color
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid
def p(input_grid):
    rows = len(input_grid)
    cols = len(input_grid[0])
    start = None
    end = None
    for r in range(rows):
        for c in range(cols):
            if input_grid[r][c] == 8:
                start = (r, c)
            elif input_grid[r][c] == 9:
                end = (r, c)
    if start is None or end is None:
        raise ValueError("Start or end not found")
    path = []
    for c in range(start[1], end[1] + 1):
        path.append((start[0], c))
    for r in range(start[0] + 1, end[0] + 1):
        path.append((r, end[1]))
    colors = set()
    for r in range(rows):
        for c in range(cols):
            color = input_grid[r][c]
            if color != 0 and color != 8 and color != 9:
                colors.add(color)
    k = len(colors)
    if k == 0:
        k = 1
    output_rows = rows * k
    output_cols = cols * k
    output_grid = grid(output_cols, output_rows, 0)
    for r in range(rows):
        for c in range(cols):
            start_r = r * k
            start_c = c * k
            if (r, c) in path:
                for dr in range(k):
                    for dc in range(k):
                        output_grid[start_r + dr][start_c + dc] = 5
            else:
                color = input_grid[r][c]
                for dr in range(k):
                    for dc in range(k):
                        output_grid[start_r + dr][start_c + dc] = color
    return output_grid
