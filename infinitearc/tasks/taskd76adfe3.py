# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: d76adfe3
Difficulty: medium

=== Tags ===
- Periodic run length encoding
- Take minimum
- Pattern coloring
- Normalize orientation

=== Description ===
The task involves transforming an input grid through a sequence of visual
operations. First, the grid is normalized to an orientation where the longest
horizontal run of identical colors is positioned at the bottom, achieved by
vertical flipping if necessary. Next, for every other row (starting from the
top), horizontal runs of identical colors are replaced by their lengths, capped
at 9. For each of these rows, the minimum run length across all runs in the row
is identified and used to fill every cell in that row with this value. Finally,
a checkerboard pattern is applied to the entire grid, where cells at positions
(i, j) with (i + j) even are set to color 5, and all other cells are set to
color 6. This transformation combines periodic run-length encoding, minimum
value selection, pattern-based coloring, and orientation normalization into a
consistent, visually intuitive process.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
def generate():
    w = random.randint(1, 30)
    h = random.randint(1, 30)
    input_grid = [[random.randint(0, 9) for _ in range(w)] for _ in range(h)]
    checkerboard = [[5 if (i + j) % 2 == 0 else 6 for j in range(w)] for i in range(h)]
    while input_grid == checkerboard:
        input_grid = [[random.randint(0, 9) for _ in range(w)] for _ in range(h)]
    return {
        "input": input_grid,
        "output": checkerboard
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable list of lists
    input_grid = [list(row) for row in input_grid]
    w = len(input_grid[0])
    h = len(input_grid)
    max_run = 0
    max_row = h - 1
    for r in range(h):
        current_run = 1
        max_in_row = 1
        for c in range(1, w):
            if input_grid[r][c] == input_grid[r][c-1]:
                current_run += 1
            else:
                if current_run > max_in_row:
                    max_in_row = current_run
                current_run = 1
        if current_run > max_in_row:
            max_in_row = current_run
        if max_in_row > max_run:
            max_run = max_in_row
            max_row = r
    if max_row != h - 1:
        input_grid = input_grid[::-1]
    for r in range(0, h, 2):
        if w == 0:
            continue
        runs = []
        current_run = 1
        for c in range(1, w):
            if input_grid[r][c] == input_grid[r][c-1]:
                current_run += 1
            else:
                runs.append(current_run)
                current_run = 1
        runs.append(current_run)
        min_run = min(runs) if runs else 0
        for c in range(w):
            input_grid[r][c] = min_run
    return [[5 if (i + j) % 2 == 0 else 6 for j in range(w)] for i in range(h)]
