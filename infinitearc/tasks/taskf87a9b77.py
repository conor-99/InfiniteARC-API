# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: f87a9b77
Difficulty: very hard

=== Tags ===
- Constraint satisfaction coloring
- Magnetic path alignment
- Shape morphing
- Contextual rule switch
- Obstacles
- Bring patterns close

=== Description ===
Input grids feature multiple disconnected clusters of colored cells (0-9)
representing distinct "patterns," interspersed with static obstacles of specific
colors or shapes (e.g., walls, barriers). Each pattern cluster has an inherent
magnetic direction dictated by its color (e.g., red clusters move right, blue
clusters move up), though the exact direction-color mapping must be inferred
from examples. The magnetic path must navigate around obstacles, with the
direction switching contextually: horizontal obstacles cause vertical turns
(e.g., a right-moving path turns up/down), and vertical obstacles cause
horizontal turns (e.g., an up-moving path turns left/right).   The
transformation involves two key phases: (1) aligning patterns along magnetic
paths while avoiding obstacles, and (2) morphing the shapes of patterns to
conform to the path's curvature (e.g., elongating into linear paths when moving
through narrow corridors, or bending around obstacles to maintain adjacency).
Patterns must be brought into proximity (adjacent or within a minimal distance)
without overlapping, crossing obstacles, or violating the magnetic constraints.
The output grid displays the morphed patterns in their new positions, with the
magnetic paths visually represented by the pattern's color extending along the
route. Obstacles remain unchanged, and the background preserves its original
structure. The task requires synthesizing multiple interacting rules—magnetic
attraction, obstacle navigation, shape adaptation, and proximity
constraints—without relying on numerical properties, demanding high-level
contextual reasoning to resolve conflicting transformations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Generator for ARC task f87a9b77 (Task 424)
# Produces input and output grids demonstrating patterns moving along magnetic paths around obstacles.

OBSTACLE = 5
PATTERN_COLORS = [1, 2, 3, 4]
DIRECTION_MAP = {1: (0, 1), 2: (-1, 0), 3: (0, -1), 4: (1, 0)}  # 1:right,2:up,3:left,4:down


def place_obstacles(g, width, height):
    # Place a few horizontal and vertical walls (obstacles), leaving gates
    rows = random.sample(range(1, height - 1), k=random.randint(1, max(1, height // 6)))
    cols = random.sample(range(1, width - 1), k=random.randint(1, max(1, width // 6)))
    for r in rows:
        for c in range(width):
            g[r][c] = OBSTACLE
        # create 1-2 gaps in the wall
        for _ in range(random.randint(1, max(1, width // 6))):
            gc = random.randint(0, width - 1)
            g[r][gc] = 0
    for c in cols:
        for r in range(height):
            g[r][c] = OBSTACLE
        # create 1-2 gaps in the wall
        for _ in range(random.randint(1, max(1, height // 6))):
            gr = random.randint(0, height - 1)
            g[gr][c] = 0
    return g


def random_shape_offsets(shape_type, size):
    if shape_type == 'single':
        return [(0, 0)]
    if shape_type == 'horizontal':
        return [(0, i) for i in range(size)]
    if shape_type == 'vertical':
        return [(i, 0) for i in range(size)]
    if shape_type == 'square':
        s = int(size ** 0.5)
        return [(r, c) for r in range(s) for c in range(s)]
    if shape_type == 'L':
        return [(0, 0), (1, 0), (1, 1)]
    # fallback
    return [(0, 0)]


def try_place_shape(g, width, height, offsets):
    # try to find a location where all offsets fit and cells are free (==0) and not obstacle
    attempts = 0
    while attempts < 200:
        r0 = random.randint(1, height - 2)
        c0 = random.randint(1, width - 2)
        fits = True
        for dr, dc in offsets:
            r, c = r0 + dr, c0 + dc
            if r < 0 or r >= height or c < 0 or c >= width:
                fits = False
                break
            if g[r][c] != 0:
                fits = False
                break
        if fits:
            return [(r0 + dr, c0 + dc) for dr, dc in offsets]
        attempts += 1
    return None


def compute_anchor(cells):
    # deterministic anchor: topmost then leftmost
    return sorted(cells)[0]


def min_dist_to_targets(cell, targets):
    if not targets:
        return 10**9
    r, c = cell
    return min(abs(r - tr) + abs(c - tc) for tr, tc in targets)


def obstacle_orientation(g, r, c, width, height):
    # returns 'horizontal' if obstacle connects left/right, 'vertical' if connects up/down, or None
    hor = False
    ver = False
    if c - 1 >= 0 and g[r][c - 1] == OBSTACLE: hor = True
    if c + 1 < width and g[r][c + 1] == OBSTACLE: hor = True
    if r - 1 >= 0 and g[r - 1][c] == OBSTACLE: ver = True
    if r + 1 < height and g[r + 1][c] == OBSTACLE: ver = True
    if hor and not ver:
        return 'horizontal'
    if ver and not hor:
        return 'vertical'
    if hor and ver:
        # corner - prefer the orientation that has more contiguous neighbors
        hor_count = 0
        ver_count = 0
        if c - 1 >= 0 and g[r][c - 1] == OBSTACLE: hor_count += 1
        if c + 1 < width and g[r][c + 1] == OBSTACLE: hor_count += 1
        if r - 1 >= 0 and g[r - 1][c] == OBSTACLE: ver_count += 1
        if r + 1 < height and g[r + 1][c] == OBSTACLE: ver_count += 1
        return 'horizontal' if hor_count >= ver_count else 'vertical'
    return None


def simulate_movement(in_grid):
    height = len(in_grid)
    width = len(in_grid[0])
    out = [row[:] for row in in_grid]

    # collect colors of patterns (exclude obstacle and background)
    colors = sorted(set(cell for row in in_grid for cell in row if cell != 0 and cell != OBSTACLE))
    # keep only allowed pattern colors (1-4)
    colors = [c for c in colors if c in PATTERN_COLORS]

    for color in colors:
        # find original cluster cells for this color in the input
        cluster = [(r, c) for r in range(height) for c in range(width) if in_grid[r][c] == color]
        if not cluster:
            continue
        anchor = compute_anchor(cluster)
        # remove original cluster from output (they will be morphed into the path)
        for (r, c) in cluster:
            out[r][c] = 0
        # place the starting cell at the anchor
        cur = anchor
        out[cur[0]][cur[1]] = color

        # targets are any non-obstacle non-zero cells currently present in out that are not this color
        def current_targets():
            return [(r, c) for r in range(height) for c in range(width) if out[r][c] != 0 and out[r][c] != color and out[r][c] != OBSTACLE]

        targets = current_targets()

        # direction based on color
        dr, dc = DIRECTION_MAP.get(color, (0, 1))

        steps = 0
        max_steps = width * height
        while steps < max_steps:
            steps += 1
            # stop if adjacent to any target
            targets = current_targets()
            if any(abs(cur[0] - tr) + abs(cur[1] - tc) == 1 for tr, tc in targets):
                break

            nr, nc = cur[0] + dr, cur[1] + dc
            # check bounds
            if not (0 <= nr < height and 0 <= nc < width):
                break
            val = out[nr][nc]
            if val == 0:
                # free cell: move forward
                cur = (nr, nc)
                out[cur[0]][cur[1]] = color
                continue
            if val == OBSTACLE:
                # obstacle orientation
                orient = obstacle_orientation(out, nr, nc, width, height)
                candidates = []
                if orient == 'horizontal':
                    candidates = [(cur[0] - 1, cur[1]), (cur[0] + 1, cur[1])]
                elif orient == 'vertical':
                    candidates = [(cur[0], cur[1] - 1), (cur[0], cur[1] + 1)]
                else:
                    # isolated or corner obstacle -> try vertical then horizontal
                    candidates = [(cur[0] - 1, cur[1]), (cur[0] + 1, cur[1]), (cur[0], cur[1] - 1), (cur[0], cur[1] + 1)]

                best = None
                best_dist = 10**9
                for (cr, cc) in candidates:
                    if not (0 <= cr < height and 0 <= cc < width):
                        continue
                    if out[cr][cc] != 0:
                        continue
                    d = min_dist_to_targets((cr, cc), targets)
                    if d < best_dist:
                        best_dist = d
                        best = (cr, cc)
                if best is None:
                    break
                # update direction to the new move
                dr, dc = best[0] - cur[0], best[1] - cur[1]
                cur = best
                out[cur[0]][cur[1]] = color
                continue
            else:
                # blocked by another pattern cell or previously drawn path: treat it as adjacency/stop
                break

    return out


def generate():
    # create grids until we satisfy movement (at least one pattern moves)
    tries = 0
    while True:
        tries += 1
        width = random.randint(10, 20)
        height = random.randint(10, 20)
        g = grid(width, height, 0)
        g = place_obstacles(g, width, height)

        # place 2-4 pattern clusters
        num = random.randint(2, 4)
        colors = random.sample(PATTERN_COLORS, k=num)
        placed = []
        for color in colors:
            # choose a shape
            shape_type = random.choice(['single', 'horizontal', 'vertical', 'L'])
            size = 1
            if shape_type in ('horizontal', 'vertical'):
                size = random.randint(1, 3)
            offsets = random_shape_offsets(shape_type, size)
            cells = try_place_shape(g, width, height, offsets)
            if cells is None:
                # fallback to single
                offsets = [(0, 0)]
                cells = try_place_shape(g, width, height, offsets)
            if cells is None:
                continue
            for (r, c) in cells:
                g[r][c] = color
            placed.append((color, cells))

        # ensure at least two clusters placed
        if len(placed) < 2:
            if tries > 50:
                continue
            else:
                continue

        # ensure at least one cluster has a free step in its initial direction -> guarantees output differs
        movable = False
        for (color, cells) in placed:
            anchor = compute_anchor(cells)
            dr, dc = DIRECTION_MAP[color]
            nr, nc = anchor[0] + dr, anchor[1] + dc
            if 0 <= nr < height and 0 <= nc < width and g[nr][nc] == 0:
                movable = True
                break
        if not movable:
            if tries > 100:
                # relax requirement and continue anyway
                break
            continue

        out = simulate_movement(g)
        # ensure output differs from input
        if out != g:
            return {'input': g, 'output': out}
        # else try again




# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert tuple grid to list of lists
    grid_in = [list(row) for row in input_grid]
    from copy import deepcopy
    OBSTACLE = 5
    PATTERN_COLORS = [1, 2, 3, 4]
    DIRECTION_MAP = {1: (0, 1), 2: (-1, 0), 3: (0, -1), 4: (1, 0)}

    height = len(grid_in)
    width = len(grid_in[0]) if height > 0 else 0
    out = [row[:] for row in grid_in]

    def compute_anchor(cells):
        return sorted(cells)[0]

    def current_targets():
        return [(r, c) for r in range(height) for c in range(width) if out[r][c] != 0 and out[r][c] != OBSTACLE and out[r][c] != color]

    def min_dist_to_targets(cell, targets):
        if not targets:
            return 10**9
        r, c = cell
        return min(abs(r - tr) + abs(c - tc) for tr, tc in targets)

    def obstacle_orientation(g, r, c):
        hor = False
        ver = False
        if c - 1 >= 0 and g[r][c - 1] == OBSTACLE: hor = True
        if c + 1 < width and g[r][c + 1] == OBSTACLE: hor = True
        if r - 1 >= 0 and g[r - 1][c] == OBSTACLE: ver = True
        if r + 1 < height and g[r + 1][c] == OBSTACLE: ver = True
        if hor and not ver:
            return 'horizontal'
        if ver and not hor:
            return 'vertical'
        if hor and ver:
            hor_count = 0
            ver_count = 0
            if c - 1 >= 0 and g[r][c - 1] == OBSTACLE: hor_count += 1
            if c + 1 < width and g[r][c + 1] == OBSTACLE: hor_count += 1
            if r - 1 >= 0 and g[r - 1][c] == OBSTACLE: ver_count += 1
            if r + 1 < height and g[r + 1][c] == OBSTACLE: ver_count += 1
            return 'horizontal' if hor_count >= ver_count else 'vertical'
        return None

    # collect active pattern colors in the input (exclude obstacle and background)
    colors = sorted(set(cell for row in grid_in for cell in row if cell != 0 and cell != OBSTACLE))
    colors = [c for c in colors if c in PATTERN_COLORS]

    for color in colors:
        # find original cluster positions for this color in the input
        cluster = [(r, c) for r in range(height) for c in range(width) if grid_in[r][c] == color]
        if not cluster:
            continue
        anchor = compute_anchor(cluster)
        # remove original cluster from out
        for (r, c) in cluster:
            out[r][c] = 0
        # starting point
        cur = anchor
        out[cur[0]][cur[1]] = color

        dr, dc = DIRECTION_MAP.get(color, (0, 1))
        steps = 0
        max_steps = width * height
        while steps < max_steps:
            steps += 1
            # update targets
            targets = [(r, c) for r in range(height) for c in range(width) if out[r][c] != 0 and out[r][c] != OBSTACLE and out[r][c] != color]
            if any(abs(cur[0] - tr) + abs(cur[1] - tc) == 1 for tr, tc in targets):
                break
            nr, nc = cur[0] + dr, cur[1] + dc
            if not (0 <= nr < height and 0 <= nc < width):
                break
            val = out[nr][nc]
            if val == 0:
                cur = (nr, nc)
                out[cur[0]][cur[1]] = color
                continue
            if val == OBSTACLE:
                orient = obstacle_orientation(out, nr, nc)
                candidates = []
                if orient == 'horizontal':
                    candidates = [(cur[0] - 1, cur[1]), (cur[0] + 1, cur[1])]
                elif orient == 'vertical':
                    candidates = [(cur[0], cur[1] - 1), (cur[0], cur[1] + 1)]
                else:
                    candidates = [(cur[0] - 1, cur[1]), (cur[0] + 1, cur[1]), (cur[0], cur[1] - 1), (cur[0], cur[1] + 1)]

                best = None
                best_dist = 10**9
                for (cr, cc) in candidates:
                    if not (0 <= cr < height and 0 <= cc < width):
                        continue
                    if out[cr][cc] != 0:
                        continue
                    d = min_dist_to_targets((cr, cc), targets)
                    if d < best_dist:
                        best_dist = d
                        best = (cr, cc)
                if best is None:
                    break
                dr, dc = best[0] - cur[0], best[1] - cur[1]
                cur = best
                out[cur[0]][cur[1]] = color
                continue
            else:
                # blocked by pattern cell or path
                break

    return out

