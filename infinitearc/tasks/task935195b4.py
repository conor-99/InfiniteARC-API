# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 935195b4
Difficulty: insane

=== Tags ===
- Pattern cycle
- Refraction simulation
- Maze
- Follow color path to destination
- Find and fix broken symmetry
- Center object in canvas

=== Description ===
The input grids present a visually complex maze-like structure composed of
interconnected colored paths, where each segment adheres to a repeating color
cycle (e.g., red → green → blue → red...). The maze is embedded within a larger
grid containing background cells, and the path must be traversed by following
the sequence of colors in order. However, the input grid contains critical
symmetry errors: key path segments or walls are missing or misaligned, creating
an asymmetric structure that disrupts the intended cycle. Additionally, specific
"refraction points" (cells of a distinct color) alter the path direction upon
entry—simulating light refraction—by forcing a 90-degree turn (left or right)
depending on the cell's color. The destination point (marked by a unique color)
is positioned off-center in the input, violating the requirement for balanced
composition.  The transformation requires multiple sequential steps: first,
identifying and correcting broken symmetry by mirroring or adjusting path
elements to restore geometric balance; second, verifying the color cycle
continuity and applying refraction rules at designated points to adjust the path
direction; third, relocating the destination point to the exact center of the
grid canvas while preserving all path integrity. The output grid must maintain
all original path colors and refraction rules, ensure the path follows the color
cycle without interruption, and position the destination at the geometric
center. Critical constraints include: no path segments may be overwritten,
refraction effects must only alter direction (not color), symmetry corrections
must not create new cycle violations, and the destination must be centered
within the grid's dimensions. The task demands simultaneous attention to pattern
consistency, spatial reasoning, and multi-step transformation logic to achieve a
visually coherent and rule-compliant output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    # Choose an odd size between 15 and 25 (inclusive) so the center is a single cell
    size = random.choice([s for s in range(15, 26) if s % 2 == 1])
    mid = size // 2
    ingrid = common.grid(size, size, 0)

    # Pick a 3-color cycle (avoid colors reserved for refraction and destination)
    cycle = common.random_colors(3, exclude=[7, 8, 9])

    # Build a non-self-intersecting path confined to the left half (columns 0..mid-1)
    start = (mid, 0)
    path = [start]
    occupied = set(path)
    r, c = start

    # target length gives variety but stays within the left half area
    target_len = random.randint(size, size * 2)
    for _ in range(target_len - 1):
        neighbors = []
        for dr, dc in [(-1, 0), (1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            # keep path inside the left half so center column stays free
            if nr < 0 or nr >= size or nc < 0 or nc >= mid:
                continue
            if (nr, nc) in occupied:
                continue
            neighbors.append((nr, nc))
        if not neighbors:
            break
        # bias toward moving right to create interesting shapes
        weights = [2 if pos[1] > c else 1 for pos in neighbors]
        nr, nc = random.choices(neighbors, weights=weights, k=1)[0]
        path.append((nr, nc))
        occupied.add((nr, nc))
        r, c = nr, nc

    # Paint the cycle colors along the path
    for i, (pr, pc) in enumerate(path):
        ingrid[pr][pc] = cycle[i % 3]

    # Place a few refraction markers on interior path cells using colors 7 and 9
    if len(path) > 3:
        k = random.randint(1, min(3, len(path) - 2))
        idxs = random.sample(range(1, len(path) - 1), k)
        for idx in idxs:
            pr, pc = path[idx]
            ingrid[pr][pc] = random.choice([7, 9])  # 7 = right-turn, 9 = left-turn

    # Place the destination (color 8) on an empty neighbor of the path end (so we don't overwrite path colors)
    end_r, end_c = path[-1]
    candidates = []
    for dr, dc in [(-1, 0), (1, 0), (0, 1), (0, -1)]:
        nr, nc = end_r + dr, end_c + dc
        if nr < 0 or nr >= size or nc < 0 or nc >= size:
            continue
        if (nr, nc) not in occupied:
            candidates.append((nr, nc))
    if candidates:
        dest_r, dest_c = random.choice(candidates)
    else:
        # fallback: any empty cell in left half
        empties = [(rr, cc) for rr in range(size) for cc in range(mid) if (rr, cc) not in occupied]
        if empties:
            dest_r, dest_c = random.choice(empties)
        else:
            # last fallback: any empty cell
            empties = [(rr, cc) for rr in range(size) for cc in range(size) if ingrid[rr][cc] == 0]
            dest_r, dest_c = random.choice(empties)
    ingrid[dest_r][dest_c] = 8

    input_grid = [row[:] for row in ingrid]

    # Introduce broken symmetry by randomly copying a subset of left-path cells to the right half
    for (pr, pc) in path:
        mr, mc = pr, size - 1 - pc
        if random.random() < 0.25:
            input_grid[mr][mc] = ingrid[pr][pc]

    # Sprinkle a few refraction markers off-path for visual complexity
    for _ in range(random.randint(0, 3)):
        rr = random.randint(0, size - 1)
        cc = random.randint(0, size - 1)
        if input_grid[rr][cc] == 0:
            input_grid[rr][cc] = random.choice([7, 9])

    # Create the correct output by perfectly restoring symmetry (mirror left half to right half)
    output_grid = [row[:] for row in input_grid]
    for rr in range(size):
        for cc in range(mid):
            output_grid[rr][size - 1 - cc] = input_grid[rr][cc]

    # Ensure there's exactly one destination marker at the geometric center (clear any existing 8s)
    for rr in range(size):
        for cc in range(size):
            if output_grid[rr][cc] == 8:
                output_grid[rr][cc] = 0
    output_grid[mid][mid] = 8

    return {
        "input": input_grid,
        "output": output_grid
    }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable grid
    grid = [list(row) for row in input_grid]
    size = len(grid)
    mid = size // 2

    # Restore symmetry by mirroring the left half into the right half
    for r in range(size):
        for c in range(mid):
            grid[r][size - 1 - c] = grid[r][c]

    # Remove any existing destination markers and place a single marker at the center
    for r in range(size):
        for c in range(size):
            if grid[r][c] == 8:
                grid[r][c] = 0
    grid[mid][mid] = 8

    return grid

