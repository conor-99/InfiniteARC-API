# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 07224275
Difficulty: hard

=== Tags ===
- Layered path system
- Mark centroid
- Draw pattern from point

=== Description ===
# Task Description: Centroid Path Patterns  Input grids are 10×10 to 30×30 in
size, featuring a single background color (0) with multiple disjoint,
orthogonally connected regions (paths) of distinct non-background colors (1–9).
Each path forms a contiguous shape surrounded by background, with no overlapping
paths. Paths may have complex geometries including loops, branches, and varying
densities.  The transformation requires identifying each path's centroid (the
arithmetic mean of all path cell coordinates, rounded to the nearest integer
grid cell), then drawing a 3×3 plus-sign pattern centered at this centroid. The
plus sign consists of the centroid cell and its four orthogonal neighbors (up,
down, left, right), drawn in a fixed pattern color (5), but only on background
cells (0 in input). Paths, background, and other elements remain unchanged.
Patterns may be partially clipped at grid boundaries or partially overwritten by
existing paths (though the pattern is never drawn over non-background cells).
The output grid preserves all original paths and background, while adding the
pattern only where background cells exist adjacent to each centroid. This
requires precise centroid calculation, careful pattern placement, and adherence
to non-overwriting constraints, making the task challenging due to the need for
multiple sequential operations (path identification, centroid calculation,
pattern drawing) across complex, layered structures.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random
import math

def _round_half_up(x):
    return int(math.floor(x + 0.5))

def _place_path(width, height, occupied, color):
    # Try to place a contiguous creature in the grid avoiding occupied cells and their orthogonal neighbors.
    for attempt in range(200):
        # Choose bounding box size
        max_box_w = min(12, max(3, width))
        max_box_h = min(12, max(3, height))
        box_w = random.randint(3, min(max_box_w, width))
        box_h = random.randint(3, min(max_box_h, height))
        # Choose size of creature (not too large)
        max_size = box_w * box_h
        size = random.randint(3, min(max(3, max_size//4), max_size))
        pixels = common.continuous_creature(size, width=box_w, height=box_h)
        # If creature is unexpectedly big or not connected, skip (continuous_creature returns contiguous)
        # Choose translation
        if width - box_w < 0 or height - box_h < 0:
            continue
        r0 = random.randint(0, height - box_h)
        c0 = random.randint(0, width - box_w)
        global_pixels = [(r0 + r, c0 + c) for (r, c) in pixels]
        # Check bounds
        ok = True
        for pr, pc in global_pixels:
            if not (0 <= pr < height and 0 <= pc < width):
                ok = False
                break
            # ensure no overlap or orthogonal adjacency with existing occupied
            for dr, dc in ((0,0),(1,0),(-1,0),(0,1),(0,-1)):
                if (pr + dr, pc + dc) in occupied:
                    ok = False
                    break
            if not ok:
                break
        if not ok:
            continue
        # Good placement; add to occupied and return pixels
        for pr, pc in global_pixels:
            occupied.add((pr, pc))
        return global_pixels
    return None

def generate():
    # keep trying until we produce a grid where at least one pattern cell is drawn
    for attempt_all in range(80):
        width = random.randint(10, 30)
        height = random.randint(10, 30)
        grid_in = common.grid(width, height, 0)
        occupied = set()
        paths = []
        num_paths = random.randint(2, 4)
        colors = common.random_colors(num_paths, exclude=[0])
        failed = False
        for color in colors:
            placed = _place_path(width, height, occupied, color)
            if placed is None:
                failed = True
                break
            paths.append((placed, color))
            for (r, c) in placed:
                grid_in[r][c] = color
        if failed:
            continue
        # compute centroids
        centroids = []
        for pixels, color in paths:
            sum_r = sum(r for r, c in pixels)
            sum_c = sum(c for r, c in pixels)
            centroid_r = _round_half_up(sum_r / len(pixels))
            centroid_c = _round_half_up(sum_c / len(pixels))
            # clamp to grid
            centroid_r = max(0, min(height - 1, centroid_r))
            centroid_c = max(0, min(width - 1, centroid_c))
            centroids.append((centroid_r, centroid_c))
        # draw pattern color 5 onto background cells only
        grid_out = [row[:] for row in grid_in]
        pattern_color = 5
        for (r, c) in centroids:
            for dr, dc in ((0,0),(1,0),(-1,0),(0,1),(0,-1)):
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid_in[nr][nc] == 0:
                    grid_out[nr][nc] = pattern_color
        if grid_in != grid_out:
            return {"input": grid_in, "output": grid_out}
    # fallback: construct two small separated paths centered so the pattern will be visible
    width = 10
    height = 10
    grid_in = common.grid(width, height, 0)
    colors = common.random_colors(2, exclude=[0])
    # path 1: two-cell vertical
    grid_in[2][2] = colors[0]
    grid_in[3][2] = colors[0]
    # path 2: two-cell horizontal
    grid_in[6][6] = colors[1]
    grid_in[6][7] = colors[1]
    centroids = []
    centroids.append((_round_half_up((2+3)/2), _round_half_up((2+2)/2)))
    centroids.append((_round_half_up((6+6)/2), _round_half_up((6+7)/2)))
    grid_out = [row[:] for row in grid_in]
    for (r, c) in centroids:
        for dr, dc in ((0,0),(1,0),(-1,0),(0,1),(0,-1)):
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and grid_in[nr][nc] == 0:
                grid_out[nr][nc] = 5
    return {"input": grid_in, "output": grid_out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import math

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    visited = [[False] * width for _ in range(height)]
    paths = []
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and grid[r][c] != 0:
                component = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] != 0:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                paths.append(component)
    def _round_half_up(x):
        return int(math.floor(x + 0.5))
    centroids = []
    for path in paths:
        if path:
            sum_r = sum(r for r, c in path)
            sum_c = sum(c for r, c in path)
            centroid_r = _round_half_up(sum_r / len(path))
            centroid_c = _round_half_up(sum_c / len(path))
            centroids.append((centroid_r, centroid_c))
    output = [row[:] for row in grid]
    for (r, c) in centroids:
        for dr, dc in [(0, 0), (1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0:
                output[nr][nc] = 5
    return output

