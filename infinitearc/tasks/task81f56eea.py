# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 81f56eea
Difficulty: very hard

=== Tags ===
- Implicit topology
- Gravity with barriers
- Motif extraction
- Align by centroid pairs
- Pattern rotation

=== Description ===
# Gravity-Align Rotating Motifs  Input grids consist of a background (color 0),
fixed barrier elements (color 5), and multiple distinct colored motifs (each a
connected region of a single non-background, non-barrier color). The barriers
form an implicit topological structure that blocks gravity, requiring motifs to
fall downward until contacting a barrier or grid boundary. Motifs may be of any
color (1-9), with each connected region of the same color forming a unique
motif.  The output transformation applies five sequential operations: 1.
**Gravity Application**: All motifs fall downward under gravity until they
contact a barrier or bottom edge. 2. **Motif Extraction**: Each connected region
of a single color (excluding barriers and background) is isolated as a distinct
motif. 3. **Centroid Calculation**: For each motif, compute its centroid
(average row and column of all cells). 4. **Centroid Pairing**: Motifs are
paired by proximity of their centroids (closest pairs first), ordered by color.
5. **Pattern Rotation**: The top-left 2×2 grid contains a repeating color
sequence that determines rotation angles (e.g., red=90°, green=180°, blue=270°).
Each motif pair is rotated around the midpoint of their centroids by the angle
specified by the current pattern element, cycling through the sequence for
successive pairs.  The output grid displays all motifs in their gravity-
positioned, centroid-aligned, and rotation-applied states, while preserving
barriers and background. The top-left pattern strip is not visible in the output
but is critical for determining rotation angles. This task requires recognizing
gravity interactions with barriers, extracting disconnected motifs, computing
centroid relationships, and deciphering a hidden rotation pattern from a small
input feature—all while maintaining strict spatial and color constraints.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import math
from common import grid, continuous_creature, random_colors

# Generator for ARC task: Gravity-Align Rotating Motifs

def generate():
    # grid size
    size = random.randint(10, 18)
    input_grid = grid(size, size, 0)

    # Place a 2x2 pattern in the top-left. Ensure at least one rotation-inducing color (1,2,3)
    pattern = [None, None, None, None]
    pattern[0] = random.choice([1, 2, 3])
    for i in range(1, 4):
        pattern[i] = random.choice([1, 2, 3, 4])
    input_grid[0][0] = pattern[0]
    input_grid[0][1] = pattern[1]
    input_grid[1][0] = pattern[2]
    input_grid[1][1] = pattern[3]

    # Place 1-3 horizontal barrier rows (color 5) somewhere below the top area.
    max_barriers = min(3, max(1, (size - 6)))
    possible_rows = list(range(4, size - 1))
    if not possible_rows:
        possible_rows = [size - 2]
    num_barriers = random.randint(1, min(max_barriers, len(possible_rows)))
    barrier_rows = sorted(random.sample(possible_rows, num_barriers))
    barrier_positions = set()
    for r in barrier_rows:
        # Add a few holes so the barrier is not a solid line everywhere.
        hole_count = random.randint(1, max(1, size // 6))
        holes = set(random.sample(range(size), hole_count))
        for c in range(size):
            if c in holes:
                continue
            input_grid[r][c] = 5
            barrier_positions.add((r, c))

    # Place multiple motifs: unique colors, connected shapes created with continuous_creature.
    num_motifs = random.randint(4, 7)
    motif_colors = random_colors(num_motifs, exclude=[5])

    placed_colors = []
    occupied = set((r, c) for r, c in barrier_positions)
    # also treat the 2x2 pattern cells as occupied for motif placement
    occupied.update([(0, 0), (0, 1), (1, 0), (1, 1)])

    for color in motif_colors:
        placed = False
        for _ in range(300):
            shape_area = random.randint(2, 6)
            shape_w = random.randint(2, 4)
            shape_h = random.randint(2, 4)
            if shape_w * shape_h < shape_area:
                # try to expand one dimension to fit the area
                shape_w = min(size - 4, max(shape_w, shape_area))
                shape_h = min(size - 4, max(shape_h, 2))
            local = continuous_creature(shape_area, shape_w, shape_h)
            max_lr = max(p[0] for p in local)
            max_lc = max(p[1] for p in local)

            # Determine feasible placement ranges
            max_r_start = size - 1 - max_lr
            max_c_start = size - 1 - max_lc
            if max_r_start < 2 or max_c_start < 2:
                continue
            r_start = random.randint(2, min(4, max_r_start))
            c_start = random.randint(2, max_c_start)

            global_positions = [(r_start + lr, c_start + lc) for (lr, lc) in local]
            # ensure positions are inside grid and not overlapping barriers/pattern/other motifs
            bad = False
            for (gr, gc) in global_positions:
                if gr < 0 or gr >= size or gc < 0 or gc >= size:
                    bad = True
                    break
                if (gr, gc) in occupied:
                    bad = True
                    break
            if bad:
                continue

            # Place motif
            for (gr, gc) in global_positions:
                input_grid[gr][gc] = color
                occupied.add((gr, gc))
            placed_colors.append(color)
            placed = True
            break
        if not placed:
            # If placement failed after many attempts, skip this color
            continue

    # Build the output grid by first applying gravity (blocked by barrier cells or bottom edge)
    output_grid = [row[:] for row in input_grid]

    # Gather motifs from the input (each placed color corresponds to one motif)
    motifs = {}
    for r in range(size):
        for c in range(size):
            v = input_grid[r][c]
            if v == 0 or v == 5:
                continue
            motifs.setdefault(v, []).append((r, c))

    # Apply gravity for each motif independently
    fallen = {}
    for color, positions in motifs.items():
        min_fall = size
        for (r, c) in positions:
            found = False
            for dr in range(1, size - r):
                rr = r + dr
                if input_grid[rr][c] == 5:
                    fall = dr - 1
                    found = True
                    break
            if not found:
                fall = (size - 1) - r
            if fall < min_fall:
                min_fall = fall
        # clear original positions in output
        for (r, c) in positions:
            output_grid[r][c] = 0
        new_positions = []
        for (r, c) in positions:
            nr = r + min_fall
            nc = c
            output_grid[nr][nc] = color
            new_positions.append((nr, nc))
        fallen[color] = new_positions

    # Compute centroids of each fallen motif
    centroids = {}
    for color, positions in fallen.items():
        n = len(positions)
        sr = sum(p[0] for p in positions)
        sc = sum(p[1] for p in positions)
        centroids[color] = (sr / n, sc / n)

    # Pair motifs by centroid proximity (greedy: pick closest remaining pair)
    pairs = []
    available = set(fallen.keys())
    cand = []
    colors = sorted(list(available))
    for i in range(len(colors)):
        for j in range(i + 1, len(colors)):
            a = colors[i]
            b = colors[j]
            dx = centroids[a][0] - centroids[b][0]
            dy = centroids[a][1] - centroids[b][1]
            dist = math.hypot(dx, dy)
            cand.append((dist, a, b))
    cand.sort(key=lambda x: (x[0], x[1], x[2]))
    taken = set()
    for dist, a, b in cand:
        if a in taken or b in taken:
            continue
        pairs.append((a, b))
        taken.add(a)
        taken.add(b)

    # Pattern sequence (top-left 2x2) determines rotation angles for successive pairs
    pattern_sequence = [input_grid[0][0], input_grid[0][1], input_grid[1][0], input_grid[1][1]]
    rotation_map = {1: 90, 2: 180, 3: 270, 4: 0}

    # Build a fresh final grid that preserves barriers but hides the top-left pattern
    final_grid = grid(size, size, 0)
    for (r, c) in barrier_positions:
        final_grid[r][c] = 5

    # Helper: rotate a single point (row, col) around (mid_r, mid_c) by angle degrees
    def rotate_point(row, col, mid_r, mid_c, angle_deg):
        angle = math.radians(angle_deg)
        x_rel = row - mid_r
        y_rel = col - mid_c
        x_new = x_rel * math.cos(angle) - y_rel * math.sin(angle)
        y_new = x_rel * math.sin(angle) + y_rel * math.cos(angle)
        return (x_new + mid_r, y_new + mid_c)

    # Apply rotations pair by pair, using the pattern sequence cyclically
    used_colors = set()
    for idx, (a, b) in enumerate(pairs):
        used_colors.add(a)
        used_colors.add(b)
        angle = rotation_map.get(pattern_sequence[idx % 4], 0)
        mid_r = (centroids[a][0] + centroids[b][0]) / 2.0
        mid_c = (centroids[a][1] + centroids[b][1]) / 2.0
        # rotate and place both motifs
        for (r, c) in fallen[a]:
            nrf, ncf = rotate_point(r, c, mid_r, mid_c, angle)
            nr = int(round(nrf))
            nc = int(round(ncf))
            if 0 <= nr < size and 0 <= nc < size and final_grid[nr][nc] != 5:
                final_grid[nr][nc] = a
        for (r, c) in fallen[b]:
            nrf, ncf = rotate_point(r, c, mid_r, mid_c, angle)
            nr = int(round(nrf))
            nc = int(round(ncf))
            if 0 <= nr < size and 0 <= nc < size and final_grid[nr][nc] != 5:
                final_grid[nr][nc] = b

    # Any unpaired motif(s) are copied as-is (after gravity)
    for color, positions in fallen.items():
        if color in used_colors:
            continue
        for (r, c) in positions:
            if final_grid[r][c] != 5:
                final_grid[r][c] = color

    # Hide the 2x2 pattern in the final output (set to background)
    if size > 1:
        final_grid[0][0] = 0
        final_grid[0][1] = 0
        final_grid[1][0] = 0
        final_grid[1][1] = 0

    return {"input": input_grid, "output": final_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import math

def p(input_grid):
    # Convert tuple-of-tuples to a mutable list-of-lists
    grid_in = [list(row) for row in input_grid]
    size = len(grid_in)

    # Record barrier cells
    barriers = set()
    for r in range(size):
        for c in range(size):
            if grid_in[r][c] == 5:
                barriers.add((r, c))

    # Read the 2x2 top-left pattern that encodes rotation angles
    pattern_sequence = [grid_in[0][0], grid_in[0][1], grid_in[1][0], grid_in[1][1]]
    rotation_map = {1: 90, 2: 180, 3: 270, 4: 0}

    # Extract motifs as connected components of the same non-zero, non-barrier color
    visited = [[False] * size for _ in range(size)]
    motifs = {}

    for r in range(size):
        for c in range(size):
            col = grid_in[r][c]
            if col == 0 or col == 5 or visited[r][c]:
                continue
            # BFS to extract connected component of this color
            stack = [(r, c)]
            visited[r][c] = True
            comp = []
            while stack:
                rr, cc = stack.pop()
                comp.append((rr, cc))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = rr + dr, cc + dc
                    if nr < 0 or nr >= size or nc < 0 or nc >= size:
                        continue
                    if visited[nr][nc]:
                        continue
                    if grid_in[nr][nc] != col:
                        continue
                    visited[nr][nc] = True
                    stack.append((nr, nc))
            motifs.setdefault(col, []).extend(comp)

    # Apply gravity to each motif independently (stop at barrier cells or grid bottom)
    fallen = {}
    for color, positions in motifs.items():
        # compute minimal fall across all pixels
        min_fall = size
        for (r, c) in positions:
            found = False
            for dr in range(1, size - r):
                rr = r + dr
                if (rr, c) in barriers:
                    fall = dr - 1
                    found = True
                    break
            if not found:
                fall = (size - 1) - r
            if fall < min_fall:
                min_fall = fall
        # move pixels down by min_fall
        new_positions = []
        for (r, c) in positions:
            nr = r + min_fall
            nc = c
            new_positions.append((nr, nc))
        fallen[color] = new_positions

    # Compute centroids of each fallen motif
    centroids = {}
    for color, positions in fallen.items():
        n = len(positions)
        if n == 0:
            continue
        sr = sum(p[0] for p in positions)
        sc = sum(p[1] for p in positions)
        centroids[color] = (sr / n, sc / n)

    # Pair motifs by centroid proximity greedily
    colors = sorted(list(fallen.keys()))
    cand = []
    for i in range(len(colors)):
        for j in range(i + 1, len(colors)):
            a = colors[i]
            b = colors[j]
            if a not in centroids or b not in centroids:
                continue
            dx = centroids[a][0] - centroids[b][0]
            dy = centroids[a][1] - centroids[b][1]
            dist = math.hypot(dx, dy)
            cand.append((dist, a, b))
    cand.sort(key=lambda x: (x[0], x[1], x[2]))
    taken = set()
    pairs = []
    for dist, a, b in cand:
        if a in taken or b in taken:
            continue
        pairs.append((a, b))
        taken.add(a)
        taken.add(b)

    # Prepare final grid: start with background and copy barriers
    final = [[0] * size for _ in range(size)]
    for (r, c) in barriers:
        final[r][c] = 5

    # Rotation helper
    def rotate_point(row, col, mid_r, mid_c, angle_deg):
        angle = math.radians(angle_deg)
        x_rel = row - mid_r
        y_rel = col - mid_c
        x_new = x_rel * math.cos(angle) - y_rel * math.sin(angle)
        y_new = x_rel * math.sin(angle) + y_rel * math.cos(angle)
        return (x_new + mid_r, y_new + mid_c)

    used = set()
    # Apply rotation for each pair using the pattern colors cyclically
    for idx, (a, b) in enumerate(pairs):
        used.add(a)
        used.add(b)
        pat_color = pattern_sequence[idx % 4]
        angle = rotation_map.get(pat_color, 0)
        mid_r = (centroids[a][0] + centroids[b][0]) / 2.0
        mid_c = (centroids[a][1] + centroids[b][1]) / 2.0
        for (r, c) in fallen[a]:
            nrf, ncf = rotate_point(r, c, mid_r, mid_c, angle)
            nr = int(round(nrf))
            nc = int(round(ncf))
            if 0 <= nr < size and 0 <= nc < size and final[nr][nc] != 5:
                final[nr][nc] = a
        for (r, c) in fallen[b]:
            nrf, ncf = rotate_point(r, c, mid_r, mid_c, angle)
            nr = int(round(nrf))
            nc = int(round(ncf))
            if 0 <= nr < size and 0 <= nc < size and final[nr][nc] != 5:
                final[nr][nc] = b

    # Any unpaired motifs are copied as-is (after gravity)
    for color, positions in fallen.items():
        if color in used:
            continue
        for (r, c) in positions:
            if final[r][c] != 5:
                final[r][c] = color

    # Hide the top-left 2x2 pattern in the output
    if size > 1:
        final[0][0] = 0
        final[0][1] = 0
        final[1][0] = 0
        final[1][1] = 0

    return final

