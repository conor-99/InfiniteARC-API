# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 61c0e0f0
Difficulty: mediumâ€“hard

=== Tags ===
- Truth table visualization
- Alternating agents
- Tiled majority vote
- Bridges

=== Description ===
Task: Tiled Majority Bridges  Input grids are even-sized (width and height
divisible by 2) grids containing colors 0-9. The grid is divided into non-
overlapping 2x2 tiles. For each tile, the majority color (most frequent in the 4
cells; tie broken by the top-left cell's color) determines the output value for
all cells in that tile. The output grid replaces every cell with the majority
color of its tile. Additionally, adjacent tiles (sharing a horizontal or
vertical edge) with identical majority colors form bridges, visually represented
by continuous color flow across their shared boundary. This continuity creates
the appearance of bridges connecting regions of the same color, while all other
grid features (background and distinct regions) remain unchanged. The
transformation requires recognizing tile boundaries, computing local majority
colors, and identifying adjacency patterns to form bridge connections.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    width = random.choice(range(2, 31, 2))
    height = random.choice(range(2, 31, 2))
    input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
    output_grid = [[0] * width for _ in range(height)]
    for i in range(0, height, 2):
        for j in range(0, width, 2):
            tile = [
                input_grid[i][j],
                input_grid[i][j+1],
                input_grid[i+1][j],
                input_grid[i+1][j+1]
            ]
            top_left = input_grid[i][j]
            counts = [tile.count(c) for c in range(10)]
            max_count = max(counts)
            candidates = [c for c in range(10) if counts[c] == max_count]
            if top_left in candidates:
                majority = top_left
            else:
                majority = candidates[0]
            output_grid[i][j] = majority
            output_grid[i][j+1] = majority
            output_grid[i+1][j] = majority
            output_grid[i+1][j+1] = majority
    if input_grid == output_grid:
        for _ in range(100):
            input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
            output_grid = [[0] * width for _ in range(height)]
            for i in range(0, height, 2):
                for j in range(0, width, 2):
                    tile = [
                        input_grid[i][j],
                        input_grid[i][j+1],
                        input_grid[i+1][j],
                        input_grid[i+1][j+1]
                    ]
                    top_left = input_grid[i][j]
                    counts = [tile.count(c) for c in range(10)]
                    max_count = max(counts)
                    candidates = [c for c in range(10) if counts[c] == max_count]
                    if top_left in candidates:
                        majority = top_left
                    else:
                        majority = candidates[0]
                    output_grid[i][j] = majority
                    output_grid[i][j+1] = majority
                    output_grid[i+1][j] = majority
                    output_grid[i+1][j+1] = majority
            if input_grid != output_grid:
                break
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = [[0] * width for _ in range(height)]
    for i in range(0, height, 2):
        for j in range(0, width, 2):
            tile = [
                input_grid[i][j],
                input_grid[i][j+1],
                input_grid[i+1][j],
                input_grid[i+1][j+1]
            ]
            top_left = input_grid[i][j]
            counts = [tile.count(c) for c in range(10)]
            max_count = max(counts)
            candidates = [c for c in range(10) if counts[c] == max_count]
            if top_left in candidates:
                majority = top_left
            else:
                majority = candidates[0]
            output_grid[i][j] = majority
            output_grid[i][j+1] = majority
            output_grid[i+1][j] = majority
            output_grid[i+1][j+1] = majority
    return output_grid
