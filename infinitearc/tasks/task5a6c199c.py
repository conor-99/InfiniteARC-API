# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 5a6c199c
Difficulty: insane

=== Tags ===
- Diagonals
- Signal to structure
- Color modulated motion
- Symbolic spatial binding
- Extend stem to border

=== Description ===
Input grids are 25×25 grids with a background color (0) and multiple diagonal
"stems" originating from the grid's edges. Each stem is composed of a single
color (1–9), where the color encodes a fixed diagonal direction: color 1 moves
northeast (↓→), color 2 moves southeast (↑→), color 3 moves northwest (↓←),
color 4 moves southwest (↑←), and colors 5–9 cycle through these directions
(color 5 = color 1, color 6 = color 2, etc.). Stems are partial in the input,
showing only their initial segments. The grid also contains background cells (0)
and may include other stems that partially overlap.  To generate the output
grid, each stem must be extended in its direction until it reaches the grid
border. If two stems intersect at a cell during extension, their colors modulate
according to a fixed rule: the new color is (color₁ + color₂ − 1) mod 9 + 1, and
the resulting color’s direction determines the path beyond the intersection. The
modulation occurs immediately at the intersection point, with the new color
overwriting all prior colors at that cell. The output grid displays all stems
fully extended to the border, with color modulations applied at all intersection
points, while preserving the original background elsewhere. The grid must
maintain consistent direction binding (e.g., color 1 always moves northeast) and
avoid overlapping paths except at modulation points.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def get_direction(color):
    directions = [(1, 1), (-1, 1), (1, -1), (-1, -1)]
    idx = (color - 1) % 4
    return directions[idx]

def generate():
    size = 25
    input_grid = grid(size, size, 0)
    colors_to_include = [c for c in range(1, 10) if random.random() > 0.5]
    for color in colors_to_include:
        dr, dc = get_direction(color)
        if dr == 1:
            r = 0
            c = random.randint(0, size - 1)
        elif dr == -1:
            r = size - 1
            c = random.randint(0, size - 1)
        else:
            r = random.randint(0, size - 1)
            c = 0 if dc == 1 else size - 1
        L = random.randint(2, 5)
        for i in range(L):
            new_r = r + dr * i
            new_c = c + dc * i
            if 0 <= new_r < size and 0 <= new_c < size:
                input_grid[new_r][new_c] = color
    output_grid = grid(size, size, 0)
    color_sets = [[[] for _ in range(size)] for _ in range(size)]
    for color in colors_to_include:
        dr, dc = get_direction(color)
        edge_found = None
        if dr == 1:
            for c in range(size):
                if input_grid[0][c] == color:
                    edge_found = (0, c)
                    break
        elif dr == -1:
            for c in range(size):
                if input_grid[size-1][c] == color:
                    edge_found = (size-1, c)
                    break
        if edge_found:
            r, c = edge_found
            while 0 <= r < size and 0 <= c < size:
                color_sets[r][c].append(color)
                r += dr
                c += dc
    for r in range(size):
        for c in range(size):
            colors = color_sets[r][c]
            if colors:
                if len(colors) == 1:
                    output_grid[r][c] = colors[0]
                else:
                    c1, c2 = colors
                    output_grid[r][c] = (c1 + c2 - 1) % 9 + 1
    if input_grid == output_grid:
        return generate()
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    size = len(input_grid)
    output = [[0] * size for _ in range(size)]
    color_sets = [[[] for _ in range(size)] for _ in range(size)]
    def get_direction(color):
        directions = [(1, 1), (-1, 1), (1, -1), (-1, -1)]
        idx = (color - 1) % 4
        return directions[idx]
    for color in range(1, 10):
        dr, dc = get_direction(color)
        edge_found = None
        if dr == 1:
            for c in range(size):
                if input_grid[0][c] == color:
                    edge_found = (0, c)
                    break
        elif dr == -1:
            for c in range(size):
                if input_grid[size-1][c] == color:
                    edge_found = (size-1, c)
                    break
        if edge_found:
            r, c = edge_found
            while 0 <= r < size and 0 <= c < size:
                color_sets[r][c].append(color)
                r += dr
                c += dc
    for r in range(size):
        for c in range(size):
            colors = color_sets[r][c]
            if colors:
                if len(colors) == 1:
                    output[r][c] = colors[0]
                else:
                    c1, c2 = colors
                    output[r][c] = (c1 + c2 - 1) % 9 + 1
    return output
