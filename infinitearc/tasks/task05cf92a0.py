# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 05cf92a0
Difficulty: medium

=== Tags ===
- Dominant color
- Reconstruct checkerboard from hint
- Pattern juxtaposition

=== Description ===
The task involves input grids that display a partial checkerboard pattern where
certain cells have been replaced by a single dominant color (the most frequently
occurring color in the grid). The output grid reconstructs the complete
checkerboard pattern by replacing all instances of the dominant color with the
correct alternating colors based on their position. The two primary colors used
in the checkerboard are determined by the two most frequent non-dominant colors
in the input. For each cell containing the dominant color, the output assigns
one of the two primary colors depending on whether the sum of its row and column
indices is even or odd (e.g., even sums become color A, odd sums become color
B). This process requires identifying the dominant color, isolating the two key
pattern colors, and applying a position-based substitution rule to restore the
checkerboard structure. The transformation is purely visual, relying on spatial
relationships rather than numerical computations, and the output grid will
always differ from the input due to the correction of dominant color cells.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

from common import grid
import random
from collections import Counter

def generate():
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    N = width * height
    colors = list(range(1, 10))
    A = random.choice(colors)
    B = random.choice([c for c in colors if c != A])
    input_grid = grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            if (r + c) % 2 == 0:
                input_grid[r][c] = A
            else:
                input_grid[r][c] = B
    C = random.choice([c for c in range(10) if c != A and c != B])
    max_A = (N + 1) // 2
    count_C = max_A + 1
    count_C = min(count_C, N - 2)
    all_cells = [(r, c) for r in range(height) for c in range(width)]
    random.shuffle(all_cells)
    cells_to_replace = all_cells[:count_C]
    for (r, c) in cells_to_replace:
        input_grid[r][c] = C
    output_grid = grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            if (r + c) % 2 == 0:
                output_grid[r][c] = A
            else:
                output_grid[r][c] = B
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid
from collections import Counter

def p(input_grid):
    flat = [pixel for row in input_grid for pixel in row]
    counts = Counter(flat)
    dominant = counts.most_common(1)[0][0]
    even_color = None
    odd_color = None
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] != dominant:
                if (r + c) % 2 == 0:
                    even_color = input_grid[r][c]
                else:
                    odd_color = input_grid[r][c]
                if even_color is not None and odd_color is not None:
                    break
        if even_color is not None and odd_color is not None:
            break
    if even_color is None or odd_color is None:
        other_colors = [color for color in counts.keys() if color != dominant]
        other_colors.sort(key=lambda x: counts[x], reverse=True)
        if len(other_colors) >= 2:
            even_color, odd_color = other_colors[0], other_colors[1]
        else:
            even_color = other_colors[0] if other_colors else 0
            odd_color = 1
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == dominant:
                output_grid[r][c] = even_color if (r + c) % 2 == 0 else odd_color
            else:
                output_grid[r][c] = input_grid[r][c]
    return output_grid
