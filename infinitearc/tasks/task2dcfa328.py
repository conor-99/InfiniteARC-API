# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 2dcfa328
Difficulty: very hard

=== Tags ===
- Kinetic collision
- Friction path
- Cooperative rule network
- Mutual reflection
- Recolor object based on neighbor count

=== Description ===
Input grids feature a large canvas (15×15 or larger) with background color 0.
Scattered across the grid are multiple disjoint, connected regions of distinct
colors (1-9), each representing a kinetic particle moving rightward at the
start. Particles move one cell right per step until colliding with another
particle or grid boundary. Upon collision with another particle, both particles
instantaneously reverse direction (right→left, left→right) and their colors are
updated to the total count of orthogonal background cells (color 0) adjacent to
their entire perimeter (not counting overlapping cells). Particles colliding
with boundaries stop moving but still recolor based on their pre-collision
neighbor count. The output grid shows all particles in their final positions
after all collisions, with colors updated per the neighbor count rule. No
particle overlaps occur, and all transitions follow deterministic rules:
collisions trigger mutual reflection, and recoloring is strictly based on pre-
collision adjacency to background. The task requires simultaneously tracking
particle movement, collision sequencing, and neighbor-based recoloring across a
complex network of interacting objects.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    """Generate an ARC-style input/output pair that models simple 1D horizontal
    kinetic particles that start moving right. Particles are small connected
    shapes (size 1-3). One particle is placed touching the right boundary so
    it immediately collides with the boundary and stops (ensuring at least one
    recoloring/movement event). Other particles are placed so they may later
    collide with that stopped particle (or with each other). The function then
    simulates the deterministic rules described in the task to produce the
    output grid.
    """
    # Grid size
    width = random.randint(15, 30)
    height = random.randint(15, 30)
    grid_in = grid(width, height, 0)

    # Small connected shapes (all sizes <= 3 cells) to keep perimeter counts <= 9
    SHAPES = [
        [(0, 0)],  # single cell
        [(0, 0), (0, 1)],  # horizontal domino
        [(0, 0), (1, 0)],  # vertical domino
        [(0, 0), (0, 1), (0, 2)],  # horizontal line of 3
        [(0, 0), (1, 0), (1, 1)],  # L-shape of 3
    ]

    def shape_size(shape):
        max_r = max(r for r, _ in shape)
        max_c = max(c for _, c in shape)
        return max_r + 1, max_c + 1

    # Decide how many particles (colors) to place
    total_particles = random.randint(2, min(7, 9))
    colors = random.sample(range(1, 10), total_particles)

    occupancy = set()  # occupied coordinates
    particles_info = []  # list of dicts: {'cells': set((r,c)), 'color': color}

    # Place one particle so that it touches the right boundary (guaranteed boundary collision)
    # Try several shapes until one fits.
    for _ in range(100):
        b_shape = random.choice(SHAPES)
        b_h, b_w = shape_size(b_shape)
        if b_w <= width:
            break
    # Anchor row must let the shape fit vertically
    b_row = random.randint(0, height - b_h)
    b_col = width - b_w
    b_cells = set((b_row + dr, b_col + dc) for dr, dc in b_shape)
    particles_info.append({'cells': b_cells, 'color': colors[0]})
    occupancy |= b_cells

    # Put at least one other particle in the same row (to the left) so it will later
    # interact with the boundary-stopped particle. Prefer at least one-column gap.
    placed_partner = False
    for _ in range(100):
        p_shape = random.choice(SHAPES)
        p_h, p_w = shape_size(p_shape)
        # keep same anchor row to ensure horizontal collision path
        if b_row + p_h > height:
            continue
        max_col = b_col - p_w - 1
        if max_col < 0:
            continue
        p_col = random.randint(0, max_col)
        p_row = b_row
        p_cells = set((p_row + dr, p_col + dc) for dr, dc in p_shape)
        if p_cells & occupancy:
            continue
        particles_info.append({'cells': p_cells, 'color': colors[1]})
        occupancy |= p_cells
        placed_partner = True
        break

    # If we failed to place a partner in the same row, place a simple single cell left of the boundary
    if not placed_partner:
        fallback_col = max(0, b_col - 3)
        fallback_row = b_row
        p_cells = set([(fallback_row, fallback_col)])
        # make sure it doesn't collide; otherwise pick a different row
        if p_cells & occupancy:
            # find any free place for single cell
            found = False
            for rr in range(0, height):
                for cc in range(0, width):
                    if (rr, cc) not in occupancy:
                        p_cells = set([(rr, cc)])
                        found = True
                        break
                if found:
                    break
        particles_info.append({'cells': p_cells, 'color': colors[1]})
        occupancy |= p_cells

    # Place remaining particles randomly ensuring no overlap
    color_idx = 2
    attempts = 0
    while color_idx < total_particles and attempts < 500:
        attempts += 1
        s = random.choice(SHAPES)
        sh, sw = shape_size(s)
        if sh > height or sw > width:
            continue
        r = random.randint(0, height - sh)
        c = random.randint(0, width - sw)
        cells = set((r + dr, c + dc) for dr, dc in s)
        if cells & occupancy:
            continue
        particles_info.append({'cells': cells, 'color': colors[color_idx]})
        occupancy |= cells
        color_idx += 1

    # Paint the input grid
    for p in particles_info:
        for (r, c) in p['cells']:
            grid_in[r][c] = p['color']

    # Simulation routine: uses the deterministic rules described in the task.
    def simulate(grid):
        H = len(grid)
        W = len(grid[0])

        # Identify connected components (particles) as orthogonally connected non-zero regions
        visited = set()
        particles = []  # each is dict: {'cells': set, 'color': int, 'dir': 1 or -1 or 0}
        for rr in range(H):
            for cc in range(W):
                if grid[rr][cc] == 0 or (rr, cc) in visited:
                    continue
                col = grid[rr][cc]
                stack = [(rr, cc)]
                comp = set()
                while stack:
                    xr, xc = stack.pop()
                    if (xr, xc) in visited:
                        continue
                    if grid[xr][xc] != col:
                        continue
                    visited.add((xr, xc))
                    comp.add((xr, xc))
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = xr + dr, xc + dc
                        if 0 <= nr < H and 0 <= nc < W and (nr, nc) not in visited and grid[nr][nc] == col:
                            stack.append((nr, nc))
                particles.append({'cells': comp, 'color': col, 'dir': 1})

        # Current grid state
        current_grid = [row[:] for row in grid]
        max_steps = W * 4 + len(particles) * 6

        for _step in range(max_steps):
            # Stop if no particle is moving
            if not any(p['dir'] != 0 for p in particles):
                break

            pre = [row[:] for row in current_grid]  # pre-collision snapshot

            # Current occupancy map
            curr_occ = {}
            for idx, p in enumerate(particles):
                for cell in p['cells']:
                    curr_occ[cell] = idx

            # Boundary collisions: if any target of a particle would be out of bounds,
            # that particle collides with boundary this step (stops and recolors)
            boundary = [False] * len(particles)
            for idx, p in enumerate(particles):
                if p['dir'] == 0:
                    continue
                for (r, c) in p['cells']:
                    nc = c + p['dir']
                    if nc < 0 or nc >= W:
                        boundary[idx] = True
                        break

            # Intended targets for moving (and not-boundary) particles
            targets = [set() for _ in particles]
            for idx, p in enumerate(particles):
                if p['dir'] == 0 or boundary[idx]:
                    continue
                tset = set()
                for (r, c) in p['cells']:
                    tset.add((r, c + p['dir']))
                targets[idx] = tset

            # Map target -> list of particles targeting it
            target_map = {}
            for idx, tset in enumerate(targets):
                for coord in tset:
                    target_map.setdefault(coord, []).append(idx)

            # Collision detection
            collided = [False] * len(particles)

            # 1) multiple particles targeting the same cell
            for coord, lst in target_map.items():
                if len(lst) > 1:
                    for idx in lst:
                        collided[idx] = True

            # 2) swap/head-on collisions between two moving particles
            for i in range(len(particles)):
                if particles[i]['dir'] == 0 or boundary[i] or collided[i]:
                    continue
                for j in range(i + 1, len(particles)):
                    if particles[j]['dir'] == 0 or boundary[j] or collided[j]:
                        continue
                    if targets[i] and targets[j]:
                        # if i's target intersects j's current cells and j's target intersects i's current cells
                        if any(coord in particles[j]['cells'] for coord in targets[i]) and any(coord in particles[i]['cells'] for coord in targets[j]):
                            collided[i] = True
                            collided[j] = True

            # 3) moving particle targeting a stationary (or boundary-stopping this step) cell
            for i in range(len(particles)):
                if particles[i]['dir'] == 0 or boundary[i] or collided[i]:
                    continue
                for coord in targets[i]:
                    if coord in curr_occ:
                        j = curr_occ[coord]
                        if particles[j]['dir'] == 0 or boundary[j]:
                            collided[i] = True
                            break

            # Compute recoloring counts for all particles that will recolor this step (boundary or collided)
            new_colors = {}
            for idx, p in enumerate(particles):
                if boundary[idx] or collided[idx]:
                    adj = set()
                    for (r, c) in p['cells']:
                        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                            nr, nc = r + dr, c + dc
                            if 0 <= nr < H and 0 <= nc < W and pre[nr][nc] == 0:
                                adj.add((nr, nc))
                    # clamp to 9 for safety (ARC colors 0-9)
                    new_colors[idx] = min(len(adj), 9)

            # Apply updates: collided particles reverse direction and stay in place; boundary ones stop and stay in place
            new_cells = [set(p['cells']) for p in particles]
            for idx, p in enumerate(particles):
                if boundary[idx]:
                    p['dir'] = 0
                    if idx in new_colors:
                        p['color'] = new_colors[idx]
                    new_cells[idx] = set(p['cells'])
                elif collided[idx]:
                    p['dir'] = -p['dir']
                    if idx in new_colors:
                        p['color'] = new_colors[idx]
                    new_cells[idx] = set(p['cells'])
                else:
                    # free to move
                    moved = set()
                    for (r, c) in p['cells']:
                        moved.add((r, c + p['dir']))
                    new_cells[idx] = moved

            # Rebuild the grid after the simultaneous update
            current_grid = [[0] * W for _ in range(H)]
            for idx, p in enumerate(particles):
                p['cells'] = new_cells[idx]
                for (r, c) in p['cells']:
                    current_grid[r][c] = p['color']

        return current_grid

    grid_out = simulate(grid_in)
    return {"input": grid_in, "output": grid_out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0])

    def find_components(g):
        visited = set()
        particles = []
        for rr in range(H):
            for cc in range(W):
                if g[rr][cc] == 0 or (rr, cc) in visited:
                    continue
                color = g[rr][cc]
                stack = [(rr, cc)]
                comp = set()
                while stack:
                    r, c = stack.pop()
                    if (r, c) in visited:
                        continue
                    if g[r][c] != color:
                        continue
                    visited.add((r, c))
                    comp.add((r, c))
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < H and 0 <= nc < W and (nr, nc) not in visited and g[nr][nc] == color:
                            stack.append((nr, nc))
                particles.append({'cells': comp, 'color': color, 'dir': 1})
        return particles

    particles = find_components(grid)
    current_grid = [row[:] for row in grid]
    max_steps = W * 4 + len(particles) * 6

    for _ in range(max_steps):
        if not any(p['dir'] != 0 for p in particles):
            break
        pre = [row[:] for row in current_grid]

        curr_occ = {}
        for idx, p in enumerate(particles):
            for cell in p['cells']:
                curr_occ[cell] = idx

        boundary = [False] * len(particles)
        for idx, p in enumerate(particles):
            if p['dir'] == 0:
                continue
            for (r, c) in p['cells']:
                nc = c + p['dir']
                if nc < 0 or nc >= W:
                    boundary[idx] = True
                    break

        targets = [set() for _ in particles]
        for idx, p in enumerate(particles):
            if p['dir'] == 0 or boundary[idx]:
                continue
            tset = set()
            for (r, c) in p['cells']:
                tset.add((r, c + p['dir']))
            targets[idx] = tset

        target_map = {}
        for idx, tset in enumerate(targets):
            for coord in tset:
                target_map.setdefault(coord, []).append(idx)

        collided = [False] * len(particles)
        for coord, lst in target_map.items():
            if len(lst) > 1:
                for idx in lst:
                    collided[idx] = True

        # swap detection
        for i in range(len(particles)):
            if particles[i]['dir'] == 0 or boundary[i] or collided[i]:
                continue
            for j in range(i + 1, len(particles)):
                if particles[j]['dir'] == 0 or boundary[j] or collided[j]:
                    continue
                if targets[i] and targets[j]:
                    if any(coord in particles[j]['cells'] for coord in targets[i]) and any(coord in particles[i]['cells'] for coord in targets[j]):
                        collided[i] = True
                        collided[j] = True

        for i in range(len(particles)):
            if particles[i]['dir'] == 0 or boundary[i] or collided[i]:
                continue
            for coord in targets[i]:
                if coord in curr_occ:
                    j = curr_occ[coord]
                    if particles[j]['dir'] == 0 or boundary[j]:
                        collided[i] = True
                        break

        new_colors = {}
        for idx, p in enumerate(particles):
            if boundary[idx] or collided[idx]:
                adj = set()
                for (r, c) in p['cells']:
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < H and 0 <= nc < W and pre[nr][nc] == 0:
                            adj.add((nr, nc))
                new_colors[idx] = min(len(adj), 9)

        new_cells = [set(p['cells']) for p in particles]
        for idx, p in enumerate(particles):
            if boundary[idx]:
                p['dir'] = 0
                if idx in new_colors:
                    p['color'] = new_colors[idx]
                new_cells[idx] = set(p['cells'])
            elif collided[idx]:
                p['dir'] = -p['dir']
                if idx in new_colors:
                    p['color'] = new_colors[idx]
                new_cells[idx] = set(p['cells'])
            else:
                moved = set()
                for (r, c) in p['cells']:
                    moved.add((r, c + p['dir']))
                new_cells[idx] = moved

        current_grid = [[0] * W for _ in range(H)]
        for idx, p in enumerate(particles):
            p['cells'] = new_cells[idx]
            for (r, c) in p['cells']:
                current_grid[r][c] = p['color']

    return current_grid

