# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: cbf25d16
Difficulty: hard

=== Tags ===
- Count tiles
- Measure length
- Color matching

=== Description ===
The task requires analyzing the input grid to count the number of connected
tiles (separate regions) for each color. For each tile, measure its width (the
horizontal span of its bounding box). In the output grid, any cell belonging to
a tile where the tile's width exactly matches the count of tiles for its
original color is transformed to color 9 (maroon); all other cells retain their
original input color. This rule combines counting connected components per
color, measuring geometric dimensions of tiles, and applying conditional color
replacement based on the relationship between these two properties. The
complexity arises from requiring simultaneous analysis of multiple color-
specific tile counts and per-tile geometric measurements, with the output visual
transformation being non-obvious without recognizing the equality condition
between these two metrics.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque

def generate():
    size = random.randint(5, 20)
    grid = [[0] * size for _ in range(size)]
    colors = [1, 2, 3, 4]
    random.shuffle(colors)
    
    for color in colors:
        N = random.randint(1, 3)
        create_good = random.choice([True, False])
        for i in range(N):
            width = N if (create_good or i < N-1) else N+1
            row = i * 2
            col_start = 0
            if row >= size:
                row = size - 1
            if col_start + width > size:
                col_start = size - width
            for j in range(width):
                grid[row][col_start + j] = color
    
    output = [row[:] for row in grid]
    colors_present = set()
    for row in grid:
        for cell in row:
            if cell != 0:
                colors_present.add(cell)
    
    for color in colors_present:
        pixels = []
        for r in range(size):
            for c in range(size):
                if grid[r][c] == color:
                    pixels.append((r, c))
        
        if not pixels:
            continue
        
        visited = set()
        components = []
        for pixel in pixels:
            if pixel not in visited:
                component = []
                queue = deque([pixel])
                visited.add(pixel)
                while queue:
                    r, c = queue.popleft()
                    component.append((r, c))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < size and 0 <= nc < size and grid[nr][nc] == color and (nr, nc) not in visited:
                            visited.add((nr, nc))
                            queue.append((nr, nc))
                components.append(component)
        
        N_count = len(components)
        for component in components:
            cols = [c for r, c in component]
            min_col = min(cols)
            max_col = max(cols)
            width = max_col - min_col + 1
            if width == N_count:
                for r, c in component:
                    output[r][c] = 9
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random
from collections import deque

def p(input_grid):
    size = len(input_grid)
    output = [list(row) for row in input_grid]
    colors_present = set()
    for row in input_grid:
        for cell in row:
            if cell != 0:
                colors_present.add(cell)
    
    for color in colors_present:
        pixels = []
        for r in range(size):
            for c in range(size):
                if input_grid[r][c] == color:
                    pixels.append((r, c))
        if not pixels:
            continue
        
        visited = set()
        components = []
        for pixel in pixels:
            if pixel not in visited:
                component = []
                queue = deque([pixel])
                visited.add(pixel)
                while queue:
                    r, c = queue.popleft()
                    component.append((r, c))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < size and 0 <= nc < size and input_grid[nr][nc] == color and (nr, nc) not in visited:
                            visited.add((nr, nc))
                            queue.append((nr, nc))
                components.append(component)
        
        N_count = len(components)
        for component in components:
            cols = [c for r, c in component]
            min_col = min(cols)
            max_col = max(cols)
            width = max_col - min_col + 1
            if width == N_count:
                for r, c in component:
                    output[r][c] = 9
    return output
