# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 713f49d9
Difficulty: medium–hard

=== Tags ===
- Example condition induction
- Oscillating rule
- Directed cave maze

=== Description ===
The input grids depict a cave-like structure where non-zero colors represent
walls and background (0) represents open cave passages. The cave is a single
connected region surrounded by walls, containing exactly one starting cell
marked with a unique color (e.g., red). The output grid transforms the input by
drawing a path through the cave that begins at the starting cell and follows an
alternating direction sequence: horizontal (left/right) followed by vertical
(up/down), repeating this pattern indefinitely while moving through background
cells. Each step in the path is drawn in a distinct color (e.g., blue), skipping
over walls and existing path cells. The path continues until no further valid
move in the current direction can be made without overlapping walls or exiting
the grid. The transformation requires recognizing the oscillating direction
pattern (horizontal → vertical → horizontal → vertical) from the input-output
examples, applying it sequentially, and drawing the path while respecting grid
boundaries and wall constraints. The output retains all input walls and
background but adds the oscillating path, creating a visually distinct maze
traversal that demonstrates the induced rule.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    # Create a cave-like connected region of zeros surrounded by walls (1).
    # Ensure there's exactly one start cell (2) inside the cave and that at least
    # one horizontal move is possible from the start so the path will be drawn.
    max_tries = 60
    for attempt in range(max_tries):
        width = random.randint(6, 20)
        height = random.randint(6, 20)
        # interior cells where caves may be carved
        if width < 3 or height < 3:
            continue
        max_interior = (width - 2) * (height - 2)
        if max_interior < 2:
            continue
        cave_size = random.randint(3, max(3, max_interior))

        # start carving the cave via randomized frontier growth to ensure connectivity
        start_r = random.randint(1, height - 2)
        start_c = random.randint(1, width - 2)
        cave = set()
        cave.add((start_r, start_c))
        frontier = set()
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = start_r + dr, start_c + dc
            if 1 <= nr <= height - 2 and 1 <= nc <= width - 2:
                frontier.add((nr, nc))
        while len(cave) < cave_size and frontier:
            cell = random.choice(tuple(frontier))
            frontier.remove(cell)
            cave.add(cell)
            r, c = cell
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = r + dr, c + dc
                if 1 <= nr <= height - 2 and 1 <= nc <= width - 2:
                    if (nr, nc) not in cave and (nr, nc) not in frontier:
                        frontier.add((nr, nc))

        if len(cave) < 2:
            continue

        # Prefer a start cell that has at least one horizontal neighbor inside the cave
        horizontal_candidates = [cell for cell in cave if ((cell[0], cell[1] + 1) in cave or (cell[0], cell[1] - 1) in cave)]
        if not horizontal_candidates:
            # If none found, try again to generate a cave with some horizontal adjacency
            continue

        start = random.choice(horizontal_candidates)

        # Build input grid: walls = 1, background (cave) = 0, start = 2
        grid_in = common.grid(width, height, 1)
        for (r, c) in cave:
            grid_in[r][c] = 0
        sr, sc = start
        grid_in[sr][sc] = 2

        # Build output by drawing the oscillating path starting with horizontal move
        grid_out = [row[:] for row in grid_in]
        current_r, current_c = sr, sc
        direction = 0  # 0 -> horizontal, 1 -> vertical
        path_color = 3

        # The movement checks both the original grid and the growing output so the path
        # never overlaps walls, the start cell, or previously drawn path cells.
        while True:
            moved = False
            if direction == 0:
                # try right first
                steps = []
                nc = current_c + 1
                while nc < width and grid_in[current_r][nc] == 0 and grid_out[current_r][nc] == 0:
                    steps.append((current_r, nc))
                    nc += 1
                if steps:
                    for r, c in steps:
                        grid_out[r][c] = path_color
                    current_r, current_c = steps[-1]
                    moved = True
                else:
                    # try left
                    steps = []
                    nc = current_c - 1
                    while nc >= 0 and grid_in[current_r][nc] == 0 and grid_out[current_r][nc] == 0:
                        steps.append((current_r, nc))
                        nc -= 1
                    if steps:
                        for r, c in steps:
                            grid_out[r][c] = path_color
                        current_r, current_c = steps[-1]
                        moved = True
            else:
                # vertical: try down first
                steps = []
                nr = current_r + 1
                while nr < height and grid_in[nr][current_c] == 0 and grid_out[nr][current_c] == 0:
                    steps.append((nr, current_c))
                    nr += 1
                if steps:
                    for r, c in steps:
                        grid_out[r][c] = path_color
                    current_r, current_c = steps[-1]
                    moved = True
                else:
                    # try up
                    steps = []
                    nr = current_r - 1
                    while nr >= 0 and grid_in[nr][current_c] == 0 and grid_out[nr][current_c] == 0:
                        steps.append((nr, current_c))
                        nr -= 1
                    if steps:
                        for r, c in steps:
                            grid_out[r][c] = path_color
                        current_r, current_c = steps[-1]
                        moved = True

            if not moved:
                break
            direction = 1 - direction

        # Ensure the output differs from the input (we drew at least one cell)
        if grid_out != grid_in:
            return {"input": grid_in, "output": grid_out}
    # Fallback (very unlikely): create a tiny valid example
    width, height = 6, 6
    grid_in = common.grid(width, height, 1)
    cave = {(2, 2), (2, 3), (3, 3)}
    for r, c in cave:
        grid_in[r][c] = 0
    grid_in[2][2] = 2
    grid_out = [row[:] for row in grid_in]
    grid_out[2][3] = 3
    return {"input": grid_in, "output": grid_out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable list-of-lists
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0]) if height > 0 else 0

    # Find the unique start cell (value 2)
    start_r = start_c = None
    for r in range(height):
        for c in range(width):
            if grid_in[r][c] == 2:
                start_r, start_c = r, c
                break
        if start_r is not None:
            break
    if start_r is None:
        return grid_in

    # Prepare output and perform the same oscillating traversal as the generator
    grid_out = [row[:] for row in grid_in]
    current_r, current_c = start_r, start_c
    direction = 0  # 0 horizontal first, then vertical
    path_color = 3

    while True:
        moved = False
        if direction == 0:
            # try right
            steps = []
            nc = current_c + 1
            while nc < width and grid_in[current_r][nc] == 0 and grid_out[current_r][nc] == 0:
                steps.append((current_r, nc))
                nc += 1
            if steps:
                for r, c in steps:
                    grid_out[r][c] = path_color
                current_r, current_c = steps[-1]
                moved = True
            else:
                # try left
                steps = []
                nc = current_c - 1
                while nc >= 0 and grid_in[current_r][nc] == 0 and grid_out[current_r][nc] == 0:
                    steps.append((current_r, nc))
                    nc -= 1
                if steps:
                    for r, c in steps:
                        grid_out[r][c] = path_color
                    current_r, current_c = steps[-1]
                    moved = True
        else:
            # vertical: try down
            steps = []
            nr = current_r + 1
            while nr < height and grid_in[nr][current_c] == 0 and grid_out[nr][current_c] == 0:
                steps.append((nr, current_c))
                nr += 1
            if steps:
                for r, c in steps:
                    grid_out[r][c] = path_color
                current_r, current_c = steps[-1]
                moved = True
            else:
                # try up
                steps = []
                nr = current_r - 1
                while nr >= 0 and grid_in[nr][current_c] == 0 and grid_out[nr][current_c] == 0:
                    steps.append((nr, current_c))
                    nr -= 1
                if steps:
                    for r, c in steps:
                        grid_out[r][c] = path_color
                    current_r, current_c = steps[-1]
                    moved = True

        if not moved:
            break
        direction = 1 - direction

    return grid_out

