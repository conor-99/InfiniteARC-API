# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: e5a8434e
Difficulty: hard

=== Tags ===
- Obstacles

=== Description ===
The input grid consists of a 2D arrangement of colored cells, where a specific
color (e.g., red) represents obstacles, and other colors represent empty or
background cells. The task requires identifying all regions completely enclosed
by obstacles—areas not connected to the grid's edges through empty cells—and
filling these regions with a new color (e.g., blue). Obstacles remain unchanged,
and empty cells connected to the grid's edges retain their original color. The
transformation involves detecting enclosed regions using connectivity analysis
(e.g., flood fill from grid edges), which requires recognizing complex obstacle
patterns that form closed loops or barriers. Input grids feature intricate
obstacle configurations with multiple nested or isolated enclosed regions,
demanding sequential reasoning to distinguish enclosed areas from accessible
ones. The output grid must precisely fill all such enclosed regions while
preserving obstacle boundaries and edge-connected empty spaces. This rule is
purely visual, relying on spatial relationships rather than numerical
properties, and scales in complexity with the number and arrangement of
obstacles.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = common.grid(width, height, 0)
    
    # Random obstacle rectangle dimensions
    obstacle_w = random.randint(3, min(width, height) - 2)
    obstacle_h = random.randint(3, min(width, height) - 2)
    
    # Position to place the obstacle
    x = random.randint(1, height - obstacle_h - 1)
    y = random.randint(1, width - obstacle_w - 1)
    
    # Fill outline
    # Top row
    for c in range(y, y + obstacle_w):
        grid[x][c] = 2
    # Bottom row
    for c in range(y, y + obstacle_w):
        grid[x + obstacle_h - 1][c] = 2
    # Left column
    for r in range(x + 1, x + obstacle_h - 1):
        grid[r][y] = 2
    # Right column
    for r in range(x + 1, x + obstacle_h - 1):
        grid[r][y + obstacle_w - 1] = 2
    
    # Fill exterior with random colors (1-9, not 2)
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0:  # empty cell
                # Check if inside the obstacle rectangle
                if x < r < x + obstacle_h - 1 and y < c < y + obstacle_w - 1:
                    continue  # interior, leave as 0
                else:
                    # Exterior, fill with random color
                    grid[r][c] = common.random_color(exclude=[2])
    
    # Output: fill interior (enclosed regions) with 3
    output = [row[:] for row in grid]
    for r in range(x + 1, x + obstacle_h - 1):
        for c in range(y + 1, y + obstacle_w - 1):
            output[r][c] = 3
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to list of lists if it's a tuple
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    obstacle = 2
    visited = [[False] * width for _ in range(height)]
    from collections import deque
    queue = deque()
    
    # Mark all edge-connected empty cells
    for r in range(height):
        for c in range(width):
            if r == 0 or r == height - 1 or c == 0 or c == width - 1:
                if input_grid[r][c] != obstacle:
                    queue.append((r, c))
                    visited[r][c] = True
    
    # BFS
    while queue:
        r, c = queue.popleft()
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] != obstacle:
                visited[nr][nc] = True
                queue.append((nr, nc))
    
    # Create output grid
    output = [list(row) for row in input_grid]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != obstacle and not visited[r][c]:
                output[r][c] = 3
    
    return output
