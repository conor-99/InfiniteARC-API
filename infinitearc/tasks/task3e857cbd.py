# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 3e857cbd
Difficulty: medium

=== Tags ===
- Inside out
- Normalize orientation
- Detect grid
- Move object based on arrow

=== Description ===
The task involves a grid containing a hidden 3×3 subgrid of non-zero values
embedded within a larger grid. The subgrid's cells contain colors where specific
values (2–5) represent directional arrows (right, up, left, down), and other
values (6–9) represent movable objects. To solve the task:  1. **Detect the
grid**: Identify the smallest contiguous 3×3 square block of non-zero cells as
the target subgrid. 2. **Normalize orientation**: Rotate the subgrid until the
arrow in its top-left cell points upward (e.g., if the top-left cell contains a
right arrow, rotate the subgrid 90° counterclockwise). 3. **Apply "inside
out"**: Reverse the order of the subgrid's rows (e.g., row 0 becomes row 2). 4.
**Move objects**: Shift each object (colors 6–9) within the subgrid to the
adjacent cell in the direction indicated by the arrow (colors 2–5) in its
original cell. If movement would exit the subgrid, the object remains in place.
The output grid replaces the original subgrid with its transformed version while
preserving all other grid elements. This requires recognizing directional color
patterns, spatial transformations, and sequential rule application.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    input_grid = [[0] * width for _ in range(height)]
    r = random.randint(0, height - 3)
    c = random.randint(0, width - 3)
    for i in range(3):
        for j in range(3):
            if i == 0 and j == 0:
                val = random.choice([2, 3, 4, 5])
            else:
                val = random.choice([2, 3, 4, 5, 6, 7, 8, 9])
            input_grid[r + i][c + j] = val
    output_grid = [row[:] for row in input_grid]
    sub = [input_grid[r + i][c:c + 3] for i in range(3)]
    top_left = sub[0][0]
    if top_left == 2:
        sub = list(zip(*sub))[::-1]
    elif top_left == 4:
        sub = list(zip(*sub))
        sub = [row[::-1] for row in sub]
    elif top_left == 5:
        sub = [row[::-1] for row in sub][::-1]
    sub = sub[::-1]
    for i in range(3):
        for j in range(3):
            output_grid[r + i][c + j] = sub[i][j]
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    for r in range(height - 2):
        for c in range(width - 2):
            if all(input_grid[r + i][c + j] != 0 for i in range(3) for j in range(3)):
                sub = [input_grid[r + i][c:c + 3] for i in range(3)]
                top_left = sub[0][0]
                if top_left == 2:
                    sub = list(zip(*sub))[::-1]
                elif top_left == 4:
                    sub = list(zip(*sub))
                    sub = [row[::-1] for row in sub]
                elif top_left == 5:
                    sub = [row[::-1] for row in sub][::-1]
                sub = sub[::-1]
                for i in range(3):
                    for j in range(3):
                        input_grid[r + i][c + j] = sub[i][j]
                return input_grid
    return input_grid
