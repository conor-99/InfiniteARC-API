# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: f2f27a8b
Difficulty: insane

=== Tags ===
- Local rule cascade
- Infer hidden grid

=== Description ===
# Task Description  Input grids are 25×25 with a background color (0). They
contain multiple contiguous colored regions (1-9), each forming a distinct
geometric shape (e.g., circle, square, triangle). Three anchor regions are
fixed: a square at top-left (color 2), a triangle at top-right (color 1), and a
circle at bottom-left (color 3). The hidden grid is a 3×3 grid that is inferred
by observing the relative positions of color regions around the anchors.
Specifically, the color of the region immediately clockwise from each anchor
(along the grid's perimeter) defines the hidden grid's rows. For example, the
region clockwise from the top-left square (color 2) forms the first hidden grid
row, the region clockwise from the top-right triangle (color 1) forms the second
row, and the region clockwise from the bottom-left circle (color 3) forms the
third row.  The transformation applies a local rule cascade: For each cell (i,j)
in the output, the color is determined by the hidden grid's value at (i mod 3, j
mod 3). If the hidden grid cell is a color, it replaces the input color. If it's
a direction (encoded as a color), the input color is shifted in that direction
(e.g., color 4 = right, color 5 = up), but only if the target cell is
background. Shifts are applied in sequence from top-left to bottom-right,
ensuring no overlaps. The output grid must maintain the anchor regions' shapes
and positions while transforming all other cells according to the cascade. This
requires inferring the hidden grid through visual pattern recognition of
clockwise regions, making the task "insane" due to the multi-step inference and
cascading transformations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid


def generate():
    size = 25
    input_grid = grid(size, size, 0)
    
    # Place anchor regions
    for r in range(3):
        for c in range(3):
            input_grid[r][c] = 2  # Top-left square (color 2)
    
    for r in range(3):
        for c in range(22 + r, 25):
            input_grid[r][c] = 1  # Top-right triangle (color 1)
    
    for r in range(22, 25):
        for c in range(0, 3):
            if (r - 22) + (c) < 3:
                input_grid[r][c] = 3  # Bottom-left circle (color 3)
    
    # Use direction colors (4-7) for hidden grid
    colors = [4, 5, 6, 7]
    C0, C1, C2 = random.sample(colors, 3)
    
    # Place perimeter regions
    for c in range(3, 6):
        input_grid[0][c] = C0  # Top edge
    for r in range(3, 6):
        input_grid[r][24] = C1  # Right edge
    for c in range(3, 6):
        input_grid[24][c] = C2  # Bottom edge
    
    # Add additional non-anchor regions (manual horizontal lines)
    for _ in range(3):
        size_region = random.randint(3, 5)
        color = random.choice([4,5,6,7])
        r = random.randint(5, 20)
        c_start = random.randint(5, 20)
        for c in range(c_start, c_start + size_region):
            if c < 25 and input_grid[r][c] == 0:
                input_grid[r][c] = color
    
    # Create hidden grid (all directions)
    hidden = [
        [C0, C0, C0],
        [C1, C1, C1],
        [C2, C2, C2]
    ]
    
    # Generate output
    output_grid = [row[:] for row in input_grid]
    for r in range(size):
        for c in range(size):
            if (r < 3 and c < 3 and input_grid[r][c] == 2) or \
               (r < 3 and c >= 22 and input_grid[r][c] == 1) or \
               (r >= 22 and c < 3 and input_grid[r][c] == 3):
                continue
            h = hidden[r % 3][c % 3]
            dr, dc = 0, 0
            if h == 4: dc = 1
            elif h == 5: dr = -1
            elif h == 6: dc = -1
            elif h == 7: dr = 1
            nr, nc = r + dr, c + dc
            if 0 <= nr < size and 0 <= nc < size and input_grid[nr][nc] == 0:
                output_grid[nr][nc] = input_grid[r][c]
                output_grid[r][c] = 0
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    size = len(input_grid)
    
    C0 = input_grid[0][3]
    C1 = input_grid[3][24]
    C2 = input_grid[24][3]
    
    hidden = [
        [C0, C0, C0],
        [C1, C1, C1],
        [C2, C2, C2]
    ]
    
    output_grid = [row[:] for row in input_grid]
    for r in range(size):
        for c in range(size):
            if (r < 3 and c < 3 and input_grid[r][c] == 2) or \
               (r < 3 and c >= 22 and input_grid[r][c] == 1) or \
               (r >= 22 and c < 3 and input_grid[r][c] == 3):
                continue
            h = hidden[r % 3][c % 3]
            dr, dc = 0, 0
            if h == 4: dc = 1
            elif h == 5: dr = -1
            elif h == 6: dc = -1
            elif h == 7: dr = 1
            nr, nc = r + dr, c + dc
            if 0 <= nr < size and 0 <= nc < size and input_grid[nr][nc] == 0:
                output_grid[nr][nc] = input_grid[r][c]
                output_grid[r][c] = 0
    return output_grid
