# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: a052dbf8
Difficulty: medium–hard

=== Tags ===
- Color clock
- Reactive surface
- Color particle fall
- Repulsion and bounce
- Color guessing
- Swap rows

=== Description ===
The task features grids with a background color (0) and a horizontal reactive
surface spanning all columns at a fixed row. Above the surface, the grid
contains particles (colors 1–9) positioned in individual cells. Each particle
falls downward one row per step, incrementing its color cyclically (1→2→3→…→9→1)
as it moves. Upon collision with the reactive surface, the particle's current
color is compared to the surface's color: if equal, the particle bounces upward
to the row directly above the surface; if unequal, the surface color cycles to
the next color in the sequence (1→2→…→9→1), and the particle remains on the
surface. After all particles are processed (in top-to-bottom, left-to-right
order), the grid is updated to reflect bounced particles and the final surface
color. Finally, the grid undergoes a row swap based on the parity of the final
surface color: if even, swap the top two rows; if odd, swap the third and fourth
rows. The transformation requires tracking dynamic color changes during particle
descent, deterministic surface interactions, and conditional row rearrangement,
all while maintaining visual consistency without relying on numerical
computations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    surface_row = random.randint(1, height-1)
    surface_color = random.randint(1, 9)
    
    input_grid = [[0] * width for _ in range(height)]
    for c in range(width):
        input_grid[surface_row][c] = surface_color
    
    particles = []
    for r in range(surface_row):
        for c in range(width):
            if random.random() < 0.3:
                color = random.randint(1, 9)
                input_grid[r][c] = color
                particles.append((r, c, color))
    if not particles:
        r = random.randint(0, surface_row-1)
        c = random.randint(0, width-1)
        color = random.randint(1, 9)
        input_grid[r][c] = color
        particles.append((r, c, color))
    
    output_grid = [row[:] for row in input_grid]
    current_surface = surface_color
    particles.sort(key=lambda x: (x[0], x[1]))
    
    for r, c, color in particles:
        steps = surface_row - r
        current_color = (color + steps - 1) % 9 + 1
        if current_color == current_surface:
            output_grid[surface_row][c] = 0
            output_grid[surface_row-1][c] = current_color
            output_grid[r][c] = 0
        else:
            current_surface = (current_surface % 9) + 1
    
    for c in range(width):
        output_grid[surface_row][c] = current_surface
    
    if current_surface % 2 == 0:
        if height >= 2:
            output_grid[0], output_grid[1] = output_grid[1], output_grid[0]
    else:
        if height >= 4:
            output_grid[2], output_grid[3] = output_grid[3], output_grid[2]
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    surface_row = None
    for r in range(height):
        if all(x == grid[r][0] for x in grid[r]) and grid[r][0] != 0:
            surface_row = r
            break
    if surface_row is None:
        surface_row = height // 2
    
    surface_color = grid[surface_row][0]
    particles = []
    for r in range(surface_row):
        for c in range(width):
            if grid[r][c] != 0:
                particles.append((r, c, grid[r][c]))
    
    particles.sort(key=lambda x: (x[0], x[1]))
    current_surface = surface_color
    output_grid = [row[:] for row in grid]
    
    for r, c, color in particles:
        steps = surface_row - r
        current_color = (color + steps - 1) % 9 + 1
        if current_color == current_surface:
            output_grid[surface_row][c] = 0
            output_grid[surface_row-1][c] = current_color
            output_grid[r][c] = 0
        else:
            current_surface = (current_surface % 9) + 1
    
    for c in range(width):
        output_grid[surface_row][c] = current_surface
    
    if current_surface % 2 == 0:
        if height >= 2:
            output_grid[0], output_grid[1] = output_grid[1], output_grid[0]
    else:
        if height >= 4:
            output_grid[2], output_grid[3] = output_grid[3], output_grid[2]
    
    return tuple(tuple(row) for row in output_grid)
