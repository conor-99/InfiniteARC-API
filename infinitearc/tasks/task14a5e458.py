# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 14a5e458
Difficulty: hard

=== Tags ===
- Conditional symmetry

=== Description ===
The task involves transforming an input grid into an output grid where each
connected region of non-zero color undergoes a symmetry transformation based on
its specific color. For regions colored red (value 2), the grid is mirrored
vertically (left-right reflection) within their bounding boxes. For regions
colored blue (value 1), the grid is mirrored horizontally (top-bottom
reflection). For regions colored green (value 3), the grid is mirrored along the
main diagonal (top-left to bottom-right). All other non-zero colors remain
unchanged. The output grid is constructed by applying these conditional
symmetries to each connected region while maintaining the background (value 0)
in all other areas. This requires identifying connected components, determining
their color-based symmetry rule, and applying the transformation within each
region's boundsâ€”combining multiple visual reasoning steps to derive the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, connected

def generate():
    width = random.randint(5, 20)
    height = random.randint(5, 20)
    input_grid = grid(width, height, 0)
    
    def is_symmetric_horizontal(pixels, height):
        for r, c in pixels:
            if (height - 1 - r, c) not in pixels:
                return False
        return True

    def is_symmetric_vertical(pixels, width):
        for r, c in pixels:
            if (r, width - 1 - c) not in pixels:
                return False
        return True

    def is_symmetric_diagonal(pixels):
        for r, c in pixels:
            if (c, r) not in pixels:
                return False
        return True

    colors = [1, 2, 3]
    for color in colors:
        size = random.randint(3, 5)
        pixels = []
        while len(pixels) < size:
            r, c = random.randint(0, height-1), random.randint(0, width-1)
            if input_grid[r][c] != 0:
                continue
            input_grid[r][c] = color
            pixels.append((r, c))
        
        if not connected(pixels):
            continue
        
        if color == 1 and is_symmetric_horizontal(pixels, height):
            for r, c in pixels:
                if (height - 1 - r, c) in pixels:
                    input_grid[r][c] = 0
                    pixels.remove((r, c))
                    break
        elif color == 2 and is_symmetric_vertical(pixels, width):
            for r, c in pixels:
                if (r, width - 1 - c) in pixels:
                    input_grid[r][c] = 0
                    pixels.remove((r, c))
                    break
        elif color == 3 and is_symmetric_diagonal(pixels):
            for r, c in pixels:
                if (c, r) in pixels:
                    input_grid[r][c] = 0
                    pixels.remove((r, c))
                    break
        
    output_grid = [row[:] for row in input_grid]
    
    for color in [1, 2, 3]:
        comp = []
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == color:
                    comp.append((r, c))
        if not comp:
            continue
        min_r, max_r = min(r for r, c in comp), max(r for r, c in comp)
        min_c, max_c = min(c for r, c in comp), max(c for r, c in comp)
        for r, c in comp:
            if color == 1:
                r_new = min_r + max_r - r
                c_new = c
            elif color == 2:
                r_new = r
                c_new = min_c + max_c - c
            elif color == 3:
                r_new = min_r + (c - min_c)
                c_new = min_c + (r - min_r)
                r_new = max(min_r, min(max_r, r_new))
                c_new = max(min_c, min(max_c, c_new))
            output_grid[r_new][c_new] = input_grid[r][c]
    
    if output_grid == input_grid:
        return generate()
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Ensure input_grid is a list of lists
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = [row[:] for row in input_grid]
    
    for color in [1, 2, 3]:
        comp = []
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == color:
                    comp.append((r, c))
        if not comp:
            continue
        min_r, max_r = min(r for r, c in comp), max(r for r, c in comp)
        min_c, max_c = min(c for r, c in comp), max(c for r, c in comp)
        for r, c in comp:
            if color == 1:
                r_new = min_r + max_r - r
                c_new = c
            elif color == 2:
                r_new = r
                c_new = min_c + max_c - c
            elif color == 3:
                r_new = min_r + (c - min_c)
                c_new = min_c + (r - min_r)
                r_new = max(min_r, min(max_r, r_new))
                c_new = max(min_c, min(max_c, c_new))
            output_grid[r_new][c_new] = input_grid[r][c]
    return output_grid
