# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 14faa358
Difficulty: very hard

=== Tags ===
- Cyclic coloring
- Color carving
- Trail memory
- Agent memory trace
- Algebra
- Image within image

=== Description ===
# Task Description: Cyclic Path Carving  Input grids are 20×20 matrices with
background color 0. Within the grid, a 5×5 subgrid (the "inner image") is
positioned at coordinates (5,5) to (9,9). This inner image contains a distinct
pattern formed by non-zero colors (1-9) on a 0 background, representing a
recognizable visual structure (e.g., a geometric shape or symbol). The grid also
contains a single agent marker at the top-left corner of the inner image
(position 5,5), which is initially on a background cell (0).  The transformation
requires simulating the agent's path through the inner image, where: - The agent
begins facing right. - Each movement step occurs in the current direction until
the agent encounters a non-background cell (color 1-9) within the inner image. -
Upon entering a non-background cell, the agent changes direction based on a
fixed color-to-direction mapping: color 1→right, 2→left, 3→right, 4→left,
5→right, 6→right, 7→left, 8→right, 9→left. - The agent's path is drawn using a
cyclic color sequence (starting at 1, incrementing by 1 per step, cycling
through 1-9), replacing the background (0) with the current cycle color at each
visited cell. - The process continues until the agent exits the inner image
boundaries (reaches row 4 or 10, column 4 or 10) or encounters a cell where no
valid direction change exists (though the inner image is designed to avoid
infinite loops). - The outer grid (outside the 5×5 inner image) remains
unchanged in the output.  The output grid retains the original background and
inner image structure but replaces all cells along the agent's path with the
cyclic color sequence, creating a "carved" trail that visually traces the
agent's memory trace through the image. The transformation requires simultaneous
tracking of the agent's position, direction, and cycle-based coloring while
respecting the inner image's structure as both a constraint and guide for
directional changes. The task demands recognizing the nested visual structure
(inner image within outer grid), applying a sequence of context-sensitive color
transformations, and maintaining precise path memory to generate the correct
output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    input_grid = [[0] * 20 for _ in range(20)]
    inner = [[0] * 5 for _ in range(5)]
    r_pos = random.randint(0, 4)
    c_pos = random.randint(0, 4)
    if r_pos == 0 and c_pos == 0:
        c_pos = (c_pos + 1) % 5
    color_val = random.randint(1, 9)
    inner[r_pos][c_pos] = color_val
    
    current_r, current_c = 0, 0
    direction = 'right'
    path = [(0, 0)]
    cycle_color = 2
    max_steps = 100
    while max_steps > 0:
        max_steps -= 1
        if direction == 'right':
            next_r, next_c = current_r, current_c + 1
        else:
            next_r, next_c = current_r, current_c - 1
        
        if next_r < 0 or next_r >= 5 or next_c < 0 or next_c >= 5:
            break
        
        if inner[next_r][next_c] != 0:
            color = inner[next_r][next_c]
            new_direction = 'right' if color in [1, 3, 5, 6, 8] else 'left'
            direction = new_direction
        else:
            current_r, current_c = next_r, next_c
            path.append((current_r, current_c))
            cycle_color = (cycle_color % 9) + 1

    for r in range(5):
        for c in range(5):
            input_grid[5 + r][5 + c] = inner[r][c]
    
    output_grid = [row[:] for row in input_grid]
    cycle_color = 1
    for r, c in path:
        output_grid[5 + r][5 + c] = cycle_color
        cycle_color = (cycle_color % 9) + 1
    
    return {
        'input': input_grid,
        'output': output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    inner_size = 5
    inner = [[grid[5 + r][5 + c] for c in range(inner_size)] for r in range(inner_size)]
    
    current_r, current_c = 0, 0
    direction = 'right'
    path = [(0, 0)]
    cycle_color = 2
    max_steps = 100
    while max_steps > 0:
        max_steps -= 1
        if direction == 'right':
            next_r, next_c = current_r, current_c + 1
        else:
            next_r, next_c = current_r, current_c - 1
        
        if next_r < 0 or next_r >= inner_size or next_c < 0 or next_c >= inner_size:
            break
        
        if inner[next_r][next_c] != 0:
            color = inner[next_r][next_c]
            new_direction = 'right' if color in [1, 3, 5, 6, 8] else 'left'
            direction = new_direction
        else:
            current_r, current_c = next_r, next_c
            path.append((current_r, current_c))
            cycle_color = (cycle_color % 9) + 1

    cycle_color = 1  # Reset to 1 for output
    for r, c in path:
        grid[5 + r][5 + c] = cycle_color
        cycle_color = (cycle_color % 9) + 1
    
    return grid
