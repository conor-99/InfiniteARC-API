# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 435cf193
Difficulty: very hard

=== Tags ===
- Tile mutation rule
- Color signal exchange
- Procedural painting
- Cave escape
- Permute rows by length
- Take minimum

=== Description ===
Input grids depict intricate cave systems with a background (value 0), solid
walls (value 1), and interconnected colored pathways (values 2–9). The cave
contains a designated start point (color 2) and exit point (color 3), both
located within pathway regions. Pathways form contiguous regions of non-
background cells surrounded by walls or grid boundaries.   The transformation
sequence is as follows:   1. **Tile Mutation Rule**: Each pathway cell (color
>1) updates its color to the most frequent orthogonal neighbor color (excluding
walls and background). Ties are resolved by selecting the smallest color value.
2. **Color Signal Exchange**: Adjacent pathway cells with complementary color
pairs (e.g., 2 ↔ 8, 3 ↔ 7, 4 ↔ 6) swap colors iteratively until no more
complementary pairs exist.   3. **Procedural Painting**: All connected regions
of color 5 (after mutation/exchange) are repainted as color 4 via flood-fill.
4. **Cave Escape**: The pathway from start (color 2) to exit (color 3) becomes
unobstructed, with any blocking walls (color 1) removed and replaced to maintain
pathway continuity (color 2).   5. **Permute Rows by Length**: Rows are sorted
in descending order based on the count of non-background cells (including walls
and pathways).   6. **Take Minimum**: For each row, replace all cells with the
smallest non-zero color value present (ignoring background 0).    The output
grid reflects all transformations, resulting in a visually coherent cave
structure with a clear escape path, rows reordered by pathway density, and each
row homogenized to its minimum pathway color.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque

ORTH = [(1,0),(-1,0),(0,1),(0,-1)]


def _make_contiguous(size, w, h):
    """
    Robust contiguous growth that finishes quickly.
    """
    size = min(size, w * h)
    for attempt in range(20):
        pixels = []
        seed_r = random.randint(0, h - 1)
        seed_c = random.randint(0, w - 1)
        pixels.append((seed_r, seed_c))
        tries = 0
        while len(pixels) < size and tries < size * 6:
            tries += 1
            pr, pc = random.choice(pixels)
            neighbors = []
            for dr, dc in ORTH:
                nr, nc = pr + dr, pc + dc
                if 0 <= nr < h and 0 <= nc < w and (nr, nc) not in pixels:
                    neighbors.append((nr, nc))
            if not neighbors:
                continue
            pixels.append(random.choice(neighbors))
        if len(pixels) == size:
            return pixels
    # fallback deterministic fill
    pixels = []
    for r in range(h):
        for c in range(w):
            if len(pixels) < size:
                pixels.append((r, c))
    return pixels


def _transform_grid(ingrid):
    grid = [row[:] for row in ingrid]
    h = len(grid)
    w = len(grid[0])

    # Step 1: Tile Mutation Rule (simultaneous update), anchor start(2) and exit(3)
    original = [row[:] for row in grid]
    mutated = [row[:] for row in grid]
    for r in range(h):
        for c in range(w):
            v = original[r][c]
            if v <= 1 or v in (2, 3):
                continue
            neighbor_colors = []
            for dr, dc in ORTH:
                nr, nc = r + dr, c + dc
                if 0 <= nr < h and 0 <= nc < w:
                    nv = original[nr][nc]
                    if nv > 1:
                        neighbor_colors.append(nv)
            if neighbor_colors:
                counts = {}
                for col in neighbor_colors:
                    counts[col] = counts.get(col, 0) + 1
                max_count = max(counts.values())
                candidates = [col for col, cnt in counts.items() if cnt == max_count]
                mutated[r][c] = min(candidates)
    grid = mutated

    # Step 2: Color Signal Exchange with bounded passes
    complementary = {(2,8),(8,2),(3,7),(7,3),(4,6),(6,4)}
    swapped = True
    passes = 0
    max_passes = max(8, h * w * 2)
    while swapped and passes < max_passes:
        passes += 1
        swapped = False
        swapped_cells = set()
        for r in range(h):
            for c in range(w):
                if grid[r][c] <= 1 or (r, c) in swapped_cells:
                    continue
                if c + 1 < w and grid[r][c+1] > 1 and (r, c+1) not in swapped_cells:
                    a, b = grid[r][c], grid[r][c+1]
                    if (a, b) in complementary and a not in (2, 3) and b not in (2, 3):
                        grid[r][c], grid[r][c+1] = b, a
                        swapped_cells.update({(r, c), (r, c+1)})
                        swapped = True
                        continue
                if r + 1 < h and grid[r+1][c] > 1 and (r+1, c) not in swapped_cells:
                    a, b = grid[r][c], grid[r+1][c]
                    if (a, b) in complementary and a not in (2, 3) and b not in (2, 3):
                        grid[r][c], grid[r+1][c] = b, a
                        swapped_cells.update({(r, c), (r+1, c)})
                        swapped = True

    # Step 3: Procedural Painting: flood-fill 5 -> 4
    for r in range(h):
        for c in range(w):
            if grid[r][c] == 5:
                dq = deque()
                dq.append((r, c))
                grid[r][c] = 4
                while dq:
                    rr, cc = dq.popleft()
                    for dr, dc in ORTH:
                        nr, nc = rr + dr, cc + dc
                        if 0 <= nr < h and 0 <= nc < w and grid[nr][nc] == 5:
                            grid[nr][nc] = 4
                            dq.append((nr, nc))

    # Step 4: Cave Escape
    start_pos = None
    exit_pos = None
    for r in range(h):
        for c in range(w):
            if grid[r][c] == 2:
                start_pos = (r, c)
            elif grid[r][c] == 3:
                exit_pos = (r, c)
    if start_pos and exit_pos:
        q = deque([start_pos])
        visited = {start_pos}
        prev = {}
        found = False
        while q:
            cr, cc = q.popleft()
            if (cr, cc) == exit_pos:
                found = True
                break
            for dr, dc in ORTH:
                nr, nc = cr + dr, cc + dc
                if 0 <= nr < h and 0 <= nc < w and (nr, nc) not in visited and grid[nr][nc] > 0:
                    visited.add((nr, nc))
                    prev[(nr, nc)] = (cr, cc)
                    q.append((nr, nc))
        if found:
            cur = exit_pos
            path = []
            while cur != start_pos:
                path.append(cur)
                cur = prev[cur]
            path.append(start_pos)
            for (pr, pc) in path:
                if grid[pr][pc] == 1:
                    grid[pr][pc] = 2

    # Step 5: Permute rows by non-background count
    row_counts = [sum(1 for cell in row if cell > 0) for row in grid]
    rows_with_counts = list(zip(row_counts, grid))
    rows_with_counts.sort(key=lambda x: x[0], reverse=True)
    grid = [row for _, row in rows_with_counts]

    # Step 6: Take Minimum
    for i in range(len(grid)):
        non_zero = [cell for cell in grid[i] if cell > 0]
        if non_zero:
            min_color = min(non_zero)
            grid[i] = [min_color] * len(grid[i])
        else:
            grid[i] = [0] * len(grid[i])

    return grid


def generate():
    # Produce varied caves quickly; ensure output != input
    for _ in range(12):
        w = random.randint(8, 18)
        h = random.randint(8, 18)
        max_size = max(4, min(w * h - 4, int(w * h * 0.45)))
        min_size = max(4, int(w * h * 0.10))
        if min_size > max_size:
            min_size = max(3, max_size // 2)
        size = random.randint(min_size, max_size)

        pathway_pixels = _make_contiguous(size, w, h)
        pathway_set = set(pathway_pixels)
        if len(pathway_set) < 3:
            continue

        start = random.choice(pathway_pixels)
        exit = random.choice([p for p in pathway_pixels if p != start])

        # build input grid
        input_grid = [[0 for _ in range(w)] for _ in range(h)]
        for (r, c) in pathway_pixels:
            if (r, c) == start:
                input_grid[r][c] = 2
            elif (r, c) == exit:
                input_grid[r][c] = 3
            else:
                input_grid[r][c] = random.choice([4,5,6,7,8,9])

        # surround with walls
        for r in range(h):
            for c in range(w):
                if (r, c) in pathway_set:
                    continue
                for dr, dc in ORTH:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < h and 0 <= nc < w and (nr, nc) in pathway_set:
                        input_grid[r][c] = 1
                        break

        output_grid = _transform_grid(input_grid)
        if input_grid != output_grid:
            return {'input': input_grid, 'output': output_grid}

    # fallback small perturbation
    input_grid[0][0] = 1 if input_grid[0][0] == 0 else 0
    return {'input': input_grid, 'output': _transform_grid(input_grid)}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

ORTH = [(1,0),(-1,0),(0,1),(0,-1)]


def _transform_grid(ingrid):
    grid = [list(row) for row in ingrid]
    h = len(grid)
    w = len(grid[0])

    # Step 1: Tile Mutation Rule (simultaneous update), anchor start(2) and exit(3)
    original = [row[:] for row in grid]
    mutated = [row[:] for row in grid]
    for r in range(h):
        for c in range(w):
            v = original[r][c]
            if v <= 1 or v in (2, 3):
                continue
            neighbor_colors = []
            for dr, dc in ORTH:
                nr, nc = r + dr, c + dc
                if 0 <= nr < h and 0 <= nc < w:
                    nv = original[nr][nc]
                    if nv > 1:
                        neighbor_colors.append(nv)
            if neighbor_colors:
                counts = {}
                for col in neighbor_colors:
                    counts[col] = counts.get(col, 0) + 1
                max_count = max(counts.values())
                candidates = [col for col, cnt in counts.items() if cnt == max_count]
                mutated[r][c] = min(candidates)
    grid = mutated

    # Step 2: Color Signal Exchange with bounded passes
    complementary = {(2,8),(8,2),(3,7),(7,3),(4,6),(6,4)}
    swapped = True
    passes = 0
    max_passes = max(8, h * w * 2)
    while swapped and passes < max_passes:
        passes += 1
        swapped = False
        swapped_cells = set()
        for r in range(h):
            for c in range(w):
                if grid[r][c] <= 1 or (r, c) in swapped_cells:
                    continue
                if c + 1 < w and grid[r][c+1] > 1 and (r, c+1) not in swapped_cells:
                    a, b = grid[r][c], grid[r][c+1]
                    if (a, b) in complementary and a not in (2, 3) and b not in (2, 3):
                        grid[r][c], grid[r][c+1] = b, a
                        swapped_cells.update({(r, c), (r, c+1)})
                        swapped = True
                        continue
                if r + 1 < h and grid[r+1][c] > 1 and (r+1, c) not in swapped_cells:
                    a, b = grid[r][c], grid[r+1][c]
                    if (a, b) in complementary and a not in (2, 3) and b not in (2, 3):
                        grid[r][c], grid[r+1][c] = b, a
                        swapped_cells.update({(r, c), (r+1, c)})
                        swapped = True

    # Step 3: Procedural Painting: flood-fill 5 -> 4
    for r in range(h):
        for c in range(w):
            if grid[r][c] == 5:
                q = deque()
                q.append((r, c))
                grid[r][c] = 4
                while q:
                    rr, cc = q.popleft()
                    for dr, dc in ORTH:
                        nr, nc = rr + dr, cc + dc
                        if 0 <= nr < h and 0 <= nc < w and grid[nr][nc] == 5:
                            grid[nr][nc] = 4
                            q.append((nr, nc))

    # Step 4: Cave Escape
    start_pos = None
    exit_pos = None
    for r in range(h):
        for c in range(w):
            if grid[r][c] == 2:
                start_pos = (r, c)
            elif grid[r][c] == 3:
                exit_pos = (r, c)
    if start_pos and exit_pos:
        q = deque([start_pos])
        visited = {start_pos}
        prev = {}
        found = False
        while q:
            cr, cc = q.popleft()
            if (cr, cc) == exit_pos:
                found = True
                break
            for dr, dc in ORTH:
                nr, nc = cr + dr, cc + dc
                if 0 <= nr < h and 0 <= nc < w and (nr, nc) not in visited and grid[nr][nc] > 0:
                    visited.add((nr, nc))
                    prev[(nr, nc)] = (cr, cc)
                    q.append((nr, nc))
        if found:
            cur = exit_pos
            while cur != start_pos:
                pr, pc = cur
                if grid[pr][pc] == 1:
                    grid[pr][pc] = 2
                cur = prev[cur]
            sr, sc = start_pos
            grid[sr][sc] = 2

    # Step 5: Permute rows
    row_counts = [sum(1 for cell in row if cell > 0) for row in grid]
    rows_with_counts = list(zip(row_counts, grid))
    rows_with_counts.sort(key=lambda x: x[0], reverse=True)
    grid = [row for _, row in rows_with_counts]

    # Step 6: Take Minimum
    for i in range(len(grid)):
        non_zero = [cell for cell in grid[i] if cell > 0]
        if non_zero:
            min_color = min(non_zero)
            grid[i] = [min_color] * len(grid[i])
        else:
            grid[i] = [0] * len(grid[i])

    return grid


def p(input_grid):
    out = _transform_grid(input_grid)
    return tuple(tuple(row) for row in out)

