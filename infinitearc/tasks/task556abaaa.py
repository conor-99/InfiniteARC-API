# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 556abaaa
Difficulty: very hard

=== Tags ===
- Color modulated motion
- Draw line of sight
- Color permutation
- Duplicate row pattern

=== Description ===
Input grids consist of 2D arrays of colors (0-9) featuring "source" cells (e.g.,
color 5) and "wall" cells (color 0). The transformation requires three
sequential steps:    1. **Color Permutation**: All colors in the grid undergo a
consistent, task-specific permutation (e.g., color 1 ↔ 3, 2 ↔ 5, 4 ↔ 7, etc.),
where the exact mapping is not revealed to the solver. This permutation affects
all cells uniformly across the grid.    2. **Color-Modulated Line of Sight**:
For each source cell (original color 5), its permuted color determines the
direction of a line of sight (e.g., permuted color 3 → right, 6 → up, 9 →
diagonal down-right). Lines propagate in the determined direction until blocked
by walls (color 0) or grid boundaries, drawn as a new color (e.g., color 8) over
background cells.    3. **Row Pattern Duplication**: Rows containing any cell
from the drawn lines (color 8) are duplicated *immediately below* their current
position. Duplicates replace the next row’s content (shifting all subsequent
rows downward), but only if the target row does not already contain line-of-
sight cells. Rows with multiple line segments are duplicated once.    The output
grid preserves all non-wall, non-source elements while embedding permuted
colors, line-of-sight paths, and duplicated row patterns. Solvers must infer the
permutation rule from examples, trace directional lines based on modulated
colors, and apply row duplication logic to reconstruct the output. The task
demands multi-step reasoning across color transformations, geometric
propagation, and structural pattern replication, making it "very hard" due to
the interdependence of rules and the need to disentangle hidden color mappings.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

direction_map = {
    1: (0, -1),  # left
    2: (0, 1),   # right
    3: (-1, 0),  # up
    4: (1, 0),   # down
    5: (-1, -1), # up-left
    6: (-1, 1),  # up-right
    7: (1, -1),  # down-left
    8: (1, 1),   # down-right
    9: (0, 0)    # default
}

PERMUTATION = [3, 5, 7, 0, 9, 2, 4, 1, 6, 8]

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = grid(width, height, 0)
    
    walls = []
    for r in range(height):
        for c in range(width):
            if random.random() < 0.2:
                walls.append((r, c))
    for r, c in walls:
        input_grid[r][c] = 0

    sources = []
    for _ in range(random.randint(1, 3)):
        r, c = random.randint(0, height-1), random.randint(0, width-1)
        if input_grid[r][c] == 0:
            input_grid[r][c] = 5
            sources.append((r, c))

    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0 or input_grid[r][c] == 5:
                continue
            input_grid[r][c] = random.choice([1,2,3,4,6,7,8,9])

    permuted_grid = [[PERMUTATION[input_grid[r][c]] for c in range(width)] for r in range(height)]
    output_grid = [row[:] for row in permuted_grid]

    for r, c in sources:
        pc = PERMUTATION[5]
        dr, dc = direction_map.get(pc, (0, 0))
        nr, nc = r + dr, c + dc
        while 0 <= nr < height and 0 <= nc < width:
            if input_grid[nr][nc] != 0 and input_grid[nr][nc] != 5:
                output_grid[nr][nc] = 8
                nr += dr
                nc += dc
            else:
                break

    rows = len(output_grid)
    to_duplicate = [i for i in range(rows) if 8 in output_grid[i]]
    for i in sorted(to_duplicate, reverse=True):
        output_grid.insert(i+1, output_grid[i][:])

    return {
        'input': input_grid,
        'output': output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random
from common import grid

direction_map = {
    1: (0, -1),  # left
    2: (0, 1),   # right
    3: (-1, 0),  # up
    4: (1, 0),   # down
    5: (-1, -1), # up-left
    6: (-1, 1),  # up-right
    7: (1, -1),  # down-left
    8: (1, 1),   # down-right
    9: (0, 0)    # default
}

PERMUTATION = [3, 5, 7, 0, 9, 2, 4, 1, 6, 8]

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    permuted_grid = [[PERMUTATION[input_grid[r][c]] for c in range(width)] for r in range(height)]
    output_grid = [row[:] for row in permuted_grid]

    sources = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 5:
                sources.append((r, c))

    for r, c in sources:
        pc = PERMUTATION[5]
        dr, dc = direction_map.get(pc, (0, 0))
        nr, nc = r + dr, c + dc
        while 0 <= nr < height and 0 <= nc < width:
            if input_grid[nr][nc] != 0 and input_grid[nr][nc] != 5:
                output_grid[nr][nc] = 8
                nr += dr
                nc += dc
            else:
                break

    rows = len(output_grid)
    to_duplicate = [i for i in range(rows) if 8 in output_grid[i]]
    for i in sorted(to_duplicate, reverse=True):
        output_grid.insert(i+1, output_grid[i][:])

    return output_grid
