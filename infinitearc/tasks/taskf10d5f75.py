# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: f10d5f75
Difficulty: medium

=== Tags ===
- Local convolution rule
- Count tiles
- Find shape in negative space
- Image rotation

=== Description ===
The input grid consists of a background of zeros (negative space) with colored
tiles (non-zero values) forming a pattern. The negative space contains a hidden
shape, such as a triangle or rectangle, detectable through local neighborhood
analysis (e.g., identifying contiguous zero regions). To generate the output
grid, first count all non-zero tiles in the input. The output is the input grid
rotated clockwise by (tile count modulo 4) Ã— 90 degrees. This rotation
standardizes the orientation of the hidden negative space shape, though the
transformation rule depends solely on the tile count, not the shape's
properties. The task requires recognizing the hidden shape visually while
applying a rotation rule based on tile count, combining local pattern detection
with global counting and rotation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import random_color

def generate():
    width = random.randint(2, 30)
    height = random.randint(2, 30)
    total = width * height
    N = random.randint(1, total - 1)
    while N % 4 == 0:
        N = random.randint(1, total - 1)
    input_grid = [[0] * width for _ in range(height)]
    positions = random.sample([(r, c) for r in range(height) for c in range(width)], N)
    for r, c in positions:
        input_grid[r][c] = random_color()
    output_grid = [row[:] for row in input_grid]
    rotation = N % 4
    for _ in range(rotation):
        output_grid = [list(x)[::-1] for x in zip(*output_grid)]
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    N = sum(1 for row in input_grid for cell in row if cell != 0)
    rotation = N % 4
    grid = [row[:] for row in input_grid]
    for _ in range(rotation):
        grid = [list(x)[::-1] for x in zip(*grid)]
    return grid
