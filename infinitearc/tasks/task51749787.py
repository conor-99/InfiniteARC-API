# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 51749787
Difficulty: medium–hard

=== Tags ===
- Simulate billiards shot
- One yes one no

=== Description ===
Input grids are medium-sized (5×5 to 20×20) with a uniform background color. A
single ball (represented by a distinct color, e.g., blue) is positioned along
the left edge of the grid, facing right. The grid contains two types of walls:
one color (e.g., red) that causes the ball to bounce (reversing direction upon
collision), and another color (e.g., green) that causes the ball to stop (ending
the trajectory). Walls are placed such that the ball moves freely through
background cells until encountering a wall. The ball never overlaps with walls
or itself during movement.   The output grid displays the complete trajectory of
the ball as a continuous path in its original color. The path follows straight-
line movement until a wall is encountered: hitting a red wall reverses the
ball’s direction (e.g., right → left), continuing the path; hitting a green wall
terminates the path at that cell. The ball exits the grid or stops at the first
green wall encountered. Walls remain unchanged in the output, with no
overlapping paths or intersections. The trajectory is deterministic, requiring
the solver to track direction changes based on wall color while ignoring
background cells.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Grid size
    width = random.randint(5, 20)
    height = random.randint(5, 20)

    # Fixed semantic colors (kept consistent with solver)
    RED = 1       # bounce wall
    BALL = 2      # ball / path
    GREEN = 3     # stopping wall

    # Choose a background color different from RED, GREEN, BALL
    possible_bg = [0, 4, 5, 6, 7, 8, 9]
    bg_color = random.choice(possible_bg)

    # Create empty grid filled with background
    grid = [[bg_color for _ in range(width)] for _ in range(height)]

    # Place the ball on the left edge at a random row
    ball_row = random.randint(0, height - 1)
    grid[ball_row][0] = BALL

    # Decide whether the ball will be stopped by a green wall in its row
    # If we place a green wall we pick a column >= 2 so that at least one
    # additional cell (col 1) will be painted and the output differs from input.
    place_green_in_row = random.choice([True, False])
    if place_green_in_row:
        stop_col = random.randint(2, width - 1)
        grid[ball_row][stop_col] = GREEN
    else:
        stop_col = None

    # Helper to find an empty cell not on the ball's row and not in column 0
    def random_empty_cell_not_ballrow():
        tries = 0
        while tries < 1000:
            r = random.randint(0, height - 1)
            c = random.randint(1, width - 1)
            if r == ball_row:
                tries += 1
                continue
            if grid[r][c] == bg_color:
                return r, c
            tries += 1
        # fallback: scan for any suitable cell
        for r in range(height):
            for c in range(1, width):
                if r == ball_row:
                    continue
                if grid[r][c] == bg_color:
                    return r, c
        # As a last resort (shouldn't happen) place at (0,1)
        return 0, 1

    # Place several red and green walls somewhere else in the grid (not on ball row)
    # to add variety but ensure we always have at least one red and one green somewhere.
    red_count = random.randint(1, max(1, width // 3))
    for _ in range(red_count):
        r, c = random_empty_cell_not_ballrow()
        grid[r][c] = RED

    green_count = random.randint(1, max(1, width // 3))
    for _ in range(green_count):
        r, c = random_empty_cell_not_ballrow()
        grid[r][c] = GREEN

    # Ensure there is at least one green (if we didn't place one in the ball row)
    if not any(GREEN in row for row in grid):
        r, c = random_empty_cell_not_ballrow()
        grid[r][c] = GREEN

    # Build the output by simulating the simple rightward motion
    # The ball moves right along its row, painting background cells until
    # it encounters a wall (RED or GREEN) or exits the grid. Walls remain unchanged.
    output = [row[:] for row in grid]

    # Paint the path: starting cell always painted (it already is BALL in input),
    # paint subsequent background cells until the first wall or edge.
    for col in range(0, width):
        if col == 0:
            output[ball_row][col] = BALL
            continue
        cell = grid[ball_row][col]
        if cell == RED or cell == GREEN:
            break
        output[ball_row][col] = BALL

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import Counter

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # Semantic colors (must match generator)
    RED = 1
    BALL = 2
    GREEN = 3

    # Find the background color as the most common color in the grid
    flat = [c for row in grid for c in row]
    if not flat:
        return grid
    counts = Counter(flat)
    bg_color = max(counts.keys(), key=lambda k: counts[k])

    # Find the ball on the left edge (column 0). The generator places exactly one BALL
    ball_row = None
    for r in range(height):
        if grid[r][0] != bg_color:
            # The left-edge non-background cell is the ball
            ball_row = r
            ball_color = grid[r][0]
            break
    # Fallback: if not found, search for a unique-colored cell
    if ball_row is None:
        ball_row = 0
        ball_color = BALL
        for r in range(height):
            for c in range(width):
                if counts[grid[r][c]] == 1:
                    ball_row = r
                    ball_color = grid[r][c]
                    break
            else:
                continue
            break

    # Produce the output by painting all traversed background cells to ball_color
    output = [row[:] for row in grid]
    # Ensure starting cell is ball_color
    if 0 < width:
        output[ball_row][0] = ball_color

    # Move right along the row until a wall appears or until we exit the grid
    for c in range(1, width):
        cell = grid[ball_row][c]
        if cell == RED or cell == GREEN:
            break
        output[ball_row][c] = ball_color

    return output

