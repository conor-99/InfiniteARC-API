# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 718ad1f4
Difficulty: hard

=== Tags ===
- Simulate gravity with obstacles
- Fractal repetition
- Divide by n

=== Description ===
The task involves a two-step transformation. First, apply gravity to the input
grid by shifting all non-zero elements in each column downward to the lowest
possible positions, preserving their relative order (zeros occupy the top
positions in each column). Second, the gravity-processed grid undergoes fractal
repetition through recursive division: the grid is divided into `n` equal
sections along both axes (e.g., `n=2` for a 4×4 grid, creating four 2×2
sections), and each section is replaced by a scaled-down version of the entire
gravity-processed grid. This division and scaling repeat recursively at each
section until the subgrids reach 1×1 size. The output grid is constructed by
arranging these recursively scaled sections, forming a fractal pattern where the
structure repeats at progressively smaller scales, with each level corresponding
to a division by `n`. The transformation ensures the output grid maintains the
fractal repetition while adhering to the gravity constraints.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def apply_gravity(grid):
    if not grid or not grid[0]:
        return grid
    h = len(grid)
    w = len(grid[0])
    new_grid = [[0] * w for _ in range(h)]
    for col in range(w):
        non_zeros = [grid[row][col] for row in range(h) if grid[row][col] != 0]
        for row in range(h - len(non_zeros), h):
            new_grid[row][col] = non_zeros[row - (h - len(non_zeros))]
    return new_grid

def generate():
    size = random.choice([2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30])
    input_grid = [[random.randint(0, 9) for _ in range(size)] for _ in range(size)]
    gravity_grid = apply_gravity(input_grid)
    output_grid = [[gravity_grid[i//2][j//2] for j in range(size)] for i in range(size)]
    if input_grid == output_grid:
        return generate()
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random

def apply_gravity(grid):
    if not grid or not grid[0]:
        return grid
    h = len(grid)
    w = len(grid[0])
    new_grid = [[0] * w for _ in range(h)]
    for col in range(w):
        non_zeros = [grid[row][col] for row in range(h) if grid[row][col] != 0]
        for row in range(h - len(non_zeros), h):
            new_grid[row][col] = non_zeros[row - (h - len(non_zeros))]
    return new_grid

def p(input_grid):
    gravity_grid = apply_gravity(input_grid)
    size = len(input_grid)
    output_grid = [[gravity_grid[i//2][j//2] for j in range(size)] for i in range(size)]
    return output_grid
