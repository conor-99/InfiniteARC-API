# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: f4ac419b
Difficulty: insane

=== Tags ===
- Friction path
- Pattern to sequence mapping
- Collision marking
- Maze
- Image filling

=== Description ===
Input grids are intricate mazes composed of a uniform background color (0) with
walls represented by distinct non-background colors (1-9) forming interconnected
corridors. A single start cell (color 1) is embedded within the maze, and a
pattern strip—a sequence of colors (2-9) displayed along the grid's
edge—specifies the exact color sequence for path traversal. The maze corridors
form a single continuous path from the start cell, with the path length
precisely matching the pattern strip's length.   The output grid draws the path
by coloring each cell along the route sequentially with the pattern strip's
colors, starting immediately after the start cell. If a move would extend the
path into a wall cell (non-background), that wall cell is marked with a fixed
collision color (9), indicating a collision point without altering the path's
progression. The start cell (color 1) and pattern strip remain visually intact.
All walls, background, and non-path elements retain their input colors. The
transformation requires identifying the unique path through the maze, aligning
its sequence with the pattern strip, and marking wall collisions as the path
would extend beyond natural corridor boundaries. This task demands multi-step
reasoning: path identification, sequence mapping, collision detection, and
precise color application within a constrained maze structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    # Try multiple times to build a valid maze/path
    for attempt in range(1000):
        # dimensions
        width = random.randint(7, 18)
        height = random.randint(7, 18)
        if height < 5:
            height = 5
        # pattern length (number of colors to paint along the path)
        max_pat = max(3, min(12, width - 2))
        pat_len = random.randint(3, max_pat)
        path_cells = pat_len + 1  # start + pat_len steps

        # create a grid filled with wall colors (2..8)
        grid = [[random.randint(2, 8) for _ in range(width)] for _ in range(height)]

        # place pattern on the top row (row 0), left-aligned
        pattern_colors = [random.randint(2, 8) for _ in range(pat_len)]
        for c, colval in enumerate(pattern_colors):
            grid[0][c] = colval
        # mark the remainder of the top row as background (0) so the pattern is a clear contiguous run
        for c in range(pat_len, width):
            grid[0][c] = 0
        # keep row 1 as a full wall row to isolate the pattern row from any carved corridors
        for c in range(width):
            grid[1][c] = random.randint(2, 8)

        # Helper to try carving a simple non-branching path contained in rows >= 2
        def try_carve_path():
            # try a few different starting positions
            for _ in range(150):
                sx = random.randint(0, width - 1)
                sy = random.randint(2, height - 1)
                path = [(sx, sy)]
                failed = False
                for _step in range(pat_len):
                    curx, cury = path[-1]
                    candidates = []
                    for dx, dy in [(0,1),(0,-1),(1,0),(-1,0)]:
                        nx, ny = curx + dx, cury + dy
                        # stay inside bounds and below the reserved pattern row
                        if not (0 <= nx < width and 2 <= ny < height):
                            continue
                        if (nx, ny) in path:
                            continue
                        # ensure we don't touch any earlier path cell (except the immediate predecessor)
                        touch_other = False
                        for ddx, ddy in [(0,1),(0,-1),(1,0),(-1,0)]:
                            mx, my = nx + ddx, ny + ddy
                            if (mx, my) in path and (mx, my) != (curx, cury):
                                touch_other = True
                                break
                        if touch_other:
                            continue
                        candidates.append((nx, ny))
                    if not candidates:
                        failed = True
                        break
                    # choose a candidate at random
                    nxt = random.choice(candidates)
                    path.append(nxt)
                if not failed and len(path) == path_cells:
                    return path
            return None

        path = try_carve_path()
        if path is None:
            continue

        # carve the corridor: path cells become background (0) except the start cell marked with 1
        for i, (x, y) in enumerate(path):
            if i == 0:
                grid[y][x] = 1
            else:
                grid[y][x] = 0

        # Build output by applying the pattern colors along the path after the start cell
        output = [row[:] for row in grid]
        for i in range(1, len(path)):
            x, y = path[i]
            output[y][x] = pattern_colors[i - 1]

        # Mark the collision cell: continue one step beyond the last cell in same direction
        if len(path) >= 2:
            last_x, last_y = path[-1]
            prev_x, prev_y = path[-2]
            dx, dy = last_x - prev_x, last_y - prev_y
            nx, ny = last_x + dx, last_y + dy
            if 0 <= nx < width and 0 <= ny < height:
                # Only mark if that cell is a wall (non-background)
                if grid[ny][nx] != 0 and grid[ny][nx] != 1:
                    output[ny][nx] = 9

        return {"input": grid, "output": output}

    # fallback (should not be reached often)
    # create a very small deterministic example
    width, height = 7, 7
    grid = [[2 for _ in range(width)] for _ in range(height)]
    pattern_colors = [3,4,5,6]
    for c, v in enumerate(pattern_colors):
        grid[0][c] = v
    for c in range(len(pattern_colors), width):
        grid[0][c] = 0
    for c in range(width):
        grid[1][c] = 2
    path = [(1,2),(2,2),(3,2),(3,3),(3,4)]
    for i,(x,y) in enumerate(path):
        grid[y][x] = 1 if i==0 else 0
    output = [row[:] for row in grid]
    for i in range(1,len(path)):
        x,y = path[i]
        output[y][x] = pattern_colors[i-1]
    last_x,last_y = path[-1]
    prev_x,prev_y = path[-2]
    dx,dy = last_x-prev_x, last_y-prev_y
    nx,ny = last_x+dx, last_y+dy
    if 0<=nx<width and 0<=ny<height:
        output[ny][nx] = 9
    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Read the pattern from the top row: contiguous run of colors 2..9 from the left
    pattern = []
    for c in range(width):
        v = grid[0][c]
        if 2 <= v <= 9:
            pattern.append(v)
        else:
            break

    # locate the start cell (color 1)
    start = None
    for y in range(height):
        for x in range(width):
            if grid[y][x] == 1:
                start = (x, y)
                break
        if start is not None:
            break

    if start is None:
        return grid

    # Walk the unique corridor: move to the unvisited adjacent background cell (0) until it ends
    path = [start]
    visited = {start}
    while True:
        cx, cy = path[-1]
        next_cells = []
        for dx, dy in [(0,1),(0,-1),(1,0),(-1,0)]:
            nx, ny = cx + dx, cy + dy
            if 0 <= nx < width and 0 <= ny < height and grid[ny][nx] == 0 and (nx, ny) not in visited:
                next_cells.append((nx, ny))
        if not next_cells:
            break
        # There should be exactly one continuation in a proper corridor; take the first
        nxt = next_cells[0]
        path.append(nxt)
        visited.add(nxt)

    # Paint the path according to the pattern (starting immediately after the start cell)
    out = [row[:] for row in grid]
    for i in range(1, len(path)):
        if i - 1 < len(pattern):
            x, y = path[i]
            out[y][x] = pattern[i - 1]

    # Mark the collision cell (one step beyond the last path cell, if it's a wall)
    if len(path) >= 2:
        last_x, last_y = path[-1]
        prev_x, prev_y = path[-2]
        dx, dy = last_x - prev_x, last_y - prev_y
        nx, ny = last_x + dx, last_y + dy
        if 0 <= nx < width and 0 <= ny < height:
            # Do not overwrite the pattern strip (top row)
            if not (ny == 0 and 2 <= grid[ny][nx] <= 9):
                if grid[ny][nx] != 0 and grid[ny][nx] != 1:
                    out[ny][nx] = 9
    return out

