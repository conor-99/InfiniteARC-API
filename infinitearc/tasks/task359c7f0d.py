# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 359c7f0d
Difficulty: mediumâ€“hard

=== Tags ===
- Detect enclosure
- Connect all dots of same color
- Draw x on largest object

=== Description ===
The input grid features a background color (0), multiple enclosed regions
(enclosures) each bounded by a single non-background border color, and scattered
colored dots (individual non-background cells not part of borders). Each
enclosure is a connected background region completely surrounded by a border of
a unique color, forming a closed loop with no connection to the grid's
perimeter. The scattered dots are cells of non-background colors that appear in
multiple isolated locations (e.g., three cells of color 2, two cells of color
5), but never overlap with borders or enclosures.  The output grid must: 1. For
every color appearing in two or more dot cells, draw a continuous straight-line
connection between all such dots. The line must traverse only background cells
(0), use the dot's color, and avoid intersecting borders or other connections.
2. Identify all enclosures (background regions inside borders) and compute their
areas (number of background cells enclosed). 3. Draw a distinct 'X' (two
crossing lines using color 9) at the geometric center of the largest enclosure
(by area). The 'X' must not overlap borders, dots, or other connections, and
must cover central cells without extending into borders.  Enclosures are
detected via background connectivity analysis (non-perimeter-connected
background regions), dot connections are drawn as minimal straight lines, and
the largest enclosure is determined by area (with ties resolved by grid
position). The transformation requires simultaneous detection of enclosed
regions, color-based dot connectivity, and spatial reasoning to locate and mark
the largest enclosure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random
import math

# Generator for ARC task 404 - enclosures, connect dots, draw X in largest enclosure

def generate():
    # Parameters
    MIN_SIZE = 15
    MAX_SIZE = 25
    MIN_INNER = 5  # minimal inner (background) dimension of each enclosure
    max_tries = 500

    width = random.randint(MIN_SIZE, MAX_SIZE)
    height = random.randint(MIN_SIZE, MAX_SIZE)
    grid = common.grid(width, height, 0)

    # Choose number of rectangular enclosures (borders)
    num_rects = random.randint(2, 4)

    # Choose border colors (avoid reserving color 9 for X)
    possible_border_colors = list(range(1, 9))
    border_colors = random.sample(possible_border_colors, num_rects)

    rectangles = []  # list of (r1, c1, r2, c2, color)

    # Helper: check if proposed rectangle (inclusive bounds) overlaps existing rectangles (with 1-cell margin)
    def rect_overlaps(r1, c1, r2, c2):
        for (pr1, pc1, pr2, pc2, _) in rectangles:
            # allow at least one cell gap between outer borders
            if not (r2 + 1 < pr1 or r1 > pr2 + 1 or c2 + 1 < pc1 or c1 > pr2 + 1):
                # previous code had bug pc1/pc2 mismatch; redo correct check
                pass
        # We'll check properly below
        for (pr1, pc1, pr2, pc2, _) in rectangles:
            if r2 + 1 < pr1 or r1 > pr2 + 1 or c2 + 1 < pc1 or c1 > pc2 + 1:
                continue
            return True
        return False

    # Place rectangles
    for color in border_colors:
        placed = False
        for _ in range(max_tries):
            # Compute feasible r1/c1 ranges so that interior (r2-r1-1) >= MIN_INNER and borders not on grid edge
            r1_min = 1
            r1_max = height - MIN_INNER - 3
            c1_min = 1
            c1_max = width - MIN_INNER - 3
            if r1_max < r1_min or c1_max < c1_min:
                # Grid too small; reduce MIN_INNER requirement
                r1_min = 1
                r1_max = max(1, height - 5)
                c1_min = 1
                c1_max = max(1, width - 5)
            r1 = random.randint(r1_min, r1_max)
            c1 = random.randint(c1_min, c1_max)
            r2_min = r1 + MIN_INNER + 1
            r2_max = height - 2
            c2_min = c1 + MIN_INNER + 1
            c2_max = width - 2
            if r2_min > r2_max or c2_min > c2_max:
                continue
            r2 = random.randint(r2_min, r2_max)
            c2 = random.randint(c2_min, c2_max)
            # check overlap with existing rectangles (with one-cell padding)
            overlap = False
            for (pr1, pc1, pr2, pc2, _) in rectangles:
                if not (r2 + 1 < pr1 or r1 > pr2 + 1 or c2 + 1 < pc1 or c1 > pc2 + 1):
                    overlap = True
                    break
            if overlap:
                continue
            # safe to place
            rectangles.append((r1, c1, r2, c2, color))
            # draw border
            for cc in range(c1, c2 + 1):
                grid[r1][cc] = color
                grid[r2][cc] = color
            for rr in range(r1, r2 + 1):
                grid[rr][c1] = color
                grid[rr][c2] = color
            placed = True
            break
        if not placed:
            # if failed to place this rectangle, skip it
            continue

    # Find external background (connected to perimeter)
    def compute_external(g):
        H = len(g)
        W = len(g[0])
        external = set()
        q = []
        for r in range(H):
            for c in (0, W - 1):
                if g[r][c] == 0 and (r, c) not in external:
                    external.add((r, c))
                    q.append((r, c))
        for c in range(W):
            for r in (0, H - 1):
                if g[r][c] == 0 and (r, c) not in external:
                    external.add((r, c))
                    q.append((r, c))
        while q:
            r, c = q.pop(0)
            for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                nr, nc = r + dr, c + dc
                if 0 <= nr < H and 0 <= nc < W and g[nr][nc] == 0 and (nr, nc) not in external:
                    external.add((nr, nc))
                    q.append((nr, nc))
        return external

    external = compute_external(grid)

    # Pick dot colors (not border colors and not 9)
    available_colors = [c for c in range(1, 9) if c not in border_colors]
    if not available_colors:
        available_colors = [c for c in range(1, 9) if c not in border_colors]
    num_dot_colors = random.randint(1, min(3, len(available_colors)))
    dot_colors = random.sample(available_colors, num_dot_colors)

    # For simplicity and to avoid connection crossings we choose a common orientation
    orientation = random.choice(['h', 'v'])

    dot_positions = {}

    # Build lookup of external contiguous segments per row/col
    H = height
    W = width
    external_by_row = {}
    for r in range(H):
        cols = [c for c in range(W) if (r, c) in external]
        cols.sort()
        segments = []
        if cols:
            start = cols[0]
            prev = cols[0]
            for c in cols[1:]:
                if c == prev + 1:
                    prev = c
                else:
                    segments.append((start, prev))
                    start = c
                    prev = c
            segments.append((start, prev))
        external_by_row[r] = segments

    external_by_col = {}
    for c in range(W):
        rows = [r for r in range(H) if (r, c) in external]
        rows.sort()
        segments = []
        if rows:
            start = rows[0]
            prev = rows[0]
            for rr in rows[1:]:
                if rr == prev + 1:
                    prev = rr
                else:
                    segments.append((start, prev))
                    start = rr
                    prev = rr
            segments.append((start, prev))
        external_by_col[c] = segments

    used_rows = set()
    used_cols = set()

    for color in dot_colors:
        count = random.randint(2, 3)
        placed = False
        attempts = 0
        while not placed and attempts < 200:
            attempts += 1
            if orientation == 'h':
                # choose a row with a contiguous segment long enough and not already used
                candidate_rows = [r for r, segs in external_by_row.items() if any((seg[1] - seg[0] + 1) >= count for seg in segs) and r not in used_rows]
                if not candidate_rows:
                    break
                r = random.choice(candidate_rows)
                segs = [seg for seg in external_by_row[r] if (seg[1] - seg[0] + 1) >= count]
                seg = random.choice(segs)
                start, end = seg
                # choose distinct columns within [start,end]
                cols = random.sample(range(start, end + 1), count)
                cols.sort()
                pos = [(r, c) for c in cols]
            else:
                candidate_cols = [c for c, segs in external_by_col.items() if any((seg[1] - seg[0] + 1) >= count for seg in segs) and c not in used_cols]
                if not candidate_cols:
                    break
                c = random.choice(candidate_cols)
                segs = [seg for seg in external_by_col[c] if (seg[1] - seg[0] + 1) >= count]
                seg = random.choice(segs)
                start, end = seg
                rows = random.sample(range(start, end + 1), count)
                rows.sort()
                pos = [(r, c) for r in rows]
            # Ensure none of these positions collide with existing non-zero (should be zeros)
            collision = any(grid[r][c] != 0 for r, c in pos)
            if collision:
                continue
            # mark used row/col
            if orientation == 'h':
                used_rows.add(r)
            else:
                used_cols.add(c)
            for r, c in pos:
                grid[r][c] = color
            dot_positions[color] = pos
            placed = True
        if not placed:
            # failed to place this dot color; remove it
            continue

    # Prepare output grid by copying input
    output = [row[:] for row in grid]

    # Draw straight-line connections for each dot color (all along chosen orientation)
    for color, positions in dot_positions.items():
        if len(positions) < 2:
            continue
        rs = sorted(set(r for r, c in positions))
        cs = sorted(set(c for r, c in positions))
        if len(rs) == 1:
            r = rs[0]
            min_c = min(c for _, c in positions)
            max_c = max(c for _, c in positions)
            # Only draw through zeros to avoid overwriting borders or other dots
            for c in range(min_c, max_c + 1):
                if output[r][c] == 0:
                    output[r][c] = color
        elif len(cs) == 1:
            c = cs[0]
            min_r = min(r for r, _ in positions)
            max_r = max(r for r, _ in positions)
            for r in range(min_r, max_r + 1):
                if output[r][c] == 0:
                    output[r][c] = color
        else:
            # fallback: connect sequentially with L-shaped segments (shouldn't happen in our generator)
            positions_sorted = sorted(positions)
            for i in range(len(positions_sorted) - 1):
                (r1, c1) = positions_sorted[i]
                (r2, c2) = positions_sorted[i + 1]
                # horizontal then vertical
                for c in range(min(c1, c2), max(c1, c2) + 1):
                    if output[r1][c] == 0:
                        output[r1][c] = color
                for r in range(min(r1, r2), max(r1, r2) + 1):
                    if output[r][c2] == 0:
                        output[r][c2] = color

    # Identify enclosed background cells (not in external)
    external = compute_external(grid)
    enclosed = [(r, c) for r in range(H) for c in range(W) if grid[r][c] == 0 and (r, c) not in external]

    if enclosed:
        # Build connected components of enclosed cells
        enclosed_set = set(enclosed)
        visited = set()
        components = []
        for pos in sorted(enclosed):
            if pos in visited:
                continue
            comp = []
            q = [pos]
            visited.add(pos)
            while q:
                rr, cc = q.pop(0)
                comp.append((rr, cc))
                for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                    nr, nc = rr + dr, cc + dc
                    if (nr, nc) in enclosed_set and (nr, nc) not in visited:
                        visited.add((nr, nc))
                        q.append((nr, nc))
            components.append(comp)

        # choose largest component by area; tie-break by smallest min row then min col
        areas = [len(c) for c in components]
        max_area = max(areas)
        candidates = [components[i] for i, a in enumerate(areas) if a == max_area]
        def comp_key(comp):
            min_r = min(r for r, _ in comp)
            min_c = min(c for _, c in comp)
            return (min_r, min_c)
        candidates.sort(key=comp_key)
        largest = candidates[0]

        # compute centroid (float), then choose a center cell within the component that allows a 3x3 X
        avg_r = sum(r for r, _ in largest) / len(largest)
        avg_c = sum(c for _, c in largest) / len(largest)
        largest_set = set(largest)

        # find candidate centers (cells in component that have diagonal neighbours in component)
        centers = []
        for (r, c) in largest:
            neighbors = [(r, c), (r - 1, c - 1), (r - 1, c + 1), (r + 1, c - 1), (r + 1, c + 1)]
            if all((nr, nc) in largest_set for nr, nc in neighbors):
                centers.append((r, c))
        if centers:
            # choose center closest to centroid, tie-break by row then col
            centers.sort(key=lambda x: (abs(x[0] - avg_r) + abs(x[1] - avg_c), x[0], x[1]))
            center_r, center_c = centers[0]
            # draw X (diagonals) using color 9
            diag_cells = [(center_r, center_c), (center_r - 1, center_c - 1), (center_r + 1, center_c + 1), (center_r - 1, center_c + 1), (center_r + 1, center_c - 1)]
            for rr, cc in diag_cells:
                # safety: only draw if inside grid and currently background (should be enclosed)
                if 0 <= rr < H and 0 <= cc < W and output[rr][cc] == 0:
                    output[rr][cc] = 9
        else:
            # fallback: place a single 9 in the integer centroid
            cr = int(round(avg_r))
            cc = int(round(avg_c))
            if 0 <= cr < H and 0 <= cc < W and output[cr][cc] == 0:
                output[cr][cc] = 9

    return {'input': grid, 'output': output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0])

    # compute external background connected to perimeter
    def compute_external(g):
        H = len(g)
        W = len(g[0])
        external = set()
        q = []
        for r in range(H):
            for c in (0, W - 1):
                if g[r][c] == 0 and (r, c) not in external:
                    external.add((r, c))
                    q.append((r, c))
        for c in range(W):
            for r in (0, H - 1):
                if g[r][c] == 0 and (r, c) not in external:
                    external.add((r, c))
                    q.append((r, c))
        while q:
            r, c = q.pop(0)
            for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                nr, nc = r + dr, c + dc
                if 0 <= nr < H and 0 <= nc < W and g[nr][nc] == 0 and (nr, nc) not in external:
                    external.add((nr, nc))
                    q.append((nr, nc))
        return external

    original = [row[:] for row in grid]
    external = compute_external(original)

    # Identify colors and positions
    color_positions = {}
    for r in range(H):
        for c in range(W):
            col = original[r][c]
            if col == 0:
                continue
            color_positions.setdefault(col, []).append((r, c))

    # Determine which colors are border colors vs dot colors.
    # Border colors will have at least one connected component of size >= 4 (borders are large connected loops)
    def connected_components_of_color(positions):
        pos_set = set(positions)
        comps = []
        visited = set()
        for p in sorted(positions):
            if p in visited:
                continue
            q = [p]
            visited.add(p)
            comp = []
            while q:
                rr, cc = q.pop(0)
                comp.append((rr, cc))
                for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                    nr, nc = rr + dr, cc + dc
                    if (nr, nc) in pos_set and (nr, nc) not in visited:
                        visited.add((nr, nc))
                        q.append((nr, nc))
            comps.append(comp)
        return comps

    border_colors = set()
    dot_colors = set()
    for col, positions in color_positions.items():
        comps = connected_components_of_color(positions)
        if any(len(comp) >= 4 for comp in comps):
            border_colors.add(col)
        else:
            dot_colors.add(col)

    # Prepare output as a copy
    out = [row[:] for row in original]

    # For each dot color with at least two positions, draw straight minimal connection
    for color in list(dot_colors):
        positions = color_positions.get(color, [])
        if len(positions) < 2:
            continue
        rows = sorted(set(r for r, c in positions))
        cols = sorted(set(c for r, c in positions))
        if len(rows) == 1:
            r = rows[0]
            min_c = min(c for _, c in positions)
            max_c = max(c for _, c in positions)
            # draw only on background cells
            for c in range(min_c, max_c + 1):
                if out[r][c] == 0:
                    out[r][c] = color
        elif len(cols) == 1:
            c = cols[0]
            min_r = min(r for r, _ in positions)
            max_r = max(r for r, _ in positions)
            for r in range(min_r, max_r + 1):
                if out[r][c] == 0:
                    out[r][c] = color
        else:
            # fallback L-shaped connections (should not be necessary for generated puzzles)
            pos_sorted = sorted(positions)
            for i in range(len(pos_sorted) - 1):
                r1, c1 = pos_sorted[i]
                r2, c2 = pos_sorted[i + 1]
                for c in range(min(c1, c2), max(c1, c2) + 1):
                    if out[r1][c] == 0:
                        out[r1][c] = color
                for r in range(min(r1, r2), max(r1, r2) + 1):
                    if out[r][c2] == 0:
                        out[r][c2] = color

    # Recompute enclosed areas from original (not modified) grid
    enclosed = [(r, c) for r in range(H) for c in range(W) if original[r][c] == 0 and (r, c) not in external]
    if enclosed:
        enclosed_set = set(enclosed)
        visited = set()
        components = []
        for pos in sorted(enclosed):
            if pos in visited:
                continue
            q = [pos]
            visited.add(pos)
            comp = []
            while q:
                rr, cc = q.pop(0)
                comp.append((rr, cc))
                for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                    nr, nc = rr + dr, cc + dc
                    if (nr, nc) in enclosed_set and (nr, nc) not in visited:
                        visited.add((nr, nc))
                        q.append((nr, nc))
            components.append(comp)

        # choose largest by area, tie-break by smallest min row then min col
        areas = [len(c) for c in components]
        max_area = max(areas)
        candidates = [components[i] for i, a in enumerate(areas) if a == max_area]
        def comp_key(comp):
            min_r = min(r for r, _ in comp)
            min_c = min(c for _, c in comp)
            return (min_r, min_c)
        candidates.sort(key=comp_key)
        largest = candidates[0]

        # compute centroid and find a 3x3 X center in the component
        avg_r = sum(r for r, _ in largest) / len(largest)
        avg_c = sum(c for _, c in largest) / len(largest)
        largest_set = set(largest)
        centers = []
        for (r, c) in largest:
            neighbors = [(r, c), (r - 1, c - 1), (r - 1, c + 1), (r + 1, c - 1), (r + 1, c + 1)]
            if all((nr, nc) in largest_set for nr, nc in neighbors):
                centers.append((r, c))
        if centers:
            centers.sort(key=lambda x: (abs(x[0] - avg_r) + abs(x[1] - avg_c), x[0], x[1]))
            cr, cc = centers[0]
            diag_cells = [(cr, cc), (cr - 1, cc - 1), (cr + 1, cc + 1), (cr - 1, cc + 1), (cr + 1, cc - 1)]
            for rr, cc in diag_cells:
                if 0 <= rr < H and 0 <= cc < W and out[rr][cc] == 0:
                    out[rr][cc] = 9
        else:
            cr = int(round(avg_r))
            cc = int(round(avg_c))
            if 0 <= cr < H and 0 <= cc < W and out[cr][cc] == 0:
                out[cr][cc] = 9

    return out

