# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 961c8688
Difficulty: very hard

=== Tags ===
- Directed cave maze
- Loopless path
- Token following
- Propagation by rule weight
- Image rotation

=== Description ===
Input grids depict a cave maze with walls (color 0) and a single, loopless path
(color 1) connecting a start token (color 2) to an endpoint (color 3). The maze
structure is obscured by directional markers embedded within path cells, where
each marker (colors 4-7) indicates a local movement direction relative to the
cell's position: color 4 = up, color 5 = right, color 6 = down, color 7 = left.
The entire maze is presented in a randomly rotated orientation (90°, 180°, or
270°), but directional markers remain consistent with the cell's local
orientation. The token follows the path by moving in the direction specified by
each marker, traversing only path cells (color 1) without loops or wall
collisions. The output grid must first unrotate the maze to its original
orientation (as if rotated 0°), then highlight the token's complete path with
color 8, ensuring the path matches the directional markers when interpreted in
the unrotated frame. The solution requires simultaneous rotation correction and
path tracing based on visual direction indicators, with no numerical
dependencies on cell values beyond their color-based meaning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque

# Generator for the task

def rotate_grid(grid, degrees):
    # Rotate grid clockwise by degrees (degrees in {0,90,180,270})
    degrees = degrees % 360
    if degrees == 0:
        return [row[:] for row in grid]
    h = len(grid)
    w = len(grid[0])
    if degrees == 90:
        out = [[0] * h for _ in range(w)]
        for r in range(h):
            for c in range(w):
                out[c][h - 1 - r] = grid[r][c]
        return out
    if degrees == 180:
        out = [[0] * w for _ in range(h)]
        for r in range(h):
            for c in range(w):
                out[h - 1 - r][w - 1 - c] = grid[r][c]
        return out
    if degrees == 270:
        out = [[0] * h for _ in range(w)]
        for r in range(h):
            for c in range(w):
                out[w - 1 - c][r] = grid[r][c]
        return out
    raise ValueError('Unsupported rotation')


def build_spanning_tree(size, start):
    # Randomized DFS spanning tree over all cells
    h = size
    w = size
    all_cells = [(r, c) for r in range(h) for c in range(w)]
    edges = {cell: set() for cell in all_cells}
    visited = set([start])
    stack = [start]
    while stack:
        cur = stack[-1]
        r, c = cur
        neighbors = []
        for dr, dc in [(-1, 0), (0, 1), (1, 0), (0, -1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < h and 0 <= nc < w and (nr, nc) not in visited:
                neighbors.append((nr, nc))
        if neighbors:
            nxt = random.choice(neighbors)
            edges[cur].add(nxt)
            edges[nxt].add(cur)
            visited.add(nxt)
            stack.append(nxt)
        else:
            stack.pop()
    return edges


def path_in_tree(edges, start, end):
    # BFS on the tree (edges) to extract the unique path
    q = deque([start])
    prev = {start: None}
    while q:
        cur = q.popleft()
        if cur == end:
            break
        for nb in edges[cur]:
            if nb not in prev:
                prev[nb] = cur
                q.append(nb)
    if end not in prev:
        return None
    path = []
    cur = end
    while cur is not None:
        path.append(cur)
        cur = prev[cur]
    path.reverse()
    return path


def generate():
    # Size selection: keep it moderate but variable to ensure many unique examples
    size = random.randint(6, 16)

    # Choose a random starting cell
    start = (random.randint(0, size - 1), random.randint(0, size - 1))

    # Build a random spanning tree (so there is a unique simple path between any two cells)
    edges = build_spanning_tree(size, start)

    # Choose an end cell whose path length from start is at least min_len
    all_cells = [(r, c) for r in range(size) for c in range(size)]
    min_len = 4
    path = None
    tries = 0
    while tries < 200:
        tries += 1
        end = random.choice(all_cells)
        if end == start:
            continue
        candidate = path_in_tree(edges, start, end)
        if candidate is None:
            continue
        if len(candidate) >= min_len:
            path = candidate
            break
    if path is None:
        # fallback: pick the farthest cell from start
        best = None
        best_len = -1
        for cell in all_cells:
            cand = path_in_tree(edges, start, cell)
            if cand is None:
                continue
            if len(cand) > best_len:
                best_len = len(cand)
                best = cand
        path = best

    # Construct base grid: walls 0 by default
    base = [[0 for _ in range(size)] for _ in range(size)]

    # Place start and end and directional markers along the path
    for i, (r, c) in enumerate(path):
        if i == 0:
            base[r][c] = 2
        elif i == len(path) - 1:
            base[r][c] = 3
        else:
            nr, nc = path[i + 1]
            dr, dc = nr - r, nc - c
            if dr == -1 and dc == 0:
                base[r][c] = 4  # up
            elif dr == 0 and dc == 1:
                base[r][c] = 5  # right
            elif dr == 1 and dc == 0:
                base[r][c] = 6  # down
            elif dr == 0 and dc == -1:
                base[r][c] = 7  # left
            else:
                # Shouldn't happen in a 4-neighbor grid
                base[r][c] = 4

    # Create the output grid: unrotated, with directional markers replaced by 8
    output = [row[:] for row in base]
    for r in range(size):
        for c in range(size):
            if output[r][c] in (4, 5, 6, 7):
                output[r][c] = 8

    # Rotate the base grid (the maze) by a random non-zero multiple of 90° to form the input
    rotation = random.choice([90, 180, 270])
    input_grid = rotate_grid(base, rotation)

    return {"input": input_grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------


# Solver that detects the rotation by interpreting marker colors under each rotation


def rotate_grid(grid, degrees):
    # Rotate grid clockwise by degrees (degrees in {0,90,180,270})
    degrees = degrees % 360
    if degrees == 0:
        return [row[:] for row in grid]
    h = len(grid)
    w = len(grid[0])
    if degrees == 90:
        out = [[0] * h for _ in range(w)]
        for r in range(h):
            for c in range(w):
                out[c][h - 1 - r] = grid[r][c]
        return out
    if degrees == 180:
        out = [[0] * w for _ in range(h)]
        for r in range(h):
            for c in range(w):
                out[h - 1 - r][w - 1 - c] = grid[r][c]
        return out
    if degrees == 270:
        out = [[0] * h for _ in range(w)]
        for r in range(h):
            for c in range(w):
                out[w - 1 - c][r] = grid[r][c]
        return out
    raise ValueError('Unsupported rotation')


def rotate_vector(dr, dc, times):
    # rotate (dr,dc) clockwise by 90 degrees 'times' times
    for _ in range(times % 4):
        dr, dc = dc, -dr
    return dr, dc


def try_follow_with_rotation(grid, rotation_deg):
    # Interpret marker colors 4->up,5->right,6->down,7->left in the original
    # frame; if the input grid was rotated clockwise by rotation_deg, then
    # each base direction should be rotated clockwise by rotation_deg to get
    # its meaning in the current grid coordinates.
    base_map = {4: (-1, 0), 5: (0, 1), 6: (1, 0), 7: (0, -1)}
    times = (rotation_deg // 90) % 4

    h = len(grid)
    w = len(grid[0])

    # find start
    start = None
    start_count = 0
    for r in range(h):
        for c in range(w):
            if grid[r][c] == 2:
                start = (r, c)
                start_count += 1
    if start is None or start_count != 1:
        return None

    # adjacent candidates
    adj = []
    for dr, dc in [(-1, 0), (0, 1), (1, 0), (0, -1)]:
        nr, nc = start[0] + dr, start[1] + dc
        if 0 <= nr < h and 0 <= nc < w:
            if grid[nr][nc] in (3, 4, 5, 6, 7):
                adj.append((nr, nc))
    if not adj:
        return None

    for first in adj:
        path = [start, first]
        visited = set(path)
        r, c = first
        ok = True
        while True:
            val = grid[r][c]
            if val == 3:
                # Additional global consistency check: in the unrotated frame, every
                # marker must point to another marker or the endpoint. We do this after
                # we deduce the candidate rotation.
                return path
            if val not in (4, 5, 6, 7):
                ok = False
                break
            # get base direction and rotate it to current grid coordinates
            bdr, bdc = base_map[val]
            dr, dc = rotate_vector(bdr, bdc, times)
            nr, nc = r + dr, c + dc
            if not (0 <= nr < h and 0 <= nc < w):
                ok = False
                break
            if (nr, nc) in visited:
                ok = False
                break
            if grid[nr][nc] not in (3, 4, 5, 6, 7):
                ok = False
                break
            visited.add((nr, nc))
            path.append((nr, nc))
            r, c = nr, nc
        if ok:
            return path
    return None


def all_markers_consistent_unrotated(unrot):
    # In the canonical (unrotated) frame, every marker 4-7 should point to a
    # cell that is either another marker or the endpoint 3.
    h = len(unrot)
    w = len(unrot[0])
    for r in range(h):
        for c in range(w):
            v = unrot[r][c]
            if v in (4, 5, 6, 7):
                if v == 4:
                    nr, nc = r - 1, c
                elif v == 5:
                    nr, nc = r, c + 1
                elif v == 6:
                    nr, nc = r + 1, c
                elif v == 7:
                    nr, nc = r, c - 1
                else:
                    return False
                if not (0 <= nr < h and 0 <= nc < w):
                    return False
                if unrot[nr][nc] not in (3, 4, 5, 6, 7):
                    return False
    return True


def p(input_grid):
    grid = [list(row) for row in input_grid]

    # Try all possible rotations that might have been applied to the original
    # maze (clockwise). If we deduce that the input grid was produced by
    # rotating the original by R degrees, unrotate it by (360 - R) to get
    # the canonical output and replace markers 4-7 with 8.
    for R in (0, 90, 180, 270):
        path = try_follow_with_rotation(grid, R)
        if path is not None:
            # unrotate the input to get the canonical, unrotated maze
            unrot = rotate_grid(grid, (-R) % 360)
            # global consistency check
            if not all_markers_consistent_unrotated(unrot):
                continue
            out = [row[:] for row in unrot]
            for r in range(len(out)):
                for c in range(len(out[0])):
                    if out[r][c] in (4, 5, 6, 7):
                        out[r][c] = 8
            return out

    # fallback: if no rotation yielded a valid traced path, just try to
    # unrotate by 0 and replace markers (defensive)
    out = [row[:] for row in grid]
    for r in range(len(out)):
        for c in range(len(out[0])):
            if out[r][c] in (4, 5, 6, 7):
                out[r][c] = 8
    return out

