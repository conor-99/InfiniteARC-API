# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: e9e8c219
Difficulty: easy

=== Tags ===
- Connect the dots
- Background filling
- Seal gaps inside shape
- Image juxtaposition

=== Description ===
The input grid contains a single closed shape formed by contiguous non-zero
values, with one or more empty cells (0) enclosed within its boundary. The
output grid is created by filling all enclosed empty cells with the shape's
color, thereby sealing internal gaps. This process involves identifying all
cells inside the shape's boundary that are empty and replacing them with the
dominant non-zero color of the shape. The transformation adheres to "connect the
dots" by ensuring the boundary forms a continuous loop, uses "background
filling" to replace background (0) cells within the shape with the shape's
color, and addresses "seal gaps inside shape" by eliminating all internal voids.
The "image juxtaposition" tag is incorporated as the input may feature a single
shape that appears to be composed of juxtaposed elements (e.g., two connected
sub-shapes), which are unified into a solid form in the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
def generate():
    size = random.randint(5, 30)
    grid = [[0] * size for _ in range(size)]
    color = random.randint(1, 9)
    rect_width = random.randint(3, size - 2)
    rect_height = random.randint(3, size - 2)
    r = random.randint(0, size - rect_height)
    c = random.randint(0, size - rect_width)
    for i in range(r, r + rect_height):
        for j in range(c, c + rect_width):
            if i == r or i == r + rect_height - 1 or j == c or j == c + rect_width - 1:
                grid[i][j] = color
    output = [row[:] for row in grid]
    for i in range(r + 1, r + rect_height - 1):
        for j in range(c + 1, c + rect_width - 1):
            output[i][j] = color
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random
def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    non_zero = []
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] != 0:
                non_zero.append((r, c))
    if not non_zero:
        return input_grid
    min_r = min(r for r, c in non_zero)
    max_r = max(r for r, c in non_zero)
    min_c = min(c for r, c in non_zero)
    max_c = max(c for r, c in non_zero)
    color = input_grid[min_r][min_c]
    output = [row[:] for row in input_grid]
    for r in range(min_r + 1, max_r):
        for c in range(min_c + 1, max_c):
            if input_grid[r][c] == 0:
                output[r][c] = color
    return output
