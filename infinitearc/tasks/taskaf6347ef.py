# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: af6347ef
Difficulty: mediumâ€“hard

=== Tags ===
- Hierarchical agent routing
- Repulsion and bounce

=== Description ===
Hierarchical Bounce Paths  Input grids feature a single background color (0),
multiple agents represented by distinct colors (1-4), and static wall barriers
in a fixed wall color (5). Agents are positioned at single-cell locations with
an initial movement direction (all start moving right). Walls appear as 1-cell-
thick horizontal or vertical barriers that agents cannot pass through.  The
output grid depicts the complete movement paths of all agents, generated through
the following rules:  1. **Movement**: Agents move one cell per step in their
current direction (initially right for all). 2. **Wall Bounce**: When an agent
encounters a wall, it reverses direction and continues moving. The path segment
drawn from the collision point onward uses the wall's color (5). 3. **Agent
Repulsion**: When two agents are moving toward each other (e.g., agent A moving
right and agent B moving left, adjacent in the direction of movement), the
**lower-priority agent** (higher color number) reverses direction while the
**higher-priority agent** (lower color number) continues unimpeded. The path
segment drawn from the repulsion point onward uses a dedicated repulsion color
(6). 4. **Hierarchical Routing**: Agent priority is determined by color number
(lower number = higher priority, e.g., color 1 > color 2 > color 3 > color 4).
Movement continues until all agents exit the grid boundaries. The output grid
displays: - Background and walls unchanged - Agent paths drawn over background
cells only - Path segments colored as follows:   - Original agent color before
any events   - Wall color (5) after wall bounces   - Repulsion color (6) after
repulsion events  No two agents occupy the same cell at any time. Paths never
overwrite walls, agents, or other paths. The task requires identifying agent
priorities, wall locations, and applying dynamic repulsion rules while tracking
path color changes through sequential events. Complexity arises from multiple
interacting agents with hierarchical priority, combined wall bounces, and color-
dependent path coloring.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(8, 20)
    height = random.randint(8, 20)
    grid = [[0] * width for _ in range(height)]
    
    num_walls = random.randint(2, 5)
    for _ in range(num_walls):
        if random.choice([True, False]):
            r = random.randint(0, height - 1)
            c_start = random.randint(0, width - 3)
            length = random.randint(1, 3)
            for c in range(c_start, c_start + length):
                grid[r][c] = 5
        else:
            c = random.randint(0, width - 1)
            r_start = random.randint(0, height - 3)
            length = random.randint(1, 3)
            for r in range(r_start, r_start + length):
                grid[r][c] = 5

    agent_colors = [1, 2, 3, 4]
    random.shuffle(agent_colors)
    for color in agent_colors:
        placed = False
        while not placed:
            r = random.randint(0, height - 1)
            c = random.randint(0, width - 2)
            if grid[r][c] == 0:
                grid[r][c] = color
                placed = True

    output = [row[:] for row in grid]
    agents = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] in [1, 2, 3, 4]:
                agents.append({'r': r, 'c': c, 'color': grid[r][c], 'dir': (0, 1)})

    active_agents = agents[:]
    max_steps = 100
    for _ in range(max_steps):
        next_positions = []
        for agent in active_agents:
            dr, dc = agent['dir']
            next_r = agent['r'] + dr
            next_c = agent['c'] + dc
            next_positions.append((next_r, next_c))
        
        collision_positions = {}
        for i, pos in enumerate(next_positions):
            if pos in collision_positions:
                collision_positions[pos].append(i)
            else:
                collision_positions[pos] = [i]
        
        for pos, indices in collision_positions.items():
            if len(indices) == 2:
                i1, i2 = indices
                agent1 = active_agents[i1]
                agent2 = active_agents[i2]
                if agent1['color'] < agent2['color']:
                    lower_priority = agent2
                else:
                    lower_priority = agent1
                dr, dc = lower_priority['dir']
                lower_priority['dir'] = (-dr, -dc)
                r, c = pos
                if 0 <= r < height and 0 <= c < width and output[r][c] == 0:
                    output[r][c] = 6

        to_remove = []
        for i, agent in enumerate(active_agents):
            dr, dc = agent['dir']
            next_r = agent['r'] + dr
            next_c = agent['c'] + dc
            if next_r < 0 or next_r >= height or next_c < 0 or next_c >= width:
                to_remove.append(i)
                continue
            if grid[next_r][next_c] == 5:
                agent['dir'] = (-dr, -dc)
                agent['color'] = 5
            else:
                if output[next_r][next_c] == 0:
                    output[next_r][next_c] = agent['color']
                agent['r'] = next_r
                agent['c'] = next_c
        
        for i in sorted(to_remove, reverse=True):
            del active_agents[i]
        if not active_agents:
            break
    
    return {'input': grid, 'output': output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    
    output = [row[:] for row in grid]
    
    agents = []
    for r in range(height):
        for c in range(width):
            color = grid[r][c]
            if 1 <= color <= 4:
                agents.append({'r': r, 'c': c, 'color': color, 'dir': (0, 1)})
    
    active_agents = agents[:]
    max_steps = 100
    for _ in range(max_steps):
        next_positions = []
        for agent in active_agents:
            dr, dc = agent['dir']
            next_r = agent['r'] + dr
            next_c = agent['c'] + dc
            next_positions.append((next_r, next_c))
        
        collision_positions = {}
        for i, pos in enumerate(next_positions):
            if pos in collision_positions:
                collision_positions[pos].append(i)
            else:
                collision_positions[pos] = [i]
        
        for pos, indices in collision_positions.items():
            if len(indices) == 2:
                i1, i2 = indices
                agent1 = active_agents[i1]
                agent2 = active_agents[i2]
                if agent1['color'] < agent2['color']:
                    lower_priority = agent2
                else:
                    lower_priority = agent1
                dr, dc = lower_priority['dir']
                lower_priority['dir'] = (-dr, -dc)
                r, c = pos
                if 0 <= r < height and 0 <= c < width and output[r][c] == 0:
                    output[r][c] = 6
        
        to_remove = []
        for i, agent in enumerate(active_agents):
            dr, dc = agent['dir']
            next_r = agent['r'] + dr
            next_c = agent['c'] + dc
            if next_r < 0 or next_r >= height or next_c < 0 or next_c >= width:
                to_remove.append(i)
                continue
            if grid[next_r][next_c] == 5:
                agent['dir'] = (-dr, -dc)
                agent['color'] = 5
            else:
                if output[next_r][next_c] == 0:
                    output[next_r][next_c] = agent['color']
                agent['r'] = next_r
                agent['c'] = next_c
        
        for i in sorted(to_remove, reverse=True):
            del active_agents[i]
        if not active_agents:
            break
    
    return output
