# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 6d3abea5
Difficulty: medium

=== Tags ===
- Take minimum
- Size guessing
- Extrapolate image from grid

=== Description ===
The task involves transforming an input grid containing a single prominent
connected shape (non-zero color) on a background (color 0) into an output grid.
The transformation scales the shape by a factor determined by the minimum
dimension of its bounding box. The bounding box is the smallest axis-aligned
rectangle containing all pixels of the shape. The scaling factor M is the
minimum of the bounding box's width and height. Each pixel in the original shape
is replaced by an M×M block of the same color in the output, resulting in an
output grid size of (original shape height × M) × (original shape width × M).
The background remains color 0, and the output contains only the scaled shape
without additional elements. The input and output grids differ in size and
structure, requiring the solver to identify the main shape, compute its bounding
box dimensions, determine the scaling factor M, and apply the scaling
transformation. This task tests visual pattern recognition, spatial reasoning,
and the ability to derive scaling rules from grid geometry.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_el, random_you, random_aitch, random_pixels, random_color

def generate():
    color = random_color(exclude=[0])
    shape_generators = [random_el, random_you, random_aitch, random_pixels]
    shape_type = random.choice(shape_generators)
    shape_width = random.randint(3, 5)
    shape_height = random.randint(3, 5)
    shape_pixels = shape_type(shape_width, shape_height)
    
    rows = [p[0] for p in shape_pixels]
    cols = [p[1] for p in shape_pixels]
    min_row, max_row = min(rows), max(rows)
    min_col, max_col = min(cols), max(cols)
    W = max_col - min_col + 1
    H = max_row - min_row + 1
    M = min(W, H)
    
    while M < 2:
        shape_type = random.choice(shape_generators)
        shape_width = random.randint(3, 5)
        shape_height = random.randint(3, 5)
        shape_pixels = shape_type(shape_width, shape_height)
        rows = [p[0] for p in shape_pixels]
        cols = [p[1] for p in shape_pixels]
        min_row, max_row = min(rows), max(rows)
        min_col, max_col = min(cols), max(cols)
        W = max_col - min_col + 1
        H = max_row - min_row + 1
        M = min(W, H)
    
    shape_w = W
    shape_h = H
    input_w = random.randint(shape_w + 1, 30)
    input_h = random.randint(shape_h + 1, 30)
    
    max_r_offset = input_h - shape_h
    max_c_offset = input_w - shape_w
    r0 = random.randint(0, max_r_offset)
    c0 = random.randint(0, max_c_offset)
    
    input_grid = grid(input_w, input_h, 0)
    for (r, c) in shape_pixels:
        input_r = r0 + r
        input_c = c0 + c
        if 0 <= input_r < input_h and 0 <= input_c < input_w:
            input_grid[input_r][input_c] = color
    
    output_w = W * M
    output_h = H * M
    output_grid = grid(output_w, output_h, 0)
    for (r, c) in shape_pixels:
        rel_r = r - min_row
        rel_c = c - min_col
        start_r = rel_r * M
        start_c = rel_c * M
        for i in range(start_r, start_r + M):
            for j in range(start_c, start_c + M):
                output_grid[i][j] = color
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    non_zero = []
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] != 0:
                non_zero.append((r, c))
    
    if not non_zero:
        return input_grid
    
    color = input_grid[non_zero[0][0]][non_zero[0][1]]
    
    rows = [p[0] for p in non_zero]
    cols = [p[1] for p in non_zero]
    min_row, max_row = min(rows), max(rows)
    min_col, max_col = min(cols), max(cols)
    W = max_col - min_col + 1
    H = max_row - min_row + 1
    M = min(W, H)
    
    output_w = W * M
    output_h = H * M
    output_grid = grid(output_w, output_h, 0)
    
    for (r, c) in non_zero:
        rel_r = r - min_row
        rel_c = c - min_col
        start_r = rel_r * M
        start_c = rel_c * M
        for i in range(start_r, start_r + M):
            for j in range(start_c, start_c + M):
                output_grid[i][j] = color
    
    return output_grid
