# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 310283ec
Difficulty: medium

=== Tags ===
- Color by rank in row
- Periodic run length encoding
- Compose two transforms
- Orthogonal path planning

=== Description ===
The task involves transforming each row of the input grid through two sequential
operations. First, for each row, the elements are sorted in descending order of
their frequency within that row (i.e., most frequent color appears first,
followed by less frequent ones). Second, each contiguous run of identical values
in the sorted row is replaced by the length of that run. For example, a row with
input [1, 1, 2, 2, 2, 3] (frequencies: 1 appears twice, 2 appears three times, 3
appears once) becomes [2, 2, 2, 1, 1, 3] after sorting by frequency, and then
transforms to [3, 3, 3, 2, 2, 1] after replacing each run with its length. This
two-step process is applied independently to every row, resulting in the output
grid. The "periodic" aspect refers to the consistent application of run-length
encoding across all rows, while "orthogonal path planning" aligns with
processing rows (horizontal paths) as the fundamental unit for the
transformation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import Counter

def transform_row(row):
    if not row:
        return []
    count = Counter(row)
    sorted_row = sorted(row, key=lambda x: (-count[x], -x))
    output_row = []
    current = sorted_row[0]
    run_len = 1
    for i in range(1, len(sorted_row)):
        if sorted_row[i] == current:
            run_len += 1
        else:
            output_row.extend([(run_len % 10)] * run_len)
            current = sorted_row[i]
            run_len = 1
    output_row.extend([(run_len % 10)] * run_len)
    return output_row

def generate():
    while True:
        width = random.randint(1, 30)
        height = random.randint(1, 30)
        input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
        output_grid = [transform_row(row) for row in input_grid]
        if input_grid != output_grid:
            return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random
from collections import Counter

def transform_row(row):
    if not row:
        return []
    count = Counter(row)
    sorted_row = sorted(row, key=lambda x: (-count[x], -x))
    output_row = []
    current = sorted_row[0]
    run_len = 1
    for i in range(1, len(sorted_row)):
        if sorted_row[i] == current:
            run_len += 1
        else:
            output_row.extend([(run_len % 10)] * run_len)
            current = sorted_row[i]
            run_len = 1
    output_row.extend([(run_len % 10)] * run_len)
    return output_row

def p(input_grid):
    return [transform_row(row) for row in input_grid]
