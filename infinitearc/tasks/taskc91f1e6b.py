# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: c91f1e6b
Difficulty: hard

=== Tags ===
- Perimeter smoothing

=== Description ===
The task involves transforming input grids containing multiple distinct colored
regions (non-zero values) on a uniform background (value 0). Each region must
have a jagged, irregular perimeter characterized by "notches" where background
pixels are surrounded on three sides by the region's color within a 2×2 block.
The output grid is generated by filling all such background pixels that occupy
the fourth corner of any 2×2 block containing exactly three identical non-zero
color cells, thereby smoothing the perimeter of each region. This transformation
requires identifying all valid 2×2 blocks across the grid, ignoring overlapping
regions, and applying the fill operation in a single pass without iterative
refinement. The task is challenging due to the need to process multiple regions
simultaneously in large grids (e.g., 20×20), where notches may appear in complex
configurations, and the solution must avoid overwriting adjacent regions or
background pixels outside the specified block patterns.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    W = random.randint(15, 30)
    H = random.randint(15, 30)
    grid = common.grid(W, H, 0)
    colors_used = []
    num_regions = random.randint(2, 5)
    for _ in range(num_regions):
        color = random.choice([c for c in range(1, 10) if c not in colors_used])
        colors_used.append(color)
        r = random.randint(0, H - 2)
        c = random.randint(0, W - 2)
        w = random.randint(2, min(5, W - c))
        h = random.randint(2, min(5, H - r))
        for i in range(r, r + h):
            for j in range(c, c + w):
                grid[i][j] = color
        corners = [(r, c), (r, c + w - 1), (r + h - 1, c), (r + h - 1, c + w - 1)]
        for (i, j) in corners:
            if 0 <= i < H and 0 <= j < W and random.random() < 0.5:
                grid[i][j] = 0
    output = [row[:] for row in grid]
    for i in range(H - 1):
        for j in range(W - 1):
            cells = [grid[i][j], grid[i][j+1], grid[i+1][j], grid[i+1][j+1]]
            if cells.count(0) == 1:
                color = next((c for c in cells if c != 0), None)
                if color is not None:
                    idx = cells.index(0)
                    if idx == 0:
                        output[i][j] = color
                    elif idx == 1:
                        output[i][j+1] = color
                    elif idx == 2:
                        output[i+1][j] = color
                    elif idx == 3:
                        output[i+1][j+1] = color
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    H = len(input_grid)
    W = len(input_grid[0])
    output = [row[:] for row in input_grid]
    for i in range(H - 1):
        for j in range(W - 1):
            cells = [input_grid[i][j], input_grid[i][j+1], input_grid[i+1][j], input_grid[i+1][j+1]]
            if cells.count(0) == 1:
                color = next((c for c in cells if c != 0), None)
                if color is not None:
                    idx = cells.index(0)
                    if idx == 0:
                        output[i][j] = color
                    elif idx == 1:
                        output[i][j+1] = color
                    elif idx == 2:
                        output[i+1][j] = color
                    elif idx == 3:
                        output[i+1][j+1] = color
    return output
