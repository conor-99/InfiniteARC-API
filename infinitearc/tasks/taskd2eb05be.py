# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: d2eb05be
Difficulty: medium

=== Tags ===
- Separate images

=== Description ===
The input grids consist of 2D grids with values between 0 and 9, containing
multiple connected regions of distinct non-zero colors (e.g., red, blue, green)
that touch or overlap at their boundaries. The output grids transform these
inputs by separating the regions: every pixel that is adjacent (horizontally or
vertically) to a pixel of a different non-zero color is set to 0 (background),
while all other pixels retain their original color. This operation isolates each
connected region by removing the boundary pixels between different colors,
resulting in a grid where distinct regions are no longer touching. The task
requires identifying adjacent color boundaries and applying the separation rule
consistently across the grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid
def generate():
    width = random.randint(3, 30)
    height = random.randint(2, 30)
    color1 = random.randint(1, 9)
    color2 = random.randint(1, 9)
    while color2 == color1:
        color2 = random.randint(1, 9)
    split_col = random.randint(1, width - 2)
    input_grid = grid(width, height, 0)
    for r in range(height):
        for c in range(split_col + 1):
            input_grid[r][c] = color1
        for c in range(split_col + 1, width):
            input_grid[r][c] = color2
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                output_grid[r][c] = 0
                continue
            has_diff_neighbor = False
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    neighbor = input_grid[nr][nc]
                    if neighbor != 0 and neighbor != input_grid[r][c]:
                        has_diff_neighbor = True
                        break
            output_grid[r][c] = 0 if has_diff_neighbor else input_grid[r][c]
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                output[r][c] = 0
                continue
            has_diff = False
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    neighbor = input_grid[nr][nc]
                    if neighbor != 0 and neighbor != input_grid[r][c]:
                        has_diff = True
                        break
            output[r][c] = 0 if has_diff else input_grid[r][c]
    return output
