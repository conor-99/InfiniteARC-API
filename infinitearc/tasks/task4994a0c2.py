# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 4994a0c2
Difficulty: insane

=== Tags ===
- Associate images to images
- Diagonals
- Pattern expansion
- Associate colors to bools

=== Description ===
The task involves transforming an input grid into an output grid by expanding
diagonal segments of non-zero colors into 3x3 blocks. Input grids contain
diagonal patterns (both main and anti-diagonals) where consecutive cells share
the same non-zero color. Each such segment of length ≥2 triggers a deterministic
expansion: for every cell in the segment, the corresponding 3x3 block in the
output grid (centered at the cell's position) is filled with the segment's
color. The expansion process follows a top-left-to-bottom-right traversal order,
ensuring overlapping blocks are resolved by the earliest processed segment.
Zero-value cells (background) are ignored. The output grid size scales to 3× the
input dimensions, creating a visually distinct pattern where diagonal structures
are thickened while preserving color associations. This transformation requires
recognizing diagonal continuity, color-based expansion triggers, and resolving
spatial overlaps through traversal order—combinatorial reasoning that scales
complexity with input density.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    W = random.randint(2, 10)
    H = random.randint(2, 10)
    grid_input = [[0] * W for _ in range(H)]
    num_segments = random.randint(1, 3)
    
    for _ in range(num_segments):
        direction = random.choice(['main', 'anti'])
        color = random.randint(1, 9)
        if direction == 'main':
            r0 = random.randint(0, H - 2)
            c0 = random.randint(0, W - 2)
            max_L = min(H - r0, W - c0)
            if max_L < 2:
                continue
            L = random.randint(2, max_L)
            valid = True
            for i in range(L):
                r = r0 + i
                c = c0 + i
                if grid_input[r][c] != 0:
                    valid = False
                    break
            if not valid:
                continue
            for i in range(L):
                r = r0 + i
                c = c0 + i
                grid_input[r][c] = color
        else:  # anti-diagonal
            r0 = random.randint(0, H - 2)
            c0 = random.randint(1, W - 1)
            max_L = min(H - r0, c0 + 1)
            if max_L < 2:
                continue
            L = random.randint(2, max_L)
            valid = True
            for i in range(L):
                r = r0 + i
                c = c0 - i
                if grid_input[r][c] != 0:
                    valid = False
                    break
            if not valid:
                continue
            for i in range(L):
                r = r0 + i
                c = c0 - i
                grid_input[r][c] = color
    
    W_out = 3 * W
    H_out = 3 * H
    grid_output = [[0] * W_out for _ in range(H_out)]
    
    for r in range(H):
        for c in range(W):
            if grid_input[r][c] != 0:
                color = grid_input[r][c]
                for dr in range(3):
                    for dc in range(3):
                        grid_output[r * 3 + dr][c * 3 + dc] = color
    
    return {'input': grid_input, 'output': grid_output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    H = len(input_grid)
    if H == 0:
        return []
    W = len(input_grid[0])
    W_out = 3 * W
    H_out = 3 * H
    output_grid = [[0] * W_out for _ in range(H_out)]
    
    for r in range(H):
        for c in range(W):
            if input_grid[r][c] != 0:
                color = input_grid[r][c]
                for dr in range(3):
                    for dc in range(3):
                        output_grid[r * 3 + dr][c * 3 + dc] = color
    return output_grid
