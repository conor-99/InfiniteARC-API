# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 13dc9768
Difficulty: insane

=== Tags ===
- Blockwise rule application
- Assemble from parts
- Pattern reflection
- Associate colors to shapes

=== Description ===
Input grids consist of multiple contiguous regions of uniform color (0-9), where
each color corresponds to a unique geometric shape (e.g., color 1 = square,
color 2 = triangle, color 3 = circle, color 4 = pentagon). The shape is
represented by filling its bounding box with the region's color, with the
shape's orientation (e.g., triangle pointing up/down) determined by the color's
parity (even color = upright orientation, odd color = inverted orientation).
The transformation process involves two key steps. First, each region is
replaced with its associated shape pattern within its bounding box. Second, the
entire grid undergoes reflection across a vertical axis determined dynamically:
if the top-left region's color is even, the grid reflects over the vertical
midline; if odd, it reflects over a vertical line positioned at 1/3 of the
grid's width from the left edge. This reflection applies only to the shape
patterns (not original colors), and the output grid is constructed by assembling
the reflected shapes while preserving all region boundaries and color
associations. The task requires identifying color-shape mappings, orientation
rules, and the reflection axis determination through visual pattern analysis.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, continuous_creature

def generate():
    # choose grid size (keep reasonably sized to allow shapes and reflection)
    W = random.randint(6, 20)
    H = random.randint(6, 20)
    # create empty input grid (width W, height H)
    inp = grid(W, H, 0)
    used = set()
    regions = []

    # pick number of regions (at least 2)
    max_regions = min(6, max(2, (W * H) // 8))
    num_regions = random.randint(2, max_regions)
    colors = random.sample(list(range(1, 10)), num_regions)

    # place regions; ensure first region touches the top-left cell (0,0)
    for i, color in enumerate(colors):
        placed = False
        for _ in range(200):
            # choose bbox size
            bbox_w = random.randint(1, min(6, W))
            bbox_h = random.randint(1, min(6, H))
            # if first region ensure it touches (0,0) by placing at offset (0,0)
            if i == 0:
                off_r, off_c = 0, 0
                if bbox_h > H or bbox_w > W:
                    continue
            else:
                off_r = random.randint(0, H - bbox_h)
                off_c = random.randint(0, W - bbox_w)
            area = bbox_w * bbox_h
            if area <= 0:
                continue
            size = random.randint(1, area)
            # generate contiguous shape within bbox
            try:
                rel_pixels = continuous_creature(size, bbox_w, bbox_h)
            except Exception:
                continue
            abs_pixels = [(off_r + r, off_c + c) for (r, c) in rel_pixels]
            # verify within grid and not overlapping existing regions
            conflict = False
            for p in abs_pixels:
                if p[0] < 0 or p[0] >= H or p[1] < 0 or p[1] >= W or p in used:
                    conflict = True
                    break
            if conflict:
                continue
            # place region
            regions.append((color, abs_pixels))
            for p in abs_pixels:
                used.add(p)
            placed = True
            break
        if not placed:
            # fallback create a single pixel region somewhere (prefer non-overlapping)
            for _ in range(200):
                rr = random.randint(0, H - 1)
                cc = random.randint(0, W - 1)
                if (rr, cc) not in used:
                    regions.append((color, [(rr, cc)]))
                    used.add((rr, cc))
                    placed = True
                    break
            if not placed:
                # worst-case, use (0,0)
                regions.append((color, [(0, 0)]))
                used.add((0, 0))
    # fill input grid with regions
    for color, pixels in regions:
        for (r, c) in pixels:
            inp[r][c] = color
    # construct output by replacing each region with its shape in bounding box
    out = grid(W, H, 0)

    def fill_shape_into(out_grid, color, min_r, min_c, max_r, max_c):
        Wb = max_c - min_c + 1
        Hb = max_r - min_r + 1
        shape_idx = (color - 1) % 5
        # rectangle (filled)
        if shape_idx == 0:
            for r in range(min_r, max_r + 1):
                for c in range(min_c, max_c + 1):
                    out_grid[r][c] = color
        # vertical triangle (orientation by parity)
        elif shape_idx == 1:
            for dr in range(Hb):
                if color % 2 == 0:  # upright (apex at top)
                    fill_count = ((dr + 1) * Wb) // Hb
                else:  # inverted (apex at bottom)
                    fill_count = ((Hb - dr) * Wb) // Hb
                if fill_count < 1:
                    fill_count = 1
                start_c = min_c + (Wb - fill_count) // 2
                r = min_r + dr
                for dc in range(fill_count):
                    out_grid[r][start_c + dc] = color
        # diagonal line (thick)
        elif shape_idx == 2:
            for dr in range(Hb):
                if Hb == 1:
                    rel = 0
                else:
                    rel = (dr * (Wb - 1)) // max(1, (Hb - 1))
                if color % 2 == 0:
                    c = min_c + rel
                else:
                    c = min_c + (Wb - 1 - rel)
                r = min_r + dr
                # draw a small thick diagonal
                for cc in (c - 1, c, c + 1):
                    if min_c <= cc <= max_c:
                        out_grid[r][cc] = color
        # diamond (manhattan)
        elif shape_idx == 3:
            center_r = min_r + (Hb - 1) // 2
            center_c = min_c + (Wb - 1) // 2
            radius = max(0, min(Hb, Wb) // 2)
            for r in range(min_r, max_r + 1):
                for c in range(min_c, max_c + 1):
                    if abs(r - center_r) + abs(c - center_c) <= radius:
                        out_grid[r][c] = color
        # plus (cross)
        else:
            center_r = min_r + Hb // 2
            center_c = min_c + Wb // 2
            for c in range(min_c, max_c + 1):
                out_grid[center_r][c] = color
            for r in range(min_r, max_r + 1):
                out_grid[r][center_c] = color

    for color, pixels in regions:
        if not pixels:
            continue
        rows = [p[0] for p in pixels]
        cols = [p[1] for p in pixels]
        min_r, max_r = min(rows), max(rows)
        min_c, max_c = min(cols), max(cols)
        fill_shape_into(out, color, min_r, min_c, max_r, max_c)
    # reflection axis determined by color at top-left (0,0)
    top_left_color = inp[0][0]
    if top_left_color % 2 == 0:
        # reflect across vertical midline (mirror each row)
        out = [row[::-1] for row in out]
    else:
        axis = W // 3
        new_out = grid(W, H, 0)
        for r in range(H):
            for c in range(W):
                v = out[r][c]
                if v == 0:
                    continue
                new_c = 2 * axis - c
                if 0 <= new_c < W:
                    new_out[r][new_c] = v
        out = new_out
    return { "input": inp, "output": out }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # convert to mutable list-of-lists
    grid_in = [list(row) for row in input_grid]
    H = len(grid_in)
    W = len(grid_in[0]) if H else 0
    visited = [[False] * W for _ in range(H)]
    regions = []
    for r in range(H):
        for c in range(W):
            if grid_in[r][c] == 0 or visited[r][c]:
                continue
            color = grid_in[r][c]
            stack = [(r, c)]
            visited[r][c] = True
            pixels = []
            while stack:
                cr, cc = stack.pop()
                pixels.append((cr, cc))
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc] and grid_in[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            regions.append((color, pixels))
    out = [[0 for _ in range(W)] for __ in range(H)]

    def fill_shape(out_grid, color, min_r, min_c, max_r, max_c):
        Wb = max_c - min_c + 1
        Hb = max_r - min_r + 1
        shape_idx = (color - 1) % 5
        if shape_idx == 0:
            for r in range(min_r, max_r + 1):
                for c in range(min_c, max_c + 1):
                    out_grid[r][c] = color
        elif shape_idx == 1:
            for dr in range(Hb):
                if color % 2 == 0:
                    fill_count = ((dr + 1) * Wb) // Hb
                else:
                    fill_count = ((Hb - dr) * Wb) // Hb
                if fill_count < 1:
                    fill_count = 1
                start_c = min_c + (Wb - fill_count) // 2
                r = min_r + dr
                for dc in range(fill_count):
                    out_grid[r][start_c + dc] = color
        elif shape_idx == 2:
            for dr in range(Hb):
                if Hb == 1:
                    rel = 0
                else:
                    rel = (dr * (Wb - 1)) // max(1, (Hb - 1))
                if color % 2 == 0:
                    c = min_c + rel
                else:
                    c = min_c + (Wb - 1 - rel)
                r = min_r + dr
                for cc in (c - 1, c, c + 1):
                    if min_c <= cc <= max_c:
                        out_grid[r][cc] = color
        elif shape_idx == 3:
            center_r = min_r + (Hb - 1) // 2
            center_c = min_c + (Wb - 1) // 2
            radius = max(0, min(Hb, Wb) // 2)
            for r in range(min_r, max_r + 1):
                for c in range(min_c, max_c + 1):
                    if abs(r - center_r) + abs(c - center_c) <= radius:
                        out_grid[r][c] = color
        else:
            center_r = min_r + Hb // 2
            center_c = min_c + Wb // 2
            for c in range(min_c, max_c + 1):
                out_grid[center_r][c] = color
            for r in range(min_r, max_r + 1):
                out_grid[r][center_c] = color

    for color, pixels in regions:
        if not pixels:
            continue
        rows = [p[0] for p in pixels]
        cols = [p[1] for p in pixels]
        min_r, max_r = min(rows), max(rows)
        min_c, max_c = min(cols), max(cols)
        fill_shape(out, color, min_r, min_c, max_r, max_c)

    top_left_color = grid_in[0][0] if H and W else 0
    if top_left_color % 2 == 0:
        out = [row[::-1] for row in out]
    else:
        axis = W // 3
        new_out = [[0 for _ in range(W)] for __ in range(H)]
        for r in range(H):
            for c in range(W):
                v = out[r][c]
                if v == 0:
                    continue
                new_c = 2 * axis - c
                if 0 <= new_c < W:
                    new_out[r][new_c] = v
        out = new_out
    return out

