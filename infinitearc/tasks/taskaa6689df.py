# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: aa6689df
Difficulty: hard

=== Tags ===
- Goal conditioned path
- Tunnel connection
- Pattern rotation
- Count touches

=== Description ===
The input grid features a background (color 0), a single goal cell (color 1),
multiple tunnel pairs (each pair consists of two adjacent cells of the same
color 2-9, forming horizontal or vertical connections), and a token cell (color
8) positioned on the left edge. The token begins moving right. When the token
enters a tunnel cell, it teleports to the paired cell of the same color, rotates
its direction 90Â° clockwise, and increments the tunnel's touch count. Tunnels
deactivate (stop teleporting) after two touches. The output grid depicts the
token's path: initial segments in color 8 until the first tunnel, followed by
segments in the tunnel's color after each teleportation. If a tunnel is
deactivated (count=2), the token moves normally without teleporting. The path
terminates upon reaching the goal cell (color 1), with all tunnels and the goal
visible in their original positions. The transformation requires tracking tunnel
touch counts and dynamically adjusting path colors based on interaction with
tunnels.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid


def rotate_clockwise(d):
    dr, dc = d
    if (dr, dc) == (0, 1):
        return (1, 0)
    if (dr, dc) == (1, 0):
        return (0, -1)
    if (dr, dc) == (0, -1):
        return (-1, 0)
    return (0, 1)


def in_bounds(pos, n):
    r, c = pos
    return 0 <= r < n and 0 <= c < n


def generate():
    # Attempt generation until a valid configuration is found.
    for attempt in range(1000):
        n = random.randint(15, 20)
        input_grid = grid(n, n, 0)

        # Place token (8) on left edge, not on corners to leave room
        token_r = random.randint(2, n - 3)
        token = (token_r, 0)
        input_grid[token_r][0] = 8

        # Build a chain of tunnels that cause clockwise turns only
        num_tunnels = random.randint(2, 4)
        colors = random.sample(list(range(2, 10)), num_tunnels)

        dir = (0, 1)  # start moving right (east)
        cur = token
        pair_positions = {}  # maps a tunnel cell -> its paired cell
        occupied = {token}
        success = True

        # Place tunnels along the path; each tunnel is two adjacent cells
        for color in colors:
            placed = False
            # Try several distances for this tunnel
            for _ in range(50):
                # choose a modest forward distance so the chain fits comfortably
                d = random.randint(2, max(2, n // 4))
                entry = (cur[0] + dir[0] * d, cur[1] + dir[1] * d)
                partner = (entry[0] + dir[0], entry[1] + dir[1])
                if not (in_bounds(entry, n) and in_bounds(partner, n)):
                    continue
                if entry in occupied or partner in occupied:
                    continue
                # ensure we don't place over the left edge token at col 0 except token itself
                if entry[1] == 0 or partner[1] == 0:
                    # avoid placing tunnels in the leftmost column
                    continue
                # place
                pair_positions[entry] = partner
                pair_positions[partner] = entry
                input_grid[entry[0]][entry[1]] = color
                input_grid[partner[0]][partner[1]] = color
                occupied.add(entry)
                occupied.add(partner)
                # move to partner location (this is where the token will be after teleport)
                cur = partner
                dir = rotate_clockwise(dir)
                placed = True
                break
            if not placed:
                success = False
                break

        if not success:
            continue

        # Place goal somewhere along the final direction, a bit forward
        placed_goal = False
        for _ in range(200):
            dist = random.randint(2, max(2, n // 3))
            goal = (cur[0] + dir[0] * dist, cur[1] + dir[1] * dist)
            if not in_bounds(goal, n):
                continue
            if goal in occupied:
                continue
            # Avoid goal on left edge
            if goal[1] == 0:
                continue
            input_grid[goal[0]][goal[1]] = 1
            placed_goal = True
            break
        if not placed_goal:
            continue

        # Prepare output as a copy of input (tunnels and goal remain visible)
        output_grid = [row[:] for row in input_grid]

        # Build quick lookup for tunnel color at positions and mapping to partner
        pos_color = {}
        for (r, c), partner in list(pair_positions.items()):
            pos_color[(r, c)] = input_grid[r][c]

        # Simulate token movement and draw the path
        cur = token
        dir = (0, 1)
        current_color = 8
        touch_counts = {col: 0 for col in colors}
        goal_pos = (goal[0], goal[1])

        steps = 0
        max_steps = n * n * 10
        reached = False
        while steps < max_steps:
            steps += 1
            nr = cur[0] + dir[0]
            nc = cur[1] + dir[1]
            if not in_bounds((nr, nc), n):
                break
            val = input_grid[nr][nc]
            # If next cell is a tunnel cell and that tunnel is active
            if (nr, nc) in pos_color:
                color = pos_color[(nr, nc)]
                if touch_counts[color] < 2:
                    touch_counts[color] += 1
                    # teleport to paired cell
                    cur = pair_positions[(nr, nc)]
                    # rotate direction 90 deg clockwise
                    dir = rotate_clockwise(dir)
                    # After teleport the path color changes to the tunnel's color
                    current_color = color
                    # tunnels remain visible in the output; do not paint them
                    continue
                else:
                    # Deactivated tunnel: move normally onto that colored cell
                    cur = (nr, nc)
                    # do not paint tunnel cells
                    if cur == goal_pos:
                        reached = True
                    continue
            else:
                # Normal movement onto a background or the goal
                cur = (nr, nc)
                if cur == goal_pos:
                    reached = True
                    break
                if input_grid[cur[0]][cur[1]] == 0:
                    output_grid[cur[0]][cur[1]] = current_color
                continue

        if not reached:
            # Failed attempt, try again
            continue

        # Safety: ensure input and output are different
        if input_grid == output_grid:
            continue

        return {"input": input_grid, "output": output_grid}

    raise RuntimeError("Could not generate a valid training example")



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable grid
    grid_in = [list(row) for row in input_grid]
    n = len(grid_in)

    # Find token (8) on left edge
    token = None
    for r in range(n):
        if grid_in[r][0] == 8:
            token = (r, 0)
            break
    if token is None:
        return grid_in

    # Find goal (1)
    goal = None
    for r in range(n):
        for c in range(n):
            if grid_in[r][c] == 1:
                goal = (r, c)
                break
        if goal is not None:
            break
    if goal is None:
        return grid_in

    # Identify tunnel pairs: map each tunnel cell to its paired neighbor and record colors
    partner = {}
    pos_color = {}
    visited = set()
    for r in range(n):
        for c in range(n):
            val = grid_in[r][c]
            if 2 <= val <= 9 and (r, c) not in visited:
                # look for the adjacent partner cell
                found = False
                for dr, dc in ((0, 1), (1, 0), (0, -1), (-1, 0)):
                    rr, cc = r + dr, c + dc
                    if 0 <= rr < n and 0 <= cc < n and grid_in[rr][cc] == val:
                        partner[(r, c)] = (rr, cc)
                        partner[(rr, cc)] = (r, c)
                        pos_color[(r, c)] = val
                        pos_color[(rr, cc)] = val
                        visited.add((r, c))
                        visited.add((rr, cc))
                        found = True
                        break
                if not found:
                    # stray colored cell (shouldn't happen in generator)
                    continue

    # Prepare output as a copy of the input (tunnels and goal remain visible)
    output = [row[:] for row in grid_in]

    # Movement helpers
    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    def rotate_clockwise(d):
        # rotate 90 degrees clockwise
        dr, dc = d
        if (dr, dc) == (0, 1):
            return (1, 0)
        if (dr, dc) == (1, 0):
            return (0, -1)
        if (dr, dc) == (0, -1):
            return (-1, 0)
        return (0, 1)

    # Simulate token
    cur = token
    direction = (0, 1)
    current_color = 8
    touch_counts = {c: 0 for c in range(2, 10)}

    steps = 0
    max_steps = n * n * 10
    while cur != goal and steps < max_steps:
        steps += 1
        nr = cur[0] + direction[0]
        nc = cur[1] + direction[1]
        if not (0 <= nr < n and 0 <= nc < n):
            break
        if (nr, nc) in pos_color:
            color = pos_color[(nr, nc)]
            if touch_counts[color] < 2:
                # teleport
                touch_counts[color] += 1
                cur = partner[(nr, nc)]
                direction = rotate_clockwise(direction)
                current_color = color
                continue
            else:
                # deactivated tunnel: move into it normally
                cur = (nr, nc)
                continue
        else:
            # normal movement
            cur = (nr, nc)
            if cur == goal:
                break
            if grid_in[cur[0]][cur[1]] == 0:
                output[cur[0]][cur[1]] = current_color
            continue

    return output

