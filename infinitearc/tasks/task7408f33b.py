# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 7408f33b
Difficulty: very hard

=== Tags ===
- Bidirectional escape
- Energy absorption
- Lattice completion
- Associate colors to patterns

=== Description ===
Input grids consist of a large lattice structure (20x20 minimum) with cells
containing colors 1-9 or background (color 0). The lattice contains scattered
"energy sources" (cells with distinct colors) and incomplete pattern fragments.
A bottom-edge pattern strip lists color-pattern associations: each color
corresponds to a fixed geometric pattern (e.g., color 1 = diagonal line, color 2
= 3x3 square, color 3 = concentric circles).   "Energy absorption" occurs when
an energy source cell absorbs adjacent pattern fragments matching its
association. The absorption triggers bidirectional lattice completion: for each
energy source, the pattern expands in all four cardinal directions until blocked
by existing lattice cells or the grid boundary. The expansion must align with
the pattern's geometry (e.g., a diagonal pattern expands diagonally, not
orthogonally).   "Lattice completion" requires filling all empty cells while
respecting pattern geometry and directionality. Each completed pattern must form
a contiguous, non-overlapping structure matching the color's association. The
output grid preserves all input cells (sources, fragments, and pattern strip)
while filling empty cells to complete the lattice.   "Associate colors to
patterns" means the pattern strip explicitly defines the geometry for each
color, requiring the solver to map color values to their geometric rules without
relying on numerical properties. The task is very hard because patterns may
overlap in complex ways, require multi-step expansion sequences, and demand
precise geometric alignment across the lattice. Input grids feature 5-8 distinct
colors with partially overlapping patterns, creating ambiguous expansion paths
that resolve only through strict adherence to the pattern geometry and
bidirectional absorption rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = 20
    height = 20
    main_height = height - 2
    main_grid = grid(width, main_height, 0)
    colors = random.sample(range(1, 10), 3)
    patterns = ["diagonal", "square", "concentric"]  # Fixed: patterns based on strip order, not color value
    
    strip = grid(width, 2, 0)
    for i, c in enumerate(colors):
        for r in range(2):
            for c_idx in range(2):
                strip[r][i*3 + c_idx] = c
    
    for idx, c in enumerate(colors):
        r = random.randint(0, main_height-1)
        c_pos = random.randint(0, width-1)
        main_grid[r][c_pos] = c
        if patterns[idx] == "diagonal" and r + 1 < main_height and c_pos + 1 < width:
            main_grid[r+1][c_pos+1] = c
        elif patterns[idx] == "square" and c_pos + 1 < width:
            main_grid[r][c_pos+1] = c
        elif patterns[idx] == "concentric" and r + 1 < main_height:
            main_grid[r+1][c_pos] = c
    
    output_grid = [row[:] for row in main_grid]
    for idx, c in enumerate(colors):
        if patterns[idx] == "diagonal":
            cells = []
            for r in range(main_height):
                for c_pos in range(width):
                    if main_grid[r][c_pos] == c:
                        cells.append((r, c_pos))
            if cells:
                k = cells[0][0] - cells[0][1]
                for r in range(main_height):
                    for c_pos in range(width):
                        if (r - c_pos) == k and main_grid[r][c_pos] == 0:
                            output_grid[r][c_pos] = c
        elif patterns[idx] == "square":
            cells = []
            for r in range(main_height):
                for c_pos in range(width):
                    if main_grid[r][c_pos] == c:
                        cells.append((r, c_pos))
            if cells:
                center_r = sum(r for r, _ in cells) // len(cells)
                center_c = sum(c_pos for _, c_pos in cells) // len(cells)
                for dr in [-1, 0, 1]:
                    for dc in [-1, 0, 1]:
                        r_fill = center_r + dr
                        c_fill = center_c + dc
                        if 0 <= r_fill < main_height and 0 <= c_fill < width and main_grid[r_fill][c_fill] == 0:
                            output_grid[r_fill][c_fill] = c
        else:  # concentric
            cells = []
            for r in range(main_height):
                for c_pos in range(width):
                    if main_grid[r][c_pos] == c:
                        cells.append((r, c_pos))
            if cells:
                center_r = sum(r for r, _ in cells) // len(cells)
                center_c = sum(c_pos for _, c_pos in cells) // len(cells)
                for dr in [-1, 0, 1]:
                    for dc in [-1, 0, 1]:
                        r_fill = center_r + dr
                        c_fill = center_c + dc
                        if 0 <= r_fill < main_height and 0 <= c_fill < width and main_grid[r_fill][c_fill] == 0:
                            output_grid[r_fill][c_fill] = c
    
    input_grid = main_grid + strip
    output_grid = output_grid + strip
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    height = len(input_list)
    width = len(input_list[0])
    strip = input_list[-2:]
    color_pattern = {}
    for i in range(0, width, 3):
        color = strip[0][i]
        if color != 0 and color not in color_pattern:
            color_pattern[color] = i // 3
    
    main_grid = input_list[:-2]
    output_grid = [row[:] for row in main_grid]
    
    for color, pattern_idx in color_pattern.items():
        if pattern_idx == 0:
            cells = []
            for r in range(len(main_grid)):
                for c in range(len(main_grid[0])):
                    if main_grid[r][c] == color:
                        cells.append((r, c))
            if cells:
                k = cells[0][0] - cells[0][1]
                for r in range(len(main_grid)):
                    for c in range(len(main_grid[0])):
                        if (r - c) == k and main_grid[r][c] == 0:
                            output_grid[r][c] = color
        elif pattern_idx == 1:
            cells = []
            for r in range(len(main_grid)):
                for c in range(len(main_grid[0])):
                    if main_grid[r][c] == color:
                        cells.append((r, c))
            if cells:
                center_r = sum(r for r, _ in cells) // len(cells)
                center_c = sum(c for _, c in cells) // len(cells)
                for dr in [-1, 0, 1]:
                    for dc in [-1, 0, 1]:
                        r_fill = center_r + dr
                        c_fill = center_c + dc
                        if 0 <= r_fill < len(main_grid) and 0 <= c_fill < len(main_grid[0]) and main_grid[r_fill][c_fill] == 0:
                            output_grid[r_fill][c_fill] = color
        else:
            cells = []
            for r in range(len(main_grid)):
                for c in range(len(main_grid[0])):
                    if main_grid[r][c] == color:
                        cells.append((r, c))
            if cells:
                center_r = sum(r for r, _ in cells) // len(cells)
                center_c = sum(c for _, c in cells) // len(cells)
                for dr in [-1, 0, 1]:
                    for dc in [-1, 0, 1]:
                        r_fill = center_r + dr
                        c_fill = center_c + dc
                        if 0 <= r_fill < len(main_grid) and 0 <= c_fill < len(main_grid[0]) and main_grid[r_fill][c_fill] == 0:
                            output_grid[r_fill][c_fill] = color
    
    return [tuple(row) for row in output_grid + strip]
