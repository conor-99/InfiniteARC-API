# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: ca27b630
Difficulty: medium–hard

=== Tags ===
- Simulate billiards shot
- Spring chain
- Remove singletons
- Count touches

=== Description ===
The input grid consists of colored cells (0-9) on a background (0), where non-
zero cells form connected components (chains) based on horizontal/vertical
adjacency. Singletons—cells with no adjacent cells of the same color—are
removed. Remaining chains are moved as rigid units: horizontal chains (width >
height) shift left until they hit a boundary or another chain, while vertical
chains (height > width) shift up. The movement stops upon collision or boundary
contact. After movement, each chain's final color is adjusted by its "touch
count"—the number of boundary collisions during movement (e.g., 1 touch → color
+1, 2 touches → color +2, modulo 9). The output grid reflects moved chains,
removed singletons, and color-adjusted components based on touch counts.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = common.grid(width, height, 0)
    
    num_chains = random.randint(3, 5)
    for _ in range(num_chains):
        sprite_type = random.choice(['el', 'aitch', 'you'])
        pixels = common.rand_sprite(sprite_type, width, height)
        min_r = random.randint(0, height - 1)
        min_c = random.randint(0, width - 1)
        shifted_pixels = [(r + min_r, c + min_c) for (r, c) in pixels]
        shifted_pixels = [(r, c) for (r, c) in shifted_pixels if 0 <= r < height and 0 <= c < width]
        if not shifted_pixels:
            continue
        color = random.randint(1, 9)
        for (r, c) in shifted_pixels:
            input_grid[r][c] = color
    
    num_singletons = random.randint(5, 10)
    for _ in range(num_singletons):
        r = random.randint(0, height - 1)
        c = random.randint(0, width - 1)
        if input_grid[r][c] != 0:
            continue
        color = random.randint(1, 9)
        neighbors = [(r+1, c), (r-1, c), (r, c+1), (r, c-1)]
        valid = True
        for nr, nc in neighbors:
            if 0 <= nr < height and 0 <= nc < width:
                if input_grid[nr][nc] == color:
                    valid = False
                    break
        if valid:
            input_grid[r][c] = color
    
    output_grid = [row[:] for row in input_grid]
    
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] == 0:
                continue
            color = output_grid[r][c]
            has_neighbor = False
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and output_grid[nr][nc] == color:
                    has_neighbor = True
                    break
            if not has_neighbor:
                output_grid[r][c] = 0
    
    visited = [[False] * width for _ in range(height)]
    chains = []
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and output_grid[r][c] != 0:
                color = output_grid[r][c]
                component = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and output_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                chains.append((color, component))
    
    for color, component in chains:
        rows, cols = zip(*component)
        min_r, max_r = min(rows), max(rows)
        min_c, max_c = min(cols), max(cols)
        width_chain = max_c - min_c + 1
        height_chain = max_r - min_r + 1
        if width_chain > height_chain:
            shift = min_c
            new_component = [(r, c - shift) for (r, c) in component]
            touch_count = 1
        else:
            shift = min_r
            new_component = [(r - shift, c) for (r, c) in component]
            touch_count = 1
        new_color = (color + touch_count) % 9
        for (r, c) in new_component:
            output_grid[r][c] = new_color
    
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    
    output_grid = [list(row) for row in input_grid]
    
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] == 0:
                continue
            color = output_grid[r][c]
            has_neighbor = False
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and output_grid[nr][nc] == color:
                    has_neighbor = True
                    break
            if not has_neighbor:
                output_grid[r][c] = 0
    
    visited = [[False] * width for _ in range(height)]
    chains = []
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and output_grid[r][c] != 0:
                color = output_grid[r][c]
                component = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and output_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                chains.append((color, component))
    
    for color, component in chains:
        rows, cols = zip(*component)
        min_r, max_r = min(rows), max(rows)
        min_c, max_c = min(cols), max(cols)
        width_chain = max_c - min_c + 1
        height_chain = max_r - min_r + 1
        if width_chain > height_chain:
            shift = min_c
            new_component = [(r, c - shift) for (r, c) in component]
            touch_count = 1
        else:
            shift = min_r
            new_component = [(r - shift, c) for (r, c) in component]
            touch_count = 1
        new_color = (color + touch_count) % 9
        for (r, c) in new_component:
            output_grid[r][c] = new_color
    
    return output_grid
