# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 194b593d
Difficulty: medium–hard

=== Tags ===
- Color implication network
- Pattern cycle
- Line collision
- Hole punch pattern
- Simple tile repeat

=== Description ===
The input grid consists of a regular tiling of 2×2 blocks, each block containing
a single colored line segment (horizontal, vertical, or diagonal) represented by
one of eight distinct colors (1-8). Each color corresponds to a specific
direction: 1=right, 2=down, 3=left, 4=up, 5=down-right, 6=down-left, 7=up-left,
8=up-right. The line segment occupies the center of the tile's edge (e.g., color
1's segment spans the right edge of the tile, covering the top and bottom right
cells of the 2×2 block).   In the output grid, each line segment is extended in
its implied direction until it either reaches the grid boundary or collides with
a line segment from an adjacent tile moving in a perpendicular direction (e.g.,
a right-pointing line colliding with a down-pointing line). At every collision
point, the cell is set to background (color 0), creating a "hole" in the
pattern. Extended lines are drawn in their original color, except at collision
points. Additionally, each tile's color cycles to the next color in a fixed
sequence (1→2→3→4→5→6→7→8→1), with tiles containing collision points (holes)
retaining the background color (0) instead of cycling. The background color (0)
remains unchanged throughout the transformation. This task requires simultaneous
application of directional extension, collision detection, hole creation, and
cyclic color progression across the tiled structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.choice(range(2, 31, 2))
    height = random.choice(range(2, 31, 2))
    input_grid = grid(width, height, 0)
    for i in range(height // 2):
        for j in range(width // 2):
            d = random.randint(1, 8)
            if d == 1:
                input_grid[2*i][2*j+1] = d
                input_grid[2*i+1][2*j+1] = d
            elif d == 2:
                input_grid[2*i+1][2*j] = d
                input_grid[2*i+1][2*j+1] = d
            elif d == 3:
                input_grid[2*i][2*j] = d
                input_grid[2*i+1][2*j] = d
            elif d == 4:
                input_grid[2*i][2*j] = d
                input_grid[2*i][2*j+1] = d
            elif d == 5:
                input_grid[2*i][2*j] = d
                input_grid[2*i+1][2*j+1] = d
            elif d == 6:
                input_grid[2*i][2*j+1] = d
                input_grid[2*i+1][2*j] = d
            elif d == 7:
                input_grid[2*i][2*j] = d
                input_grid[2*i+1][2*j+1] = d
            elif d == 8:
                input_grid[2*i][2*j+1] = d
                input_grid[2*i+1][2*j] = d
    output_grid = grid(width, height, 0)
    collision_tiles = [[False] * (width // 2) for _ in range(height // 2)]
    for r in range(height):
        for c in range(width):
            cell = input_grid[r][c]
            is_horizontal = cell in [1, 3]
            is_vertical = cell in [2, 4]
            if is_horizontal and is_vertical:
                tile_i = r // 2
                tile_j = c // 2
                collision_tiles[tile_i][tile_j] = True
    for i in range(height // 2):
        for j in range(width // 2):
            if collision_tiles[i][j]:
                output_grid[2*i][2*j] = 0
                output_grid[2*i][2*j+1] = 0
                output_grid[2*i+1][2*j] = 0
                output_grid[2*i+1][2*j+1] = 0
            else:
                d = 0
                for r in [2*i, 2*i+1]:
                    for c in [2*j, 2*j+1]:
                        if input_grid[r][c] > 0:
                            d = input_grid[r][c]
                            break
                    if d > 0:
                        break
                d_cycled = d % 8 + 1
                output_grid[2*i][2*j] = d_cycled
                output_grid[2*i][2*j+1] = d_cycled
                output_grid[2*i+1][2*j] = d_cycled
                output_grid[2*i+1][2*j+1] = d_cycled
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    width = len(input_list[0])
    height = len(input_list)
    output_grid = grid(width, height, 0)
    collision_tiles = [[False] * (width // 2) for _ in range(height // 2)]
    for r in range(height):
        for c in range(width):
            cell = input_list[r][c]
            is_horizontal = cell in [1, 3]
            is_vertical = cell in [2, 4]
            if is_horizontal and is_vertical:
                tile_i = r // 2
                tile_j = c // 2
                collision_tiles[tile_i][tile_j] = True
    for i in range(height // 2):
        for j in range(width // 2):
            if collision_tiles[i][j]:
                output_grid[2*i][2*j] = 0
                output_grid[2*i][2*j+1] = 0
                output_grid[2*i+1][2*j] = 0
                output_grid[2*i+1][2*j+1] = 0
            else:
                d = 0
                for r in [2*i, 2*i+1]:
                    for c in [2*j, 2*j+1]:
                        if input_list[r][c] > 0:
                            d = input_list[r][c]
                            break
                    if d > 0:
                        break
                d_cycled = d % 8 + 1
                output_grid[2*i][2*j] = d_cycled
                output_grid[2*i][2*j+1] = d_cycled
                output_grid[2*i+1][2*j] = d_cycled
                output_grid[2*i+1][2*j+1] = d_cycled
    return output_grid
