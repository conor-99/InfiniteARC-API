# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: b012fd76
Difficulty: mediumâ€“hard

=== Tags ===
- Symbolic spatial binding
- Line collision
- Detect hor lines
- Draw line to nearest object of same color

=== Description ===
Input grids consist of a 2D grid of colors (0-9), where 0 represents background.
Non-zero colors represent distinct objects arranged in rows. Each object (non-
background cell) exists in a row containing at least one other object of the
same color. The output grid is generated by drawing horizontal lines (using the
object's color) between each object and the nearest object of the same color in
its row. Lines are drawn only on background cells (0), preserving existing
objects. For each object, the nearest same-color object is determined by
horizontal distance (left or right), with ties resolved by selecting the
leftmost object. Overlapping lines merge into a single continuous line (no
additional colors or artifacts are introduced). The transformation requires
detecting horizontal spatial relationships, binding color to line direction,
resolving line collisions through merging, and ensuring all lines connect to the
nearest same-color object within the same row without overwriting non-background
elements. The task demands precise spatial reasoning across multiple colors and
row configurations to correctly map input object positions to output line
connections.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    grid = [[0] * width for _ in range(height)]
    
    for r in range(height):
        num_colors = random.randint(1, 3)
        colors = random.sample(range(1, 10), num_colors)
        for color in colors:
            pos1 = random.randint(0, width-3)
            pos2 = random.randint(pos1+2, width-1)
            grid[r][pos1] = color
            grid[r][pos2] = color
    
    output = [row[:] for row in grid]
    for r in range(height):
        color_positions = {}
        for c in range(width):
            if grid[r][c] != 0:
                color = grid[r][c]
                if color not in color_positions:
                    color_positions[color] = []
                color_positions[color].append(c)
        
        for color, positions in color_positions.items():
            positions.sort()
            for i in range(1, len(positions)):
                start, end = positions[i-1], positions[i]
                for c in range(start+1, end):
                    if output[r][c] == 0:
                        output[r][c] = color
    
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    height = len(input_list)
    width = len(input_list[0])
    
    for r in range(height):
        color_positions = {}
        for c in range(width):
            color = input_list[r][c]
            if color != 0:
                if color not in color_positions:
                    color_positions[color] = []
                color_positions[color].append(c)
        
        for color, positions in color_positions.items():
            positions.sort()
            for i in range(1, len(positions)):
                start, end = positions[i-1], positions[i]
                for c in range(start+1, end):
                    if input_list[r][c] == 0:
                        input_list[r][c] = color
    
    return tuple(tuple(row) for row in input_list)
