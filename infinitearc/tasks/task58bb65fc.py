# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 58bb65fc
Difficulty: hard

=== Tags ===
- Associate patterns to colors

=== Description ===
The task involves transforming each input grid by replacing every connected
region (a group of adjacent cells sharing the same color) with a color
determined by the region's size. Specifically, for each connected region of size
N, all cells in that region are replaced with the color N modulo 10. The output
grid maintains the same dimensions as the input, and the transformation is
applied uniformly to all regions. For example, a region consisting of 7 cells
becomes color 7, while a region of 12 cells becomes color 2. This rule requires
recognizing connected components and applying a modular arithmetic operation,
making it challenging to deduce from a small number of examples.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
    output_grid = compute_output(input_grid)
    if input_grid == output_grid:
        return generate()
    return {"input": input_grid, "output": output_grid}

def compute_output(grid):
    rows = len(grid)
    cols = len(grid[0])
    visited = [[False] * cols for _ in range(rows)]
    output = [[0] * cols for _ in range(rows)]
    for r in range(rows):
        for c in range(cols):
            if not visited[r][c]:
                color = grid[r][c]
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                size = len(component)
                output_color = size % 10
                for (cr, cc) in component:
                    output[cr][cc] = output_color
    return output


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    rows = len(input_grid)
    cols = len(input_grid[0])
    visited = [[False] * cols for _ in range(rows)]
    output = [[0] * cols for _ in range(rows)]
    for r in range(rows):
        for c in range(cols):
            if not visited[r][c]:
                color = input_grid[r][c]
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                size = len(component)
                output_color = size % 10
                for (cr, cc) in component:
                    output[cr][cc] = output_color
    return output
