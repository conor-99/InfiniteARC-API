# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 35c8813e
Difficulty: very hard

=== Tags ===
- Multi stage color switch
- State transfer chain
- Symbolic color algebra

=== Description ===
Task Name: State Transfer Cascade  Description: Input grids feature
interconnected orthogonal paths formed by non-background colors (1-9), with
background color 0. Each path is a sequence of cells where the color of each
cell represents a state that propagates sequentially along the path. The
propagation follows a symbolic color algebra: when a cell with color A (source)
is adjacent to a cell with color B (target) in the path direction, the target
cell transforms to a new color C determined by a fixed, task-specific lookup
rule (e.g., A=2, B=5 â†’ C=8). Transformations occur sequentially from start to
end along each path, with each cell's color updating before affecting the next
cell. Background cells (0) remain unchanged. The output grid displays the final
state after all possible sequential transformations along every path have
completed, processed in parallel until no further changes occur. Transformations
must follow path direction (e.g., left-to-right for horizontal paths), and the
lookup rule is consistent across all paths but must be inferred from input-
output examples. The complexity arises from multi-stage color transitions where
each transformation depends on the evolving state of prior cells, requiring
recognition of both path structure and hidden color algebra patterns to resolve
the chain.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

color_algebra = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 9, 8, 7, 6, 5, 4, 3, 2, 1],
    [0, 8, 7, 6, 5, 4, 3, 2, 1, 9],
    [0, 7, 6, 5, 4, 3, 2, 1, 9, 8],
    [0, 6, 5, 4, 3, 2, 1, 9, 8, 7],
    [0, 5, 4, 3, 2, 1, 9, 8, 7, 6],
    [0, 4, 3, 2, 1, 9, 8, 7, 6, 5],
    [0, 3, 2, 1, 9, 8, 7, 6, 5, 4],
    [0, 2, 1, 9, 8, 7, 6, 5, 4, 3],
    [0, 1, 9, 8, 7, 6, 5, 4, 3, 2],
]

def generate():
    while True:
        width = random.randint(5, 25)
        height = random.randint(5, 25)
        input_grid = grid(width, height, 0)
        output_grid = [row[:] for row in input_grid]
        
        for _ in range(random.randint(1, 3)):
            if random.choice([True, False]):
                row = random.randint(0, height-1)
                start = random.randint(0, width-2)
                length = random.randint(2, min(10, width - start))
                for c in range(start, start + length):
                    output_grid[row][c] = random.randint(1, 9)
            else:
                col = random.randint(0, width-1)
                start = random.randint(0, height-2)
                length = random.randint(2, min(10, height - start))
                for r in range(start, start + length):
                    output_grid[r][col] = random.randint(1, 9)
        
        input_grid = [row[:] for row in output_grid]
        
        visited = [[False] * width for _ in range(height)]
        paths = []
        for r in range(height):
            for c in range(width):
                if output_grid[r][c] != 0 and not visited[r][c]:
                    path = []
                    col = c
                    while col < width and output_grid[r][col] != 0:
                        path.append((r, col))
                        visited[r][col] = True
                        col += 1
                    if len(path) > 1:
                        paths.append(path)
                    path = []
                    row = r
                    while row < height and output_grid[row][c] != 0:
                        if not visited[row][c]:
                            path.append((row, c))
                            visited[row][c] = True
                        row += 1
                    if len(path) > 1:
                        paths.append(path)
        
        for path in paths:
            for i in range(1, len(path)):
                r_prev, c_prev = path[i-1]
                r_curr, c_curr = path[i]
                prev_color = output_grid[r_prev][c_prev]
                curr_color = output_grid[r_curr][c_curr]
                new_color = color_algebra[prev_color][curr_color]
                output_grid[r_curr][c_curr] = new_color
        
        if input_grid != output_grid:
            return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random
from common import grid

color_algebra = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 9, 8, 7, 6, 5, 4, 3, 2, 1],
    [0, 8, 7, 6, 5, 4, 3, 2, 1, 9],
    [0, 7, 6, 5, 4, 3, 2, 1, 9, 8],
    [0, 6, 5, 4, 3, 2, 1, 9, 8, 7],
    [0, 5, 4, 3, 2, 1, 9, 8, 7, 6],
    [0, 4, 3, 2, 1, 9, 8, 7, 6, 5],
    [0, 3, 2, 1, 9, 8, 7, 6, 5, 4],
    [0, 2, 1, 9, 8, 7, 6, 5, 4, 3],
    [0, 1, 9, 8, 7, 6, 5, 4, 3, 2],
]

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = [row[:] for row in input_grid]
    
    visited = [[False] * width for _ in range(height)]
    paths = []
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] != 0 and not visited[r][c]:
                path = []
                col = c
                while col < width and output_grid[r][col] != 0:
                    path.append((r, col))
                    visited[r][col] = True
                    col += 1
                if len(path) > 1:
                    paths.append(path)
                path = []
                row = r
                while row < height and output_grid[row][c] != 0:
                    if not visited[row][c]:
                        path.append((row, c))
                        visited[row][c] = True
                    row += 1
                if len(path) > 1:
                    paths.append(path)
    
    for path in paths:
        for i in range(1, len(path)):
            r_prev, c_prev = path[i-1]
            r_curr, c_curr = path[i]
            prev_color = output_grid[r_prev][c_prev]
            curr_color = output_grid[r_curr][c_curr]
            new_color = color_algebra[prev_color][curr_color]
            output_grid[r_curr][c_curr] = new_color
    
    return output_grid
