# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: a22b6740
Difficulty: hard

=== Tags ===
- Associate colors to shapes
- Create image from info
- Shape morphing

=== Description ===
The task involves transforming input grids containing multiple distinct shapes,
each represented by a unique color (1-9), into output grids where each shape is
morphed into a predefined geometric form based on its color association. Input
grids feature connected regions (shapes) of varying sizes and positions, with
each color corresponding to a specific target shape (e.g., color 1 morphs into a
square, color 2 into a diamond, color 3 into a hexagon). The transformation rule
is consistent across all instances of a given color, requiring the solver to
recognize the color-shape association through visual pattern induction. For
example, a triangular shape (color 1) is uniformly replaced with a square-shaped
region of the same color, while a circular shape (color 2) becomes a diamond-
shaped region. The output grid maintains the original color of each shape but
reconfigures its pixel layout to match the target geometric form. The complexity
arises from the need to simultaneously apply multiple color-specific morphing
rules to a grid with overlapping or nested shapes, varying sizes, and non-
obvious visual cues for the color associations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, rand_sprite

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = grid(width, height, 0)
    
    colors = random.sample(range(1, 10), random.randint(3, 5))
    for color in colors:
        sprite_name = random.choice(['el', 'you', 'aitch'])
        pixels = rand_sprite(sprite_name, width, height)
        for (r, c) in pixels:
            if 0 <= r < height and 0 <= c < width:
                input_grid[r][c] = color
    
    output_grid = grid(width, height, 0)
    
    def get_target_shape(color, minr, maxr, minc, maxc):
        h_bb = maxr - minr + 1
        w_bb = maxc - minc + 1
        target = grid(w_bb, h_bb, 0)
        if color == 1:
            for i in range(h_bb):
                for j in range(w_bb):
                    target[i][j] = color
        elif color == 2:
            center_r = h_bb // 2
            center_c = w_bb // 2
            for i in range(h_bb):
                for j in range(w_bb):
                    if abs(i - center_r) + abs(j - center_c) <= min(h_bb, w_bb) // 2:
                        target[i][j] = color
        elif color == 3:
            for i in range(h_bb):
                for j in range(i + 1):
                    if j < w_bb:
                        target[i][j] = color
        else:
            for i in range(h_bb):
                for j in range(w_bb):
                    target[i][j] = color
        return target
    
    visited = [[False] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                region = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    region.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == input_grid[r][c] and not visited[nr][nc]:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                minr = min(p[0] for p in region)
                maxr = max(p[0] for p in region)
                minc = min(p[1] for p in region)
                maxc = max(p[1] for p in region)
                target_shape = get_target_shape(input_grid[r][c], minr, maxr, minc, maxc)
                h_bb = len(target_shape)
                w_bb = len(target_shape[0])
                for i in range(h_bb):
                    for j in range(w_bb):
                        if target_shape[i][j] != 0:
                            output_grid[minr + i][minc + j] = input_grid[r][c]
    
    if input_grid == output_grid:
        return generate()
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid:
        return input_grid
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = [[0] * width for _ in range(height)]
    
    def get_target_shape(color, minr, maxr, minc, maxc):
        h_bb = maxr - minr + 1
        w_bb = maxc - minc + 1
        target = [[0] * w_bb for _ in range(h_bb)]
        if color == 1:
            for i in range(h_bb):
                for j in range(w_bb):
                    target[i][j] = color
        elif color == 2:
            center_r = h_bb // 2
            center_c = w_bb // 2
            for i in range(h_bb):
                for j in range(w_bb):
                    if abs(i - center_r) + abs(j - center_c) <= min(h_bb, w_bb) // 2:
                        target[i][j] = color
        elif color == 3:
            for i in range(h_bb):
                for j in range(i + 1):
                    if j < w_bb:
                        target[i][j] = color
        else:
            for i in range(h_bb):
                for j in range(w_bb):
                    target[i][j] = color
        return target
    
    visited = [[False] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                region = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    region.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == input_grid[r][c] and not visited[nr][nc]:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                minr = min(p[0] for p in region)
                maxr = max(p[0] for p in region)
                minc = min(p[1] for p in region)
                maxc = max(p[1] for p in region)
                target_shape = get_target_shape(input_grid[r][c], minr, maxr, minc, maxc)
                h_bb = len(target_shape)
                w_bb = len(target_shape[0])
                for i in range(h_bb):
                    for j in range(w_bb):
                        if target_shape[i][j] != 0:
                            output_grid[minr + i][minc + j] = input_grid[r][c]
    return output_grid
