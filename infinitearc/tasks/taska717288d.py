# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: a717288d
Difficulty: very hard

=== Tags ===
- Procedural painting
- Analogical goal mapping
- Sand simulation
- Relational projection
- Associate images to numbers
- Follow color path to destination

=== Description ===
Task Name: Analogical Sand Pathway  Description: Input grids feature a uniform
background color (0) overlaid with a complex path network where each cell is
marked with one of four direction colors (1=up, 2=right, 3=down, 4=left),
forming a continuous route from a start point to a destination. Scattered
throughout the grid are sand cells (color 5) not part of the path, and a
reference pattern (a unique 3x3 color arrangement) positioned in the top-left
quadrant. The destination is determined through analogical mapping: the
reference pattern's color distribution relative to its top-left corner is
mirrored to the path's start point, projecting the destination location to a
cell offset by the same relative position. Sand cells follow the path network by
moving one step per direction color (e.g., a cell marked color 1 moves up),
converging toward the destination. Path cells remain unchanged, and sand
movement stops only upon reaching the destination. Output grids show all sand
cells relocated along their path to the destination, with the destination cell
now containing sand (color 5) while preserving the original direction colors and
reference pattern. The transformation requires identifying the reference
pattern's spatial relationship to the path start, projecting the destination,
and executing path-following movement for each sand cell through the direction-
coded network.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = random.randint(10, 15)
    height = random.randint(10, 15)
    grid_input = common.grid(width, height, 0)
    
    ref_color = random.randint(6, 9)
    ref_r, ref_c = random.randint(0, 2), random.randint(0, 2)
    grid_input[ref_r][ref_c] = ref_color
    
    s_row, s_col = 3, 0
    d_row = s_row + ref_r
    d_col = s_col + ref_c
    d_row = min(d_row, height - 1)
    d_col = min(d_col, width - 1)
    
    for col in range(s_col, d_col):
        if s_row < height and col < width:
            grid_input[s_row][col] = 2
    for row in range(s_row, d_row):
        if row < height and d_col < width:
            grid_input[row][d_col] = 3
    
    sand_positions = []
    for r in range(height):
        for c in range(width):
            if grid_input[r][c] == 0:
                in_ref = (r < 3 and c < 3)
                in_path = (r == s_row and s_col <= c < d_col) or (c == d_col and s_row <= r < d_row)
                if not (in_ref or in_path) and random.random() < 0.3:
                    sand_positions.append((r, c))
    
    for r, c in sand_positions:
        grid_input[r][c] = 5
    
    grid_output = [row[:] for row in grid_input]
    grid_output[d_row][d_col] = 5
    for r, c in sand_positions:
        grid_output[r][c] = 0
    
    return {
        "input": grid_input,
        "output": grid_output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to list of lists if it's a tuple
    input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    
    ref_pattern = [row[:3] for row in input_grid[:3]]
    ref_r, ref_c = 1, 1
    for r in range(3):
        for c in range(3):
            if ref_pattern[r][c] not in [0, 1, 2, 3, 4, 5]:
                ref_r, ref_c = r, c
                break
        else:
            continue
        break
    
    s_row, s_col = -1, -1
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] in [1, 2, 3, 4]:
                if s_row == -1 or (r < s_row) or (r == s_row and c < s_col):
                    s_row, s_col = r, c
    if s_row == -1:
        s_row, s_col = 3, 0
    
    d_row = s_row + ref_r
    d_col = s_col + ref_c
    d_row = max(0, min(d_row, height - 1))
    d_col = max(0, min(d_col, width - 1))
    
    output_grid = [row[:] for row in input_grid]
    output_grid[d_row][d_col] = 5
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 5:
                output_grid[r][c] = 0
    return output_grid
