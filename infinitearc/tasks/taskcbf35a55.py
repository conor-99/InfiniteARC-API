# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: cbf35a55
Difficulty: mediumâ€“hard

=== Tags ===
- Impact highlight
- Context sensitive recolor
- Connect all dots of same color
- Move object to nearest corner

=== Description ===
The input grid consists of isolated single-pixel dots of various colors (1-9)
scattered across a uniform background (color 0). For each color present, all
dots of that color must be connected into a single continuous path using the
same color. The connection is formed by filling adjacent cells (horizontally or
vertically) to create a minimal-length path between all dots of that color. The
path is then recolored to a context-sensitive color determined by the most
frequent adjacent background color surrounding the original dots in the input
grid. This recoloring creates an "impact highlight" effect, making the path
visually distinct from the background. Finally, each recolored path is moved to
the nearest grid corner (top-left, top-right, bottom-left, or bottom-right)
based on the centroid of its original position, with the path positioned as
close as possible to the chosen corner without overlapping other paths or grid
boundaries. The background remains unchanged except for the new path placements.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Helper functions

def manhattan(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])


def compute_mst(points):
    # Kruskal over complete graph with Manhattan distances. Returns list of edges as (i,j)
    n = len(points)
    if n <= 1:
        return []
    edges = []
    for i in range(n):
        for j in range(i + 1, n):
            d = manhattan(points[i], points[j])
            edges.append((d, i, j))
    # deterministic sort
    edges.sort()
    parent = list(range(n))

    def find(x):
        while parent[x] != x:
            parent[x] = parent[parent[x]]
            x = parent[x]
        return x

    def union(a, b):
        pa, pb = find(a), find(b)
        if pa == pb:
            return False
        parent[pb] = pa
        return True

    mst = []
    for d, i, j in edges:
        if union(i, j):
            mst.append((i, j))
            if len(mst) == n - 1:
                break
    return mst


def connect_path(p, q):
    # Create a 4-connected Manhattan path between p and q.
    (r1, c1), (r2, c2) = p, q
    cells = []
    # move vertically first (deterministic), then horizontally
    step = 1 if r2 >= r1 else -1
    for r in range(r1, r2 + step, step):
        cells.append((r, c1))
    step = 1 if c2 >= c1 else -1
    for c in range(c1, c2 + step, step):
        cells.append((r2, c))
    return cells


def isolated_candidates(in_grid):
    h = len(in_grid)
    w = len(in_grid[0])
    cand = []
    for r in range(h):
        for c in range(w):
            if in_grid[r][c] != 0:
                continue
            ok = True
            for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                rr, cc = r + dr, c + dc
                if 0 <= rr < h and 0 <= cc < w and in_grid[rr][cc] != 0:
                    ok = False
                    break
            if ok:
                cand.append((r, c))
    return cand


def generate():
    # Try a few times to build a valid configuration
    for attempt in range(200):
        width = random.randint(6, 20)
        height = random.randint(6, 20)
        inp = grid(width, height, 0)

        # choose 2-4 colors to place
        num_colors = random.randint(2, 4)
        colors = random.sample(range(1, 10), num_colors)

        positions_by_color = {}
        success = True

        # place isolated single-pixel dots for each color
        for color in colors:
            num_dots = random.randint(2, 4)
            positions = []
            for _ in range(num_dots):
                cand = isolated_candidates(inp)
                if not cand:
                    success = False
                    break
                pos = random.choice(cand)
                positions.append(pos)
                inp[pos[0]][pos[1]] = color
            if not success:
                break
            positions_by_color[color] = positions

        if not success:
            continue

        # Build output grid by connecting each color's dots, recoloring and moving to corner
        out = grid(width, height, 0)
        occupied = set()
        used_input_colors = set(colors)

        # Process colors in deterministic order (sorted) so generator and solver match
        for color in sorted(colors):
            orig_positions = positions_by_color[color]

            # sort original positions deterministically (row-major) before computing MST
            pts = sorted(list(orig_positions))

            mst_edges = compute_mst(pts)

            path_cells = set(pts)
            for i, j in mst_edges:
                p, q = pts[i], pts[j]
                for cell in connect_path(p, q):
                    path_cells.add(cell)

            # Context-sensitive recolor: look for non-zero neighbours around original dots
            neighbor_counts = {}
            for r, c in orig_positions:
                for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                    rr, cc = r + dr, c + dc
                    if 0 <= rr < height and 0 <= cc < width:
                        val = inp[rr][cc]
                        if val != 0 and val != color:
                            neighbor_counts[val] = neighbor_counts.get(val, 0) + 1

            if neighbor_counts:
                maxcnt = max(neighbor_counts.values())
                candidates = [col for col, cnt in neighbor_counts.items() if cnt == maxcnt]
                context_color = min(candidates)
            else:
                # choose a color not used by any original dots if possible (so highlight contrasts)
                free_colors = [c for c in range(1, 10) if c not in used_input_colors]
                if free_colors:
                    context_color = free_colors[0]
                else:
                    # fallback
                    context_color = 1 if color != 1 else 2

            # Bounding box and relative cells for the path shape
            min_r = min(r for r, c in path_cells)
            max_r = max(r for r, c in path_cells)
            min_c = min(c for r, c in path_cells)
            max_c = max(c for r, c in path_cells)
            box_h = max_r - min_r + 1
            box_w = max_c - min_c + 1
            rel_cells = [(r - min_r, c - min_c) for r, c in path_cells]

            # centroid of the original dots determines corner
            centroid_r = sum(r for r, c in orig_positions) / len(orig_positions)
            centroid_c = sum(c for r, c in orig_positions) / len(orig_positions)
            if centroid_r < height / 2 and centroid_c < width / 2:
                corner = 'tl'
                corner_coord = (0, 0)
            elif centroid_r < height / 2 and centroid_c >= width / 2:
                corner = 'tr'
                corner_coord = (0, width - 1)
            elif centroid_r >= height / 2 and centroid_c < width / 2:
                corner = 'bl'
                corner_coord = (height - 1, 0)
            else:
                corner = 'br'
                corner_coord = (height - 1, width - 1)

            # search for placement (top-left of bounding box) that stays in grid, avoids overlap,
            # and minimizes distance to corner (min over path cells)
            best_key = None
            best_place = None
            for trow in range(0, height - box_h + 1):
                for tcol in range(0, width - box_w + 1):
                    abs_cells = [(trow + rr, tcol + rc) for rr, rc in rel_cells]
                    # check overlap
                    if any((ar, ac) in occupied for ar, ac in abs_cells):
                        continue
                    # compute min distance to corner over path cells
                    dist = min(abs(r - corner_coord[0]) + abs(c - corner_coord[1]) for r, c in abs_cells)
                    key = (dist, trow, tcol)
                    if best_key is None or key < best_key:
                        best_key = key
                        best_place = (trow, tcol, abs_cells)

            if best_place is None:
                # fallback anchored to the corner (within bounds)
                if corner == 'tl':
                    trow, tcol = 0, 0
                elif corner == 'tr':
                    trow, tcol = 0, width - box_w
                elif corner == 'bl':
                    trow, tcol = height - box_h, 0
                else:
                    trow, tcol = height - box_h, width - box_w
                abs_cells = [(trow + rr, tcol + rc) for rr, rc in rel_cells]
            else:
                trow, tcol, abs_cells = best_place

            for r, c in abs_cells:
                out[r][c] = context_color
                occupied.add((r, c))

        return {'input': inp, 'output': out}

    # final fallback if attempts exhausted (shouldn't happen)
    inp = grid(6, 6, 0)
    inp[1][1] = 1
    inp[4][4] = 1
    out = grid(6, 6, 0)
    out[0][0] = 2
    return {'input': inp, 'output': out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable list-of-lists
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])

    def manhattan(a, b):
        return abs(a[0] - b[0]) + abs(a[1] - b[1])

    def compute_mst(points):
        n = len(points)
        if n <= 1:
            return []
        edges = []
        for i in range(n):
            for j in range(i + 1, n):
                d = manhattan(points[i], points[j])
                edges.append((d, i, j))
        edges.sort()
        parent = list(range(n))

        def find(x):
            while parent[x] != x:
                parent[x] = parent[parent[x]]
                x = parent[x]
            return x

        def union(a, b):
            pa, pb = find(a), find(b)
            if pa == pb:
                return False
            parent[pb] = pa
            return True

        mst = []
        for d, i, j in edges:
            if union(i, j):
                mst.append((i, j))
                if len(mst) == n - 1:
                    break
        return mst

    def connect_path(p, q):
        (r1, c1), (r2, c2) = p, q
        cells = []
        step = 1 if r2 >= r1 else -1
        for r in range(r1, r2 + step, step):
            cells.append((r, c1))
        step = 1 if c2 >= c1 else -1
        for c in range(c1, c2 + step, step):
            cells.append((r2, c))
        return cells

    # collect colors and positions
    positions_by_color = {}
    for r in range(height):
        for c in range(width):
            v = grid_in[r][c]
            if v == 0:
                continue
            positions_by_color.setdefault(v, []).append((r, c))

    colors_present = sorted(positions_by_color.keys())
    out = [[0] * width for _ in range(height)]
    occupied = set()
    used_input_colors = set(colors_present)

    for color in colors_present:
        orig_positions = positions_by_color[color]
        if len(orig_positions) < 1:
            continue

        # sort positions deterministically (row-major) to match generator
        pts = sorted(list(orig_positions))

        mst_edges = compute_mst(pts)
        path_cells = set(pts)
        for i, j in mst_edges:
            p, q = pts[i], pts[j]
            for cell in connect_path(p, q):
                path_cells.add(cell)

        # determine context color by looking at neighbours of original dots
        neighbor_counts = {}
        for r, c in orig_positions:
            for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                rr, cc = r + dr, c + dc
                if 0 <= rr < height and 0 <= cc < width:
                    val = grid_in[rr][cc]
                    if val != 0 and val != color:
                        neighbor_counts[val] = neighbor_counts.get(val, 0) + 1
        if neighbor_counts:
            maxcnt = max(neighbor_counts.values())
            candidates = [col for col, cnt in neighbor_counts.items() if cnt == maxcnt]
            context_color = min(candidates)
        else:
            free_colors = [c for c in range(1, 10) if c not in used_input_colors]
            if free_colors:
                context_color = free_colors[0]
            else:
                context_color = 1 if color != 1 else 2

        min_r = min(r for r, c in path_cells)
        max_r = max(r for r, c in path_cells)
        min_c = min(c for r, c in path_cells)
        max_c = max(c for r, c in path_cells)
        box_h = max_r - min_r + 1
        box_w = max_c - min_c + 1
        rel_cells = [(r - min_r, c - min_c) for r, c in path_cells]

        centroid_r = sum(r for r, c in orig_positions) / len(orig_positions)
        centroid_c = sum(c for r, c in orig_positions) / len(orig_positions)
        if centroid_r < height / 2 and centroid_c < width / 2:
            corner = 'tl'
            corner_coord = (0, 0)
        elif centroid_r < height / 2 and centroid_c >= width / 2:
            corner = 'tr'
            corner_coord = (0, width - 1)
        elif centroid_r >= height / 2 and centroid_c < width / 2:
            corner = 'bl'
            corner_coord = (height - 1, 0)
        else:
            corner = 'br'
            corner_coord = (height - 1, width - 1)

        best_key = None
        best_place = None
        for trow in range(0, height - box_h + 1):
            for tcol in range(0, width - box_w + 1):
                abs_cells = [(trow + rr, tcol + rc) for rr, rc in rel_cells]
                if any((ar, ac) in occupied for ar, ac in abs_cells):
                    continue
                dist = min(abs(r - corner_coord[0]) + abs(c - corner_coord[1]) for r, c in abs_cells)
                key = (dist, trow, tcol)
                if best_key is None or key < best_key:
                    best_key = key
                    best_place = (trow, tcol, abs_cells)

        if best_place is None:
            if corner == 'tl':
                trow, tcol = 0, 0
            elif corner == 'tr':
                trow, tcol = 0, width - box_w
            elif corner == 'bl':
                trow, tcol = height - box_h, 0
            else:
                trow, tcol = height - box_h, width - box_w
            abs_cells = [(trow + rr, tcol + rc) for rr, rc in rel_cells]
        else:
            trow, tcol, abs_cells = best_place

        for r, c in abs_cells:
            out[r][c] = context_color
            occupied.add((r, c))

    return out

