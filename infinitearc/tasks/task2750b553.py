# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 2750b553
Difficulty: medium–hard

=== Tags ===
- Spatial signal
- If then color switch
- Color permutation
- Obstacles

=== Description ===
Input grids consist of a 10×10 to 20×20 grid with a background color (0),
obstacles (color 1 forming irregular wall shapes), and a spatial signal—a small
arrow-shaped cluster (color 2) pointing in one of four cardinal directions
(e.g., right, up, down, or left). Adjacent to the signal, a horizontal sequence
of four distinct colors (3, 4, 5, 6) defines a fixed permutation cycle (3→4,
4→5, 5→6, 6→3). The output grid permutes the color of every cell along the
signal's direction (starting from the cell immediately adjacent to the signal)
until encountering an obstacle (color 1), applying the cycle to each cell's
color in sequence. Cells blocked by obstacles are unchanged, and all other
elements (background, obstacles, signal, and non-permuted cells) remain
identical to the input. The permutation cycle is consistent across all examples,
requiring the solver to recognize the directional arrow shape, trace the line of
sight, and apply the cyclic color shift while respecting obstacle boundaries.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    # Grid size
    w = random.randint(10, 20)
    h = random.randint(10, 20)
    grid = common.grid(w, h, 0)

    # Direction and arrow geometry
    directions = ['right', 'left', 'up', 'down']
    direction = random.choice(directions)
    step_map = {'right': (0, 1), 'left': (0, -1), 'up': (-1, 0), 'down': (1, 0)}
    # Offsets for a 3-cell arrow: tip at (r,c) plus two diagonal "tail" pixels behind it
    offsets_map = {
        'right': [(0, 0), (-1, -1), (1, -1)],
        'left': [(0, 0), (-1, 1), (1, 1)],
        'up': [(0, 0), (1, -1), (1, 1)],
        'down': [(0, 0), (-1, -1), (-1, 1)],
    }

    dr_step, dc_step = step_map[direction]
    arrow_offsets = offsets_map[direction]

    # Pick a tip position so that the arrow fits and there is room along the arrow's direction
    attempts = 0
    tip = None
    while attempts < 500:
        attempts += 1
        r = random.randint(1, h - 2)
        c = random.randint(1, w - 2)
        # All arrow offsets must be inside
        ok = True
        for odr, odc in arrow_offsets:
            rr, cc = r + odr, c + odc
            if not (0 <= rr < h and 0 <= cc < w):
                ok = False
                break
        # Ensure at least one cell in the arrow direction exists
        nxt_r, nxt_c = r + dr_step, c + dc_step
        if not (0 <= nxt_r < h and 0 <= nxt_c < w):
            ok = False
        if ok:
            tip = (r, c)
            break
    if tip is None:
        # Fallback: place tip roughly centered
        r = h // 2
        c = w // 2
        tip = (r, c)
        for odr, odc in arrow_offsets:
            rr, cc = r + odr, c + odc
            if 0 <= rr < h and 0 <= cc < w:
                grid[rr][cc] = 2

    r, c = tip

    # Place the signal (arrow-shaped cluster, color 2)
    twos = set()
    for odr, odc in arrow_offsets:
        rr, cc = r + odr, c + odc
        if 0 <= rr < h and 0 <= cc < w:
            grid[rr][cc] = 2
            twos.add((rr, cc))

    # Place a horizontal sequence of 4 colors (3,4,5,6) adjacent to the signal.
    # Find candidate starts so the 4 cells do not overlap the signal and at least one
    # cell is orthogonally adjacent to some signal cell.
    seq_candidates = []
    for sr in range(h):
        for sc in range(w - 3):
            seq_cells = [(sr, sc + j) for j in range(4)]
            if any(p in twos for p in seq_cells):
                continue
            # At least one seq cell must be orthogonally adjacent to the signal cluster
            adjacent = False
            for (srp, scp) in seq_cells:
                for (tr, tc) in twos:
                    if abs(srp - tr) + abs(scp - tc) == 1:
                        adjacent = True
                        break
                if adjacent:
                    break
            if adjacent:
                seq_candidates.append((sr, sc))
    if seq_candidates:
        seq_r, seq_c = random.choice(seq_candidates)
    else:
        # If no perfectly adjacent place was found, choose a non-overlapping place
        placed = False
        for sr in range(h):
            for sc in range(w - 3):
                seq_cells = [(sr, sc + j) for j in range(4)]
                if any(p in twos for p in seq_cells):
                    continue
                seq_r, seq_c = sr, sc
                placed = True
                break
            if placed:
                break
        # If still not placed (very small grid), just place it at a safe corner
        if not placed:
            seq_r, seq_c = 0, 0
            while any((seq_r, seq_c + j) in twos for j in range(4)):
                seq_r += 1
                if seq_r >= h:
                    seq_r = 0
                    seq_c += 1

    for j in range(4):
        grid[seq_r][seq_c + j] = 3 + j

    sequence_positions = {(seq_r, seq_c + j) for j in range(4)}

    # Compute the path of cells in the arrow's direction (starting immediately beyond the tip)
    path = []
    cur_r, cur_c = r + dr_step, c + dc_step
    while 0 <= cur_r < h and 0 <= cur_c < w:
        path.append((cur_r, cur_c))
        cur_r += dr_step
        cur_c += dc_step

    # Ensure there is at least one cell on the path and that at least one of them will be permuted
    if len(path) == 0:
        # Shouldn't happen because we checked room, but just in case: pick a nearby cell
        pr = min(max(r + dr_step, 0), h - 1)
        pc = min(max(c + dc_step, 0), w - 1)
        path = [(pr, pc)]

    # Pick at least one path cell to be a color in {3,4,5,6} so the output differs from input
    chosen_idx = random.randint(0, len(path) - 1)
    chosen_r, chosen_c = path[chosen_idx]
    grid[chosen_r][chosen_c] = random.choice([3, 4, 5, 6])

    # Optionally sprinkle a few other 3-6 colors along the path (but avoid turning them into obstacles)
    for i, (pr, pc) in enumerate(path):
        if (pr, pc) == (chosen_r, chosen_c):
            continue
        if random.random() < 0.18:
            grid[pr][pc] = random.choice([0, 3, 4, 5, 6])

    # Fill the rest of the grid with obstacles (1) randomly to create irregular walls,
    # but never overwrite the signal, the sequence, or the reserved path cells.
    reserved = set(twos) | sequence_positions | set(path)
    obstacle_count = 0
    for rr in range(h):
        for cc in range(w):
            if (rr, cc) in reserved:
                continue
            if random.random() < 0.34:
                grid[rr][cc] = 1
                obstacle_count += 1

    # Make sure at least one obstacle exists somewhere (task description implies obstacles are present)
    if obstacle_count == 0:
        for rr in range(h):
            for cc in range(w):
                if (rr, cc) in reserved:
                    continue
                grid[rr][cc] = 1
                obstacle_count += 1
                break
            if obstacle_count:
                break

    # Create output by applying the permutation cycle along the path until an obstacle or edge
    output = [row[:] for row in grid]
    for (pr, pc) in path:
        if grid[pr][pc] == 1:
            break
        color = grid[pr][pc]
        if 3 <= color <= 6:
            output[pr][pc] = (color + 1) if color < 6 else 3

    return {'input': grid, 'output': output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0]) if h > 0 else 0

    # Find all signal cells (color 2)
    twos = [(r, c) for r in range(h) for c in range(w) if grid[r][c] == 2]
    if not twos:
        return tuple(tuple(row) for row in grid)

    # For each 2-cell, count how many other 2-cells are in its 8-neighborhood
    def neigh_count(cell):
        r, c = cell
        count = 0
        for (rr, cc) in twos:
            if (rr, cc) == (r, c):
                continue
            if abs(rr - r) <= 1 and abs(cc - c) <= 1:
                count += 1
        return count

    # Choose the tip as the 2-cell with maximum neighbor count (the "point" of the arrow)
    twos_sorted = sorted(twos, key=lambda p: (neigh_count(p), -p[0], -p[1]), reverse=True)
    tip = twos_sorted[0]
    tr, tc = tip

    # Other two cells
    others = [p for p in twos if p != tip]
    if others:
        avg_r = sum(p[0] for p in others) / len(others)
        avg_c = sum(p[1] for p in others) / len(others)
    else:
        avg_r, avg_c = tr, tc

    # Determine direction based on where the tail pixels sit relative to the tip
    if avg_c < tc:
        # tail is to the left of tip -> arrow points right
        dr, dc = 0, 1
    elif avg_c > tc:
        # tail is to the right -> arrow points left
        dr, dc = 0, -1
    elif avg_r > tr:
        # tail is below tip -> arrow points up
        dr, dc = -1, 0
    else:
        # tail is above tip -> arrow points down
        dr, dc = 1, 0

    # Start from the cell immediately adjacent to the tip in the pointing direction
    cur_r, cur_c = tr + dr, tc + dc

    # Apply the cycle along the line until encountering an obstacle (color 1) or the edge
    while 0 <= cur_r < h and 0 <= cur_c < w and grid[cur_r][cur_c] != 1:
        color = grid[cur_r][cur_c]
        if 3 <= color <= 6:
            grid[cur_r][cur_c] = 3 if color == 6 else color + 1
        cur_r += dr
        cur_c += dc

    return tuple(tuple(row) for row in grid)

