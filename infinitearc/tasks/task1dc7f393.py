# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 1dc7f393
Difficulty: hard

=== Tags ===
- Inverse rule reconstruction
- Multi object alignment
- Truth table visualization
- Detect symmetry
- Add center crosshair
- Bridge gaps

=== Description ===
Input grids consist of a background color (0) and multiple colored objects
arranged to form a 2×2 truth table structure. Each truth table cell (top-left,
top-right, bottom-left, bottom-right) corresponds to a binary input pair (A, B),
where the presence of a non-zero color in a cell indicates the output of a
logical operation (e.g., AND, OR, XOR) for that input combination. Objects are
placed within fixed subgrid regions (e.g., 3×3 blocks) to align with truth table
positions, with no overlap between cells. The grid dimensions range from 15×15
to 30×30 to accommodate the structure.  The transformation requires: 1.
**Inverse rule reconstruction**: Identify the logical operation (e.g., AND, OR)
governing the truth table by analyzing which input pairs produce a colored
output. 2. **Multi object alignment**: Verify symmetry in the truth table
arrangement (e.g., vertical symmetry where top-left = bottom-left and top-right
= bottom-right, or horizontal symmetry where top-left = top-right and bottom-
left = bottom-right). 3. **Truth table visualization**: Confirm the logical
operation’s consistency across all four truth table cells. 4. **Detect
symmetry**: If symmetry is detected, add a center crosshair (a vertical and
horizontal line of color 5 intersecting at the grid’s geometric center). 5.
**Add center crosshair**: Only apply if symmetry is confirmed; otherwise, omit.
6. **Bridge gaps**: For any two horizontally or vertically adjacent truth table
cells that both contain objects but are separated by background cells, draw a
bridge (a straight line of color 6) connecting their closest non-background
points without overlapping other objects.  The output grid must strictly
preserve the input’s truth table structure while applying these rules
sequentially: symmetry detection first, then crosshair addition, followed by gap
bridging. All bridges and crosshairs are drawn exclusively over background
cells, with no overlap with existing objects or the background. The task demands
recognizing hidden logical patterns and applying geometric transformations based
on structural properties.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(15, 30)
    height = random.randint(15, 30)
    symmetry = random.choice([True, False])
    
    if symmetry:
        op = 'all'
    else:
        op = random.choice(['or', 'nand'])
    
    if op == 'all':
        colored_cells = ['top_left', 'top_right', 'bottom_left', 'bottom_right']
    elif op == 'or':
        colored_cells = ['top_right', 'bottom_left', 'bottom_right']
    elif op == 'nand':
        colored_cells = ['top_left', 'top_right', 'bottom_left']
    
    input_grid = [[0] * width for _ in range(height)]
    block_size = 3
    spacing = random.randint(1, 3)
    
    center_x = width // 2
    center_y = height // 2
    start_x = max(0, center_x - (block_size + spacing) * 1 - 1)
    start_y = max(0, center_y - (block_size + spacing) * 1 - 1)
    
    tl_x, tl_y = start_x, start_y
    tr_x, tr_y = start_x + block_size + spacing, start_y
    bl_x, bl_y = start_x, start_y + block_size + spacing
    br_x, br_y = start_x + block_size + spacing, start_y + block_size + spacing
    
    if 'top_left' in colored_cells:
        input_grid[tl_y + 1][tl_x + 1] = 1
    if 'top_right' in colored_cells:
        input_grid[tr_y + 1][tr_x + 1] = 1
    if 'bottom_left' in colored_cells:
        input_grid[bl_y + 1][bl_x + 1] = 1
    if 'bottom_right' in colored_cells:
        input_grid[br_y + 1][br_x + 1] = 1
    
    output_grid = [row[:] for row in input_grid]
    
    if symmetry:
        cx, cy = width // 2, height // 2
        for r in range(height):
            output_grid[r][cx] = 5
        for c in range(width):
            output_grid[cy][c] = 5
    
    if 'top_left' in colored_cells and 'top_right' in colored_cells:
        start_col = tl_x + block_size
        end_col = tr_x - 1
        if start_col <= end_col:
            row = tl_y + 1
            for c in range(start_col, end_col + 1):
                output_grid[row][c] = 6
    
    if 'bottom_left' in colored_cells and 'bottom_right' in colored_cells:
        start_col = bl_x + block_size
        end_col = br_x - 1
        if start_col <= end_col:
            row = bl_y + 1
            for c in range(start_col, end_col + 1):
                output_grid[row][c] = 6
    
    if 'top_left' in colored_cells and 'bottom_left' in colored_cells:
        start_row = tl_y + block_size
        end_row = bl_y - 1
        if start_row <= end_row:
            col = tl_x + 1
            for r in range(start_row, end_row + 1):
                output_grid[r][col] = 6
    
    if 'top_right' in colored_cells and 'bottom_right' in colored_cells:
        start_row = tr_y + block_size
        end_row = br_y - 1
        if start_row <= end_row:
            col = tr_x + 1
            for r in range(start_row, end_row + 1):
                output_grid[r][col] = 6
    
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    colored = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 1:
                colored.append((r, c))
    colored.sort(key=lambda x: (x[0], x[1]))
    
    output_grid = [list(row) for row in input_grid]
    
    if len(colored) >= 4:
        cx, cy = width // 2, height // 2
        for r in range(height):
            output_grid[r][cx] = 5
        for c in range(width):
            output_grid[cy][c] = 5
    
    # Identify top pair (same row, smallest columns)
    if colored:
        top_row = colored[0][0]
        top_row_cells = [cell for cell in colored if cell[0] == top_row]
        top_row_cells.sort(key=lambda x: x[1])
        if len(top_row_cells) >= 2:
            top_left, top_right = top_row_cells[0], top_row_cells[1]
            start_col = top_left[1] + 2
            end_col = top_right[1] - 2
            for c in range(start_col, end_col + 1):
                if 0 <= c < width:
                    output_grid[top_left[0]][c] = 6
        
        # Identify left pair (same column, smallest rows)
        left_col = colored[0][1]
        left_col_cells = [cell for cell in colored if cell[1] == left_col]
        left_col_cells.sort(key=lambda x: x[0])
        if len(left_col_cells) >= 2:
            top_left, bottom_left = left_col_cells[0], left_col_cells[1]
            start_row = top_left[0] + 2
            end_row = bottom_left[0] - 2
            for r in range(start_row, end_row + 1):
                if 0 <= r < height:
                    output_grid[r][left_col] = 6
        
        # Identify bottom pair (same row, largest rows)
        bottom_row = colored[-1][0]
        bottom_row_cells = [cell for cell in colored if cell[0] == bottom_row]
        bottom_row_cells.sort(key=lambda x: x[1])
        if len(bottom_row_cells) >= 2:
            bottom_left, bottom_right = bottom_row_cells[0], bottom_row_cells[1]
            start_col = bottom_left[1] + 2
            end_col = bottom_right[1] - 2
            for c in range(start_col, end_col + 1):
                if 0 <= c < width:
                    output_grid[bottom_row][c] = 6
        
        # Identify right pair (same column, largest columns)
        right_col = colored[-1][1]
        right_col_cells = [cell for cell in colored if cell[1] == right_col]
        right_col_cells.sort(key=lambda x: x[0])
        if len(right_col_cells) >= 2:
            top_right, bottom_right = right_col_cells[0], right_col_cells[1]
            start_row = top_right[0] + 2
            end_row = bottom_right[0] - 2
            for r in range(start_row, end_row + 1):
                if 0 <= r < height:
                    output_grid[r][right_col] = 6
    
    return output_grid
