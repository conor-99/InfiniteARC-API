# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: dcab6229
Difficulty: very hard

=== Tags ===
- Draw pattern from point
- Draw line of sight
- Bouncing

=== Description ===
**Task Description: Bouncing Light Path**    Input grids feature a single
starting point (a cell with a distinct non-background color, positioned on one
of the grid edges) and walls composed of contiguous horizontal or vertical
segments (each 1–3 cells long) in unique non-background colors. Walls never
touch each other, the starting point, or grid boundaries. The background is
uniform (e.g., black).    The output grid retains all walls unchanged but draws
the complete path of a light beam originating from the starting point. The beam
moves orthogonally inward from the edge (e.g., rightward from a left-edge
starting point) through background cells until it strikes a wall. Upon impact,
the beam reflects off the wall (reversing direction perpendicular to the wall’s
orientation: horizontal walls reverse vertical movement, vertical walls reverse
horizontal movement), changes its color to match the wall’s color, and
continues. This process repeats: the beam travels straight until hitting another
wall, reflects, and updates its color. The path is drawn using the current beam
color for each segment, with the initial segment (before first bounce) in the
starting point’s color.    All paths eventually exit the grid after a finite
number of bounces. Beams never intersect walls at corners, remain single-cell
wide, and never overwrite walls or the starting point. The output grid contains
the original walls and the path, with all other background cells unchanged. The
complexity arises from tracking directional reflections, color transitions
across multiple walls, and ensuring geometric consistency in path generation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid as make_grid


def generate():
    """Generate an ARC task input/output pair for the "Bouncing Light Path" task.

    The generator creates a grid with a single start cell on the border and several
    interior walls (horizontal or vertical segments of length 2 or 3). The beam
    starts from the border cell and travels inward; when it would hit a wall cell
    it reflects (changing the sign of the velocity component perpendicular to the
    wall) and changes its color to the wall color. The path is drawn on a copy of
    the input grid, never overwriting walls or the start cell.
    """
    # Try several times if we stumble into looped configurations
    for global_attempt in range(200):
        width = random.randint(15, 25)
        height = random.randint(15, 25)
        grid_input = make_grid(width, height, 0)

        # Choose an edge start (not a corner) and initial direction
        edge = random.choice(['top', 'bottom', 'left', 'right'])
        if edge == 'top':
            start_r, start_c = 0, random.randint(1, width - 2)
            dr, dc = 1, 0
        elif edge == 'bottom':
            start_r, start_c = height - 1, random.randint(1, width - 2)
            dr, dc = -1, 0
        elif edge == 'left':
            start_r, start_c = random.randint(1, height - 2), 0
            dr, dc = 0, 1
        else:  # right
            start_r, start_c = random.randint(1, height - 2), width - 1
            dr, dc = 0, -1

        start_color = random.randint(1, 9)
        grid_input[start_r][start_c] = start_color

        used_colors = {start_color}
        walls = []  # list of tuples: (color, [(r,c),...], orientation 'h' or 'v')

        # Place a moderate number of walls (segments of length 2 or 3)
        num_walls = random.randint(3, 6)
        place_attempts = 0
        while len(walls) < num_walls and place_attempts < 2000:
            place_attempts += 1
            # choose a new color for the wall
            available = [c for c in range(1, 10) if c not in used_colors]
            if not available:
                break
            color = random.choice(available)
            orientation = random.choice(['h', 'v'])
            length = random.choice([2, 3])

            # pick a candidate position that keeps the wall strictly interior
            if orientation == 'h':
                r = random.randint(1, height - 2)
                # ensure the wall doesn't touch the right boundary
                c_start = random.randint(1, width - length - 1)
                cells = [(r, c) for c in range(c_start, c_start + length)]
            else:
                c = random.randint(1, width - 2)
                r_start = random.randint(1, height - length - 1)
                cells = [(r, c) for r in range(r_start, r_start + length)]

            # validity checks: must not overlap with existing marks, must not be
            # adjacent (including diagonally) to the start cell or other walls,
            # and must remain interior (no cell on border)
            ok = True
            for (rr, cc) in cells:
                if grid_input[rr][cc] != 0:
                    ok = False
                    break
                if rr == 0 or rr == height - 1 or cc == 0 or cc == width - 1:
                    ok = False
                    break
                if abs(rr - start_r) <= 1 and abs(cc - start_c) <= 1:
                    ok = False
                    break
            if not ok:
                continue

            for (_, other_cells, _) in walls:
                for (wr, wc) in other_cells:
                    for (rr, cc) in cells:
                        if abs(wr - rr) <= 1 and abs(wc - cc) <= 1:
                            ok = False
                            break
                    if not ok:
                        break
                if not ok:
                    break
            if not ok:
                continue

            # place the wall
            for (rr, cc) in cells:
                grid_input[rr][cc] = color
            walls.append((color, cells, orientation))
            used_colors.add(color)

        # Ensure we placed at least one wall
        if len(walls) == 0:
            continue

        # Simulate the beam. We reflect when the next cell in the beam
        # direction would be a wall (we never step into wall cells).
        def simulate_and_check():
            grid_output = [row[:] for row in grid_input]
            r, c = start_r, start_c
            vdr, vdc = dr, dc
            current_color = start_color
            seen = set()
            steps = 0
            while True:
                steps += 1
                if steps > 5000:
                    # too long -> probably looped
                    return None
                # record state to detect cycles (position + direction + color)
                state = (r, c, vdr, vdc, current_color)
                if state in seen:
                    return None
                seen.add(state)

                nr, nc = r + vdr, c + vdc
                # beam exits
                if nr < 0 or nr >= height or nc < 0 or nc >= width:
                    return grid_output

                if grid_input[nr][nc] == 0:
                    # advance into a background cell and draw the beam color
                    r, c = nr, nc
                    # never overwrite the starting cell or walls
                    if not (r == start_r and c == start_c):
                        grid_output[r][c] = current_color
                    continue

                # we would hit a wall cell; reflect and change color
                wall_color = grid_input[nr][nc]
                # find orientation from the recorded walls (safe) or by local check
                orientation = None
                for (wc, wcells, orient) in walls:
                    if wc == wall_color:
                        orientation = orient
                        break
                if orientation is None:
                    # fallback: decide by checking neighbours of the impacted cell
                    if (nc - 1 >= 0 and grid_input[nr][nc - 1] == wall_color) or (nc + 1 < width and grid_input[nr][nc + 1] == wall_color):
                        orientation = 'h'
                    else:
                        orientation = 'v'

                current_color = wall_color
                if orientation == 'h':
                    vdr = -vdr
                else:
                    vdc = -vdc
                # do not move into the wall cell
                continue

        grid_output = simulate_and_check()
        # If simulation failed (cycle or too long), try a new layout
        if grid_output is None:
            continue
        # Must be different from input (beam must draw at least one cell)
        if grid_output == grid_input:
            continue

        return {
            'input': grid_input,
            'output': grid_output
        }

    # If generation fails after many attempts, raise
    raise RuntimeError('Could not generate a valid instance after many tries')



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    """Solve the Bouncing Light Path task: draw the beam path on a copy of the
    input grid using the reflection rules described in the generator.
    """
    # Normalize input to a mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Find the start cell: the single non-background cell on the border
    start_r = start_c = None
    # top and bottom rows
    for c in range(width):
        if grid[0][c] != 0:
            start_r, start_c = 0, c
            break
        if grid[height - 1][c] != 0:
            start_r, start_c = height - 1, c
            break
    # left and right columns (if not found yet)
    if start_r is None:
        for r in range(height):
            if grid[r][0] != 0:
                start_r, start_c = r, 0
                break
            if grid[r][width - 1] != 0:
                start_r, start_c = r, width - 1
                break

    if start_r is None:
        # No start found; return the grid unchanged as a fallback
        return grid

    start_color = grid[start_r][start_c]

    # Initial direction based on which border the start cell is on
    if start_r == 0:
        dr, dc = 1, 0
    elif start_r == height - 1:
        dr, dc = -1, 0
    elif start_c == 0:
        dr, dc = 0, 1
    else:
        dr, dc = 0, -1

    r, c = start_r, start_c
    current_color = start_color

    # We'll draw into this output copy (never overwrite walls or the start cell)
    output = [row[:] for row in grid]

    seen = set()
    steps = 0
    while True:
        steps += 1
        if steps > 10000:
            # safety break if something unexpected occurs
            break
        state = (r, c, dr, dc, current_color)
        if state in seen:
            # loop detected; stop
            break
        seen.add(state)

        nr, nc = r + dr, c + dc
        # beam exits
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break

        if grid[nr][nc] == 0:
            # advance into background and paint
            r, c = nr, nc
            if not (r == start_r and c == start_c):
                output[r][c] = current_color
            continue

        # We would hit a wall cell. Determine its orientation by local check.
        wall_color = grid[nr][nc]
        # If either left or right neighbour of the impacted cell has the same
        # wall color, it's a horizontal wall; otherwise it's vertical. This is
        # safe because walls are straight segments (length >= 2 in generator).
        if (nc - 1 >= 0 and grid[nr][nc - 1] == wall_color) or (nc + 1 < width and grid[nr][nc + 1] == wall_color):
            orientation = 'h'
        else:
            orientation = 'v'

        # change beam color and reflect
        current_color = wall_color
        if orientation == 'h':
            dr = -dr
        else:
            dc = -dc
        # do not step into the wall cell; continue the simulation
        continue

    return output

