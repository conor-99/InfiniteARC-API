# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 022c6057
Difficulty: very hard

=== Tags ===
- Pattern completion
- Path instruction following
- Pattern to sequence mapping
- Rule gate simulation
- Draw pattern from point
- Stripe detection

=== Description ===
**Task Name: Stripe Gate Path**  **Description:**   Input grids feature a single
starting cell (color 5) and scattered horizontal or vertical stripes (contiguous
lines of colors 1-4) across the grid. Each stripe color encodes a directional
rule: 1 = left, 2 = right, 3 = up, 4 = down. The output grid must generate a
continuous path starting at the initial cell, moving in the default right
direction, and dynamically changing direction upon intersecting any stripe. The
path traverses only background cells (color 0), altering its direction based
solely on the stripe color encountered. Movement stops when no valid adjacent
background cell remains (all adjacent cells are non-background or grid
boundaries). The output retains all input elements (start cell, stripes) but
overlays the completed path in a new color (color 6). Path completion requires
navigating complex intersections of stripes, ensuring each direction change
strictly adheres to the stripeâ€™s color code, with no overlaps or invalid moves.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def get_direction(color):
    if color == 1:
        return (0, -1)
    elif color == 2:
        return (0, 1)
    elif color == 3:
        return (-1, 0)
    elif color == 4:
        return (1, 0)
    return (0, 1)

def simulate_path(grid, start):
    height = len(grid)
    width = len(grid[0])
    path = [start]
    current = start
    direction = (0, 1)
    max_steps = height * width * 2
    step_count = 0
    while step_count < max_steps:
        next_r = current[0] + direction[0]
        next_c = current[1] + direction[1]
        if next_r < 0 or next_r >= height or next_c < 0 or next_c >= width:
            break
        cell_color = grid[next_r][next_c]
        if cell_color == 0:
            current = (next_r, next_c)
            path.append(current)
        else:
            new_dir = get_direction(cell_color)
            if new_dir == direction:
                break
            direction = new_dir
            continue
        step_count += 1
    return path

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = common.grid(width, height, 0)
    start_r, start_c = random.randint(0, height-1), random.randint(0, width-1)
    grid[start_r][start_c] = 5

    for _ in range(random.randint(2, 5)):
        color = random.randint(1, 4)
        direction = random.choice(['h', 'v'])
        length = random.randint(2, 5)
        if direction == 'h':
            r = random.randint(0, height-1)
            c = random.randint(0, width - length)
            if any(grid[r][c + i] != 0 for i in range(length)):
                continue
            for i in range(length):
                grid[r][c + i] = color
        else:
            c = random.randint(0, width-1)
            r = random.randint(0, height - length)
            if any(grid[r + i][c] != 0 for i in range(length)):
                continue
            for i in range(length):
                grid[r + i][c] = color

    path = simulate_path(grid, (start_r, start_c))
    output = [row[:] for row in grid]
    for (r, c) in path:
        output[r][c] = 6

    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def get_direction(color):
    if color == 1:
        return (0, -1)
    elif color == 2:
        return (0, 1)
    elif color == 3:
        return (-1, 0)
    elif color == 4:
        return (1, 0)
    return (0, 1)

def simulate_path(grid, start):
    height = len(grid)
    width = len(grid[0])
    path = [start]
    current = start
    direction = (0, 1)
    max_steps = height * width * 2
    step_count = 0
    while step_count < max_steps:
        next_r = current[0] + direction[0]
        next_c = current[1] + direction[1]
        if next_r < 0 or next_r >= height or next_c < 0 or next_c >= width:
            break
        cell_color = grid[next_r][next_c]
        if cell_color == 0:
            current = (next_r, next_c)
            path.append(current)
        else:
            new_dir = get_direction(cell_color)
            if new_dir == direction:
                break
            direction = new_dir
            continue
        step_count += 1
    return path

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    start = None
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 5:
                start = (r, c)
                break
        if start:
            break
    if start is None:
        return input_grid
    path = simulate_path(grid, start)
    output = [row[:] for row in grid]
    for (r, c) in path:
        output[r][c] = 6
    return output
