# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: a23b2e0e
Difficulty: hard

=== Tags ===
- Boundary tracing

=== Description ===
Input grids feature a complex, non-rectangular foreground region (color 1)
embedded within a uniform background (color 0), with the region's shape
containing multiple concave and convex features. The foreground region does not
touch the grid edges and has no internal holes. In the top-left corner of the
grid, a 2×2 pattern strip (typically occupying a 3×2 subsection) contains four
distinct colors arranged sequentially, defining a cyclic color sequence for
boundary tracing. The output grid must trace the outer boundary of the
foreground region using this cyclic sequence, starting from the topmost-leftmost
cell of the foreground. The boundary is traced clockwise around the region, with
each boundary cell (adjacent to both foreground and background) replaced by the
current color in the sequence, cycling through the pattern as the tracing
progresses. The pattern strip remains visible in the output, and all non-
boundary cells retain their original colors. The tracing forms a closed loop,
requiring the sequence to repeat seamlessly to cover the entire boundary path.
This task demands precise identification of the boundary path, recognition of
the pattern strip's color sequence, and accurate application of the cyclic
coloring across the boundary's continuous loop.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import math
import common

def generate():
    # Grid size
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    # Start with background 0
    input_grid = common.grid(width, height, 0)

    # Choose four distinct pattern colors that are NOT the foreground color (1)
    pattern_colors = random.sample(list(range(2, 10)), 4)
    # Place the 2x2 pattern in the top-left corner
    input_grid[0][0] = pattern_colors[0]
    input_grid[0][1] = pattern_colors[1]
    input_grid[1][0] = pattern_colors[2]
    input_grid[1][1] = pattern_colors[3]

    # Reserve a margin so the foreground region doesn't touch the edges or the pattern
    shift = 2
    base_w = max(1, width - shift - 1)
    base_h = max(1, height - shift - 1)
    base_area = base_w * base_h

    # Choose a size for the contiguous creature
    min_size = 3
    max_size = min(base_area, 20)
    if max_size < min_size:
        min_size = 1
    size = random.randint(min_size, max_size)

    # Generate a contiguous creature in the base area and shift it to avoid the pattern and edges
    pixels = common.continuous_creature(size, base_w, base_h)
    pixels = [(r + shift, c + shift) for (r, c) in pixels]

    # Paint the foreground region with color 1
    for r, c in pixels:
        input_grid[r][c] = 1

    # Compute the foreground boundary (foreground cells adjacent to background)
    boundary = []
    for r, c in pixels:
        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 0:
                boundary.append((r, c))
                break

    # Deduplicate while preserving order
    boundary = list(dict.fromkeys(boundary))

    # Order the boundary clockwise around the centroid of the foreground
    centroid_r = sum(r for r, c in pixels) / len(pixels)
    centroid_c = sum(c for r, c in pixels) / len(pixels)
    # Sort by angle descending (clockwise) and tie-break by row then col for determinism
    boundary.sort(key=lambda cell: (-math.atan2(cell[0] - centroid_r, cell[1] - centroid_c), cell[0], cell[1]))

    # Rotate so we start at the topmost-leftmost boundary cell
    if boundary:
        start = min(boundary, key=lambda t: (t[0], t[1]))
        if start in boundary:
            idx = boundary.index(start)
            ordered = boundary[idx:] + boundary[:idx]
        else:
            ordered = boundary
    else:
        ordered = []

    # Create output by coloring the ordered boundary with the cyclic pattern
    output_grid = [row[:] for row in input_grid]
    for i, (r, c) in enumerate(ordered):
        output_grid[r][c] = pattern_colors[i % 4]

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import math

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height else 0

    # Read the 2x2 pattern from the top-left corner
    colors = [grid[0][0], grid[0][1], grid[1][0], grid[1][1]]

    # Find all foreground cells (color 1)
    foreground = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == 1]
    if not foreground:
        return tuple(tuple(row) for row in grid)

    # Boundary are foreground cells adjacent to background (0)
    boundary = []
    for r, c in foreground:
        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0:
                boundary.append((r, c))
                break

    boundary = list(dict.fromkeys(boundary))

    # Order boundary clockwise around the centroid of the foreground
    centroid_r = sum(r for r, c in foreground) / len(foreground)
    centroid_c = sum(c for r, c in foreground) / len(foreground)
    boundary.sort(key=lambda cell: (-math.atan2(cell[0] - centroid_r, cell[1] - centroid_c), cell[0], cell[1]))

    # Rotate to start at the topmost-leftmost boundary cell
    if boundary:
        start = min(boundary, key=lambda t: (t[0], t[1]))
        if start in boundary:
            idx = boundary.index(start)
            ordered = boundary[idx:] + boundary[:idx]
        else:
            ordered = boundary
    else:
        ordered = []

    # Color the boundary with the cyclic pattern
    for i, (r, c) in enumerate(ordered):
        grid[r][c] = colors[i % 4]

    return tuple(tuple(row) for row in grid)

