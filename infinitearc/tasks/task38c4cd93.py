# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 38c4cd93
Difficulty: very hard

=== Tags ===
- Paint on collision
- Draw line of sight
- Elastic reflection
- Momentum transfer

=== Description ===
Input grids feature a background color and multiple objects of distinct colors,
each color representing a unique movement direction (e.g., red moves right,
green moves down). Objects move one cell per step in their fixed direction until
exiting the grid or colliding. Upon hitting a grid boundary, objects reflect
elastically (reversing direction) and mark the collision cell with their color.
Upon colliding with another object (occupying the same cell), objects transfer
momentum (reversing both directions) and mark the collision cell with their
color. The output grid visualizes the complete path of all objects as a
cumulative trail, where each cell is colored by the object that traversed it
during movement. Paths include all cells visited until objects exit the grid.
The complexity arises from dynamically tracking direction changes due to
multiple wall reflections and object collisions across sequential movement
steps, requiring simultaneous reasoning about spatial relationships, collision
mechanics, and path propagation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def get_direction(color):
    idx = (color - 1) % 4
    if idx == 0: return (0, 1)
    if idx == 1: return (1, 0)
    if idx == 2: return (0, -1)
    return (-1, 0)

def simulate_path(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    path_grid = grid(width, height, 0)
    current = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] > 0:
                color = input_grid[r][c]
                dr, dc = get_direction(color)
                current.append((color, r, c, dr, dc))
    while current:
        next_positions = []
        exiting = []
        for (color, r, c, dr, dc) in current:
            nr, nc = r + dr, c + dc
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                path_grid[r][c] = color
                exiting.append((color, r, c, dr, dc))
            else:
                next_positions.append((color, nr, nc, dr, dc))
        if not next_positions:
            break
        collision_cells = {}
        for (color, nr, nc, dr, dc) in next_positions:
            key = (nr, nc)
            if key not in collision_cells:
                collision_cells[key] = []
            collision_cells[key].append((color, dr, dc))
        for (nr, nc), items in collision_cells.items():
            if len(items) > 1:
                path_grid[nr][nc] = items[0][0]
                for i in range(len(items)):
                    color, dr, dc = items[i]
                    items[i] = (color, -dr, -dc)
            else:
                path_grid[nr][nc] = items[0][0]
        current = []
        for (nr, nc), items in collision_cells.items():
            for (color, dr, dc) in items:
                current.append((color, nr, nc, dr, dc))
    return path_grid

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = grid(width, height, 0)
    num_objects = random.randint(2, 5)
    colors = random.sample(range(1, 10), num_objects)
    for color in colors:
        r = random.randint(1, height-2)
        c = random.randint(1, width-2)
        input_grid[r][c] = color
    output_grid = simulate_path(input_grid)
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    
    def get_direction(color):
        idx = (color - 1) % 4
        if idx == 0: return (0, 1)
        if idx == 1: return (1, 0)
        if idx == 2: return (0, -1)
        return (-1, 0)
    
    height = len(input_grid)
    width = len(input_grid[0])
    path_grid = [[0] * width for _ in range(height)]
    current = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] > 0:
                color = input_grid[r][c]
                dr, dc = get_direction(color)
                current.append((color, r, c, dr, dc))
    
    while current:
        next_positions = []
        exiting = []
        for (color, r, c, dr, dc) in current:
            nr, nc = r + dr, c + dc
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                path_grid[r][c] = color
                exiting.append((color, r, c, dr, dc))
            else:
                next_positions.append((color, nr, nc, dr, dc))
        if not next_positions:
            break
        collision_cells = {}
        for (color, nr, nc, dr, dc) in next_positions:
            key = (nr, nc)
            if key not in collision_cells:
                collision_cells[key] = []
            collision_cells[key].append((color, dr, dc))
        for (nr, nc), items in collision_cells.items():
            if len(items) > 1:
                path_grid[nr][nc] = items[0][0]
                for i in range(len(items)):
                    color, dr, dc = items[i]
                    items[i] = (color, -dr, -dc)
            else:
                path_grid[nr][nc] = items[0][0]
        current = []
        for (nr, nc), items in collision_cells.items():
            for (color, dr, dc) in items:
                current.append((color, nr, nc, dr, dc))
    
    return path_grid
