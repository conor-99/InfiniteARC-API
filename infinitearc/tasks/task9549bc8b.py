# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 9549bc8b
Difficulty: medium–hard

=== Tags ===
- Bridges
- Layered path system
- Bouncing

=== Description ===
Input grids feature a single continuous path composed of connected cells in a
distinct color, moving in straight horizontal or vertical segments. The path
encounters bridge structures—thin (one cell wide) horizontal or vertical lines
of a unique color—positioned at grid intersections. Upon intersecting a vertical
bridge (a vertical line), the path changes direction from horizontal to vertical
(e.g., moving right turns to move up). Upon intersecting a horizontal bridge (a
horizontal line), the path changes from vertical to horizontal (e.g., moving
down turns to move left). The direction change follows a consistent 90-degree
counterclockwise turn relative to the current movement direction. The output
grid extends the path by adding the next cell(s) in the new direction after the
last bridge intersection, using the same path color. Existing bridges, path
segments, and background cells remain unchanged, with the extension strictly
adhering to the bounce rule without overlapping any elements.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Try multiple times to create a valid configuration that fits the rules.
    for _ in range(1000):
        width = random.randint(6, 12)
        height = random.randint(6, 12)

        # Choose distinct colors for the path and the bridge
        path_color = random.randint(1, 9)
        bridge_color = random.randint(1, 9)
        while bridge_color == path_color:
            bridge_color = random.randint(1, 9)

        # Choose a direction for the straight path segment
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        dr, dc = random.choice(directions)

        # Choose path length (at least 2 so there is an endpoint and a previous cell)
        max_len = max(2, min(5, max(width, height)))
        path_len = random.randint(2, max_len)

        # Pick a start cell and ensure the path, the bridge cell and the extension cell fit
        start_r = random.randint(0, height - 1)
        start_c = random.randint(0, width - 1)

        path_cells = []
        valid = True
        for i in range(path_len):
            r = start_r + dr * i
            c = start_c + dc * i
            if not (0 <= r < height and 0 <= c < width):
                valid = False
                break
            path_cells.append((r, c))
        if not valid:
            continue

        # Bridge must sit immediately after the last path cell in the current direction
        bridge_r = path_cells[-1][0] + dr
        bridge_c = path_cells[-1][1] + dc

        # New direction after bounce is a 90-degree counterclockwise rotation
        new_dr = -dc
        new_dc = dr

        ext_r = bridge_r + new_dr
        ext_c = bridge_c + new_dc

        # All important cells must be inside bounds
        if not (0 <= bridge_r < height and 0 <= bridge_c < width):
            continue
        if not (0 <= ext_r < height and 0 <= ext_c < width):
            continue

        # The extension cell must not overlap the existing path
        if (ext_r, ext_c) in path_cells:
            continue

        # Build the input grid and place path and bridge
        grid = [[0 for _ in range(width)] for _ in range(height)]
        for (r, c) in path_cells:
            grid[r][c] = path_color
        grid[bridge_r][bridge_c] = bridge_color

        # Ensure the extension cell is empty in the input
        if grid[ext_r][ext_c] != 0:
            continue

        # Build output by copying and adding one cell in the rotated direction after the bridge
        output = [row[:] for row in grid]
        output[ext_r][ext_c] = path_color

        return {"input": grid, "output": output}

    # Fallback deterministic example if random attempts fail
    width, height = 6, 6
    path_color, bridge_color = 1, 2
    grid = [[0 for _ in range(width)] for _ in range(height)]
    grid[2][1] = path_color
    grid[2][2] = path_color
    grid[2][3] = path_color
    grid[2][4] = bridge_color
    output = [row[:] for row in grid]
    output[1][4] = path_color
    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert tuple-of-tuples input into mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Collect non-zero colors and their cells
    color_cells = {}
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if v == 0:
                continue
            color_cells.setdefault(v, []).append((r, c))

    # Helper to get same-color neighbors
    neighbors4 = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    path_color = None
    bridge_color = None
    end_cell = None
    prev_cell = None

    # Find the path color by locating an endpoint cell that has exactly one neighbor of the same color
    # and that has, immediately beyond it in the incoming direction, a cell of a different non-zero color
    for color, cells in color_cells.items():
        for (r, c) in cells:
            same_neighbors = []
            for dr, dc in neighbors4:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == color:
                    same_neighbors.append((nr, nc))
            if len(same_neighbors) == 1:
                # Candidate endpoint
                nr, nc = same_neighbors[0]
                # Direction of motion into this endpoint
                dr = r - nr
                dc = c - nc
                # Cell immediately beyond the endpoint in the same direction
                br, bc = r + dr, c + dc
                if 0 <= br < height and 0 <= bc < width:
                    v = grid[br][bc]
                    if v != 0 and v != color:
                        path_color = color
                        bridge_color = v
                        end_cell = (r, c)
                        prev_cell = (nr, nc)
                        break
        if path_color is not None:
            break

    # If we couldn't identify via the endpoint heuristic, we try a looser heuristic:
    if path_color is None:
        # Look for any cell that has exactly one same-color neighbor and an adjacent different non-zero color
        for color, cells in color_cells.items():
            for (r, c) in cells:
                same_neighbors = []
                for dr, dc in neighbors4:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == color:
                        same_neighbors.append((nr, nc))
                if len(same_neighbors) == 1:
                    nr, nc = same_neighbors[0]
                    dr = r - nr
                    dc = c - nc
                    br, bc = r + dr, c + dc
                    if 0 <= br < height and 0 <= bc < width:
                        v = grid[br][bc]
                        if v != 0 and v != color:
                            path_color = color
                            bridge_color = v
                            end_cell = (r, c)
                            prev_cell = (nr, nc)
                            break
            if path_color is not None:
                break

    # If still not found, nothing to do
    if path_color is None:
        return grid

    # Compute incoming direction
    dr = end_cell[0] - prev_cell[0]
    dc = end_cell[1] - prev_cell[1]

    # Confirm the bridge sits immediately in front of the endpoint
    bridge_r = end_cell[0] + dr
    bridge_c = end_cell[1] + dc
    if not (0 <= bridge_r < height and 0 <= bridge_c < width):
        return grid
    if grid[bridge_r][bridge_c] != bridge_color:
        return grid

    # New direction after 90-degree counterclockwise turn
    new_dr = -dc
    new_dc = dr

    next_r = bridge_r + new_dr
    next_c = bridge_c + new_dc
    if 0 <= next_r < height and 0 <= next_c < width and grid[next_r][next_c] == 0:
        grid[next_r][next_c] = path_color

    return grid

