# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 8495e4b5
Difficulty: mediumâ€“hard

=== Tags ===
- Gravity
- Minimal path fill
- Inference from demonstration
- Path merging
- Pattern reflection

=== Description ===
Input grids feature a background color (0), multiple distinct contiguous colored
paths (each path is a single color), and a gravity indicator (a small
directional arrow symbol, e.g., downward-pointing, in a corner). The
transformation applies gravity by shifting all paths in the indicator's
direction until they hit a boundary or another path. Paths touching at a single
cell after shifting are merged into one path using the color of the path that
was lower in the gravity direction. The output grid then displays the minimal
filled path of the merged path (i.e., the path itself, as it is contiguous and
minimal) and reflects this path's pattern across the grid's vertical midline to
form a symmetric design. The reflected pattern ensures that every cell of the
merged path has a mirrored counterpart, creating a visually symmetric output
that maintains all path connections and merges.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random
from copy import deepcopy


def generate():
    # Keep trying until we produce a non-trivial example (at least one path moves)
    for _ in range(100):
        width = random.randint(5, 20)
        height = random.randint(5, 20)
        gravity_dir = random.choice(['down', 'up', 'left', 'right'])
        if gravity_dir == 'down':
            arrow_pos = (height - 1, 0)
            shift_dir = (1, 0)
        elif gravity_dir == 'up':
            arrow_pos = (0, 0)
            shift_dir = (-1, 0)
        elif gravity_dir == 'right':
            arrow_pos = (0, width - 1)
            shift_dir = (0, 1)
        else:  # left
            arrow_pos = (height - 1, width - 1)
            shift_dir = (0, -1)

        # Create input grid and place the gravity arrow (color 1)
        input_grid = common.grid(width, height, 0)
        input_grid[arrow_pos[0]][arrow_pos[1]] = 1

        # Place between 2 and 4 distinct colored contiguous paths
        num_paths = random.randint(2, 4)
        available_colors = list(range(2, 10))
        colors = random.sample(available_colors, num_paths)
        paths = []
        for color in colors:
            placed = False
            for _try in range(60):
                size = random.randint(3, 6)
                sprite = common.continuous_creature(size, width, height)
                dx = random.randint(0, width - 1)
                dy = random.randint(0, height - 1)
                translated = [(r + dy, c + dx) for (r, c) in sprite]
                # Keep only pixels that fall inside the grid
                valid_pixels = [(r, c) for (r, c) in translated if 0 <= r < height and 0 <= c < width]
                if not valid_pixels:
                    continue
                # Avoid overlapping arrow or previously placed paths
                overlap = any(input_grid[r][c] != 0 for (r, c) in valid_pixels)
                if overlap:
                    continue
                # Place this path
                for (r, c) in valid_pixels:
                    input_grid[r][c] = color
                paths.append((color, valid_pixels))
                placed = True
                break
            if not placed:
                # give up on this color
                continue

        if len(paths) < 2:
            # need at least two paths to allow merges and interesting behavior
            continue

        # Simulate gravity: shift paths in the shift_dir until they can no longer move.
        grid_temp = deepcopy(input_grid)
        path_data = [(color, list(pixels)) for color, pixels in paths]
        moved_any = False
        while True:
            moved = False
            # Try to move each path (in the order they were created) one step at a time
            for i in range(len(path_data)):
                color, pixels = path_data[i]
                # compute destination cells for this path
                dests = [(r + shift_dir[0], c + shift_dir[1]) for (r, c) in pixels]
                can_shift = True
                for (nr, nc) in dests:
                    if nr < 0 or nr >= height or nc < 0 or nc >= width:
                        can_shift = False
                        break
                    val = grid_temp[nr][nc]
                    # allow shifting into empty cells or into cells currently occupied by the same path (same color)
                    if val != 0 and val != color:
                        can_shift = False
                        break
                if not can_shift:
                    continue
                # perform the shift: clear old pixels then write new ones
                moved = True
                for (r, c) in pixels:
                    # clear previous position
                    grid_temp[r][c] = 0
                new_pixels = []
                for (r, c) in pixels:
                    nr, nc = r + shift_dir[0], c + shift_dir[1]
                    grid_temp[nr][nc] = color
                    new_pixels.append((nr, nc))
                path_data[i] = (color, new_pixels)
            if not moved:
                break
            moved_any = True

        # require that something actually moved so input != output
        if not moved_any:
            continue

        # Collect final path cells (ignore the arrow color 1)
        final_cells = set()
        for r in range(height):
            for c in range(width):
                if grid_temp[r][c] > 1:
                    final_cells.add((r, c))

        # Find connected components (4-connected)
        visited = set()
        components = []
        for cell in final_cells:
            if cell in visited:
                continue
            comp = set()
            queue = [cell]
            visited.add(cell)
            while queue:
                cr, cc = queue.pop(0)
                comp.add((cr, cc))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = cr + dr, cc + dc
                    if (nr, nc) in final_cells and (nr, nc) not in visited:
                        visited.add((nr, nc))
                        queue.append((nr, nc))
            components.append(comp)

        # For each component pick the color of the path that is "lowest" in gravity direction.
        merged_grid = common.grid(width, height, 0)

        def pick_extreme(comp):
            # Return the extreme cell in comp according to gravity direction.
            if shift_dir[0] == 1:  # down -> largest row
                return max(comp, key=lambda x: (x[0], x[1]))
            if shift_dir[0] == -1:  # up -> smallest row
                return min(comp, key=lambda x: (x[0], x[1]))
            if shift_dir[1] == 1:  # right -> largest column
                return max(comp, key=lambda x: (x[1], x[0]))
            # left -> smallest column
            return min(comp, key=lambda x: (x[1], x[0]))

        for comp in components:
            ex = pick_extreme(comp)
            color_to_use = None
            # path_data holds the final pixels for each original path and their color
            for color, pixels in path_data:
                if ex in pixels:
                    color_to_use = color
                    break
            if color_to_use is None:
                # as a fallback, read the color from the grid (shouldn't normally happen)
                color_to_use = grid_temp[ex[0]][ex[1]] if grid_temp[ex[0]][ex[1]] > 1 else 2
            for (r, c) in comp:
                merged_grid[r][c] = color_to_use

        # Reflect the merged pattern across the vertical midline
        output_grid = common.grid(width, height, 0)
        for r in range(height):
            for c in range(width):
                if merged_grid[r][c] != 0:
                    output_grid[r][c] = merged_grid[r][c]
                    mirror_c = width - 1 - c
                    output_grid[r][mirror_c] = merged_grid[r][c]

        return {
            "input": input_grid,
            "output": output_grid
        }

    # If we fail repeatedly (very unlikely), return a trivial example
    w, h = 6, 6
    inp = common.grid(w, h, 0)
    inp[h - 1][0] = 1
    out = common.grid(w, h, 0)
    return {"input": inp, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
from copy import deepcopy


def p(input_grid):
    grid_list = [list(row) for row in input_grid]
    height = len(grid_list)
    width = len(grid_list[0])

    # Find the gravity arrow (color 1). It is placed in a corner by the generator.
    arrow_pos = None
    for r in range(height):
        for c in range(width):
            if grid_list[r][c] == 1:
                arrow_pos = (r, c)
                break
        if arrow_pos is not None:
            break

    # Default mapping of corner -> gravity, same as generator
    if arrow_pos is None:
        arrow_pos = (height - 1, 0)
    if arrow_pos[0] == height - 1 and arrow_pos[1] == 0:
        shift_dir = (1, 0)   # down
    elif arrow_pos[0] == 0 and arrow_pos[1] == 0:
        shift_dir = (-1, 0)  # up
    elif arrow_pos[0] == 0 and arrow_pos[1] == width - 1:
        shift_dir = (0, 1)   # right
    else:
        shift_dir = (0, -1)  # left

    # Build initial mapping of color -> pixels (colors > 1)
    path_cells = {}
    for r in range(height):
        for c in range(width):
            color = grid_list[r][c]
            if color > 1:
                path_cells.setdefault(color, []).append((r, c))

    path_data = [(color, list(cells)) for color, cells in path_cells.items()]

    # Simulate the same shifting process as the generator
    grid_temp = deepcopy(grid_list)
    moved_any = False
    while True:
        moved = False
        for i in range(len(path_data)):
            color, pixels = path_data[i]
            dests = [(r + shift_dir[0], c + shift_dir[1]) for (r, c) in pixels]
            can_shift = True
            for (nr, nc) in dests:
                if nr < 0 or nr >= height or nc < 0 or nc >= width:
                    can_shift = False
                    break
                val = grid_temp[nr][nc]
                if val != 0 and val != color:
                    can_shift = False
                    break
            if not can_shift:
                continue
            # perform shift
            moved = True
            for (r, c) in pixels:
                grid_temp[r][c] = 0
            new_pixels = []
            for (r, c) in pixels:
                nr, nc = r + shift_dir[0], c + shift_dir[1]
                grid_temp[nr][nc] = color
                new_pixels.append((nr, nc))
            path_data[i] = (color, new_pixels)
        if not moved:
            break
        moved_any = moved_any or moved

    # Collect final path cells (ignore arrow)
    final_cells = set()
    for r in range(height):
        for c in range(width):
            if grid_temp[r][c] > 1:
                final_cells.add((r, c))

    # Connected components (4-connected)
    visited = set()
    components = []
    for cell in final_cells:
        if cell in visited:
            continue
        comp = set()
        queue = [cell]
        visited.add(cell)
        while queue:
            cr, cc = queue.pop(0)
            comp.add((cr, cc))
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = cr + dr, cc + dc
                if (nr, nc) in final_cells and (nr, nc) not in visited:
                    visited.add((nr, nc))
                    queue.append((nr, nc))
        components.append(comp)

    # Function to pick the extreme cell in a component according to gravity
    def pick_extreme(comp):
        if shift_dir[0] == 1:  # down
            return max(comp, key=lambda x: (x[0], x[1]))
        if shift_dir[0] == -1:  # up
            return min(comp, key=lambda x: (x[0], x[1]))
        if shift_dir[1] == 1:  # right
            return max(comp, key=lambda x: (x[1], x[0]))
        return min(comp, key=lambda x: (x[1], x[0]))  # left

    # Assign colors to merged components by looking up which final path contributed the extreme cell
    merged_grid = common.grid(width, height, 0)
    for comp in components:
        ex = pick_extreme(comp)
        color_to_use = None
        for color, pixels in path_data:
            if ex in pixels:
                color_to_use = color
                break
        if color_to_use is None:
            color_to_use = grid_temp[ex[0]][ex[1]] if grid_temp[ex[0]][ex[1]] > 1 else 2
        for (r, c) in comp:
            merged_grid[r][c] = color_to_use

    # Reflect across vertical midline
    output_grid = common.grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            if merged_grid[r][c] != 0:
                output_grid[r][c] = merged_grid[r][c]
                mirror_c = width - 1 - c
                output_grid[r][mirror_c] = merged_grid[r][c]

    return output_grid

