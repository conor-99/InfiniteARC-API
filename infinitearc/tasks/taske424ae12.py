# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: e424ae12
Difficulty: insane

=== Tags ===
- Cave escape
- Paired color flow
- Pattern resizing

=== Description ===
Input grids depict intricate cave systems with two distinct wall color types
(e.g., blue and red) forming interconnected passages. The cave contains a hidden
color pattern strip at the top-left corner, consisting of alternating 2×2 blocks
that define a cyclic sequence (e.g., blue → red → blue → red). Two source cells
of matching colors (e.g., blue and red) are positioned along the left edge,
separated from walls by at least one background cell. The grid features multiple
"exit" markers (e.g., yellow 2×2 blocks) embedded in walls along the right and
top edges, with at least one exit per flow path.  The output grid requires two
independent color flows to propagate from the sources while adhering to the
pattern strip's sequence. Each flow moves rightward through background cells
until encountering a wall of its color, where it reflects upward (blue flow
reflects off blue walls, red flow off red walls). Upon reflection, the flow
continues with the next color in the sequence, and the segment length between
reflections increases by one cell per cycle (e.g., first segment = 1 cell,
second = 2 cells, etc.). Flows never overlap or overwrite walls, pattern strips,
or exit markers. As flows propagate, the pattern strip is "resized" in the
output: its sequence repeats the base pattern but with each subsequent segment
length scaled by the flow's current cycle (e.g., pattern strip shows [blue, red,
blue, red] → output shows [blue, red, blue, red, blue, red, blue, red] for a
flow with two cycles). The final output visually renders both flows with
dynamically sized segments and the resized pattern strip, while preserving all
original cave structure, wall colors, and exit markers.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, all_pixels, grid_intersect, grid_enhance, choice, choices

def generate():
    # Generate square grid size
    grid_size = random.randint(20, 30)
    base_grid = grid(grid_size, grid_size, 0)
    
    # Create background path from left to right and top exits
    path_row = random.randint(5, 10)
    for c in range(grid_size):
        base_grid[path_row][c] = 0
    for r in range(path_row):
        base_grid[r][grid_size-1] = 0
    
    # Add walls (1 and 2) in non-background cells
    wall_colors = [1, 2]
    for r in range(grid_size):
        for c in range(grid_size):
            if base_grid[r][c] == 0:
                continue
            base_grid[r][c] = choice(wall_colors)
    
    # Create pattern strip (top-left, alternating 2x2 blocks)
    pattern_length = random.randint(2, 4)
    pattern_colors = [choice([1, 2]) for _ in range(pattern_length)]
    for r in range(2):
        for i in range(pattern_length):
            for c in range(2):
                col_start = i * 2
                if col_start + c < grid_size:
                    base_grid[r][col_start + c] = pattern_colors[i]
    
    # Place sources (left edge, background cells)
    sources = []
    for i in range(2):
        source_color = pattern_colors[i % len(pattern_colors)]
        # Find valid source position
        for r in range(1, grid_size-1):
            if base_grid[r][0] == 0 and base_grid[r][1] == 0:
                base_grid[r][0] = source_color
                sources.append((r, 0))
                break
    
    # Place exit markers (2x2 yellow blocks in walls)
    exit_color = 4
    for _ in range(2):
        r = random.randint(0, 3)
        c = random.randint(grid_size-4, grid_size-3)
        for dr in range(2):
            for dc in range(2):
                if r + dr < grid_size and c + dc < grid_size:
                    base_grid[r + dr][c + dc] = exit_color
    
    # Create output grid from input (simulate flows)
    output_grid = [row[:] for row in base_grid]
    
    # Simulate flows for each source
    for (r, c) in sources:
        current_pos = (r, c)
        direction = (0, 1)  # Right
        cycle = 0
        
        while True:
            # Calculate segment length
            segment_length = cycle + 1
            
            # Move in current direction for segment_length
            for _ in range(segment_length):
                nr, nc = current_pos[0] + direction[0], current_pos[1] + direction[1]
                
                # Check if out of bounds
                if nr < 0 or nr >= grid_size or nc < 0 or nc >= grid_size:
                    break
                
                # If hit wall of matching color, reflect
                if base_grid[nr][nc] == output_grid[r][c]:
                    # Correct reflection direction: alternate between right and up
                    if direction == (0, 1):
                        direction = (-1, 0)
                    else:
                        direction = (0, 1)
                    break
                
                # If exit, stop
                if output_grid[nr][nc] == 4:
                    break
                
                # Color the path with pattern sequence
                pattern_idx = (cycle * len(pattern_colors)) % len(pattern_colors)
                output_grid[nr][nc] = pattern_colors[pattern_idx]
                current_pos = (nr, nc)
            else:
                # Continue if not broken
                continue
            break
            
            cycle += 1
    
    return {
        "input": base_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert tuple input to list of lists
    grid_size = len(input_grid)
    grid = [list(row) for row in input_grid]
    
    # Extract pattern strip from top-left (2x2 blocks)
    pattern_colors = []
    for r in range(2):
        for c in range(0, min(8, len(grid[0])), 2):
            pattern_colors.append(grid[r][c])
    
    # Identify sources (left edge, color 1 or 2)
    sources = []
    for r in range(grid_size):
        if 0 < grid[r][0] < 3 and grid[r][1] == 0:
            sources.append((r, 0, grid[r][0]))
    
    # Create output grid
    output_grid = [row[:] for row in grid]
    
    # Simulate flows for each source
    for (r, c, source_color) in sources:
        current_pos = (r, c)
        direction = (0, 1)  # Right
        cycle = 0
        
        while True:
            segment_length = cycle + 1
            for _ in range(segment_length):
                nr, nc = current_pos[0] + direction[0], current_pos[1] + direction[1]
                if not (0 <= nr < grid_size and 0 <= nc < grid_size):
                    break
                
                # Check for wall reflection
                if grid[nr][nc] == source_color:
                    # Correct reflection direction: alternate between right and up
                    if direction == (0, 1):
                        direction = (-1, 0)
                    else:
                        direction = (0, 1)
                    break
                
                # Check for exit
                if grid[nr][nc] == 4:
                    break
                
                # Color path with pattern sequence
                pattern_idx = (cycle * len(pattern_colors)) % len(pattern_colors)
                output_grid[nr][nc] = pattern_colors[pattern_idx]
                current_pos = (nr, nc)
            else:
                continue
            break
            cycle += 1
    
    return output_grid
