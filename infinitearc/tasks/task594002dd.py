# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 594002dd
Difficulty: insane

=== Tags ===
- State transfer chain
- Shape attribute projection
- Dependency topological sort
- Size guessing

=== Description ===
# Topological Shape Cascade  Input grids depict a forest of interconnected
geometric shapes (triangles, squares, circles) in distinct colors, each
occupying a contiguous region of the grid. The background color is uniform. Each
shape has a size (number of cells) and a color, where color encodes the shape
type (e.g., red = triangle, blue = square, green = circle). The shapes are
arranged such that some depend on others: a shape's size is determined by the
size of a dependent shape, forming a directed acyclic graph (DAG) of
dependencies.   To generate the output grid: 1. Perform a topological sort of
the shapes based on their dependency graph (e.g., a shape with no dependencies
comes first, followed by those depending on it). 2. For each shape in the sorted
order, project its current size onto all directly dependent shapes (e.g., if
square depends on triangle, square's size becomes the triangle's size). 3.
Adjust each shape's size in the output grid to match the projected size,
maintaining its shape type (e.g., a square remains a square but expands to the
new size). 4. The background remains unchanged, and all projected sizes must be
feasible within the grid's bounds.  The output grid visually shows the cascade
of size adjustments through the dependency chain, with shape types preserved but
sizes altered according to the topological order. The challenge lies in
correctly identifying dependencies from the spatial arrangement (e.g.,
adjacency, color patterns) and applying the size projections in the correct
sequence without overwriting other shapes.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(15, 30)
    height = random.randint(15, 30)
    bg = 0
    input_grid = grid(width, height, bg)
    
    num_shapes = random.randint(2, 4)
    colors = list(range(1, 1 + num_shapes))
    
    dependencies = {colors[i]: colors[i-1] for i in range(1, num_shapes)}
    
    input_sizes = [random.randint(3, 10) for _ in range(num_shapes)]
    for i in range(1, num_shapes):
        if input_sizes[i] == input_sizes[i-1]:
            input_sizes[i] = (input_sizes[i-1] + 1) % 10 or 3
    
    for i, color in enumerate(colors):
        size = input_sizes[i]
        for j in range(min(size, width)):
            input_grid[i][j] = color
    
    output_grid = grid(width, height, bg)
    output_sizes = [input_sizes[0]]
    for i in range(1, num_shapes):
        output_sizes.append(input_sizes[i-1])
    
    for i, color in enumerate(colors):
        size = output_sizes[i]
        for j in range(min(size, width)):
            output_grid[i][j] = color
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid
def p(input_grid):
    colors = set()
    for row in input_grid:
        for cell in row:
            if cell != 0:
                colors.add(cell)
    colors = sorted(colors)
    
    shape_info = {}
    for color in colors:
        top_row = float('inf')
        size = 0
        for r, row in enumerate(input_grid):
            for c, cell in enumerate(row):
                if cell == color:
                    top_row = min(top_row, r)
                    size += 1
        shape_info[color] = (top_row, size)
    
    sorted_colors = sorted(colors, key=lambda c: shape_info[c][0])
    
    dependencies = {}
    for i in range(1, len(sorted_colors)):
        dependencies[sorted_colors[i]] = sorted_colors[i-1]
    
    output_sizes = {}
    for color in sorted_colors:
        if color in dependencies:
            dep_color = dependencies[color]
            output_sizes[color] = shape_info[dep_color][1]
        else:
            output_sizes[color] = shape_info[color][1]
    
    bg = 0
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = grid(width, height, bg)
    
    for color in sorted_colors:
        size = output_sizes[color]
        top_row, _ = shape_info[color]
        for j in range(min(size, width)):
            if top_row < height:
                output_grid[top_row][j] = color
    
    return output_grid
