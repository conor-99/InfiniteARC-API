# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: f93f3805
Difficulty: easy

=== Tags ===
- Divide by n
- Duplicate column pattern
- Detect closed curves

=== Description ===
The input grid contains a single closed loop formed by a contiguous rectangle
perimeter (e.g., the outer edges of a rectangle) made of a single non-zero
color. The loop must be axis-aligned and enclose at least one empty cell inside.
The width of this loop (number of columns it spans horizontally) is determined
as 'n'. The output grid is generated by duplicating each column of the input
grid exactly 'n' times, preserving the original order of columns. For example,
if the input has 5 columns and the loop width is 2, the output will have 10
columns (each input column repeated twice). The transformation is visual and
does not rely on numerical values or pixel-level computations, focusing solely
on the spatial structure of the closed loop to determine the duplication factor.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    n = random.randint(3, 5)
    m = random.randint(3, 30)
    color = random.randint(1, 9)
    input_grid = [[0] * n for _ in range(m)]
    for r in range(m):
        for c in range(n):
            if r == 0 or r == m - 1 or c == 0 or c == n - 1:
                input_grid[r][c] = color
    output_grid = []
    for r in range(m):
        new_row = []
        for c in range(n):
            new_row.extend([input_grid[r][c]] * n)
        output_grid.append(new_row)
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid or not input_grid[0]:
        return []
    n = len(input_grid[0])
    output_grid = []
    for row in input_grid:
        new_row = []
        for val in row:
            new_row.extend([val] * n)
        output_grid.append(new_row)
    return output_grid
