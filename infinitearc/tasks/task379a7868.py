# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 379a7868
Difficulty: hard

=== Tags ===
- Recolor
- Tetris piece packing
- Detect closed curves
- Multi object alignment

=== Description ===
The input grid displays multiple Tetris-like shapes (each a contiguous, single-
color region of non-background pixels) arranged across a background of black
(0). These shapes form closed loops around empty areas, creating enclosed
regions that are visually distinct from the surrounding pieces. The output
requires two sequential transformations: first, detecting all enclosed regions
(background pixels completely surrounded by non-background pixels with no
connection to the grid boundary) and recoloring them to match the color of their
enclosing boundary; second, packing the pieces into a compact top-left-aligned
arrangement by shifting all non-background regions to minimize their bounding
box while preserving their internal structure. This involves aligning every
piece such that their topmost and leftmost pixels are positioned as close to the
grid's top-left corner as possible, ensuring no overlapping between pieces and
creating a visually cohesive, aligned configuration. The task demands
recognizing closed loops through visual pattern analysis, applying color
transformations based on boundary context, and executing multi-object spatial
reorganization without altering the shapes or colors of the original pieces.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def recolor_enclosed(grid):
    height = len(grid)
    width = len(grid[0])
    visited = [[False] * width for _ in range(height)]
    queue = []
    
    for r in range(height):
        for c in [0, width - 1]:
            if grid[r][c] == 0 and not visited[r][c]:
                visited[r][c] = True
                queue.append((r, c))
    for c in range(width):
        for r in [0, height - 1]:
            if grid[r][c] == 0 and not visited[r][c]:
                visited[r][c] = True
                queue.append((r, c))
    
    while queue:
        r, c = queue.pop(0)
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == 0:
                visited[nr][nc] = True
                queue.append((nr, nc))
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 and not visited[r][c]:
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                        grid[r][c] = grid[nr][nc]
                        break
    return grid

def shift_to_top_left(grid):
    height = len(grid)
    width = len(grid[0])
    min_r = height
    min_c = width
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                min_r = min(min_r, r)
                min_c = min(min_c, c)
    
    output = common.grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                new_r = r - min_r
                new_c = c - min_c
                if 0 <= new_r < height and 0 <= new_c < width:
                    output[new_r][new_c] = grid[r][c]
    return output

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = common.grid(width, height, 0)
    num_shapes = random.randint(2, 4)
    colors = common.random_colors(num_shapes, exclude=[0])
    
    for i in range(num_shapes):
        rows, cols = common.hollow_conway(3, 3, 5)
        x = random.randint(1, width - 4)
        y = random.randint(1, height - 4)
        for r, c in zip(rows, cols):
            if 0 <= y + r < height and 0 <= x + c < width:
                input_grid[y + r][x + c] = colors[i]
    
    output_grid = recolor_enclosed(input_grid)
    output_grid = shift_to_top_left(output_grid)
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
import random

def recolor_enclosed(grid):
    height = len(grid)
    width = len(grid[0])
    visited = [[False] * width for _ in range(height)]
    queue = []
    
    for r in range(height):
        for c in [0, width - 1]:
            if grid[r][c] == 0 and not visited[r][c]:
                visited[r][c] = True
                queue.append((r, c))
    for c in range(width):
        for r in [0, height - 1]:
            if grid[r][c] == 0 and not visited[r][c]:
                visited[r][c] = True
                queue.append((r, c))
    
    while queue:
        r, c = queue.pop(0)
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == 0:
                visited[nr][nc] = True
                queue.append((nr, nc))
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 and not visited[r][c]:
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                        grid[r][c] = grid[nr][nc]
                        break
    return grid

def shift_to_top_left(grid):
    height = len(grid)
    width = len(grid[0])
    min_r = height
    min_c = width
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                min_r = min(min_r, r)
                min_c = min(min_c, c)
    
    output = common.grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                new_r = r - min_r
                new_c = c - min_c
                if 0 <= new_r < height and 0 <= new_c < width:
                    output[new_r][new_c] = grid[r][c]
    return output

def p(input_grid):
    output_grid = recolor_enclosed(input_grid)
    output_grid = shift_to_top_left(output_grid)
    return output_grid
