# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: ef0a8ba1
Difficulty: mediumâ€“hard

=== Tags ===
- Energy absorption
- Shape extrusion
- Complete the 2x2 color pattern
- Snap objects to gridlines

=== Description ===
Input grids feature irregularly shaped colored regions (non-zero values) on a
background of 0, with shapes positioned at fractional grid offsets. Output grids
must adhere to four sequential transformation rules:   1. **Snap objects to
gridlines**: Each shape is shifted horizontally/vertically to align its edges
with integer grid coordinates, eliminating fractional positioning.   2. **Energy
absorption via shape extrusion**: Shapes expand outward by one cell in their
primary axis (horizontal/vertical) using their own color, filling adjacent
background cells. Expansion stops at grid boundaries or other shapes.   3. **2x2
pattern completion**: Every 2x2 block is checked for duplicate colors. One
duplicate cell is replaced with the smallest missing color (from 1-9 not present
in the block), ensuring all four colors in the block are unique.   4.
**Consistency enforcement**: After transformation, all 2x2 blocks contain four
distinct colors, shapes are grid-aligned, and extrusion fills background cells
without overlapping.    The rules operate sequentially: snapping enables
accurate extrusion, extrusion creates new color patterns, and pattern completion
resolves duplicates. The output grid must visually satisfy all constraints
without memorizing input patterns.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, rand_sprite, random_color

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    base_grid = grid(width, height, 0)
    num_shapes = random.randint(2, 5)
    for _ in range(num_shapes):
        color = random_color(exclude=[0])
        sprite = rand_sprite(random.choice(['el', 'you', 'aitch']), width, height)
        for (r, c) in sprite:
            if 0 <= r < height and 0 <= c < width:
                base_grid[r][c] = color
    
    dx = random.randint(-width//2, width//2)
    dy = random.randint(-height//2, height//2)
    input_grid = grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            nr, nc = r + dy, c + dx
            if 0 <= nr < height and 0 <= nc < width:
                input_grid[nr][nc] = base_grid[r][c]
    
    output_grid = [row[:] for row in input_grid]
    
    # Snap shapes to top-left
    visited = [[False] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and output_grid[r][c] != 0:
                shape = []
                color = output_grid[r][c]
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    shape.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and output_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                min_r = min(cr for cr, cc in shape)
                min_c = min(cc for cr, cc in shape)
                for cr, cc in shape:
                    output_grid[cr][cc] = 0
                for cr, cc in shape:
                    output_grid[cr - min_r][cc - min_c] = color
    
    # Extrude shapes
    visited = [[False] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and output_grid[r][c] != 0:
                shape = []
                color = output_grid[r][c]
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    shape.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and output_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                min_r, max_r = min(cr for cr, cc in shape), max(cr for cr, cc in shape)
                min_c, max_c = min(cc for cr, cc in shape), max(cc for cr, cc in shape)
                width = max_c - min_c + 1
                height = max_r - min_r + 1
                is_horizontal = width > height
                for cr, cc in shape:
                    if is_horizontal:
                        if cc - 1 >= 0 and output_grid[cr][cc - 1] == 0:
                            output_grid[cr][cc - 1] = color
                        if cc + 1 < width and output_grid[cr][cc + 1] == 0:
                            output_grid[cr][cc + 1] = color
                    else:
                        if cr - 1 >= 0 and output_grid[cr - 1][cc] == 0:
                            output_grid[cr - 1][cc] = color
                        if cr + 1 < height and output_grid[cr + 1][cc] == 0:
                            output_grid[cr + 1][cc] = color
    
    # Complete 2x2 patterns
    for r in range(height - 1):
        for c in range(width - 1):
            colors = [output_grid[r][c], output_grid[r][c+1], output_grid[r+1][c], output_grid[r+1][c+1]]
            if len(set(colors)) < 4:
                present = set(colors)
                missing = [col for col in range(1, 10) if col not in present]
                if missing:
                    smallest = min(missing)
                    for i, col in enumerate(colors):
                        if colors.count(col) > 1:
                            if i == 0:
                                output_grid[r][c] = smallest
                            elif i == 1:
                                output_grid[r][c+1] = smallest
                            elif i == 2:
                                output_grid[r+1][c] = smallest
                            elif i == 3:
                                output_grid[r+1][c+1] = smallest
                            break
    
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    
    # Snap shapes to top-left
    visited = [[False] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and grid[r][c] != 0:
                shape = []
                color = grid[r][c]
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    shape.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                min_r = min(cr for cr, cc in shape)
                min_c = min(cc for cr, cc in shape)
                for cr, cc in shape:
                    grid[cr][cc] = 0
                for cr, cc in shape:
                    grid[cr - min_r][cc - min_c] = color
    
    # Extrude shapes
    visited = [[False] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and grid[r][c] != 0:
                shape = []
                color = grid[r][c]
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    shape.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                min_r, max_r = min(cr for cr, cc in shape), max(cr for cr, cc in shape)
                min_c, max_c = min(cc for cr, cc in shape), max(cc for cr, cc in shape)
                width = max_c - min_c + 1
                height = max_r - min_r + 1
                is_horizontal = width > height
                for cr, cc in shape:
                    if is_horizontal:
                        if cc - 1 >= 0 and grid[cr][cc - 1] == 0:
                            grid[cr][cc - 1] = color
                        if cc + 1 < width and grid[cr][cc + 1] == 0:
                            grid[cr][cc + 1] = color
                    else:
                        if cr - 1 >= 0 and grid[cr - 1][cc] == 0:
                            grid[cr - 1][cc] = color
                        if cr + 1 < height and grid[cr + 1][cc] == 0:
                            grid[cr + 1][cc] = color
    
    # Complete 2x2 patterns
    for r in range(height - 1):
        for c in range(width - 1):
            colors = [grid[r][c], grid[r][c+1], grid[r+1][c], grid[r+1][c+1]]
            if len(set(colors)) < 4:
                present = set(colors)
                missing = [col for col in range(1, 10) if col not in present]
                if missing:
                    smallest = min(missing)
                    for i, col in enumerate(colors):
                        if colors.count(col) > 1:
                            if i == 0:
                                grid[r][c] = smallest
                            elif i == 1:
                                grid[r][c+1] = smallest
                            elif i == 2:
                                grid[r+1][c] = smallest
                            elif i == 3:
                                grid[r+1][c+1] = smallest
                            break
    
    return tuple(tuple(row) for row in grid)
