# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 4a9c82eb
Difficulty: hard

=== Tags ===
- Connect the dots

=== Description ===
The input grid contains multiple isolated points (dots) of a single color, each
surrounded by empty spaces (color 0) or other non-dot elements. The task
requires connecting all these dots in a continuous path using a distinct color.
The connection follows a deterministic sequence: dots are sorted by row (top to
bottom), then by column (left to right). For each consecutive pair in this
sorted order, the path is drawn by moving horizontally first to align with the
next dot's column, then vertically to reach the next dot's row. The output grid
must retain all original elements while adding the connecting path, which uses a
color different from the dots and all other existing elements in the input. The
path must not overlap with non-empty cells (non-dot elements) in the input,
ensuring the transformation is visually consistent and requires multi-step
reasoning to discover.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 20)
    height = random.randint(5, 20)
    grid = [[0] * width for _ in range(height)]
    
    dot_color = random.randint(1, 9)
    # Use deterministic path_color (smallest available)
    path_color = 1 if dot_color != 1 else 2
    
    num_dots = random.randint(2, 5)
    dots = []
    for _ in range(num_dots):
        while True:
            r = random.randint(1, height-2)
            c = random.randint(1, width-2)
            if (r, c) not in dots and (r-1, c) not in dots and (r+1, c) not in dots and (r, c-1) not in dots and (r, c+1) not in dots:
                dots.append((r, c))
                break
        grid[r][c] = dot_color
    
    dots.sort(key=lambda x: (x[0], x[1]))
    
    output = [row[:] for row in grid]
    for i in range(len(dots) - 1):
        r1, c1 = dots[i]
        r2, c2 = dots[i+1]
        
        if c1 < c2:
            for c in range(c1+1, c2+1):
                output[r1][c] = path_color
        else:
            for c in range(c1-1, c2-1, -1):
                output[r1][c] = path_color
        
        if r1 < r2:
            for r in range(r1+1, r2+1):
                output[r][c2] = path_color
        else:
            for r in range(r1-1, r2-1, -1):
                output[r][c2] = path_color
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    
    dot_color = None
    for row in input_grid:
        for val in row:
            if val != 0:
                dot_color = val
                break
        if dot_color is not None:
            break
    if dot_color is None:
        return input_grid
    
    all_colors = set()
    for row in input_grid:
        for val in row:
            if val != 0:
                all_colors.add(val)
    
    # Use deterministic path_color (smallest available)
    path_color = 1
    while path_color in all_colors or path_color == 0:
        path_color += 1
        if path_color > 9:
            path_color = 1
    
    dots = []
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] == dot_color:
                dots.append((r, c))
    
    dots.sort(key=lambda x: (x[0], x[1]))
    
    output = [row[:] for row in input_grid]
    for i in range(len(dots) - 1):
        r1, c1 = dots[i]
        r2, c2 = dots[i+1]
        
        if c1 < c2:
            for c in range(c1+1, c2+1):
                output[r1][c] = path_color
        else:
            for c in range(c1-1, c2-1, -1):
                output[r1][c] = path_color
        
        if r1 < r2:
            for r in range(r1+1, r2+1):
                output[r][c2] = path_color
        else:
            for r in range(r1-1, r2-1, -1):
                output[r][c2] = path_color
    
    return output
