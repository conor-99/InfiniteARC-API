# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: beb083c1
Difficulty: hard

=== Tags ===
- Mirrored attribute binding
- Oscillating rule
- Multi agent path weaving
- Coordinate system translation
- Mimic pattern
- Separate images

=== Description ===
The input grid features a 2D canvas with a vertical mirror axis (centered at the
grid's midpoint) and multiple pairs of agents, each pair consisting of two
identically colored cells positioned symmetrically across the axis. Each agent
begins moving in a sequence governed by an oscillating direction rule: starting
with horizontal movement (right for agents on the left half, left for agents on
the right half), the direction alternates to vertical (down for all agents) on
subsequent steps. Movement continues until the next step would exit the grid.
The output grid renders each agent's complete path as a continuous line of its
color, with paths strictly confined to their respective halves of the grid (left
or right of the mirror axis), ensuring no overlap between mirrored paths. The
transformation requires recognizing mirrored symmetry, tracking alternating
movement directions, and applying coordinate translation relative to the mirror
axis. Paths weave through the grid without intersecting, with each agent's
trajectory mimicking its mirror counterpart's path while adhering to the
oscillating rule. The solution demands simultaneous interpretation of multiple
agents' paths, coordinate system translation, and adherence to the mirror-bound
movement logic.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Choose an odd-sized canvas to ensure a centered vertical mirror axis
    width = random.choice([15, 17, 19, 21, 23, 25, 27, 29])
    height = random.choice([15, 17, 19, 21, 23, 25, 27, 29])
    center = (width - 1) // 2

    # Prepare empty grids
    input_grid = [[0] * width for _ in range(height)]
    output_grid = [[0] * width for _ in range(height)]

    # Number of mirrored agent pairs
    num_pairs = random.randint(2, 5)

    # Use distinct colors and keep them in sorted order so the drawing order is deterministic
    colors = sorted(random.sample(range(1, 10), num_pairs))

    # Choose start rows spaced across the height to reduce accidental path overlap
    rows = []
    block = max(1, height // num_pairs)
    for i in range(num_pairs):
        start = i * block
        end = min((i + 1) * block - 1, height - 1)
        # Avoid selecting the very last row for a start (makes at least one vertical step possible in many cases)
        if end > 0:
            end = end - 0
        if start > end:
            start = 0
            end = height - 1
        rows.append(random.randint(start, end))

    for color, row in zip(colors, rows):
        # Pick left column inside left half and mirror it for the right agent
        left_col = random.randint(0, center - 2)
        right_col = width - 1 - left_col

        # Place agents in the input
        input_grid[row][left_col] = color
        input_grid[row][right_col] = color

        # Generate left agent path (start horizontal to the right, then alternate with down)
        r, c = row, left_col
        step = 1
        path = [(r, c)]
        while True:
            if step % 2 == 1:  # horizontal step (right for left-half agents)
                next_c = c + 1
                if next_c >= center:  # can't cross or step onto the mirror axis
                    break
                c = next_c
            else:  # vertical step (down)
                next_r = r + 1
                if next_r >= height:
                    break
                r = next_r
            path.append((r, c))
            step += 1
        for rr, cc in path:
            output_grid[rr][cc] = color

        # Generate right agent path (start horizontal to the left, then alternate with down)
        r, c = row, right_col
        step = 1
        path = [(r, c)]
        while True:
            if step % 2 == 1:  # horizontal step (left for right-half agents)
                next_c = c - 1
                if next_c <= center:  # can't cross or step onto the mirror axis
                    break
                c = next_c
            else:  # vertical step (down)
                next_r = r + 1
                if next_r >= height:
                    break
                r = next_r
            path.append((r, c))
            step += 1
        for rr, cc in path:
            output_grid[rr][cc] = color

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Normalize input to list of lists
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    center = (width - 1) // 2

    output_grid = [[0] * width for _ in range(height)]

    # Find distinct agent colors and process them in a deterministic order
    colors = sorted({input_grid[r][c] for r in range(height) for c in range(width) if input_grid[r][c] > 0})

    for color in colors:
        # Find the two starting positions for this color (left and right of the mirror axis)
        positions = [(r, c) for r in range(height) for c in range(width) if input_grid[r][c] == color]
        if len(positions) < 2:
            # Defensive: if malformed input, skip this color
            continue
        left_pos = None
        right_pos = None
        for (r, c) in positions:
            if c < center:
                left_pos = (r, c)
            elif c > center:
                right_pos = (r, c)
        if left_pos is None or right_pos is None:
            # If we cannot identify a proper mirrored pair, skip
            continue

        # Reconstruct left agent path (horizontal-right on odd steps, down on even steps)
        r, c = left_pos
        output_grid[r][c] = color
        current_r, current_c = r, c
        step = 1
        while True:
            if step % 2 == 1:
                next_c = current_c + 1
                if next_c >= center:
                    break
                current_c = next_c
            else:
                next_r = current_r + 1
                if next_r >= height:
                    break
                current_r = next_r
            output_grid[current_r][current_c] = color
            step += 1

        # Reconstruct right agent path (horizontal-left on odd steps, down on even steps)
        r, c = right_pos
        output_grid[r][c] = color
        current_r, current_c = r, c
        step = 1
        while True:
            if step % 2 == 1:
                next_c = current_c - 1
                if next_c <= center:
                    break
                current_c = next_c
            else:
                next_r = current_r + 1
                if next_r >= height:
                    break
                current_r = next_r
            output_grid[current_r][current_c] = color
            step += 1

    return output_grid

