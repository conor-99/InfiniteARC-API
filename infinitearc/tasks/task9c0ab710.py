# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 9c0ab710
Difficulty: hard

=== Tags ===
- Recursive pattern copy
- Incremental pattern growth
- Mark extrema corners

=== Description ===
Input grids are medium to large (15×15 to 30×30) with a single background color
(0). Over this background, multiple disjoint, convex patterns of distinct non-
background colors (1–9) are positioned away from grid edges. Each pattern is a
connected region with no holes, forming a rectangular bounding box where all
cells within the box are either part of the pattern or background (no internal
gaps). Patterns are spaced such that their recursive copies can grow without
overlapping.  The output grid is generated through three interdependent
transformations:  1. **Recursive Pattern Copy**: For each pattern (ordered by
top-left corner position), create a copy shifted right by 3 and down by 3 cells.
This copy is scaled to increase its width and height by 1 cell each (e.g., a 2×3
pattern becomes 3×4 in the next copy). The process repeats recursively for each
new copy until the pattern would exceed grid boundaries or overlap existing
patterns (input patterns, their copies, or other patterns). Each copy retains
its parent pattern’s original color.  2. **Incremental Pattern Growth**: Each
recursive copy grows incrementally in both dimensions by exactly 1 cell compared
to its parent, maintaining the pattern’s shape while expanding outward. Growth
stops when the next copy would extend beyond the grid or overlap any existing
pattern.  3. **Mark Extrema Corners**: The four grid corners (top-left, top-
right, bottom-left, bottom-right) are set to color 9 if they are background (0)
in the input grid; otherwise, they remain unchanged. This marking occurs after
all recursive copies are placed and does not interact with pattern placements.
All transformations operate in parallel across all patterns, preserving
background cells not modified by the recursive growth or corner marking.
Patterns do not interact with each other during copying, and no cell is
overwritten by multiple patterns. The output grid retains all input patterns,
their recursive copies, and the marked corners, with all non-background cells
strictly derived from the input patterns and their recursive expansions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_color

# Generator for ARC task 437: recursive pattern copy with growth and corner marking

def generate():
    # Grid size
    width = random.randint(15, 30)
    height = random.randint(15, 30)

    # Initialize input grid (only initial patterns) and output grid
    input_grid = grid(width, height, 0)
    output_grid = [row[:] for row in input_grid]

    # Helpers
    def rect_overlap(a, b):
        # a and b are (x1, y1, x2, y2) with x2,y2 exclusive
        return not (a[2] <= b[0] or a[0] >= b[2] or a[3] <= b[1] or a[1] >= b[3])

    initial_rects = []  # list of initial rectangles (x1,y1,x2,y2)
    patterns = []  # store (x,y,w,h,color) for the initial patterns

    colors_used = set()
    num_patterns = random.randint(2, 4)

    margin = 2

    attempts_limit = 300
    placed = 0
    tries = 0
    while placed < num_patterns and tries < attempts_limit:
        tries += 1
        # choose a unique color for this pattern
        color = random_color(exclude=list(colors_used))
        # choose pattern size
        w = random.randint(1, 6)
        h = random.randint(1, 6)
        # choose top-left position away from edges
        if width - 2 * margin - w <= 0 or height - 2 * margin - h <= 0:
            # fallback if size too large for current grid margins
            continue
        x = random.randint(margin, width - margin - w)
        y = random.randint(margin, height - margin - h)

        # initial rect
        init_rect = (x, y, x + w, y + h)

        # ensure initial rect does not overlap any existing initial rect
        bad = False
        for r in initial_rects:
            if rect_overlap(init_rect, r):
                bad = True
                break
        if bad:
            continue

        # Accept this initial pattern: paint it into the input grid
        for rr in range(y, y + h):
            for cc in range(x, x + w):
                input_grid[rr][cc] = color

        initial_rects.append(init_rect)
        colors_used.add(color)
        patterns.append((x, y, w, h, color))
        placed += 1

    # Now create recursive copies in sorted order by top-left (row, col)
    patterns.sort(key=lambda p: (p[1], p[0]))

    # Start with a fresh output grid equal to input, we will check cell-level overlaps
    output_grid = [row[:] for row in input_grid]

    for (x, y, w, h, color) in patterns:
        curr_x, curr_y, curr_w, curr_h = x, y, w, h
        while True:
            next_x = curr_x + 3
            next_y = curr_y + 3
            next_w = curr_w + 1
            next_h = curr_h + 1
            # boundary check (x2 and y2 are exclusive)
            if next_x + next_w > width or next_y + next_h > height:
                break
            # cell-level overlap check: ensure all cells in next rect are background (0)
            overlap = False
            for rr in range(next_y, next_y + next_h):
                for cc in range(next_x, next_x + next_w):
                    if output_grid[rr][cc] != 0:
                        overlap = True
                        break
                if overlap:
                    break
            if overlap:
                break
            # paint this copy into the output grid
            for rr in range(next_y, next_y + next_h):
                for cc in range(next_x, next_x + next_w):
                    output_grid[rr][cc] = color
            curr_x, curr_y, curr_w, curr_h = next_x, next_y, next_w, next_h

    # After placing all patterns and their copies, mark corners (color 9) if they were background in input
    if input_grid[0][0] == 0:
        output_grid[0][0] = 9
    if input_grid[0][width - 1] == 0:
        output_grid[0][width - 1] = 9
    if input_grid[height - 1][0] == 0:
        output_grid[height - 1][0] = 9
    if input_grid[height - 1][width - 1] == 0:
        output_grid[height - 1][width - 1] = 9

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input (tuple of tuples) to mutable list of lists
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])

    # Detect initial patterns in the input grid.
    patterns = []  # list of (x, y, w, h, color)
    for color in range(1, 10):
        cells = []
        for r in range(height):
            for c in range(width):
                if grid_in[r][c] == color:
                    cells.append((r, c))
        if not cells:
            continue
        min_r = min(r for r, c in cells)
        max_r = max(r for r, c in cells)
        min_c = min(c for r, c in cells)
        max_c = max(c for r, c in cells)
        # Verify the bounding box is a filled rectangle of this color (generator produces solid rects)
        filled = True
        for r in range(min_r, max_r + 1):
            for c in range(min_c, max_c + 1):
                if grid_in[r][c] != color:
                    filled = False
                    break
            if not filled:
                break
        if not filled:
            continue
        w = max_c - min_c + 1
        h = max_r - min_r + 1
        patterns.append((min_c, min_r, w, h, color))

    # Sort patterns by top-left (row, col)
    patterns.sort(key=lambda p: (p[1], p[0]))

    # Start from input (initial patterns) and create output grid (cell-based overlap checks)
    output = [row[:] for row in grid_in]

    for (x, y, w, h, color) in patterns:
        curr_x, curr_y, curr_w, curr_h = x, y, w, h
        while True:
            next_x = curr_x + 3
            next_y = curr_y + 3
            next_w = curr_w + 1
            next_h = curr_h + 1
            # boundary check
            if next_x + next_w > width or next_y + next_h > height:
                break
            # cell-level overlap check
            overlap = False
            for rr in range(next_y, next_y + next_h):
                for cc in range(next_x, next_x + next_w):
                    if output[rr][cc] != 0:
                        overlap = True
                        break
                if overlap:
                    break
            if overlap:
                break
            # paint this copy
            for rr in range(next_y, next_y + next_h):
                for cc in range(next_x, next_x + next_w):
                    output[rr][cc] = color
            curr_x, curr_y, curr_w, curr_h = next_x, next_y, next_w, next_h

    # Mark corners (color 9) if they were background in the original input
    if input_grid[0][0] == 0:
        output[0][0] = 9
    if input_grid[0][width - 1] == 0:
        output[0][width - 1] = 9
    if input_grid[height - 1][0] == 0:
        output[height - 1][0] = 9
    if input_grid[height - 1][width - 1] == 0:
        output[height - 1][width - 1] = 9

    return output

