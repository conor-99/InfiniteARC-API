# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 789733ca
Difficulty: hard

=== Tags ===
- Heat map draw
- Seal gaps inside shape

=== Description ===
Input grids feature a single closed shape composed of a distinct non-background
color (e.g., color 2) drawn on a uniform background (color 0). The shape
encloses one or more internal regions of background color (color 0), forming
"gaps" that are completely surrounded by the shape (i.e., enclosed without
touching the grid edges or external background). Each gap is a contiguous
background region fully enclosed by the shape's boundary. The output grid
transforms each gap by filling it with a heat map gradient: cells adjacent to
the gap's boundary (immediately touching the shape) are filled with a base color
(e.g., color 3), and each subsequent layer inward uses the next integer color
value (e.g., 4, 5, ...), progressing sequentially with increasing intensity. The
gradient starts at color 3 for boundary cells and increases by 1 per layer until
reaching color 9 (if the gap size permits), with all filled cells remaining
within the gap's bounds. The shape color and external background remain
unchanged. Multiple gaps are sealed independently, each with its own gradient
progression based on the gap's size and distance from its boundary. No gaps are
left unfilled, and no background cells remain inside the shape in the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid
from collections import deque

def draw_rectangle_outline(grid, top, left, bottom, right, color):
    for c in range(left, right + 1):
        grid[top][c] = color
    for c in range(left, right + 1):
        grid[bottom][c] = color
    for r in range(top + 1, bottom):
        grid[r][left] = color
    for r in range(top + 1, bottom):
        grid[r][right] = color

def generate():
    size = random.randint(11, 20)
    grid = [[0] * size for _ in range(size)]
    shape_color = 2
    
    # Ensure outer rectangle has sufficient size
    outer_height = random.randint(7, size - 4)
    outer_width = random.randint(7, size - 4)
    outer_top = random.randint(2, size - outer_height - 2)
    outer_left = random.randint(2, size - outer_width - 2)
    outer_bottom = outer_top + outer_height - 1
    outer_right = outer_left + outer_width - 1
    
    draw_rectangle_outline(grid, outer_top, outer_left, outer_bottom, outer_right, shape_color)
    
    # Ensure inner rectangle fits inside outer with buffer
    inner_height = random.randint(3, outer_height - 4)
    inner_width = random.randint(3, outer_width - 4)
    inner_top = random.randint(outer_top + 2, outer_bottom - inner_height - 1)
    inner_left = random.randint(outer_left + 2, outer_right - inner_width - 1)
    inner_bottom = inner_top + inner_height - 1
    inner_right = inner_left + inner_width - 1
    
    draw_rectangle_outline(grid, inner_top, inner_left, inner_bottom, inner_right, shape_color)
    
    # Connect outer and inner rectangles
    for c in range(outer_left, inner_left):
        grid[inner_top][c] = shape_color
    
    input_grid = grid
    output_grid = [row[:] for row in grid]
    size = len(grid)
    
    visited = [[False] * size for _ in range(size)]
    q = deque()
    
    for c in range(size):
        if grid[0][c] == 0:
            q.append((0, c))
            visited[0][c] = True
        if grid[size-1][c] == 0:
            q.append((size-1, c))
            visited[size-1][c] = True
    for r in range(size):
        if grid[r][0] == 0:
            q.append((r, 0))
            visited[r][0] = True
        if grid[r][size-1] == 0:
            q.append((r, size-1))
            visited[r][size-1] = True
    
    while q:
        r, c = q.popleft()
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < size and 0 <= nc < size and not visited[nr][nc] and grid[nr][nc] == 0:
                visited[nr][nc] = True
                q.append((nr, nc))
    
    dist = [[-1] * size for _ in range(size)]
    q = deque()
    for r in range(size):
        for c in range(size):
            if grid[r][c] == shape_color:
                dist[r][c] = 0
                q.append((r, c))
    
    while q:
        r, c = q.popleft()
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < size and 0 <= nc < size and dist[nr][nc] == -1 and grid[nr][nc] == 0:
                dist[nr][nc] = dist[r][c] + 1
                q.append((nr, nc))
    
    for r in range(size):
        for c in range(size):
            if grid[r][c] == 0 and not visited[r][c]:
                d = dist[r][c]
                color_val = min(3 + (d - 1), 9)
                output_grid[r][c] = color_val
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque
def p(input_grid):
    grid = [list(row) for row in input_grid]
    size = len(grid)
    
    shape_color = None
    for r in range(size):
        for c in range(size):
            if grid[r][c] != 0:
                shape_color = grid[r][c]
                break
        if shape_color is not None:
            break
    if shape_color is None:
        return grid
    
    visited = [[False] * size for _ in range(size)]
    q = deque()
    
    for c in range(size):
        if grid[0][c] == 0:
            q.append((0, c))
            visited[0][c] = True
        if grid[size-1][c] == 0:
            q.append((size-1, c))
            visited[size-1][c] = True
    for r in range(size):
        if grid[r][0] == 0:
            q.append((r, 0))
            visited[r][0] = True
        if grid[r][size-1] == 0:
            q.append((r, size-1))
            visited[r][size-1] = True
    
    while q:
        r, c = q.popleft()
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < size and 0 <= nc < size and not visited[nr][nc] and grid[nr][nc] == 0:
                visited[nr][nc] = True
                q.append((nr, nc))
    
    dist = [[-1] * size for _ in range(size)]
    q = deque()
    for r in range(size):
        for c in range(size):
            if grid[r][c] == shape_color:
                dist[r][c] = 0
                q.append((r, c))
    
    while q:
        r, c = q.popleft()
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < size and 0 <= nc < size and dist[nr][nc] == -1 and grid[nr][nc] == 0:
                dist[nr][nc] = dist[r][c] + 1
                q.append((nr, nc))
    
    for r in range(size):
        for c in range(size):
            if grid[r][c] == 0 and not visited[r][c]:
                d = dist[r][c]
                color_val = min(3 + (d - 1), 9)
                grid[r][c] = color_val
    
    return grid
