# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: b5a255a2
Difficulty: hard

=== Tags ===
- Measure area

=== Description ===
The input grid consists of a 2D array with values between 0 and 9, where non-
zero values represent distinct colored regions. Each region is defined as a
maximal set of 4-connected (horizontally or vertically adjacent) cells sharing
the same non-zero color. The output grid is generated by replacing every cell in
a region with the area (number of cells) of that region. For example, a region
of 5 connected cells becomes a grid of 5s across all those cells. The task
requires identifying all regions, accurately counting their areas (ensuring all
areas are between 1 and 9 to stay within valid output values), and replacing
each cell accordingly. The challenge for a hard difficulty task lies in
distinguishing between numerous small, visually similar regions (e.g., multiple
disconnected regions of the same color with different areas) and correctly
computing their sizes without confusion, especially in larger grids with complex
arrangements.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    grid = [[0] * width for _ in range(height)]
    for _ in range(random.randint(1, 10)):
        size = random.randint(1, 9)
        color = random.randint(1, 9)
        while color == size:
            color = random.randint(1, 9)
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        pixels = [(r, c)]
        while len(pixels) < size:
            neighbors = []
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in pixels:
                    neighbors.append((nr, nc))
            if not neighbors:
                break
            nr, nc = random.choice(neighbors)
            pixels.append((nr, nc))
            r, c = nr, nc
        can_place = True
        for (r, c) in pixels:
            if grid[r][c] != 0:
                can_place = False
                break
        if not can_place:
            continue
        for (r, c) in pixels:
            grid[r][c] = color
    output = [[0] * width for _ in range(height)]
    visited = [[False] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and not visited[r][c]:
                color = grid[r][c]
                region = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    region.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                size = len(region)
                size = min(size, 9)
                for (cr, cc) in region:
                    output[cr][cc] = size
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output = [[0] * width for _ in range(height)]
    visited = [[False] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                color = input_grid[r][c]
                region = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    region.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                size = len(region)
                size = min(size, 9)
                for (cr, cc) in region:
                    output[cr][cc] = size
    return output
