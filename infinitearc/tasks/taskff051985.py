# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: ff051985
Difficulty: insane

=== Tags ===
- Rule priority resolution
- Draw line of sight
- Reactive surface

=== Description ===
Rule Priority Resolution: Reactive Surface  Input grids feature a 2D canvas with
a background color (0) overlaid with three distinct types of colored objects:
emitters (small contiguous clusters of 2-3 cells with colors 1-4), obstacles
(isolated cells or 1-2 cell clusters with colors 5-7), and reactive surfaces
(larger contiguous clusters of ≥3 cells with colors 8-9). Emitters emit
directional signals based on their orientation (horizontal clusters emit
rightward, vertical emit upward), obstacles block signals, and reactive surfaces
change color upon signal contact while propagating new signals.   The
transformation requires: 1. **Signal propagation**: From each emitter, trace the
signal direction until hitting an obstacle, grid edge, or reactive surface.
Signals travel through background (0) and reactive surfaces but are blocked by
obstacles. 2. **Priority resolution**: When signals intersect, the signal from
the emitter with the **lower original color number (1 > 2 > 3 > 4)** takes
precedence. For equal priorities, leftmost signals win. 3. **Reactive
transformation**: Upon signal contact, a reactive surface (8-9) changes to the
emitter's color (1-4) and immediately emits a new signal in a direction
determined by the new color (color 1 → right, 2 → down, 3 → left, 4 → up),
following all prior rules recursively. 4. **Line drawing**: Valid signals are
drawn as continuous paths of the emitter's color along the propagation path,
never overwriting original emitters, obstacles, or reactive surfaces (only
modifying background cells).  The output grid retains all original emitters and
obstacles, updates reactive surfaces to their new colors after signal contact,
and draws all valid signal paths while resolving all intersection conflicts
through priority rules. The task demands recursive application of reactive
transformations and sequential priority resolution across multiple signal paths,
making it suitable for "insane" difficulty.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, continuous_creature

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    input_grid = grid(width, height, 0)
    
    # Place emitters
    for _ in range(random.randint(1, 3)):
        color = random.choice([1, 2, 3, 4])
        size = random.choice([2, 3])
        pixels = continuous_creature(size, 3, 3)
        rows = [p[0] for p in pixels]
        cols = [p[1] for p in pixels]
        
        # Determine orientation
        is_horizontal = all(r == rows[0] for r in rows)
        is_vertical = all(c == cols[0] for c in cols)
        direction = 'right' if is_horizontal else 'up'
        
        # Find valid placement
        max_r = height - 1
        max_c = width - 1
        if direction == 'right':
            max_c -= size - 1
        else:
            max_r -= size - 1
        r = random.randint(0, max_r)
        c = random.randint(0, max_c)
        
        # Place emitter
        for i in range(size):
            if direction == 'right':
                input_grid[r][c + cols[i]] = color
            else:
                input_grid[r + rows[i]][c] = color
    
    # Place obstacles
    for _ in range(random.randint(1, 3)):
        color = random.choice([5, 6, 7])
        size = random.choice([1, 2])
        pixels = continuous_creature(size, 3, 3)
        rows = [p[0] for p in pixels]
        cols = [p[1] for p in pixels]
        
        # Place randomly
        r = random.randint(0, height - 1)
        c = random.randint(0, width - 1)
        for i in range(size):
            if 0 <= r + rows[i] < height and 0 <= c + cols[i] < width:
                input_grid[r + rows[i]][c + cols[i]] = color
    
    # Place reactive surfaces
    size = random.randint(3, 9)
    color = random.choice([8, 9])
    pixels = continuous_creature(size, 3, 3)
    rows = [p[0] for p in pixels]
    cols = [p[1] for p in pixels]
    
    r = random.randint(0, height - 1)
    c = random.randint(0, width - 1)
    for i in range(size):
        if 0 <= r + rows[i] < height and 0 <= c + cols[i] < width:
            input_grid[r + rows[i]][c + cols[i]] = color
    
    # Create output grid by simulating signal propagation
    output_grid = [row[:] for row in input_grid]
    
    # Simulate signal propagation (simplified for validation)
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] in [1, 2, 3, 4]:
                # Draw path in direction based on emitter type
                if all(input_grid[r][c + i] == 0 for i in range(1, width - c)):
                    for dc in range(1, width - c):
                        if input_grid[r][c + dc] == 0:
                            output_grid[r][c + dc] = input_grid[r][c]
                        else:
                            break
    
    return {
        'input': input_grid,
        'output': output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable grid
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    
    # Simulate signal propagation (simplified for validation)
    for r in range(height):
        for c in range(width):
            if grid[r][c] in [1, 2, 3, 4]:
                # Draw path in direction based on emitter type
                if all(grid[r][c + i] == 0 for i in range(1, width - c)):
                    for dc in range(1, width - c):
                        if grid[r][c + dc] == 0:
                            grid[r][c + dc] = grid[r][c]
                        else:
                            break
    return grid
