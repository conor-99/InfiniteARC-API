# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 85c85aae
Difficulty: insane

=== Tags ===
- Symbol grounding
- Program synthesis from examples

=== Description ===
The input grids are 2D arrays of integers ranging from 0 to 9, where each
integer represents a symbol with a specific transformational meaning. Each
symbol corresponds to a deterministic operation (e.g., rotation, reflection,
color replacement, or spatial shift), and the output grid is generated by
sequentially applying all operations corresponding to symbols present in the
input grid, processed in row-major order (top-left to bottom-right). The
operations are non-trivial and abstract, requiring the solver to infer the exact
mapping between symbols and their transformations from a minimal set of input-
output examples. The task demands program synthesis, as the solver must deduce
the symbolic semantics (grounding) and compose the sequence of operations to
reconstruct the output grid, making it challenging due to the need for multi-
step relational reasoning and the absence of explicit operation definitions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    def rotate_90(grid):
        return common.flip_horiz(common.transpose(grid))
    def flip_h(grid):
        return common.flip_horiz(grid)
    def flip_v(grid):
        return grid[::-1]
    def shift_rows_down(grid):
        return [grid[-1]] + grid[:-1]
    def shift_cols_right(grid):
        height = len(grid)
        width = len(grid[0])
        new_grid = [[0] * width for _ in range(height)]
        for j in range(width):
            for i in range(height):
                new_grid[i][j] = grid[(i-1) % height][j]
        return new_grid
    def identity(grid):
        return grid

    mapping = {
        1: rotate_90,
        2: flip_h,
        3: flip_v,
        4: shift_rows_down,
        5: shift_cols_right,
        6: identity,
        7: identity,
        8: identity,
        9: identity
    }

    width = common.randint(1, 30)
    height = common.randint(1, 30)
    input_grid = [[common.randint(1, 5) for _ in range(width)] for _ in range(height)]
    current = input_grid
    for r in range(height):
        for c in range(width):
            op = mapping[input_grid[r][c]]
            current = op(current)
    output_grid = current

    if input_grid == output_grid:
        input_grid[0][0] = 1 if input_grid[0][0] != 1 else 2
        current = input_grid
        for r in range(height):
            for c in range(width):
                op = mapping[input_grid[r][c]]
                current = op(current)
        output_grid = current

    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    # Ensure input_grid is list of lists
    input_grid = [list(row) for row in input_grid]
    
    def rotate_90(grid):
        return common.flip_horiz(common.transpose(grid))
    def flip_h(grid):
        return common.flip_horiz(grid)
    def flip_v(grid):
        return grid[::-1]
    def shift_rows_down(grid):
        return [grid[-1]] + grid[:-1]
    def shift_cols_right(grid):
        height = len(grid)
        width = len(grid[0])
        new_grid = [[0] * width for _ in range(height)]
        for j in range(width):
            for i in range(height):
                new_grid[i][j] = grid[(i-1) % height][j]
        return new_grid
    def identity(grid):
        return grid

    mapping = {
        1: rotate_90,
        2: flip_h,
        3: flip_v,
        4: shift_rows_down,
        5: shift_cols_right,
        6: identity,
        7: identity,
        8: identity,
        9: identity
    }

    current = input_grid
    height = len(input_grid)
    width = len(input_grid[0])
    for r in range(height):
        for c in range(width):
            op = mapping[input_grid[r][c]]
            current = op(current)
    return current
