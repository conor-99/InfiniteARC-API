# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 244cf510
Difficulty: medium

=== Tags ===
- Image expasion
- Remove intruders
- Image rotation
- Create image from info

=== Description ===
The input grid contains a single connected shape composed of adjacent non-
background pixels (0 represents background), surrounded by isolated,
disconnected pixels (intruders) that do not form part of the main shape. The
correct output grid is generated through three sequential transformations:
first, all disconnected pixels (intruders) are removed, leaving only the largest
connected component of the main shape; second, the resulting grid is rotated 90
degrees clockwise; third, the grid is expanded by a factor of 2, where each
pixel in the rotated grid becomes a 2Ã—2 block of identical color in the output,
doubling both dimensions. This process ensures the output visually represents
the core shape, oriented differently, and scaled up while maintaining structural
consistency.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    import common

    width = random.randint(5, 15)
    height = random.randint(5, 15)
    main_size = random.randint(5, 15)
    main_pixels = common.continuous_creature(main_size, width, height)
    input_grid = common.grid(width, height, 0)
    for r, c in main_pixels:
        input_grid[r][c] = 1
    intruders = []
    for _ in range(random.randint(2, 4)):
        while True:
            r = random.randint(0, height-1)
            c = random.randint(0, width-1)
            if (r, c) in main_pixels:
                continue
            adjacent = False
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and (nr, nc) in main_pixels:
                    adjacent = True
                    break
            if not adjacent:
                intruders.append((r, c))
                break
    for r, c in intruders:
        input_grid[r][c] = 2
    grid_step1 = common.grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 1:
                grid_step1[r][c] = 1
    rotated = [list(x)[::-1] for x in zip(*grid_step1)]
    output_height = len(rotated)
    output_width = len(rotated[0]) if rotated else 0
    output_grid = common.grid(2 * output_width, 2 * output_height, 0)
    for r in range(output_height):
        for c in range(output_width):
            color = rotated[r][c]
            for dr in range(2):
                for dc in range(2):
                    output_grid[2*r + dr][2*c + dc] = color
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    import common
    from collections import deque

    if not input_grid or not input_grid[0]:
        return input_grid
    rows = len(input_grid)
    cols = len(input_grid[0])
    visited = [[False] * cols for _ in range(rows)]
    components = []
    for r in range(rows):
        for c in range(cols):
            if not visited[r][c] and input_grid[r][c] > 0:
                component = []
                queue = deque([(r, c)])
                visited[r][c] = True
                while queue:
                    cr, cc = queue.popleft()
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and input_grid[nr][nc] > 0:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                components.append(component)
    largest = max(components, key=len)
    grid_step1 = common.grid(cols, rows, 0)
    for r, c in largest:
        grid_step1[r][c] = input_grid[r][c]
    rotated = [list(x)[::-1] for x in zip(*grid_step1)]
    output_rows = len(rotated)
    output_cols = len(rotated[0]) if rotated else 0
    output_grid = common.grid(2 * output_cols, 2 * output_rows, 0)
    for r in range(output_rows):
        for c in range(output_cols):
            color = rotated[r][c]
            for dr in range(2):
                for dc in range(2):
                    output_grid[2*r + dr][2*c + dc] = color
    return output_grid
