# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 9e734f83
Difficulty: hard

=== Tags ===
- Pressure release

=== Description ===
Input grids feature a rectangular chamber bounded by a continuous wall of a
single color, with exactly one cell missing from the wall (the "vent") on one
edge. Inside the chamber, a contiguous path of cells (the "pressure wave")
connects the chamber's interior to the vent. The output grid transforms the
pressure wave into a straight-line segment extending from the vent in the
direction perpendicular to the chamber's boundary (e.g., if the vent is on the
right edge, the line extends leftward), with the segment's length matching the
wave's cell count. All other cells remain unchanged, preserving the chamber's
wall and background. This task demands identifying the chamber, vent location,
wave path, and aligning the wave into a straight line based on the vent's
orientation, requiring complex spatial and relational reasoning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    H = random.randint(3, 30)
    W = random.randint(3, 30)
    grid = [[0] * W for _ in range(H)]
    
    # Set perimeter to 1
    for r in range(H):
        for c in range(W):
            if r == 0 or r == H-1 or c == 0 or c == W-1:
                grid[r][c] = 1

    # Choose vent edge
    edges = ['top', 'bottom', 'left', 'right']
    edge = random.choice(edges)
    if edge == 'top':
        c = random.randint(1, W-2)
        grid[0][c] = 0
        vent_r, vent_c = 0, c
        start_r, start_c = 1, c
    elif edge == 'bottom':
        c = random.randint(1, W-2)
        grid[H-1][c] = 0
        vent_r, vent_c = H-1, c
        start_r, start_c = H-2, c
    elif edge == 'left':
        r = random.randint(1, H-2)
        grid[r][0] = 0
        vent_r, vent_c = r, 0
        start_r, start_c = r, 1
    else:  # right
        r = random.randint(1, H-2)
        grid[r][W-1] = 0
        vent_r, vent_c = r, W-1
        start_r, start_c = r, W-2

    # Generate path length N (up to max possible)
    N = random.randint(1, min(H, W) - 1)
    path = [(start_r, start_c)]
    current = (start_r, start_c)
    for _ in range(N-1):
        directions = [(1,0), (-1,0), (0,1), (0,-1)]
        valid_dirs = []
        for dr, dc in directions:
            nr, nc = current[0] + dr, current[1] + dc
            if 1 <= nr < H-1 and 1 <= nc < W-1 and (nr, nc) not in path:
                valid_dirs.append((dr, dc))
        if not valid_dirs:
            break
        dr, dc = random.choice(valid_dirs)
        current = (current[0] + dr, current[1] + dc)
        path.append(current)

    # Set path to color 2
    for r, c in path:
        grid[r][c] = 2

    # Update N to actual path length
    N = len(path)

    # Create output
    output = [row[:] for row in grid]
    
    # Determine direction
    if edge == 'top':
        dr, dc = 1, 0
    elif edge == 'bottom':
        dr, dc = -1, 0
    elif edge == 'left':
        dr, dc = 0, 1
    else:
        dr, dc = 0, -1

    # Set line cells to 2
    for k in range(N):
        r = vent_r + k * dr
        c = vent_c + k * dc
        output[r][c] = 2

    # Set path cells not in line to 0
    for r, c in path:
        in_line = False
        for k in range(N):
            lr = vent_r + k * dr
            lc = vent_c + k * dc
            if lr == r and lc == c:
                in_line = True
                break
        if not in_line:
            output[r][c] = 0

    return {'input': grid, 'output': output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0])

    # Find vent cell (0 on perimeter)
    vent = None
    for r in [0, H-1]:
        for c in range(W):
            if grid[r][c] == 0:
                vent = (r, c)
                break
        if vent:
            break
    if not vent:
        for c in [0, W-1]:
            for r in range(1, H-1):
                if grid[r][c] == 0:
                    vent = (r, c)
                    break
            if vent:
                break
    if not vent:
        return input_grid

    vent_r, vent_c = vent
    
    # Determine edge and direction
    if vent_r == 0:
        dr, dc = 1, 0
    elif vent_r == H-1:
        dr, dc = -1, 0
    elif vent_c == 0:
        dr, dc = 0, 1
    else:
        dr, dc = 0, -1

    # Find adjacent cell
    if vent_r == 0:
        adj_r, adj_c = 1, vent_c
    elif vent_r == H-1:
        adj_r, adj_c = H-2, vent_c
    elif vent_c == 0:
        adj_r, adj_c = vent_r, 1
    else:
        adj_r, adj_c = vent_r, W-2

    # Find path (connected 2s from adjacent cell)
    path = []
    visited = [[False] * W for _ in range(H)]
    queue = deque([(adj_r, adj_c)])
    visited[adj_r][adj_c] = True
    
    while queue:
        r, c = queue.popleft()
        if grid[r][c] == 2:
            path.append((r, c))
            for dr2, dc2 in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr2, c + dc2
                if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc] and grid[nr][nc] == 2:
                    visited[nr][nc] = True
                    queue.append((nr, nc))

    N = len(path)
    
    # Generate line cells
    line_cells = []
    for k in range(N):
        r = vent_r + k * dr
        c = vent_c + k * dc
        line_cells.append((r, c))

    # Build output
    output = [row[:] for row in grid]
    
    # Set path cells not in line to 0
    for r, c in path:
        if (r, c) not in line_cells:
            output[r][c] = 0
    
    # Set line cells to 2
    for r, c in line_cells:
        output[r][c] = 2

    return output
