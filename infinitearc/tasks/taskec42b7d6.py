# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: ec42b7d6
Difficulty: insane

=== Tags ===
- Symbol grounding
- Associate colors to ranks
- Algebra

=== Description ===
The task involves transforming an input grid of colors (values 0-9) into an
output grid through a multi-step process based on dynamic color ranking and
algebraic operations. First, the frequency of each color in the input grid is
calculated. Colors are then sorted by descending frequency, with ties broken by
ascending color value (e.g., color 2 precedes color 5 if both appear equally
often). Each color is assigned a rank (1 for the most frequent, 2 for the next,
etc.). The output grid is generated by replacing each cell's color value `c`
with `(rank(c) × c) mod 10`, where `rank(c)` is the rank assigned to the color.
The transformation ensures the output grid differs from the input by design, as
the algebraic operation `(rank × c) mod 10` typically alters at least one cell's
value. This process requires inductive reasoning to deduce the frequency-based
ranking and the modular arithmetic operation, making it challenging to
generalize without explicit examples.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    while True:
        width = random.randint(1, 30)
        height = random.randint(1, 30)
        input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
        color_freq = [0] * 10
        for row in input_grid:
            for color in row:
                color_freq[color] += 1
        present_colors = [c for c in range(10) if color_freq[c] > 0]
        present_colors.sort(key=lambda c: (-color_freq[c], c))
        rank_map = {}
        for rank, color in enumerate(present_colors, 1):
            rank_map[color] = rank
        output_grid = []
        for row in input_grid:
            new_row = []
            for color in row:
                new_color = (rank_map[color] * color) % 10
                new_row.append(new_color)
            output_grid.append(new_row)
        if input_grid == output_grid:
            continue
        return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random

def p(input_grid):
    color_freq = [0] * 10
    for row in input_grid:
        for color in row:
            color_freq[color] += 1
    present_colors = [c for c in range(10) if color_freq[c] > 0]
    present_colors.sort(key=lambda c: (-color_freq[c], c))
    rank_map = {}
    for rank, color in enumerate(present_colors, 1):
        rank_map[color] = rank
    output_grid = []
    for row in input_grid:
        new_row = []
        for color in row:
            new_color = (rank_map[color] * color) % 10
            new_row.append(new_color)
        output_grid.append(new_row)
    return output_grid
