# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 04311e72
Difficulty: hard

=== Tags ===
- Pattern deconstruction

=== Description ===
The input grids consist of complex arrangements featuring multiple nested and
overlapping closed boundaries (e.g., squares, rectangles, or irregular loops),
each forming a continuous edge-to-edge loop with no branches or intersections.
Each boundary encloses a distinct interior region. The output grid is generated
by identifying all such closed boundaries and removing their interior cells
(setting them to background color 0), while preserving the boundary cells and
all exterior regions. For example, a square boundary with a colored interior in
the input results in the boundary remaining intact and the interior becoming 0
in the output. Nested boundaries (e.g., a large square containing a smaller
square) require sequential interior removal from the innermost to outermost
loops. The task demands recognizing closed loops in complex configurations,
distinguishing boundaries from non-boundary patterns, and accurately defining
interior regions without relying on pixel-level analysis. This multi-step
deconstruction process, combined with overlapping and nested structures, creates
a challenging visual reasoning problem requiring abstract pattern recognition.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid


def generate():
    size = random.randint(10, 30)
    input_grid = grid(size, size, 0)
    num_rects = random.randint(2, 4)
    
    # Generate nested rectangles
    rects = []
    r1, c1 = 0, 0
    r2, c2 = size - 1, size - 1
    
    for _ in range(num_rects):
        if r2 - r1 < 2 or c2 - c1 < 2:
            break
        rects.append((r1, c1, r2, c2))
        r1 += 2
        c1 += 2
        r2 -= 2
        c2 -= 2

    # Draw boundaries with random color
    boundary_color = random.randint(1, 9)
    for (r1, c1, r2, c2) in rects:
        # Top and bottom
        for c in range(c1, c2 + 1):
            input_grid[r1][c] = boundary_color
            input_grid[r2][c] = boundary_color
        # Left and right
        for r in range(r1 + 1, r2):
            input_grid[r][c1] = boundary_color
            input_grid[r][c2] = boundary_color

    # Fill interiors with random colors
    interior_color = random.randint(1, 9)
    for (r1, c1, r2, c2) in rects:
        for r in range(r1 + 1, r2):
            for c in range(c1 + 1, c2):
                input_grid[r][c] = interior_color
                interior_color = (interior_color + 1) % 9 or 1

    # Create output grid by setting all non-boundary cells to 0
    output_grid = [[boundary_color if input_grid[r][c] == boundary_color else 0 for c in range(size)] for r in range(size)]
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid:
        return input_grid
    size = len(input_grid)
    
    # Find boundary color (first non-zero color that forms loops)
    boundary_color = None
    for r in range(size):
        for c in range(size):
            if input_grid[r][c] != 0:
                boundary_color = input_grid[r][c]
                break
        if boundary_color:
            break
    
    # Create output grid: keep boundary_color cells, set others to 0
    output_grid = [[boundary_color if input_grid[r][c] == boundary_color else 0 for c in range(size)] for r in range(size)]
    return output_grid
