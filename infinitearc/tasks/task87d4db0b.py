# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 87d4db0b
Difficulty: insane

=== Tags ===
- Teleporter network routing
- Constraint satisfaction coloring
- Lava flow
- Non overwriting draw

=== Description ===
Lava Teleporter Network: In this task, input grids feature a 20×20 grid with a
single background color (0), scattered teleporter pairs (two identical non-
background colors 1-9, positioned with at least one cell separation between
pairs), a left-edge lava source (color 9), and constraint markers (color 5)
arranged to define a target color sequence (e.g., [3, 7, 2]). Lava flows right
from the source, moving only through background cells (0) until encountering a
teleporter. Upon entering a teleporter (color X), it instantly teleports to its
paired cell, reversing direction based on pair orientation (horizontal pairs
flip left/right, vertical pairs flip up/down). The path from source to first
teleporter is drawn in color 9. Each subsequent segment (between teleporter
exits) uses the next color in the constraint sequence, cycling if exhausted. The
path must strictly follow the constraint sequence order (e.g., first teleporter
must match sequence[0]), and segments must not overlap with teleporters,
constraint markers, or the source. The output grid preserves all input elements
while drawing the lava path as a continuous line over background cells, with
color changes corresponding to the constraint sequence. Direction changes upon
teleportation and sequence adherence create a multi-layered constraint
satisfaction problem requiring precise path tracking across a grid with 8-12
teleporter pairs and non-trivial navigation around grid boundaries.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common


def generate():
    size = 20
    # initialize empty background grid
    input_grid = common.grid(size, size, 0)

    # Colors available for teleporters (avoid marker color 5 and source color 9)
    available_colors = [1, 2, 3, 4, 6, 7, 8]

    # choose total number of distinct teleporter colors (pairs)
    tele_count = random.randint(5, min(7, len(available_colors)))
    tele_colors = random.sample(available_colors, tele_count)

    # sequence length (3-5) but cannot exceed number of teleporter colors
    seq_len = random.randint(3, min(5, tele_count))
    # pick the colors that will form the sequence (order will be the encounter order along the path)
    sequence_colors = random.sample(tele_colors, seq_len)

    # choose rows that the path will visit: need seq_len+1 distinct rows (start row + one per teleport exit)
    rows_pool = list(range(2, size - 2))
    rows_use = random.sample(rows_pool, seq_len + 1)
    # Source is on the left edge at the first row in rows_use
    src_r = rows_use[0]
    input_grid[src_r][0] = 9

    # pick increasing columns for the teleporter entry cells (one per sequence element)
    # ensure at least one background cell between consecutive entries
    attempts = 0
    while True:
        attempts += 1
        cands = list(range(2, size - 3))
        if len(cands) < seq_len:
            raise ValueError("Grid too small for sequence")
        c_list = sorted(random.sample(cands, seq_len))
        ok = True
        for i in range(1, len(c_list)):
            if c_list[i] - c_list[i - 1] < 2:
                ok = False
                break
        if ok:
            break
        if attempts > 200:
            # fallback: use evenly spaced columns
            step = max(2, (size - 4) // seq_len)
            c_list = [2 + i * step for i in range(seq_len)]
            break

    # place visual markers (color 5) on bottom row. They are decorative here.
    marker_row = size - 1
    possible_marker_cols = [c for c in range(1, size - 1) if c not in c_list]
    # ensure we can place the same number of markers as sequence length
    if len(possible_marker_cols) < seq_len:
        # if not enough distinct columns, just pick distinct ones from full range
        possible_marker_cols = [c for c in range(1, size - 1)]
    marker_cols = sorted(random.sample(possible_marker_cols, seq_len))
    for mc in marker_cols:
        input_grid[marker_row][mc] = 5

    # place the sequence teleporter pairs as vertical pairs (same column, different rows)
    # entry at (rows_use[i], c_list[i]), partner at (rows_use[i+1], c_list[i])
    teleporter_positions = {}  # color -> list of (r,c)
    occupied = set()
    occupied.add((src_r, 0))
    for i, color in enumerate(sequence_colors):
        r_entry = rows_use[i]
        c_entry = c_list[i]
        r_dest = rows_use[i + 1]
        # safety checks, but these cells should be empty
        if input_grid[r_entry][c_entry] != 0 or input_grid[r_dest][c_entry] != 0:
            # in the unlikely event of collision, try to find nearby safe spots
            # (very unlikely with current sampling)
            raise ValueError("Collision when placing sequence teleporters")
        input_grid[r_entry][c_entry] = color
        input_grid[r_dest][c_entry] = color
        teleporter_positions.setdefault(color, []).append((r_entry, c_entry))
        teleporter_positions.setdefault(color, []).append((r_dest, c_entry))
        occupied.add((r_entry, c_entry))
        occupied.add((r_dest, c_entry))

    # Place the remaining teleporter pairs (colors not used in the sequence)
    extra_colors = [c for c in tele_colors if c not in sequence_colors]

    def cell_ok(r, c):
        if r < 1 or r >= size - 1 or c < 1 or c >= size - 1:
            return False
        if input_grid[r][c] != 0:
            return False
        # avoid direct adjacency (Manhattan distance <=1) to any existing teleporter cell
        for (pr, pc) in occupied:
            if abs(pr - r) + abs(pc - c) <= 1:
                return False
        # avoid using rows that are part of the main path and avoid the path columns
        if r in rows_use:
            return False
        if c in c_list:
            return False
        return True

    for color in extra_colors:
        placed = False
        tries = 0
        while not placed and tries < 400:
            tries += 1
            orient = random.choice(["h", "v"])
            if orient == "h":
                # choose a row not in rows_use and two distinct columns not in c_list
                r = random.choice([r for r in range(1, size - 1) if r not in rows_use])
                cols_pool = [c for c in range(1, size - 1) if c not in c_list]
                if len(cols_pool) < 2:
                    continue
                c1 = random.choice(cols_pool)
                c2 = random.choice([c for c in cols_pool if c != c1])
                if not cell_ok(r, c1) or not cell_ok(r, c2):
                    continue
                input_grid[r][c1] = color
                input_grid[r][c2] = color
                teleporter_positions.setdefault(color, []).append((r, c1))
                teleporter_positions.setdefault(color, []).append((r, c2))
                occupied.add((r, c1))
                occupied.add((r, c2))
                placed = True
            else:
                # vertical
                c = random.choice([c for c in range(1, size - 1) if c not in c_list])
                rows_pool2 = [r for r in range(1, size - 1) if r not in rows_use]
                if len(rows_pool2) < 2:
                    continue
                r1 = random.choice(rows_pool2)
                r2 = random.choice([r for r in rows_pool2 if r != r1])
                if not cell_ok(r1, c) or not cell_ok(r2, c):
                    continue
                input_grid[r1][c] = color
                input_grid[r2][c] = color
                teleporter_positions.setdefault(color, []).append((r1, c))
                teleporter_positions.setdefault(color, []).append((r2, c))
                occupied.add((r1, c))
                occupied.add((r2, c))
                placed = True
        if not placed:
            # fallback brute force placement
            for r in range(1, size - 1):
                if r in rows_use:
                    continue
                for c in range(1, size - 1):
                    if c in c_list:
                        continue
                    if not cell_ok(r, c):
                        continue
                    # find partner
                    found_partner = False
                    for rr in range(1, size - 1):
                        if rr in rows_use:
                            continue
                        for cc in range(1, size - 1):
                            if cc in c_list:
                                continue
                            if (rr, cc) == (r, c):
                                continue
                            if not cell_ok(rr, cc):
                                continue
                            input_grid[r][c] = color
                            input_grid[rr][cc] = color
                            teleporter_positions.setdefault(color, []).append((r, c))
                            teleporter_positions.setdefault(color, []).append((rr, cc))
                            occupied.add((r, c))
                            occupied.add((rr, cc))
                            found_partner = True
                            break
                        if found_partner:
                            break
                    if found_partner:
                        placed = True
                        break
                if placed:
                    break

    # Build the output grid by simulating lava movement and drawing only on background cells
    output_grid = [row[:] for row in input_grid]

    # Utility: find pair position for a teleporter color given one endpoint
    def find_pair(color, r0, c0):
        pts = teleporter_positions.get(color, [])
        for (r, c) in pts:
            if r != r0 or c != c0:
                return (r, c)
        # fallback: brute force search
        for r in range(size):
            for c in range(size):
                if (r, c) != (r0, c0) and input_grid[r][c] == color:
                    return (r, c)
        return None

    # simulate
    r, c = src_r, 0
    segment_index = 0
    max_steps = 10000
    steps = 0
    while steps < max_steps:
        steps += 1
        # move right until hitting a teleporter or the right edge
        next_tele = None
        for nc in range(c + 1, size):
            val = input_grid[r][nc]
            if val != 0 and val != 5 and val != 9:
                # treat any non-zero non-marker non-source as teleporter
                next_tele = (r, nc, val)
                break
        if next_tele is None:
            # color to the edge
            color = 9 if segment_index == 0 else sequence_colors[(segment_index - 1) % len(sequence_colors)]
            for cc in range(c + 1, size):
                if output_grid[r][cc] == 0:
                    output_grid[r][cc] = color
            break

        tr, tc, tcol = next_tele
        # draw from current position (exclusive) to teleporter (exclusive)
        color = 9 if segment_index == 0 else sequence_colors[(segment_index - 1) % len(sequence_colors)]
        for cc in range(c + 1, tc):
            if output_grid[r][cc] == 0:
                output_grid[r][cc] = color

        # teleport
        pair = find_pair(tcol, tr, tc)
        if pair is None:
            break
        pr, pc = pair
        # move to pair cell (we don't draw on teleporter cells)
        r, c = pr, pc
        # step one cell forward in the right direction to continue the flow
        c += 1
        if c >= size:
            break
        segment_index += 1

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input (possibly tuple-of-tuples) into a mutable list-of-lists
    grid = [list(row) for row in input_grid]
    size = len(grid)

    # Find the lava source (color 9) on the left edge; prefer a cell in column 0
    src = None
    for r in range(size):
        if grid[r][0] == 9:
            src = (r, 0)
            break
    if src is None:
        # fallback: search entire grid
        for r in range(size):
            for c in range(size):
                if grid[r][c] == 9:
                    src = (r, c)
                    break
            if src:
                break
    if src is None:
        return grid

    # Build teleporter map: color -> list of coordinates (exclude markers (5) and source (9))
    tele_map = {}
    for r in range(size):
        for c in range(size):
            val = grid[r][c]
            if val != 0 and val != 5 and val != 9:
                tele_map.setdefault(val, []).append((r, c))

    # helper to find the partner of a teleporter cell
    def find_pair(color, r0, c0):
        pts = tele_map.get(color, [])
        for (r, c) in pts:
            if (r, c) != (r0, c0):
                return (r, c)
        # brute force fallback
        for r in range(size):
            for c in range(size):
                if (r, c) != (r0, c0) and grid[r][c] == color:
                    return (r, c)
        return None

    # First pass: simulate the lava flow to collect the sequence of teleporter colors encountered
    r, c = src
    seq_encounter = []
    steps = 0
    max_steps = 10000
    while steps < max_steps:
        steps += 1
        # move right until we hit a teleporter or edge
        next_tele = None
        for nc in range(c + 1, size):
            val = grid[r][nc]
            if val != 0 and val != 5 and val != 9:
                next_tele = (r, nc, val)
                break
        if next_tele is None:
            break
        tr, tc, tcol = next_tele
        seq_encounter.append(tcol)
        pair = find_pair(tcol, tr, tc)
        if pair is None:
            break
        pr, pc = pair
        r, c = pr, pc
        c += 1
        if c >= size:
            break

    if not seq_encounter:
        # Nothing to draw (no teleporters encountered) — return input preserved
        return grid

    # Second pass: draw the lava path onto a copy of the input grid
    out = [row[:] for row in grid]
    r, c = src
    seg_index = 0
    steps = 0
    while steps < max_steps:
        steps += 1
        # find next teleporter to the right on current row
        next_tele = None
        for nc in range(c + 1, size):
            val = grid[r][nc]
            if val != 0 and val != 5 and val != 9:
                next_tele = (r, nc, val)
                break
        if next_tele is None:
            # color to the edge
            color = 9 if seg_index == 0 else seq_encounter[(seg_index - 1) % len(seq_encounter)]
            for cc in range(c + 1, size):
                if out[r][cc] == 0:
                    out[r][cc] = color
            break

        tr, tc, tcol = next_tele
        color = 9 if seg_index == 0 else seq_encounter[(seg_index - 1) % len(seq_encounter)]
        for cc in range(c + 1, tc):
            if out[r][cc] == 0:
                out[r][cc] = color

        # teleport
        pair = find_pair(tcol, tr, tc)
        if pair is None:
            break
        pr, pc = pair
        r, c = pr, pc
        c += 1
        if c >= size:
            break
        seg_index += 1

    return out

