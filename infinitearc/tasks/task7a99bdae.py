# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 7a99bdae
Difficulty: insane

=== Tags ===
- Split and merge
- Pattern translation

=== Description ===
Input grids feature multiple non-overlapping colored regions (each a connected
component of a single non-background color) arranged on a uniform background.
Each region undergoes a vertical split into left and right halves based on its
bounding box. The left half of every region is translated by a unique vector
specific to its color (e.g., color 1: (-2, -1), color 2: (-1, -2), color 3: (-3,
0)), while the right half is translated by the opposite vector (e.g., color 1:
(+2, +1)). After translation, overlapping cells between translated halves merge
into a single cell retaining the original region's color. Regions truncated at
grid boundaries are preserved only within the grid. Output grids reflect these
transformations, with all background cells unchanged and merged regions forming
new connected components. The task requires recognizing the color-specific
translation vectors through pattern analysis and applying parallel spatial
reconfiguration.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

color_vectors = {
    1: (-2, -1),
    2: (-1, -2),
    3: (-3, 0),
    4: (0, -3),
    5: (2, 1),
    6: (1, 2),
    7: (3, 0),
    8: (0, 3),
    9: (1, -1)
}

def generate():
    width = random.randint(5, 20)
    height = random.randint(5, 20)
    input_grid = grid(width, height, 0)
    colors = sorted(random.sample(list(color_vectors.keys()), random.randint(1, 3)))
    
    for c in colors:
        size = 5
        while True:
            r = random.randint(0, height - 1)
            c_start = random.randint(0, width - size)
            if all(input_grid[r][c_pos] == 0 for c_pos in range(c_start, c_start + size)):
                for c_pos in range(c_start, c_start + size):
                    input_grid[r][c_pos] = c
                break
    
    output_grid = grid(width, height, 0)
    for c in colors:
        region_pixels = [(r, col) for r in range(height) for col in range(width) if input_grid[r][col] == c]
        if not region_pixels:
            continue
        min_r = min(r for r, _ in region_pixels)
        max_r = max(r for r, _ in region_pixels)
        min_c = min(col for _, col in region_pixels)
        max_c = max(col for _, col in region_pixels)
        mid_c = (min_c + max_c) // 2
        
        left_pixels = [(r, col) for (r, col) in region_pixels if col <= mid_c]
        right_pixels = [(r, col) for (r, col) in region_pixels if col > mid_c]
        
        dx, dy = color_vectors[c]
        for r, col in left_pixels:
            nr, nc = r + dy, col + dx
            if 0 <= nr < height and 0 <= nc < width:
                output_grid[nr][nc] = c
        for r, col in right_pixels:
            nr, nc = r - dy, col - dx
            if 0 <= nr < height and 0 <= nc < width:
                output_grid[nr][nc] = c
    
    if input_grid == output_grid:
        output_grid[0][0] = (output_grid[0][0] + 1) % 10
        if output_grid[0][0] == 0:
            output_grid[0][0] = 1
    
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

color_vectors = {
    1: (-2, -1),
    2: (-1, -2),
    3: (-3, 0),
    4: (0, -3),
    5: (2, 1),
    6: (1, 2),
    7: (3, 0),
    8: (0, 3),
    9: (1, -1)
}

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = grid(width, height, 0)
    for c in range(1, 10):
        region_pixels = []
        for r in range(height):
            for col in range(width):
                if input_grid[r][col] == c:
                    region_pixels.append((r, col))
        if not region_pixels:
            continue
        min_r = min(r for r, _ in region_pixels)
        max_r = max(r for r, _ in region_pixels)
        min_c = min(col for _, col in region_pixels)
        max_c = max(col for _, col in region_pixels)
        mid_c = (min_c + max_c) // 2
        
        left_pixels = [(r, col) for (r, col) in region_pixels if col <= mid_c]
        right_pixels = [(r, col) for (r, col) in region_pixels if col > mid_c]
        
        dx, dy = color_vectors[c]
        for r, col in left_pixels:
            nr, nc = r + dy, col + dx
            if 0 <= nr < height and 0 <= nc < width:
                output_grid[nr][nc] = c
        for r, col in right_pixels:
            nr, nc = r - dy, col - dx
            if 0 <= nr < height and 0 <= nc < width:
                output_grid[nr][nc] = c
    return output_grid
