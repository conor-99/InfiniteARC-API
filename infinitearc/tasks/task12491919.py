# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 12491919
Difficulty: hard

=== Tags ===
- Stacked layer alignment

=== Description ===
Input grids contain a background color (0) and multiple 4-connected colored
layers (1-9), each forming a distinct contiguous region. Each layer is offset
from the reference layer (the layer with the smallest minimum row index, and
smallest minimum column index among those with the same minimum row) by a
consistent displacement vector. The output grid aligns all layers such that
their top-left corners (the minimum row and column indices of each layer's
cells) coincide with the reference layer's top-left corner. This is achieved by
shifting each layer's cells by the vector (ref_row - layer_row, ref_col -
layer_col), where ref_row and ref_col are the reference layer's top-left
coordinates. Shifted cells outside grid boundaries are discarded, but alignment
is exact for all cells within bounds. The output maintains background color in
unoccupied cells, and no layer overlaps with another in the output. The
transformation requires identifying connected regions, computing bounding boxes,
determining the reference layer, and applying precise coordinate shiftsâ€”all
while preserving the visual integrity of each layer's structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

_call_count = 0

def _make_normalized_shapes(layers_count):
    """
    Construct a list of normalized, pairwise-disjoint, 4-connected shapes N_i inside a small
    local canvas. Each normalized shape touches the top row (row 0) and left column (col 0)
    so that after normalization its min row and min col are 0. The construction below builds
    an L-shaped path for each layer using unique mid-columns and unique rows so the shapes
    never intersect.
    Returns a list of lists of (r,c) coordinates.
    """
    shapes = []
    for i in range(layers_count):
        mid_col = i + 1
        row_idx = i + 1
        shape = set()
        # include the topmost cell at (0, mid_col)
        shape.add((0, mid_col))
        # go down from row 1 to row_idx along column mid_col
        for r in range(1, row_idx + 1):
            shape.add((r, mid_col))
        # then go left along row 'row_idx' from mid_col-1 down to 0
        for c in range(mid_col - 1, -1, -1):
            shape.add((row_idx, c))
        shapes.append(sorted(shape))
    return shapes


def generate():
    """
    Generate an input-output pair where multiple colored 4-connected layers are placed
    at different positions in the input. The output aligns them so their top-left
    corners coincide with the reference layer's top-left.
    """
    global _call_count
    _call_count += 1

    # Number of layers
    layers_count = random.randint(2, 4)

    # Local (normalized) canvas that will host the disjoint normalized shapes
    local_w = layers_count + 2
    local_h = layers_count + 2

    # Grid must be at least as big as the local canvas to allow placement
    width = random.randint(local_w, min(20, 30))
    height = random.randint(local_h, min(20, 30))

    # Build normalized shapes (they are disjoint by construction)
    normalized_shapes = _make_normalized_shapes(layers_count)

    # Choose distinct colors for each layer
    colors = random.sample(list(range(1, 10)), layers_count)

    # Prepare empty input grid
    input_grid = [[0 for _ in range(width)] for _ in range(height)]
    occupied = set()
    placed_layers = []  # list of (color, abs_pixels)

    # Place each normalized shape somewhere in the grid without overlap
    for idx, shape in enumerate(normalized_shapes):
        # compute shape bounding box
        max_r = max(r for r, c in shape)
        max_c = max(c for r, c in shape)
        shape_h = max_r + 1
        shape_w = max_c + 1

        placed = False
        for attempt in range(300):
            base_row = random.randint(0, height - shape_h)
            base_col = (random.randint(0, width - shape_w) + _call_count) % (width - shape_w + 1)

            abs_pixels = [(base_row + r, base_col + c) for (r, c) in shape]

            # Check in-bounds and non-overlap with already placed layers
            ok = True
            for (rr, cc) in abs_pixels:
                if not (0 <= rr < height and 0 <= cc < width):
                    ok = False
                    break
                if (rr, cc) in occupied:
                    ok = False
                    break
            if not ok:
                continue

            # Place
            for (rr, cc) in abs_pixels:
                input_grid[rr][cc] = colors[idx]
                occupied.add((rr, cc))
            placed_layers.append((colors[idx], abs_pixels))
            placed = True
            break

        if not placed:
            # Failed to find a placement without overlap; regenerate
            return generate()

    # Compute top-left for each placed layer
    layers_info = []  # (color, abs_pixels, min_r, min_c)
    for color, abs_pixels in placed_layers:
        min_r = min(r for r, c in abs_pixels)
        min_c = min(c for r, c in abs_pixels)
        layers_info.append((color, abs_pixels, min_r, min_c))

    # Reference: smallest min row, tie-breaker by min col
    ref_min_r, ref_min_c = min(((mi[2], mi[3]) for mi in layers_info))

    # Build output by aligning each layer
    output_grid = [[0 for _ in range(width)] for _ in range(height)]
    for color, abs_pixels, min_r, min_c in layers_info:
        shift_r = ref_min_r - min_r
        shift_c = ref_min_c - min_c
        for (r, c) in abs_pixels:
            new_r = r + shift_r
            new_c = c + shift_c
            if 0 <= new_r < height and 0 <= new_c < width:
                output_grid[new_r][new_c] = color

    # Ensure input and output differ
    if input_grid == output_grid:
        return generate()

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    visited = [[False] * width for _ in range(height)]
    layers = []

    # Find 4-connected components (each layer is a connected region of a single color)
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 or visited[r][c]:
                continue
            color = grid[r][c]
            stack = [(r, c)]
            visited[r][c] = True
            pixels = []
            while stack:
                cr, cc = stack.pop()
                pixels.append((cr, cc))
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            layers.append((color, pixels))

    if not layers:
        return grid

    # Compute top-left for each layer
    info = []  # (color, pixels, min_r, min_c)
    for color, pixels in layers:
        min_r = min(r for r, c in pixels)
        min_c = min(c for r, c in pixels)
        info.append((color, pixels, min_r, min_c))

    # Reference top-left
    ref_min_r, ref_min_c = min(((mi[2], mi[3]) for mi in info))

    # Build output by aligning each layer to the reference top-left
    output = [[0 for _ in range(width)] for _ in range(height)]
    for color, pixels, min_r, min_c in info:
        shift_r = ref_min_r - min_r
        shift_c = ref_min_c - min_c
        for r, c in pixels:
            new_r = r + shift_r
            new_c = c + shift_c
            if 0 <= new_r < height and 0 <= new_c < width:
                output[new_r][new_c] = color

    return output

