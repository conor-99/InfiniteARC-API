# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 9fce6740
Difficulty: mediumâ€“hard

=== Tags ===
- Cyclic coloring
- Associate images to numbers

=== Description ===
Input grids consist of a background color (0) and multiple distinct, non-
overlapping shapes formed by contiguous regions of identical non-zero colors.
Each shape represents a unique visual pattern (e.g., squares, lines, L-shapes)
with no overlapping or adjacent shapes sharing the same color. The output grid
transforms each shape by recoloring all its cells to a single color determined
by the shape's size (number of cells) modulo 10. Background cells remain
unchanged. The transformation requires identifying all connected components
(shapes), independently counting each shape's cell count, and applying the
cyclic color mapping (size mod 10) to every cell within that shape. This process
must be applied to all shapes in the grid, with no exceptions or special cases.
The task demands recognition of shape boundaries, precise cell counting, and
application of modular arithmetic to derive new colors, making it medium-hard
due to the need for multi-step visual analysis and avoidance of common pitfalls
like misidentifying connected regions or miscalculating modulo operations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
from common import grid, continuous_creature, randint, random_color

def generate():
    # Choose grid size (width W, height H)
    W = randint(3, min(20, 30))
    H = randint(3, min(20, 30))
    # Create grid with H rows and W columns
    grid_in = grid(W, H, 0)
    used_colors = set()
    shapes = []

    max_shapes = min(6, 9)
    n = randint(1, max_shapes)

    for _ in range(n):
        placed = False
        # Try a few times to create and place a shape
        for attempt in range(40):
            bw = randint(1, min(6, W))
            bh = randint(1, min(6, H))
            max_s = bw * bh
            if max_s <= 0:
                continue
            s = randint(1, max_s)
            target = s % 10
            color = random_color(exclude=[target])
            # Ensure unique initial color per shape
            tries_color = 0
            while color in used_colors and tries_color < 20:
                color = random_color(exclude=[target])
                tries_color += 1
            if color in used_colors:
                # Failed to find a unique color for this attempt
                continue
            sprite = continuous_creature(s, bw, bh)
            # Try to place the sprite somewhere it fits without overlap
            for _p in range(30):
                top = randint(0, H - bh)
                left = randint(0, W - bw)
                ok = True
                for (sr, sc) in sprite:
                    r = top + sr
                    c = left + sc
                    if grid_in[r][c] != 0:
                        ok = False
                        break
                if not ok:
                    continue
                # place shape
                cells = []
                for (sr, sc) in sprite:
                    r = top + sr
                    c = left + sc
                    grid_in[r][c] = color
                    cells.append((r, c))
                used_colors.add(color)
                shapes.append((cells, s))
                placed = True
                break
            if placed:
                break
        # next shape

    # If no shapes were successfully placed (rare), force a single-pixel shape
    if not shapes:
        r = randint(0, H - 1)
        c = randint(0, W - 1)
        s = 1
        target = s % 10
        color = random_color(exclude=[target])
        grid_in[r][c] = color
        shapes.append(([(r, c)], s))

    # Build output by recoloring each shape to size % 10
    grid_out = [row[:] for row in grid_in]
    for cells, s in shapes:
        target = s % 10
        for (r, c) in cells:
            grid_out[r][c] = target

    return {"input": grid_in, "output": grid_out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0]) if H > 0 else 0
    visited = [[False] * W for _ in range(H)]
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]

    for i in range(H):
        for j in range(W):
            if grid[i][j] == 0 or visited[i][j]:
                continue
            color = grid[i][j]
            stack = [(i, j)]
            visited[i][j] = True
            component = []
            while stack:
                r, c = stack.pop()
                component.append((r, c))
                for dr, dc in directions:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc] and grid[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            size = len(component)
            target = size % 10
            for (r, c) in component:
                grid[r][c] = target

    return tuple(tuple(row) for row in grid)

