# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: fcb7b7f9
Difficulty: medium

=== Tags ===
- Lattice completion
- Detect connectedness
- Reconstruct checkerboard from hint
- Orthogonal path planning

=== Description ===
The input grid is a 2D array containing a single connected region (orthogonally
connected) of non-zero colors that already follows a checkerboard pattern, with
the remaining cells set to 0. The connected region must contain exactly two
distinct colors arranged such that orthogonally adjacent cells within it
alternate between them. The task requires reconstructing the full checkerboard
pattern across the entire grid by extending the pattern observed in the
connected region. The solver must first detect the connected region (using
4-directional connectivity), identify the two colors used in the region,
determine the starting parity based on the top-leftmost cell of the region, and
then fill all empty cells (0s) with alternating colors such that orthogonally
adjacent cells consistently alternate. The output grid must maintain the
checkerboard pattern uniformly across all cells, matching the inferred color
sequence from the connected region's pattern.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(2, 30)
    height = random.randint(2, 30)
    colors = random.sample(range(1, 10), 2)
    A, B = colors
    region_w = random.randint(2, width)
    region_h = random.randint(2, height)
    input_grid = [[0] * width for _ in range(height)]
    output_grid = [[0] * width for _ in range(height)]
    for r in range(region_h):
        for c in range(region_w):
            if (r + c) % 2 == 0:
                input_grid[r][c] = A
            else:
                input_grid[r][c] = B
    for r in range(height):
        for c in range(width):
            if (r + c) % 2 == 0:
                output_grid[r][c] = A
            else:
                output_grid[r][c] = B
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    non_zero = []
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] != 0:
                non_zero.append((r, c))
    if not non_zero:
        return [[1 if (r + c) % 2 == 0 else 2 for c in range(len(input_grid[0]))] for r in range(len(input_grid))]
    r0, c0 = min(non_zero, key=lambda x: (x[0], x[1]))
    A = input_grid[r0][c0]
    colors_seen = set(input_grid[r][c] for r, c in non_zero)
    B = next(col for col in colors_seen if col != A)
    ref_parity = (r0 + c0) % 2
    output = [[A if (r + c) % 2 == ref_parity else B for c in range(len(input_grid[0]))] for r in range(len(input_grid))]
    return output
