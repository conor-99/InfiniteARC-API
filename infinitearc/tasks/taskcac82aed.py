# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: cac82aed
Difficulty: insane

=== Tags ===
- Hierarchical repetition
- Sequential path painting
- Draw line from point

=== Description ===
Task Description: Hierarchical Path Repetition  Input grids feature a central
seed cell surrounded by concentric rings of colored markers. Each ring
corresponds to a hierarchical level, with marker colors indicating level
progression (e.g., red = level 1, green = level 2, blue = level 3). The markers
are arranged at precise angular intervals along each ring's circumference, with
their positions encoding directional instructions for path progression (e.g.,
evenly spaced markers imply straight-line movement, clustered markers indicate
turns). The seed cell is a distinct color, and the background is a uniform
color.  The output grid must generate a continuous path starting at the seed
cell. For each level n, the path segment follows the directional pattern encoded
by the markers in ring n, with segment length scaled by n times the base length
(determined by the seed's initial orientation). The path progresses
sequentially: level 1 draws the base path, level 2 extends it with scaled
repetitions in the encoded direction, level 3 adds further scaled repetitions,
and so on. Each segment is painted with its level's marker color, with segments
transitioning smoothly at connection points. The output displays the complete
hierarchical path as a nested structure where each level's repetition appears at
progressively larger scales, forming a visually coherent fractal-like sequence
without overlaps or crossings, with all directional cues preserved from the
input's marker arrangements.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import math
from common import grid

def generate():
    # Hierarchical ring marker generator with variable size and randomness
    # Number of hierarchical levels (rings)
    num_levels = random.randint(2, 4)
    base_len = 1  # base step length used when drawing path segments

    # Ring geometry
    base_radius = random.randint(2, 3)
    ring_spacing = random.randint(2, 3)

    # Maximum extension needed to safely place the path and rings
    max_segment = sum(base_len * (i + 1) for i in range(num_levels))
    max_ring_radius = base_radius + ring_spacing * (num_levels - 1)
    margin = max(max_segment, max_ring_radius) + 2

    # Choose grid size that can fit the structure
    min_size = max(9, margin * 2 + 1)
    max_size = min(30, min_size + 8)
    size = random.randint(min_size, max_size)

    # Choose a center that leaves a margin on all sides
    cx = random.randint(margin, size - 1 - margin)
    cy = random.randint(margin, size - 1 - margin)

    # Create input grid
    grid_in = grid(size, size, 0)
    grid_in[cx][cy] = 9  # seed color

    # Choose distinct colors for each ring (exclude 9)
    colors_pool = [1, 2, 3, 4, 5, 6, 7, 8]
    color_choices = random.sample(colors_pool, num_levels)

    # Radii for rings (strictly increasing)
    radii = [base_radius + ring_spacing * i for i in range(num_levels)]

    for idx, radius in enumerate(radii):
        color = color_choices[idx]
        # Cluster center angle and spread. Small spread -> clustered markers (turns),
        # larger spread -> more spread-out markers (straighter cue).
        angle0 = random.random() * 2 * math.pi
        spread = random.uniform(math.pi / 12, math.pi / 3)
        n_markers = random.randint(1, min(8, int(radius * 1.5) + 1))

        angles = []
        if n_markers == 1:
            angles = [angle0]
        else:
            for j in range(n_markers):
                frac = (j - (n_markers - 1) / 2.0) / max(1, (n_markers - 1))
                ang = angle0 + frac * spread + random.uniform(-0.05, 0.05)
                angles.append(ang)

        positions = set()
        for ang in angles:
            dr = int(round(radius * math.sin(ang)))
            dc = int(round(radius * math.cos(ang)))
            r = cx + dr
            c = cy + dc
            if 0 <= r < size and 0 <= c < size and not (r == cx and c == cy):
                positions.add((r, c))

        # If rounding pushed points out of bounds (rare), place one marker at the
        # principal angle location on the ring.
        if not positions:
            dr = int(round(radius * math.sin(angle0)))
            dc = int(round(radius * math.cos(angle0)))
            r = cx + dr
            c = cy + dc
            if 0 <= r < size and 0 <= c < size and not (r == cx and c == cy):
                positions.add((r, c))

        for (r, c) in positions:
            grid_in[r][c] = color

    # Build output by interpreting ring markers as directional cues
    grid_out = grid(size, size, 0)
    grid_out[cx][cy] = 9

    # Identify marker colors (exclude background and seed)
    present_colors = sorted(list({grid_in[r][c] for r in range(size) for c in range(size) if grid_in[r][c] not in (0, 9)}))

    # Map colors to hierarchical level by mean distance from seed (inner rings -> lower levels)
    color_mean = {}
    for col in present_colors:
        coords = [(r, c) for r in range(size) for c in range(size) if grid_in[r][c] == col]
        color_mean[col] = sum(math.hypot(r - cx, c - cy) for r, c in coords) / len(coords)
    sorted_colors = sorted(present_colors, key=lambda c: color_mean[c])

    # Direction octants (angles) and corresponding integer step directions (dr, dc)
    centers = [-math.pi, -3 * math.pi / 4, -math.pi / 2, -math.pi / 4, 0, math.pi / 4, math.pi / 2, 3 * math.pi / 4]
    dir_vectors = [(0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1)]

    cur_r, cur_c = cx, cy
    for level, color in enumerate(sorted_colors, start=1):
        coords = [(r, c) for r in range(size) for c in range(size) if grid_in[r][c] == color]
        dr_avg = sum(r - cx for r, c in coords) / len(coords)
        dc_avg = sum(c - cy for r, c in coords) / len(coords)
        angle = math.atan2(dr_avg, dc_avg)

        def ang_diff(a, b):
            d = abs(a - b)
            if d > math.pi:
                d = 2 * math.pi - d
            return d

        # Candidate directions ordered by closeness to the measured angle
        candidates = sorted(range(len(centers)), key=lambda i: ang_diff(angle, centers[i]))

        length = level * base_len
        drawn = False
        for idx_dir in candidates:
            dr_dir, dc_dir = dir_vectors[idx_dir]
            can_draw = 0
            for step in range(1, length + 1):
                nr = cur_r + dr_dir * step
                nc = cur_c + dc_dir * step
                if not (0 <= nr < size and 0 <= nc < size):
                    break
                if grid_out[nr][nc] != 0:
                    break
                can_draw += 1
            if can_draw > 0:
                for k in range(1, can_draw + 1):
                    r = cur_r + dr_dir * k
                    c = cur_c + dc_dir * k
                    grid_out[r][c] = color
                cur_r += dr_dir * can_draw
                cur_c += dc_dir * can_draw
                drawn = True
                break
        # if no candidate allowed even a single step, skip this level

    return {
        'input': grid_in,
        'output': grid_out
    }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import math

def p(input_grid):
    # Convert to mutable list-of-lists
    grid_in = [list(row) for row in input_grid]
    size = len(grid_in)

    # Find seed (color 9)
    cx = cy = -1
    for r in range(size):
        for c in range(size):
            if grid_in[r][c] == 9:
                cx, cy = r, c
                break
        if cx != -1:
            break

    # Prepare output
    grid_out = [[0] * size for _ in range(size)]
    if cx == -1:
        # No seed found: return empty output
        return tuple(tuple(row) for row in grid_out)
    grid_out[cx][cy] = 9

    # Identify marker colors (exclude background and seed)
    present_colors = sorted(list({grid_in[r][c] for r in range(size) for c in range(size) if grid_in[r][c] not in (0, 9)}))

    # Map colors to hierarchical level by mean distance from seed
    color_mean = {}
    for col in present_colors:
        coords = [(r, c) for r in range(size) for c in range(size) if grid_in[r][c] == col]
        color_mean[col] = sum(math.hypot(r - cx, c - cy) for r, c in coords) / len(coords)
    sorted_colors = sorted(present_colors, key=lambda c: color_mean[c])

    # Direction octants (angles) and corresponding integer step directions (dr, dc)
    centers = [-math.pi, -3 * math.pi / 4, -math.pi / 2, -math.pi / 4, 0, math.pi / 4, math.pi / 2, 3 * math.pi / 4]
    dir_vectors = [(0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1)]

    cur_r, cur_c = cx, cy
    base_len = 1

    for level, color in enumerate(sorted_colors, start=1):
        coords = [(r, c) for r in range(size) for c in range(size) if grid_in[r][c] == color]
        if not coords:
            continue
        dr_avg = sum(r - cx for r, c in coords) / len(coords)
        dc_avg = sum(c - cy for r, c in coords) / len(coords)
        angle = math.atan2(dr_avg, dc_avg)

        def ang_diff(a, b):
            d = abs(a - b)
            if d > math.pi:
                d = 2 * math.pi - d
            return d

        candidates = sorted(range(len(centers)), key=lambda i: ang_diff(angle, centers[i]))

        length = level * base_len
        for idx_dir in candidates:
            dr_dir, dc_dir = dir_vectors[idx_dir]
            can_draw = 0
            for step in range(1, length + 1):
                nr = cur_r + dr_dir * step
                nc = cur_c + dc_dir * step
                if not (0 <= nr < size and 0 <= nc < size):
                    break
                if grid_out[nr][nc] != 0:
                    break
                can_draw += 1
            if can_draw > 0:
                for k in range(1, can_draw + 1):
                    r = cur_r + dr_dir * k
                    c = cur_c + dc_dir * k
                    grid_out[r][c] = color
                cur_r += dr_dir * can_draw
                cur_c += dc_dir * can_draw
                break

    return tuple(tuple(row) for row in grid_out)

