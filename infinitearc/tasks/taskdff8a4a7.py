# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: dff8a4a7
Difficulty: very hard

=== Tags ===
- Topological invariance
- Pattern rotation
- Deterministic reflection
- Propagation by rule weight

=== Description ===
# Topological Propagation Sequence  Input grids depict a complex maze-like
structure composed of multiple topologically connected regions of distinct
colors (1-9), separated by background cells (0). The maze is enclosed within a
grid boundary, with at least one "source" region positioned along the left edge
(not touching walls). Each source region is a contiguous area of uniform color,
and the maze contains irregular wall regions that form enclosed pathways and
passages. The grid may contain up to 6 distinct non-background colors, with each
color representing a unique propagation behavior.  The transformation applies
four deterministic rules in sequence:  1. **Rule Weight Determination**: For
each source region, calculate its area (number of cells) modulo the length of a
hidden color cycle (3-5 colors). This determines the starting rotation offset
within the cycle.  2. **Color Rotation**: Each source region's color is rotated
clockwise within the hidden cycle (e.g., if the cycle is [2,4,5] and offset=1,
color 2 becomes 4). The cycle must be inferred from example pairs.  3. **Path
Propagation**: Starting from the source's rightmost boundary cell, propagate
through background cells (0) in a direction determined by the source's *rotated*
color (e.g., color 2 = right, 4 = up, 5 = left). The propagation follows the
maze's open corridors without crossing walls.  4. **Deterministic Reflection**:
Upon hitting a wall (non-background cell), the path reflects 90° clockwise
(right → up → left → down → right) and the color rotates again within the cycle.
Each reflection step alternates direction and updates the color.  The output
grid preserves all original wall regions and their connectivity (topological
invariance), while adding propagation paths. The path color changes at each step
according to the rotation cycle, and reflections occur only at wall boundaries.
No path may overlap with existing regions or extend beyond the grid. The
transformation requires simultaneous application of all four rules across
multiple sources, with the hidden color cycle inferred from the examples.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Dimensions ensure enough room for the top-left pattern (2x2 blocks spaced by 1 column)
    width = random.randint(15, 20)  # ensure space for up to 5 blocks starting at col 1
    height = random.randint(12, 20)
    ingrid = grid(width, height, 0)

    # Hidden cycle: length 3..5
    L = random.randint(3, 5)
    possible_colors = list(range(1, 10))
    cycle_colors = random.sample(possible_colors, L)

    # Place 2x2 pattern blocks at top-left starting from column 1, separated by one column
    start_col = 1
    pattern_cols = set()
    for i, color in enumerate(cycle_colors):
        col = start_col + i * 3
        for r in range(0, 2):
            for c in range(col, col + 2):
                if r < height and c < width:
                    ingrid[r][c] = color
                    pattern_cols.add(c)

    # Choose wall colors distinct from cycle colors
    remaining = [c for c in possible_colors if c not in cycle_colors]
    wall_color_count = random.randint(1, min(4, len(remaining)))
    wall_colors = random.sample(remaining, wall_color_count)

    # Add random rectangular wall blocks to create irregular enclosed regions
    num_blocks = random.randint(3, 8)
    attempts = 0
    for _ in range(num_blocks):
        # pick a left/top that does not overlap the top two rows or pattern columns
        # ensure blocks do not intersect the 2-row pattern area
        w_block = random.randint(2, min(6, width - 4))
        h_block = random.randint(2, min(6, height - 4))
        # choose top starting at row >= 2
        top = random.randint(2, height - h_block - 2)
        # choose left so that block does not overlap pattern_cols
        left_candidates = [c for c in range(2, width - w_block - 1) if not any(pc in range(c, c + w_block) for pc in pattern_cols)]
        if not left_candidates:
            left = 2
        else:
            left = random.choice(left_candidates)
        color = random.choice(wall_colors)
        for r in range(top, top + h_block):
            for c in range(left, left + w_block):
                ingrid[r][c] = color

    # Add a few vertical bars with occasional gaps to create maze-like corridors
    num_bars = random.randint(2, max(2, min(5, (width - 6))))
    candidate_cols = [c for c in range(3, width - 3) if c not in pattern_cols]
    random.shuffle(candidate_cols)
    for col in candidate_cols[:num_bars]:
        color = random.choice(wall_colors)
        for r in range(1, height - 1):
            # leave gaps occasionally to form passages
            if random.random() < 0.8:
                ingrid[r][col] = color

    # Place exactly one source region on the left edge (column 0).
    # Source uses a color from the cycle and is a vertical contiguous block.
    source_color = random.choice(cycle_colors)
    size = random.randint(1, 4)
    # choose a start row away from the top pattern and bottom border
    attempts = 0
    while True:
        r0 = random.randint(2, height - 3 - size)
        # Prefer positions where the immediate right column (col 1) can be a corridor.
        ok = True
        for rr in range(r0, r0 + size):
            if rr < 2 and ingrid[rr][1] != 0:
                ok = False
                break
        if ok:
            break
        attempts += 1
        if attempts > 50:
            r0 = 2
            break
    # Place vertical source block at column 0 and ensure a corridor to its right
    for rr in range(r0, r0 + size):
        ingrid[rr][0] = source_color
        ingrid[rr][1] = 0

    # Carve a short corridor to the right of the source so propagation can begin
    steps = random.randint(1, 3)
    for step in range(1, steps + 1):
        if 1 + step < width:
            ingrid[r0][1 + step] = 0

    # Prepare output as a copy of the input (walls and source preserved)
    outgrid = [row[:] for row in ingrid]

    # Propagation rules (must match solver):
    directions = [(0, 1), (-1, 0), (0, -1), (1, 0)]  # right, up, left, down

    # Find the contiguous source region that touches the left edge and belongs to the cycle colors
    visited = set()
    for r in range(height):
        if ingrid[r][0] in cycle_colors and (r, 0) not in visited:
            color = ingrid[r][0]
            # BFS to collect the full connected region of that color
            stack = [(r, 0)]
            region = []
            while stack:
                rr, cc = stack.pop()
                if (rr, cc) in visited:
                    continue
                if ingrid[rr][cc] != color:
                    continue
                visited.add((rr, cc))
                region.append((rr, cc))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in visited and ingrid[nr][nc] == color:
                        stack.append((nr, nc))

            # Determine starting boundary cell: rightmost cell of the region, pick the topmost among equals
            area = len(region)
            maxc = max(c for rr, c in region)
            r_candidates = [rr for rr, c in region if c == maxc]
            r0 = min(r_candidates)
            c0 = maxc

            # Rule weight: use area modulo cycle length to compute starting rotation offset
            original_index = cycle_colors.index(color)
            current_color_index = (original_index + (area % L)) % L

            # Propagate from the rightmost boundary cell
            rr, cc = r0, c0
            while True:
                made_move = False
                # Try up to four reflections (i.e., four color/direction rotations) to find an open neighbor
                for attempt in range(4):
                    dr, dc = directions[current_color_index % 4]
                    nr, nc = rr + dr, cc + dc
                    # Out of bounds or blocked by original non-background cell -> reflect (advance color)
                    if not (0 <= nr < height and 0 <= nc < width):
                        current_color_index = (current_color_index + 1) % L
                        continue
                    if ingrid[nr][nc] != 0:
                        current_color_index = (current_color_index + 1) % L
                        continue
                    # Avoid overlapping previously drawn path from another source (treat as blocked)
                    if outgrid[nr][nc] != 0 and ingrid[nr][nc] == 0:
                        current_color_index = (current_color_index + 1) % L
                        continue
                    # Open cell found: paint it with the current color and advance the color
                    outgrid[nr][nc] = cycle_colors[current_color_index % L]
                    current_color_index = (current_color_index + 1) % L
                    rr, cc = nr, nc
                    made_move = True
                    break
                if not made_move:
                    # no available moves after trying all four reflections
                    break

    return {'input': ingrid, 'output': outgrid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable list of lists
    height = len(input_grid)
    width = len(input_grid[0])
    ingrid = [list(row) for row in input_grid]

    # Detect cycle colors from the top-left 2x2 pattern blocks (spaced by one column)
    cycle_colors = []
    c = 0
    while c + 1 < width and len(cycle_colors) < 5:
        color = ingrid[0][c]
        if color != 0 and 1 < height and c + 1 < width:
            ok = True
            for rr in (0, 1):
                for cc in (c, c + 1):
                    if ingrid[rr][cc] != color:
                        ok = False
                        break
                if not ok:
                    break
            if ok:
                cycle_colors.append(color)
                c += 3
                continue
        c += 1

    # Fallback if pattern not found
    if not cycle_colors:
        cycle_colors = [1, 2, 3]
    L = len(cycle_colors)

    directions = [(0, 1), (-1, 0), (0, -1), (1, 0)]  # right, up, left, down

    # Start with a copy of the input for the output; we'll paint paths on top of zeros only
    outgrid = [row[:] for row in ingrid]

    # Find source region on the left edge: connected components of cycle colors that touch column 0
    visited = set()
    for r in range(height):
        if ingrid[r][0] in cycle_colors and (r, 0) not in visited:
            color = ingrid[r][0]
            # BFS to get the full connected region of this color
            stack = [(r, 0)]
            region = []
            while stack:
                rr, cc = stack.pop()
                if (rr, cc) in visited:
                    continue
                if ingrid[rr][cc] != color:
                    continue
                visited.add((rr, cc))
                region.append((rr, cc))
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in visited and ingrid[nr][nc] == color:
                        stack.append((nr, nc))

            # Ensure this region touches the left edge (col 0)
            if not any(cc == 0 for rr, cc in region):
                continue

            # Determine starting rightmost boundary cell (topmost among those with max column)
            area = len(region)
            maxc = max(cc for rr, cc in region)
            r_candidates = [rr for rr, cc in region if cc == maxc]
            r0 = min(r_candidates)
            c0 = maxc

            # Compute starting color index using area modulo cycle length
            original_index = cycle_colors.index(color)
            current_color_index = (original_index + (area % L)) % L

            # Propagate following the deterministic reflection rule synchronized with color rotation
            rr, cc = r0, c0
            while True:
                made_move = False
                for attempt in range(4):
                    dr, dc = directions[current_color_index % 4]
                    nr, nc = rr + dr, cc + dc
                    # Blocked if out of bounds or original non-background
                    if not (0 <= nr < height and 0 <= nc < width):
                        current_color_index = (current_color_index + 1) % L
                        continue
                    if ingrid[nr][nc] != 0:
                        current_color_index = (current_color_index + 1) % L
                        continue
                    # Avoid painting over cells already painted by another source (treat as blocked)
                    if outgrid[nr][nc] != 0 and ingrid[nr][nc] == 0:
                        current_color_index = (current_color_index + 1) % L
                        continue
                    # Paint the cell and advance the cycle
                    outgrid[nr][nc] = cycle_colors[current_color_index % L]
                    current_color_index = (current_color_index + 1) % L
                    rr, cc = nr, nc
                    made_move = True
                    break
                if not made_move:
                    break

    return outgrid

