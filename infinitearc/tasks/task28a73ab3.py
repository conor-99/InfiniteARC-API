# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 28a73ab3
Difficulty: insane

=== Tags ===
- Color matching
- Global property defines local rule

=== Description ===
The input grid consists of a 2D arrangement of colors (0-9), where each color
represents a distinct visual element. The task requires identifying a specific
global property: the presence of a closed loop formed exclusively by color 1
cells, where each cell in the loop has exactly two neighboring color 1 cells
(forming a continuous cycle without branches or intersections). If such a loop
exists, all cells enclosed within the loop must be replaced with color 6. The
output grid reflects this transformation, while all other cells remain
unchanged. The complexity arises from the need to distinguish true closed loops
from fragmented or non-cyclic patterns of color 1, and to correctly identify the
enclosed interior regions in grids with multiple overlapping or nested loops.
Input grids are large (up to 30x30) and contain intricate arrangements of other
colors and shapes that may distract from the loop detection, demanding precise
visual reasoning to apply the rule consistently.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = [[0] * width for _ in range(height)]
    r = random.randint(0, height - 3)
    c = random.randint(0, width - 3)
    h_loop = random.randint(3, height - r)
    w_loop = random.randint(3, width - c)
    
    for i in range(r, r + h_loop):
        for j in range(c, c + w_loop):
            if i == r or i == r + h_loop - 1 or j == c or j == c + w_loop - 1:
                grid[i][j] = 1
    
    for i in range(r + 1, r + h_loop - 1):
        for j in range(c + 1, c + w_loop - 1):
            grid[i][j] = random.choice([0, 2, 3, 4, 5, 7, 8, 9])
    
    for i in range(height):
        for j in range(width):
            if not (r <= i < r + h_loop and c <= j < c + w_loop):
                if grid[i][j] != 1:
                    grid[i][j] = random.choice([0, 2, 3, 4, 5, 6, 7, 8, 9])
    
    output = [row[:] for row in grid]
    for i in range(r + 1, r + h_loop - 1):
        for j in range(c + 1, c + w_loop - 1):
            output[i][j] = 6
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    color1_cells = []
    for i in range(height):
        for j in range(width):
            if input_grid[i][j] == 1:
                color1_cells.append((i, j))
    
    if not color1_cells:
        return input_grid
    
    min_r = min(r for r, c in color1_cells)
    max_r = max(r for r, c in color1_cells)
    min_c = min(c for r, c in color1_cells)
    max_c = max(c for r, c in color1_cells)
    
    for i in range(min_r, max_r + 1):
        for j in range(min_c, max_c + 1):
            if i == min_r or i == max_r or j == min_c or j == max_c:
                if input_grid[i][j] != 1:
                    return input_grid
    
    output = [row[:] for row in input_grid]
    for i in range(min_r + 1, max_r):
        for j in range(min_c + 1, max_c):
            output[i][j] = 6
    return output
