# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 9bfcfe0a
Difficulty: hard

=== Tags ===
- Topological invariance
- Fill smallest enclosed hole

=== Description ===
Input grids feature a background of color 0 with non-zero colors forming
interconnected walls that enclose multiple regions of background color. These
enclosed regions (holes) are defined as connected components of 0s that are
completely surrounded by non-zero cells and do not touch the grid's boundary.
Each hole's size is determined by the number of cells it contains. The output
grid identifies the smallest enclosed hole (by cell count) and fills all its
cells with color 1, while leaving all other cells—walls, background regions, and
larger enclosed holes—unchanged. This task requires recognizing topological
enclosure through connectivity analysis rather than geometric shape, and
selecting the minimal area hole through precise counting, without any reliance
on visual symmetry, position, or color value properties. The solution must
correctly handle complex hole shapes and distinguish between similarly sized
regions through accurate area measurement.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    grid = [[0] * width for _ in range(height)]
    
    num_holes = random.randint(2, 4)
    holes = []
    
    # First hole is always 2x2 (smallest possible)
    h0, w0 = 2, 2
    r0 = random.randint(1, height - h0 - 2)
    c0 = random.randint(1, width - w0 - 2)
    wall_color0 = random.randint(1, 9)
    for dr in range(-1, h0 + 1):
        for dc in range(-1, w0 + 1):
            nr = r0 + dr
            nc = c0 + dc
            if 0 <= nr < height and 0 <= nc < width:
                if 0 <= dr < h0 and 0 <= dc < w0:
                    continue
                grid[nr][nc] = wall_color0
    holes.append((r0, c0, h0, w0, wall_color0))
    
    # Remaining holes are 3x3 (larger)
    for _ in range(1, num_holes):
        h = 3
        w = 3
        r = random.randint(1, height - h - 2)
        c = random.randint(1, width - w - 2)
        overlap = False
        for (r0, c0, _, _, _) in holes:
            if abs(r - r0) < 4 and abs(c - c0) < 4:
                overlap = True
                break
        if overlap:
            continue
        wall_color = random.randint(1, 9)
        for dr in range(-1, h + 1):
            for dc in range(-1, w + 1):
                nr = r + dr
                nc = c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    if 0 <= dr < h and 0 <= dc < w:
                        continue
                    grid[nr][nc] = wall_color
        holes.append((r, c, h, w, wall_color))
    
    # Smallest hole is always the first one (2x2)
    r, c, h, w = holes[0][0], holes[0][1], holes[0][2], holes[0][3]
    output = [row[:] for row in grid]
    for i in range(h):
        for j in range(w):
            output[r + i][c + j] = 1
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    visited = [[False] * width for _ in range(height)]
    enclosed_holes = []
    
    for i in range(height):
        for j in range(width):
            if grid[i][j] == 0 and not visited[i][j]:
                component = []
                queue = [(i, j)]
                visited[i][j] = True
                while queue:
                    r, c = queue.pop(0)
                    component.append((r, c))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == 0:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                
                touches_boundary = any(r == 0 or r == height - 1 or c == 0 or c == width - 1 for r, c in component)
                if not touches_boundary:
                    enclosed_holes.append((len(component), component))
    
    if enclosed_holes:
        enclosed_holes.sort(key=lambda x: x[0])
        _, region = enclosed_holes[0]
        for (r, c) in region:
            grid[r][c] = 1
    return grid
