# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 2d2e1066
Difficulty: hard

=== Tags ===
- Pattern rotation
- Energy field diffusion
- Circuit reflection

=== Description ===
Input grids feature a complex circuit path composed of connected cells in a
single circuit color (e.g., blue), forming a closed loop with multiple turns.
Scattered along this circuit are reflective nodes—2×2 blocks with distinct
diagonal patterns (top-left to bottom-right or top-right to bottom-left) that
indicate rotation direction. An energy source cell (e.g., red) is positioned at
the start of the circuit, and the background is a uniform color (e.g., black).
The transformation requires tracing the energy diffusion path from the source
cell along the circuit. The energy moves orthogonally through the circuit path
until encountering a reflective node. Upon contact, the energy direction rotates
90° clockwise for a top-left to bottom-right diagonal pattern or
counterclockwise for a top-right to bottom-left diagonal pattern, continuing
along the new direction. The output grid draws this path using a new color
(e.g., green), preserving the circuit, source, and reflective nodes without
overwriting them. The path must follow all turns dictated by reflective node
patterns, with no loops or intersections, and exit the circuit after a finite
number of reflections. The energy diffusion pattern is visually determined by
the circuit’s structure and the diagonal patterns of the reflective nodes,
requiring multi-step reasoning to infer the rotation rules from the input.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid


def generate():
    """
    Generate a random circuit-with-reflectors grid and its energy-diffusion output.

    Grid color convention:
      0 - background
      1 - circuit path
      2 - source (start)
      3 - reflector diagonal pixels (two per 2x2 block)
      4 - energy path (output only)

    The generator builds a simple 4-neighbor path starting from the left edge and
    walks forward, inserting 2x2 reflective nodes (anchored at the current cell
    as the top-left corner of the 2x2 block) occasionally. When a reflector is
    placed it deterministically rotates the walking direction (left or right)
    so that the subsequently constructed path is consistent with the reflector
    behavior. After the path reaches the boundary or cannot continue, the
    function simulates the energy diffusion (using the same rules) to paint
    the energy path in the output grid.
    """
    # Try repeatedly until we construct a valid (nontrivial) path
    for _ in range(100):
        size = random.randint(12, 20)
        ingrid = grid(size, size, 0)

        # Start on left edge at a random row (avoid the very bottom row so we can
        # place some 2x2 blocks during the path if needed).
        start_r = random.randint(0, size - 2)
        start_c = 0
        path = [(start_r, start_c)]
        visited = {path[0]}

        # Keep track of 2x2 blocks occupied by reflectors to avoid overlapping
        occupied = set()

        r, c = start_r, start_c
        # start moving to the right
        dr, dc = 0, 1

        # We will only change direction when placing a reflector; that means
        # direction changes are always detectable during the energy simulation.
        max_steps = size * size
        steps = 0

        while True:
            # Attempt to place a reflector at the current cell (but not at the
            # very first cell). Reflector must be anchored at top-left of a
            # 2x2 block, so r < size-1 and c < size-1.
            placed = False
            if len(path) > 1 and r < size - 1 and c < size - 1 and random.random() < 0.28:
                block = [(r, c), (r, c + 1), (r + 1, c), (r + 1, c + 1)]
                if not any(b in occupied for b in block):
                    # Choose rotation: 'R' -> clockwise, 'L' -> counterclockwise
                    turn = random.choice(["R", "L"])
                    if turn == "R":
                        # top-left to bottom-right diagonal (\) -> rotate clockwise
                        ingrid[r][c] = 3
                        ingrid[r + 1][c + 1] = 3
                        # ensure the other two cells are circuit cells
                        if ingrid[r][c + 1] == 0:
                            ingrid[r][c + 1] = 1
                        if ingrid[r + 1][c] == 0:
                            ingrid[r + 1][c] = 1
                        # commit the block as occupied
                        for b in block:
                            occupied.add(b)
                        # rotate direction clockwise
                        dr, dc = dc, -dr
                        placed = True
                    else:
                        # top-right to bottom-left diagonal (/) -> rotate counterclockwise
                        ingrid[r][c + 1] = 3
                        ingrid[r + 1][c] = 3
                        if ingrid[r][c] == 0:
                            ingrid[r][c] = 1
                        if ingrid[r + 1][c + 1] == 0:
                            ingrid[r + 1][c + 1] = 1
                        for b in block:
                            occupied.add(b)
                        # rotate direction counterclockwise
                        dr, dc = -dc, dr
                        placed = True

            # If we didn't place a reflector here, make sure this cell is a circuit
            # pixel (unless some reflector already wrote a 3 here).
            if not placed and ingrid[r][c] == 0:
                ingrid[r][c] = 1

            # Move forward one step in the current direction if possible.
            nr, nc = r + dr, c + dc
            if not (0 <= nr < size and 0 <= nc < size):
                # path leaves the grid -> this will be the natural exit
                break
            if (nr, nc) in visited:
                # would self-intersect; stop the path here
                break

            path.append((nr, nc))
            visited.add((nr, nc))
            r, c = nr, nc

            steps += 1
            if steps > max_steps:
                break

        # Fill any leftover path pixels (some were set by reflector placement)
        for (pr, pc) in path:
            if ingrid[pr][pc] == 0:
                ingrid[pr][pc] = 1

        # Must be a nontrivial path
        if len(path) < max(8, size // 2):
            continue

        # Ensure the start is not a reflector pixel
        if ingrid[path[0][0]][path[0][1]] == 3:
            continue

        # Place the source
        ingrid[path[0][0]][path[0][1]] = 2

        # Simulate the energy to paint the output overlay (preserve source and
        # reflector pixels, do not overwrite them)
        outgrid = [row[:] for row in ingrid]

        # Determine initial direction from the source by finding the adjacent
        # circuit pixel.
        sr, sc = path[0]
        start_dir = None
        for cand in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
            nr, nc = sr + cand[0], sc + cand[1]
            if 0 <= nr < size and 0 <= nc < size and ingrid[nr][nc] in (1, 3):
                start_dir = cand
                break
        if start_dir is None:
            # No outgoing circuit from source (degenerate) -> try again
            continue

        r, c = sr, sc
        dr, dc = start_dir
        visited_energy = set()
        step_limit = size * size * 2
        steps = 0
        while 0 <= r < size and 0 <= c < size and (r, c) not in visited_energy and steps < step_limit:
            visited_energy.add((r, c))
            # paint energy color unless it's a source or reflector
            if ingrid[r][c] not in (2, 3):
                outgrid[r][c] = 4

            # check for a 2x2 reflector anchored at (r,c)
            if r < size - 1 and c < size - 1:
                if ingrid[r][c] == 3 and ingrid[r + 1][c + 1] == 3:
                    # top-left to bottom-right diagonal -> rotate clockwise
                    dr, dc = dc, -dr
                elif ingrid[r][c + 1] == 3 and ingrid[r + 1][c] == 3:
                    # top-right to bottom-left diagonal -> rotate counterclockwise
                    dr, dc = -dc, dr

            # step forward
            r += dr
            c += dc
            steps += 1

        # Make sure output differs from input
        if outgrid != ingrid:
            return {"input": ingrid, "output": outgrid}

    # Fallback (should not normally happen): very small trivial grid
    size = 6
    ingrid = grid(size, size, 0)
    ingrid[2][0] = 2
    ingrid[2][1] = 1
    ingrid[2][2] = 1
    outgrid = [row[:] for row in ingrid]
    outgrid[2][0] = 4
    outgrid[2][1] = 4
    return {"input": ingrid, "output": outgrid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to a mutable grid
    grid_in = [list(row) for row in input_grid]
    h = len(grid_in)
    w = len(grid_in[0]) if h else 0
    grid_out = [row[:] for row in grid_in]

    # Find the source cell (value 2)
    source = None
    for r in range(h):
        for c in range(w):
            if grid_in[r][c] == 2:
                source = (r, c)
                break
        if source:
            break
    if source is None:
        return grid_out

    sr, sc = source
    # Determine initial direction by looking for an adjacent circuit pixel
    start_dir = None
    for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
        nr, nc = sr + dr, sc + dc
        if 0 <= nr < h and 0 <= nc < w and grid_in[nr][nc] in (1, 3):
            start_dir = (dr, dc)
            break
    if start_dir is None:
        return grid_out

    r, c = sr, sc
    dr, dc = start_dir
    visited = set()
    step_limit = h * w * 2
    steps = 0
    while 0 <= r < h and 0 <= c < w and (r, c) not in visited and steps < step_limit:
        visited.add((r, c))
        # Paint energy path unless this cell is a source or a reflector
        if grid_in[r][c] not in (2, 3):
            grid_out[r][c] = 4

        # Reflection checks (2x2 anchors with diagonals)
        if r < h - 1 and c < w - 1:
            if grid_in[r][c] == 3 and grid_in[r + 1][c + 1] == 3:
                # \ diagonal -> rotate clockwise
                dr, dc = dc, -dr
            elif grid_in[r][c + 1] == 3 and grid_in[r + 1][c] == 3:
                # / diagonal -> rotate counterclockwise
                dr, dc = -dc, dr

        r += dr
        c += dc
        steps += 1

    return grid_out

