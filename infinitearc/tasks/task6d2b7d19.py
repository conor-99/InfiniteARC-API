# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 6d2b7d19
Difficulty: hard

=== Tags ===
- Take maximum
- Image filling
- Pattern completion

=== Description ===
The task involves transforming an input grid into an output grid by identifying
the largest connected region (by area) and filling its bounding box with the
region's color. Input grids consist of 2D arrays with values 0â€“9, where 0
denotes empty cells and other values represent distinct colors. The output grid
is generated through the following steps:   1. **Identify all 4-connected
regions** (adjacent cells sharing the same non-zero color, considering
up/down/left/right neighbors).   2. **Determine the region with the maximum
area** (number of cells). In case of ties, the region with the smallest color
value (numerical) is selected.   3. **Compute the bounding box** of this largest
region (the smallest rectangle covering all its cells).   4. **Fill every cell
within this bounding box** with the largest region's color, overriding any
original values (including empty cells or other colors).    This transformation
requires multiple layers of reasoning: region detection, area calculation,
bounding box determination, and spatial filling. The input grids for a hard
difficulty task will feature complex arrangements with multiple regions of
similar size, irregular shapes, and overlapping color patterns, making it
challenging to accurately identify the largest region and its bounding box. The
output completes the "pattern" of the largest region by solidifying its bounding
box, fulfilling the "Image filling" and "Pattern completion" tags while relying
on the "Take maximum" principle (largest area). The visual nature of the task
ensures reliance on spatial relationships rather than numerical properties.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import continuous_creature

def generate():
    size = random.randint(5, 30)
    input_grid = [[0] * size for _ in range(size)]
    colors = [random.randint(1, 9) for _ in range(3)]
    for color in colors:
        region_size = random.randint(5, 15)
        pixels = continuous_creature(region_size, size, size)
        for (r, c) in pixels:
            input_grid[r][c] = color
    visited = [[False] * size for _ in range(size)]
    all_regions = []
    for r in range(size):
        for c in range(size):
            if input_grid[r][c] > 0 and not visited[r][c]:
                color = input_grid[r][c]
                component = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < size and 0 <= nc < size and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                all_regions.append((color, component))
    all_regions.sort(key=lambda x: (-len(x[1]), x[0]))
    largest_color, largest_region = all_regions[0]
    min_r = min(r for r, c in largest_region)
    max_r = max(r for r, c in largest_region)
    min_c = min(c for r, c in largest_region)
    max_c = max(c for r, c in largest_region)
    output_grid = [row[:] for row in input_grid]
    for r in range(min_r, max_r + 1):
        for c in range(min_c, max_c + 1):
            output_grid[r][c] = largest_color
    if input_grid == output_grid:
        return generate()
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid[0], tuple):
        input_grid = [list(row) for row in input_grid]
    size = len(input_grid)
    width = len(input_grid[0])
    visited = [[False] * width for _ in range(size)]
    regions = []
    for r in range(size):
        for c in range(width):
            if input_grid[r][c] > 0 and not visited[r][c]:
                color = input_grid[r][c]
                component = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < size and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                regions.append((color, component))
    regions.sort(key=lambda x: (-len(x[1]), x[0]))
    largest_color, largest_region = regions[0]
    min_r = min(r for r, c in largest_region)
    max_r = max(r for r, c in largest_region)
    min_c = min(c for r, c in largest_region)
    max_c = max(c for r, c in largest_region)
    output_grid = [row[:] for row in input_grid]
    for r in range(min_r, max_r + 1):
        for c in range(min_c, max_c + 1):
            output_grid[r][c] = largest_color
    return output_grid
