# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 47372498
Difficulty: very hard

=== Tags ===
- Incremental pattern growth
- Hollow shape detection
- Contouring
- Directed field
- Pattern reflection
- Move object to first unoccupied space

=== Description ===
Input grids feature multiple hollow rectangular regions enclosed by a continuous
single-color contour, with all interior cells empty (background color).
Scattered across the grid are distinct colored markers ("fillers") positioned
outside these hollow regions. The task requires identifying hollow regions
through contour detectionâ€”ensuring interior cells are fully enclosed by the
contour without gaps. Each hollow's primary dimension (width vs. height)
dictates a movement direction for fillers: wider hollows direct fillers to move
horizontally (left/right), while taller hollows direct fillers to move
vertically (up/down). Fillers must be moved to the first unoccupied interior
cell along this direction, prioritizing the nearest hollow region. After all
fillers are placed, the filled interior pattern within each hollow is reflected
across its central axis (horizontal for taller hollows, vertical for wider
hollows), creating a mirrored arrangement of fillers. The output grid retains
all original contours, displays filled interiors with markers, and shows the
reflected pattern, while all non-hollow cells and unused markers remain
unchanged.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Grid size
    width = random.randint(12, 20)
    height = random.randint(12, 20)
    grid = [[0 for _ in range(width)] for _ in range(height)]

    # Choose distinct colors for contours and fillers from 1..9
    colors = list(range(1, 10))
    random.shuffle(colors)

    # Number of hollows (rectangular contours)
    num_hollows = random.randint(2, 3)
    contour_colors = colors[:num_hollows]
    remaining_colors = colors[num_hollows:]

    hollows = []  # list of tuples (color, top, left, width, height)

    # Helper to check overlap with margin 1
    def overlaps_with_margin(top, left, w, h, existing):
        for (_, t2, l2, w2, h2) in existing:
            if not (top + h + 1 < t2 or t2 + h2 + 1 < top or left + w + 1 < l2 or l2 + w2 + 1 < left):
                return True
        return False

    # Place hollows randomly without overlapping (with margin)
    for color in contour_colors:
        placed = False
        for _ in range(300):
            w_h = random.randint(4, min(9, width - 4))  # total width including border
            h_h = random.randint(3, min(8, height - 4))
            if w_h == h_h:
                continue  # prefer non-square to have a clear primary dimension
            left = random.randint(1, width - w_h - 1)
            top = random.randint(1, height - h_h - 1)
            if overlaps_with_margin(top, left, w_h, h_h, hollows):
                continue
            # draw border
            for r in range(top, top + h_h):
                for c in range(left, left + w_h):
                    if r == top or r == top + h_h - 1 or c == left or c == left + w_h - 1:
                        grid[r][c] = color
            hollows.append((color, top, left, w_h, h_h))
            placed = True
            break
        if not placed:
            break

    # If placement failed to produce hollows, fallback to create one centered hollow
    if len(hollows) < 1:
        fallback_color = remaining_colors.pop(0) if remaining_colors else 1
        w_h = min(6, width - 4)
        h_h = min(5, height - 4)
        if w_h == h_h:
            w_h += 1
        left = (width - w_h) // 2
        top = (height - h_h) // 2
        for r in range(top, top + h_h):
            for c in range(left, left + w_h):
                if r == top or r == top + h_h - 1 or c == left or c == left + w_h - 1:
                    grid[r][c] = fallback_color
        hollows.append((fallback_color, top, left, w_h, h_h))

    # Compute total interior capacity (sum of interior cells)
    total_interior = 0
    for (_, top, left, w_h, h_h) in hollows:
        interior_w = max(0, w_h - 2)
        interior_h = max(0, h_h - 2)
        total_interior += interior_w * interior_h

    # Choose number of fillers (at least 1) and ensure we have enough distinct colors
    available_filler_colors = [c for c in range(1, 10) if c not in [h[0] for h in hollows]]
    max_fillers = min(5, len(available_filler_colors), total_interior if total_interior > 0 else 1)
    filler_count = random.randint(1, max(1, max_fillers)) if max_fillers > 0 else 0
    filler_colors = random.sample(available_filler_colors, filler_count) if filler_count > 0 else []

    # Helper to check if a cell is inside (including border) of any hollow
    def inside_any_hollow(r, c, hollows_list):
        for (_, top, left, w_h, h_h) in hollows_list:
            if top <= r <= top + h_h - 1 and left <= c <= left + w_h - 1:
                return True
        return False

    # Place at least one guaranteed filler adjacent to the first hollow (to ensure change)
    fillers = []  # list of tuples (color, r, c)
    used_positions = set()
    if filler_count > 0:
        first_h = hollows[0]
        _, t0, l0, w0, h0 = first_h
        center_r = t0 + h0 // 2
        # try place to the left of the hollow if possible
        cand_positions = []
        if l0 - 1 >= 0 and grid[center_r][l0 - 1] == 0:
            cand_positions.append((center_r, l0 - 1))
        if l0 + w0 < width and grid[center_r][l0 + w0] == 0:
            cand_positions.append((center_r, l0 + w0))
        if t0 - 1 >= 0 and grid[t0 - 1][l0 + w0 // 2] == 0:
            cand_positions.append((t0 - 1, l0 + w0 // 2))
        if t0 + h0 < height and grid[t0 + h0][l0 + w0 // 2] == 0:
            cand_positions.append((t0 + h0, l0 + w0 // 2))
        # pick first available candidate
        if cand_positions:
            pos = random.choice(cand_positions)
            color = filler_colors.pop(0)
            fillers.append((color, pos[0], pos[1]))
            grid[pos[0]][pos[1]] = color
            used_positions.add((pos[0], pos[1]))

    # Place remaining fillers randomly outside hollows and not on existing markers
    all_positions = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == 0]
    random.shuffle(all_positions)
    for color in filler_colors:
        placed = False
        for (r, c) in all_positions:
            if (r, c) in used_positions:
                continue
            if inside_any_hollow(r, c, hollows):
                continue
            # place filler here
            grid[r][c] = color
            fillers.append((color, r, c))
            used_positions.add((r, c))
            placed = True
            break
        if not placed:
            # no room found; skip this filler (should be rare)
            continue

    # Create output grid and perform placement into hollows + reflection
    output = [row[:] for row in grid]

    # Precompute hollow centers for nearest selection
    hollow_centers = []
    for (color, top, left, w_h, h_h) in hollows:
        center_r = top + (h_h // 2)
        center_c = left + (w_h // 2)
        hollow_centers.append((center_r, center_c))

    # Assign each filler to nearest hollow (Manhattan), then place them in increasing distance order
    assignment = []  # list of tuples (dist, color, fr, fc, hollow_index)
    for (color, fr, fc) in fillers:
        best_key = None
        chosen_idx = None
        for i, (h_color, top, left, w_h, h_h) in enumerate(hollows):
            cen_r, cen_c = hollow_centers[i]
            d = abs(fr - cen_r) + abs(fc - cen_c)
            key = (d, top, left)
            if best_key is None or key < best_key:
                best_key = key
                chosen_idx = i
        if chosen_idx is not None:
            assignment.append((best_key[0], color, fr, fc, chosen_idx))

    # Sort so nearest movers go first and deterministic tie-breaks
    assignment.sort(key=lambda x: (x[0], x[2], x[3], x[1]))

    for (_, color, fr, fc, hidx) in assignment:
        h_color, top, left, w_h, h_h = hollows[hidx]
        L_in = left + 1
        R_in = left + w_h - 2
        T_in = top + 1
        B_in = top + h_h - 2
        if L_in > R_in or T_in > B_in:
            continue  # no interior

        # Determine movement axis
        if w_h > h_h:
            # horizontal movement toward the hollow
            center_c = left + (w_h // 2)
            # choose entry column side
            if fc < center_c:
                start_c = L_in
                step = 1
            else:
                start_c = R_in
                step = -1
            # clamp row to interior
            target_r = fr
            if target_r < T_in:
                target_r = T_in
            elif target_r > B_in:
                target_r = B_in
            # search first unoccupied interior cell along the horizontal direction
            placed = False
            c = start_c
            while L_in <= c <= R_in:
                if output[target_r][c] == 0:
                    output[target_r][c] = color
                    # remove original marker
                    if output[fr][fc] == color:
                        output[fr][fc] = 0
                    placed = True
                    break
                c += step
            # if not placed, do nothing (marker stays)
        else:
            # vertical movement toward the hollow
            center_r = top + (h_h // 2)
            if fr < center_r:
                start_r = T_in
                step = 1
            else:
                start_r = B_in
                step = -1
            target_c = fc
            if target_c < L_in:
                target_c = L_in
            elif target_c > R_in:
                target_c = R_in
            placed = False
            r = start_r
            while T_in <= r <= B_in:
                if output[r][target_c] == 0:
                    output[r][target_c] = color
                    if output[fr][fc] == color:
                        output[fr][fc] = 0
                    placed = True
                    break
                r += step

    # Reflect filled interior patterns across hollow central axis
    for (h_color, top, left, w_h, h_h) in hollows:
        L_in = left + 1
        R_in = left + w_h - 2
        T_in = top + 1
        B_in = top + h_h - 2
        if L_in > R_in or T_in > B_in:
            continue
        filled = []
        for r in range(T_in, B_in + 1):
            for c in range(L_in, R_in + 1):
                if output[r][c] != 0 and output[r][c] != h_color:
                    filled.append((r, c, output[r][c]))
        # Mirror based on primary dimension
        if w_h > h_h:
            # vertical mirror across interior center column
            for (r, c, colval) in filled:
                new_c = L_in + R_in - c
                if L_in <= new_c <= R_in:
                    output[r][new_c] = colval
        else:
            # horizontal mirror across interior center row
            for (r, c, colval) in filled:
                new_r = T_in + B_in - r
                if T_in <= new_r <= B_in:
                    output[new_r][c] = colval

    return {'input': grid, 'output': output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    visited = [[False] * width for _ in range(height)]
    hollows = []  # (color, top, left, width, height)

    # Helper to collect a connected component of same color
    from collections import deque

    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 or visited[r][c]:
                continue
            color = grid[r][c]
            # BFS to collect component of this color
            q = deque()
            q.append((r, c))
            comp = []
            comp_set = set()
            while q:
                rr, cc = q.popleft()
                if (rr, cc) in comp_set:
                    continue
                if rr < 0 or rr >= height or cc < 0 or cc >= width:
                    continue
                if grid[rr][cc] != color:
                    continue
                comp_set.add((rr, cc))
                comp.append((rr, cc))
                for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in comp_set:
                        if grid[nr][nc] == color:
                            q.append((nr, nc))
            # bounding box
            minr = min(p[0] for p in comp)
            maxr = max(p[0] for p in comp)
            minc = min(p[1] for p in comp)
            maxc = max(p[1] for p in comp)
            h_h = maxr - minr + 1
            w_h = maxc - minc + 1
            # Validate that component is exactly the border of the bounding box and interior is zeros
            if h_h >= 3 and w_h >= 3:
                border_positions = set()
                for rr in range(minr, maxr + 1):
                    border_positions.add((rr, minc))
                    border_positions.add((rr, maxc))
                for cc in range(minc, maxc + 1):
                    border_positions.add((minr, cc))
                    border_positions.add((maxr, cc))
                # check all border positions have the color
                border_ok = True
                for (rr, cc) in border_positions:
                    if grid[rr][cc] != color:
                        border_ok = False
                        break
                # check interior cells are zero
                interior_ok = True
                for rr in range(minr + 1, maxr):
                    for cc in range(minc + 1, maxc):
                        if grid[rr][cc] != 0:
                            interior_ok = False
                            break
                    if not interior_ok:
                        break
                # ensure component size equals border size
                if border_ok and interior_ok and len(comp) == len(border_positions):
                    hollows.append((color, minr, minc, w_h, h_h))
                    for (rr, cc) in comp:
                        visited[rr][cc] = True

    # Identify filler markers (colors not used by hollows)
    hollow_colors = set(h[0] for h in hollows)
    fillers = []  # (color, r, c)
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and grid[r][c] not in hollow_colors:
                fillers.append((grid[r][c], r, c))

    # Prepare output copy
    output = [row[:] for row in grid]

    # Precompute hollow centers
    hollow_centers = []
    for (color, top, left, w_h, h_h) in hollows:
        center_r = top + (h_h // 2)
        center_c = left + (w_h // 2)
        hollow_centers.append((center_r, center_c))

    # Assign each filler to nearest hollow using tie-break (distance, top, left)
    assignment = []
    for (color, fr, fc) in fillers:
        best_key = None
        chosen_idx = None
        for i, (h_color, top, left, w_h, h_h) in enumerate(hollows):
            cen_r, cen_c = hollow_centers[i]
            d = abs(fr - cen_r) + abs(fc - cen_c)
            key = (d, top, left)
            if best_key is None or key < best_key:
                best_key = key
                chosen_idx = i
        if chosen_idx is not None:
            assignment.append((best_key[0], color, fr, fc, chosen_idx))

    # Sort assignments deterministically
    assignment.sort(key=lambda x: (x[0], x[2], x[3], x[1]))

    # Move fillers into hollows following the same rules as generator
    for (_, color, fr, fc, hidx) in assignment:
        h_color, top, left, w_h, h_h = hollows[hidx]
        L_in = left + 1
        R_in = left + w_h - 2
        T_in = top + 1
        B_in = top + h_h - 2
        if L_in > R_in or T_in > B_in:
            continue
        if w_h > h_h:
            center_c = left + (w_h // 2)
            if fc < center_c:
                start_c = L_in
                step = 1
            else:
                start_c = R_in
                step = -1
            target_r = fr
            if target_r < T_in:
                target_r = T_in
            elif target_r > B_in:
                target_r = B_in
            c = start_c
            while L_in <= c <= R_in:
                if output[target_r][c] == 0:
                    output[target_r][c] = color
                    if output[fr][fc] == color:
                        output[fr][fc] = 0
                    break
                c += step
        else:
            center_r = top + (h_h // 2)
            if fr < center_r:
                start_r = T_in
                step = 1
            else:
                start_r = B_in
                step = -1
            target_c = fc
            if target_c < L_in:
                target_c = L_in
            elif target_c > R_in:
                target_c = R_in
            r = start_r
            while T_in <= r <= B_in:
                if output[r][target_c] == 0:
                    output[r][target_c] = color
                    if output[fr][fc] == color:
                        output[fr][fc] = 0
                    break
                r += step

    # Reflection
    for (h_color, top, left, w_h, h_h) in hollows:
        L_in = left + 1
        R_in = left + w_h - 2
        T_in = top + 1
        B_in = top + h_h - 2
        if L_in > R_in or T_in > B_in:
            continue
        filled = []
        for r in range(T_in, B_in + 1):
            for c in range(L_in, R_in + 1):
                if output[r][c] != 0 and output[r][c] != h_color:
                    filled.append((r, c, output[r][c]))
        if w_h > h_h:
            for (r, c, colval) in filled:
                new_c = L_in + R_in - c
                if L_in <= new_c <= R_in:
                    output[r][new_c] = colval
        else:
            for (r, c, colval) in filled:
                new_r = T_in + B_in - r
                if T_in <= new_r <= B_in:
                    output[new_r][c] = colval

    return output

