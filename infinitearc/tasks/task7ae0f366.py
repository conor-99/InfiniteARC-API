# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 7ae0f366
Difficulty: hard

=== Tags ===
- Zigzag path
- Reactive surface

=== Description ===
The input grids feature a continuous straight-line path (represented by a single
color) moving orthogonally through a grid containing two distinct types of
reactive surface elements: "left-turn" cells (color Y) and "right-turn" cells
(color Z). The path originates at one edge of the grid and travels in a
consistent initial direction (e.g., horizontally right or vertically down). Upon
encountering a left-turn cell (Y), the path rotates 90 degrees counterclockwise
relative to its current direction; upon encountering a right-turn cell (Z), it
rotates 90 degrees clockwise. The path continues moving in the new direction
until it exits the grid boundary. The output grid must depict the complete
trajectory of the path after all directional changes, with the path drawn in its
original color and the reactive surface elements remaining unchanged. The
transformation requires sequential application of directional rules across
multiple reactive cells, with each turn dependent on the path's current
orientation. The task demands precise tracking of direction changes through a
series of interactions with the reactive surface, resulting in a zigzag path
that deviates from the input's initial straight-line configuration.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Generator for the zigzag path with reactive left/right turn tiles.
# Path color = 5, left-turn = 2, right-turn = 3. The input contains only the
# initial straight segment (color 5) plus reactive tiles (2/3) placed ahead.
# The output is the full traversed path: the path color marks every visited
# non-reactive cell and reactive tiles keep their color in the output.

def _rotate_left(d):
    return (-d[1], d[0])

def _rotate_right(d):
    return (d[1], -d[0])

def _inside(pos, w, h):
    r, c = pos
    return 0 <= r < h and 0 <= c < w


def generate():
    path_color = 5
    left_color = 2
    right_color = 3

    # Try repeatedly to create a valid configuration. We expect to succeed quickly.
    for attempt in range(400):
        width = random.randint(5, 15)
        height = random.randint(5, 15)

        # choose a starting edge and the inward direction
        edge = random.choice(['left', 'right', 'top', 'bottom'])
        if edge == 'left':
            start_row = random.randint(0, height - 1)
            start_col = 0
            initial_dir = (0, 1)
        elif edge == 'right':
            start_row = random.randint(0, height - 1)
            start_col = width - 1
            initial_dir = (0, -1)
        elif edge == 'top':
            start_col = random.randint(0, width - 1)
            start_row = 0
            initial_dir = (1, 0)
        else:  # bottom
            start_col = random.randint(0, width - 1)
            start_row = height - 1
            initial_dir = (-1, 0)

        # how many cells are available from the start moving straight until off-grid
        steps_possible = 0
        rr, cc = start_row, start_col
        while 0 <= rr < height and 0 <= cc < width:
            steps_possible += 1
            rr += initial_dir[0]
            cc += initial_dir[1]

        # require at least room for: initial path cell(s), first reactive tile and at least one cell after that
        if steps_possible < 3:
            continue

        # choose a small initial visible straight segment in the input (1..3)
        initial_length = random.randint(1, min(3, steps_possible - 2))
        initial_positions = [
            (start_row + i * initial_dir[0], start_col + i * initial_dir[1])
            for i in range(initial_length)
        ]

        # first reactive tile sits immediately after the visible initial segment
        first_reactive = (start_row + initial_length * initial_dir[0], start_col + initial_length * initial_dir[1])
        if not _inside(first_reactive, width, height):
            continue

        # ensure the first reactive tile is chosen so that the path will continue at least one more step
        visited = set(initial_positions)
        possible_first_colors = []
        for col in (left_color, right_color):
            new_dir = _rotate_left(initial_dir) if col == left_color else _rotate_right(initial_dir)
            after = (first_reactive[0] + new_dir[0], first_reactive[1] + new_dir[1])
            if _inside(after, width, height) and after not in visited:
                possible_first_colors.append(col)
        if not possible_first_colors:
            # cannot place a reactive tile here that leads to another cell, try another configuration
            continue

        first_color = random.choice(possible_first_colors)

        # build the input grid: background 0, initial visible path cells = path_color,
        # reactive tiles at chosen positions = left_color/right_color
        input_grid = grid(width, height, 0)
        for (r, c) in initial_positions:
            input_grid[r][c] = path_color
        input_grid[first_reactive[0]][first_reactive[1]] = first_color

        # Mark as visited the cells that will be part of the path so far (initial + first reactive)
        visited.add(first_reactive)

        # extend the reactive tile sequence a few more times (randomly) while avoiding
        # self-intersection and leaving room for movement
        current_pos = first_reactive
        current_dir = _rotate_left(initial_dir) if first_color == left_color else _rotate_right(initial_dir)
        extra_turns = random.randint(0, 4)
        for _ in range(extra_turns):
            # how many empty steps are available in current_dir before border or a visited cell
            steps_available = 0
            tr, tc = current_pos[0] + current_dir[0], current_pos[1] + current_dir[1]
            while _inside((tr, tc), width, height) and (tr, tc) not in visited:
                steps_available += 1
                tr += current_dir[0]
                tc += current_dir[1]
            if steps_available == 0:
                break
            # choose a small distance to the next reactive tile
            d = random.randint(1, min(steps_available, 4))
            nr, nc = current_pos
            for _step in range(d):
                nr += current_dir[0]
                nc += current_dir[1]
                visited.add((nr, nc))
            # place a reactive tile at (nr, nc)
            color = random.choice((left_color, right_color))
            input_grid[nr][nc] = color
            current_pos = (nr, nc)
            current_dir = _rotate_left(current_dir) if color == left_color else _rotate_right(current_dir)

        # Now simulate the full traversal to create the output grid
        output_grid = grid(width, height, 0)
        r, c = start_row, start_col
        cur_dir = initial_dir
        seen = set()
        safe_counter = 0
        while _inside((r, c), width, height) and (r, c) not in seen and safe_counter < width * height * 4:
            seen.add((r, c))
            val = input_grid[r][c]
            # reactive tiles are preserved in the output; non-reactive visited cells are painted with path_color
            if val == left_color or val == right_color:
                output_grid[r][c] = val
                cur_dir = _rotate_left(cur_dir) if val == left_color else _rotate_right(cur_dir)
            else:
                output_grid[r][c] = path_color
            r += cur_dir[0]
            c += cur_dir[1]
            safe_counter += 1

        # ensure the transformation changed something (input != output) and is valid
        if input_grid != output_grid:
            return {'input': input_grid, 'output': output_grid}

    # In the unlikely event the random attempts failed, return a deterministic small example
    width, height = 7, 7
    input_grid = grid(width, height, 0)
    # start at left row 3 going right for two cells, then a right-turn, then continue
    input_grid[3][0] = path_color
    input_grid[3][1] = path_color
    input_grid[3][2] = right_color
    input_grid[4][2] = left_color
    input_grid[4][3] = 0
    # produce the output by simulating the rule so the fallback is self-consistent
    output_grid = grid(width, height, 0)
    r, c = 3, 0
    cur_dir = (0, 1)
    for _ in range(50):
        if not _inside((r, c), width, height):
            break
        val = input_grid[r][c]
        if val in (left_color, right_color):
            output_grid[r][c] = val
            cur_dir = _rotate_left(cur_dir) if val == left_color else _rotate_right(cur_dir)
        else:
            output_grid[r][c] = path_color
        r += cur_dir[0]
        c += cur_dir[1]
    return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from typing import List, Tuple

def p(input_grid: Tuple[Tuple[int, ...], ...]) -> List[List[int]]:
    # Convert to mutable list
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    path_color = 5
    left_color = 2
    right_color = 3

    def inside(r, c):
        return 0 <= r < height and 0 <= c < width

    def rotate_left(d):
        return (-d[1], d[0])

    def rotate_right(d):
        return (d[1], -d[0])

    # collect all input path cells and reactive cells
    input_path_cells = {(r, c) for r in range(height) for c in range(width) if grid[r][c] == path_color}
    input_reactive_cells = {(r, c) for r in range(height) for c in range(width) if grid[r][c] in (left_color, right_color)}

    # Candidate starts: border cells that are painted with path_color (typical origin)
    candidates = []
    for c in range(width):
        if height > 0 and grid[0][c] == path_color:
            candidates.append((0, c))
    for c in range(width):
        if height > 0 and grid[height - 1][c] == path_color:
            candidates.append((height - 1, c))
    for r in range(height):
        if width > 0 and grid[r][0] == path_color:
            candidates.append((r, 0))
    for r in range(height):
        if width > 0 and grid[r][width - 1] == path_color:
            candidates.append((r, width - 1))

    # If there are no border path cells (unexpected), consider any path cell as a candidate
    if not candidates:
        candidates = list(input_path_cells)

    # Try each candidate and each initial direction; pick the simulation that matches the input markings
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    def simulate_from(start, init_dir):
        r, c = start
        cur_dir = init_dir
        visited = []
        seen = set()
        steps = 0
        while inside(r, c) and (r, c) not in seen and steps < width * height * 4:
            seen.add((r, c))
            visited.append((r, c))
            val = grid[r][c]
            if val == left_color:
                cur_dir = rotate_left(cur_dir)
            elif val == right_color:
                cur_dir = rotate_right(cur_dir)
            r += cur_dir[0]
            c += cur_dir[1]
            steps += 1
        return visited

    chosen_visited = None
    for start in candidates:
        for d in directions:
            # direction must point into the grid from the border candidate (if start is on an edge)
            # but we don't strictly require this for interior candidates
            nr, nc = start[0] + d[0], start[1] + d[1]
            if not inside(nr, nc):
                continue
            visited = simulate_from(start, d)
            visited_set = set(visited)
            # Ensure that all path cells present in the input are visited by this simulation
            if input_path_cells.issubset(visited_set) and input_reactive_cells.issubset(visited_set):
                chosen_visited = visited
                break
        if chosen_visited is not None:
            break

    # If no simulation matched exactly, fall back to a simple heuristic: pick the first candidate and
    # neighbor with non-zero (reactive or path) as the initial direction and simulate once.
    if chosen_visited is None:
        start = candidates[0] if candidates else (0, 0)
        r0, c0 = start
        cur_dir = None
        for d in directions:
            nr, nc = r0 + d[0], c0 + d[1]
            if inside(nr, nc) and grid[nr][nc] in (path_color, left_color, right_color):
                cur_dir = d
                break
        if cur_dir is None:
            # pick some inward direction
            for d in directions:
                nr, nc = r0 + d[0], c0 + d[1]
                if inside(nr, nc):
                    cur_dir = d
                    break
        chosen_visited = simulate_from(start, cur_dir)

    # Build output grid: reactive tiles remain their original color; other visited positions become path_color
    output = [[0] * width for _ in range(height)]
    for (r, c) in chosen_visited:
        if 0 <= r < height and 0 <= c < width:
            if grid[r][c] in (left_color, right_color):
                output[r][c] = grid[r][c]
            else:
                output[r][c] = path_color

    return output

