# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 91d5afe8
Difficulty: hard

=== Tags ===
- Nested structure detection
- Detect enclosure
- Find and double the smallest object

=== Description ===
Input grids feature a background color (0) with multiple non-background objects
(connected components of colors 1-9), forming nested structures where some
objects are enclosed within others. Each object is a distinct connected region
with no overlapping colors. The smallest object is defined as the connected
component with the fewest cells (e.g., a single cell is smaller than a 2-cell
object). The output grid retains all original objects but adds a copy of the
smallest object at the top-left corner (0,0), which is guaranteed to be
background (color 0) in all inputs. This requires identifying the smallest
object through size comparison (not color or position), detecting nested
enclosures to distinguish separate objects, and applying a deterministic
placement rule. The transformation is non-overwriting, preserving all original
structures while duplicating only the smallest object.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(15, 25)
    height = random.randint(15, 25)
    grid = [[0] * width for _ in range(height)]
    colors = list(range(1, 10))
    smallest_color = random.choice(colors)
    colors.remove(smallest_color)
    r = random.randint(2, height-3)
    c = random.randint(2, width-3)
    grid[r][c] = smallest_color
    medium_color = random.choice(colors)
    colors.remove(medium_color)
    for i in range(r-1, r+2):
        for j in range(c-1, c+2):
            if i == r-1 or i == r+1 or j == c-1 or j == c+1:
                grid[i][j] = medium_color
    outer_color = random.choice(colors)
    for i in range(r-2, r+3):
        for j in range(c-2, c+3):
            if i == r-2 or i == r+2 or j == c-2 or j == c+2:
                grid[i][j] = outer_color
    output = [row[:] for row in grid]
    output[0][0] = smallest_color
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    visited = [[False] * width for _ in range(height)]
    directions = [(1,0), (-1,0), (0,1), (0,-1)]
    components = {}
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                color = input_grid[r][c]
                stack = [(r, c)]
                visited[r][c] = True
                component_cells = []
                while stack:
                    cr, cc = stack.pop()
                    component_cells.append((cr, cc))
                    for dr, dc in directions:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                size = len(component_cells)
                components[color] = size
    smallest_color = min(components, key=components.get)
    output = [row[:] for row in input_grid]
    output[0][0] = smallest_color
    return output
