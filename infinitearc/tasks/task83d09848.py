# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 83d09848
Difficulty: very hard

=== Tags ===
- Hierarchical reasoning
- Fill holes

=== Description ===
Input grids feature a complex hierarchical structure of nested geometric shapes
(e.g., rectangles or circles) arranged concentrically, each with a central
background "hole" region. The shapes are separated by consistent background
gaps, and each has a distinct color. The hole within a shape is proportional to
its size (e.g., a 7x7 rectangle has a 3x3 hole), positioned at the center and
surrounded by the shape's color. The hierarchy is defined by the nesting depth:
the outermost shape is level 1, the next inner level 2, and so on.  The
transformation requires filling each hole with a pattern derived from the
hierarchical properties of the enclosing shape. For a hole at level N (counting
from the outermost), the fill pattern is a scaled-down, rotated, and color-
transformed version of the shape at level N-1. Specifically:   - **Rotation**:
Each level's fill pattern is rotated 90° clockwise relative to the previous
level.   - **Color transformation**: The fill color cycles through the sequence
(e.g., 0→1→2→...→9→0) based on the level's parity (odd levels shift forward,
even levels shift backward).   - **Scaling**: The fill pattern's dimensions are
reduced by 50% (rounded down) compared to the enclosing shape's size.    The
output grid must fill all holes without overlapping the surrounding shape
outlines or other holes. Background regions outside the nested structures remain
unchanged. The solution requires identifying the hierarchical level of each
hole, applying the level-specific rotation and color transformation, and scaling
the pattern accordingly. This demands multi-layered reasoning to track
transformations across nested structures while respecting visual constraints.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from copy import deepcopy
from common import grid

def rotate_cw(mat):
    if not mat: return mat
    h = len(mat)
    w = len(mat[0])
    # rotate 90 degrees clockwise
    return [[mat[h - 1 - r][c] for r in range(h)] for c in range(w)]


def generate():
    """
    Generates a concentric-hollow-square hierarchy with 2-3 levels.
    Each level is a hollow square (border thickness = 2). The inner hole of
    each level (level >= 2) is filled with a scaled-down (50%), rotated and
    color-transformed version of the previous level's shape.

    Returns:
      A dict with keys "input" and "output" mapping to 2D lists of ints.
    """
    # Number of levels: keep to 2 or 3 for reliably fitting patterns
    levels = random.choice([2, 3])

    # Border thickness (fixed to 2 to match the intended hierarchical shrinking)
    b = 2

    # Choose an outer size s1 so that all inner levels fit comfortably.
    # We pick odd/even sizes >= 15 up to 25 to ensure the scaled pattern fits.
    possible_s1 = [s for s in range(15, 26) if s - 2 * b * (levels - 1) >= 3]
    s1 = random.choice(possible_s1)

    # Grid size: allow a small margin around the outer shape to increase variety
    max_grid = min(30, s1 + 6)
    grid_size = random.randint(s1, max_grid)

    # Top-left offset for the outer shape: keep shapes concentric but move them
    # around the grid to increase variety.
    margin_r = random.randint(0, grid_size - s1)
    margin_c = random.randint(0, grid_size - s1)

    # Distinct non-zero colors for each level
    colors = random.sample(list(range(1, 10)), levels)

    # Create empty input grid
    input_grid = grid(grid_size, grid_size, 0)

    # Store shape descriptors: (top, left, size, color)
    shapes = []
    for lvl in range(levels):
        size = s1 - (2 * b) * lvl  # shrink by 2*b each level
        top = margin_r + lvl * b
        left = margin_c + lvl * b
        color = colors[lvl]
        shapes.append((top, left, size, color))

        # Draw hollow square border of thickness b
        for r in range(top, top + size):
            for c in range(left, left + size):
                if (r - top < b) or (r - top >= size - b) or (c - left < b) or (c - left >= size - b):
                    input_grid[r][c] = color

    # Create output as a copy and then fill holes according to the rules
    output_grid = [row[:] for row in input_grid]

    # For each inner level (level index >= 1) fill its internal hole by deriving
    # a pattern from the previous (outer) level.
    for idx in range(1, levels):
        prev_top, prev_left, prev_size, prev_color = shapes[idx - 1]
        cur_top, cur_left, cur_size, cur_color = shapes[idx]

        # Extract the previous level's bounding box
        prev_box = [[input_grid[prev_top + r][prev_left + c] for c in range(prev_size)] for r in range(prev_size)]

        # Scaling: downscale by factor ~2 using 2x2 blocks (majority/any non-zero -> filled)
        psize = prev_size // 2
        if psize < 1:
            continue
        pattern = [[0 for _ in range(psize)] for _ in range(psize)]
        for pr in range(psize):
            for pc in range(psize):
                found = False
                base_r = pr * 2
                base_c = pc * 2
                for dr in (0, 1):
                    for dc in (0, 1):
                        rr = base_r + dr
                        cc = base_c + dc
                        if rr < prev_size and cc < prev_size and prev_box[rr][cc] != 0:
                            found = True
                if found:
                    pattern[pr][pc] = prev_color

        # Rotation: each inner level's pattern is rotated 90deg clockwise relative to
        # the previous level. Cumulatively the rotation count = idx (since outermost
        # level is index 0)
        rot = idx % 4
        for _ in range(rot):
            pattern = rotate_cw(pattern)

        # Color transformation: odd levels shift forward (+1), even levels shift backward (-1)
        # Level numbering: outermost = 1, so current level = idx+1
        level_num = idx + 1
        shift = 1 if (level_num % 2 == 1) else -1
        def transform_color(c):
            return ((c - 1 + shift) % 9) + 1

        for r in range(len(pattern)):
            for c in range(len(pattern[0])):
                if pattern[r][c] != 0:
                    pattern[r][c] = transform_color(pattern[r][c])

        # Place the pattern centered in the current shape's hole
        hole_top = cur_top + b
        hole_left = cur_left + b
        hole_size = cur_size - 2 * b
        if hole_size <= 0:
            continue
        start_r = hole_top + (hole_size - len(pattern)) // 2
        start_c = hole_left + (hole_size - len(pattern[0])) // 2

        for pr in range(len(pattern)):
            for pc in range(len(pattern[0])):
                val = pattern[pr][pc]
                if val != 0:
                    rr = start_r + pr
                    cc = start_c + pc
                    if 0 <= rr < grid_size and 0 <= cc < grid_size:
                        output_grid[rr][cc] = val

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert tuple-of-tuples to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0]) if H > 0 else 0

    # Collect all non-zero colors and bounding boxes for each color
    color_boxes = {}
    for r in range(H):
        for c in range(W):
            v = grid[r][c]
            if v == 0: continue
            if v not in color_boxes:
                color_boxes[v] = [r, r, c, c]
            else:
                box = color_boxes[v]
                if r < box[0]: box[0] = r
                if r > box[1]: box[1] = r
                if c < box[2]: box[2] = c
                if c > box[3]: box[3] = c

    # Each color corresponds to a hollow square; build shape descriptors (top,left,size,color)
    shapes = []
    for color, (rmin, rmax, cmin, cmax) in color_boxes.items():
        size_r = rmax - rmin + 1
        size_c = cmax - cmin + 1
        size = min(size_r, size_c)
        shapes.append((rmin, cmin, size, color))

    # Sort by bounding-box size descending to get outer-to-inner order
    shapes.sort(key=lambda x: -x[2])

    if len(shapes) <= 1:
        return grid

    # Helper: rotate clockwise
    def rotate_cw(mat):
        if not mat: return mat
        h = len(mat)
        w = len(mat[0])
        return [[mat[h - 1 - r][c] for r in range(h)] for c in range(w)]

    # Helper: color shift among 1..9 (avoid 0 background)
    def shift_color(c, shift):
        return ((c - 1 + shift) % 9) + 1

    # Detect border thickness for each shape (robust): count full-color rows from top and full-color cols from left
    borders = []
    for (top, left, size, color) in shapes:
        # count consecutive full-color rows from top
        b_row = 0
        for r in range(top, top + size):
            ok = True
            for cc in range(left, left + size):
                if grid[r][cc] != color:
                    ok = False
                    break
            if ok:
                b_row += 1
            else:
                break
        # count consecutive full-color cols from left
        b_col = 0
        for c in range(left, left + size):
            ok = True
            for rr in range(top, top + size):
                if grid[rr][c] != color:
                    ok = False
                    break
            if ok:
                b_col += 1
            else:
                break
        b = min(b_row, b_col)
        if b <= 0:
            b = 1
        borders.append(b)

    # Work on a copy for output
    out = [row[:] for row in grid]

    # For each inner shape, create a fill pattern from the previous (outer) shape
    for idx in range(1, len(shapes)):
        prev_top, prev_left, prev_size, prev_color = shapes[idx - 1]
        cur_top, cur_left, cur_size, cur_color = shapes[idx]
        prev_b = borders[idx - 1]
        cur_b = borders[idx]

        # Extract previous bounding box
        prev_box = [[grid[prev_top + r][prev_left + c] for c in range(prev_size)] for r in range(prev_size)]

        # Downscale by 2x2 blocks
        psize = prev_size // 2
        if psize < 1:
            continue
        pattern = [[0 for _ in range(psize)] for _ in range(psize)]
        for pr in range(psize):
            for pc in range(psize):
                any_nonzero = False
                base_r = pr * 2
                base_c = pc * 2
                for dr in (0, 1):
                    for dc in (0, 1):
                        rr = base_r + dr
                        cc = base_c + dc
                        if rr < prev_size and cc < prev_size and prev_box[rr][cc] != 0:
                            any_nonzero = True
                if any_nonzero:
                    # use the previous level's color for the pattern cell
                    pattern[pr][pc] = prev_color

        # Rotation: cumulative 90deg clockwise per level (outermost has index 0)
        rot = idx % 4
        for _ in range(rot):
            pattern = rotate_cw(pattern)

        # Color transform for current level (level numbering = idx+1)
        level_num = idx + 1
        shift = 1 if (level_num % 2 == 1) else -1
        for pr in range(len(pattern)):
            for pc in range(len(pattern[0])):
                if pattern[pr][pc] != 0:
                    pattern[pr][pc] = shift_color(pattern[pr][pc], shift)

        # Place pattern centered in the current hole
        hole_top = cur_top + cur_b
        hole_left = cur_left + cur_b
        hole_size = cur_size - 2 * cur_b
        if hole_size <= 0:
            continue
        start_r = hole_top + (hole_size - len(pattern)) // 2
        start_c = hole_left + (hole_size - len(pattern[0])) // 2

        for pr in range(len(pattern)):
            for pc in range(len(pattern[0])):
                val = pattern[pr][pc]
                if val != 0:
                    rr = start_r + pr
                    cc = start_c + pc
                    if 0 <= rr < H and 0 <= cc < W:
                        out[rr][cc] = val

    return out

