# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: e3b74155
Difficulty: medium–hard

=== Tags ===
- Simulate billiards shot
- Pattern repetition with offset
- Connect all dots of same color
- Enclosure completion
- Connect two dots with a line
- Adapt image to grid

=== Description ===
Input grids feature a background color (0) with multiple colored dots (1-9),
where each color appears at least twice in distinct positions. The output grid
connects all dots of the same color using paths that simulate billiard ball
reflections—moving in straight lines and bouncing off grid edges at 90-degree
angles, avoiding non-background cells. Paths must follow the shortest route
(minimal reflections) between dots, with connections sequenced by spatial order
(e.g., top-to-bottom, left-to-right). After all paths are drawn, any enclosed
regions formed by these paths and grid boundaries are filled with the connecting
color. The transformation ensures no overlapping connections, preserves original
dot positions, and adapts the visual path to grid geometry without relying on
numerical values.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    input_grid = grid(width, height, 0)
    output_grid = grid(width, height, 0)
    
    colors = [1, 2, 3]
    for color in colors:
        top = random.randint(2, height - 4)
        left = random.randint(2, width - 4)
        bottom = random.randint(top + 2, height - 2)
        right = random.randint(left + 2, width - 2)
        dots = [(top, left), (top, right), (bottom, right), (bottom, left)]
        for r, c in dots:
            input_grid[r][c] = color
            output_grid[r][c] = color
    
    for color in colors:
        dots = []
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == color:
                    dots.append((r, c))
        if not dots:
            continue
        dots.sort(key=lambda x: (x[0], x[1]))
        for i in range(len(dots)):
            r1, c1 = dots[i]
            r2, c2 = dots[(i+1) % len(dots)]
            if r1 == r2:
                for c in range(min(c1, c2), max(c1, c2) + 1):
                    output_grid[r1][c] = color
            elif c1 == c2:
                for r in range(min(r1, r2), max(r1, r2) + 1):
                    output_grid[r][c1] = color
        
        min_r = min(r for r, c in dots)
        max_r = max(r for r, c in dots)
        min_c = min(c for r, c in dots)
        max_c = max(c for r, c in dots)
        for r in range(min_r + 1, max_r):
            for c in range(min_c + 1, max_c):
                output_grid[r][c] = color
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    input_grid = [list(row) for row in input_grid]
    output_grid = [row[:] for row in input_grid]
    
    colors = set()
    for row in input_grid:
        for val in row:
            if val > 0:
                colors.add(val)
    
    for color in colors:
        positions = []
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == color:
                    positions.append((r, c))
        if len(positions) < 2:
            continue
        
        positions.sort(key=lambda x: (x[0], x[1]))
        for i in range(len(positions)):
            r1, c1 = positions[i]
            r2, c2 = positions[(i+1) % len(positions)]
            if r1 == r2:
                for c in range(min(c1, c2), max(c1, c2) + 1):
                    output_grid[r1][c] = color
            elif c1 == c2:
                for r in range(min(r1, r2), max(r1, r2) + 1):
                    output_grid[r][c1] = color
        
        min_r = min(r for r, c in positions)
        max_r = max(r for r, c in positions)
        min_c = min(c for r, c in positions)
        max_c = max(c for r, c in positions)
        for r in range(min_r + 1, max_r):
            for c in range(min_c + 1, max_c):
                output_grid[r][c] = color
    
    return output_grid
