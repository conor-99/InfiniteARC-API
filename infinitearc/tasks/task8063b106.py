# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 8063b106
Difficulty: very hard

=== Tags ===
- Simulate billiards shot
- Propagation by rule weight
- Directed cave maze
- Conditional draw

=== Description ===
The input grid depicts a cave maze composed of walls (represented by color 1)
and open paths (color 0). A ball is positioned at a starting cell (color 2) and
initially moves to the right. Each open path cell (color 0) may contain a
'weight' color (3–9), which determines the number of steps the ball moves in its
current direction before checking for walls. The ball moves step-by-step in the
current direction, with the step count dictated by the weight of the cell it
occupies. Upon encountering a wall (color 1), the ball reverses direction along
the axis of collision (e.g., moving right hits a vertical wall → direction
becomes left) and continues moving for the remaining steps. The output grid
replicates the input maze but replaces the ball's trajectory with a new color
(3), tracing the path followed by the ball as it navigates the cave according to
the weight-based movement and bounce rules. The trajectory must account for all
bounces and step counts, avoiding overlap with walls and filling only background
cells (color 0).
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def simulate_trajectory(grid):
    start = None
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            if grid[r][c] == 2:
                start = (r, c)
                break
        if start:
            break
    if start is None:
        start = (0, 0)
    
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    current_dir = 0
    path = set()
    path.add(start)
    r, c = start
    
    remaining = 0
    max_steps = 1000
    steps = 0
    
    while steps < max_steps:
        if remaining == 0:
            if grid[r][c] == 2:
                nr, nc = r + directions[current_dir][0], c + directions[current_dir][1]
                if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]):
                    r, c = nr, nc
                    path.add((r, c))
                    weight = grid[r][c]
                    if 3 <= weight <= 9:
                        remaining = weight
                    else:
                        remaining = 1
                else:
                    current_dir = (current_dir + 2) % 4
                    nr, nc = r + directions[current_dir][0], c + directions[current_dir][1]
                    if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]):
                        r, c = nr, nc
                        path.add((r, c))
                        weight = grid[r][c]
                        if 3 <= weight <= 9:
                            remaining = weight
                        else:
                            remaining = 1
                    else:
                        break
            else:
                weight = grid[r][c]
                if weight < 3 or weight > 9:
                    weight = 1
                remaining = weight
        else:
            nr, nc = r + directions[current_dir][0], c + directions[current_dir][1]
            if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]):
                if grid[nr][nc] == 1:
                    current_dir = (current_dir + 2) % 4
                    nr, nc = r + directions[current_dir][0], c + directions[current_dir][1]
                    if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]):
                        r, c = nr, nc
                        path.add((r, c))
                    else:
                        break
                else:
                    r, c = nr, nc
                    path.add((r, c))
                remaining -= 1
            else:
                current_dir = (current_dir + 2) % 4
                nr, nc = r + directions[current_dir][0], c + directions[current_dir][1]
                if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]):
                    r, c = nr, nc
                    path.add((r, c))
                else:
                    break
        steps += 1
    return path

def generate():
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    grid = common.grid(width, height, 1)
    
    path = []
    start = (0, 0)
    path.append(start)
    r, c = start
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    current_dir = (0, 1)
    
    for _ in range(10):
        for _ in range(3):
            nr, nc = r + current_dir[0], c + current_dir[1]
            if 0 <= nr < height and 0 <= nc < width:
                r, c = nr, nc
                path.append((r, c))
            else:
                current_dir = (-current_dir[0], -current_dir[1])
                nr, nc = r + current_dir[0], c + current_dir[1]
                if 0 <= nr < height and 0 <= nc < width:
                    r, c = nr, nc
                    path.append((r, c))
        current_dir = random.choice(directions)
    
    path = list(dict.fromkeys(path))
    if len(path) < 5:
        return generate()
    
    for r, c in path:
        grid[r][c] = 0
    
    grid[path[0][0]][path[0][1]] = 2
    
    for i in range(1, len(path)):
        r, c = path[i]
        grid[r][c] = 3  # Fixed weight
    
    trajectory = simulate_trajectory(grid)
    output = common.grid(width, height, 1)
    for (r, c) in trajectory:
        output[r][c] = 3
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    start = None
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] == 2:
                start = (r, c)
                break
        if start:
            break
    if start is None:
        start = (0, 0)
    
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    current_dir = 0
    path = set()
    path.add(start)
    r, c = start
    
    remaining = 0
    max_steps = 1000
    steps = 0
    
    while steps < max_steps:
        if remaining == 0:
            if input_grid[r][c] == 2:
                nr, nc = r + directions[current_dir][0], c + directions[current_dir][1]
                if 0 <= nr < len(input_grid) and 0 <= nc < len(input_grid[0]):
                    r, c = nr, nc
                    path.add((r, c))
                    weight = input_grid[r][c]
                    if 3 <= weight <= 9:
                        remaining = weight
                    else:
                        remaining = 1
                else:
                    current_dir = (current_dir + 2) % 4
                    nr, nc = r + directions[current_dir][0], c + directions[current_dir][1]
                    if 0 <= nr < len(input_grid) and 0 <= nc < len(input_grid[0]):
                        r, c = nr, nc
                        path.add((r, c))
                        weight = input_grid[r][c]
                        if 3 <= weight <= 9:
                            remaining = weight
                        else:
                            remaining = 1
                    else:
                        break
            else:
                weight = input_grid[r][c]
                if weight < 3 or weight > 9:
                    weight = 1
                remaining = weight
        else:
            nr, nc = r + directions[current_dir][0], c + directions[current_dir][1]
            if 0 <= nr < len(input_grid) and 0 <= nc < len(input_grid[0]):
                if input_grid[nr][nc] == 1:
                    current_dir = (current_dir + 2) % 4
                    nr, nc = r + directions[current_dir][0], c + directions[current_dir][1]
                    if 0 <= nr < len(input_grid) and 0 <= nc < len(input_grid[0]):
                        r, c = nr, nc
                        path.add((r, c))
                    else:
                        break
                else:
                    r, c = nr, nc
                    path.add((r, c))
                remaining -= 1
            else:
                current_dir = (current_dir + 2) % 4
                nr, nc = r + directions[current_dir][0], c + directions[current_dir][1]
                if 0 <= nr < len(input_grid) and 0 <= nc < len(input_grid[0]):
                    r, c = nr, nc
                    path.add((r, c))
                else:
                    break
        steps += 1
    
    output = common.grid(len(input_grid[0]), len(input_grid), 1)
    for (r, c) in path:
        output[r][c] = 3
    return output
