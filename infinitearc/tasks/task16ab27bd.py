# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 16ab27bd
Difficulty: very hard

=== Tags ===
- Terrain erosion
- Reflect by color
- Multi stage color switch
- Background filling
- Shape guessing

=== Description ===
The input grid features a complex terrain landscape composed of multiple
interconnected regions, each defined by a distinct non-zero color, surrounded by
a uniform background (color 0). The transformation to the output grid involves
the following sequential steps:  1. **Terrain Erosion**: Each terrain region is
simplified by removing its outermost boundary layer. Boundary cells are those
adjacent to background (color 0) or a different terrain color. This shrinks all
regions inward by one cell layer.  2. **Reflection by Color**: The grid is
reflected vertically if a cell of color 5 exists anywhere in the input;
otherwise, it is reflected horizontally. This reflection applies to the entire
grid after erosion.  3. **Multi-stage Color Switching**: Colors transition
through two sequential mappings. In the first stage, each color shifts to a
target color within a hidden cyclic sequence (e.g., 1→2→3→1). In the second
stage, the sequence is applied again, causing colors to advance further along
the cycle (e.g., 2→3→1→2).  4. **Background Filling**: All remaining background
cells (color 0) after erosion and reflection are filled with color 9 (maroon).
The output grid combines these transformations, requiring the solver to identify
erosion patterns, determine the reflection axis from the presence of color 5 or
6, deduce the cyclic color sequence through two stages of transitions, and apply
the background fill. The complexity arises from the interplay of multiple visual
rules applied in sequence, with no numerical dependencies, relying solely on
color relationships and spatial transformations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def apply_erosion(grid):
    height = len(grid)
    width = len(grid[0])
    new_grid = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        if grid[nr][nc] != grid[r][c] or grid[nr][nc] == 0:
                            new_grid[r][c] = 0
                            break
    return new_grid

def apply_reflection(grid, has_color_5):
    if has_color_5:
        return grid[::-1]
    else:
        return [row[::-1] for row in grid]

def apply_color_switch(grid):
    cycle = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    for _ in range(2):
        new_grid = [[0] * len(row) for row in grid]
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                color = grid[r][c]
                idx = cycle.index(color)
                next_idx = (idx + 1) % len(cycle)
                new_grid[r][c] = cycle[next_idx]
        grid = new_grid
    return grid

def fill_background(grid):
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            if grid[r][c] == 0:
                grid[r][c] = 9
    return grid

def generate():
    while True:
        width = random.randint(5, 30)
        height = random.randint(5, 30)
        input_grid = [[0] * width for _ in range(height)]
        
        pixels = common.random_pixels(width, height, prob=0.3)
        # Fixed: Use random integers instead of random_colors to avoid sample error
        colors = [random.randint(1, 9) for _ in range(len(pixels))]
        for (r, c), color in zip(pixels, colors):
            input_grid[r][c] = color
        
        has_color_5 = random.choice([True, False])
        if has_color_5:
            r = random.randint(0, height-1)
            c = random.randint(0, width-1)
            input_grid[r][c] = 5
        
        grid1 = apply_erosion(input_grid)
        has_color_5_input = any(5 in row for row in input_grid)
        grid2 = apply_reflection(grid1, has_color_5_input)
        grid3 = apply_color_switch(grid2)
        output_grid = fill_background(grid3)
        
        if input_grid != output_grid:
            break
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def apply_erosion(grid):
    height = len(grid)
    width = len(grid[0])
    new_grid = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        if grid[nr][nc] != grid[r][c] or grid[nr][nc] == 0:
                            new_grid[r][c] = 0
                            break
    return new_grid

def apply_reflection(grid, has_color_5):
    if has_color_5:
        return grid[::-1]
    else:
        return [row[::-1] for row in grid]

def apply_color_switch(grid):
    cycle = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    for _ in range(2):
        new_grid = [[0] * len(row) for row in grid]
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                color = grid[r][c]
                idx = cycle.index(color)
                next_idx = (idx + 1) % len(cycle)
                new_grid[r][c] = cycle[next_idx]
        grid = new_grid
    return grid

def fill_background(grid):
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            if grid[r][c] == 0:
                grid[r][c] = 9
    return grid

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    has_color_5 = any(5 in row for row in input_list)
    grid1 = apply_erosion(input_list)
    grid2 = apply_reflection(grid1, has_color_5)
    grid3 = apply_color_switch(grid2)
    output_grid = fill_background(grid3)
    return output_grid
