# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: e8bc59b4
Difficulty: hard

=== Tags ===
- Pattern mirroring chain
- Chain reaction
- Connect components by property
- Energy loss per bounce
- Recoloring

=== Description ===
Input grids feature a central geometric pattern composed of a single color,
surrounded by a sequence of mirrored patterns arranged in a connected chain.
Each pattern in the chain is a reflection of the previous one across a line
(alternating horizontal and vertical mirror axes), with each subsequent
pattern's color value decreasing by 1 (e.g., 8 → 7 → 6). The background is a
distinct color (0), and all patterns in the chain are connected through
adjacency, forming a continuous visual path. The chain direction alternates
between horizontal and vertical mirrors with each step (e.g., horizontal mirror
→ vertical mirror → horizontal mirror).  The output grid must extend this chain
by adding one more mirrored pattern. The new pattern is the reflection of the
last pattern in the chain across the next mirror axis in the alternating
sequence (e.g., if the last mirror was vertical, the next is horizontal), with
its color decreased by 1 from the previous pattern. All existing elements
(central pattern and prior chain) remain unchanged, and the new pattern is
placed in the correct direction without overlapping other elements. The
transformation requires recognizing both the mirror direction pattern and the
color decrement rule, with the chain reaction propagating through the connected
components by their color property. Energy loss manifests as the color decrease
per mirror step, creating a visually distinct progression through the chain.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

# Generator for ARC task: pattern mirroring chain

def _reflect(coords, axis_type, axis_pos):
    new = set()
    if axis_type == 'V':
        for r, c in coords:
            new_c = int(2 * axis_pos - c)
            new.add((r, new_c))
    else:
        for r, c in coords:
            new_r = int(2 * axis_pos - r)
            new.add((new_r, c))
    return new


def _bbox(coords):
    rs = [r for r, _ in coords]
    cs = [c for _, c in coords]
    return min(rs), max(rs), min(cs), max(cs)


def generate():
    attempts = 0
    while attempts < 200:
        attempts += 1
        height = random.randint(10, 20)
        width = random.randint(10, 20)
        bg = 0

        # Create a small contiguous sprite
        sprite_h = random.randint(2, 4)
        sprite_w = random.randint(2, 4)
        max_cells = sprite_h * sprite_w
        sprite_size = random.randint(3, max(3, min(6, max_cells)))
        rel_pixels = common.continuous_creature(sprite_size, sprite_w, sprite_h)

        # Place central sprite near the center
        top0 = height // 2 - sprite_h // 2
        left0 = width // 2 - sprite_w // 2
        central = set((top0 + r, left0 + c) for r, c in rel_pixels)

        # choose start color and chain length so new_color will be >=1
        start_color = random.randint(5, 9)
        max_chain = start_color - 2  # ensure final extension color >= 1
        if max_chain < 2:
            continue
        chain_len = random.randint(2, min(4, max_chain))

        axis0 = random.choice(['V', 'H'])

        patterns = [central]
        colors = [start_color]
        occupied = set(central)
        success = True

        # Build chain of chain_len mirrored patterns for the INPUT
        for i in range(chain_len):
            axis_type = axis0 if (i % 2 == 0) else ('H' if axis0 == 'V' else 'V')
            prev = patterns[-1]
            min_r, max_r, min_c, max_c = _bbox(prev)

            candidates = []
            if axis_type == 'V':
                candidates.append(max_c + 0.5)  # reflect to the right
                candidates.append(min_c - 0.5)  # reflect to the left
            else:
                candidates.append(max_r + 0.5)  # reflect downward
                candidates.append(min_r - 0.5)  # reflect upward

            placed = False
            for axis_pos in candidates:
                new_coords = _reflect(prev, axis_type, axis_pos)
                ok_inside = all(0 <= r < height and 0 <= c < width for r, c in new_coords)
                if not ok_inside:
                    continue
                if new_coords & occupied:
                    continue
                patterns.append(new_coords)
                occupied |= new_coords
                colors.append(colors[-1] - 1)
                placed = True
                break

            if not placed:
                success = False
                break

        if not success:
            continue

        # Ensure there is room to append one more mirror for the OUTPUT
        axis_next = axis0 if (chain_len % 2 == 0) else ('H' if axis0 == 'V' else 'V')
        last = patterns[-1]
        min_r, max_r, min_c, max_c = _bbox(last)
        if axis_next == 'V':
            candidates = [max_c + 0.5, min_c - 0.5]
        else:
            candidates = [max_r + 0.5, min_r - 0.5]

        extension_ok = False
        extension_coords = None
        for axis_pos in candidates:
            candidate = _reflect(last, axis_next, axis_pos)
            if not all(0 <= r < height and 0 <= c < width for r, c in candidate):
                continue
            if candidate & occupied:
                continue
            extension_ok = True
            extension_coords = candidate
            break

        if not extension_ok:
            continue

        # Build input and output grids
        input_grid = common.grid(width, height, bg)
        for pattern, color in zip(patterns, colors):
            for r, c in pattern:
                input_grid[r][c] = color

        output_grid = [row[:] for row in input_grid]
        new_color = colors[-1] - 1
        for r, c in extension_coords:
            output_grid[r][c] = new_color

        return {'input': input_grid, 'output': output_grid}

    # Fallback small example (should rarely be used)
    w, h = 11, 11
    in_g = common.grid(w, h, 0)
    center = {(5,5),(5,6),(6,5),(6,6)}
    for r,c in center:
        in_g[r][c] = 5
    in_g[5][7] = in_g[5][8] = in_g[6][7] = in_g[6][8] = 4
    in_g[7][5] = in_g[7][6] = in_g[8][5] = in_g[8][6] = 3
    out_g = [row[:] for row in in_g]
    out_g[7][7] = out_g[7][8] = out_g[8][7] = out_g[8][8] = 2
    return {'input': in_g, 'output': out_g}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------


from collections import deque

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    bg = 0

    # Collect colored pixels by color
    color_pixels = {}
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if v == bg: continue
            color_pixels.setdefault(v, []).append((r, c))

    if not color_pixels:
        return grid

    colors_sorted = sorted(color_pixels.keys(), reverse=True)
    if len(colors_sorted) < 2:
        return grid

    patterns = [set(color_pixels[col]) for col in colors_sorted]
    occupied = set().union(*patterns)

    def bbox(pts):
        rs = [r for r, _ in pts]
        cs = [c for _, c in pts]
        return min(rs), max(rs), min(cs), max(cs)

    p0 = patterns[0]
    p1 = patterns[1]
    min_r0, max_r0, min_c0, max_c0 = bbox(p0)
    min_r1, max_r1, min_c1, max_c1 = bbox(p1)

    if min_r0 == min_r1 and max_r0 == max_r1:
        axis0 = 'V'
    elif min_c0 == min_c1 and max_c0 == max_c1:
        axis0 = 'H'
    else:
        row_overlap = max(0, min(max_r0, max_r1) - max(min_r0, min_r1) + 1)
        col_overlap = max(0, min(max_c0, max_c1) - max(min_c0, min_c1) + 1)
        axis0 = 'V' if row_overlap >= col_overlap else 'H'

    num_patterns = len(patterns)
    axis_next = axis0 if ((num_patterns - 1) % 2 == 0) else ('H' if axis0 == 'V' else 'V')

    last = patterns[-1]
    min_rl, max_rl, min_cl, max_cl = bbox(last)
    candidates = []
    if axis_next == 'V':
        candidates = [max_cl + 0.5, min_cl - 0.5]
    else:
        candidates = [max_rl + 0.5, min_rl - 0.5]

    def reflect(pts, axis_type, axis_pos):
        new = set()
        if axis_type == 'V':
            for r, c in pts:
                new_c = int(2 * axis_pos - c)
                new.add((r, new_c))
        else:
            for r, c in pts:
                new_r = int(2 * axis_pos - r)
                new.add((new_r, c))
        return new

    new_pattern = None
    for axis_pos in candidates:
        cand = reflect(last, axis_next, axis_pos)
        if not all(0 <= r < height and 0 <= c < width for r, c in cand):
            continue
        if cand & occupied:
            continue
        new_pattern = cand
        break

    if not new_pattern:
        return grid

    new_color = colors_sorted[-1] - 1
    for r, c in new_pattern:
        grid[r][c] = new_color

    return grid

