# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: fe53653d
Difficulty: medium–hard

=== Tags ===
- Lava flow
- Meta rule switching
- Path following
- Goal conditioned path
- Mirror pad edges
- Permute columns by length

=== Description ===
Lava Mirror Path Permutation  Input grids feature a 2D array with background
(0), lava source (5) located at a single non-edge cell, goal cell (9) positioned
anywhere, mirror pads (3) exclusively placed along grid edges (top, bottom,
left, right), and obstacles (2) that block lava movement. Lava flows from the
source in a default rightward direction, progressing cell by cell. Upon
encountering a mirror pad (3) on the grid edge during movement, the lava
direction reverses (right → left, left → right, up → down, down → up) without
entering the mirror pad cell. The path terminates immediately upon reaching the
goal cell (9), which remains visible as color 9. After path generation, each
column is evaluated for the count of lava path cells (5) within it. Columns are
then reordered such that columns with the highest count of lava path cells
appear first, followed by descending counts. The output grid displays the
complete lava path (all path cells marked as 5), with columns permuted according
to the path cell counts, while mirror pads (3), obstacles (2), and goal (9)
retain their original positions and colors.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    
    # Create empty grid
    grid_input = grid(width, height, 0)
    
    # Place source (5) at non-edge position
    sx, sy = random.randint(1, height-2), random.randint(1, width-2)
    grid_input[sx][sy] = 5
    
    # Place goal (9) left of source
    gy = random.randint(0, sy-1)
    grid_input[sx][gy] = 9
    
    # Place mirror on right edge
    grid_input[sx][width-1] = 3
    
    # Place obstacles (2) in non-path cells
    for _ in range(width * height // 10):
        r, c = random.randint(0, height-1), random.randint(0, width-1)
        if (r == sx and (c == sy or c == gy or c == width-1)) or grid_input[r][c] != 0:
            continue
        grid_input[r][c] = 2
    
    # Create output grid by marking path and permuting columns
    grid_output = [row[:] for row in grid_input]
    
    # Simulate path to mark cells as 5 (excluding goal)
    path_counts = {}
    r, c = sx, sy
    dr, dc = 0, 1  # Start moving right
    
    while (r, c) != (sx, gy):
        path_counts[(r, c)] = path_counts.get((r, c), 0) + 1
        nr, nc = r + dr, c + dc
        
        # Goal reached
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        if grid_input[nr][nc] == 9:
            break
        
        # Mirror hit
        if grid_input[nr][nc] == 3:
            dr, dc = -dr, -dc
            continue
        
        r, c = nr, nc
    
    # Mark path cells as 5 (counting visits)
    for (r, c), count in path_counts.items():
        if grid_input[r][c] != 9:
            grid_output[r][c] = 5
    
    # Count path visits per column
    col_counts = [0] * width
    for (r, c), count in path_counts.items():
        col_counts[c] += count
    
    # Create new column order by descending count
    sorted_cols = sorted(range(width), key=lambda c: col_counts[c], reverse=True)
    
    # Reorder columns in output
    grid_output = [[grid_output[r][c] for c in sorted_cols] for r in range(height)]
    
    return {
        "input": grid_input,
        "output": grid_output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    # Find source (5) and goal (9)
    source = None
    goal = None
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 5:
                source = (r, c)
            elif grid[r][c] == 9:
                goal = (r, c)
    
    if not source or not goal:
        return grid
    
    # Simulate lava path
    path_counts = {}
    r, c = source
    dr, dc = 0, 1  # Start moving right
    
    while (r, c) != goal:
        path_counts[(r, c)] = path_counts.get((r, c), 0) + 1
        nr, nc = r + dr, c + dc
        
        # Check if next cell is out of bounds or goal
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        if grid[nr][nc] == 9:
            break
        
        # Mirror hit (3) reverses direction
        if grid[nr][nc] == 3:
            dr, dc = -dr, -dc
            continue
        
        r, c = nr, nc
    
    # Mark path cells as 5 (counting visits)
    for (r, c), count in path_counts.items():
        grid[r][c] = 5
    
    # Count path visits per column
    col_counts = [0] * width
    for (r, c), count in path_counts.items():
        col_counts[c] += count
    
    # Reorder columns by count descending
    sorted_cols = sorted(range(width), key=lambda c: col_counts[c], reverse=True)
    
    # Create new output grid with permuted columns
    output = [[grid[r][c] for c in sorted_cols] for r in range(height)]
    return output
