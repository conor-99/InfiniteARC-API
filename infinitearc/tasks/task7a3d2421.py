# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 7a3d2421
Difficulty: very hard

=== Tags ===
- If then color switch
- Pattern rotation
- Color modulated motion
- Count hor lines

=== Description ===
Input grids feature a central, irregularly shaped motif composed of multiple
distinct colors (non-background) surrounded by a structured arrangement of
horizontal lines. Each horizontal line is a complete row of identical non-
background color, spaced with at least one background cell (color 0) between
lines. The topmost horizontal line's color determines the rotation direction of
the motif: even-numbered colors (e.g., red, yellow) trigger clockwise rotation,
while odd-numbered colors (e.g., blue, green) trigger counterclockwise rotation.
The number of horizontal lines (N) dictates the total rotation magnitude: each
line contributes a 90° rotation (e.g., N=3 results in 270° rotation).
Simultaneously, the motif undergoes a cyclic color shift based on N's parity: if
N is even, all motif colors advance to the next color in a fixed 9-color cycle;
if N is odd, all colors retreat to the previous color in the cycle. Finally, the
transformed motif shifts vertically by N rows, wrapping around the grid edges
(downward for even N, upward for odd N), while all horizontal lines and
background remain unchanged. The output grid preserves the original horizontal
line positions and background structure, with all transformations applied
exclusively to the motif.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, continuous_creature


def generate():
    """
    Generate an ARC-style input/output pair according to the specification:
    - Square grid (size between 9 and 15)
    - N horizontal full rows of non-zero color spaced by at least one background row (rows 0,2,4,...)
    - Central contiguous motif (multi-colored) not overlapping the line rows
    - Motif is rotated by N*90 degrees (direction depends on top line color parity)
    - Motif colors are shifted by +1 (if N even) or -1 (if N odd) in a 1..9 cycle
    - Motif is shifted vertically by N rows (down for even N, up for odd N) with wrap
    - Horizontal lines and their colors remain unchanged; motif pixels never overwrite line pixels

    Returns:
      {"input": input_grid, "output": output_grid}
    """
    tries = 0
    while True:
        tries += 1
        # Grid size (square for simpler rotation handling)
        H = random.randint(9, 15)
        W = H

        # Maximum number of lines such that rows 0,2,4,... fit
        maxN = min(5, (H + 1) // 2)
        N = random.randint(1, maxN)
        spacing = 1
        line_rows = [i * (spacing + 1) for i in range(N)]

        # Create blank input grid
        input_grid = grid(W, H, 0)

        # Assign colors to horizontal lines. Topmost line color controls rotation direction.
        top_line_color = random.randint(1, 9)
        line_colors = [random.randint(1, 9) for _ in range(N)]
        line_colors[0] = top_line_color
        for r, color in zip(line_rows, line_colors):
            for c in range(W):
                input_grid[r][c] = color

        # --- Create a contiguous, irregular motif that does NOT overlap line rows ---
        # Choose motif bounding-box vertical size. If chosen size cannot fit without hitting a line row,
        # shrink it until it can be placed without overlap.
        max_motif_h = max(3, min(7, H - len(line_rows) - 1))
        motif_h = random.randint(3, max_motif_h)
        motif_w = random.randint(3, min(7, W - 1))

        # Reduce motif_h until there is at least one top position that doesn't overlap any line row
        allowed_tops = []
        while motif_h >= 3:
            allowed_tops = []
            for top in range(0, H - motif_h + 1):
                overlap = False
                for lr in line_rows:
                    if top <= lr <= top + motif_h - 1:
                        overlap = True
                        break
                if not overlap:
                    allowed_tops.append(top)
            if allowed_tops:
                break
            motif_h -= 1
        if not allowed_tops:
            # As a safety (extremely unlikely), skip this grid and retry
            continue

        motif_top = random.choice(allowed_tops)
        motif_left = random.randint(0, W - motif_w)

        # Size of the creature (must fit inside bounding box)
        max_cells = motif_h * motif_w
        min_cells = max(4, max_cells // 4)
        size = random.randint(min_cells, max_cells)
        local_pixels = continuous_creature(size, motif_w, motif_h)
        # Map to absolute coordinates
        motif_pixels = [(r + motif_top, c + motif_left) for r, c in local_pixels]
        motif_pixels = sorted(set(motif_pixels))

        # Choose at least two distinct colors for the motif
        k_colors = random.randint(2, min(4, 9))
        palette = random.sample(list(range(1, 10)), k_colors)
        random.shuffle(palette)
        # Assign colors in a deterministic but shuffled way
        motif_pixels_sorted = sorted(motif_pixels)
        motif_colors = [palette[i % len(palette)] for i in range(len(motif_pixels_sorted))]

        # Paint motif into input grid
        for (r, c), col in zip(motif_pixels_sorted, motif_colors):
            input_grid[r][c] = col

        # --- Build output grid by applying the described transforms to motif only ---
        output_grid = [row[:] for row in input_grid]
        # Clear original motif pixels (they moved)
        for (r, c) in motif_pixels_sorted:
            # Never clear a line row (motif shouldn't overlap lines initially)
            if r not in line_rows:
                output_grid[r][c] = 0

        # Rotation parameters
        rot_steps = N % 4
        clockwise = (top_line_color % 2 == 0)

        # Bounding box and center of the motif (float center)
        min_r = min(r for r, _ in motif_pixels_sorted)
        max_r = max(r for r, _ in motif_pixels_sorted)
        min_c = min(c for _, c in motif_pixels_sorted)
        max_c = max(c for _, c in motif_pixels_sorted)
        center_r = (min_r + max_r) / 2.0
        center_c = (min_c + max_c) / 2.0

        def rotate_once(rf, cf, cw):
            dr = rf - center_r
            dc = cf - center_c
            if cw:
                return (center_r + dc, center_c - dr)
            else:
                return (center_r - dc, center_c + dr)

        def rotate_point(r0, c0, steps, cw):
            rf, cf = float(r0), float(c0)
            for _ in range(steps):
                rf, cf = rotate_once(rf, cf, cw)
            return int(round(rf)), int(round(cf))

        # Color shift helper
        def shift_color(col, even_N):
            if even_N:
                return (col % 9) + 1
            else:
                return ((col - 2) % 9) + 1

        even_N = (N % 2 == 0)
        shift_v = N if even_N else -N

        # Apply transform: rotate each motif pixel (keeping its color attached), shift color, then vertical shift
        for (r0, c0), orig_col in zip(motif_pixels_sorted, motif_colors):
            r_rot, c_rot = rotate_point(r0, c0, rot_steps, clockwise)
            r_target = (r_rot + shift_v) % H
            c_target = c_rot
            # Skip painting if this would overwrite a horizontal line
            if r_target in line_rows:
                continue
            # Skip if out of bounds horizontally
            if c_target < 0 or c_target >= W:
                continue
            new_col = shift_color(orig_col, even_N)
            # Only write into background (do not overwrite lines or other non-background)
            if output_grid[r_target][c_target] == 0:
                output_grid[r_target][c_target] = new_col

        # Safety: ensure the output differs from input (motif moved/changed)
        if output_grid != input_grid:
            return {"input": input_grid, "output": output_grid}

        # If unlucky (rare), regenerate a few times
        if tries > 200:
            # As a last resort, force a simple vertical shift so output differs
            for (r, c) in motif_pixels_sorted:
                output_grid[r][c] = ((input_grid[r][c]) % 9) + 1
            return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid_in = [list(row) for row in input_grid]
    H = len(grid_in)
    W = len(grid_in[0]) if H > 0 else 0

    # Identify horizontal full rows (non-zero and all equal across the row)
    line_rows = []
    for r in range(H):
        if grid_in[r][0] != 0 and all(grid_in[r][c] == grid_in[r][0] for c in range(W)):
            line_rows.append(r)
    if not line_rows:
        # Nothing to do
        return grid_in

    line_rows = sorted(line_rows)
    top_line_color = grid_in[line_rows[0]][0]
    N = len(line_rows)

    # Collect motif pixels (non-background and not part of the horizontal lines)
    motif = []  # list of (r,c,col)
    for r in range(H):
        if r in line_rows:
            continue
        for c in range(W):
            if grid_in[r][c] != 0:
                motif.append((r, c, grid_in[r][c]))

    if not motif:
        # No motif found -> return copy
        return [row[:] for row in grid_in]

    # Sort motif deterministically (to match generator order)
    motif_sorted = sorted(motif, key=lambda x: (x[0], x[1]))

    # Bounding box and center
    min_r = min(r for r, _, _ in motif_sorted)
    max_r = max(r for r, _, _ in motif_sorted)
    min_c = min(c for _, c, _ in motif_sorted)
    max_c = max(c for _, c, _ in motif_sorted)
    center_r = (min_r + max_r) / 2.0
    center_c = (min_c + max_c) / 2.0

    # Rotation helpers (use same math as generator)
    def rotate_once(rf, cf, cw):
        dr = rf - center_r
        dc = cf - center_c
        if cw:
            return (center_r + dc, center_c - dr)
        else:
            return (center_r - dc, center_c + dr)

    def rotate_point(r0, c0, steps, cw):
        rf, cf = float(r0), float(c0)
        for _ in range(steps):
            rf, cf = rotate_once(rf, cf, cw)
        return int(round(rf)), int(round(cf))

    rot_steps = N % 4
    clockwise = (top_line_color % 2 == 0)

    # Color shift helper
    def shift_color(col, even_N):
        if even_N:
            return (col % 9) + 1
        else:
            return ((col - 2) % 9) + 1

    even_N = (N % 2 == 0)
    shift_v = N if even_N else -N

    # Prepare output: start from input but clear motif original cells
    output = [row[:] for row in grid_in]
    for (r, c, _) in motif_sorted:
        if r not in line_rows:
            output[r][c] = 0

    # Apply transforms to each motif pixel in the same order used by the generator
    for (r0, c0, orig_col) in motif_sorted:
        r_rot, c_rot = rotate_point(r0, c0, rot_steps, clockwise)
        r_target = (r_rot + shift_v) % H
        c_target = c_rot
        # Do not overwrite horizontal lines or out-of-bounds columns
        if r_target in line_rows:
            continue
        if c_target < 0 or c_target >= W:
            continue
        new_col = shift_color(orig_col, even_N)
        if output[r_target][c_target] == 0:
            output[r_target][c_target] = new_col

    return output

