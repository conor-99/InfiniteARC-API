# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: ddb04a53
Difficulty: very hard

=== Tags ===
- Stepwise color transition
- Folded grid reasoning
- Path merging
- Associate colors to patterns

=== Description ===
Folded Path Merges  Input grids feature a central fold line (vertical or
horizontal) dividing the grid into two mirrored halves. Each half contains one
or more color-coded paths (contiguous sequences of cells of a single color) that
extend from one edge of the grid to the opposite edge, crossing the fold line.
The paths on both sides are mirror images across the fold line. Paths may be
diagonal, L-shaped, or straight, but must maintain consistent color throughout
their entire length.  The transformation involves folding the grid along the
fold line, merging mirror-image path segments. For each pair of cells that are
mirror images across the fold line (and part of paths), their colors transition
stepwise to the next color in a predefined sequence (0→1→2→...→9) after the
higher of the two original colors. For example, merging color 3 and 5 produces
color 6. The sequence wraps around (9→0) for the final transition.  Non-path
cells and background remain unchanged. The output grid displays the folded grid
with merged paths, where the fold line appears as a continuous merged path with
stepwise color transitions. Multiple paths crossing the fold line must be
processed independently, with each merge point applying the transition rule to
its specific color pair. Path segments not crossing the fold line remain
unchanged, while background elements stay consistent. The transformation
requires identifying the fold line, recognizing mirror-image path pairs,
applying the stepwise transition sequence correctly, and handling overlapping
paths without conflating color transitions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def _rand_even(low, high):
    # return a random even integer between low and high inclusive
    if low > high:
        low, high = high, low
    # adjust bounds
    if low % 2 == 1:
        low += 1
    if high % 2 == 1:
        high -= 1
    if low > high:
        # fallback to nearest even
        return max(2, low)
    step = 2
    count = (high - low) // step + 1
    return low + 2 * random.randrange(count)


def _rand_odd(low, high):
    if low > high:
        low, high = high, low
    if low % 2 == 0:
        low += 1
    if high % 2 == 0:
        high -= 1
    if low > high:
        return 1
    step = 2
    count = (high - low) // step + 1
    return low + 2 * random.randrange(count)


def _try_make_path(width, height, mid_left, used):
    # attempt to build a 8-connected monotonic-from-left path from col 0 to col mid_left
    # avoiding used cells. Returns list of (r,c) or None.
    for attempt in range(120):
        start_r = random.randrange(height)
        if (start_r, 0) in used:
            continue
        r = start_r
        positions = []
        ok = True
        for c in range(0, mid_left + 1):
            if (r, c) in used:
                ok = False
                break
            positions.append((r, c))
            if c == mid_left:
                break
            # choose next row allowing diagonal
            deltas = [0, 1, -1]
            random.shuffle(deltas)
            found = False
            for d in deltas:
                nr = r + d
                if nr < 0 or nr >= height:
                    continue
                if (nr, c + 1) in used:
                    continue
                # small bias towards staying in bounds
                found = True
                r = nr
                break
            if not found:
                ok = False
                break
        if ok:
            return positions
    return None


def generate():
    # Choose fold orientation and dimensions so that only the fold axis is even
    # to make detection unambiguous in the solver.
    fold_type = random.choice(['vertical', 'horizontal'])
    if fold_type == 'vertical':
        width = _rand_even(4, 30)
        height = _rand_odd(3, 29)
        mid_left = width // 2 - 1
        mid_right = width // 2
    else:
        height = _rand_even(4, 30)
        width = _rand_odd(3, 29)
        mid_top = height // 2 - 1
        mid_bottom = height // 2

    input_grid = common.grid(width, height, 0)
    used = set()

    # number of paths limited so they can be placed without excessive overlap
    max_paths = 1 + min(4, (height if fold_type == 'vertical' else width) // 2)
    num_paths = random.randint(1, max_paths)
    # pick distinct nonzero colors for different paths to make output varied
    colors = common.random_colors(num_paths, exclude=[0])

    if fold_type == 'vertical':
        for color in colors:
            path = _try_make_path(width, height, mid_left, used)
            if path is None:
                # give up on this path if can't place it
                continue
            # mirrored positions
            mirrored = [(r, width - 1 - c) for (r, c) in path]
            # if any mirrored collides, skip placement
            conflict = False
            for p in mirrored:
                if p in used:
                    conflict = True
                    break
            if conflict:
                continue
            # place both halves
            for (r, c) in path:
                input_grid[r][c] = color
                used.add((r, c))
            for (r, c) in mirrored:
                input_grid[r][c] = color
                used.add((r, c))
    else:
        # horizontal fold: build paths top->bottom in the top half and mirror them
        for color in colors:
            # attempt to build a path from row 0 to mid_top, moving downwards with possible left/right steps
            for attempt in range(120):
                start_c = random.randrange(width)
                if (0, start_c) in used:
                    continue
                c = start_c
                positions = []
                ok = True
                for r in range(0, mid_top + 1):
                    if (r, c) in used:
                        ok = False
                        break
                    positions.append((r, c))
                    if r == mid_top:
                        break
                    # choose next column allowing diagonal movement
                    deltas = [0, 1, -1]
                    random.shuffle(deltas)
                    found = False
                    for d in deltas:
                        nc = c + d
                        if nc < 0 or nc >= width:
                            continue
                        if (r + 1, nc) in used:
                            continue
                        found = True
                        c = nc
                        break
                    if not found:
                        ok = False
                        break
                if not ok:
                    continue
                mirrored = [(height - 1 - r, c) for (r, c) in positions]
                conflict = any(p in used for p in mirrored)
                if conflict:
                    continue
                for (r, c) in positions:
                    input_grid[r][c] = color
                    used.add((r, c))
                for (r, c) in mirrored:
                    input_grid[r][c] = color
                    used.add((r, c))
                break

    # build output by folding: for each mirrored pair where both are path cells, set both to next color
    output_grid = common.grid(width, height, 0)
    if fold_type == 'vertical':
        for r in range(height):
            for c in range(0, mid_left + 1):
                mirror_c = width - 1 - c
                a = input_grid[r][c]
                b = input_grid[r][mirror_c]
                if a != 0 and b != 0:
                    new_color = (max(a, b) + 1) % 10
                    output_grid[r][c] = new_color
                    output_grid[r][mirror_c] = new_color
                else:
                    output_grid[r][c] = a
                    output_grid[r][mirror_c] = b
    else:
        for c in range(width):
            for r in range(0, mid_top + 1):
                mirror_r = height - 1 - r
                a = input_grid[r][c]
                b = input_grid[mirror_r][c]
                if a != 0 and b != 0:
                    new_color = (max(a, b) + 1) % 10
                    output_grid[r][c] = new_color
                    output_grid[mirror_r][c] = new_color
                else:
                    output_grid[r][c] = a
                    output_grid[mirror_r][c] = b

    return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # input_grid: Tuple[Tuple[int]]
    inp = [list(row) for row in input_grid]
    height = len(inp)
    width = len(inp[0])

    # Decide fold orientation. Generator ensures the fold axis dimension is even.
    if width % 2 == 0:
        # vertical fold between columns (mid_left, mid_right)
        mid_left = width // 2 - 1
        # mid_right = width // 2
        out = [row[:] for row in inp]
        for r in range(height):
            for c in range(0, mid_left + 1):
                mirror_c = width - 1 - c
                a = inp[r][c]
                b = inp[r][mirror_c]
                if a != 0 and b != 0:
                    new_color = (max(a, b) + 1) % 10
                    out[r][c] = new_color
                    out[r][mirror_c] = new_color
                else:
                    out[r][c] = a
                    out[r][mirror_c] = b
    else:
        # horizontal fold between rows (mid_top, mid_bottom)
        mid_top = height // 2 - 1
        out = [row[:] for row in inp]
        for c in range(width):
            for r in range(0, mid_top + 1):
                mirror_r = height - 1 - r
                a = inp[r][c]
                b = inp[mirror_r][c]
                if a != 0 and b != 0:
                    new_color = (max(a, b) + 1) % 10
                    out[r][c] = new_color
                    out[mirror_r][c] = new_color
                else:
                    out[r][c] = a
                    out[mirror_r][c] = b

    return tuple(tuple(row) for row in out)

