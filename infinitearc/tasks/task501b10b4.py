# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 501b10b4
Difficulty: very hard

=== Tags ===
- Path scarring
- Maze
- Remove singletons

=== Description ===
Input grids depict complex maze structures where pathways (color 2) are embedded
within walls (color 1), with background (color 0) filling all other areas.
Scattered throughout the grid are isolated scar cells (color 3) that exist as
singletonsâ€”each has no orthogonally adjacent scar cells of the same color.
Additionally, a continuous path of path markers (color 4) traverses the maze,
connecting the top-left to bottom-right corners via pathway cells (color 2),
forming a valid route through the maze structure.  The output grid requires two
sequential transformations: first, all singleton scar cells (color 3) must be
removed (set to background color 0), while preserving connected scar clusters
(if any exist). Second, a path scarring effect is applied to the path marker
route (color 4), where for each cell along the path, a 1-cell-wide scar (color
5) extends 2 cells in all four orthogonal directions (up, down, left, right),
but only through background cells (color 0). These scar extensions must not
overlap with walls (color 1), pathways (color 2), or existing scars, and must
terminate at grid boundaries or non-background cells. The resulting output
retains all original maze structure and path markers, now augmented with
directional scar trails along the path, while isolated scar cells are completely
eliminated.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    g = grid(width, height, 0)
    
    for c in range(width):
        g[0][c] = 2
    for r in range(1, height):
        g[r][width-1] = 2
    
    for c in range(width):
        g[0][c] = 4
    for r in range(1, height):
        g[r][width-1] = 4
    
    background_cells = []
    for r in range(height):
        for c in range(width):
            if g[r][c] == 0:
                background_cells.append((r, c))
    
    random.shuffle(background_cells)
    scar_cells = []
    for r, c in background_cells:
        adjacent = False
        for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and (nr, nc) in scar_cells:
                adjacent = True
                break
        if not adjacent:
            scar_cells.append((r, c))
            g[r][c] = 3
    
    output = [row[:] for row in g]
    for r in range(height):
        for c in range(width):
            if output[r][c] == 3:
                output[r][c] = 0
    
    for r in range(height):
        for c in range(width):
            if g[r][c] == 4:
                for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
                    for step in range(1, 3):
                        nr = r + dr * step
                        nc = c + dc * step
                        if 0 <= nr < height and 0 <= nc < width and output[nr][nc] == 0:
                            output[nr][nc] = 5
                        else:
                            break
    
    return {"input": g, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])
    
    for r in range(h):
        for c in range(w):
            if grid[r][c] == 3:
                has_adjacent = False
                for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < h and 0 <= nc < w and grid[nr][nc] == 3:
                        has_adjacent = True
                        break
                if not has_adjacent:
                    grid[r][c] = 0
    
    for r in range(h):
        for c in range(w):
            if grid[r][c] == 4:
                for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
                    for step in range(1, 3):
                        nr = r + dr * step
                        nc = c + dc * step
                        if 0 <= nr < h and 0 <= nc < w and grid[nr][nc] == 0:
                            grid[nr][nc] = 5
                        else:
                            break
    
    return grid
