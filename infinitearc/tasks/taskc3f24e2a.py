# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: c3f24e2a
Difficulty: medium

=== Tags ===
- Pattern deconstruction

=== Description ===
The input grid is a larger grid formed by repeating a smaller base pattern both
horizontally and vertically. The output grid is the smallest base pattern that
can tile the input grid. For example, if the input is a 6x6 grid constructed by
repeating a 3x3 pattern three times in each direction, the output is the 3x3
pattern. The transformation requires identifying the periodic structure within
the input grid, determining the smallest repeating unit, and extracting it to
form the output. This task involves recognizing tiling patterns and abstractly
deconstructing the grid into its fundamental repeating component, which is a
medium-level reasoning challenge requiring analysis of grid structure rather
than simple transformation rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import math
    import random
    while True:
        w = random.randint(1, 10)
        h = random.randint(1, 10)
        if math.gcd(w, h) == 1:
            break
    base = [[random.randint(0, 9) for _ in range(w)] for _ in range(h)]
    k = random.choice([2, 3])
    m = random.choice([2, 3])
    input_width = k * w
    input_height = m * h
    input_grid = [[base[i % h][j % w] for j in range(input_width)] for i in range(input_height)]
    return {"input": input_grid, "output": base}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    H = len(input_grid)
    W = len(input_grid[0])
    divisors_w = [w for w in range(1, W+1) if W % w == 0]
    divisors_h = [h for h in range(1, H+1) if H % h == 0]
    for w in sorted(divisors_w):
        for h in sorted(divisors_h):
            valid = True
            for i in range(H):
                for j in range(W):
                    if input_grid[i][j] != input_grid[i % h][j % w]:
                        valid = False
                        break
                if not valid:
                    break
            if valid:
                return [input_grid[i][:w] for i in range(h)]
    return input_grid
