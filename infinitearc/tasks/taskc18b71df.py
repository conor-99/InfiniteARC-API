# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: c18b71df
Difficulty: hard

=== Tags ===
- Progressive rule shift
- Ripple spread
- Embedded rule repetition

=== Description ===
**Task Description: Progressive Ripple Cascade**  Input grids feature a central
source cell (distinct color) on a uniform background. Scattered throughout the
grid are colored rule markers arranged in a continuous spiral path originating
from the source. Each marker color corresponds to one of four cardinal
directions (e.g., red = right, blue = up, green = left, yellow = down), with the
sequence of marker colors repeating cyclically (e.g., red → blue → green →
yellow → red → ...). The markers form a spiral that gradually expands outward
from the source, with no two markers sharing the same cell.  The transformation
simulates a ripple propagation starting at the source. The initial ripple (first
layer) spreads uniformly one cell in all four cardinal directions. Upon
encountering a rule marker, the ripple's propagation direction shifts to match
the marker's color. Each subsequent ripple layer propagates strictly in the
current direction until it hits the next marker, triggering another direction
shift. The ripple cycles through the embedded direction sequence as it follows
the spiral path, with propagation continuing until the grid boundary is reached.
The output grid displays the complete ripple path, where each layer is colored
according to its propagation direction (e.g., rightward layers use red, upward
layers use blue). Rule markers remain fully visible within the output, as they
are integral to the grid's structure and not overwritten. The ripple path forms
a non-intersecting spiral that dynamically shifts direction at each marker, with
the final path reflecting the embedded cyclic rule sequence. The challenge
requires identifying the spiral marker pattern, decoding the direction cycle,
and applying the progressive rule shifts across multiple propagation layers to
reconstruct the full ripple trajectory.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Size large enough to allow an expanding spiral
    size = random.randint(15, 30)
    grid = [[0] * size for _ in range(size)]
    center = (size // 2, size // 2)
    grid[center[0]][center[1]] = 1  # source

    # Directions: right, up, left, down
    directions = [(0, 1), (-1, 0), (0, -1), (1, 0)]
    # Map direction index -> marker color (2..5)
    color_map = {0: 2, 1: 3, 2: 4, 3: 5}

    # Start direction and initial leg length
    start_dir = random.randint(0, 3)
    step_len = random.randint(2, 4)  # ensure gaps between markers

    nodes = [center]
    nodes_dir_indices = []  # which direction was used to reach each node (for nodes[1:])
    current = center
    done = False

    # Build the spiral as a sequence of leg endpoints (nodes). Each node is at the end of a straight leg.
    # This ensures markers are spaced out so drawing the connecting lines will produce visible segments.
    while not done:
        for _ in range(2):  # repeat each leg length twice (standard spiral pattern)
            dindex = start_dir
            dr, dc = directions[dindex]
            steps_made = 0
            for _ in range(step_len):
                nr = current[0] + dr
                nc = current[1] + dc
                if not (0 <= nr < size and 0 <= nc < size):
                    done = True
                    break
                current = (nr, nc)
                steps_made += 1
            if steps_made == 0:
                done = True
                break
            nodes.append(current)
            nodes_dir_indices.append(dindex)
            start_dir = (start_dir + 1) % 4
            if done:
                break
        if not done:
            # grow the leg length a bit for the next pair of legs
            step_len += random.randint(1, 2)

    # Safety: ensure there's at least one marker
    if len(nodes) <= 1:
        # place a single marker two cells to the right (or the first direction that fits)
        for dindex, (dr, dc) in enumerate(directions):
            nr = center[0] + dr * 2
            nc = center[1] + dc * 2
            if 0 <= nr < size and 0 <= nc < size:
                nodes.append((nr, nc))
                nodes_dir_indices.append(dindex)
                break

    # Place markers on the nodes (excluding the source at nodes[0])
    for idx, node in enumerate(nodes[1:]):
        color = color_map[nodes_dir_indices[idx]]
        r, c = node
        grid[r][c] = color

    # Create output by drawing straight segments between consecutive nodes.
    # Each segment is colored with the marker color at its destination node.
    output = [row[:] for row in grid]
    for i in range(1, len(nodes)):
        r1, c1 = nodes[i - 1]
        r2, c2 = nodes[i]
        color = grid[r2][c2]
        if r1 == r2:
            step = 1 if c2 > c1 else -1
            for cc in range(c1 + step, c2 + step, step):
                # don't overwrite the source cell
                if output[r1][cc] == 1:
                    continue
                output[r1][cc] = color
        elif c1 == c2:
            step = 1 if r2 > r1 else -1
            for rr in range(r1 + step, r2 + step, step):
                if output[rr][c1] == 1:
                    continue
                output[rr][c1] = color
        else:
            # Spiral nodes should always be aligned; if not, skip
            continue

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0]) if h else 0

    # Find source (color 1)
    source = None
    for r in range(h):
        for c in range(w):
            if grid[r][c] == 1:
                source = (r, c)
                break
        if source:
            break
    if source is None:
        source = (h // 2, w // 2)

    # Collect markers positions and colors
    markers = []
    for r in range(h):
        for c in range(w):
            if 2 <= grid[r][c] <= 5:
                markers.append(((r, c), grid[r][c]))

    if not markers:
        return grid

    # All known points (used for blocked checks)
    all_points = [source] + [pos for pos, col in markers]

    # Helper: check if two points are unobstructed (no other point strictly between them on same row/col)
    def unobstructed(a, b):
        r1, c1 = a
        r2, c2 = b
        if r1 == r2:
            for p in all_points:
                if p == a or p == b:
                    continue
                if p[0] == r1 and min(c1, c2) < p[1] < max(c1, c2):
                    return False
            return True
        if c1 == c2:
            for p in all_points:
                if p == a or p == b:
                    continue
                if p[1] == c1 and min(r1, r2) < p[0] < max(r1, r2):
                    return False
            return True
        return False

    # Build path starting from source using the directional hint embedded in each marker's color.
    remaining = {pos: col for pos, col in markers}
    path = [source]
    cur = source

    # Direction index mapping: 0=right,1=up,2=left,3=down (matches generator color_map: color = dir_index + 2)
    while remaining:
        candidates = []
        cr, cc = cur
        for pos, col in list(remaining.items()):
            r, c = pos
            dir_index = col - 2
            # Determine movement direction from cur to this marker
            if r == cr and c > cc:
                move_idx = 0  # right
            elif c == cc and r < cr:
                move_idx = 1  # up
            elif r == cr and c < cc:
                move_idx = 2  # left
            elif c == cc and r > cr:
                move_idx = 3  # down
            else:
                continue  # not aligned

            # Candidate only if the movement direction from cur to marker matches the marker's encoded direction
            if move_idx == dir_index and unobstructed(cur, pos):
                dist = abs(r - cr) + abs(c - cc)
                candidates.append((dist, pos))

        if not candidates:
            # Fallback: allow any unobstructed aligned marker (ignore the color hint)
            for pos, col in list(remaining.items()):
                if unobstructed(cur, pos):
                    dist = abs(pos[0] - cr) + abs(pos[1] - cc)
                    candidates.append((dist, pos))

        if not candidates:
            # Shouldn't happen, but if it does, stop building path
            break

        # pick the nearest candidate
        candidates.sort()
        _, chosen = candidates[0]
        path.append(chosen)
        del remaining[chosen]
        cur = chosen

    # If there are any markers left (due to unusual layouts), append them by nearest distance order
    if remaining:
        rest = sorted(remaining.keys(), key=lambda p: (abs(p[0] - source[0]) + abs(p[1] - source[1])))
        path.extend(rest)

    # Draw output by coloring straight segments between consecutive path points with the destination marker color
    output = [row[:] for row in grid]
    for i in range(1, len(path)):
        r1, c1 = path[i - 1]
        r2, c2 = path[i]
        color = grid[r2][c2] if 0 <= r2 < h and 0 <= c2 < w else 0
        if r1 == r2:
            step = 1 if c2 > c1 else -1
            for cc in range(c1 + step, c2 + step, step):
                if output[r1][cc] == 1:
                    continue
                output[r1][cc] = color
        elif c1 == c2:
            step = 1 if r2 > r1 else -1
            for rr in range(r1 + step, r2 + step, step):
                if output[rr][c1] == 1:
                    continue
                output[rr][c1] = color

    return output

