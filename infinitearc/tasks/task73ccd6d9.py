# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 73ccd6d9
Difficulty: mediumâ€“hard

=== Tags ===
- Multi layer projection
- Bouncing
- Color majority row

=== Description ===
The input grid consists of a 2D array of colors (0-9), where each row contains a
distinct arrangement of colors. For each row, the majority color (the color
appearing most frequently in that row; in case of a tie, the highest numerical
value is chosen) is identified. The output grid is constructed by generating a
continuous path that traverses the entire grid in a "bouncing" pattern: starting
at the top-left corner (0,0), the path moves right across the first row until
reaching the right edge, then moves down to the next row and left across it
until the left edge, then down and right, and so on, alternating direction at
each row boundary. Each cell along this path is colored with the majority color
of the row it traverses, while all non-path cells remain background color (0).
The output visually represents the majority color progression across the grid
through this bouncing path, with the direction change at row edges creating a
wave-like pattern that alternates between left-to-right and right-to-left
movement.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    width = random.randint(2, 30)
    height = random.randint(1, 30)
    input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
    while all(len(set(row)) == 1 for row in input_grid):
        input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
    output_grid = []
    for row in input_grid:
        counts = {}
        for color in row:
            counts[color] = counts.get(color, 0) + 1
        max_count = max(counts.values())
        candidates = [c for c, cnt in counts.items() if cnt == max_count]
        majority = max(candidates)
        output_grid.append([majority] * width)
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = []
    for row in input_grid:
        counts = {}
        for color in row:
            counts[color] = counts.get(color, 0) + 1
        max_count = max(counts.values())
        candidates = [c for c, cnt in counts.items() if cnt == max_count]
        majority = max(candidates)
        output_grid.append([majority] * width)
    return output_grid
