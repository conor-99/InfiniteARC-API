# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 5a288b28
Difficulty: very hard

=== Tags ===
- Color particle fall
- Compositional reflection
- Detect symmetry
- Recursive path tracing
- Detect repetition
- Associate images to colors

=== Description ===
# Color Particle Fall  Input grids are medium to large (15×15 to 30×30) with a
uniform background color (0). The grids contain multiple colored particles (1-9)
positioned at the top edge, each representing a falling "particle" with its own
color. Scattered throughout the grid are mirror elements—specific color patterns
that form symmetrical structures (vertical, horizontal, or diagonal lines) but
are not explicitly labeled. These mirror patterns must be identified through
symmetry detection, as they determine reflection behavior. Crucially, each
mirror color (e.g., color 3) corresponds to a unique reflection type (e.g.,
vertical mirror), but this association must be deduced by the solver through
pattern recognition of the mirror structures.  The transformation process
involves:   1. **Symmetry detection**: Identify the primary symmetry axis
(vertical, horizontal, or diagonal) of the entire grid or dominant mirror
structures.   2. **Mirror-color association**: Analyze the shape of mirror
patterns to map each color to its reflection behavior (e.g., a vertical line of
color 5 always reflects particles vertically).   3. **Recursive path tracing**:
For each particle, simulate its fall downward until it hits a mirror. Upon
collision, reflect the particle’s direction using the mirror’s symmetry and
color-mapped behavior. Continue tracing the path recursively with each new
bounce, updating direction based on the mirror’s reflection rule.   4.
**Repetition detection**: Identify repeating mirror sequences (e.g., alternating
vertical/horizontal mirrors) to predict path behavior without full simulation.
5. **Path drawing**: In the output grid, render the complete path of each
particle using its original color, drawn only on background cells (never over
mirrors or other particles), with paths ending when particles exit the grid.
The output grid retains all input elements (mirrors, background) but replaces
the initial particle positions with their traced paths. Path segments must
strictly follow the reflection rules derived from symmetry and color
associations, with no overlaps or intersections. The solution requires detecting
grid symmetry, deducing color-mirror mappings, and recursively tracing paths
while recognizing repetitive patterns—all while avoiding reliance on numerical
values or pixel-level features.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import randint, random_colors

def generate():
    # Grid size
    width = randint(15, 30)
    height = randint(15, 30)
    grid = [[0 for _ in range(width)] for _ in range(height)]

    # Place 2-4 particles on the top row, in distinct columns
    num_particles = randint(2, 4)
    particle_colors = random_colors(num_particles, exclude=[0])
    # choose columns separated by at least 2 to reduce path intersections
    possible_cols = list(range(1, width - 1))
    particle_cols = random.sample(possible_cols, num_particles)
    particle_cols.sort()
    for col, color in zip(particle_cols, particle_colors):
        grid[0][col] = color

    # Place 2-5 mirror segments of various symmetry orientations
    mirror_types = ['horizontal', 'vertical', 'diag_down', 'diag_up']
    num_mirrors = randint(2, 5)
    mirror_colors = random_colors(num_mirrors, exclude=particle_colors + [0])

    mirror_info = {}
    used = set()

    def cells_free(cells):
        for (r, c) in cells:
            if r < 0 or r >= height or c < 0 or c >= width: return False
            if (r, c) in used: return False
            if r == 0: return False  # do not place mirrors on top row
        return True

    for color in mirror_colors:
        placed = False
        tries = 0
        # length between 3 and 6
        while not placed and tries < 100:
            tries += 1
            mtype = random.choice(mirror_types)
            length = randint(3, min(6, max(3, min(width, height) - 4)))
            if mtype == 'horizontal':
                r = randint(2, height - 3)
                c0 = randint(1, width - length - 1)
                cells = [(r, c0 + i) for i in range(length)]
            elif mtype == 'vertical':
                c = randint(1, width - 2)
                r0 = randint(2, height - length - 1)
                cells = [(r0 + i, c) for i in range(length)]
            elif mtype == 'diag_down':
                r0 = randint(2, height - length - 1)
                c0 = randint(1, width - length - 1)
                cells = [(r0 + i, c0 + i) for i in range(length)]
            else:  # diag_up
                r0 = randint(2, height - length - 1)
                c0 = randint(length, width - 2)
                cells = [(r0 + i, c0 - i) for i in range(length)]

            if not cells_free(cells):
                continue

            # mark cells and write color
            for (r, c) in cells:
                grid[r][c] = color
                used.add((r, c))
            mirror_info[color] = {'type': mtype, 'cells': set(cells)}
            placed = True

        # if not placed after tries, skip this color

    # Helper to test if a move goes to an empty background cell
    def can_move(r, c, dr, dc):
        r2 = r + dr
        c2 = c + dc
        if r2 < 0 or r2 >= height or c2 < 0 or c2 >= width:
            return False
        return grid[r2][c2] == 0

    # Reflection function (deterministic). Applies mirror rule then tries alternatives
    def reflect(dr, dc, mtype, r, c):
        # basic reflection across mirror axis
        if mtype == 'horizontal':
            cand = (-dr, dc)
        elif mtype == 'vertical':
            cand = (dr, -dc)
        elif mtype == 'diag_down':
            cand = (dc, dr)
        else:  # diag_up
            cand = (-dc, -dr)

        # list of candidate direction vectors in priority order
        cand_list = [cand, (-dc, dr), (dc, -dr), (-cand[0], -cand[1])]
        # filter duplicates while preserving order
        seen = set()
        uniq = []
        for d in cand_list:
            if d in seen: continue
            seen.add(d)
            uniq.append(d)

        for (ndr, ndc) in uniq:
            r2 = r + ndr
            c2 = c + ndc
            if 0 <= r2 < height and 0 <= c2 < width and grid[r2][c2] == 0:
                return ndr, ndc
        # if no candidate moves to free cell, return original basic cand (may cause stop)
        return cand

    # Create output and simulate each particle's path
    output = [row[:] for row in grid]

    for col, color in zip(particle_cols, particle_colors):
        r, c = 0, col
        dr, dc = 1, 0
        steps = 0
        visited_states = set()
        while steps < 1000:
            steps += 1
            state = (r, c, dr, dc)
            if state in visited_states:
                break
            visited_states.add(state)

            nr = r + dr
            nc = c + dc
            # if moving out of grid -> particle exits
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                break

            if grid[nr][nc] != 0:
                # We've encountered a mirror or occupied cell; reflect in place
                mirror_color = grid[nr][nc]
                if mirror_color in mirror_info:
                    mtype = mirror_info[mirror_color]['type']
                else:
                    # treat unknown occupant as horizontal mirror (fallback)
                    mtype = 'horizontal'
                dr, dc = reflect(dr, dc, mtype, r, c)
                # do not step into the mirror; recompute next iteration
                continue

            # empty cell: step into it and draw path if background
            r, c = nr, nc
            if output[r][c] == 0:
                output[r][c] = color
            # if we stepped onto another particle or path, treat as obstacle next loop

    return {'input': grid, 'output': output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # convert tuple-of-tuples to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Detect mirror colors and orientations by analyzing positions
    mirror_info = {}
    for color in range(1, 10):
        positions = []
        for r in range(height):
            for c in range(width):
                if grid[r][c] == color:
                    positions.append((r, c))
        if not positions:
            continue
        # require at least 3 pixels to be considered a mirror (filters out single-pixel particles)
        if len(positions) < 3:
            continue
        # check vertical (same column)
        cols = [c for (r, c) in positions]
        rows = [r for (r, c) in positions]
        if all(c == cols[0] for c in cols):
            mirror_info[color] = {'type': 'vertical', 'cells': set(positions)}
            continue
        if all(r == rows[0] for r in rows):
            mirror_info[color] = {'type': 'horizontal', 'cells': set(positions)}
            continue
        # diagonal down: r-c constant
        vals = [r - c for (r, c) in positions]
        if all(v == vals[0] for v in vals):
            mirror_info[color] = {'type': 'diag_down', 'cells': set(positions)}
            continue
        # diagonal up: r+c constant
        vals2 = [r + c for (r, c) in positions]
        if all(v == vals2[0] for v in vals2):
            mirror_info[color] = {'type': 'diag_up', 'cells': set(positions)}
            continue

    # helper to test if a move goes to an empty background cell
    def can_move(r, c, dr, dc):
        r2 = r + dr
        c2 = c + dc
        if r2 < 0 or r2 >= height or c2 < 0 or c2 >= width:
            return False
        return grid[r2][c2] == 0

    # reflection function: same deterministic behavior as in generator
    def reflect(dr, dc, mtype, r, c):
        if mtype == 'horizontal':
            cand = (-dr, dc)
        elif mtype == 'vertical':
            cand = (dr, -dc)
        elif mtype == 'diag_down':
            cand = (dc, dr)
        else:  # diag_up
            cand = (-dc, -dr)

        cand_list = [cand, (-dc, dr), (dc, -dr), (-cand[0], -cand[1])]
        seen = set()
        uniq = []
        for d in cand_list:
            if d in seen:
                continue
            seen.add(d)
            uniq.append(d)
        for (ndr, ndc) in uniq:
            r2 = r + ndr
            c2 = c + ndc
            if 0 <= r2 < height and 0 <= c2 < width and grid[r2][c2] == 0:
                return ndr, ndc
        return cand

    # find particles on top row
    particles = []
    for c in range(width):
        if grid[0][c] != 0:
            particles.append((0, c, grid[0][c]))

    output = [row[:] for row in grid]

    for (r0, c0, color) in particles:
        r, c = r0, c0
        dr, dc = 1, 0
        steps = 0
        visited = set()
        while steps < 1000:
            steps += 1
            state = (r, c, dr, dc)
            if state in visited:
                break
            visited.add(state)

            nr = r + dr
            nc = c + dc
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                break
            if grid[nr][nc] != 0:
                mirror_color = grid[nr][nc]
                mtype = mirror_info.get(mirror_color, {'type': 'horizontal'})['type']
                dr, dc = reflect(dr, dc, mtype, r, c)
                continue
            # step
            r, c = nr, nc
            if output[r][c] == 0:
                output[r][c] = color

    return output

