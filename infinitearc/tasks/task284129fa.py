# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 284129fa
Difficulty: very hard

=== Tags ===
- Staircase construction
- Pattern imitation
- Deterministic update

=== Description ===
Input grids feature a partially constructed staircase pattern oriented
diagonally (e.g., top-left to bottom-right), where each step consists of a
horizontal segment of three contiguous cells followed by a vertical segment of
two contiguous cells. The color of each step follows a repeating cycle of three
distinct colors (e.g., red → green → blue → red...), starting from the topmost
step. The staircase is incomplete, ending at the edge of the grid or adjacent to
background cells. Background cells are uniformly colored and distinct from all
staircase colors.  The output grid must extend the staircase by adding one
additional step in the same diagonal direction, maintaining identical horizontal
(3 cells) and vertical (2 cells) dimensions. The new step uses the next color in
the cycle. If extending would cause overlap with non-background cells or exceed
grid boundaries, the output remains identical to the input. The transformation
requires identifying the staircase's orientation, determining the current color
cycle from the input's step sequence, and precisely calculating the next step's
position based on the existing pattern. The solution must apply all rules
simultaneously and deterministically, with no ambiguity in the extension logic.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, flip_horiz

def generate():
    # Ensure grid is large enough to contain at least three steps so the 3-color cycle is visible
    while True:
        width = random.randint(9, 30)
        height = random.randint(9, 30)
        max_index = min((width - 3) // 2, (height - 3) // 2)
        if max_index >= 3:
            break
    bg = random.randint(0, 9)
    # choose three distinct step colors that are not the background
    palette = [c for c in range(1, 10) if c != bg]
    c1, c2, c3 = random.sample(palette, 3)
    cycle = [c1, c2, c3]
    # number of existing steps (k). Choose at least 3 so the 3-color cycle is unambiguous.
    n = random.randint(3, max_index)
    # Build base (TL->BR) staircase in a blank grid with background color bg
    base_in = grid(width, height, bg)
    for i in range(n):
        color = cycle[i % 3]
        r = 2 * i
        c_start = 2 * i
        # horizontal segment of length 3
        for c in range(c_start, c_start + 3):
            base_in[r][c] = color
        # vertical segment of length 2 (immediately below the rightmost horizontal cell)
        base_in[r + 1][c_start + 2] = color
        base_in[r + 2][c_start + 2] = color
    # Create the output by adding one more step (index n) in the same pattern
    base_out = [row[:] for row in base_in]
    r_new = 2 * n
    c_new = 2 * n
    next_color = cycle[n % 3]
    # Place the extra step (it should always fit because of how n was chosen)
    if r_new + 2 < height and c_new + 2 < width:
        for c in range(c_new, c_new + 3):
            base_out[r_new][c] = next_color
        base_out[r_new + 1][c_new + 2] = next_color
        base_out[r_new + 2][c_new + 2] = next_color
    else:
        # Defensive: fall back to identical copy (should not happen with chosen parameters)
        base_out = [row[:] for row in base_in]
    # Randomly flip horizontally to create a second orientation (top-right -> bottom-left)
    if random.random() < 0.5:
        final_in = flip_horiz(base_in)
        final_out = flip_horiz(base_out)
    else:
        final_in = base_in
        final_out = base_out
    return {"input": final_in, "output": final_out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import Counter

def p(input_grid):
    # Convert tuple-of-tuples to a mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    # Identify background as the most common color
    flat = [val for row in grid for val in row]
    bg = Counter(flat).most_common(1)[0][0]
    # Find horizontal segments (contiguous non-background runs of length >= 3)
    horizontals = []  # each entry: (row, left_col, color)
    for r in range(height):
        c = 0
        while c < width:
            if grid[r][c] == bg:
                c += 1
                continue
            start = c
            col_color = grid[r][c]
            while c < width and grid[r][c] != bg:
                c += 1
            end = c - 1
            length = end - start + 1
            if length >= 3:
                # record the leftmost column of the run and its color
                horizontals.append((r, start, col_color))
    # Sort by row (topmost step first)
    horizontals.sort(key=lambda x: x[0])
    # If no horizontals found, nothing to do
    if len(horizontals) == 0:
        return grid
    # Determine direction: if left column increases downwards it's TL->BR, else TR->BL
    if len(horizontals) >= 2:
        step_dir = 1 if horizontals[1][1] > horizontals[0][1] else -1
    else:
        # Fallback: inspect the vertical cells under the horizontal to choose direction
        r0, c0, _ = horizontals[0]
        if r0 + 1 < height and grid[r0 + 1][c0 + 2] != bg:
            step_dir = 1
        else:
            step_dir = -1
    # Determine the 3-color cycle from the first three horizontals (generator guarantees >=3)
    if len(horizontals) >= 3:
        cycle = [horizontals[i][2] for i in range(3)]
    else:
        # Defensive fallback: build a cycle using found colors and any other non-bg color
        found = []
        for h in horizontals:
            if h[2] not in found:
                found.append(h[2])
        # choose a third color different from the found ones (prefer small numbers)
        candidate = None
        for c in range(1, 10):
            if c == bg: 
                continue
            if c not in found:
                candidate = c
                break
        if candidate is None:
            candidate = found[0] if found else bg
        while len(found) < 3:
            found.append(candidate)
        cycle = found[:3]
    n_steps = len(horizontals)
    next_color = cycle[n_steps % 3]
    last_r, last_c_left, _ = horizontals[-1]
    r_new = last_r + 2
    c_left_new = last_c_left + 2 * step_dir
    # For TL->BR (step_dir == 1) vertical is under the rightmost (c_left + 2) and connecting corner is leftmost.
    # For TR->BL (step_dir == -1) vertical is under the leftmost (c_left) and connecting corner is rightmost (c_left + 2).
    if step_dir == 1:
        vert_col = c_left_new + 2
        connecting_corner = (r_new, c_left_new)
    else:
        vert_col = c_left_new
        connecting_corner = (r_new, c_left_new + 2)
    # Check bounds for the new step (horizontal length 3 and vertical 2)
    if r_new + 2 >= height or c_left_new < 0 or c_left_new + 2 >= width or vert_col < 0 or vert_col >= width:
        return grid
    # Coordinates that the new step would occupy
    new_cells = [(r_new, c_left_new + i) for i in range(3)] + [(r_new + 1, vert_col), (r_new + 2, vert_col)]
    # Verify that the new cells (except the expected connecting corner) are background
    for (rr, cc) in new_cells:
        if (rr, cc) == connecting_corner:
            # The connecting corner may already be filled by the previous step and will be overwritten
            continue
        if grid[rr][cc] != bg:
            # Can't extend because we'd overlap an existing non-background cell
            return grid
    # Apply the new color to produce the output grid
    out_grid = [row[:] for row in grid]
    for (rr, cc) in new_cells:
        out_grid[rr][cc] = next_color
    return out_grid

