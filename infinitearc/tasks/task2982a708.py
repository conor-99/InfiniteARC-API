# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 2982a708
Difficulty: hard

=== Tags ===
- One yes one no
- Interlock pieces

=== Description ===
The input grids consist of multiple disconnected, single-color regions (pieces)
arranged within a 2D grid. Each piece has a distinct shape with protrusions
(extensions along edges) and notches (indentations). The transformation requires
identifying all pairs of pieces where one piece's protrusion aligns perfectly
with another's notch (i.e., the geometric shape of the protrusion matches the
notch's contour). For each such matching pair, the piece containing the notch is
shifted by exactly one cell in the direction of the protrusion to achieve
interlocking. Pieces without a matching counterpart remain unchanged. The task
emphasizes precise geometric alignment over color or numerical properties,
requiring the solver to analyze edge shapes and spatial relationships across the
grid. The "one yes" refers to the mandatory interlocking of valid pairs, while
the "one no" signifies that non-matching pairs must not be altered, ensuring
only specific geometric relationships are transformed.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, randint, random_color

def generate():
    width = random.randint(6, 30)
    height = random.randint(6, 30)
    input_grid = grid(width, height, 0)
    output_grid = grid(width, height, 0)
    
    colors = random_color(exclude=[0]), random_color(exclude=[0])
    color1, color2 = colors
    
    a_r = random.randint(1, height - 3)
    a_c = random.randint(1, width - 5)
    input_grid[a_r][a_c] = color1
    input_grid[a_r][a_c + 1] = color1
    input_grid[a_r + 1][a_c] = color1
    
    b_r = a_r
    b_c = a_c + 3
    input_grid[b_r][b_c] = color2
    input_grid[b_r][b_c + 1] = color2
    input_grid[b_r + 1][b_c] = color2
    
    for r in range(height):
        for c in range(width):
            output_grid[r][c] = input_grid[r][c]
    
    output_grid[b_r][b_c] = 0
    output_grid[b_r][b_c - 1] = color2
    output_grid[b_r][b_c + 1] = 0
    output_grid[b_r][b_c] = color2
    output_grid[b_r + 1][b_c] = 0
    output_grid[b_r + 1][b_c - 1] = color2
    
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = [row[:] for row in input_grid]
    
    for r in range(height):
        for c in range(1, width):
            if input_grid[r][c] != 0 and input_grid[r][c-1] == 0:
                if (r > 0 and input_grid[r-1][c-1] != 0) or \
                   (r < height-1 and input_grid[r+1][c-1] != 0) or \
                   (c-2 >= 0 and input_grid[r][c-2] != 0):
                    color = input_grid[r][c]
                    output_grid[r][c] = 0
                    output_grid[r][c-1] = color
                    if c+1 < width and input_grid[r][c+1] == color:
                        output_grid[r][c+1] = 0
                        output_grid[r][c] = color
                    if r+1 < height and input_grid[r+1][c] == color:
                        output_grid[r+1][c] = 0
                        output_grid[r+1][c-1] = color
    return output_grid
