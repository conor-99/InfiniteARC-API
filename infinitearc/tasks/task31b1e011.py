# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 31b1e011
Difficulty: medium–hard

=== Tags ===
- Recursive agent following
- Refraction simulation
- Pattern resizing

=== Description ===
Input grids feature a background color (0), a small solid-colored motif (the
stencil) positioned anywhere on the grid, and a continuous path of a distinct
color (1) that begins at the top-left corner and initially moves rightward. The
path encounters two types of refraction elements: color 2 (causing a leftward
turn) and color 3 (causing a rightward turn). The path follows these rules: upon
encountering color 2, the direction changes to upward; upon encountering color
3, the direction changes to downward. The path continues until it exits the
grid, never looping or overlapping itself. The output grid retains all original
elements except the stencil, which is resized to dimensions (original width +
count of color 2 elements along the path) × (original height + count of color 3
elements along the path). The resized stencil is centered at the original
stencil's position, maintaining its color. All other grid content, including the
path, remains unchanged. The resizing is purely additive—no distortion or
scaling of internal patterns occurs. The task requires tracking the path's
direction changes, counting refraction elements, and applying the additive
resizing rule to the stencil.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = [[0] * width for _ in range(height)]
    
    stencil_color = random.choice([4,5,6,7,8,9])
    st_w = random.randint(2, 3)
    st_h = random.randint(2, 3)
    st_r = random.randint(0, height - st_h)
    st_c = random.randint(0, width - st_w)
    for r in range(st_r, st_r + st_h):
        for c in range(st_c, st_c + st_w):
            grid[r][c] = stencil_color
    
    # Place 2s along path
    for _ in range(random.randint(1, 3)):
        r2 = 0
        c2 = 2 * (random.randint(1, 3))
        if c2 < width and grid[r2][c2] == 0:
            grid[r2][c2] = 2
    
    # Place 3s along path
    for _ in range(random.randint(1, 3)):
        r3 = 2 * (random.randint(1, 3))
        c3 = 0
        if r3 < height and grid[r3][c3] == 0:
            grid[r3][c3] = 3
    
    # Generate path and count actual encounters
    r, c = 0, 0
    direction = (0, 1)
    count_2 = 0
    count_3 = 0
    steps = 0
    max_steps = 1000
    
    while steps < max_steps and 0 <= r < height and 0 <= c < width:
        if grid[r][c] == 0:
            grid[r][c] = 1
        nr, nc = r + direction[0], c + direction[1]
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        if grid[nr][nc] == 2:
            count_2 += 1
            direction = (-1, 0)
        elif grid[nr][nc] == 3:
            count_3 += 1
            direction = (1, 0)
        r, c = nr, nc
        steps += 1
    
    output = [row[:] for row in grid]
    
    # Resize stencil using actual counts
    st_pixels = []
    for r in range(st_r, st_r + st_h):
        for c in range(st_c, st_c + st_w):
            st_pixels.append((r, c))
    
    new_w = st_w + count_2
    new_h = st_h + count_3
    
    new_st_r = st_r + st_h//2 - new_h//2
    new_st_c = st_c + st_w//2 - new_w//2
    
    for r in range(st_r, st_r + st_h):
        for c in range(st_c, st_c + st_w):
            output[r][c] = 0
    
    for r in range(new_st_r, new_st_r + new_h):
        for c in range(new_st_c, new_st_c + new_w):
            if 0 <= r < height and 0 <= c < width:
                output[r][c] = stencil_color
    
    return {'input': grid, 'output': output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    r, c = 0, 0
    direction = (0, 1)
    count_2 = 0
    count_3 = 0
    steps = 0
    max_steps = 1000
    
    while steps < max_steps and 0 <= r < height and 0 <= c < width:
        nr, nc = r + direction[0], c + direction[1]
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        if grid[nr][nc] == 2:
            count_2 += 1
            direction = (-1, 0)
        elif grid[nr][nc] == 3:
            count_3 += 1
            direction = (1, 0)
        r, c = nr, nc
        steps += 1
    
    stencil_color = 4
    for r in range(height):
        for c in range(width):
            if grid[r][c] not in [0, 1, 2, 3]:
                stencil_color = grid[r][c]
                break
        else:
            continue
        break
    
    visited = set()
    stack = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] == stencil_color:
                stack.append((r, c))
                break
        if stack:
            break
    
    while stack:
        r, c = stack.pop()
        if (r, c) in visited:
            continue
        visited.add((r, c))
        for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == stencil_color:
                stack.append((nr, nc))
    
    if not visited:
        return grid
    
    st_r = min(r for r, c in visited)
    st_c = min(c for r, c in visited)
    st_w = max(c for r, c in visited) - st_c + 1
    st_h = max(r for r, c in visited) - st_r + 1
    
    new_w = st_w + count_2
    new_h = st_h + count_3
    
    new_st_r = st_r + st_h//2 - new_h//2
    new_st_c = st_c + st_w//2 - new_w//2
    
    output = [row[:] for row in grid]
    
    for r in range(st_r, st_r + st_h):
        for c in range(st_c, st_c + st_w):
            output[r][c] = 0
    
    for r in range(new_st_r, new_st_r + new_h):
        for c in range(new_st_c, new_st_c + new_w):
            if 0 <= r < height and 0 <= c < width:
                output[r][c] = stencil_color
    
    return output
