# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: b75aef9d
Difficulty: medium–hard

=== Tags ===
- Zigzag path
- Image expansion
- Fill between lines

=== Description ===
Input grids feature two parallel, straight lines of identical color, oriented
either horizontally or vertically, separated by a minimum gap of two cells. The
lines are the only non-background elements, with the rest of the grid filled
with a single background color. Grid dimensions are sufficient to accommodate
the lines and gap (e.g., horizontal lines require height > 2, vertical lines
require width > 2).  The output grid must fill the region between the two
parallel lines with a continuous zigzag path. For horizontally oriented lines,
the path alternates direction between rightward and leftward segments at each
row within the gap, creating a serpentine pattern. For vertically oriented
lines, the path alternates between upward and downward segments at each column
within the gap. The path uses a new color distinct from both the lines and
background, spans the entire width (for horizontal lines) or height (for
vertical lines) of the gap, and maintains consistent segment length (2 cells per
segment). The original lines remain visible, and the path does not overlap with
the lines, background, or other elements. The transformation requires
identifying line orientation, computing the gap, and generating the alternating
pattern—requiring multi-step reasoning and handling both orientations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

# Keep a global set of used parameter tuples so that repeated calls produce unique examples.
_used_configs = set()


def generate():
    """Generate an input/output pair for the zigzag-between-lines task.

    The input contains exactly two parallel full rows (horizontal) or full columns
    (vertical) of a single non-background color. There is a gap of at least two
    cells between the lines. The output fills the region between the two lines
    with a new color (the smallest color not equal to the background or the
    line color). The original lines remain unchanged.
    """
    tries = 0
    while tries < 2000:
        tries += 1
        orientation = random.choice(["horizontal", "vertical"])  # orientation of the two lines

        # pick background and line colors (distinct)
        bg = random.randint(0, 9)
        line = random.randint(0, 9)
        while line == bg:
            line = random.randint(0, 9)

        # choose the path color deterministically so the solver can reproduce it:
        path = next(c for c in range(10) if c != bg and c != line)

        if orientation == "horizontal":
            width = random.randint(3, 30)
            height = random.randint(4, 30)  # need at least two rows between the lines

            # pick two distinct row indices y1 < y2 with y2 - y1 >= 3
            # ensure y1 upper bound keeps y2 selection valid
            y1 = random.randint(0, height - 4)
            y2 = random.randint(y1 + 3, height - 1)

            key = ("h", width, height, bg, line, path, y1, y2)
            if key in _used_configs:
                continue
            _used_configs.add(key)

            # build the input: background with two full horizontal lines
            input_grid = common.grid(width, height, bg)
            for c in range(width):
                input_grid[y1][c] = line
                input_grid[y2][c] = line

            # build the output: fill the rows strictly between y1 and y2 with path color
            output_grid = [row[:] for row in input_grid]
            for r in range(y1 + 1, y2):
                for c in range(width):
                    output_grid[r][c] = path

            return {"input": input_grid, "output": output_grid}

        else:  # vertical
            height = random.randint(3, 30)
            width = random.randint(4, 30)  # need at least two columns between the lines

            # pick two distinct column indices x1 < x2 with x2 - x1 >= 3
            # ensure x1 upper bound keeps x2 selection valid
            x1 = random.randint(0, width - 4)
            x2 = random.randint(x1 + 3, width - 1)

            key = ("v", width, height, bg, line, path, x1, x2)
            if key in _used_configs:
                continue
            _used_configs.add(key)

            # build the input: background with two full vertical lines
            input_grid = common.grid(width, height, bg)
            for r in range(height):
                input_grid[r][x1] = line
                input_grid[r][x2] = line

            # build the output: fill the columns strictly between x1 and x2 with path color
            output_grid = [row[:] for row in input_grid]
            for c in range(x1 + 1, x2):
                for r in range(height):
                    output_grid[r][c] = path

            return {"input": input_grid, "output": output_grid}

    raise RuntimeError("Failed to generate a unique grid after many attempts")



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import collections

def p(input_grid):
    # Convert to mutable list-of-lists if necessary
    if isinstance(input_grid, tuple) or isinstance(input_grid[0], tuple):
        grid = [list(row) for row in input_grid]
    else:
        grid = [list(row) for row in input_grid]

    height = len(grid)
    width = len(grid[0])

    # Count full uniform rows and columns per color
    row_full = {}
    for r in range(height):
        val = grid[r][0]
        if all(grid[r][c] == val for c in range(width)):
            row_full[val] = row_full.get(val, 0) + 1

    col_full = {}
    for c in range(width):
        val = grid[0][c]
        if all(grid[r][c] == val for r in range(height)):
            col_full[val] = col_full.get(val, 0) + 1

    # Prefer a color that fills exactly two full rows or two full columns (the lines)
    line_color = None
    for color, cnt in row_full.items():
        if cnt == 2:
            line_color = color
            break
    if line_color is None:
        for color, cnt in col_full.items():
            if cnt == 2:
                line_color = color
                break

    # If not found yet, look for a color that has total full count >= 2
    if line_color is None:
        for color in set(list(row_full.keys()) + list(col_full.keys())):
            if row_full.get(color, 0) + col_full.get(color, 0) >= 2:
                line_color = color
                break

    # Fallback: determine background first and then pick any other color
    if line_color is None:
        flat = [v for row in grid for v in row]
        bg = collections.Counter(flat).most_common(1)[0][0]
        for v in set(flat):
            if v != bg:
                line_color = v
                break

    # Now determine background as the most common color that's not the line color
    flat = [v for row in grid for v in row]
    counts = collections.Counter(flat)
    bg = None
    for color, _ in counts.most_common():
        if color != line_color:
            bg = color
            break
    if bg is None:
        # extremely degenerate fallback
        bg = 0 if line_color != 0 else 1

    # Choose path color deterministically to match the generator
    path_color = next(c for c in range(10) if c != bg and c != line_color)

    # Produce output by filling the region strictly between the two lines
    out = [row[:] for row in grid]

    # Check horizontal lines
    horiz_rows = [r for r in range(height) if all(grid[r][c] == line_color for c in range(width))]
    if len(horiz_rows) == 2:
        y1, y2 = sorted(horiz_rows)
        for r in range(y1 + 1, y2):
            for c in range(width):
                out[r][c] = path_color
        return out

    # Check vertical lines
    vert_cols = [c for c in range(width) if all(grid[r][c] == line_color for r in range(height))]
    if len(vert_cols) == 2:
        x1, x2 = sorted(vert_cols)
        for c in range(x1 + 1, x2):
            for r in range(height):
                out[r][c] = path_color
        return out

    return out

