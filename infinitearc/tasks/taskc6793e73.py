# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: c6793e73
Difficulty: medium–hard

=== Tags ===
- Multi object alignment

=== Description ===
Input grids contain multiple distinct colored objects (each a contiguous group
of 2–4 cells forming simple geometric shapes like squares or Ls) against a
uniform background. The objects are positioned at various locations with no
overlapping. The output grid transforms the input by repositioning each object
such that the top-left corner of every object aligns precisely along the main
diagonal of the grid (where row index equals column index), while preserving the
objects' relative horizontal and vertical order from the input. Objects are
shifted vertically and/or horizontally to achieve this diagonal alignment
without overlapping, maintaining their original shapes and colors. The
background remains unchanged, and all objects remain fully contained within the
grid boundaries.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, continuous_creature, random_colors


def generate():
    """
    Generates an ARC pair where multiple small contiguous colored objects are placed
    on a background. The output moves each object's top-left corner to the main diagonal
    at positions d_k = sum_{i<k} max(h_i, w_i) (i.e. starting at 0) preserving the
    sorted order of objects by their original top-lefts. The generator ensures that
    objects don't overlap, fit in the grid, and that the input differs from the output.
    """
    bg = 0
    # Try a few times to build a valid configuration
    for attempt in range(200):
        num_objects = random.randint(2, 4)
        # Create a small contiguous sprite for each object (size 2..4) inside a 3x3 box
        sprites = []  # list of lists of (r,c)
        sizes = [random.randint(2, 4) for _ in range(num_objects)]
        for s in sizes:
            pixels = continuous_creature(s, width=3, height=3)
            # normalize so top-left of sprite is at (0,0)
            min_r = min(p[0] for p in pixels)
            min_c = min(p[1] for p in pixels)
            norm = [(p[0] - min_r, p[1] - min_c) for p in pixels]
            # recompute dims
            h = max(p[0] for p in norm) + 1
            w = max(p[1] for p in norm) + 1
            sprites.append({
                'pixels': norm,
                'h': h,
                'w': w
            })

        # step for diagonal placement is the max dimension of each object
        steps = [max(s['h'], s['w']) for s in sprites]
        total_steps = sum(steps)

        # Require at least one extra row/col so we can jitter input (avoid input==output)
        min_side = total_steps + 1
        if min_side > 30:
            continue  # try different sprites

        # choose grid size large enough
        width = random.randint(min_side, 30)
        height = random.randint(min_side, 30)

        # diagonal top-left positions: deterministic start at 0
        diag_positions = []
        prefix = 0
        fits = True
        for i, s in enumerate(sprites):
            d = prefix
            # check fits within bounds
            if d + s['w'] > width or d + s['h'] > height:
                fits = False
                break
            diag_positions.append((d, d))
            prefix += steps[i]
        if not fits:
            continue

        # create initial input positions by starting from diagonal and applying small jitters
        # while preserving strict increasing order in both row and column and avoiding overlaps
        base_positions = [list(p) for p in diag_positions]

        def rects_overlap(a_r, a_c, a_h, a_w, b_r, b_c, b_h, b_w):
            # returns True if rectangles overlap (share at least one cell)
            if a_r + a_h - 1 < b_r or b_r + b_h - 1 < a_r:
                return False
            if a_c + a_w - 1 < b_c or b_c + b_w - 1 < a_c:
                return False
            return True

        def all_non_overlapping(positions):
            for i in range(len(positions)):
                for j in range(i + 1, len(positions)):
                    r1, c1 = positions[i]
                    r2, c2 = positions[j]
                    if rects_overlap(r1, c1, sprites[i]['h'], sprites[i]['w'], r2, c2, sprites[j]['h'], sprites[j]['w']):
                        return False
            return True

        # Try greedy small jitters to ensure input != output but preserve ordering and no-overlap
        indices = list(range(num_objects))
        random.shuffle(indices)
        changed = False
        for k in indices:
            choices = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]
            random.shuffle(choices)
            for dr, dc in choices:
                new_positions = [list(p) for p in base_positions]
                new_r = base_positions[k][0] + dr
                new_c = base_positions[k][1] + dc
                # bounds check
                if new_r < 0 or new_c < 0 or new_r + sprites[k]['h'] > height or new_c + sprites[k]['w'] > width:
                    continue
                # ordering check
                ok = True
                if k > 0:
                    if not (new_r > new_positions[k - 1][0] and new_c > new_positions[k - 1][1]):
                        ok = False
                if k < num_objects - 1:
                    if not (new_positions[k + 1][0] > new_r and new_positions[k + 1][1] > new_c):
                        ok = False
                if not ok:
                    continue
                new_positions[k] = [new_r, new_c]
                if not all_non_overlapping(new_positions):
                    continue
                # accept
                base_positions = new_positions
                changed = True
                break
            if changed:
                break

        # If we failed to make any change, try to nudge the last object down/right if possible
        if not changed:
            k = num_objects - 1
            for dr, dc in [(1, 0), (0, 1), (-1, 0), (0, -1)]:
                new_positions = [list(p) for p in base_positions]
                new_r = base_positions[k][0] + dr
                new_c = base_positions[k][1] + dc
                if new_r < 0 or new_c < 0 or new_r + sprites[k]['h'] > height or new_c + sprites[k]['w'] > width:
                    continue
                if not (new_positions[k - 1][0] < new_r and new_positions[k - 1][1] < new_c):
                    continue
                new_positions[k] = [new_r, new_c]
                if all_non_overlapping(new_positions):
                    base_positions = new_positions
                    changed = True
                    break

        if not changed:
            # try again from scratch
            continue

        # Now build the input grid
        input_grid = grid(width, height, bg)
        colors = random_colors(num_objects, exclude=[bg])
        for idx, s in enumerate(sprites):
            r0, c0 = base_positions[idx]
            for (rr, cc) in s['pixels']:
                input_grid[r0 + rr][c0 + cc] = colors[idx]

        # Build the output grid using deterministic diagonal placement starting at 0
        output_grid = grid(width, height, bg)
        prefix = 0
        for idx, s in enumerate(sprites):
            d = prefix
            for (rr, cc) in s['pixels']:
                output_grid[d + rr][d + cc] = colors[idx]
            prefix += steps[idx]

        # Sanity check: input must not equal output
        if input_grid == output_grid:
            continue

        return {"input": input_grid, "output": output_grid}

    # Fallback (should not normally occur)
    # build tiny trivial instance
    width = 6
    height = 6
    input_grid = grid(width, height, bg)
    output_grid = grid(width, height, bg)
    # place two simple objects
    input_grid[0][0] = 1; input_grid[0][1] = 1
    output_grid[0][0] = 1; output_grid[2][2] = 1
    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    inp = [list(row) for row in input_grid]
    height = len(inp)
    width = len(inp[0])
    bg = 0

    # Find all colors (objects). Assumes each object uses a unique non-background color.
    colors = sorted({inp[r][c] for r in range(height) for c in range(width) if inp[r][c] != bg})

    objects = []  # list of (color, pixels, top_left_row, top_left_col)
    for color in colors:
        pixels = [(r, c) for r in range(height) for c in range(width) if inp[r][c] == color]
        min_r = min(p[0] for p in pixels)
        min_c = min(p[1] for p in pixels)
        rel = [(p[0] - min_r, p[1] - min_c) for p in pixels]
        h = max(p[0] for p in rel) + 1
        w = max(p[1] for p in rel) + 1
        objects.append((color, rel, min_r, min_c, h, w))

    # Sort objects by their original top-left to preserve relative order
    objects.sort(key=lambda x: (x[2], x[3]))

    # Determine diagonal positions: deterministic start at 0, step by max(h,w)
    steps = [max(obj[4], obj[5]) for obj in objects]
    prefix = 0
    output = [[bg for _ in range(width)] for __ in range(height)]
    for i, obj in enumerate(objects):
        color, rel, _, _, h, w = obj
        d = prefix
        for (rr, cc) in rel:
            r = d + rr
            c = d + cc
            if 0 <= r < height and 0 <= c < width:
                output[r][c] = color
        prefix += steps[i]

    return output

