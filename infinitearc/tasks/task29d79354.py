# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 29d79354
Difficulty: medium–hard

=== Tags ===
- Context sensitive recolor
- Multi agent path weaving
- Region partitioning
- Field interference pattern

=== Description ===
Input grids feature multiple colored agents (each a distinct color) positioned
at various grid cells, each moving in a fixed initial direction (N, S, E, W).
Scattered across the grid are interference fields—each a unique color—arranged
to form a field interference pattern. These fields induce context-sensitive
recoloring and directional changes when agents enter them.    The output grid
demonstrates the agents' complete paths after traversing all interference
fields, with the following rules applied in sequence:   1. **Context-sensitive
recolor**: Upon entering an interference field cell, an agent's color changes to
a new color determined by a predefined mapping (e.g., red field + blue agent →
green path).   2. **Multi-agent path weaving**: Agents move one cell per step in
their current direction, with path segments drawn using their current color.
When an agent enters a field, its direction rotates 90° clockwise (e.g., E → S →
W → N → E), and the color updates as per Rule 1.   3. **Region partitioning**:
The interference fields partition the grid into contiguous regions; each
region's boundaries define where path weaving occurs, and the output grid
visually emphasizes these partitions with boundary lines.   4. **Field
interference pattern**: The arrangement of fields creates a non-overlapping,
symmetrical pattern (e.g., checkerboard or spiral), influencing how paths weave
through the grid without overlapping or crossing.    Agents continue moving
until they exit the grid boundaries. The output grid shows the full path
trajectories (with color changes), region boundaries, and interference field
patterns. Unused field cells remain unchanged, and paths do not overlap (agents
move sequentially or in parallel with no collisions). This task requires
recognizing the field pattern, mapping color interactions, and predicting path
directions through multiple interference events—combining spatial reasoning with
sequential state updates.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Grid size (kept moderate to allow varied paths but fast simulation)
    width = random.randint(5, 9)
    height = random.randint(5, 9)

    # Initialize empty grid
    grid = [[0 for _ in range(width)] for _ in range(height)]

    # Choose an interference pattern: checkerboard or vertical lines
    pattern = random.choice(["checker", "vline"])

    # Choose 1-3 interference colors (from 1..5)
    field_colors = random.sample([1, 2, 3, 4, 5], k=random.randint(1, 3))

    # Populate interference fields according to pattern
    interference_cells = set()
    if pattern == "checker":
        for r in range(height):
            for c in range(width):
                if (r + c) % 2 == 0:
                    color = field_colors[(r + c) % len(field_colors)]
                    grid[r][c] = color
                    interference_cells.add((r, c))
    else:  # vline
        spacing = random.choice([2, 3])
        for c in range(width):
            if c % spacing == 0:
                color = field_colors[c % len(field_colors)]
                for r in range(height):
                    grid[r][c] = color
                    interference_cells.add((r, c))

    # Agent colors (distinct) drawn from 6..9
    possible_agent_colors = [6, 7, 8, 9]

    # Direction mapping for agent's initial color
    def get_dir(col):
        return {6: 'N', 7: 'E', 8: 'S', 9: 'W'}[col]

    # Candidate non-field cells
    non_field = [(r, c) for r in range(height) for c in range(width) if (r, c) not in interference_cells]
    if not non_field:
        # fallback tiny change
        return generate()

    # Build list of feasible start positions: a start is feasible if the agent will be able to mark at least
    # one additional non-field cell (so output != input). To guarantee this we require at least two steps remain
    # inside the grid in the agent's initial direction (start -> maybe field -> next non-field).
    def inside(r, c):
        return 0 <= r < height and 0 <= c < width

    drdc = {'N': (-1, 0), 'S': (1, 0), 'E': (0, 1), 'W': (0, -1)}

    feasible = []
    for (r, c) in non_field:
        for col in possible_agent_colors:
            d = get_dir(col)
            dr, dc = drdc[d]
            # require two steps in direction to be inside grid so the agent will reach another non-field cell
            nr1, nc1 = r + dr, c + dc
            nr2, nc2 = r + 2*dr, c + 2*dc
            if inside(nr1, nc1) and inside(nr2, nc2):
                # also ensure we don't place agent on a cell that is a field
                feasible.append((r, c, col))

    if not feasible:
        # If nothing feasible, retry with a different random size/pattern
        return generate()

    # Choose number of agents (1 to min(3, number of feasible / 2)) to avoid collisions
    max_agents = max(1, min(3, len(feasible)//2))
    n_agents = random.randint(1, max_agents)

    chosen = []
    used_cells = set()
    used_colors = set()
    # pick starting (cell, color) combos without reuse of same cell or same agent color
    random.shuffle(feasible)
    for (r, c, col) in feasible:
        if len(chosen) >= n_agents:
            break
        if (r, c) in used_cells: continue
        if col in used_colors: continue
        chosen.append((r, c, col))
        used_cells.add((r, c))
        used_colors.add(col)

    # If we failed to pick enough, reduce n_agents
    if len(chosen) == 0:
        return generate()

    # Sort chosen agents by position so the generator's processing order is deterministic (row-major).
    chosen.sort(key=lambda x: (x[0], x[1]))

    # Place agents on input grid
    for (r, c, col) in chosen:
        grid[r][c] = col

    # Now simulate agents sequentially to create output grid
    output = [row[:] for row in grid]

    def rotate_cw(d):
        return {'N': 'E', 'E': 'S', 'S': 'W', 'W': 'N'}[d]

    step_cap = width * height * 10

    field_color_set = set(field_colors)

    # For each agent in the order chosen, simulate its path and write path cells to output.
    for (sr, sc, scol) in chosen:
        cur_r, cur_c = sr, sc
        cur_col = scol
        cur_dir = get_dir(scol)

        # Mark the starting cell as part of the path (it already contains the agent color in input)
        output[cur_r][cur_c] = cur_col

        steps = 0
        while steps < step_cap:
            dr, dc = drdc[cur_dir]
            nr, nc = cur_r + dr, cur_c + dc
            # Exit if leaving grid
            if not inside(nr, nc):
                break
            # If next cell is a field cell (interference), update color & rotate, but do NOT overwrite the field cell
            if (nr, nc) in interference_cells:
                fcol = grid[nr][nc]
                # update color via deterministic mapping
                cur_col = ((cur_col + fcol) % 9) + 1
                cur_dir = rotate_cw(cur_dir)
                # move into the field cell (position changes) but we do not draw on it
                cur_r, cur_c = nr, nc
                steps += 1
                continue
            else:
                # Next cell is a non-field cell. If it's already occupied by a previous path (non-zero and not a field color),
                # we stop to avoid overlapping paths.
                if output[nr][nc] != 0 and (nr, nc) not in interference_cells:
                    break
                # paint the cell with current agent color
                output[nr][nc] = cur_col
                cur_r, cur_c = nr, nc
                steps += 1
                continue

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable grid
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Recognize field colors as small numbers (1..5) and agent colors as 6..9
    field_color_set = set()
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if 1 <= v <= 5:
                field_color_set.add(v)

    # Direction helpers
    drdc = {'N': (-1, 0), 'S': (1, 0), 'E': (0, 1), 'W': (0, -1)}
    def get_dir(col):
        return {6: 'N', 7: 'E', 8: 'S', 9: 'W'}[col]
    def rotate_cw(d):
        return {'N': 'E', 'E': 'S', 'S': 'W', 'W': 'N'}[d]
    def inside(r, c):
        return 0 <= r < height and 0 <= c < width

    # Identify agents (cells with colors 6..9)
    agents = []
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if v in (6, 7, 8, 9):
                agents.append((r, c, v))

    # Work on a copy for output
    output = [row[:] for row in grid]

    step_cap = width * height * 10

    # Simulate each agent sequentially in the order found (generator also used a deterministic order)
    for (sr, sc, scol) in agents:
        cur_r, cur_c = sr, sc
        cur_col = scol
        cur_dir = get_dir(scol)
        # mark starting cell
        output[cur_r][cur_c] = cur_col

        steps = 0
        while steps < step_cap:
            dr, dc = drdc[cur_dir]
            nr, nc = cur_r + dr, cur_c + dc
            if not inside(nr, nc):
                break
            # If next cell is a field
            if grid[nr][nc] in field_color_set and (nr, nc) != (cur_r, cur_c):
                fcol = grid[nr][nc]
                cur_col = ((cur_col + fcol) % 9) + 1
                cur_dir = rotate_cw(cur_dir)
                cur_r, cur_c = nr, nc
                steps += 1
                continue
            else:
                # next is non-field
                # if occupied by previous path (non-zero and not a field), stop
                if output[nr][nc] != 0 and grid[nr][nc] not in field_color_set:
                    break
                output[nr][nc] = cur_col
                cur_r, cur_c = nr, nc
                steps += 1
                continue

    # Return as tuple of tuples
    return tuple(tuple(row) for row in output)

