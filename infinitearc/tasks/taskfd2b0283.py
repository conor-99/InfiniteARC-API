# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: fd2b0283
Difficulty: mediumâ€“hard

=== Tags ===
- Symmetry axis completion
- Symbolic circuit
- Inference from demonstration
- Connect all dots of same color

=== Description ===
Input grids display a collection of colored cells (0 represents background)
arranged in an asymmetric pattern. Each color's instances are initially
disconnected, forming multiple separate regions. The output grid must complete
the grid to be symmetric across a specific axis (vertical, horizontal, or
diagonal) determined by the input's structure. This axis is inferred from the
distribution and placement of non-background elements. For example, if the left
side contains most elements while the right is sparse, the axis is vertical
through the grid's midpoint. The grid is mirrored across this axis, adding
missing elements to complete symmetry. This mirroring process inherently
connects all disconnected regions of the same color into single continuous
paths, as mirrored elements bridge gaps between original and reflected
components. The output grid will exhibit perfect symmetry, with every color
forming a single connected region without gaps, and no original elements altered
or removed. The axis is uniquely determined by the input's geometric properties,
requiring the solver to deduce its orientation and position through pattern
analysis.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # We'll retry generation until the chosen axis produces the strongest imbalance
    # so it's uniquely identifiable by the solver.
    for attempt in range(200):
        axis = random.choice(['vertical', 'horizontal', 'diag_main', 'diag_anti'])

        # Choose grid size. For diagonal axes require square grid.
        if axis == 'vertical':
            width = random.choice([w for w in range(6, 22) if w % 2 == 0])
            height = random.randint(5, 21)
        elif axis == 'horizontal':
            height = random.choice([h for h in range(6, 22) if h % 2 == 0])
            width = random.randint(5, 21)
        else:
            size = random.choice([s for s in range(6, 22)])
            width = height = size

        # initialize grid
        input_grid = [[0 for _ in range(width)] for _ in range(height)]

        # pick number of colors and which colors (1..9)
        num_colors = random.randint(2, 4)
        colors = random.sample(list(range(1, 10)), num_colors)

        # Decide which side will be the populated (major) side
        if axis == 'vertical':
            major_side = random.choice(['left', 'right'])
        elif axis == 'horizontal':
            major_side = random.choice(['top', 'bottom'])
        elif axis == 'diag_main':
            major_side = random.choice(['above', 'below'])
        else:
            major_side = random.choice(['above', 'below'])

        # Helper functions
        def is_allowed(r, c):
            if input_grid[r][c] != 0:
                return False
            if axis == 'vertical':
                if major_side == 'left':
                    return c < (width // 2)
                else:
                    return c >= ((width + 1) // 2)
            if axis == 'horizontal':
                if major_side == 'top':
                    return r < (height // 2)
                else:
                    return r >= ((height + 1) // 2)
            if axis == 'diag_main':
                if major_side == 'above':
                    return r < c
                else:
                    return r > c
            if axis == 'diag_anti':
                if major_side == 'above':
                    return r + c < (width - 1)
                else:
                    return r + c > (width - 1)
            return False

        def orth_neighbors(r, c):
            for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                rr, cc = r+dr, c+dc
                if 0 <= rr < height and 0 <= cc < width:
                    yield rr, cc

        def adjacent_same_color_outside(cell_r, cell_c, color, current_cluster_set):
            # return True if any orth neighbor not in current cluster has the same color already placed
            for rr, cc in orth_neighbors(cell_r, cell_c):
                if (rr, cc) in current_cluster_set:
                    continue
                if input_grid[rr][cc] == color:
                    return True
            return False

        # Place clusters for each color
        occupied = set()
        for color in colors:
            clusters = random.randint(2, 4)
            attempts_clusters = 0
            placed_clusters = 0
            while placed_clusters < clusters and attempts_clusters < clusters * 40:
                attempts_clusters += 1
                cl_size = random.randint(1, 6)
                allowed_positions = [(r,c) for r in range(height) for c in range(width) if is_allowed(r,c)]
                if not allowed_positions:
                    break
                start = random.choice(allowed_positions)
                if adjacent_same_color_outside(start[0], start[1], color, set()):
                    continue
                cluster = {start}
                frontier = [start]
                tries = 0
                while len(cluster) < cl_size and frontier and tries < 80:
                    tries += 1
                    base = random.choice(frontier)
                    nbrs = [p for p in orth_neighbors(base[0], base[1]) if is_allowed(p[0], p[1]) and p not in cluster]
                    nbrs = [p for p in nbrs if not adjacent_same_color_outside(p[0], p[1], color, cluster)]
                    if not nbrs:
                        try:
                            frontier.remove(base)
                        except ValueError:
                            pass
                        continue
                    nxt = random.choice(nbrs)
                    cluster.add(nxt)
                    frontier.append(nxt)
                good = True
                for (r,c) in cluster:
                    if not is_allowed(r,c):
                        good = False
                        break
                    if adjacent_same_color_outside(r, c, color, cluster):
                        good = False
                        break
                if not good:
                    continue
                for (r,c) in cluster:
                    input_grid[r][c] = color
                    occupied.add((r,c))
                placed_clusters += 1

        # Guarantee at least one colored pixel exists
        any_nonzero = any(input_grid[r][c] != 0 for r in range(height) for c in range(width))
        if not any_nonzero:
            for r in range(height):
                for c in range(width):
                    if is_allowed(r,c):
                        input_grid[r][c] = colors[0]
                        any_nonzero = True
                        break
                if any_nonzero: break

        # Compute imbalance scores to ensure chosen axis is uniquely most imbalanced
        # vertical
        left_count = sum(1 for r in range(height) for c in range(width // 2) if input_grid[r][c] != 0)
        right_count = sum(1 for r in range(height) for c in range((width + 1)//2, width) if input_grid[r][c] != 0)
        vert_diff = abs(left_count - right_count)
        # horizontal
        top_count = sum(1 for c in range(width) for r in range(height // 2) if input_grid[r][c] != 0)
        bottom_count = sum(1 for c in range(width) for r in range((height + 1)//2, height) if input_grid[r][c] != 0)
        horiz_diff = abs(top_count - bottom_count)
        # diagonals
        diag_main_diff = -1
        diag_anti_diff = -1
        if width == height:
            n = width
            above_main = sum(1 for r in range(n) for c in range(n) if r < c and input_grid[r][c] != 0)
            below_main = sum(1 for r in range(n) for c in range(n) if r > c and input_grid[r][c] != 0)
            diag_main_diff = abs(above_main - below_main)
            above_anti = sum(1 for r in range(n) for c in range(n) if r + c < n - 1 and input_grid[r][c] != 0)
            below_anti = sum(1 for r in range(n) for c in range(n) if r + c > n - 1 and input_grid[r][c] != 0)
            diag_anti_diff = abs(above_anti - below_anti)

        diffs = {'vertical': vert_diff, 'horizontal': horiz_diff, 'diag_main': diag_main_diff, 'diag_anti': diag_anti_diff}
        # require the chosen axis to have strictly larger imbalance than all others
        chosen_diff = diffs[axis]
        larger_than_all = True
        for k,v in diffs.items():
            if k == axis: continue
            # ignore negative diag diffs for non-square
            if v < 0: continue
            if chosen_diff <= v:
                larger_than_all = False
                break
        if not larger_than_all:
            # try again
            continue

        # Build output by mirroring pixels from the major side across the chosen axis.
        output_grid = [row[:] for row in input_grid]

        def is_source_side(r,c):
            if axis == 'vertical':
                return (c < (width // 2)) if major_side == 'left' else (c >= ((width + 1)//2))
            if axis == 'horizontal':
                return (r < (height // 2)) if major_side == 'top' else (r >= ((height + 1)//2))
            if axis == 'diag_main':
                return (r < c) if major_side == 'above' else (r > c)
            if axis == 'diag_anti':
                return (r + c < (width - 1)) if major_side == 'above' else (r + c > (width - 1))
            return False

        for r in range(height):
            for c in range(width):
                val = input_grid[r][c]
                if val == 0:
                    continue
                if not is_source_side(r,c):
                    continue
                if axis == 'vertical':
                    mr, mc = r, width - 1 - c
                elif axis == 'horizontal':
                    mr, mc = height - 1 - r, c
                elif axis == 'diag_main':
                    mr, mc = c, r
                else:  # diag_anti
                    mr, mc = (width - 1 - c), (height - 1 - r)
                if output_grid[mr][mc] == 0:
                    output_grid[mr][mc] = val

        # Ensure input is not identical to output
        if input_grid == output_grid:
            continue

        return {"input": input_grid, "output": output_grid}

    # if we failed to generate within attempts, fall back to a simple vertical construction
    width = 8
    height = 8
    input_grid = [[0 for _ in range(width)] for _ in range(height)]
    input_grid[2][1] = 2
    input_grid[5][3] = 2
    output_grid = [row[:] for row in input_grid]
    output_grid[2][6] = 2
    output_grid[5][4] = 2
    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # compute imbalances
    left_count = sum(1 for r in range(height) for c in range(width // 2) if grid[r][c] != 0)
    right_count = sum(1 for r in range(height) for c in range((width + 1)//2, width) if grid[r][c] != 0)
    vert_diff = abs(left_count - right_count)

    top_count = sum(1 for c in range(width) for r in range(height // 2) if grid[r][c] != 0)
    bottom_count = sum(1 for c in range(width) for r in range((height + 1)//2, height) if grid[r][c] != 0)
    horiz_diff = abs(top_count - bottom_count)

    diag_main_diff = -1
    diag_anti_diff = -1
    if width == height:
        n = width
        above_main = sum(1 for r in range(n) for c in range(n) if r < c and grid[r][c] != 0)
        below_main = sum(1 for r in range(n) for c in range(n) if r > c and grid[r][c] != 0)
        diag_main_diff = abs(above_main - below_main)
        above_anti = sum(1 for r in range(n) for c in range(n) if r + c < n - 1 and grid[r][c] != 0)
        below_anti = sum(1 for r in range(n) for c in range(n) if r + c > n - 1 and grid[r][c] != 0)
        diag_anti_diff = abs(above_anti - below_anti)

    diffs = {'vertical': vert_diff, 'horizontal': horiz_diff, 'diag_main': diag_main_diff, 'diag_anti': diag_anti_diff}
    # pick axis with the largest imbalance; deterministic tie-break order
    order = ['vertical', 'horizontal', 'diag_main', 'diag_anti']
    axis = max(order, key=lambda k: (diffs[k], -order.index(k)))

    # Determine which side is the populated/source side for the chosen axis
    def source_side(r, c):
        if axis == 'vertical':
            left = left_count
            right = right_count
            return (c < (width // 2)) if left >= right else (c >= ((width + 1)//2))
        if axis == 'horizontal':
            top = top_count
            bottom = bottom_count
            return (r < (height // 2)) if top >= bottom else (r >= ((height + 1)//2))
        if axis == 'diag_main':
            # recompute counts for clarity
            above = sum(1 for rr in range(height) for cc in range(width) if rr < cc and grid[rr][cc] != 0)
            below = sum(1 for rr in range(height) for cc in range(width) if rr > cc and grid[rr][cc] != 0)
            return (r < c) if above >= below else (r > c)
        # diag_anti
        above = sum(1 for rr in range(height) for cc in range(width) if rr + cc < width - 1 and grid[rr][cc] != 0)
        below = sum(1 for rr in range(height) for cc in range(width) if rr + cc > width - 1 and grid[rr][cc] != 0)
        return (r + c < width - 1) if above >= below else (r + c > width - 1)

    output = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            val = grid[r][c]
            if val == 0:
                continue
            if not source_side(r, c):
                continue
            if axis == 'vertical':
                mr, mc = r, width - 1 - c
            elif axis == 'horizontal':
                mr, mc = height - 1 - r, c
            elif axis == 'diag_main':
                mr, mc = c, r
            else:
                mr, mc = (width - 1 - c), (height - 1 - r)
            if output[mr][mc] == 0:
                output[mr][mc] = val
    return output

