# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 45ff636c
Difficulty: insane

=== Tags ===
- Spacing
- Take complement
- Associate colors to bools
- Proximity guessing

=== Description ===
The input grids consist of a 2D grid with a background color (0) and regions of
two distinct colors (e.g., color 1 and color 2) arranged in a pattern with
consistent spacing between regions. The spacing refers to regular intervals
(e.g., every 3 columns or rows) where background color (0) appears, creating a
grid-like structure. The transformation involves three main steps:  1.
**Associate Colors to Booleans**: Color 1 (e.g., red) represents "True" and
color 2 (e.g., blue) represents "False" within the regions. All other colors
(including background) are treated as irrelevant.  2. **Take Complement**:
Within each contiguous region of color 1 or 2 (ignoring background), invert the
color: color 1 becomes color 2, and color 2 becomes color 1.  3. **Proximity
Guessing and Spacing Adjustment**: After complementing, check the proximity of
regions. If two regions of the same color (after inversion) are adjacent
(horizontally, vertically, or diagonally), merge them into a single larger
region by filling the gap between them with the new color. Additionally, adjust
the spacing between merged regions to maintain a consistent interval (e.g.,
ensuring at least one background cell between regions).  For example, if two
color 1 regions (now color 2 after inversion) are separated by a single
background cell, the output will fill that cell with color 2, creating a larger
contiguous region. The spacing adjustment ensures the final output grid
maintains a regular spacing pattern similar to the input but with merged
regions. This task requires recognizing color associations, inverting regions,
and applying proximity-based merging while maintaining spacing constraints,
making it visually complex and challenging to deduce.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid_input = [[0]*width for _ in range(height)]
    
    # Place a 2x2 checkerboard pattern
    grid_input[0][0] = 1
    grid_input[0][1] = 2
    grid_input[1][0] = 2
    grid_input[1][1] = 1
    
    # Add spaced regions of 1 and 2
    spacing = random.randint(2, 5)
    for i in range(2, height, spacing):
        for j in range(2, width, spacing):
            if i+1 < height and j+1 < width:
                grid_input[i][j] = 1
                grid_input[i][j+1] = 2
                grid_input[i+1][j] = 2
                grid_input[i+1][j+1] = 1
    
    # Create output by inverting colors and merging diagonally adjacent regions
    grid_output = [[2 if cell == 1 else 1 if cell == 2 else 0 for cell in row] for row in grid_input]
    
    # Merge diagonally adjacent regions
    h, w = len(grid_output), len(grid_output[0])
    for i in range(h):
        for j in range(w):
            if grid_output[i][j] == 2:
                for di in (-1, 1):
                    for dj in (-1, 1):
                        ni, nj = i+di, j+dj
                        if 0 <= ni < h and 0 <= nj < w and grid_output[ni][nj] == 2:
                            if j+dj < w:
                                grid_output[i][j+dj] = 2
                            if i+di < h:
                                grid_output[i+di][j] = 2
    
    return {
        "input": grid_input,
        "output": grid_output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Step 1: Invert colors 1â†”2
    output = [[2 if x == 1 else 1 if x == 2 else 0 for x in row] for row in input_grid]
    
    # Step 2: Merge diagonally adjacent regions
    h, w = len(output), len(output[0])
    for i in range(h):
        for j in range(w):
            if output[i][j] == 2:
                for di in (-1, 1):
                    for dj in (-1, 1):
                        ni, nj = i + di, j + dj
                        if 0 <= ni < h and 0 <= nj < w and output[ni][nj] == 2:
                            if 0 <= j + dj < w:
                                output[i][j + dj] = 2
                            if 0 <= i + di < h:
                                output[i + di][j] = 2
    return output
