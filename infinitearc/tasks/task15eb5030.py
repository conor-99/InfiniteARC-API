# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 15eb5030
Difficulty: hard

=== Tags ===
- Propagate label
- Sand simulation
- Flood fill region

=== Description ===
# Sand Enclosure Labeling  Input grids are 2D grids with dimensions between 1×1
and 30×30, containing three primary elements: background (color 0), sand (color
1), and obstacles (color 2). Sand cells (color 1) are positioned above obstacles
or background, with no sand cells initially adjacent to the grid's bottom edge.
The transformation to the output grid requires two sequential operations:  1.
**Sand Simulation**: Each sand cell falls vertically downward until it hits an
obstacle (color 2), another sand cell (color 1), or the grid's bottom row. For
each column, sand cells are processed from bottom to top, stacking on top of
obstacles or existing sand piles. The simulation must account for the fact that
sand cells cannot pass through obstacles and will form stable piles when
multiple sand cells occupy the same column.  2. **Enclosed Region Flood Fill**:
After sand settles, identify all background cells (color 0) that are completely
enclosed by sand (color 1) and obstacles (color 2). A cell is enclosed if there
is no path from it to any grid boundary through adjacent background cells (up,
down, left, right) without crossing sand or obstacles. All such enclosed
background regions are filled with a label color (color 3), while all other
background cells remain color 0. The label propagation must fill all enclosed
regions without affecting non-enclosed background or altering settled
sand/obstacles.  The output grid retains the settled sand positions (color 1),
obstacles (color 2), and filled enclosed regions (color 3), while maintaining
all other background cells as color 0. This transformation requires precise
simulation of sand dynamics followed by accurate connectivity analysis to
identify enclosed regions, making it a challenging task that tests multi-step
reasoning and spatial pattern recognition.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque
from common import grid, randint

def sand_simulate(grid):
    height = len(grid)
    width = len(grid[0])
    for c in range(width):
        lowest_obstacle = height
        for r in range(height):
            if grid[r][c] == 2:
                if r < lowest_obstacle:
                    lowest_obstacle = r
        
        if lowest_obstacle < height:
            available_rows = list(range(0, lowest_obstacle))
        else:
            available_rows = list(range(0, height-1))
        
        sand_positions = [r for r in available_rows if grid[r][c] == 1]
        
        new_col = [0] * height
        for r in range(height):
            if grid[r][c] == 2:
                new_col[r] = 2
        
        bg_positions = [r for r in available_rows if new_col[r] == 0]
        bg_positions.sort(reverse=True)
        
        for i in range(min(len(sand_positions), len(bg_positions))):
            r = bg_positions[i]
            new_col[r] = 1
        
        for r in range(height):
            grid[r][c] = new_col[r]

def find_enclosed_regions(grid):
    height = len(grid)
    width = len(grid[0])
    visited = [[False] * width for _ in range(height)]
    queue = deque()
    
    for r in range(height):
        for c in [0, width-1]:
            if grid[r][c] == 0 and not visited[r][c]:
                visited[r][c] = True
                queue.append((r, c))
    for c in range(width):
        for r in [0, height-1]:
            if grid[r][c] == 0 and not visited[r][c]:
                visited[r][c] = True
                queue.append((r, c))
    
    while queue:
        r, c = queue.popleft()
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == 0:
                visited[nr][nc] = True
                queue.append((nr, nc))
    
    enclosed = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 and not visited[r][c]:
                enclosed.append((r, c))
    return enclosed

def generate():
    width = random.randint(5, 20)
    height = random.randint(5, 20)
    input_grid = grid(width, height, 0)
    
    obstacle_count = random.randint(10, 50)
    for _ in range(obstacle_count):
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        input_grid[r][c] = 2
    
    for c in range(width):
        lowest_obstacle = height
        for r in range(height):
            if input_grid[r][c] == 2:
                if r < lowest_obstacle:
                    lowest_obstacle = r
        
        if lowest_obstacle < height:
            max_r = lowest_obstacle - 1
        else:
            max_r = height - 2
        
        # Fix for potential negative max_r
        if max_r < 0:
            num_sand = 0
        else:
            num_sand = random.randint(0, max_r)
        
        sand_rows = random.sample(range(0, max_r+1), num_sand) if num_sand > 0 else []
        for r in sand_rows:
            input_grid[r][c] = 1
    
    output_grid = [row[:] for row in input_grid]
    sand_simulate(output_grid)
    enclosed = find_enclosed_regions(output_grid)
    for (r, c) in enclosed:
        output_grid[r][c] = 3
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    for c in range(width):
        lowest_obstacle = height
        for r in range(height):
            if grid[r][c] == 2:
                if r < lowest_obstacle:
                    lowest_obstacle = r
        
        if lowest_obstacle < height:
            available_rows = list(range(0, lowest_obstacle))
        else:
            available_rows = list(range(0, height-1))
        
        sand_positions = [r for r in available_rows if grid[r][c] == 1]
        
        new_col = [0] * height
        for r in range(height):
            if grid[r][c] == 2:
                new_col[r] = 2
        
        bg_positions = [r for r in available_rows if new_col[r] == 0]
        bg_positions.sort(reverse=True)
        
        for i in range(min(len(sand_positions), len(bg_positions))):
            r = bg_positions[i]
            new_col[r] = 1
        
        for r in range(height):
            grid[r][c] = new_col[r]
    
    visited = [[False] * width for _ in range(height)]
    queue = deque()
    
    for r in range(height):
        for c in [0, width-1]:
            if grid[r][c] == 0 and not visited[r][c]:
                visited[r][c] = True
                queue.append((r, c))
    for c in range(width):
        for r in [0, height-1]:
            if grid[r][c] == 0 and not visited[r][c]:
                visited[r][c] = True
                queue.append((r, c))
    
    while queue:
        r, c = queue.popleft()
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == 0:
                visited[nr][nc] = True
                queue.append((nr, nc))
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 and not visited[r][c]:
                grid[r][c] = 3
    
    return grid
