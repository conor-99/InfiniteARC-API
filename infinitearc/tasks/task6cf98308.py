# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 6cf98308
Difficulty: insane

=== Tags ===
- Multi condition recolor

=== Description ===
Input grids are 20×20 with a single background color (0), overlaid with multiple
disconnected colored regions (1-9) forming distinct shapes (squares, L-shapes,
lines) that do not touch each other. Each region is a connected component of
uniform color with minimum size 3×3. The output grid applies a multi-condition
recoloring rule where each cell's new color depends on simultaneous conditions
involving its own color, the colors of its four orthogonal neighbors, and the
presence of specific color patterns within a 3×3 neighborhood.   The
transformation follows these layered conditions in priority order: 1. If a
cell's color matches A, its top neighbor is B, right neighbor is C, and the cell
diagonally down-left is D, recolor to E. 2. If a cell's color is A and its 3×3
neighborhood contains exactly two distinct colors (B and C) in a cross pattern,
recolor to F. 3. If a cell's color is A and it has exactly three neighbors of
color B in a T-shape configuration, recolor to G.  These conditions are
consistent across all grids but require identifying the specific color mappings
(A, B, C, D, E, F, G) through pattern recognition. The background (0) remains
unchanged, and no cell's recoloring depends solely on its position. The output
grid must reflect all applicable conditions applied in priority order, with no
cell remaining unchanged if any condition matches.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Mapping constants for the task (kept consistent between generator and solver)
A, B, C, D, E, F, G = 1, 2, 3, 4, 5, 6, 7

HEIGHT = 20
WIDTH = 20


def _apply_rules(inp):
    # Apply the three priority-ordered recoloring rules to produce the output grid.
    h = len(inp)
    w = len(inp[0])
    out = [row[:] for row in inp]

    for r in range(h):
        for c in range(w):
            if inp[r][c] != A:
                continue
            # Condition 1: top == B, right == C, down-left == D -> E
            top = inp[r-1][c] if r-1 >= 0 else None
            right = inp[r][c+1] if c+1 < w else None
            down_left = inp[r+1][c-1] if r+1 < h and c-1 >= 0 else None
            if top == B and right == C and down_left == D:
                out[r][c] = E
                continue

            # Condition 2: 3x3 neighborhood (the eight neighbors) contains exactly two colors B and C
            # arranged as a cross: top & bottom == B and left & right == C
            if r-1 >= 0 and r+1 < h and c-1 >= 0 and c+1 < w:
                neigh = []
                for dr in (-1, 0, 1):
                    for dc in (-1, 0, 1):
                        if dr == 0 and dc == 0:
                            continue
                        neigh.append(inp[r+dr][c+dc])
                neigh_set = set(neigh)
                if neigh_set == {B, C} and inp[r-1][c] == B and inp[r+1][c] == B and inp[r][c-1] == C and inp[r][c+1] == C:
                    out[r][c] = F
                    continue

            # Condition 3: exactly three orthogonal neighbors equal B (a T-shape)
            orth = [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]
            b_count = 0
            for (rr, cc) in orth:
                if 0 <= rr < h and 0 <= cc < w and inp[rr][cc] == B:
                    b_count += 1
            if b_count == 3:
                out[r][c] = G
                continue

    return out


def generate():
    # Create empty background
    grid_in = grid(WIDTH, HEIGHT, 0)
    occupied = set()

    def free(coords):
        for (rr, cc) in coords:
            if not (0 <= rr < HEIGHT and 0 <= cc < WIDTH):
                return False
            if (rr, cc) in occupied:
                return False
        return True

    def mark(coords):
        for (rr, cc) in coords:
            occupied.add((rr, cc))

    # Place a few random decorative rectangles to add variety
    for _ in range(random.randint(6, 12)):
        rw = random.randint(3, 6)
        rh = random.randint(3, 6)
        tr = random.randint(0, HEIGHT - rh)
        tc = random.randint(0, WIDTH - rw)
        color = random.randint(1, 9)
        for rr in range(tr, tr + rh):
            for cc in range(tc, tc + rw):
                grid_in[rr][cc] = color
                occupied.add((rr, cc))

    # Helper to attempt to place a condition-1 pattern
    def place_cond1():
        for _ in range(200):
            r = random.randint(1, HEIGHT - 2)
            c = random.randint(1, WIDTH - 2)
            coords = [(r, c), (r-1, c), (r, c+1), (r+1, c-1)]
            if not free(coords):
                continue
            # set the pattern (may overwrite background but not other placed patterns)
            grid_in[r][c] = A
            grid_in[r-1][c] = B
            grid_in[r][c+1] = C
            grid_in[r+1][c-1] = D
            mark(coords)
            return True
        return False

    # Helper to attempt to place a condition-2 pattern (cross of B/C around A)
    def place_cond2():
        for _ in range(200):
            r = random.randint(1, HEIGHT - 2)
            c = random.randint(1, WIDTH - 2)
            coords = [(r+dr, c+dc) for dr in (-1, 0, 1) for dc in (-1, 0, 1)]
            if not free(coords):
                continue
            # center
            grid_in[r][c] = A
            # vertical neighbors B
            grid_in[r-1][c] = B
            grid_in[r+1][c] = B
            # horizontal neighbors C
            grid_in[r][c-1] = C
            grid_in[r][c+1] = C
            # corners assigned so the 3x3 neighborhood contains only B and C
            grid_in[r-1][c-1] = B
            grid_in[r-1][c+1] = C
            grid_in[r+1][c-1] = C
            grid_in[r+1][c+1] = B
            mark(coords)
            return True
        return False

    # Helper to attempt to place a condition-3 pattern (T-shape of B around A)
    def place_cond3():
        for _ in range(200):
            r = random.randint(1, HEIGHT - 2)
            c = random.randint(1, WIDTH - 2)
            orientation = random.choice([0, 1, 2, 3])  # 0 miss top, 1 miss bottom, 2 miss left, 3 miss right
            if orientation == 0:
                coords = [(r, c), (r, c-1), (r, c+1), (r+1, c)]
            elif orientation == 1:
                coords = [(r, c), (r, c-1), (r, c+1), (r-1, c)]
            elif orientation == 2:
                coords = [(r, c), (r-1, c), (r+1, c), (r, c+1)]
            else:
                coords = [(r, c), (r-1, c), (r+1, c), (r, c-1)]
            if not free(coords):
                continue
            grid_in[r][c] = A
            for (rr, cc) in coords:
                if (rr, cc) == (r, c):
                    continue
                grid_in[rr][cc] = B
            mark(coords)
            return True
        return False

    # Place at least one of each pattern type and sometimes more for variety
    place_cond1()
    place_cond2()
    place_cond3()
    for _ in range(random.randint(0, 2)):
        place_cond1()
    for _ in range(random.randint(0, 2)):
        place_cond2()
    for _ in range(random.randint(0, 2)):
        place_cond3()

    # Add some additional scattered colored pixels to increase variety (but don't overwrite patterns)
    for rr in range(HEIGHT):
        for cc in range(WIDTH):
            if (rr, cc) in occupied:
                continue
            # keep background mostly zeros
            if random.random() < 0.12:
                grid_in[rr][cc] = random.randint(1, 9)

    # Compute the output by applying the rules deterministically
    output_grid = _apply_rules(grid_in)

    # Guarantee that at least one cell changed (if not, force one change)
    changed = any(grid_in[r][c] != output_grid[r][c] for r in range(HEIGHT) for c in range(WIDTH))
    if not changed:
        # force a small pattern to ensure a change
        r = 5
        c = 5
        grid_in[r][c] = A
        grid_in[r-1][c] = B
        grid_in[r][c+1] = C
        grid_in[r+1][c-1] = D
        output_grid = _apply_rules(grid_in)

    return {
        "input": grid_in,
        "output": output_grid
    }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid_in = [list(row) for row in input_grid]
    h = len(grid_in)
    w = len(grid_in[0])

    # Same fixed mapping as the generator
    A, B, C, D, E, F, G = 1, 2, 3, 4, 5, 6, 7

    # Prepare output as a copy of the input
    out = [row[:] for row in grid_in]

    for r in range(h):
        for c in range(w):
            if grid_in[r][c] != A:
                continue
            # Condition 1
            top = grid_in[r-1][c] if r-1 >= 0 else None
            right = grid_in[r][c+1] if c+1 < w else None
            down_left = grid_in[r+1][c-1] if r+1 < h and c-1 >= 0 else None
            if top == B and right == C and down_left == D:
                out[r][c] = E
                continue

            # Condition 2: 3x3 neighborhood has exactly two colors B and C in a cross
            if r-1 >= 0 and r+1 < h and c-1 >= 0 and c+1 < w:
                neigh = []
                for dr in (-1, 0, 1):
                    for dc in (-1, 0, 1):
                        if dr == 0 and dc == 0:
                            continue
                        neigh.append(grid_in[r+dr][c+dc])
                neigh_set = set(neigh)
                if neigh_set == {B, C} and grid_in[r-1][c] == B and grid_in[r+1][c] == B and grid_in[r][c-1] == C and grid_in[r][c+1] == C:
                    out[r][c] = F
                    continue

            # Condition 3: exactly three orthogonal neighbors are B (T-shape)
            orth = [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]
            b_count = 0
            for (rr, cc) in orth:
                if 0 <= rr < h and 0 <= cc < w and grid_in[rr][cc] == B:
                    b_count += 1
            if b_count == 3:
                out[r][c] = G
                continue

    return out

