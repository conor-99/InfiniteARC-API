# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 886566b7
Difficulty: hard

=== Tags ===
- Flow with decay
- Two color checkerboard
- Mark centroid

=== Description ===
Input grids feature a two-color checkerboard pattern (e.g., alternating red and
blue cells) with a single yellow cell marking the geometric center (centroid).
All red cells represent a "flow" that decays in color as it moves toward the
centroid. The output grid transforms each red cell into a new color based on its
Manhattan distance to the yellow centroid, following a visual decay sequence
(red → orange → yellow → green → blue), where distance 1 corresponds to orange,
distance 2 to yellow, distance 3 to green, and distance 4 to blue. Blue cells
and the yellow centroid remain unchanged. The transformation requires
identifying the centroid marker, recognizing the flow color within the
checkerboard pattern, computing cell distances, and applying the perceptual
color sequence—challenging due to the need for multi-step spatial reasoning and
visual pattern recognition without relying on numerical values.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    width = common.randint(3, 30)
    height = common.randint(3, 30)
    if width % 2 == 0: width -= 1
    if height % 2 == 0: height -= 1
    colors = list(range(1, 10))
    colors.remove(4)
    flow_color, base_color = common.sample(colors, 2)
    cx = (width - 1) // 2
    cy = (height - 1) // 2
    input_grid = common.grid(width, height, base_color)
    for r in range(height):
        for c in range(width):
            if (r + c) % 2 == 0:
                input_grid[r][c] = flow_color
    input_grid[cy][cx] = 4  # Corrected: use (cy, cx) instead of (cx, cy)
    output_grid = common.grid(width, height, base_color)
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 4:
                output_grid[r][c] = 4
            elif input_grid[r][c] == flow_color:
                dist = abs(r - cy) + abs(c - cx)
                if dist == 1:
                    output_grid[r][c] = 5
                elif dist == 2:
                    output_grid[r][c] = 4
                elif dist == 3:
                    output_grid[r][c] = 3
                else:
                    output_grid[r][c] = 1
            else:
                output_grid[r][c] = input_grid[r][c]
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    cx, cy = -1, -1
    for r in range(len(input_list)):
        for c in range(len(input_list[0])):
            if input_list[r][c] == 4:
                cx, cy = c, r  # Store column, row
    if cx == -1:
        cx, cy = len(input_list[0]) // 2, len(input_list) // 2
    flow_color = input_list[0][0]
    output_list = [row[:] for row in input_list]
    for r in range(len(input_list)):
        for c in range(len(input_list[0])):
            if input_list[r][c] == 4:
                output_list[r][c] = 4
            elif input_list[r][c] == flow_color:
                dist = abs(r - cy) + abs(c - cx)
                if dist == 1:
                    output_list[r][c] = 5
                elif dist == 2:
                    output_list[r][c] = 4
                elif dist == 3:
                    output_list[r][c] = 3
                else:
                    output_list[r][c] = 1
    return tuple(tuple(row) for row in output_list)
