# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 47ed3668
Difficulty: easy

=== Tags ===
- Image expansion
- Image reflection
- Find and double the smallest object
- Color matching

=== Description ===
The input grid contains multiple colored objects (connected regions of the same
color). The output grid is created by first reflecting the input horizontally
(left-right flip), then identifying the smallest object (by area) in the input
grid. If multiple objects share the smallest size, the one with the lowest color
value (0-9) is selected. In the reflected grid, a single cell of the same color
is added immediately to the right of the smallest object's position, doubling
its size. This transformation ensures the smallest object becomes two adjacent
cells while maintaining the horizontal reflection of the entire grid. The task
requires recognizing the smallest object, applying reflection, and performing a
simple adjacency-based expansion without altering other grid elements.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(2, 30)
    height = random.randint(1, 30)
    input_grid = grid(width, height, 0)
    r = random.randint(0, height-1)
    c = random.randint(1, width-1)
    input_grid[r][c] = 1
    reflected = [row[::-1] for row in input_grid]
    new_col = width - c
    reflected[r][new_col] = 1
    return {
        "input": input_grid,
        "output": reflected
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    visited = [[False] * width for _ in range(height)]
    regions = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] > 0 and not visited[r][c]:
                color = input_grid[r][c]
                queue = [(r, c)]
                visited[r][c] = True
                cells = []
                while queue:
                    cr, cc = queue.pop(0)
                    cells.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                regions.append((color, len(cells), cells))
    regions.sort(key=lambda x: (x[1], x[0]))
    _, _, cells = regions[0]
    r, c = cells[0]
    reflected = []
    for row in input_grid:
        reflected.append(list(row)[::-1])
    new_col = width - c
    if new_col < width:
        reflected[r][new_col] = regions[0][0]
    return reflected
