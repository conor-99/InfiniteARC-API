# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 09f617e5
Difficulty: hard

=== Tags ===
- Detect enclosure
- Pattern differences

=== Description ===
The input grid consists of a 2D arrangement of colors (0-9), where non-zero
regions may form enclosed areas completely surrounded by other non-zero regions.
The output grid is generated by identifying all enclosed regions (cells not
connected to the grid's perimeter via a path of non-zero cells) and replacing
them with color 9, while preserving all other regions and boundary colors. This
requires detecting enclosed areas through connectivity analysis rather than
visual pattern matching, as the enclosing boundaries can vary in color, shape,
and position. The task demands that the solver distinguish enclosed regions from
connected exterior regions using a flood-fill-like reasoning process, making it
challenging due to the need for topological analysis rather than simple pattern
recognition.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid_in = [[0] * width for _ in range(height)]
    
    region_w = random.randint(2, 3)
    region_h = random.randint(2, 3)
    
    max_r = height - 1 - region_h
    max_c = width - 1 - region_w
    r = random.randint(1, max_r)
    c = random.randint(1, max_c)
    
    color = random.randint(1, 8)
    for i in range(region_h):
        for j in range(region_w):
            grid_in[r + i][c + j] = color
    
    grid_out = [row[:] for row in grid_in]
    for i in range(region_h):
        for j in range(region_w):
            grid_out[r + i][c + j] = 9
    
    return {"input": grid_in, "output": grid_out}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    if not input_grid:
        return input_grid
    height = len(input_grid)
    width = len(input_grid[0])
    visited = [[False] * width for _ in range(height)]
    output_grid = [row[:] for row in input_grid]
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                queue = [(r, c)]
                visited[r][c] = True
                component = []
                is_connected = False
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    if cr == 0 or cr == height-1 or cc == 0 or cc == width-1:
                        is_connected = True
                    for dr, dc in directions:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                if not is_connected:
                    for cr, cc in component:
                        output_grid[cr][cc] = 9
    return output_grid
