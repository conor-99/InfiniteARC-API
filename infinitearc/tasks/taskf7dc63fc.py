# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: f7dc63fc
Difficulty: easy

=== Tags ===
- Associate images to colors
- Snap to grid

=== Description ===
The input grid contains a single connected region of non-zero pixels (the
"image"), where connectivity is defined by edge adjacency (up, down, left,
right). The output grid is formed by translating the image so that its top-
leftmost pixel is positioned at the top-left corner (0,0) of the grid, while
maintaining the same shape and size. All other pixels remain zero. This
transformation "snaps" the image to the grid's top-left alignment, associating
its position with the grid structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    import common
    w = random.randint(3, 30)
    h = random.randint(3, 30)
    sub_w, sub_h = 3, 3
    size = random.randint(2, 9)
    region = common.continuous_creature(size, sub_w, sub_h)
    max_r = h - sub_h
    max_c = w - sub_w
    r_offset = random.randint(0, max_r)
    c_offset = random.randint(0, max_c)
    while r_offset == 0 and c_offset == 0:
        r_offset = random.randint(0, max_r)
        c_offset = random.randint(0, max_c)
    input_grid = common.grid(w, h, 0)
    color = common.random_color()
    for (r_sub, c_sub) in region:
        r = r_offset + r_sub
        c = c_offset + c_sub
        if r < h and c < w:
            input_grid[r][c] = color
    min_row = r_offset
    min_col = c_offset
    output_grid = common.grid(w, h, 0)
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] != 0:
                r_out = r - min_row
                c_out = c - min_col
                if 0 <= r_out < h and 0 <= c_out < w:
                    output_grid[r_out][c_out] = input_grid[r][c]
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    import common
    non_zero = []
    rows = len(input_grid)
    cols = len(input_grid[0])
    for r in range(rows):
        for c in range(cols):
            if input_grid[r][c] != 0:
                non_zero.append((r, c))
    if not non_zero:
        return input_grid
    min_row = min(r for r, c in non_zero)
    min_col = min(c for r, c in non_zero)
    output_grid = common.grid(cols, rows, 0)
    for (r, c) in non_zero:
        r_out = r - min_row
        c_out = c - min_col
        output_grid[r_out][c_out] = input_grid[r][c]
    return output_grid
