# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 8db1f945
Difficulty: hard

=== Tags ===
- Pattern deconstruction
- Teleporter network routing
- Symmetry completion
- Compare image

=== Description ===
The input grid features a complex, asymmetric pattern composed of multiple
distinct colors, alongside a connected network of teleporter nodes (specific
colors forming a continuous path). The teleporter network's structural
orientation—such as vertical, horizontal, or diagonal alignment—defines the
symmetry axis for the transformation. The output grid is generated by mirroring
every non-teleporter element of the main pattern across this axis, resulting in
a fully symmetrical configuration. The teleporter network itself remains
unchanged in position but serves solely as the axis-determining structure. To
complete the task, the solver must first identify the teleporter network's
connectivity and primary direction, then apply the corresponding mirror
transformation to all elements outside the network, ensuring the output grid
reflects a balanced, symmetrical arrangement that aligns with the axis derived
from the teleporter path. This requires simultaneous pattern decomposition, axis
identification via network routing, and precise symmetry completion, making the
task challenging due to the interplay of multiple layered rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(5, 15)
    height = random.randint(5, 15)
    input_grid = grid(width, height, 0)
    axis_type = random.choice(['horizontal', 'vertical'])
    if axis_type == 'horizontal':
        r = random.randint(1, height - 2)
        for c in range(width):
            input_grid[r][c] = 1
        for i in range(r):
            for c in range(width):
                input_grid[i][c] = random.randint(2, 5)
        for i in range(r + 1, height):
            for c in range(width):
                input_grid[i][c] = random.randint(6, 9)
    else:
        c = random.randint(1, width - 2)
        for i in range(height):
            input_grid[i][c] = 1
        for i in range(height):
            for j in range(c):
                input_grid[i][j] = random.randint(2, 5)
        for i in range(height):
            for j in range(c + 1, width):
                input_grid[i][j] = random.randint(6, 9)
    output = grid(width, height, 0)
    if axis_type == 'horizontal':
        for i in range(height):
            mirror_i = 2 * r - i
            if 0 <= mirror_i < height:
                for j in range(width):
                    output[i][j] = input_grid[mirror_i][j]
    else:
        for j in range(width):
            mirror_j = 2 * c - j
            if 0 <= mirror_j < width:
                for i in range(height):
                    output[i][j] = input_grid[i][mirror_j]
    return {'input': input_grid, 'output': output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    for r in range(height):
        if all(cell == 1 for cell in input_grid[r]):
            output = grid(width, height, 0)
            for i in range(height):
                mirror_i = 2 * r - i
                if 0 <= mirror_i < height:
                    for j in range(width):
                        output[i][j] = input_grid[mirror_i][j]
            return output
    for c in range(width):
        if all(input_grid[i][c] == 1 for i in range(height)):
            output = grid(width, height, 0)
            for j in range(width):
                mirror_j = 2 * c - j
                if 0 <= mirror_j < width:
                    for i in range(height):
                        output[i][j] = input_grid[i][mirror_j]
            return output
    return input_grid
