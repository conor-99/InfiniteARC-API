# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 573fb296
Difficulty: hard

=== Tags ===
- Progressive rule shift
- Infer hidden grid
- Grid coloring

=== Description ===
# Progressive Color Shift Grid  Input grids consist of a uniform background
color (0) overlaid with multiple distinct contiguous colored regions (1-9), each
region being a single connected component of identical color with no two regions
of the same color touching. Regions must be separated by at least one background
cell (0) and cannot overlap. The grid dimensions range from 15×15 to 30×30, with
regions occupying approximately 10-40% of the grid area.  The output grid is
generated through the following multi-stage transformation:  1. **Infer the
hidden grid**: Divide the input grid into a 3×3 grid of equal-sized quadrants.
For each quadrant, identify the largest connected region (measured by cell
count) and record its color. If a quadrant contains no regions, its value is 0.
This 3×3 grid constitutes the hidden grid.  2. **Apply progressive rule shift**:
For each colored region in the input, determine which quadrant it occupies. The
region's color is then transformed by shifting it cyclically through the color
sequence (1→2→3→...→9→1) by the value of the corresponding hidden grid cell. For
example, a region of color 5 in a quadrant with hidden value 3 becomes color 8
(5+3=8). If the hidden grid cell is 0, the region's color remains unchanged.  3.
**Reconstruct output grid**: All background cells remain color 0. Each region's
cells are recolored according to the progressive shift calculation, while
maintaining the original shape and connectivity of the region. The
transformation must be applied consistently across all regions without altering
their spatial arrangement or relative positions.  The task requires the solver
to simultaneously identify connected regions, partition the grid into quadrants,
infer the hidden grid from region properties, and apply the cyclic color
transformation based on the inferred values. No two regions share the same
color, and the hidden grid's values must be derived solely from the input's
structural properties without external information. The output grid will always
differ from the input due to the color transformation, and the solution requires
sequential reasoning through multiple abstract operations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_pixels, connected

def generate():
    sizes = [15, 18, 21, 24, 27, 30]
    S = random.choice(sizes)
    quadrant_size = S // 3
    input_grid = grid(S, S, 0)
    num_regions = 3
    colors = random.sample(range(1, 10), num_regions)
    for color in colors:
        total_area = S * S
        min_cells = int(0.1 * total_area / num_regions)
        max_cells = int(0.4 * total_area / num_regions)
        size = random.randint(min_cells, max_cells)
        region_pixels = []
        while len(region_pixels) < size:
            new_pixels = random_pixels(S, S, 0.05)
            region_pixels = list(set(region_pixels + new_pixels))
            if len(region_pixels) > size:
                region_pixels = region_pixels[:size]
            if connected(region_pixels):
                break
        for r, c in region_pixels:
            input_grid[r][c] = color
    hidden = [[0]*3 for _ in range(3)]
    for i in range(3):
        for j in range(3):
            start_r, start_c = i * quadrant_size, j * quadrant_size
            visited = [[False] * quadrant_size for _ in range(quadrant_size)]
            max_size = 0
            max_color = 0
            for r in range(quadrant_size):
                for c in range(quadrant_size):
                    local_r = start_r + r
                    local_c = start_c + c
                    if input_grid[local_r][local_c] != 0 and not visited[r][c]:
                        color_val = input_grid[local_r][local_c]
                        queue = [(r, c)]
                        visited[r][c] = True
                        component = []
                        while queue:
                            cr, cc = queue.pop(0)
                            component.append((cr, cc))
                            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                                nr, nc = cr + dr, cc + dc
                                if 0 <= nr < quadrant_size and 0 <= nc < quadrant_size:
                                    nr_global = start_r + nr
                                    nc_global = start_c + nc
                                    if input_grid[nr_global][nc_global] == color_val and not visited[nr][nc]:
                                        visited[nr][nc] = True
                                        queue.append((nr, nc))
                        if len(component) > max_size:
                            max_size = len(component)
                            max_color = color_val
            hidden[i][j] = max_color
    output_grid = grid(S, S, 0)
    for r in range(S):
        for c in range(S):
            if input_grid[r][c] != 0:
                i = r // quadrant_size
                j = c // quadrant_size
                new_color = (input_grid[r][c] + hidden[i][j] - 1) % 9 + 1
                output_grid[r][c] = new_color
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    S = len(input_list)
    quadrant_size = S // 3
    hidden = [[0] * 3 for _ in range(3)]
    for i in range(3):
        for j in range(3):
            start_r, start_c = i * quadrant_size, j * quadrant_size
            visited = [[False] * quadrant_size for _ in range(quadrant_size)]
            max_size = 0
            max_color = 0
            for r in range(quadrant_size):
                for c in range(quadrant_size):
                    local_r = start_r + r
                    local_c = start_c + c
                    if input_list[local_r][local_c] != 0 and not visited[r][c]:
                        color_val = input_list[local_r][local_c]
                        queue = [(r, c)]
                        visited[r][c] = True
                        component = []
                        while queue:
                            cr, cc = queue.pop(0)
                            component.append((cr, cc))
                            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                                nr, nc = cr + dr, cc + dc
                                if 0 <= nr < quadrant_size and 0 <= nc < quadrant_size:
                                    nr_global = start_r + nr
                                    nc_global = start_c + nc
                                    if input_list[nr_global][nc_global] == color_val and not visited[nr][nc]:
                                        visited[nr][nc] = True
                                        queue.append((nr, nc))
                        if len(component) > max_size:
                            max_size = len(component)
                            max_color = color_val
            hidden[i][j] = max_color
    output = [[0] * S for _ in range(S)]
    for r in range(S):
        for c in range(S):
            if input_list[r][c] != 0:
                i = r // quadrant_size
                j = c // quadrant_size
                new_color = (input_list[r][c] + hidden[i][j] - 1) % 9 + 1
                output[r][c] = new_color
    return output
