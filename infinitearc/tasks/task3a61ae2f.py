# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 3a61ae2f
Difficulty: medium–hard

=== Tags ===
- Color transfer on contact
- Rule propagation
- Associate patterns to patterns
- Homeomorphism

=== Description ===
# Pattern-Driven Color Propagation  Input grids consist of multiple
disconnected, non-overlapping regions (each region is a connected component of a
single non-zero color, surrounded by background color 0). Each region has a
unique geometric pattern defined by the arrangement of its cells, such as
horizontal lines, vertical lines, corners, or crosses. These patterns are small
(2×2 to 5×5 in size) and distinguishable by their shape regardless of
orientation or position in the grid.  The transformation applies the following
rules in sequence:  1. **Color Transfer on Contact**: For each region, if it is
orthogonally adjacent to a region of a different color, the primary color of the
first region is transferred to the boundary cells of the adjacent region. The
direction of transfer is determined by the pattern type of the *adjacent*
region:    - A *horizontal line* pattern (cells aligned left-right) transfers
color to the left.    - A *vertical line* pattern transfers color upward.    - A
*corner* pattern (cells forming a right angle) transfers color in the corner's
direction (e.g., top-left corner transfers to top and left).    - A *cross*
pattern transfers color in all four directions.  2. **Rule Propagation**: Once a
cell receives a transferred color, it propagates that color to adjacent cells in
the direction specified by the pattern association, continuing until it reaches
the boundary of the region or can no longer propagate (e.g., due to background
cells or conflicting color transfers).  3. **Pattern Association**: Each pattern
type (horizontal line, vertical line, corner, cross) is associated with a fixed
propagation direction. The output grid must correctly apply these associations
to all regions, ensuring that the transfer direction matches the pattern's
inherent geometry.  The output grid preserves all original background cells and
regions, with only the boundary cells of regions affected by color transfers.
Regions not involved in transfers remain unchanged. No two regions may overlap,
and all transfers must respect the directional constraints of the pattern
associations. The transformation is applied to all regions in parallel, with
propagation continuing until no further changes can occur. The task requires
recognizing pattern types, associating them with directional rules, and applying
propagation in a deterministic, consistent manner.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

# Generator for ARC task: Pattern-Driven Color Propagation
# Produces an input grid with four small regions (horizontal, vertical, corner, cross)
# placed around the center so directional transfers occur. Then computes the
# output by applying the same deterministic propagation rules used in the solver.


def _find_components(g):
    h, w = len(g), len(g[0])
    visited = [[False] * w for _ in range(h)]
    comp_id = [[-1] * w for _ in range(h)]
    comps = []
    cid = 0
    for r in range(h):
        for c in range(w):
            if g[r][c] == 0 or visited[r][c]:
                continue
            color = g[r][c]
            stack = [(r, c)]
            visited[r][c] = True
            cells = []
            while stack:
                rr, cc = stack.pop()
                cells.append((rr, cc))
                comp_id[rr][cc] = cid
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and g[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            comps.append({'id': cid, 'cells': cells, 'color': color})
            cid += 1
    return comp_id, comps


def _pattern_and_dirs(comp):
    # Returns (pattern_name, extra) where extra encodes orientation for corners,
    # and a list of outgoing direction vectors according to our rule set.
    cells = comp['cells']
    cellset = set(cells)
    rows = [r for r, c in cells]
    cols = [c for r, c in cells]
    rmin, rmax = min(rows), max(rows)
    cmin, cmax = min(cols), max(cols)

    # Horizontal: all in same row (length >= 2)
    if len(set(rows)) == 1 and len(cells) >= 2:
        return 'horizontal', [(0, -1)]  # transfers left
    # Vertical: all in same column (length >= 2)
    if len(set(cols)) == 1 and len(cells) >= 2:
        return 'vertical', [(-1, 0)]  # transfers up
    # Cross: center with four orthogonal neighbors
    if len(cells) == 5:
        for (r, c) in cells:
            if ((r - 1, c) in cellset and (r + 1, c) in cellset and
                    (r, c - 1) in cellset and (r, c + 1) in cellset):
                return 'cross', [(-1, 0), (1, 0), (0, -1), (0, 1)]
    # Corner: three cells in a 2x2 box (one missing)
    if len(cells) == 3 and (rmax - rmin == 1) and (cmax - cmin == 1):
        # Find the missing cell in the 2x2 box and map to propagation dirs.
        all2x2 = [(rmin, cmin), (rmin, cmin + 1), (rmin + 1, cmin), (rmin + 1, cmin + 1)]
        missing = None
        for p in all2x2:
            if p not in cellset:
                missing = p
                break
        # If missing is bottom-right -> propagate up & left
        if missing == (rmin + 1, cmin + 1):
            return 'corner-br-missing', [(-1, 0), (0, -1)]
        # missing bottom-left -> propagate up & right
        if missing == (rmin + 1, cmin):
            return 'corner-bl-missing', [(-1, 0), (0, 1)]
        # missing top-right -> propagate down & left
        if missing == (rmin, cmin + 1):
            return 'corner-tr-missing', [(1, 0), (0, -1)]
        # missing top-left -> propagate down & right
        if missing == (rmin, cmin):
            return 'corner-tl-missing', [(1, 0), (0, 1)]
    return 'unknown', []


def _apply_propagation(ingrid):
    # Implementation of the same propagation algorithm used in the solver.
    h, w = len(ingrid), len(ingrid[0])
    comp_id, comps = _find_components(ingrid)
    id_to_comp = {c['id']: c for c in comps}
    # Determine outgoing dirs for each component
    comp_dirs = {}
    for c in comps:
        _, dirs = _pattern_and_dirs(c)
        comp_dirs[c['id']] = dirs

    out = [row[:] for row in ingrid]
    # For each source component, propagate its color along its outgoing directions
    for src in comps:
        s_id = src['id']
        s_color = src['color']
        dirs = comp_dirs.get(s_id, [])
        if not dirs:
            continue
        for (sr, sc) in src['cells']:
            for (dr, dc) in dirs:
                nr, nc = sr + dr, sc + dc
                # Must be orthogonally adjacent to a different non-zero region
                if 0 <= nr < h and 0 <= nc < w and ingrid[nr][nc] != 0 and comp_id[nr][nc] != s_id:
                    target_id = comp_id[nr][nc]
                    # Paint the immediate adjacent cell
                    out[nr][nc] = s_color
                    # Continue propagating inside the target region along the same vector
                    pr, pc = nr + dr, nc + dc
                    while 0 <= pr < h and 0 <= pc < w and ingrid[pr][pc] != 0 and comp_id[pr][pc] == target_id:
                        out[pr][pc] = s_color
                        pr += dr
                        pc += dc
    return out


def generate():
    # Ensure grid is big enough for the canonical layout
    size = random.randint(7, 15)
    g = [[0 for _ in range(size)] for _ in range(size)]

    # Choose four distinct colors for the four regions
    colors = random.sample(range(1, 10), 4)
    cross_col, hor_col, ver_col, corner_col = colors

    mid = size // 2

    # Place a cross at the center (5-cell cross)
    cross_cells = [(mid, mid), (mid-1, mid), (mid+1, mid), (mid, mid-1), (mid, mid+1)]
    for (r, c) in cross_cells:
        g[r][c] = cross_col

    # Place a horizontal line to the right, adjacent to the cross's right arm
    max_h_len = max(2, min(4, size - (mid + 2)))
    h_len = random.randint(2, max_h_len)
    h_start = mid + 2
    for c in range(h_start, h_start + h_len):
        g[mid][c] = hor_col

    # Place a vertical line below, adjacent to the cross's bottom arm
    max_v_len = max(2, min(4, size - (mid + 2)))
    v_len = random.randint(2, max_v_len)
    v_start = mid + 2
    for r in range(v_start, v_start + v_len):
        g[r][mid] = ver_col

    # Place a corner to the left of the cross. Choose missing corner orientation that includes a
    # rightward propagation so it will affect the cross.
    # bounding box top-left for the corner
    crow = mid - 1
    ccol = mid - 3
    orientation = random.choice(['missing_tl', 'missing_bl'])
    if orientation == 'missing_tl':
        # missing top-left -> present: (crow, ccol+1), (crow+1, ccol), (crow+1, ccol+1)
        pts = [(crow, ccol + 1), (crow + 1, ccol), (crow + 1, ccol + 1)]
    else:
        # missing bottom-left -> present: (crow, ccol), (crow, ccol+1), (crow+1, ccol+1)
        pts = [(crow, ccol), (crow, ccol + 1), (crow + 1, ccol + 1)]
    for (r, c) in pts:
        # Safety check for bounds in unexpected small sizes
        if 0 <= r < size and 0 <= c < size:
            g[r][c] = corner_col

    out = _apply_propagation(g)

    # Safety: ensure input != output (there should be at least one transfer); if not, tweak
    # by making horizontal longer by 1 (if possible) and recomputing.
    if out == g:
        # try to force a contact by extending the horizontal region if possible
        extra_col = h_start + h_len
        if extra_col < size:
            g[mid][extra_col] = hor_col
        out = _apply_propagation(g)

    return {'input': g, 'output': out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Solver implementing the propagation rules described in the generator.
    grid = [list(row) for row in input_grid]
    h, w = len(grid), len(grid[0])

    def find_components(g):
        visited = [[False] * w for _ in range(h)]
        comp_id = [[-1] * w for _ in range(h)]
        comps = []
        cid = 0
        for r in range(h):
            for c in range(w):
                if g[r][c] == 0 or visited[r][c]:
                    continue
                color = g[r][c]
                stack = [(r, c)]
                visited[r][c] = True
                cells = []
                while stack:
                    rr, cc = stack.pop()
                    cells.append((rr, cc))
                    comp_id[rr][cc] = cid
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = rr + dr, cc + dc
                        if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and g[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                comps.append({'id': cid, 'cells': cells, 'color': color})
                cid += 1
        return comp_id, comps

    def pattern_dirs(comp):
        cells = comp['cells']
        cellset = set(cells)
        rows = [r for r, c in cells]
        cols = [c for r, c in cells]
        rmin, rmax = min(rows), max(rows)
        cmin, cmax = min(cols), max(cols)
        # Horizontal
        if len(set(rows)) == 1 and len(cells) >= 2:
            return [(0, -1)]
        # Vertical
        if len(set(cols)) == 1 and len(cells) >= 2:
            return [(-1, 0)]
        # Cross
        if len(cells) == 5:
            for (r, c) in cells:
                if ((r - 1, c) in cellset and (r + 1, c) in cellset and
                        (r, c - 1) in cellset and (r, c + 1) in cellset):
                    return [(-1, 0), (1, 0), (0, -1), (0, 1)]
        # Corner (3 cells in 2x2)
        if len(cells) == 3 and (rmax - rmin == 1) and (cmax - cmin == 1):
            all2x2 = [(rmin, cmin), (rmin, cmin + 1), (rmin + 1, cmin), (rmin + 1, cmin + 1)]
            missing = None
            for p in all2x2:
                if p not in cellset:
                    missing = p
                    break
            if missing == (rmin + 1, cmin + 1):
                return [(-1, 0), (0, -1)]
            if missing == (rmin + 1, cmin):
                return [(-1, 0), (0, 1)]
            if missing == (rmin, cmin + 1):
                return [(1, 0), (0, -1)]
            if missing == (rmin, cmin):
                return [(1, 0), (0, 1)]
        return []

    comp_id, comps = find_components(grid)
    comp_dirs = {c['id']: pattern_dirs(c) for c in comps}

    out = [row[:] for row in grid]
    # Apply propagation: for each source component, for each outgoing direction, for each cell
    for src in comps:
        s_id = src['id']
        s_color = src['color']
        dirs = comp_dirs.get(s_id, [])
        if not dirs:
            continue
        for (sr, sc) in src['cells']:
            for (dr, dc) in dirs:
                nr, nc = sr + dr, sc + dc
                if 0 <= nr < h and 0 <= nc < w and grid[nr][nc] != 0 and comp_id[nr][nc] != s_id:
                    target_id = comp_id[nr][nc]
                    out[nr][nc] = s_color
                    pr, pc = nr + dr, nc + dc
                    while 0 <= pr < h and 0 <= pc < w and grid[pr][pc] != 0 and comp_id[pr][pc] == target_id:
                        out[pr][pc] = s_color
                        pr += dr
                        pc += dc
    return out

