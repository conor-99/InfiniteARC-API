# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 318d08c5
Difficulty: hard

=== Tags ===
- Maze

=== Description ===
The task involves transforming a maze grid where 0 represents a passable path
and any non-zero value represents a wall. The output grid is derived by
identifying all path cells (0s) that serve as dead ends—cells with exactly one
adjacent path cell (top, bottom, left, or right)—and converting those dead-end
path cells into walls (1s). All other cells remain unchanged. This requires the
solver to analyze the connectivity of path cells, detect cycles or branches
through neighbor counts, and systematically replace dead ends with walls to
simplify the maze structure. The input grids feature complex maze layouts with
numerous branches, loops, and dead ends, making the transformation non-trivial
and requiring multi-step abstract reasoning to identify and resolve all dead
ends across the grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    from common import continuous_creature, grid
    width = random.randint(5, 20)
    height = random.randint(5, 20)
    max_size = width * height
    path_size = random.randint(3, max_size - 5)
    path_pixels = continuous_creature(path_size, width, height)
    input_grid = grid(width, height, 1)
    for r, c in path_pixels:
        input_grid[r][c] = 0
    output_grid = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                count = 0
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 0:
                        count += 1
                if count == 1:
                    output_grid[r][c] = 1
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    output_grid = [list(row) for row in input_grid]
    width = len(output_grid[0])
    height = len(output_grid)
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                count = 0
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 0:
                        count += 1
                if count == 1:
                    output_grid[r][c] = 1
    return output_grid
