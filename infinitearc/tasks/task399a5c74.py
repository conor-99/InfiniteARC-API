# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 399a5c74
Difficulty: medium–hard

=== Tags ===
- Pattern cycle
- Deterministic reflection
- Dual grid translation
- Source target routing

=== Description ===
Input grids feature a background color (0) with a closed loop cycle formed by a
single non-background color (e.g., color 5), surrounded by background. Scattered
across the grid are two distinct markers: a source marker (color 3) and a target
marker (color 7), positioned outside the cycle and not aligned with it. The
cycle must be contiguous and fully enclosed by background, with markers placed
such that no direct path exists between them in the input.  The output grid is
generated through the following deterministic sequence:  1. **Pattern Cycle
Reflection**: The cycle is reflected across the vertical midline of the grid
(deterministic reflection), creating a mirror image. Each cell (r, c) in the
original cycle maps to (r, width - 1 - c) in the reflected cycle.  2. **Dual
Grid Translation**: The original cycle is translated 2 cells to the right, while
the reflected cycle is translated 3 cells downward. These translations are
applied to the centroid of each cycle, ensuring no overlap with background or
other elements.  3. **Source-Target Routing**: A continuous path connects the
source marker (color 3) to the target marker (color 7) by following the
translated original cycle and reflected cycle. The path alternates between the
two translated cycles, forming a loop that links source to target. This routing
uses a new color (color 4) to mark the path, which only overlaps with background
cells and does not overwrite existing cycle elements or markers.  The output
grid preserves all background cells, source, and target markers. The cycle, its
reflection, and the routing path are clearly visible, with all transformations
applied exactly once. No loops, self-intersections, or distortions occur in the
cycle or routing path. The task requires recognizing the cycle, applying
reflection, executing dual translations, and constructing the routing path—all
while ensuring no color conflicts with existing elements.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    W = random.randint(9, 30)
    H = random.randint(9, 30)
    cycle_w = random.randint(5, 15)
    cycle_h = random.randint(5, 15)
    
    # Ensure cycle fits with padding
    cycle_w = min(cycle_w, W - 4)
    cycle_h = min(cycle_h, H - 4)
    
    r_start_upper = H - cycle_h - 3
    if r_start_upper < 2:
        r_start_upper = 2
    r_start = random.randint(2, r_start_upper)
    
    c_start_upper = W - cycle_w - 3
    if c_start_upper < 2:
        c_start_upper = 2
    c_start = random.randint(2, c_start_upper)
    
    input_grid = grid(W, H, 0)
    
    for r in range(cycle_h):
        for c in range(cycle_w):
            if r == 0 or r == cycle_h-1 or c == 0 or c == cycle_w-1:
                input_grid[r_start + r][c_start + c] = 5

    s_r = r_start - 3
    s_c = c_start + cycle_w // 2
    s_r = max(0, min(s_r, H-1))
    s_c = max(0, min(s_c, W-1))
    input_grid[s_r][s_c] = 3

    t_r = r_start + cycle_h + 3
    t_c = c_start + cycle_w // 2
    t_r = max(0, min(t_r, H-1))
    t_c = max(0, min(t_c, W-1))
    input_grid[t_r][t_c] = 7

    output_grid = grid(W, H, 0)
    output_grid[s_r][s_c] = 3
    output_grid[t_r][t_c] = 7
    
    for r in range(cycle_h):
        for c in range(cycle_w):
            if r == 0 or r == cycle_h-1 or c == 0 or c == cycle_w-1:
                new_r = r_start + r
                new_c = c_start + c + 2
                if 0 <= new_r < H and 0 <= new_c < W:
                    output_grid[new_r][new_c] = 5

    for r in range(cycle_h):
        for c in range(cycle_w):
            if r == 0 or r == cycle_h-1 or c == 0 or c == cycle_w-1:
                reflected_c = W - 1 - (c_start + c)
                new_r = r_start + r + 3
                new_c = reflected_c
                if 0 <= new_r < H and 0 <= new_c < W:
                    output_grid[new_r][new_c] = 5

    source = (s_r, s_c)
    target = (t_r, t_c)
    
    # Find closest point on translated cycle to source
    closest_original = None
    min_dist = float('inf')
    for r in range(H):
        for c in range(W):
            if output_grid[r][c] == 5:
                dist = abs(r - s_r) + abs(c - s_c)
                if dist < min_dist:
                    min_dist = dist
                    closest_original = (r, c)

    # Find closest point on reflected cycle to target
    closest_reflected = None
    min_dist = float('inf')
    for r in range(H):
        for c in range(W):
            if output_grid[r][c] == 5:
                dist = abs(r - t_r) + abs(c - t_c)
                if dist < min_dist:
                    min_dist = dist
                    closest_reflected = (r, c)

    # Draw path from source to closest_original
    r, c = s_r, s_c
    while c < closest_original[1] and output_grid[r][c] == 0:
        output_grid[r][c] = 4
        c += 1
    while r < closest_original[0] and output_grid[r][c] == 0:
        output_grid[r][c] = 4
        r += 1

    # Draw path from closest_original to closest_reflected
    r, c = closest_original
    while r < closest_reflected[0] and output_grid[r][c] == 0:
        output_grid[r][c] = 4
        r += 1

    # Draw path from closest_reflected to target
    r, c = closest_reflected
    while c < target[1] and output_grid[r][c] == 0:
        output_grid[r][c] = 4
        c += 1
    while r < target[0] and output_grid[r][c] == 0:
        output_grid[r][c] = 4
        r += 1

    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    W = len(input_grid[0])
    H = len(input_grid)
    
    # Find cycle (color 5), source (3), target (7)
    cycle_cells = []
    source = None
    target = None
    
    for r in range(H):
        for c in range(W):
            if input_grid[r][c] == 5:
                cycle_cells.append((r, c))
            elif input_grid[r][c] == 3:
                source = (r, c)
            elif input_grid[r][c] == 7:
                target = (r, c)

    if not source or not target:
        return input_grid

    # Create translated original cycle (right 2)
    original_translated = [(r, c + 2) for (r, c) in cycle_cells]
    # Reflect cycle over vertical midline
    reflected_cycle = [(r, W - 1 - c) for (r, c) in cycle_cells]
    # Translate reflected cycle down 3
    reflected_translated = [(r + 3, c) for (r, c) in reflected_cycle]

    # Create output grid
    output = [[0] * W for _ in range(H)]
    
    # Place source and target
    sr, sc = source
    output[sr][sc] = 3
    tr, tc = target
    output[tr][tc] = 7

    # Place translated cycles
    for (r, c) in original_translated:
        if 0 <= r < H and 0 <= c < W:
            output[r][c] = 5
    for (r, c) in reflected_translated:
        if 0 <= r < H and 0 <= c < W:
            output[r][c] = 5

    # Find closest points for path
    closest_original = None
    min_dist = float('inf')
    for (r, c) in original_translated:
        if 0 <= r < H and 0 <= c < W:
            dist = abs(r - sr) + abs(c - sc)
            if dist < min_dist:
                min_dist = dist
                closest_original = (r, c)

    closest_reflected = None
    min_dist = float('inf')
    for (r, c) in reflected_translated:
        if 0 <= r < H and 0 <= c < W:
            dist = abs(r - tr) + abs(c - tc)
            if dist < min_dist:
                min_dist = dist
                closest_reflected = (r, c)

    # Draw path from source to closest_original
    r, c = sr, sc
    while c < closest_original[1] and output[r][c] == 0:
        output[r][c] = 4
        c += 1
    while r < closest_original[0] and output[r][c] == 0:
        output[r][c] = 4
        r += 1

    # Draw path from closest_original to closest_reflected
    r, c = closest_original
    while r < closest_reflected[0] and output[r][c] == 0:
        output[r][c] = 4
        r += 1

    # Draw path from closest_reflected to target
    r, c = closest_reflected
    while c < tc and output[r][c] == 0:
        output[r][c] = 4
        c += 1
    while r < tr and output[r][c] == 0:
        output[r][c] = 4
        r += 1

    return output
