# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 6cbeb573
Difficulty: insane

=== Tags ===
- Attention switching

=== Description ===
The task involves input grids containing intersecting horizontal and vertical
lines, where each line consists of a contiguous row or column of uniform color
(distinct from surrounding cells). The output grid is generated by dividing the
input into regions based on these lines, with each region undergoing a
transformation determined by its boundary line types. Regions bounded by
horizontal lines on both top and bottom are rotated 180 degrees, while regions
bounded by vertical lines on both left and right are reflected horizontally. For
regions bounded by mixed line types (e.g., horizontal top and vertical left), a
diagonal reflection is applied. The solver must sequentially identify line
orientations, partition the grid into regions, and apply context-dependent
transformationsâ€”requiring constant attention switching between line types and
transformation rules across the grid. This complexity arises from the need to
dynamically switch between multiple transformation rules based on local boundary
conditions, with no reliance on numerical values or color-specific properties.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    
    # Ensure minimum size for valid sampling (difference >=2)
    if height < 7:
        height = 7
    if width < 7:
        width = 7
    
    line_color = random.randint(1, 9)
    
    # Horizontal lines (rows) - ensure space at edges
    H = []
    while len(H) < 2:
        H = sorted(random.sample(range(2, height-2), 2))
        if H[1] - H[0] < 2:
            H = []
    
    # Vertical lines (columns) - ensure space at edges
    V = []
    while len(V) < 2:
        V = sorted(random.sample(range(2, width-2), 2))
        if V[1] - V[0] < 2:
            V = []
    
    input_grid = grid(width, height)
    
    # Set horizontal lines
    for r in H:
        for c in range(width):
            input_grid[r][c] = line_color
    
    # Set vertical lines
    for c in V:
        for r in range(height):
            input_grid[r][c] = line_color
    
    # Fill non-line cells
    for r in range(height):
        for c in range(width):
            if r not in H and c not in V:
                color = random.randint(0, 9)
                while color == line_color:
                    color = random.randint(0, 9)
                input_grid[r][c] = color
    
    output_grid = [row[:] for row in input_grid]
    
    # Add boundaries for edge regions
    hor_bounds = [0] + H + [height-1]
    ver_bounds = [0] + V + [width-1]
    
    for i in range(len(hor_bounds)-1):
        top = hor_bounds[i]
        bottom = hor_bounds[i+1]
        for j in range(len(ver_bounds)-1):
            left = ver_bounds[j]
            right = ver_bounds[j+1]
            
            region_rows = list(range(top+1, bottom))
            region_cols = list(range(left+1, right))
            
            if top in H and bottom in H:
                region = [[input_grid[r][c] for c in region_cols] for r in region_rows]
                rotated = [row[::-1] for row in region[::-1]]
                for idx, r in enumerate(region_rows):
                    for jdx, c in enumerate(region_cols):
                        output_grid[r][c] = rotated[idx][jdx]
            elif left in V and right in V:
                region = [[input_grid[r][c] for c in region_cols] for r in region_rows]
                reflected = [row[::-1] for row in region]
                for idx, r in enumerate(region_rows):
                    for jdx, c in enumerate(region_cols):
                        output_grid[r][c] = reflected[idx][jdx]
            else:
                region = [[input_grid[r][c] for c in region_cols] for r in region_rows]
                transposed = [[region[r][c] for r in range(len(region))] for c in range(len(region[0]))]
                for idx, r in enumerate(region_rows):
                    for jdx, c in enumerate(region_cols):
                        output_grid[r][c] = transposed[jdx][idx]
    
    return {
        'input': input_grid,
        'output': output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    
    # Convert input to list of lists for mutation
    output_grid = [list(row) for row in input_grid]
    
    # Determine line_color by finding the color that appears in the most full rows
    line_color = 0
    max_rows = -1
    for color in range(1, 10):
        count = 0
        for r in range(height):
            if all(input_grid[r][c] == color for c in range(width)):
                count += 1
        if count > max_rows:
            max_rows = count
            line_color = color
    
    # Find horizontal lines (rows with all line_color)
    H = []
    for r in range(2, height-2):
        if all(input_grid[r][c] == line_color for c in range(width)):
            H.append(r)
    
    # Find vertical lines (columns with all line_color)
    V = []
    for c in range(2, width-2):
        if all(input_grid[r][c] == line_color for r in range(height)):
            V.append(c)
    
    # Add boundaries for edge regions
    hor_bounds = [0] + H + [height-1]
    ver_bounds = [0] + V + [width-1]
    
    for i in range(len(hor_bounds)-1):
        top = hor_bounds[i]
        bottom = hor_bounds[i+1]
        for j in range(len(ver_bounds)-1):
            left = ver_bounds[j]
            right = ver_bounds[j+1]
            
            region_rows = list(range(top+1, bottom))
            region_cols = list(range(left+1, right))
            
            if top in H and bottom in H:
                region = [[input_grid[r][c] for c in region_cols] for r in region_rows]
                rotated = [row[::-1] for row in region[::-1]]
                for idx, r in enumerate(region_rows):
                    for jdx, c in enumerate(region_cols):
                        output_grid[r][c] = rotated[idx][jdx]
            elif left in V and right in V:
                region = [[input_grid[r][c] for c in region_cols] for r in region_rows]
                reflected = [row[::-1] for row in region]
                for idx, r in enumerate(region_rows):
                    for jdx, c in enumerate(region_cols):
                        output_grid[r][c] = reflected[idx][jdx]
            else:
                region = [[input_grid[r][c] for c in region_cols] for r in region_rows]
                transposed = [[region[r][c] for r in range(len(region))] for c in range(len(region[0]))]
                for idx, r in enumerate(region_rows):
                    for jdx, c in enumerate(region_cols):
                        output_grid[r][c] = transposed[jdx][idx]
    
    return output_grid
