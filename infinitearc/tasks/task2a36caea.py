# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 2a36caea
Difficulty: medium

=== Tags ===
- Connect equal color components
- Take minimum

=== Description ===
The input grid contains disconnected regions of the same color. The output grid
is formed by connecting all disconnected regions of each color using the
shortest possible path (minimum number of cells) between them, thereby merging
them into a single connected region for each color. The transformation involves
identifying all disconnected regions for a given color and filling the minimum
number of cells required to connect them, which corresponds to the shortest path
between the regions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 10)
    height = random.randint(5, 10)
    color = random.randint(1, 9)
    
    input_grid = [[0] * width for _ in range(height)]
    
    region_a_x = random.randint(0, width // 2 - 2)
    region_a_y = random.randint(0, height // 2 - 2)
    for dx in range(2):
        for dy in range(2):
            if region_a_x + dx < width and region_a_y + dy < height:
                input_grid[region_a_y + dy][region_a_x + dx] = color
    
    region_b_x = max(region_a_x + 3, width // 2)
    region_b_y = region_a_y
    for dx in range(2):
        for dy in range(2):
            if region_b_x + dx < width and region_b_y + dy < height:
                input_grid[region_b_y + dy][region_b_x + dx] = color
    
    output_grid = [list(row) for row in input_grid]
    region_a_right = region_a_x + 1
    region_b_left = region_b_x
    for col in range(region_a_right + 1, region_b_left):
        for row in range(region_a_y, region_a_y + 2):
            if 0 <= row < height and 0 <= col < width:
                output_grid[row][col] = color
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    output_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    
    colors = set()
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                colors.add(input_grid[r][c])
    
    for color in colors:
        positions = []
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == color:
                    positions.append((r, c))
        
        if not positions:
            continue
        
        visited = [[False] * width for _ in range(height)]
        components = []
        for pos in positions:
            r, c = pos
            if not visited[r][c]:
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                components.append(component)
        
        if len(components) > 1:
            min_dist = float('inf')
            closest_pair = None
            for i in range(len(components)):
                for j in range(i + 1, len(components)):
                    for p1 in components[i]:
                        for p2 in components[j]:
                            dist = abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])
                            if dist < min_dist:
                                min_dist = dist
                                closest_pair = (components[i], components[j])
            
            if closest_pair:
                comp1, comp2 = closest_pair
                min_point_dist = float('inf')
                closest_points = None
                for p1 in comp1:
                    for p2 in comp2:
                        dist = abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])
                        if dist < min_point_dist:
                            min_point_dist = dist
                            closest_points = (p1, p2)
                
                p1, p2 = closest_points
                if p1[0] == p2[0]:
                    start_col = min(p1[1], p2[1])
                    end_col = max(p1[1], p2[1])
                    min_row = min(min(r for r, c in comp1), min(r for r, c in comp2))
                    max_row = max(max(r for r, c in comp1), max(r for r, c in comp2))
                    for row in range(min_row, max_row + 1):
                        for col in range(start_col + 1, end_col):
                            output_grid[row][col] = color
                elif p1[1] == p2[1]:
                    start_row = min(p1[0], p2[0])
                    end_row = max(p1[0], p2[0])
                    min_col = min(min(c for r, c in comp1), min(c for r, c in comp2))
                    max_col = max(max(c for r, c in comp1), max(c for r, c in comp2))
                    for col in range(min_col, max_col + 1):
                        for row in range(start_row + 1, end_row):
                            output_grid[row][col] = color
                else:
                    if abs(p1[0] - p2[0]) < abs(p1[1] - p2[1]):
                        start_row = min(p1[0], p2[0])
                        end_row = max(p1[0], p2[0])
                        min_col = min(min(c for r, c in comp1), min(c for r, c in comp2))
                        max_col = max(max(c for r, c in comp1), max(c for r, c in comp2))
                        for col in range(min_col, max_col + 1):
                            for row in range(start_row + 1, end_row):
                                output_grid[row][col] = color
                    else:
                        start_col = min(p1[1], p2[1])
                        end_col = max(p1[1], p2[1])
                        min_row = min(min(r for r, c in comp1), min(r for r, c in comp2))
                        max_row = max(max(r for r, c in comp1), max(r for r, c in comp2))
                        for row in range(min_row, max_row + 1):
                            for col in range(start_col + 1, end_col):
                                output_grid[row][col] = color
    return output_grid
