# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 3ab8d37d
Difficulty: hard

=== Tags ===
- Surface unfolding
- Pressure release
- Stacked layer alignment
- Pattern moving
- Remove intruder

=== Description ===
**Task Title**: Layered Unfolding    **Description**:    Input grids depict a
complex, folded surface composed of multiple stacked layers, each containing a
distinct pattern. The fold is along a central vertical or horizontal axis,
causing the layers to overlap incorrectly and creating "pressure" at the fold
line. This pressure manifests as an intruder—a small cluster of cells (typically
a single color not present in the main patterns) embedded within the overlapping
region. The intruder disrupts the alignment of the layers and prevents the
surface from unfolding correctly.    The transformation requires the following
steps:   1. **Remove the intruder**: Identify and eliminate all cells of the
intruder color (e.g., color `5`), which is unique to the overlapping region and
absent from the primary patterns.   2. **Pressure release**: After removal, the
overlapping layers "release" their tension, requiring the right (or bottom) half
of the grid to shift toward the fold line to align with the left (or top) half.
This shift corrects misaligned patterns caused by the intruder.   3. **Stacked
layer alignment**: Each layer (e.g., layers defined by distinct colors) must be
realigned horizontally or vertically to match the primary pattern’s structure.
For example, a layer shifted right by two cells must shift left by two cells to
align with its counterpart.   4. **Pattern moving**: The corrected, unfolded
pattern is then shifted to a new position within the grid (e.g., centered or
moved to the top-left corner), ensuring no overlap with the remaining
background.   5. **Surface unfolding**: The final grid displays a continuous,
flat pattern without folds, overlaps, or intruders, with all layers aligned and
the pattern positioned as per the alignment rule.    **Key Visual Cues**:   -
The intruder is always a small, compact cluster (e.g., 1–3 cells) of a single
color not used elsewhere in the grid.   - Overlapping layers appear as mirrored
or shifted duplicates of the primary pattern, with the intruder disrupting the
symmetry.   - Alignment requires precise horizontal/vertical shifts (e.g., +2
columns, -1 row) based on the intruder’s position.   - The output grid is
visually distinct from the input, with no overlapping regions, the intruder
removed, and all patterns in their correct, aligned positions.    **Example
Insight**:   An input grid may have a central vertical fold, with the right half
shifted right by 2 cells. The intruder (color `5`) occupies the fold line,
causing the right half to be misaligned. After removing `5`, the right half
shifts left by 2 cells to align with the left half. The stacked layers (e.g.,
red and blue patterns) then adjust to match the corrected fold, and the entire
pattern moves to the top-right corner, completing the unfolded surface.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    
    input_grid = grid(width, height, 0)
    
    for r in range(3):
        for c in range(3):
            input_grid[r][c] = 1
    
    for r in range(3):
        for c in range(3):
            input_grid[r][c] = 2
    
    intruder_positions = random.sample([(r, c) for r in range(3) for c in range(3)], k=random.randint(1, 3))
    for r, c in intruder_positions:
        input_grid[r][c] = 5
    
    output_grid = grid(width, height, 0)
    
    for r in range(3):
        for c in range(3):
            if input_grid[r][c] == 1:
                output_grid[r][c] = 1
    
    for r in range(3):
        for c in range(3):
            if input_grid[r][c] == 2:
                if c + 2 < width:
                    output_grid[r][c + 2] = 2
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    width = len(input_list[0])
    height = len(input_list)
    
    output_list = [[0] * width for _ in range(height)]
    
    for r in range(height):
        for c in range(width):
            if input_list[r][c] == 1:
                output_list[r][c] = 1
    
    for r in range(height):
        for c in range(width):
            if input_list[r][c] == 2:
                if c + 2 < width:
                    output_list[r][c + 2] = 2
    
    return tuple(tuple(row) for row in output_list)
