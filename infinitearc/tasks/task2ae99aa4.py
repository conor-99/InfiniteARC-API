# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 2ae99aa4
Difficulty: mediumâ€“hard

=== Tags ===
- Non rectangular tiling
- Two color checkerboard
- Dominant color

=== Description ===
The input grid features a two-color checkerboard pattern (e.g., alternating
colors like 0 and 1), but some connected regions (tiles) of the same color are
non-rectangular. A region is non-rectangular if it does not completely fill the
smallest axis-aligned rectangle that contains all its cells (i.e., the bounding
box contains at least one cell of a different color or background). The dominant
color is the most frequently occurring color in the entire input grid. The
output grid is generated by replacing all cells belonging to non-rectangular
regions with the dominant color. This transformation corrects irregular tile
shapes, ensuring all remaining regions are rectangular while preserving the
checkerboard structure. The dominant color acts as the "filler" for non-
rectangular gaps, resulting in a visually consistent checkerboard pattern where
all tiles align with their bounding boxes. This requires sequential reasoning:
identifying connected regions, verifying rectangularity via bounding box
analysis, and applying the dominant color replacement. The task challenges users
to distinguish between valid checkerboard-aligned regions and irregular shapes,
leveraging frequency analysis and spatial reasoning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    grid = [[0] * width for _ in range(height)]
    
    num_regions = random.randint(1, 3)
    
    for _ in range(num_regions):
        region_width = random.randint(3, 5)
        region_height = random.randint(3, 5)
        region_width = min(region_width, width)
        region_height = min(region_height, height)
        top = random.randint(0, height - region_height)
        left = random.randint(0, width - region_width)
        
        for r in range(top, top + region_height):
            for c in range(left, left + region_width):
                grid[r][c] = 1
        
        if region_width > 2 and region_height > 2:
            interior_r = random.randint(top + 1, top + region_height - 2)
            interior_c = random.randint(left + 1, left + region_width - 2)
            grid[interior_r][interior_c] = 0
    
    all_cells = [cell for row in grid for cell in row]
    dominant_color = max(set(all_cells), key=all_cells.count)
    
    output_grid = [row[:] for row in grid]
    visited = [[False] * width for _ in range(height)]
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c]:
                stack = [(r, c)]
                visited[r][c] = True
                color = grid[r][c]
                region = []
                while stack:
                    cr, cc = stack.pop()
                    region.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                
                if region:
                    min_r, max_r = min(r for r, c in region), max(r for r, c in region)
                    min_c, max_c = min(c for r, c in region), max(c for r, c in region)
                    is_rect = True
                    for r2 in range(min_r, max_r + 1):
                        for c2 in range(min_c, max_c + 1):
                            if (r2, c2) not in region:
                                is_rect = False
                                break
                        if not is_rect:
                            break
                    if not is_rect:
                        for (r2, c2) in region:
                            output_grid[r2][c2] = dominant_color
    
    return {"input": grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    
    all_cells = [cell for row in grid for cell in row]
    dominant_color = max(set(all_cells), key=all_cells.count)
    
    visited = [[False] * width for _ in range(height)]
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c]:
                stack = [(r, c)]
                visited[r][c] = True
                color = grid[r][c]
                region = []
                while stack:
                    cr, cc = stack.pop()
                    region.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                
                if region:
                    min_r, max_r = min(r for r, c in region), max(r for r, c in region)
                    min_c, max_c = min(c for r, c in region), max(c for r, c in region)
                    is_rect = True
                    for r2 in range(min_r, max_r + 1):
                        for c2 in range(min_c, max_c + 1):
                            if (r2, c2) not in region:
                                is_rect = False
                                break
                        if not is_rect:
                            break
                    if not is_rect:
                        for (r2, c2) in region:
                            grid[r2][c2] = dominant_color
    
    return tuple(tuple(row) for row in grid)
