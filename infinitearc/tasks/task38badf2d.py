# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 38badf2d
Difficulty: insane

=== Tags ===
- Terrain erosion
- Cooperative beams
- Maze
- Draw path through ordered checkpoints

=== Description ===
Input grids depict a maze-like structure with walls (color 0), background cells
(color 1), and four checkpoints labeled with distinct colors in sequential
order: 2 (first), 3 (second), 4 (third), and 5 (fourth). Scattered throughout
the grid are cooperative beams—horizontal or vertical lines of color 6—that form
a network of traversable pathways. The beams must be utilized when moving
between consecutive checkpoints, even if it extends the path length beyond the
shortest possible route.  To generate the output grid, the transformation
follows these steps: 1. **Path Tracing**: For each consecutive checkpoint pair
(2→3, 3→4, 4→5), trace the shortest orthogonal path (moving only
up/down/left/right) that aligns with the cooperative beam network. If a beam
intersects the direct path, the route must follow the beam, potentially
deviating from the shortest route. 2. **Terrain Erosion**: Replace all wall
cells (0) along the traced path with the segment's designated path color (7 for
2→3, 8 for 3→4, 9 for 4→5). Background cells (1) remain unchanged unless part of
the path. 3. **Cooperative Beam Integration**: Beams (color 6) remain visible as
part of the path structure but are overwritten by the path color (7/8/9) where
they overlap with the traced route. Beams not traversed remain color 6. 4.
**Sequential Path Drawing**: Each segment (2→3, 3→4, 4→5) is drawn in sequence
with unique colors, ensuring no path segments overlap or intersect beams outside
the traced route.  The output grid displays the original maze structure with all
walls along the path erased (replaced by path colors), the cooperative beam
network intact where not overwritten, and checkpoints preserved. The
transformation requires precise pathfinding, beam alignment, sequential color
application, and terrain modification—all while adhering to strict non-
overlapping constraints.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = 20
    height = 20
    grid_in = grid(width, height, 1)
    
    # Place checkpoints
    grid_in[5][5] = 2
    grid_in[5][15] = 3
    grid_in[15][15] = 4
    grid_in[15][5] = 5
    
    # Place beams
    for c in range(6, 15):
        grid_in[5][c] = 6
    for r in range(6, 15):
        grid_in[r][15] = 6
    for c in range(6, 15):
        grid_in[15][c] = 6
    
    # Identify available cells for walls
    available = []
    for r in range(height):
        for c in range(width):
            if (r == 5 and c == 5) or (r == 5 and c == 15) or (r == 15 and c == 15) or (r == 15 and c == 5):
                continue
            if (r == 5 and 6 <= c <= 14) or (c == 15 and 6 <= r <= 14) or (r == 15 and 6 <= c <= 14):
                continue
            available.append((r, c))
    
    # Randomly place walls
    random.shuffle(available)
    num_walls = random.randint(20, 50)
    for i in range(num_walls):
        r, c = available[i]
        grid_in[r][c] = 0
    
    # Create output grid
    grid_out = [row[:] for row in grid_in]
    # 2→3 (row 5)
    for c in range(6, 15):
        if grid_out[5][c] in [0, 6]:
            grid_out[5][c] = 7
    # 3→4 (column 15)
    for r in range(6, 15):
        if grid_out[r][15] in [0, 6]:
            grid_out[r][15] = 8
    # 4→5 (row 15)
    for c in range(6, 15):
        if grid_out[15][c] in [0, 6]:
            grid_out[15][c] = 9
    
    return {"input": grid_in, "output": grid_out}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid_in = [list(row) for row in input_grid]
    positions = {}
    for r in range(len(grid_in)):
        for c in range(len(grid_in[0])):
            color = grid_in[r][c]
            if 2 <= color <= 5:
                positions[color] = (r, c)
    
    if len(positions) != 4:
        return grid_in
    
    path_segments = [
        (2, 3, 7),
        (3, 4, 8),
        (4, 5, 9)
    ]
    
    for (color1, color2, path_color) in path_segments:
        r1, c1 = positions[color1]
        r2, c2 = positions[color2]
        
        if r1 == r2:
            start_c = min(c1, c2) + 1
            end_c = max(c1, c2)
            for c in range(start_c, end_c):
                if grid_in[r1][c] in [0, 6]:
                    grid_in[r1][c] = path_color
        elif c1 == c2:
            start_r = min(r1, r2) + 1
            end_r = max(r1, r2)
            for r in range(start_r, end_r):
                if grid_in[r][c1] in [0, 6]:
                    grid_in[r][c1] = path_color
    
    return grid_in
