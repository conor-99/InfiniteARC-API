# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 637dd86d
Difficulty: medium

=== Tags ===
- Associate images to numbers
- Spacing
- Image within image

=== Description ===
The input grids contain a single connected region of non-zero values (the
"image") surrounded by zero values (the "spacing" or background). The output
grid is the minimal bounding box that encompasses all non-zero pixels,
effectively cropping out the surrounding zero background to reveal only the
central image. This transformation requires identifying the contiguous
foreground region and determining its smallest rectangular boundary, which
removes all extraneous spacing while preserving the image's shape and color
values. The task leverages visual spatial reasoning to isolate the core image
within the grid, aligning with the "Image within image" and "Spacing" tags,
while the non-zero values inherently associate with numerical colors as part of
the visual representation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    size = random.randint(3, 10)
    pixels = common.continuous_creature(size, width=10, height=10)
    if not pixels:
        pixels = [(0, 0)]
    min_r = min(p[0] for p in pixels)
    max_r = max(p[0] for p in pixels)
    min_c = min(p[1] for p in pixels)
    max_c = max(p[1] for p in pixels)
    bbox_height = max_r - min_r + 1
    bbox_width = max_c - min_c + 1
    input_width = min(bbox_width + 2, 30)
    input_height = min(bbox_height + 2, 30)
    input_grid = common.grid(input_width, input_height, 0)
    color = random.randint(1, 9)
    for r, c in pixels:
        input_grid[r + 1][c + 1] = color
    output_grid = []
    for r in range(min_r, max_r + 1):
        output_grid.append([input_grid[r + 1][c + 1] for c in range(min_c, max_c + 1)])
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    non_zero = []
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] != 0:
                non_zero.append((r, c))
    if not non_zero:
        return input_grid
    min_r = min(p[0] for p in non_zero)
    max_r = max(p[0] for p in non_zero)
    min_c = min(p[1] for p in non_zero)
    max_c = max(p[1] for p in non_zero)
    output = []
    for r in range(min_r, max_r + 1):
        output.append(input_grid[r][min_c:max_c + 1])
    return output
