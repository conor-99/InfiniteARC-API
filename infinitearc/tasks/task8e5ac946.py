# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 8e5ac946
Difficulty: very hard

=== Tags ===
- Pattern bounce
- Substitution rule discovery
- Portal momentum pathing

=== Description ===
# Task Description: Portal Momentum Pathing  The input grids depict a large,
complex environment (20×20 or larger) with a single background color. Scattered
across the grid are colored portals (distinct from background and token color)
arranged in pairs of identical color and shape. A small token (initially colored
differently from all portals) begins at the left edge of the grid, facing right.
The transformation rule requires tracing the token's complete path until it
exits the grid. Each time the token enters a portal cell, it instantly teleports
to the paired portal of the same color and changes direction according to a
hidden substitution rule: the portal's color determines the direction of the 90°
turn (e.g., red portals cause clockwise turns, blue portals cause counter-
clockwise turns). The substitution rule must be discovered by analyzing the
input-output pairs, as it is not explicitly given.   The output grid precisely
renders the token's path using two color schemes:  1. The initial segment
(before first portal entry) is drawn in the token's original color. 2. All
segments after portal entries are drawn in the color of the portal used to
trigger the turn.  The path must follow strict geometric rules:  - Movement is
strictly orthogonal (no diagonals). - Portals are always entered edge-to-edge
with the token's current direction. - The substitution rule consistently maps
each portal color to a fixed turning direction (left/right) across all input-
output pairs. - The output retains all original portal positions and background,
with only the token's path drawn through background cells.  This task requires
multi-step reasoning:  1. Identify all portal pairs and their colors. 2. Deduce
the substitution rule mapping colors to turning directions by comparing path
segments across examples. 3. Apply the rule to trace the complete path,
accounting for sequential portal entries and direction changes.  The difficulty
arises from the need to discover the substitution rule through abstract pattern
matching in a grid with multiple portal colors, where the direction change is
not visually intuitive (e.g., red = left turn, green = right turn, requiring
inference rather than direct color-direction association). The path may involve
5+ portal entries with varying colors, demanding sequential application of the
discovered rule.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    size = random.randint(20, 30)
    bg = 0
    token_color = 1
    substitution = {
        2: 'left',
        3: 'right',
        4: 'left',
        5: 'right',
        6: 'left',
        7: 'right',
        8: 'left',
        9: 'right'
    }
    
    input_grid = grid(size, size, bg)
    start_r = random.randint(1, size-2)
    input_grid[start_r][0] = token_color
    
    portal_colors = random.sample([2,3,4,5,6,7,8,9], k=random.randint(2,4))
    portals = {}
    for color in portal_colors:
        positions = []
        while len(positions) < 2:
            r = random.randint(1, size-2)
            c = random.randint(1, size-2)
            if (r, c) not in positions and input_grid[r][c] == bg:
                positions.append((r, c))
        portals[color] = positions
        for r, c in positions:
            input_grid[r][c] = color
    
    output_grid = grid(size, size, bg)
    path_segments = []
    current_pos = (start_r, 0)
    direction = (0, 1)
    current_color = token_color
    current_path = [current_pos]
    
    while True:
        next_pos = (current_pos[0] + direction[0], current_pos[1] + direction[1])
        if not (0 <= next_pos[0] < size and 0 <= next_pos[1] < size):
            break
        cell_color = input_grid[next_pos[0]][next_pos[1]]
        if cell_color > 0 and cell_color != 1:
            other_pos = [p for p in portals[cell_color] if p != next_pos][0]
            current_pos = other_pos
            if substitution[cell_color] == 'left':
                dr, dc = direction
                direction = (-dc, dr)
            else:
                dr, dc = direction
                direction = (dc, -dr)
            path_segments.append((current_color, current_path))
            current_color = cell_color
            current_path = [current_pos]
        else:
            current_pos = next_pos
            current_path.append(current_pos)
    
    path_segments.append((current_color, current_path))
    
    for color, positions in path_segments:
        for r, c in positions:
            output_grid[r][c] = color
    
    return {
        'input': input_grid,
        'output': output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
from common import grid

def p(input_grid):
    size = len(input_grid)
    token_start = None
    for r in range(size):
        if input_grid[r][0] == 1:
            token_start = (r, 0)
            break
    if token_start is None:
        token_start = (0, 0)
    
    portals = {}
    for r in range(size):
        for c in range(size):
            color = input_grid[r][c]
            if color > 0 and color != 1:
                if color not in portals:
                    portals[color] = []
                portals[color].append((r, c))
    
    substitution = {
        2: 'left',
        3: 'right',
        4: 'left',
        5: 'right',
        6: 'left',
        7: 'right',
        8: 'left',
        9: 'right'
    }
    
    output_grid = grid(size, size, 0)
    path_segments = []
    current_pos = token_start
    direction = (0, 1)
    current_color = 1
    current_path = [current_pos]
    
    while True:
        next_pos = (current_pos[0] + direction[0], current_pos[1] + direction[1])
        if not (0 <= next_pos[0] < size and 0 <= next_pos[1] < size):
            break
        cell_color = input_grid[next_pos[0]][next_pos[1]]
        if cell_color > 0 and cell_color != 1:
            other_pos = [p for p in portals[cell_color] if p != next_pos][0]
            current_pos = other_pos
            if substitution[cell_color] == 'left':
                dr, dc = direction
                direction = (-dc, dr)
            else:
                dr, dc = direction
                direction = (dc, -dr)
            path_segments.append((current_color, current_path))
            current_color = cell_color
            current_path = [current_pos]
        else:
            current_pos = next_pos
            current_path.append(current_pos)
    
    path_segments.append((current_color, current_path))
    
    for color, positions in path_segments:
        for r, c in positions:
            output_grid[r][c] = color
    
    return output_grid
