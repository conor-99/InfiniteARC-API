# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: df1e11cd
Difficulty: hard

=== Tags ===
- Pattern deconstruction
- Associate images to colors
- Associate patterns to patterns

=== Description ===
The input grids consist of complex 2D arrangements of non-zero color components
forming distinct geometric patterns, where each pattern's shape (e.g.,
horizontal line, diagonal segment, L-shape, or square) is the sole determinant
of its association. The output grid is generated by replacing every cell with
the specific color uniquely mapped to the shape of its connected component in
the input. This association is purely structural: a horizontal line of three
cells always maps to red, a 2x2 square to blue, a diagonal line of four cells to
green, and an L-shape to yellow, regardless of the input color values. The task
requires the solver to first segment the input into connected components (using
4-connectivity), then classify each component's geometric structure, and finally
apply the pre-defined shape-color mapping. The complexity arises from the
presence of overlapping patterns, subtle variations in shape (e.g., a line of
four cells vs. five cells), and the need to simultaneously apply multiple
associations across a large grid (e.g., 20x20) with up to 20 distinct pattern
instances. The solver must ignore color values entirely and focus solely on
spatial relationships and pattern geometry to derive the correct output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
def generate():
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    input_grid = [[0] * width for _ in range(height)]
    shapes = [
        ('horizontal', 3, 2, lambda r, c: [(r, c), (r, c+1), (r, c+2)]),
        ('square', 4, 1, lambda r, c: [(r, c), (r, c+1), (r+1, c), (r+1, c+1)]),
        ('diagonal', 4, 3, lambda r, c: [(r, c), (r+1, c+1), (r+2, c+2), (r+3, c+3)]),
        ('L', 3, 4, lambda r, c: [(r, c), (r, c+1), (r+1, c)])
    ]
    num_shapes = random.randint(3, 5)
    for _ in range(num_shapes):
        shape_type, cell_count, output_color, coords_func = random.choice(shapes)
        placed = False
        for _ in range(100):
            r = random.randint(0, height - 1)
            c = random.randint(0, width - 1)
            coords = coords_func(r, c)
            if any(rr < 0 or rr >= height or cc < 0 or cc >= width for rr, cc in coords):
                continue
            if any(input_grid[rr][cc] != 0 for rr, cc in coords):
                continue
            color = random.randint(1, 9)
            for rr, cc in coords:
                input_grid[rr][cc] = color
            placed = True
            break
        if not placed:
            continue
    output_grid = [[0] * width for _ in range(height)]
    visited = [[False] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    rr, cc = queue.pop(0)
                    component.append((rr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = rr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                min_r = min(rr for rr, cc in component)
                max_r = max(rr for rr, cc in component)
                min_c = min(cc for rr, cc in component)
                max_c = max(cc for rr, cc in component)
                width_comp = max_c - min_c + 1
                height_comp = max_r - min_r + 1
                num_cells = len(component)
                if num_cells == 3:
                    if all(rr == min_r for rr, cc in component) and width_comp == 3:
                        color_val = 2
                    elif width_comp == 2 and height_comp == 2:
                        color_val = 4
                    else:
                        color_val = 2
                elif num_cells == 4:
                    if width_comp == 2 and height_comp == 2:
                        color_val = 1
                    elif all(rr - cc == component[0][0] - component[0][1] for rr, cc in component):
                        color_val = 3
                    else:
                        color_val = 1
                else:
                    color_val = 0
                for rr, cc in component:
                    output_grid[rr][cc] = color_val
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid:
        return []
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = [[0] * width for _ in range(height)]
    visited = [[False] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    rr, cc = queue.pop(0)
                    component.append((rr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = rr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                min_r = min(rr for rr, cc in component)
                max_r = max(rr for rr, cc in component)
                min_c = min(cc for rr, cc in component)
                max_c = max(cc for rr, cc in component)
                width_comp = max_c - min_c + 1
                height_comp = max_r - min_r + 1
                num_cells = len(component)
                if num_cells == 3:
                    if all(rr == min_r for rr, cc in component) and width_comp == 3:
                        color_val = 2
                    elif width_comp == 2 and height_comp == 2:
                        color_val = 4
                    else:
                        color_val = 2
                elif num_cells == 4:
                    if width_comp == 2 and height_comp == 2:
                        color_val = 1
                    elif all(rr - cc == component[0][0] - component[0][1] for rr, cc in component):
                        color_val = 3
                    else:
                        color_val = 1
                else:
                    color_val = 0
                for rr, cc in component:
                    output_grid[rr][cc] = color_val
    return output_grid
