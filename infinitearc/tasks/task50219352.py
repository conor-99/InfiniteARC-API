# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 50219352
Difficulty: easy

=== Tags ===
- Contouring
- Pattern modification
- Projection unto rectangle

=== Description ===
The input grid features a single solid rectangle composed of a uniform non-zero
color, surrounded by zero-valued background cells. The output grid is generated
by retaining only the perimeter (outer border) of this rectangle while setting
all interior cells to zero. This transformation consistently extracts the
contour of the rectangle, preserving its color and position within the grid. The
rule applies regardless of the rectangle's size or location, as long as it is a
solid, axis-aligned block without internal variations. The output reflects the
minimal rectangular bounding box of the input shape, with the pattern modified
to show only the outline.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    grid_w = random.randint(3, 30)
    grid_h = random.randint(3, 30)
    input_grid = [[0] * grid_w for _ in range(grid_h)]
    rect_w = random.randint(3, grid_w)
    rect_h = random.randint(3, grid_h)
    r_start = random.randint(0, grid_h - rect_h)
    c_start = random.randint(0, grid_w - rect_w)
    color = random.randint(1, 9)
    for r in range(r_start, r_start + rect_h):
        for c in range(c_start, c_start + rect_w):
            input_grid[r][c] = color
    output_grid = [row[:] for row in input_grid]
    for r in range(r_start + 1, r_start + rect_h - 1):
        for c in range(c_start + 1, c_start + rect_w - 1):
            output_grid[r][c] = 0
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    if not input_grid or not input_grid[0]:
        return input_grid
    rows = []
    cols = []
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] != 0:
                rows.append(r)
                cols.append(c)
    if not rows:
        return input_grid
    min_r, max_r = min(rows), max(rows)
    min_c, max_c = min(cols), max(cols)
    output_grid = [row[:] for row in input_grid]
    for r in range(min_r + 1, max_r):
        for c in range(min_c + 1, max_c):
            output_grid[r][c] = 0
    return output_grid
