# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: d95f3c15
Difficulty: medium–hard

=== Tags ===
- Transformation stack
- Line decay
- Fill single gap
- Enlarge image

=== Description ===
Input grids consist of 2D grids (1×1 to 30×30) with a single background color
and multiple disjoint horizontal or vertical line segments composed of a single
non-background color. Each line segment contains exactly one gap (a background
cell) separating two or more non-background cells. No line segments contain
multiple gaps, and no gaps exist outside of line segments. The background color
is distinct from all line colors.  The transformation process involves three
sequential steps:   1. **Fill single gap**: Replace every gap in line segments
with the segment's color, making all line segments continuous.   2.
**Transformation stack**: Apply a fixed sequence of geometric transformations:
rotate the filled grid 90° clockwise, then flip the result horizontally.   3.
**Enlarge image**: Scale the transformed grid by a factor of 2, where each cell
in the transformed grid becomes a 2×2 block of identical color in the output.
The output grid maintains all original line segments (now continuous), undergoes
the fixed geometric transformations, and is scaled to double the input
dimensions. The background remains unchanged, and no new features are introduced
beyond the described operations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import flip_horiz

def rotate_90_clockwise(grid):
    return [list(reversed(col)) for col in zip(*grid)]

def enlarge_2x(grid):
    new_grid = []
    for row in grid:
        expanded = []
        for cell in row:
            expanded.append(cell)
            expanded.append(cell)
        new_grid.append(expanded)
        new_grid.append(expanded)
    return new_grid

def generate():
    width = random.randint(5, 15)
    height = random.randint(5, 15)
    bg = 0
    grid = [[bg] * width for _ in range(height)]
    
    line_colors = random.sample(range(1, 10), random.randint(1, 3))
    
    for color in line_colors:
        direction = random.choice(['horizontal', 'vertical'])
        if direction == 'horizontal':
            row = random.randint(0, height-1)
            left_len = random.randint(1, min(3, width - 2))
            right_len = random.randint(1, min(3, width - left_len - 1))
            total_len = left_len + 1 + right_len
            start_col = random.randint(0, width - total_len)
            gap_col = start_col + left_len
            for c in range(start_col, gap_col):
                grid[row][c] = color
            for c in range(gap_col + 1, start_col + total_len):
                grid[row][c] = color
        else:
            col = random.randint(0, width-1)
            left_len = random.randint(1, min(3, height - 2))
            right_len = random.randint(1, min(3, height - left_len - 1))
            total_len = left_len + 1 + right_len
            start_row = random.randint(0, height - total_len)
            gap_row = start_row + left_len
            for r in range(start_row, gap_row):
                grid[r][col] = color
            for r in range(gap_row + 1, start_row + total_len):
                grid[r][col] = color
    
    input_grid = grid
    filled_grid = [row[:] for row in input_grid]
    for i in range(height):
        for j in range(width):
            if input_grid[i][j] == 0:
                if j > 0 and j < width-1 and input_grid[i][j-1] != 0 and input_grid[i][j+1] != 0:
                    filled_grid[i][j] = input_grid[i][j-1]
                elif i > 0 and i < height-1 and input_grid[i-1][j] != 0 and input_grid[i+1][j] != 0:
                    filled_grid[i][j] = input_grid[i-1][j]
    
    rotated = rotate_90_clockwise(filled_grid)
    flipped = flip_horiz(rotated)
    output_grid = enlarge_2x(flipped)
    
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    filled_grid = [row[:] for row in input_grid]
    for i in range(height):
        for j in range(width):
            if input_grid[i][j] == 0:
                if j > 0 and j < width-1 and input_grid[i][j-1] != 0 and input_grid[i][j+1] != 0:
                    filled_grid[i][j] = input_grid[i][j-1]
                elif i > 0 and i < height-1 and input_grid[i-1][j] != 0 and input_grid[i+1][j] != 0:
                    filled_grid[i][j] = input_grid[i-1][j]
    
    rotated = [list(reversed(col)) for col in zip(*filled_grid)]
    flipped = [row[::-1] for row in rotated]
    
    output = []
    for row in flipped:
        expanded = []
        for cell in row:
            expanded.append(cell)
            expanded.append(cell)
        output.append(expanded)
        output.append(expanded)
    
    return output
