# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 0889f725
Difficulty: medium

=== Tags ===
- Periodic tiling
- Associate colors to images

=== Description ===
The task involves transforming an input grid into an output grid using a
consistent rule based on periodic tiling and color associations. The input grid
contains values between 0 and 9 representing distinct colors. Each color is
associated with a specific periodic pattern that determines how it appears in
the output grid. The pattern for each color depends on either the row index,
column index, or a combination of both, following a deterministic rule (e.g.,
even rows → color A, odd rows → color B for color 1; even columns → color C, odd
columns → color D for color 2).   To generate the output, for every cell in the
input grid, the color value is replaced by a value determined by its associated
pattern and the cell's position. For example, if a color is linked to row-based
periodicity, the output color alternates based on whether the row index is even
or odd. Similarly, a column-based pattern alternates based on column parity. The
output grid maintains the same dimensions as the input. The solver must deduce
the pattern for each color present in the input grid by analyzing the provided
examples and apply the pattern uniformly across the grid. This task requires
identifying color-pattern relationships and applying positional logic, making it
medium difficulty due to the need for relational reasoning and pattern
generalization.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    input_grid = [[random.randint(0,9) for _ in range(width)] for _ in range(height)]
    output_grid = [[0]*width for _ in range(height)]
    for i in range(height):
        for j in range(width):
            c = input_grid[i][j]
            if c % 2 == 0:
                X = (c + 1) % 10
                Y = (c + 2) % 10
                output_grid[i][j] = X if i % 2 == 0 else Y
            else:
                X = (c + 1) % 10
                Y = (c + 2) % 10
                output_grid[i][j] = X if j % 2 == 0 else Y
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = [[0]*width for _ in range(height)]
    for i in range(height):
        for j in range(width):
            c = input_grid[i][j]
            if c % 2 == 0:
                X = (c + 1) % 10
                Y = (c + 2) % 10
                output_grid[i][j] = X if i % 2 == 0 else Y
            else:
                X = (c + 1) % 10
                Y = (c + 2) % 10
                output_grid[i][j] = X if j % 2 == 0 else Y
    return output_grid
