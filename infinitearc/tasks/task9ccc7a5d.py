# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 9ccc7a5d
Difficulty: easy

=== Tags ===
- Image filling

=== Description ===
This task involves input grids displaying outlined rectangular shapes where the
perimeter is formed by a single non-zero color (e.g., color 3), while interior
pixels remain as 0 (background). The output grid is generated by filling all
interior pixels of each outlined rectangle with the same color used for the
perimeter. The transformation requires identifying closed rectangular boundaries
and completing the shape by replacing background pixels (0) inside the perimeter
with the perimeter color. The solution is visually intuitive, relying on pattern
recognition of enclosed areas rather than numerical computations or complex
transformations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    grid_input = [[0] * width for _ in range(height)]
    r = random.randint(0, height - 3)
    c = random.randint(0, width - 3)
    h = random.randint(3, height - r)
    w = random.randint(3, width - c)
    color = random.randint(1, 9)
    
    for col in range(c, c + w):
        grid_input[r][col] = color
        grid_input[r + h - 1][col] = color
    for row in range(r + 1, r + h - 1):
        grid_input[row][c] = color
        grid_input[row][c + w - 1] = color
    
    grid_output = [row[:] for row in grid_input]
    for row in range(r + 1, r + h - 1):
        for col in range(c + 1, c + w - 1):
            grid_output[row][col] = color
    return {"input": grid_input, "output": grid_output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    color = None
    for row in input_grid:
        for val in row:
            if val != 0:
                color = val
                break
        if color is not None:
            break
    if color is None:
        return input_grid
    
    min_r, max_r, min_c, max_c = float('inf'), -1, float('inf'), -1
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] == color:
                min_r = min(min_r, r)
                max_r = max(max_r, r)
                min_c = min(min_c, c)
                max_c = max(max_c, c)
    
    output_grid = [list(row) for row in input_grid]
    for r in range(min_r + 1, max_r):
        for c in range(min_c + 1, max_c):
            output_grid[r][c] = color
    return output_grid
