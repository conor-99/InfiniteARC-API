# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 6b18439b
Difficulty: medium

=== Tags ===
- Associate patterns to colors
- Image juxtaposition
- Fill between lines
- Image within image

=== Description ===
The task involves transforming an input grid into an output grid by filling the
background (value 0) regions between parallel lines of the same color. The input
grid contains one or more pairs of parallel lines (horizontal or vertical) of
color C. The output grid fills all background cells strictly between each pair
of parallel lines with color C, while preserving non-background cells (value >
0) within these regions. The inner image (non-background pattern) within the
filled region remains unchanged. This operation associates the line color C with
the filling color, demonstrating "image within image" (the inner pattern is
preserved) and "fill between lines" (background between lines is filled). "Image
juxtaposition" is reflected in the placement of lines creating distinct regions,
with each line pair independently processed. The transformation requires
recognizing line pairs and applying background filling without altering existing
non-background structures.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    width = common.randint(5, 30)
    height = common.randint(5, 30)
    grid = [[0] * width for _ in range(height)]
    color = common.randint(1, 9)
    direction = common.choice(['horizontal', 'vertical'])
    
    if direction == 'horizontal':
        r1 = common.randint(0, height - 3)
        r2 = common.randint(r1 + 2, height - 1)
        c1 = common.randint(0, width - 2)
        c2 = common.randint(c1 + 1, width - 1)
        
        for c in range(c1, c2 + 1):
            grid[r1][c] = color
            grid[r2][c] = color
        
        r_mid = common.randint(r1 + 1, r2 - 1)
        c_mid = common.randint(c1, c2)
        grid[r_mid][c_mid] = common.randint(1, 9)
        while grid[r_mid][c_mid] == color:
            grid[r_mid][c_mid] = common.randint(1, 9)
    else:
        c1 = common.randint(0, width - 3)
        c2 = common.randint(c1 + 2, width - 1)
        r1 = common.randint(0, height - 2)
        r2 = common.randint(r1 + 1, height - 1)
        
        for r in range(r1, r2 + 1):
            grid[r][c1] = color
            grid[r][c2] = color
        
        c_mid = common.randint(c1 + 1, c2 - 1)
        r_mid = common.randint(r1, r2)
        grid[r_mid][c_mid] = common.randint(1, 9)
        while grid[r_mid][c_mid] == color:
            grid[r_mid][c_mid] = common.randint(1, 9)
    
    output = [row[:] for row in grid]
    if direction == 'horizontal':
        for r in range(r1 + 1, r2):
            for c in range(c1, c2 + 1):
                if grid[r][c] == 0:
                    output[r][c] = color
    else:
        for c in range(c1 + 1, c2):
            for r in range(r1, r2 + 1):
                if grid[r][c] == 0:
                    output[r][c] = color
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output = [list(row) for row in input_grid]
    
    for color in range(1, 10):
        horizontal_segments = []
        for r in range(height):
            left = None
            right = None
            for c in range(width):
                if input_grid[r][c] == color:
                    if left is None:
                        left = c
                    right = c
            if left is not None:
                horizontal_segments.append((r, left, right))
        
        for i in range(len(horizontal_segments)):
            for j in range(i + 1, len(horizontal_segments)):
                r1, l1, r1_end = horizontal_segments[i]
                r2, l2, r2_end = horizontal_segments[j]
                if l1 == l2 and r1_end == r2_end:
                    start_r = min(r1, r2)
                    end_r = max(r1, r2)
                    for r in range(start_r + 1, end_r):
                        for c in range(l1, r1_end + 1):
                            if input_grid[r][c] == 0:
                                output[r][c] = color
        
        vertical_segments = []
        for c in range(width):
            top = None
            bottom = None
            for r in range(height):
                if input_grid[r][c] == color:
                    if top is None:
                        top = r
                    bottom = r
            if top is not None:
                vertical_segments.append((c, top, bottom))
        
        for i in range(len(vertical_segments)):
            for j in range(i + 1, len(vertical_segments)):
                c1, t1, b1 = vertical_segments[i]
                c2, t2, b2 = vertical_segments[j]
                if t1 == t2 and b1 == b2:
                    start_c = min(c1, c2)
                    end_c = max(c1, c2)
                    for c in range(start_c + 1, end_c):
                        for r in range(t1, b1 + 1):
                            if input_grid[r][c] == 0:
                                output[r][c] = color
    return output
