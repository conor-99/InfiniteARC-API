# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 71d34ada
Difficulty: mediumâ€“hard

=== Tags ===
- Emergent behavior
- Loopless feedback
- Measure area
- Propagate color until boundary

=== Description ===
Input grids feature a background color, multiple disconnected colored regions
(each a contiguous group of cells), and single-cell-thick boundary walls forming
irregular obstacles. Each colored region's color propagates outward in all four
cardinal directions (up, down, left, right) until encountering a boundary wall,
expanding to fill all reachable cells without crossing walls. Propagation is
loopless: each cell is processed exactly once, moving outward from the original
region. The output grid retains the boundary walls and background, while the
colored regions are expanded to fill all cells reachable from their original
positions. The 'measure area' aspect refers to the visual measurement of
original region sizes, which dictates propagation extent before boundary
contact. 'Emergent behavior' arises from the complex, non-linear patterns formed
by multiple propagations interacting with irregular boundary configurations,
creating output patterns that cannot be deduced by simple local transformations
alone. 'Loopless feedback' ensures propagation follows a single-directional path
without recursive or cyclic dependencies, maintaining deterministic behavior.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Try building an interesting wall layout until we can place at least two regions
    for attempt in range(100):
        width = random.randint(10, 20)
        height = random.randint(10, 20)
        grid_in = grid(width, height, 0)

        # Create a few full-length (single-cell-thick) walls with a single gap to form compartments
        for _ in range(random.randint(1, 3)):
            r = random.randint(1, max(1, height - 2))
            gap = random.randint(0, width - 1)
            for c in range(width):
                if c == gap:
                    continue
                grid_in[r][c] = 9
        for _ in range(random.randint(1, 3)):
            c = random.randint(1, max(1, width - 2))
            gap = random.randint(0, height - 1)
            for r in range(height):
                if r == gap:
                    continue
                grid_in[r][c] = 9

        # Add some irregular single-cell-thick wall segments using short random walks
        for _ in range(random.randint(2, 6)):
            r = random.randint(0, height - 1)
            c = random.randint(0, width - 1)
            length = random.randint(max(width, height) // 2, max(width, height))
            for _s in range(length):
                grid_in[r][c] = 9
                dr, dc = random.choice([(1, 0), (-1, 0), (0, 1), (0, -1)])
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    r, c = nr, nc
                else:
                    r = random.randint(0, height - 1)
                    c = random.randint(0, width - 1)

        # Find connected components of non-wall cells (cells that are not 9)
        visited = [[False] * width for _ in range(height)]
        components = []
        for r in range(height):
            for c in range(width):
                if visited[r][c] or grid_in[r][c] == 9:
                    continue
                comp = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    rr, cc = stack.pop()
                    comp.append((rr, cc))
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = rr + dr, cc + dc
                        if (
                            0 <= nr < height
                            and 0 <= nc < width
                            and not visited[nr][nc]
                            and grid_in[nr][nc] != 9
                        ):
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append(comp)

        # Keep only components large enough to host a small region
        comp_candidates = [comp for comp in components if len(comp) >= 3]
        if len(comp_candidates) < 2:
            # not enough separated areas, try again
            continue

        num_regions = random.randint(2, min(4, len(comp_candidates)))
        chosen_components = random.sample(comp_candidates, num_regions)

        # Pick distinct colors for the regions
        colors = random.sample(list(range(1, 9)), num_regions)

        # Place small contiguous seed regions inside chosen components
        grid_out = [row[:] for row in grid_in]
        seeds_by_color = {}
        for color, comp in zip(colors, chosen_components):
            size = random.randint(1, 4)
            possible = [cell for cell in comp if grid_in[cell[0]][cell[1]] == 0]
            if not possible:
                # unexpected, skip this component
                continue
            start = random.choice(possible)
            shape = [start]
            comp_set = set(comp)
            # Grow a small contiguous creature inside the component
            while len(shape) < size:
                neighbors = []
                for (sr, sc) in shape:
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = sr + dr, sc + dc
                        if (
                            (nr, nc) in comp_set
                            and (nr, nc) not in shape
                            and grid_in[nr][nc] == 0
                        ):
                            neighbors.append((nr, nc))
                if not neighbors:
                    break
                shape.append(random.choice(neighbors))

            seeds_by_color[color] = shape
            for (rr, cc) in shape:
                grid_in[rr][cc] = color
                grid_out[rr][cc] = color

        if not seeds_by_color:
            # no seeds placed, try again
            continue

        # Expand each color outward (deterministically in ascending color order)
        for color in sorted(seeds_by_color.keys()):
            queue = seeds_by_color[color].copy()
            while queue:
                rr, cc = queue.pop(0)
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        if grid_in[nr][nc] == 9:
                            # can't cross walls
                            continue
                        # only fill previously-unfilled background cells
                        if grid_out[nr][nc] == 0:
                            grid_out[nr][nc] = color
                            queue.append((nr, nc))

        # Ensure the output actually changed something
        if grid_in != grid_out:
            return {"input": grid_in, "output": grid_out}

    # Fallback deterministic small pattern (should rarely be used)
    width, height = 10, 10
    grid_in = grid(width, height, 0)
    for r in range(height):
        grid_in[r][width // 2] = 9
    grid_in[1][1] = 3
    grid_in[height - 2][width - 2] = 4
    grid_out = [row[:] for row in grid_in]
    for r in range(height):
        for c in range(width // 2):
            if grid_out[r][c] == 0:
                grid_out[r][c] = 3
    for r in range(height):
        for c in range(width // 2 + 1, width):
            if grid_out[r][c] == 0:
                grid_out[r][c] = 4
    return {"input": grid_in, "output": grid_out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert tuple-of-tuples to mutable list-of-lists
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])

    grid_out = [row[:] for row in grid_in]

    # Collect the seed pixels for each color (exclude background 0 and wall 9)
    seeds_by_color = {}
    for r in range(height):
        for c in range(width):
            val = grid_in[r][c]
            if val != 0 and val != 9:
                seeds_by_color.setdefault(val, []).append((r, c))

    # Expand colors in deterministic ascending order to match the generator
    for color in sorted(seeds_by_color.keys()):
        queue = list(seeds_by_color[color])
        while queue:
            rr, cc = queue.pop(0)
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = rr + dr, cc + dc
                if 0 <= nr < height and 0 <= nc < width:
                    if grid_in[nr][nc] == 9:
                        continue
                    if grid_out[nr][nc] == 0:
                        grid_out[nr][nc] = color
                        queue.append((nr, nc))

    return grid_out

