# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 79054468
Difficulty: medium–hard

=== Tags ===
- Perimeter smoothing
- Meta rule switching
- Local convolution rule
- Paint outer ring
- Contouring

=== Description ===
Input grids consist of a single, connected shape (color C, C ≠ 0) on a uniform
background (color 0). The shape exhibits jagged, irregular perimeter edges with
numerous corners and indentations. The output grid applies two sequential
transformations:  1. **Perimeter Smoothing via Local Convolution**: For each
cell in the shape (C), examine its 8-directional neighbors. If a cell has
exactly two diagonally adjacent background cells (0), it is replaced with a new
color (C_smooth = (C + 1) % 9, with 0 excluded). This targets sharp corners to
create a smoother contour, applied simultaneously to all qualifying cells
without altering other shape cells.  2. **Meta Rule Switching for Outer Ring**:
After smoothing, a single-cell-wide outer ring is painted around the entire
smoothed shape. The ring's color is determined by a meta-rule based on the
original shape's color C: if C is even (2, 4, 6, 8), the ring uses color (C + 2)
% 9; if C is odd (1, 3, 5, 7), it uses color (C + 3) % 9. The ring is painted
only on background cells (0) immediately adjacent to the smoothed shape's
perimeter, preserving all other background cells as 0.  The transformation
preserves all non-perimeter shape cells and ensures the smoothed perimeter
becomes the new contour, while the outer ring's color dynamically adapts to the
original shape's properties. No cells are overwritten beyond the specified
rules, and the output grid maintains visual coherence with all transformations
applied in strict sequence.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, continuous_creature
def generate():
    grid_size = random.randint(5, 30)
    C = random.randint(1, 9)
    shape_size = random.randint(5, grid_size * grid_size // 4)
    shape_pixels = continuous_creature(shape_size, grid_size, grid_size)
    input_grid = grid(grid_size, grid_size, 0)
    for r, c in shape_pixels:
        input_grid[r][c] = C
    output_grid = [row[:] for row in input_grid]
    for r, c in shape_pixels:
        diag_count = 0
        for dr, dc in [(-1, -1), (-1, 1), (1, -1), (1, 1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < grid_size and 0 <= nc < grid_size and input_grid[nr][nc] == 0:
                diag_count += 1
        if diag_count == 2:
            new_color = (C % 9) + 1
            output_grid[r][c] = new_color
    if C % 2 == 0:
        ring_color = (C + 2) % 9
    else:
        ring_color = (C + 3) % 9
    if ring_color == 0:
        ring_color = 9
    for r in range(grid_size):
        for c in range(grid_size):
            if output_grid[r][c] != 0:
                for dr in [-1, 0, 1]:
                    for dc in [-1, 0, 1]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < grid_size and 0 <= nc < grid_size and output_grid[nr][nc] == 0:
                            output_grid[nr][nc] = ring_color
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    C = None
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            if grid[r][c] != 0:
                C = grid[r][c]
                break
        if C is not None:
            break
    if C is None:
        return input_grid
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            if grid[r][c] == C:
                diag_count = 0
                for dr, dc in [(-1, -1), (-1, 1), (1, -1), (1, 1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == 0:
                        diag_count += 1
                if diag_count == 2:
                    new_color = (C % 9) + 1
                    grid[r][c] = new_color
    if C % 2 == 0:
        ring_color = (C + 2) % 9
    else:
        ring_color = (C + 3) % 9
    if ring_color == 0:
        ring_color = 9
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            if grid[r][c] != 0:
                for dr in [-1, 0, 1]:
                    for dc in [-1, 0, 1]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == 0:
                            grid[nr][nc] = ring_color
    return grid
