# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: a1429896
Difficulty: insane

=== Tags ===
- Pattern mirroring chain
- Rule based tiling

=== Description ===
The input grid is a 25×25 grid with a uniform background color (0). Overlaid are
8 distinct rectangular regions arranged in a staggered 3×3 grid pattern (with
variable spacing between regions, ranging from 1 to 3 background cells). Each
region has a unique border color (1–9) and contains a 4×4 central pattern
composed of two distinct colors: the border color (for the pattern's frame) and
a secondary color (2–9, not the border color). The patterns are non-orthogonal,
featuring connected shapes like spirals, zigzags, or nested diamonds.   The
"pattern mirroring chain" rule requires that for each region in the path from
top-left to bottom-right (determined by adjacency in the staggered grid), the
central pattern is mirrored in a direction sequence determined by its border
color: regions with even border colors mirror horizontally first, then
vertically (chain: H→V), while regions with odd border colors mirror vertically
first, then horizontally (chain: V→H). Each mirror operation is applied
sequentially to the pattern's shape within its region.  The "rule-based tiling"
rule dictates that the output grid replaces the background with a continuous
tiling of transformed patterns. After mirroring, the secondary color of each
region's pattern is used to draw a band between consecutive regions along the
path. The band direction alternates between horizontal and vertical based on the
mirroring chain (e.g., horizontal mirror → vertical band, vertical mirror →
horizontal band), with thickness equal to the pattern's size (4 cells). Bands
must align perfectly with the region edges, never overlapping borders or other
bands, and the pattern strip (a horizontal sequence of secondary colors along
the bottom edge) remains unchanged as a reference.  No two bands intersect, and
all transformations strictly preserve the input's region positions and adjacency
while introducing new visual patterns through the mirroring chain and tiling
rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import copy

# Simplified Generator for ARC task (fixed, reliable layout)

def generate():
    size = 25
    bg = 0
    W = 6
    H = 6

    # 4x4 pattern templates (1: border color, 0: secondary color)
    templates = [
        [[1,1,1,1],[1,0,0,1],[1,0,1,1],[1,1,1,1]],
        [[1,1,1,1],[1,0,1,1],[1,0,0,1],[1,1,1,1]],
        [[1,1,0,0],[0,1,1,0],[0,0,1,1],[0,0,0,1]],
        [[1,0,0,0],[1,1,0,0],[0,1,1,0],[0,0,1,1]],
        [[0,1,1,0],[1,1,0,0],[0,0,1,1],[0,1,1,0]],
        [[0,1,0,0],[1,1,1,0],[0,1,0,1],[0,0,1,0]],
        [[0,1,0,0],[1,0,1,0],[0,1,0,1],[0,0,1,0]],
        [[1,0,1,0],[1,1,0,0],[0,1,1,0],[0,0,1,1]]
    ]

    # Fixed top-left positions for the 8 regions (staggered 3x3 grid missing bottom-right)
    region_positions = [(3,3),(3,10),(3,17),
                        (10,3),(10,10),(10,17),
                        (17,3),(17,10)]

    # Path: row-major order of the above positions
    path_positions = sorted(region_positions, key=lambda pos: (pos[0], pos[1]))

    # Determine parity-required positions based on adjacency orientation between consecutive path nodes
    odd_indices = []
    even_indices = []
    for i in range(len(path_positions)-1):
        r1,c1 = path_positions[i]
        r2,c2 = path_positions[i+1]
        if r1 == r2:
            odd_indices.append(i)
        else:
            even_indices.append(i)

    # Choose border colors to match parity requirements (odd->1,3,5,7,9 ; even->2,4,6,8)
    odd_vals = [1,3,5,7,9]
    even_vals = [2,4,6,8]
    border_colors = [None] * len(path_positions)
    chosen_odds = random.sample(odd_vals, len(odd_indices))
    chosen_evens = random.sample(even_vals, len(even_indices))
    for idx, val in zip(odd_indices, chosen_odds):
        border_colors[idx] = val
    for idx, val in zip(even_indices, chosen_evens):
        border_colors[idx] = val
    # assign last position a remaining color unique
    used = set([c for c in border_colors if c is not None])
    remaining = [c for c in range(1,10) if c not in used]
    border_colors[-1] = random.choice(remaining)

    # Ensure uniqueness
    if len(set(border_colors)) != len(border_colors):
        # fallback: sample any 8 unique colors
        border_colors = random.sample(list(range(1,10)), len(path_positions))

    # Assign unique secondary colors (2..9) with sec[i] != border[i]
    def assign_secondaries(border_colors):
        candidates = list(range(2,10))
        N = len(border_colors)
        assigned = [None] * N
        used = set()
        def backtrack(i):
            if i == N:
                return True
            for c in candidates:
                if c in used: continue
                if c == border_colors[i]: continue
                used.add(c)
                assigned[i] = c
                if backtrack(i+1):
                    return True
                used.remove(c)
                assigned[i] = None
            return False
        if not backtrack(0):
            # Shouldn't happen, but as a fallback allow duplicates per-region
            assigned = []
            for b in border_colors:
                choices = [c for c in candidates if c != b]
                assigned.append(random.choice(choices))
        return assigned

    secondary_colors = assign_secondaries(border_colors)

    # Choose pattern templates for each region
    pattern_choices = [random.choice(templates) for _ in range(len(path_positions))]

    # Build input grid
    grid_input = [[bg for _ in range(size)] for _ in range(size)]

    # Place border frames
    for (rpos, cpos), border in zip(path_positions, border_colors):
        for dr in range(H):
            for dc in range(W):
                rr = rpos + dr
                cc = cpos + dc
                if 0 <= rr < size and 0 <= cc < size:
                    if dr == 0 or dr == H-1 or dc == 0 or dc == W-1:
                        grid_input[rr][cc] = border

    # Place central 4x4 patterns
    for (rpos, cpos), tpl, border, sec in zip(path_positions, pattern_choices, border_colors, secondary_colors):
        for dr in range(4):
            for dc in range(4):
                rr = rpos + 1 + dr
                cc = cpos + 1 + dc
                if tpl[dr][dc] == 1:
                    grid_input[rr][cc] = border
                else:
                    grid_input[rr][cc] = sec

    # Place bottom pattern strip using secondary colors in path order
    for i, sec in enumerate(secondary_colors):
        if i < size:
            grid_input[-1][i] = sec

    # Build output
    grid_output = copy.deepcopy(grid_input)

    # Apply mirroring chain to each region and record mirrored patterns
    mirrored_patterns = []
    for (rpos, cpos), border in zip(path_positions, border_colors):
        pattern = [list(grid_input[rpos + 1 + dr][cpos + 1:cpos + 5]) for dr in range(4)]
        if border % 2 == 0:
            pattern = [row[::-1] for row in pattern]
            pattern = pattern[::-1]
        else:
            pattern = pattern[::-1]
            pattern = [row[::-1] for row in pattern]
        # place mirrored pattern
        for dr in range(4):
            for dc in range(4):
                rr = rpos + 1 + dr
                cc = cpos + 1 + dc
                grid_output[rr][cc] = pattern[dr][dc]
        mirrored_patterns.append(pattern)

    # Determine tile offsets so that region central blocks align to tiles
    tile_row_offset = (path_positions[0][0] + 1) % 4
    tile_col_offset = (path_positions[0][1] + 1) % 4
    tile_row_starts = list(range(tile_row_offset, size, 4))
    tile_col_starts = list(range(tile_col_offset, size, 4))
    tile_rows_count = len(tile_row_starts)
    tile_cols_count = len(tile_col_starts)

    # Tile the background with mirrored patterns (do not overwrite region borders or bottom strip)
    for tr_idx, tr in enumerate(tile_row_starts):
        for tc_idx, tc in enumerate(tile_col_starts):
            tile_idx = (tr_idx * tile_cols_count + tc_idx) % len(mirrored_patterns)
            patt = mirrored_patterns[tile_idx]
            for dr in range(4):
                for dc in range(4):
                    r = tr + dr
                    c = tc + dc
                    if r >= size or c >= size:
                        continue
                    if r == size - 1:
                        continue
                    if grid_input[r][c] == 0:
                        grid_output[r][c] = patt[dr][dc]

    # Draw bands between consecutive regions (using adjacency defined by row-equality or column-equality)
    for idx in range(len(path_positions) - 1):
        (r1, c1) = path_positions[idx]
        (r2, c2) = path_positions[idx+1]
        band_color = secondary_colors[idx]
        if r1 == r2:
            for row in range(r1 + 1, r1 + 5):
                for col in range(c1 + W, c2):
                    if 0 <= row < size and 0 <= col < size and grid_input[row][col] == 0:
                        grid_output[row][col] = band_color
        else:
            for col in range(c1 + 1, c1 + 5):
                for row in range(r1 + H, r2):
                    if 0 <= row < size and 0 <= col < size and grid_input[row][col] == 0:
                        grid_output[row][col] = band_color

    return {"input": grid_input, "output": grid_output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    size = len(grid)
    W = 6
    H = 6

    # Detect 6x6 region frames by scanning for uniform border rings
    region_tops = []
    for r in range(size - 5):
        for c in range(size - 5):
            color = grid[r][c]
            if color == 0:
                continue
            ok = True
            for dr in range(H):
                for dc in range(W):
                    rr = r + dr
                    cc = c + dc
                    if dr == 0 or dr == H-1 or dc == 0 or dc == W-1:
                        if grid[rr][cc] != color:
                            ok = False
                            break
                if not ok:
                    break
            if ok:
                region_tops.append((r, c, color))

    # Unique top-left coords
    seen = set()
    unique = []
    for r,c,col in region_tops:
        if (r,c) in seen:
            continue
        seen.add((r,c))
        unique.append((r,c,col))
    region_tops = unique

    # Sort detected regions row-major
    region_tops_sorted = sorted(region_tops, key=lambda t: (t[0], t[1]))

    # Build mapping of central secondary colors
    secondary_colors = []
    border_colors = []
    region_positions = []
    for rpos, cpos, bcol in region_tops_sorted:
        region_positions.append((rpos, cpos))
        border_colors.append(bcol)
        vals = set()
        for dr in range(4):
            for dc in range(4):
                vals.add(grid[rpos + 1 + dr][cpos + 1 + dc])
        if bcol in vals:
            vals.remove(bcol)
        if vals:
            # pick the non-border color
            sec = vals.pop()
        else:
            sec = bcol
        secondary_colors.append(sec)

    # Bottom strip determines path order (left-to-right first N entries)
    N = len(region_positions)
    bottom_strip = [grid[-1][i] for i in range(N)]

    # Map bottom strip colors to regions
    sec_to_idx = {sec: i for i, sec in enumerate(secondary_colors)}
    path_order = []
    used = set()
    for col in bottom_strip:
        if col in sec_to_idx:
            idx = sec_to_idx[col]
            if idx in used:
                # already used; pick next unused
                for j in range(N):
                    if j not in used:
                        idx = j
                        break
            path_order.append(idx)
            used.add(idx)
        else:
            for j in range(N):
                if j not in used:
                    path_order.append(j)
                    used.add(j)
                    break
    # append any remaining indices
    for j in range(N):
        if j not in used:
            path_order.append(j)
            used.add(j)

    # Build path-based lists
    ordered_region_positions = [region_positions[i] for i in path_order]
    ordered_border_colors = [border_colors[i] for i in path_order]
    ordered_secondary_colors = [secondary_colors[i] for i in path_order]

    # Extract original 4x4 patterns and compute mirrored versions
    mirrored_patterns = []
    for (rpos, cpos), bcol in zip(ordered_region_positions, ordered_border_colors):
        pat = [list(grid[rpos + 1 + dr][cpos + 1:cpos + 5]) for dr in range(4)]
        if bcol % 2 == 0:
            pat = [row[::-1] for row in pat]
            pat = pat[::-1]
        else:
            pat = pat[::-1]
            pat = [row[::-1] for row in pat]
        mirrored_patterns.append(pat)

    # Start constructing the output
    out = [row[:] for row in grid]

    # Place mirrored central patterns
    for (rpos, cpos), pat in zip(ordered_region_positions, mirrored_patterns):
        for dr in range(4):
            for dc in range(4):
                out[rpos + 1 + dr][cpos + 1 + dc] = pat[dr][dc]

    # Tile offsets (use first detected region as anchor)
    tile_row_offset = (ordered_region_positions[0][0] + 1) % 4
    tile_col_offset = (ordered_region_positions[0][1] + 1) % 4
    tile_row_starts = list(range(tile_row_offset, size, 4))
    tile_col_starts = list(range(tile_col_offset, size, 4))
    tile_rows_count = len(tile_row_starts)
    tile_cols_count = len(tile_col_starts)

    # Tile the background with mirrored patterns
    for tr_idx, tr in enumerate(tile_row_starts):
        for tc_idx, tc in enumerate(tile_col_starts):
            tile_idx = (tr_idx * tile_cols_count + tc_idx) % len(mirrored_patterns)
            patt = mirrored_patterns[tile_idx]
            for dr in range(4):
                for dc in range(4):
                    r = tr + dr
                    c = tc + dc
                    if r >= size or c >= size:
                        continue
                    if r == size - 1:
                        continue
                    if grid[r][c] == 0:
                        out[r][c] = patt[dr][dc]

    # Draw bands between consecutive regions along path_order
    for idx in range(len(ordered_region_positions) - 1):
        r1, c1 = ordered_region_positions[idx]
        r2, c2 = ordered_region_positions[idx+1]
        band_color = ordered_secondary_colors[idx]
        if r1 == r2:
            for row in range(r1 + 1, r1 + 5):
                for col in range(c1 + W, c2):
                    if 0 <= row < size and 0 <= col < size and grid[row][col] == 0:
                        out[row][col] = band_color
        else:
            for col in range(c1 + 1, c1 + 5):
                for row in range(r1 + H, r2):
                    if 0 <= row < size and 0 <= col < size and grid[row][col] == 0:
                        out[row][col] = band_color

    # Ensure bottom strip unchanged
    for i in range(len(ordered_secondary_colors)):
        if i < size:
            out[-1][i] = grid[-1][i]

    return out

