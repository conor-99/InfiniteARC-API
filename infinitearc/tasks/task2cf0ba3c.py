# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 2cf0ba3c
Difficulty: very hard

=== Tags ===
- Mask based logic
- Propagation by rule weight
- Adaptive behavior switch

=== Description ===
Input grids feature a background of neutral color (0) overlaid with multiple
disjoint, connected regions (masks) of distinct non-neutral colors (1-9). Each
mask is a contiguous area (4-connected) of a single color. The output grid is
generated through the following multi-step process:  1. **Mask Weight
Assignment**: Each mask's color value (1-9) defines its rule weight, with higher
values indicating stronger propagation influence. This weight determines both
the reach and priority of the mask's influence.  2. **Propagation Waveform**:
From each mask, a wave propagates outward in all four cardinal directions. The
wave's maximum reach is determined by the mask's rule weight (e.g., weight 9
propagates 9 cells in all directions), but is interrupted by other masks, grid
edges, or stronger waves from higher-weight masks.  3. **Priority Resolution**:
For any background cell (color 0), the output color is selected from the
influencing masks based on the highest rule weight. In case of equal weights,
the closest mask determines the color. Waves from higher-weight masks override
lower-weight waves.  4. **Adaptive Edge Behavior**: When a propagation wave
encounters a grid edge, its direction adapts based on the edge type: horizontal
edges (top/bottom) cause vertical propagation, while vertical edges (left/right)
cause horizontal propagation. This creates "bouncing" waves that continue
propagating along the new axis without changing their path length.  5.
**Wavefront Merging**: When waves from multiple masks overlap, the highest-
weight wave dominates. This creates complex, non-overlapping color regions that
expand from each mask until they meet, hit an edge, or are blocked by a higher-
weight wave.  The output grid retains all mask regions unchanged, replaces
background cells with the color of the dominant influencing mask (based on rule
weight and proximity), and applies adaptive edge behavior to ensure waves
reflect off boundaries. The resulting grid displays a dynamic interplay of color
regions shaped by mask weights, propagation limits, and edge adaptation, with no
cell influenced by multiple masks of equal weight. The transformation requires
simultaneous consideration of distance, weight priority, and directional
adaptation to deduce the correct output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = random.randint(15, 30)
    height = random.randint(15, 30)
    grid = [[0] * width for _ in range(height)]
    masks = []
    used_colors = []
    num_masks = random.randint(3, 5)
    
    for _ in range(num_masks):
        color = common.random_color(exclude=used_colors)
        used_colors.append(color)
        size = random.randint(2, 5)
        pixels = common.continuous_creature(size, 3, 3)
        placed = False
        for _ in range(100):
            r_start = random.randint(0, height - 3)
            c_start = random.randint(0, width - 3)
            valid = True
            for (r, c) in pixels:
                r_pos = r_start + r
                c_pos = c_start + c
                if r_pos >= height or c_pos >= width or grid[r_pos][c_pos] != 0:
                    valid = False
                    break
            if valid:
                for (r, c) in pixels:
                    r_pos = r_start + r
                    c_pos = c_start + c
                    grid[r_pos][c_pos] = color
                masks.append((color, [(r_start + r, c_start + c) for (r, c) in pixels]))
                placed = True
                break
        if not placed:
            r_start = 0
            c_start = 0
            for (r, c) in pixels:
                r_pos = r_start + r
                c_pos = c_start + c
                if r_pos < height and c_pos < width:
                    grid[r_pos][c_pos] = color
            masks.append((color, [(r_start + r, c_start + c) for (r, c) in pixels]))
    
    output = [row[:] for row in grid]
    mask_groups = {}
    for color, positions in masks:
        mask_groups[color] = positions
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0:
                best_color = 0
                best_weight = 0
                best_dist = float('inf')
                for color, positions in mask_groups.items():
                    min_dist = float('inf')
                    for (mask_r, mask_c) in positions:
                        dist = abs(r - mask_r) + abs(c - mask_c)
                        if dist < min_dist:
                            min_dist = dist
                    if color > best_weight or (color == best_weight and min_dist < best_dist):
                        best_weight = color
                        best_dist = min_dist
                        best_color = color
                output[r][c] = best_color
    
    return {'input': grid, 'output': output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random
import common

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    height = len(input_list)
    width = len(input_list[0])
    
    mask_groups = {}
    for r in range(height):
        for c in range(width):
            color = input_list[r][c]
            if color != 0:
                if color not in mask_groups:
                    mask_groups[color] = []
                mask_groups[color].append((r, c))
    
    output = [row[:] for row in input_list]
    
    for r in range(height):
        for c in range(width):
            if input_list[r][c] == 0:
                best_color = 0
                best_weight = 0
                best_dist = float('inf')
                for color, positions in mask_groups.items():
                    min_dist = float('inf')
                    for (mask_r, mask_c) in positions:
                        dist = abs(r - mask_r) + abs(c - mask_c)
                        if dist < min_dist:
                            min_dist = dist
                    if color > best_weight or (color == best_weight and min_dist < best_dist):
                        best_weight = color
                        best_dist = min_dist
                        best_color = color
                output[r][c] = best_color
    
    return tuple(tuple(row) for row in output)
