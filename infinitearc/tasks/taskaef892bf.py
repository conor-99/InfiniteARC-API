# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: aef892bf
Difficulty: insane

=== Tags ===
- Shape morphing
- Momentum transfer
- Count shapes
- Pattern resizing

=== Description ===
Input grids are 15×15 or larger, featuring a background color (0) and multiple
distinct shapes (each a connected region of a single color 1-9), where each
shape's geometric form is visually identifiable (e.g., solid square, diamond,
triangle, or line segment). Shapes are fully surrounded by background, with no
overlapping or touching edges.  The transformation sequence is as follows:   1.
**Count Shapes**: Identify all diamond-shaped regions (visualized as filled
diamond patterns where cells form a symmetric diamond boundary around a central
cell). Let N be the count of such diamond shapes.   2. **Momentum Transfer**:
For each non-diamond shape, expand its bounding box outward by N cells in all
four directions (top, bottom, left, right), clipping to grid boundaries.
Expansion preserves shape connectivity but may shift the shape's position to
avoid overlapping other shapes.   3. **Shape Morphing**: Morph each expanded
shape into the next form in a cyclic sequence (square → rectangle → triangle →
diamond → square...), adjusting cell arrangement to match the new form while
maintaining connectivity.   4. **Pattern Resizing**: Scale the morphed shape's
area to exactly N times its original area. If N × original area is not grid-
aligned, use the closest possible arrangement (prioritizing vertical alignment),
ensuring all cells remain connected.    Output grids display all transformed
shapes with background unchanged, where no shape overlaps, all shapes fit within
grid boundaries, and the transformation strictly follows the visual rules
without numerical dependencies.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import math
import common

# Generator for ARC task 441
# Produces an input grid with diamonds and other shapes and an output grid
# following the specified transformation rules.

def generate():
    random.seed()
    # Grid size between 15 and 20
    size = random.randint(15, 20)
    grid = common.grid(size, size, 0)

    occupied = set()  # cells occupied by any placed shape

    # Helper: 4-neighbors
    def neighbors4(r, c):
        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
            yield r + dr, c + dc

    def in_bounds(r, c):
        return 0 <= r < size and 0 <= c < size

    # Manhattan-diamond pixels for center and radius
    def diamond_pixels(cr, cc, radius):
        pts = []
        for dr in range(-radius, radius + 1):
            rem = radius - abs(dr)
            for dc in range(-rem, rem + 1):
                pts.append((cr + dr, cc + dc))
        return pts

    # Check that a set of pixels can be placed (no overlap and no orthogonal adjacency)
    def can_place(pixels, margin=0):
        for (r, c) in pixels:
            if not in_bounds(r, c):
                return False
            if (r, c) in occupied:
                return False
            # check adjacency with existing shapes (must not touch edges)
            for nr, nc in neighbors4(r, c):
                if (nr, nc) in occupied:
                    return False
            # check margin area for future expansion if margin>0
            if margin > 0:
                # ensure any cell within manhattan distance <= margin is free of other shapes
                for dr in range(-margin, margin + 1):
                    rem = margin - abs(dr)
                    for dc in range(-rem, rem + 1):
                        rr, cc = r + dr, c + dc
                        if (rr, cc) in occupied:
                            return False
                        if not in_bounds(rr, cc):
                            # if expansion would go out of bounds, that's okay; we allow clipping
                            pass
        return True

    # Place pixels into grid with a color and mark occupied
    def place_pixels(pixels, color):
        for (r, c) in pixels:
            grid[r][c] = color
            occupied.add((r, c))

    colors = list(range(1, 10))
    random.shuffle(colors)
    color_iter = iter(colors)

    # Decide number of diamonds N (1..3)
    N = random.randint(1, 3)

    diamonds = []
    attempts = 0
    # Place N diamonds of radius 1 or 2
    for i in range(N):
        placed = False
        for _ in range(200):
            attempts += 1
            radius = random.choice([1, 2])
            cr = random.randint(radius + 1, size - radius - 2)
            cc = random.randint(radius + 1, size - radius - 2)
            pts = diamond_pixels(cr, cc, radius)
            if not can_place(pts, margin=0):
                continue
            color = next(color_iter)
            place_pixels(pts, color)
            diamonds.append({
                'center': (cr, cc),
                'radius': radius,
                'pixels': set(pts),
                'color': color
            })
            placed = True
            break
        if not placed:
            # failed to place diamonds safely, restart generation
            return generate()

    # Reserve a margin to avoid overlapping when shapes expand by N
    margin = N + 1

    # Generate non-diamond shapes (2..4)
    non_diamonds = []
    M = random.randint(2, 4)

    def square_pixels(top, left, side):
        return [(r, c) for r in range(top, top + side) for c in range(left, left + side)]

    def rectangle_pixels(top, left, h, w):
        return [(r, c) for r in range(top, top + h) for c in range(left, left + w)]

    def right_triangle_pixels(top, left, height):
        # left-aligned right triangle with row lengths 1..height
        pts = []
        for i in range(height):
            length = i + 1
            for c in range(left, left + length):
                pts.append((top + i, c))
        return pts

    def line_pixels(top, left, length, vertical=False):
        if vertical:
            return [(top + i, left) for i in range(length)]
        else:
            return [(top, left + i) for i in range(length)]

    for _ in range(M):
        placed = False
        for _try in range(300):
            shape_type = random.choice(['square', 'rectangle', 'triangle', 'line_h', 'line_v'])
            if shape_type == 'square':
                side = random.randint(2, 3)
                top = random.randint(margin, size - margin - side)
                left = random.randint(margin, size - margin - side)
                pts = square_pixels(top, left, side)
            elif shape_type == 'rectangle':
                h = random.randint(2, 3)
                w = random.randint(2, 4)
                top = random.randint(margin, size - margin - h)
                left = random.randint(margin, size - margin - w)
                pts = rectangle_pixels(top, left, h, w)
            elif shape_type == 'triangle':
                h = random.randint(2, 4)
                top = random.randint(margin, size - margin - h)
                left = random.randint(margin, size - margin - h)  # ensure enough width
                pts = right_triangle_pixels(top, left, h)
            elif shape_type == 'line_h':
                length = random.randint(3, 5)
                top = random.randint(margin, size - margin - 1)
                left = random.randint(margin, size - margin - length)
                pts = line_pixels(top, left, length, vertical=False)
            else:  # line_v
                length = random.randint(3, 5)
                top = random.randint(margin, size - margin - length)
                left = random.randint(margin, size - margin - 1)
                pts = line_pixels(top, left, length, vertical=True)

            pts_set = set(pts)
            # ensure fits and not adjacent to any existing shape, and safe for future expansion (margin)
            if not can_place(pts_set, margin=margin):
                continue
            color = next(color_iter)
            place_pixels(pts, color)
            # store metadata
            min_r = min(p[0] for p in pts)
            min_c = min(p[1] for p in pts)
            max_r = max(p[0] for p in pts)
            max_c = max(p[1] for p in pts)
            non_diamonds.append({
                'type': shape_type,
                'pixels': pts_set,
                'color': color,
                'bbox': (min_r, min_c, max_r, max_c)
            })
            placed = True
            break
        if not placed:
            # fail safe restart
            return generate()

    # Build output grid by transforming non-diamond shapes
    out = [row[:] for row in grid]

    # Utility: detect shape type from pixels (consistent with generator)
    def detect_type(pixels):
        # pixels: set of (r,c)
        min_r = min(r for r, c in pixels)
        max_r = max(r for r, c in pixels)
        min_c = min(c for r, c in pixels)
        max_c = max(c for r, c in pixels)
        h = max_r - min_r + 1
        w = max_c - min_c + 1
        area = len(pixels)
        # diamond test
        if h == w and h % 2 == 1:
            r = (h - 1) // 2
            # center
            cr = (min_r + max_r) // 2
            cc = (min_c + max_c) // 2
            expected = set(diamond_pixels(cr, cc, r))
            if expected == pixels:
                return 'diamond'
        # square
        if h == w and area == h * w:
            return 'square'
        # rectangle
        if area == h * w:
            return 'rectangle'
        # triangle (left-aligned right triangle rows 1..H)
        # check rows
        row_lengths = []
        for rr in range(min_r, max_r + 1):
            cols = sorted([c for (r, c) in pixels if r == rr])
            if not cols:
                row_lengths.append(0)
            else:
                # check contiguous
                if cols != list(range(cols[0], cols[-1] + 1)):
                    row_lengths = None
                    break
                row_lengths.append(cols[-1] - cols[0] + 1)
        if row_lengths is not None:
            # trim zero rows at top if any
            trimmed = [l for l in row_lengths if l > 0]
            if trimmed and all(trimmed[i] == i + 1 for i in range(len(trimmed))):
                return 'triangle'
        # line
        if h == 1 or w == 1:
            return 'line'
        return 'unknown'

    # Sort non_diamonds by top-left coordinate for deterministic processing
    non_diamonds.sort(key=lambda s: (s['bbox'][0], s['bbox'][1]))

    # Build morphed shape to fit into bbox and have area target (or closest possible)
    def build_morphed(target_type, target_area, bbox_w, bbox_h):
        # cap at bbox area
        max_area = bbox_w * bbox_h
        if max_area <= 0:
            return set(), 0, 0
        desired = min(target_area, max_area)

        # Rectangle-like builder (used for rectangle and square)
        if target_type in ('rectangle', 'square'):
            # try to find w,h with h>=w and within bbox that can contain desired cells
            best = None
            for w in range(1, bbox_w + 1):
                h = (desired + w - 1) // w
                if h <= bbox_h:
                    if h >= w:
                        best = (w, h)
                        break
            if best is None:
                # fallback to using full bbox and partial fill
                w = bbox_w
                h = bbox_h
            else:
                w, h = best
            cells = set()
            count = 0
            for rr in range(h):
                for cc in range(w):
                    if count < desired:
                        cells.add((rr, cc))
                        count += 1
            return cells, h, w

        if target_type == 'triangle':
            # left-aligned right triangle rows: 1,2,...,H. H <= bbox_h and H <= bbox_w
            max_H = min(bbox_h, bbox_w)
            if max_H <= 0:
                return set(), 0, 0
            # choose H so that triangular number T(H) >= desired if possible
            best_H = 1
            best_diff = None
            for H in range(1, max_H + 1):
                T = H * (H + 1) // 2
                diff = abs(T - desired)
                if best_diff is None or diff < best_diff:
                    best_diff = diff
                    best_H = H
            # build triangle rows of lengths 1..best_H and then trim or extend last row to match desired
            rows = [i + 1 for i in range(best_H)]
            T = sum(rows)
            if T >= desired:
                # trim from last row
                excess = T - desired
                rows[-1] -= excess
                if rows[-1] <= 0:
                    # if trimming made last row zero, adjust by removing rows
                    while rows and rows[-1] <= 0:
                        rows.pop()
                h = len(rows)
                cells = set()
                for i, length in enumerate(rows):
                    for cc in range(length):
                        cells.add((i, cc))
                return cells, h, max(rows) if rows else 0
            else:
                # T < desired, try to extend bottom rows up to bbox_w
                extra_needed = desired - T
                rows2 = rows[:]
                idx = best_H - 1
                while extra_needed > 0 and idx >= 0:
                    can_add = bbox_w - rows2[idx]
                    add = min(can_add, extra_needed)
                    rows2[idx] += add
                    extra_needed -= add
                    idx -= 1
                # if still extra_needed, we try to add more rows if possible
                while extra_needed > 0 and len(rows2) < bbox_h:
                    add_len = min(bbox_w, extra_needed)
                    rows2.append(add_len)
                    extra_needed -= add_len
                h = len(rows2)
                cells = set()
                for i, length in enumerate(rows2):
                    for cc in range(length):
                        cells.add((i, cc))
                return cells, h, max(rows2) if rows2 else 0

        if target_type == 'diamond':
            # try to pick radius r so that diamond base fits in bbox
            max_r = min((bbox_h - 1) // 2, (bbox_w - 1) // 2)
            if max_r < 0:
                return set(), 0, 0
            best_r = 0
            best_diff = None
            for r in range(0, max_r + 1):
                D = 1 + 2 * r * (r + 1)
                diff = abs(D - desired)
                if best_diff is None or diff < best_diff:
                    best_diff = diff
                    best_r = r
            # build diamond centered in width
            r = best_r
            base_w = 2 * r + 1
            base_h = 2 * r + 1
            top = 0
            left = (bbox_w - base_w) // 2
            cells = set()
            for dr in range(-r, r + 1):
                row_len = r - abs(dr)
                row_center = left + r
                for dc in range(-row_len, row_len + 1):
                    cells.add((top + dr + r, row_center + dc))
            # adjust area by adding extra cells below if needed
            current = len(cells)
            if current < desired:
                # try to add cells row by row under bottom of diamond, left to right
                row = base_h
                while current < desired and row < bbox_h:
                    for cc in range(bbox_w):
                        if current >= desired:
                            break
                        cells.add((row, cc))
                        current += 1
                    row += 1
            elif current > desired:
                # remove some outer cells (from bottom rows) to reduce to desired
                # remove from bottom-most rows first
                rem = current - desired
                rows = sorted(list({r for r, c in cells}), reverse=True)
                for rr in rows:
                    if rem <= 0:
                        break
                    cols_in_row = sorted([c for (r, c) in cells if r == rr])
                    for c in cols_in_row:
                        if rem <= 0:
                            break
                        cells.remove((rr, c))
                        rem -= 1
            # normalize to top-left anchored coords
            minr = min(r for r, c in cells)
            minc = min(c for r, c in cells)
            norm = set(((r - minr, c - minc) for (r, c) in cells))
            h = max(r for r, c in norm) + 1
            w = max(c for r, c in norm) + 1
            return norm, h, w

        # unknown fallback: fill rows
        # just make a vertical strip
        w = min(1, bbox_w)
        h = min(desired, bbox_h)
        cells = set((r, 0) for r in range(h))
        return cells, h, w

    # Now transform each non-diamond shape
    for shape in non_diamonds:
        pixels = shape['pixels']
        color = shape['color']
        min_r, min_c, max_r, max_c = shape['bbox']
        orig_area = len(pixels)

        # Step 2: expand bounding box by N
        new_min_r = max(0, min_r - N)
        new_min_c = max(0, min_c - N)
        new_max_r = min(size - 1, max_r + N)
        new_max_c = min(size - 1, max_c + N)
        bbox_h = new_max_r - new_min_r + 1
        bbox_w = new_max_c - new_min_c + 1

        # Remove original shape from output grid
        for (r, c) in pixels:
            out[r][c] = 0

        # Step 3: morph shape type
        original_type = detect_type(pixels)
        if original_type == 'square':
            target = 'rectangle'
        elif original_type == 'rectangle':
            target = 'triangle'
        elif original_type == 'triangle':
            target = 'diamond'
        elif original_type == 'line':
            target = 'square'
        else:
            target = 'rectangle'

        # Step 4: scale area to N * original_area (or closest possible within bbox)
        target_area = N * orig_area

        # Build morphed shape within bbox constraints
        cells_rel, h_shape, w_shape = build_morphed(target, target_area, bbox_w, bbox_h)

        # Place at first available location inside expanded bbox (scan top-left to bottom-right)
        placed = False
        for anchor_r in range(new_min_r, new_max_r - h_shape + 2):
            if placed:
                break
            for anchor_c in range(new_min_c, new_max_c - w_shape + 2):
                conflict = False
                for (rr, cc) in cells_rel:
                    R = anchor_r + rr
                    C = anchor_c + cc
                    if out[R][C] != 0:
                        conflict = True
                        break
                if not conflict:
                    # place it
                    for (rr, cc) in cells_rel:
                        out[anchor_r + rr][anchor_c + cc] = color
                    placed = True
                    break
        if not placed:
            # fallback: try to place overlapping only with original color positions (should be removed)
            for anchor_r in range(new_min_r, new_max_r - h_shape + 2):
                if placed:
                    break
                for anchor_c in range(new_min_c, new_max_c - w_shape + 2):
                    # force place (overwrite zeros only)
                    ok = True
                    for (rr, cc) in cells_rel:
                        R = anchor_r + rr
                        C = anchor_c + cc
                        if out[R][C] != 0:
                            ok = False
                            break
                    if ok:
                        for (rr, cc) in cells_rel:
                            out[anchor_r + rr][anchor_c + cc] = color
                        placed = True
                        break
        # if still not placed, give up and leave area cleared (should be rare given spacing)

    return {'input': grid, 'output': out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # solver mirrors the generator's logic to compute the same output
    import math
    grid_in = [list(row) for row in input_grid]
    size = len(grid_in)

    def neighbors4(r, c):
        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
            yield r + dr, c + dc

    def in_bounds(r, c):
        return 0 <= r < size and 0 <= c < size

    def diamond_pixels(cr, cc, radius):
        pts = []
        for dr in range(-radius, radius + 1):
            rem = radius - abs(dr)
            for dc in range(-rem, rem + 1):
                pts.append((cr + dr, cc + dc))
        return pts

    # Flood fill to get shapes
    visited = [[False] * size for _ in range(size)]
    shapes = []  # each shape as dict: color, pixels set, bbox

    for r in range(size):
        for c in range(size):
            if grid_in[r][c] == 0 or visited[r][c]:
                continue
            color = grid_in[r][c]
            stack = [(r, c)]
            visited[r][c] = True
            pixels = set()
            while stack:
                cr, cc = stack.pop()
                pixels.add((cr, cc))
                for nr, nc in neighbors4(cr, cc):
                    if in_bounds(nr, nc) and not visited[nr][nc] and grid_in[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            min_r = min(p[0] for p in pixels)
            min_c = min(p[1] for p in pixels)
            max_r = max(p[0] for p in pixels)
            max_c = max(p[1] for p in pixels)
            shapes.append({
                'color': color,
                'pixels': pixels,
                'bbox': (min_r, min_c, max_r, max_c)
            })

    # detect diamonds and count N
    def detect_type(pixels):
        min_r = min(r for r, c in pixels)
        max_r = max(r for r, c in pixels)
        min_c = min(c for r, c in pixels)
        max_c = max(c for r, c in pixels)
        h = max_r - min_r + 1
        w = max_c - min_c + 1
        area = len(pixels)
        # diamond test
        if h == w and h % 2 == 1:
            r = (h - 1) // 2
            cr = (min_r + max_r) // 2
            cc = (min_c + max_c) // 2
            expected = set(diamond_pixels(cr, cc, r))
            if expected == pixels:
                return 'diamond'
        # square
        if h == w and area == h * w:
            return 'square'
        # rectangle
        if area == h * w:
            return 'rectangle'
        # triangle
        row_lengths = []
        for rr in range(min_r, max_r + 1):
            cols = sorted([c for (r, c) in pixels if r == rr])
            if not cols:
                row_lengths.append(0)
            else:
                if cols != list(range(cols[0], cols[-1] + 1)):
                    row_lengths = None
                    break
                row_lengths.append(cols[-1] - cols[0] + 1)
        if row_lengths is not None:
            trimmed = [l for l in row_lengths if l > 0]
            if trimmed and all(trimmed[i] == i + 1 for i in range(len(trimmed))):
                return 'triangle'
        # line
        if h == 1 or w == 1:
            return 'line'
        return 'unknown'

    diamonds = [s for s in shapes if detect_type(s['pixels']) == 'diamond']
    N = len(diamonds)

    # Build list of non-diamond shapes sorted by top-left coordinate
    non_diamonds = [s for s in shapes if detect_type(s['pixels']) != 'diamond']
    non_diamonds.sort(key=lambda s: (s['bbox'][0], s['bbox'][1]))

    # Builder function mirrors generator's build_morphed
    def build_morphed(target_type, target_area, bbox_w, bbox_h):
        max_area = bbox_w * bbox_h
        if max_area <= 0:
            return set(), 0, 0
        desired = min(target_area, max_area)
        if target_type in ('rectangle', 'square'):
            best = None
            for w in range(1, bbox_w + 1):
                h = (desired + w - 1) // w
                if h <= bbox_h:
                    if h >= w:
                        best = (w, h)
                        break
            if best is None:
                w = bbox_w
                h = bbox_h
            else:
                w, h = best
            cells = set()
            count = 0
            for rr in range(h):
                for cc in range(w):
                    if count < desired:
                        cells.add((rr, cc))
                        count += 1
            return cells, h, w

        if target_type == 'triangle':
            max_H = min(bbox_h, bbox_w)
            if max_H <= 0:
                return set(), 0, 0
            best_H = 1
            best_diff = None
            for H in range(1, max_H + 1):
                T = H * (H + 1) // 2
                diff = abs(T - desired)
                if best_diff is None or diff < best_diff:
                    best_diff = diff
                    best_H = H
            rows = [i + 1 for i in range(best_H)]
            T = sum(rows)
            if T >= desired:
                excess = T - desired
                rows[-1] -= excess
                if rows[-1] <= 0:
                    while rows and rows[-1] <= 0:
                        rows.pop()
                h = len(rows)
                cells = set()
                for i, length in enumerate(rows):
                    for cc in range(length):
                        cells.add((i, cc))
                return cells, h, max(rows) if rows else 0
            else:
                extra_needed = desired - T
                rows2 = rows[:]
                idx = best_H - 1
                while extra_needed > 0 and idx >= 0:
                    can_add = bbox_w - rows2[idx]
                    add = min(can_add, extra_needed)
                    rows2[idx] += add
                    extra_needed -= add
                    idx -= 1
                while extra_needed > 0 and len(rows2) < bbox_h:
                    add_len = min(bbox_w, extra_needed)
                    rows2.append(add_len)
                    extra_needed -= add_len
                h = len(rows2)
                cells = set()
                for i, length in enumerate(rows2):
                    for cc in range(length):
                        cells.add((i, cc))
                return cells, h, max(rows2) if rows2 else 0

        if target_type == 'diamond':
            max_r = min((bbox_h - 1) // 2, (bbox_w - 1) // 2)
            if max_r < 0:
                return set(), 0, 0
            best_r = 0
            best_diff = None
            for r in range(0, max_r + 1):
                D = 1 + 2 * r * (r + 1)
                diff = abs(D - desired)
                if best_diff is None or diff < best_diff:
                    best_diff = diff
                    best_r = r
            r = best_r
            base_w = 2 * r + 1
            base_h = 2 * r + 1
            top = 0
            left = (bbox_w - base_w) // 2
            cells = set()
            for dr in range(-r, r + 1):
                row_len = r - abs(dr)
                row_center = left + r
                for dc in range(-row_len, row_len + 1):
                    cells.add((top + dr + r, row_center + dc))
            current = len(cells)
            if current < desired:
                row = base_h
                while current < desired and row < bbox_h:
                    for cc in range(bbox_w):
                        if current >= desired:
                            break
                        cells.add((row, cc))
                        current += 1
                    row += 1
            elif current > desired:
                rem = current - desired
                rows_list = sorted(list({r for r, c in cells}), reverse=True)
                for rr in rows_list:
                    if rem <= 0:
                        break
                    cols_in_row = sorted([c for (r, c) in cells if r == rr])
                    for c in cols_in_row:
                        if rem <= 0:
                            break
                        cells.remove((rr, c))
                        rem -= 1
            minr = min(r for r, c in cells)
            minc = min(c for r, c in cells)
            norm = set(((r - minr, c - minc) for (r, c) in cells))
            h = max(r for r, c in norm) + 1
            w = max(c for r, c in norm) + 1
            return norm, h, w

        w = min(1, bbox_w)
        h = min(desired, bbox_h)
        cells = set((r, 0) for r in range(h))
        return cells, h, w

    # Create output grid starting from input but we'll clear non-diamond shapes and rebuild
    out = [row[:] for row in grid_in]

    # Clear non-diamond shapes in out first to mimic generator
    for s in non_diamonds:
        for (r, c) in s['pixels']:
            out[r][c] = 0

    # Process shapes in same sorted order
    for s in non_diamonds:
        pixels = s['pixels']
        color = s['color']
        min_r, min_c, max_r, max_c = s['bbox']
        orig_area = len(pixels)
        # expand bbox by N
        new_min_r = max(0, min_r - N)
        new_min_c = max(0, min_c - N)
        new_max_r = min(size - 1, max_r + N)
        new_max_c = min(size - 1, max_c + N)
        bbox_h = new_max_r - new_min_r + 1
        bbox_w = new_max_c - new_min_c + 1

        original_type = detect_type(pixels)
        if original_type == 'square':
            target = 'rectangle'
        elif original_type == 'rectangle':
            target = 'triangle'
        elif original_type == 'triangle':
            target = 'diamond'
        elif original_type == 'line':
            target = 'square'
        else:
            target = 'rectangle'

        target_area = N * orig_area
        cells_rel, h_shape, w_shape = build_morphed(target, target_area, bbox_w, bbox_h)

        placed = False
        for anchor_r in range(new_min_r, new_max_r - h_shape + 2):
            if placed:
                break
            for anchor_c in range(new_min_c, new_max_c - w_shape + 2):
                conflict = False
                for (rr, cc) in cells_rel:
                    R = anchor_r + rr
                    C = anchor_c + cc
                    if out[R][C] != 0:
                        conflict = True
                        break
                if not conflict:
                    for (rr, cc) in cells_rel:
                        out[anchor_r + rr][anchor_c + cc] = color
                    placed = True
                    break
        # if not placed, ignore (should be rare)

    return out

