# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 7dd3e33c
Difficulty: very hard

=== Tags ===
- Color signal exchange
- Simulate gravity with obstacles
- Dynamic environment
- Bridge gaps
- Periodic tiling

=== Description ===
**Task Description: Color Signal Exchange and Gravity-Driven Bridge Formation**
Input grids consist of a 15×15 to 30×30 canvas with four distinct categories of
elements:   1. **Background (color 0)**: Empty space where signals move.   2.
**Obstacles (colors 1–4)**: Fixed, non-moving structures that block signal
movement.   3. **Signals (colors 5–8)**: Mobile elements that fall downward due
to gravity until blocked by obstacles or other signals.   4. **Collision points
(implicit)**: Positions where signals meet after falling.    **Transformation
Rules**:   1. **Gravity Simulation**: All signals fall vertically downward until
they:      - Hit an obstacle (colors 1–4), or      - Land on a cell occupied by
another signal (collision).      *Obstacles and background remain unchanged
during movement.*    2. **Color Signal Exchange**: Upon collision (two signals
occupying the same cell):      - The signals **swap their colors** (e.g., signal
5 and 6 become 6 and 5).      - This swap is **deterministic and reversible**
(e.g., swapping again reverts to original).    3. **Bridge Gap Formation**: For
every collision:      - A **bridge (color 9)** is drawn as a **straight line**
connecting the **original positions** of the colliding signals.      - Bridges
span **horizontally** if signals were in the same row initially, or
**vertically** if in the same column.      - Bridges **do not overwrite
obstacles or background**; they occupy only background cells.      - Bridges
**do not overlap** with existing obstacles or other bridges.    4. **Periodic
Tiling**: The bridges form a **repeating pattern** across the grid:      -
Horizontal bridges align to form **evenly spaced rows** (e.g., every 3rd row).
- Vertical bridges align to form **evenly spaced columns** (e.g., every 4th
column).      - This pattern is **derived from the collision geometry**, not
artificially imposed.    **Output Grid Requirements**:   - Signals are
positioned at their lowest valid location after gravity.   - All collisions
result in swapped colors and bridges.   - Bridges form a **periodic tiling
structure** (e.g., a grid of bridges spaced 3–5 cells apart).   - Obstacles and
background remain intact.   - **No signal is left unprocessed**, and no bridge
is drawn for non-colliding signals.    **Difficulty Justification**:   The task
requires **simultaneous execution** of gravity simulation, collision detection,
color swapping, and bridge pattern generation. The periodic tiling constraint
necessitates **relational reasoning** between bridge positions (e.g.,
recognizing that a vertical bridge at column 7 implies another at column 11),
while obstacle placement creates **non-linear pathing** that must be resolved
before bridge placement. The input grid’s complexity (e.g., 20+ signals,
irregular obstacles) ensures that **sequential processing** (gravity → collision
→ bridge) is non-trivial, with **no direct pixel-matching shortcut**.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = random.randint(15, 30)
    height = random.randint(15, 30)
    input_grid = common.grid(width, height, 0)
    obstacle_count = random.randint(int(0.1 * width * height), int(0.2 * width * height))
    for _ in range(obstacle_count):
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        input_grid[r][c] = random.randint(1, 4)
    
    for c in range(2, width, 3):
        for r in range(2, height-2, 3):
            if input_grid[r][c] == 0 and input_grid[r+2][c] == 0 and input_grid[r+1][c] == 0:
                color1 = random.randint(5, 8)
                color2 = random.randint(5, 8)
                while color2 == color1:
                    color2 = random.randint(5, 8)
                input_grid[r][c] = color1
                input_grid[r+2][c] = color2
    
    for r in range(2, height, 3):
        for c in range(2, width-2, 3):
            if input_grid[r][c] == 0 and input_grid[r][c+2] == 0 and input_grid[r][c+1] == 0:
                color1 = random.randint(5, 8)
                color2 = random.randint(5, 8)
                while color2 == color1:
                    color2 = random.randint(5, 8)
                input_grid[r][c] = color1
                input_grid[r][c+2] = color2
    
    output_grid = [row[:] for row in input_grid]
    
    for c in range(2, width, 3):
        for r in range(2, height-2, 3):
            if input_grid[r][c] > 4 and input_grid[r+2][c] > 4:
                output_grid[r][c], output_grid[r+2][c] = output_grid[r+2][c], output_grid[r][c]
                if output_grid[r+1][c] == 0:
                    output_grid[r+1][c] = 9
    
    for r in range(2, height, 3):
        for c in range(2, width-2, 3):
            if input_grid[r][c] > 4 and input_grid[r][c+2] > 4:
                output_grid[r][c], output_grid[r][c+2] = output_grid[r][c+2], output_grid[r][c]
                if output_grid[r][c+1] == 0:
                    output_grid[r][c+1] = 9
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    output = [row[:] for row in grid]
    
    for c in range(2, width, 3):
        for r in range(2, height-2, 3):
            if 5 <= output[r][c] <= 8 and 5 <= output[r+2][c] <= 8 and output[r+1][c] == 0:
                output[r][c], output[r+2][c] = output[r+2][c], output[r][c]
                output[r+1][c] = 9
    
    for r in range(2, height, 3):
        for c in range(2, width-2, 3):
            if 5 <= output[r][c] <= 8 and 5 <= output[r][c+2] <= 8 and output[r][c+1] == 0:
                output[r][c], output[r][c+2] = output[r][c+2], output[r][c]
                output[r][c+1] = 9
    
    return output
