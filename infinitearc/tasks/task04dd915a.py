# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 04dd915a
Difficulty: medium–hard

=== Tags ===
- Modular sequence
- Periodic reflection
- Even or odd
- Detect repetition

=== Description ===
Input grids feature a central horizontal sequence of 2×2 colored blocks arranged
in a repeating pattern (e.g., Block A → Block B → Block C → Block A → Block B →
Block C...), with the sequence repeating consistently across the row. The
repeating unit consists of exactly three distinct blocks, forming a modular
sequence that spans the grid's width. The grid also contains background elements
such as isolated colored cells or simple geometric shapes, but the critical
feature is the central repeating block sequence.  Output grids transform the
central sequence by horizontally mirroring every block at an even index (0-based
counting), while preserving blocks at odd indices. Mirroring swaps the left and
right columns within each 2×2 block: for instance, a block with top row [Red,
Blue] and bottom row [Green, Yellow] becomes [Blue, Red] and [Yellow, Green]
after mirroring. The rest of the grid—including background elements, non-central
patterns, and the original sequence's repeating structure—remains unchanged. The
transformation requires detecting the repeating sequence's period (three
blocks), recognizing the periodic reflection pattern (applied every second
block), and applying the mirror operation based on even-indexed positions within
the sequence. This task demands visual pattern analysis to identify repetition,
determine periodicity, and apply directional transformations without numerical
computations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = 12
    height = random.randint(2, 30)
    grid_input = common.grid(width, height)
    mid_row = (height - 2) // 2
    
    def generate_block():
        return [
            [random.randint(1, 9) for _ in range(2)],
            [random.randint(1, 9) for _ in range(2)]
        ]
    
    A = generate_block()
    B = generate_block()
    C = generate_block()
    blocks = [A, B, C, A, B, C]
    
    for i in range(6):
        col_start = i * 2
        for r in range(2):
            for c in range(2):
                grid_input[mid_row + r][col_start + c] = blocks[i][r][c]
    
    for r in range(height):
        for c in range(width):
            if r not in [mid_row, mid_row+1] and random.random() > 0.5:
                grid_input[r][c] = random.randint(1, 9)
    
    grid_output = [row[:] for row in grid_input]
    for i in range(6):
        if i % 2 == 0:
            col_start = i * 2
            for r in range(2):
                grid_output[mid_row + r][col_start], grid_output[mid_row + r][col_start + 1] = grid_output[mid_row + r][col_start + 1], grid_output[mid_row + r][col_start]
    
    return {
        "input": grid_input,
        "output": grid_output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    height = len(input_list)
    mid_row = (height - 2) // 2
    for i in range(6):
        if i % 2 == 0:
            col_start = i * 2
            for r in range(2):
                input_list[mid_row + r][col_start], input_list[mid_row + r][col_start + 1] = input_list[mid_row + r][col_start + 1], input_list[mid_row + r][col_start]
    return tuple(tuple(row) for row in input_list)
