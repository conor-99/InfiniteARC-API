# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: ab324c98
Difficulty: insane

=== Tags ===
- Adaptive behavior switch
- Path scarring
- Dual source paths
- Count hor lines

=== Description ===
The input grid consists of a 20Ã—20 grid containing two distinct colored paths
starting from opposite edges (left and right), each moving toward the center.
Each path is represented by a unique color that determines its adaptive
behavior. Scattered throughout the grid are horizontal line segments of a
neutral background color (color 0), which serve as interaction points. As each
path moves cell-by-cell in its initial direction, it leaves a continuous scar
(trail) of its original color along its path. When a path encounters a
horizontal line segment (color 0), it immediately turns 90 degrees according to
its color-specific rule: red paths turn left, blue paths turn right (or vice
versa depending on the path's color), while continuing to move. The horizontal
lines remain visually unchanged in the output. Paths may intersect but do not
interact with each other. The output grid displays the complete scarred
trajectories of both paths, their final positions, and all horizontal line
segments, with no modifications to the input's structural elements. The
transformation requires simultaneous tracking of dual path movements,
conditional direction changes based on visual color cues, and persistent scar
marking without overlap or interference.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = 20
    height = 20
    input_grid = grid(width, height, 0)
    colors = list(range(1, 10))
    C1 = random.choice(colors)
    C2 = random.choice([c for c in colors if c != C1])
    r1 = random.randint(0, height-1)
    r2 = random.randint(0, height-1)
    input_grid[r1][0] = C1
    input_grid[r2][19] = C2
    output_grid = [row[:] for row in input_grid]
    
    def turn_left(d):
        dr, dc = d
        if dr == 0 and dc == 1: return (-1, 0)
        if dr == -1 and dc == 0: return (0, -1)
        if dr == 0 and dc == -1: return (1, 0)
        if dr == 1 and dc == 0: return (0, 1)
        return (dr, dc)
    
    def turn_right(d):
        dr, dc = d
        if dr == 0 and dc == 1: return (1, 0)
        if dr == -1 and dc == 0: return (0, 1)
        if dr == 0 and dc == -1: return (-1, 0)
        if dr == 1 and dc == 0: return (0, -1)
        return (dr, dc)
    
    # Left path
    r, c = r1, 0
    direction = (0, 1)
    while True:
        nr = r + direction[0]
        nc = c + direction[1]
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        if input_grid[nr][nc] == 0:
            has_left = (nc > 0 and input_grid[nr][nc-1] == 0)
            has_right = (nc < width-1 and input_grid[nr][nc+1] == 0)
            if has_left or has_right:
                if C1 == 2:
                    direction = turn_left(direction)
                else:
                    direction = turn_right(direction)
        output_grid[nr][nc] = C1
        r, c = nr, nc
    
    # Right path
    r, c = r2, 19
    direction = (0, -1)
    while True:
        nr = r + direction[0]
        nc = c + direction[1]
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        if input_grid[nr][nc] == 0:
            has_left = (nc > 0 and input_grid[nr][nc-1] == 0)
            has_right = (nc < width-1 and input_grid[nr][nc+1] == 0)
            if has_left or has_right:
                if C2 == 3:
                    direction = turn_right(direction)
                else:
                    direction = turn_left(direction)
        output_grid[nr][nc] = C2
        r, c = nr, nc
    
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    
    # Find left path start
    left_start = None
    for r in range(height):
        if grid[r][0] != 0:
            left_start = (r, grid[r][0])
            break
    if not left_start:
        raise ValueError('No left path found')
    C1, r1 = left_start[1], left_start[0]
    
    # Find right path start
    right_start = None
    for r in range(height):
        if grid[r][width-1] != 0:
            right_start = (r, grid[r][width-1])
            break
    if not right_start:
        raise ValueError('No right path found')
    C2, r2 = right_start[1], right_start[0]
    
    def turn_left(d):
        dr, dc = d
        if dr == 0 and dc == 1: return (-1, 0)
        if dr == -1 and dc == 0: return (0, -1)
        if dr == 0 and dc == -1: return (1, 0)
        if dr == 1 and dc == 0: return (0, 1)
        return (dr, dc)
    
    def turn_right(d):
        dr, dc = d
        if dr == 0 and dc == 1: return (1, 0)
        if dr == -1 and dc == 0: return (0, 1)
        if dr == 0 and dc == -1: return (-1, 0)
        if dr == 1 and dc == 0: return (0, -1)
        return (dr, dc)
    
    output = [row[:] for row in grid]
    
    # Left path
    r, c = r1, 0
    direction = (0, 1)
    while True:
        nr = r + direction[0]
        nc = c + direction[1]
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        if grid[nr][nc] == 0:
            has_left = (nc > 0 and grid[nr][nc-1] == 0)
            has_right = (nc < width-1 and grid[nr][nc+1] == 0)
            if has_left or has_right:
                if C1 == 2:
                    direction = turn_left(direction)
                else:
                    direction = turn_right(direction)
        output[nr][nc] = C1
        r, c = nr, nc
    
    # Right path
    r, c = r2, width-1
    direction = (0, -1)
    while True:
        nr = r + direction[0]
        nc = c + direction[1]
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        if grid[nr][nc] == 0:
            has_left = (nc > 0 and grid[nr][nc-1] == 0)
            has_right = (nc < width-1 and grid[nr][nc+1] == 0)
            if has_left or has_right:
                if C2 == 3:
                    direction = turn_right(direction)
                else:
                    direction = turn_left(direction)
        output[nr][nc] = C2
        r, c = nr, nc
    
    return output
