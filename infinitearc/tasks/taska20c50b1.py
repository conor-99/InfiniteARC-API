# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: a20c50b1
Difficulty: hard

=== Tags ===
- Image juxtaposition
- Detect wall
- Divide by n
- Simulate gravity with obstacles

=== Description ===
The task involves transforming an input grid into an output grid by simulating
gravity with obstacles, where walls (detected via a specific color value, e.g.,
5) block downward movement. The input grid contains movable elements (colors
1â€“4) and walls (color 5). The transformation process begins by detecting all
wall positions. Each column is then divided into segments bounded by walls or
grid edges. Within each segment, all movable elements fall downward until they
collide with the segment's bottom boundary (either a wall or the grid's base).
The "Divide by n" component refers to the segmentation of columns into \( n \)
segments, where \( n \) is determined by the number of walls in the column.
"Image juxtaposition" describes the resulting arrangement where elements are
positioned adjacent to walls in the output, creating a visual alignment with
obstacles. The rules are deterministic: for every column, elements move downward
in their segment without overlapping or crossing walls, ensuring all elements
settle at the lowest possible position within their segment.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    input_grid = [[0] * width for _ in range(height)]
    
    for r in range(height):
        for c in range(width):
            if random.random() < 0.2:
                input_grid[r][c] = 5
    
    for c in range(width):
        walls = [r for r in range(height) if input_grid[r][c] == 5]
        walls.sort()
        boundaries = [0] + walls + [height]
        for i in range(len(boundaries) - 1):
            start = boundaries[i]
            end = boundaries[i+1]
            if start >= end:
                continue
            element_rows = list(range(start, end - 1))
            if not element_rows:
                continue
            num_elements = random.randint(0, len(element_rows))
            selected_rows = random.sample(element_rows, num_elements)
            for r in selected_rows:
                input_grid[r][c] = random.randint(1, 4)
    
    output_grid = [list(row) for row in input_grid]
    for c in range(width):
        walls = [r for r in range(height) if input_grid[r][c] == 5]
        walls.sort()
        boundaries = [0] + walls + [height]
        for i in range(len(boundaries) - 1):
            start = boundaries[i]
            end = boundaries[i+1]
            if start >= end:
                continue
            elements = []
            for r in range(start, end):
                val = input_grid[r][c]
                if val != 5 and val != 0:
                    elements.append(val)
            k = len(elements)
            if k == 0:
                continue
            for r in range(start, end):
                if input_grid[r][c] != 5 and input_grid[r][c] != 0:
                    output_grid[r][c] = 0
            target_start = end - 1 - k + 1
            for idx in range(k):
                output_grid[target_start + idx][c] = elements[idx]
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output = [list(row) for row in input_grid]
    
    for c in range(width):
        walls = []
        for r in range(height):
            if input_grid[r][c] == 5:
                walls.append(r)
        walls.sort()
        boundaries = [0] + walls + [height]
        
        for i in range(len(boundaries) - 1):
            start = boundaries[i]
            end = boundaries[i+1]
            if start >= end:
                continue
            elements = []
            for r in range(start, end):
                val = input_grid[r][c]
                if val != 5 and val != 0:
                    elements.append(val)
            k = len(elements)
            if k == 0:
                continue
            for r in range(start, end):
                if input_grid[r][c] != 5 and input_grid[r][c] != 0:
                    output[r][c] = 0
            target_start = end - 1 - k + 1
            for idx in range(k):
                output[target_start + idx][c] = elements[idx]
    
    return output
