# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 2075f223
Difficulty: insane

=== Tags ===
- Connect components by property
- Mapping by size relation
- Dependency topological sort
- Separate images
- Flood fill region

=== Description ===
Input grids consist of multiple disconnected, solid-colored regions (each region
is a contiguous block of cells with the same non-zero color, 1-9) surrounded by
background (0). Regions are separated by at least one background cell in all
four directions. Each region has a unique size (number of cells) and color. The
transformation requires the following steps: First, identify all connected
components (4-connected) and sort them topologically by size in ascending order
(smallest to largest), establishing a dependency chain where each smaller region
"depends on" the next larger region. Second, map each region's original color to
a new color based on its rank in this sorted order (e.g., the smallest region
becomes color 1, the next color 2, etc.), using a permutation of colors 1-9 that
avoids conflicts. Third, connect each consecutive pair of regions in the sorted
order with a minimal orthogonal path of color 9 drawn exclusively through
background cells (avoiding all non-background cells), creating a visual
"dependency chain." Fourth, apply a flood fill to each region using its new
mapped color, preserving all original region boundaries and the connecting
paths. The output grid must show the transformed regions with new colors, the
connecting paths, and no overlaps or merged regions. All background cells remain
0, and the transformation is deterministic based on size relations and
topological ordering.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque

def generate():
    n = random.randint(1, 9)
    width = random.randint(max(n, 3), 30)
    height = random.randint(2 * n + 2, 30)
    input_grid = [[0] * width for _ in range(height)]
    colors = random.sample(range(1, 10), n)
    region_positions = []
    for i in range(n):
        size = i + 1
        color = colors[i]
        row = 2 * i
        start_col = random.randint(0, width - size)
        for col in range(start_col, start_col + size):
            input_grid[row][col] = color
        region_positions.append((row, start_col, size))
    output_grid = [row[:] for row in input_grid]
    for i in range(n):
        size = i + 1
        new_color = size
        row = 2 * i
        start_col = region_positions[i][1]
        for col in range(start_col, start_col + size):
            output_grid[row][col] = new_color
    for i in range(n - 1):
        row1, start_col1, size1 = region_positions[i]
        row2, start_col2, size2 = region_positions[i+1]
        region1 = [(row1, col) for col in range(start_col1, start_col1 + size1)]
        region2 = [(row2, col) for col in range(start_col2, start_col2 + size2)]
        min_dist = float('inf')
        p1 = None
        p2 = None
        for (r1, c1) in region1:
            for (r2, c2) in region2:
                dist = abs(r1 - r2) + abs(c1 - c2)
                if dist < min_dist:
                    min_dist = dist
                    p1 = (r1, c1)
                    p2 = (r2, c2)
        visited = [[False] * width for _ in range(height)]
        parent = {}
        queue = deque([p1])
        visited[p1[0]][p1[1]] = True
        while queue:
            r, c = queue.popleft()
            if (r, c) == p2:
                break
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == 0:
                    visited[nr][nc] = True
                    parent[(nr, nc)] = (r, c)
                    queue.append((nr, nc))
        path = []
        current = p2
        while current != p1:
            path.append(current)
            current = parent.get(current, None)
            if current is None:
                break
        path.append(p1)
        for (r, c) in path:
            output_grid[r][c] = 9
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def find_path(p1, p2, bg_grid):
    visited = [[False] * len(bg_grid[0]) for _ in range(len(bg_grid))]
    parent = {}
    queue = deque([p1])
    visited[p1[0]][p1[1]] = True
    while queue:
        r, c = queue.popleft()
        if (r, c) == p2:
            break
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < len(bg_grid) and 0 <= nc < len(bg_grid[0]) and not visited[nr][nc] and bg_grid[nr][nc] == 0:
                visited[nr][nc] = True
                parent[(nr, nc)] = (r, c)
                queue.append((nr, nc))
    path = []
    current = p2
    while current != p1:
        path.append(current)
        current = parent.get(current, None)
        if current is None:
            break
    path.append(p1)
    return path[::-1]

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    input_grid_copy = [row[:] for row in input_grid]
    visited = [[False] * len(input_grid[0]) for _ in range(len(input_grid))]
    components = []
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if not visited[r][c] and input_grid[r][c] != 0:
                color = input_grid[r][c]
                pixels = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    pixels.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < len(input_grid) and 0 <= nc < len(input_grid[0]) and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                size = len(pixels)
                components.append((color, size, pixels))
    components.sort(key=lambda x: x[1])
    new_colors = {comp[0]: idx + 1 for idx, comp in enumerate(components)}
    output_grid = [row[:] for row in input_grid]
    for color, _, pixels in components:
        new_color = new_colors[color]
        for (r, c) in pixels:
            output_grid[r][c] = new_color
    for i in range(len(components) - 1):
        comp1 = components[i]
        comp2 = components[i+1]
        min_dist = float('inf')
        p1 = None
        p2 = None
        for (r1, c1) in comp1[2]:
            for (r2, c2) in comp2[2]:
                dist = abs(r1 - r2) + abs(c1 - c2)
                if dist < min_dist:
                    min_dist = dist
                    p1 = (r1, c1)
                    p2 = (r2, c2)
        path = find_path(p1, p2, input_grid_copy)
        for (r, c) in path:
            output_grid[r][c] = 9
    return output_grid
