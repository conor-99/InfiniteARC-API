# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 1f410f1e
Difficulty: very hard

=== Tags ===
- Phase shift
- Pattern cycle
- Lattice completion
- Swap positions of two objects

=== Description ===
The input grid is a large (≥15×15) grid divided into a regular lattice of 3×3
blocks. Each block contains a single non-background symbol (color 1–9) or is
empty (background color 0). The symbol's color defines its phase shift
direction: color 1 (right), 2 (down), 3 (left), 4 (up), with colors 5–9 cycling
through these directions (e.g., 5 = right, 6 = down, 7 = left, 8 = up, 9 =
right). Each symbol shifts once within its 3×3 block in its direction, wrapping
around the block edges. After shifting, the lattice is completed by filling each
empty cell with the symbol from the adjacent block in the direction opposite to
the shift (e.g., if a symbol shifted right, the empty cell to the left is filled
from the block to the left). Finally, all occurrences of the two most frequently
present non-background colors in the input grid are swapped in the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    N = random.randint(5, 10)
    size = 3 * N
    input_grid = [[0] * size for _ in range(size)]
    
    for i in range(N):
        for j in range(N):
            is_left = (j == 0)
            is_right = (j == N-1)
            is_top = (i == 0)
            is_bottom = (i == N-1)
            if is_left and is_top:
                allowed_colors = [3,4,7,8]
            elif is_left:
                allowed_colors = [2,3,4,6,7,8]
            elif is_right:
                allowed_colors = [1,2,4,5,6,8]
            elif is_top:
                allowed_colors = [1,3,4,5,7,8]
            elif is_bottom:
                allowed_colors = [1,3,4,5,7,8]
            else:
                allowed_colors = list(range(1,10))
            c = random.choice(allowed_colors)
            r_block = random.randint(0, 2)
            c_block = random.randint(0, 2)
            input_grid[3*i + r_block][3*j + c_block] = c
    
    output_grid = [[0] * size for _ in range(size)]
    for i in range(N):
        for j in range(N):
            found = False
            for r in range(3):
                for c in range(3):
                    if input_grid[3*i + r][3*j + c] != 0:
                        symbol_color = input_grid[3*i + r][3*j + c]
                        found = True
                        break
                if found:
                    break
            if not found:
                continue
            d_val = (symbol_color - 1) % 4 + 1
            if d_val == 1:
                new_r, new_c = r, (c + 1) % 3
            elif d_val == 2:
                new_r, new_c = (r + 1) % 3, c
            elif d_val == 3:
                new_r, new_c = r, (c - 1) % 3
            elif d_val == 4:
                new_r, new_c = (r - 1) % 3, c
            output_grid[3*i + new_r][3*j + new_c] = symbol_color
    
    for r in range(size):
        for c in range(size):
            if output_grid[r][c] == 0:
                i_block, j_block = r // 3, c // 3
                input_color = 0
                for r_in in range(3):
                    for c_in in range(3):
                        if input_grid[3*i_block + r_in][3*j_block + c_in] != 0:
                            input_color = input_grid[3*i_block + r_in][3*j_block + c_in]
                            break
                    if input_color != 0:
                        break
                if input_color == 0:
                    continue
                d_val = (input_color - 1) % 4 + 1
                d_opposite = 3 if d_val == 1 else 4 if d_val == 2 else 1 if d_val == 3 else 2
                if d_opposite == 1:
                    adj_i, adj_j = i_block, j_block + 1
                elif d_opposite == 2:
                    adj_i, adj_j = i_block + 1, j_block
                elif d_opposite == 3:
                    adj_i, adj_j = i_block, j_block - 1
                elif d_opposite == 4:
                    adj_i, adj_j = i_block - 1, j_block
                if not (0 <= adj_i < N and 0 <= adj_j < N):
                    continue
                adj_color = 0
                for r_in in range(3):
                    for c_in in range(3):
                        if input_grid[3*adj_i + r_in][3*adj_j + c_in] != 0:
                            adj_color = input_grid[3*adj_i + r_in][3*adj_j + c_in]
                            break
                    if adj_color != 0:
                        break
                if adj_color == 0:
                    continue
                output_grid[r][c] = adj_color
    
    input_colors = [val for row in input_grid for val in row if val != 0]
    if not input_colors:
        return {'input': input_grid, 'output': output_grid}
    color_count = {}
    for color in input_colors:
        color_count[color] = color_count.get(color, 0) + 1
    if len(color_count) < 2:
        return {'input': input_grid, 'output': output_grid}
    sorted_colors = sorted(color_count.items(), key=lambda x: x[1], reverse=True)
    color1, color2 = sorted_colors[0][0], sorted_colors[1][0]
    for r in range(size):
        for c in range(size):
            if output_grid[r][c] == color1:
                output_grid[r][c] = color2
            elif output_grid[r][c] == color2:
                output_grid[r][c] = color1
    
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    size = len(input_grid)
    N = size // 3
    output_grid = [[0] * size for _ in range(size)]
    for i in range(N):
        for j in range(N):
            found = False
            for r in range(3):
                for c in range(3):
                    if input_grid[3*i + r][3*j + c] != 0:
                        symbol_color = input_grid[3*i + r][3*j + c]
                        found = True
                        break
                if found:
                    break
            if not found:
                continue
            d_val = (symbol_color - 1) % 4 + 1
            if d_val == 1:
                new_r, new_c = r, (c + 1) % 3
            elif d_val == 2:
                new_r, new_c = (r + 1) % 3, c
            elif d_val == 3:
                new_r, new_c = r, (c - 1) % 3
            elif d_val == 4:
                new_r, new_c = (r - 1) % 3, c
            output_grid[3*i + new_r][3*j + new_c] = symbol_color
    
    for r in range(size):
        for c in range(size):
            if output_grid[r][c] == 0:
                i_block, j_block = r // 3, c // 3
                input_color = 0
                for r_in in range(3):
                    for c_in in range(3):
                        if input_grid[3*i_block + r_in][3*j_block + c_in] != 0:
                            input_color = input_grid[3*i_block + r_in][3*j_block + c_in]
                            break
                    if input_color != 0:
                        break
                if input_color == 0:
                    continue
                d_val = (input_color - 1) % 4 + 1
                d_opposite = 3 if d_val == 1 else 4 if d_val == 2 else 1 if d_val == 3 else 2
                if d_opposite == 1:
                    adj_i, adj_j = i_block, j_block + 1
                elif d_opposite == 2:
                    adj_i, adj_j = i_block + 1, j_block
                elif d_opposite == 3:
                    adj_i, adj_j = i_block, j_block - 1
                elif d_opposite == 4:
                    adj_i, adj_j = i_block - 1, j_block
                if not (0 <= adj_i < N and 0 <= adj_j < N):
                    continue
                adj_color = 0
                for r_in in range(3):
                    for c_in in range(3):
                        if input_grid[3*adj_i + r_in][3*adj_j + c_in] != 0:
                            adj_color = input_grid[3*adj_i + r_in][3*adj_j + c_in]
                            break
                    if adj_color != 0:
                        break
                if adj_color == 0:
                    continue
                output_grid[r][c] = adj_color
    
    input_colors = [val for row in input_grid for val in row if val != 0]
    if not input_colors:
        return output_grid
    color_count = {}
    for color in input_colors:
        color_count[color] = color_count.get(color, 0) + 1
    if len(color_count) < 2:
        return output_grid
    sorted_colors = sorted(color_count.items(), key=lambda x: x[1], reverse=True)
    color1, color2 = sorted_colors[0][0], sorted_colors[1][0]
    for r in range(size):
        for c in range(size):
            if output_grid[r][c] == color1:
                output_grid[r][c] = color2
            elif output_grid[r][c] == color2:
                output_grid[r][c] = color1
    
    return output_grid
