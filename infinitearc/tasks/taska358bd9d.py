# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: a358bd9d
Difficulty: medium–hard

=== Tags ===
- Coordinate warp
- Reconstruct checkerboard from hint
- Measure area
- Detect repetition

=== Description ===
Input grids display a checkerboard pattern distorted by a consistent coordinate
warp, where each row is shifted left by a fixed amount modulo a small integer
(e.g., row *r* is shifted by *r* mod *k* for *k* ∈ {2, 3}). The distortion
causes alternating colors to appear misaligned. Specific "hint" cells are
colored with a distinct marker color (e.g., red) and are positioned such that
their colors match the expected checkerboard pattern in the *undistorted* grid.
The output grid reconstructs the original checkerboard by detecting the
repeating pattern (via the hints), measuring the periodicity of the shift (e.g.,
distance between hints), and applying the inverse warp to realign all cells. The
solution requires identifying the shift period through repetition detection,
verifying area consistency of the repeating unit, and correcting the coordinate
warp to restore a perfect checkerboard with alternating colors.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Choose the period k (shift repeats every k rows)
    k = random.choice([2, 3])
    # Choose an offset for which rows will carry the hint markers (0..k-1)
    start = random.randint(0, k - 1)
    # Ensure height is large enough to contain at least two hint rows
    min_height = start + k * 2
    height = random.randint(max(6, min_height), min(25, max(6, min_height + 10)))
    width = random.randint(6, 25)

    color1, color2 = 1, 2
    marker = 3

    # Build the undistorted checkerboard (the desired output)
    base = [[color1 if (r + c) % 2 == 0 else color2 for c in range(width)] for r in range(height)]

    # Apply the consistent coordinate warp: left-shift each row by s = r % k
    input_grid = []
    for r in range(height):
        s = r % k
        row = base[r][s:] + base[r][:s]
        input_grid.append(list(row))

    # Place hint markers on a regular set of rows (start, start+k, ...).
    # Hints are placed on cells that match color1 in the undistorted grid so their
    # color agrees with the expected checkerboard before warping.
    for r in range(start, height, k):
        cols = [c for c in range(width) if base[r][c] == color1]
        if not cols:
            continue
        num_hints = random.randint(2, min(len(cols), max(2, min(6, len(cols)))))
        selected = random.sample(cols, num_hints)
        for c in selected:
            # Map the undistorted column c into the warped/input coordinates
            pos = (c - (r % k)) % width
            input_grid[r][pos] = marker

    # Safety: ensure input differs from output; if unlucky collision, try again quickly
    if input_grid == base:
        # perform a trivial extra shift on the first row to break equality
        if width > 1:
            input_grid[0] = input_grid[0][1:] + input_grid[0][:1]
        else:
            input_grid[0] = [ (input_grid[0][0] % 9) + 1 ]

    return {"input": input_grid, "output": base}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import math

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])

    # Detect a marker color: generator uses 1 and 2 for checkerboard and 3 for hints.
    vals = set()
    for row in grid:
        vals.update(row)
    marker = None
    for v in vals:
        if v not in (1, 2):
            marker = v
            break
    if marker is None:
        marker = 3

    # Find rows that contain markers
    hint_rows = [r for r in range(h) if any(grid[r][c] == marker for c in range(w))]

    # Determine k as the gcd of distances between successive hint rows (robust to noise)
    if len(hint_rows) >= 2:
        diffs = [hint_rows[i+1] - hint_rows[i] for i in range(len(hint_rows) - 1)]
        k = diffs[0]
        for d in diffs[1:]:
            k = math.gcd(k, d)
        if k <= 0:
            k = 2
    else:
        # fallback if no or single hint-row is found
        k = 2

    # Reconstruct the undistorted checkerboard by undoing the left shift (right shift by s=r%k)
    out = [[0] * w for _ in range(h)]
    for r in range(h):
        s = r % k
        for c in range(w):
            src = (c - s) % w
            val = grid[r][src]
            if val == marker:
                # Hints were placed on cells that originally had the color for even parity
                out[r][c] = 1 if ((r + c) % 2 == 0) else 2
            else:
                out[r][c] = val

    return tuple(tuple(row) for row in out)

