# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 2bbb66e4
Difficulty: easy

=== Tags ===
- Cylindrical
- Algebra
- Count tiles

=== Description ===
The task involves transforming an input grid into an output grid by shifting
each row's non-zero elements (referred to as "tiles") to the right by the count
of tiles in that row, with the grid wrapping around (cylindrical behavior). For
each row, the number of non-zero elements is counted, and all non-zero elements
are shifted right by this count, wrapping from the end of the row back to the
beginning. The transformation is applied uniformly to every row independently,
resulting in a visually distinct output grid where tile positions change based
on their row's tile count. This rule is simple to identify through visual
inspection of row-wise tile counts and their corresponding shifts.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(2, 30)
    height = random.randint(1, 30)
    input_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        k = random.randint(1, width - 1)
        positions = random.sample(range(width), k)
        for c in positions:
            input_grid[r][c] = random.randint(1, 9)
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        k = sum(1 for val in input_grid[r] if val != 0)
        for c in range(width):
            if input_grid[r][c] != 0:
                new_c = (c + k) % width
                output_grid[r][new_c] = input_grid[r][c]
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        k = sum(1 for val in input_grid[r] if val != 0)
        for c in range(width):
            if input_grid[r][c] != 0:
                new_c = (c + k) % width
                output_grid[r][new_c] = input_grid[r][c]
    return output_grid
