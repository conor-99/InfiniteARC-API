# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 6d33701a
Difficulty: very hard

=== Tags ===
- Rule based tiling
- Paint on collision
- Reflect by color
- Contouring
- Column parity coloring

=== Description ===
Input grids are large (20×20 or larger) with a uniform background color (0).
Overlaid are multiple disjoint, non-overlapping regions of solid colors (1–9),
each forming a contiguous 4-connected area. Regions never share the same color,
and no two regions of identical color are adjacent. Each region has a distinct
leftmost column (the smallest column index containing that region), which
determines its column parity (even or odd).   The output grid requires two
primary transformations applied simultaneously: (1) contouring and (2)
reflection-based color mapping. For each region, a single-pixel contour is drawn
around its perimeter. The default contour color is determined by the region’s
leftmost column parity: even columns use color A (e.g., 3), odd columns use
color B (e.g., 7). However, where two regions of different colors share an edge
(adjacency), their mutual boundary is replaced with a reflection color derived
from a fixed, consistent rule based on the pair of adjacent region colors (e.g.,
color 2 and 4 reflect to 9, color 5 and 6 reflect to 1).   Contouring must
preserve the original region shapes and avoid overlapping with background or
other regions. Reflections override default contour colors *only* along shared
edges between distinct-colored regions. The reflection rule is not numerical
(e.g., no sum or mod operations) but requires inductive deduction from input-
output examples (e.g., observing that adjacent red and blue regions always
produce green in the output).   Column parity coloring governs the default
contour color, while reflection by color governs interactions between adjacent
regions. Rule-based tiling refers to the requirement that all contour boundaries
must form closed loops around regions without gaps or overlaps, with reflection
rules applied consistently across all adjacent region pairs. The solution must
simultaneously track region positions, column parity, adjacency, and reflection
mappings to produce the correct output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import continuous_creature

# A fixed, non-numeric reflection mapping for unordered pairs (a,b) with a<b
reflection_map = {
    (1, 2): 3,
    (1, 3): 4,
    (1, 4): 5,
    (1, 5): 6,
    (1, 6): 7,
    (1, 7): 8,
    (1, 8): 9,
    (1, 9): 2,
    (2, 3): 4,
    (2, 4): 9,
    (2, 5): 1,
    (2, 6): 2,
    (2, 7): 3,
    (2, 8): 4,
    (2, 9): 5,
    (3, 4): 5,
    (3, 5): 6,
    (3, 6): 7,
    (3, 7): 8,
    (3, 8): 9,
    (3, 9): 1,
    (4, 5): 6,
    (4, 6): 7,
    (4, 7): 8,
    (4, 8): 9,
    (4, 9): 2,
    (5, 6): 1,
    (5, 7): 2,
    (5, 8): 3,
    (5, 9): 4,
    (6, 7): 3,
    (6, 8): 4,
    (6, 9): 5,
    (7, 8): 4,
    (7, 9): 5,
    (8, 9): 6,
}


def _make_sprite(max_w, max_h):
    # create a contiguous sprite using common.continuous_creature
    # choose a local box and a size
    local_w = random.randint(3, min(8, max_w))
    local_h = random.randint(3, min(8, max_h))
    max_cells = local_w * local_h
    size = random.randint(3, max(3, min(max_cells, 18)))
    pixels = continuous_creature(size, local_w, local_h)
    # continuous_creature already produces coordinates starting at (0,0)
    return pixels


def generate():
    # Attempt until we produce a placement that meets constraints.
    for attempt in range(2000):
        width = random.randint(20, 25)
        height = random.randint(20, 25)
        # number of regions
        n_regions = random.randint(3, 6)
        colors = random.sample(list(range(1, 10)), n_regions)

        placed = []  # list of (color, pixels)
        occupied = set()
        leftmost_cols = set()
        ok = True

        # Place each region sequentially, trying to avoid overlap and duplicate leftmost columns
        for color in colors:
            placed_success = False
            for _ in range(500):
                sprite = _make_sprite(width, height)
                if not sprite:
                    continue
                max_r = max(p[0] for p in sprite)
                max_c = max(p[1] for p in sprite)
                s_h = max_r + 1
                s_w = max_c + 1
                if s_h > height or s_w > width:
                    continue

                top = random.randint(0, height - s_h)
                left = random.randint(0, width - s_w)
                shifted = [(r + top, c + left) for (r, c) in sprite]

                # check overlap with existing regions
                if any(p in occupied for p in shifted):
                    continue

                # leftmost column of this region
                leftmost = min(c for (r, c) in shifted)
                if leftmost in leftmost_cols:
                    # enfore distinct leftmost column property
                    continue

                # accept placement
                placed.append((color, shifted))
                for p in shifted:
                    occupied.add(p)
                leftmost_cols.add(leftmost)
                placed_success = True
                break

            if not placed_success:
                ok = False
                break

        if not ok:
            continue

        # Build input grid
        ingrid = [[0 for _ in range(width)] for _ in range(height)]
        for color, pixels in placed:
            for (r, c) in pixels:
                ingrid[r][c] = color

        # Evaluate neighbor structure: we require at least one background cell with exactly 2
        # distinct region neighbors (so a reflection will appear), and we forbid any background
        # cell touching 3 or more different regions (that would create ambiguous reflections).
        two_count = 0
        bad = False
        for r in range(height):
            for c in range(width):
                if ingrid[r][c] != 0:
                    continue
                neighbors = set()
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and ingrid[nr][nc] != 0:
                        neighbors.add(ingrid[nr][nc])
                if len(neighbors) >= 3:
                    bad = True
                    break
                if len(neighbors) == 2:
                    two_count += 1
            if bad:
                break

        if bad or two_count == 0:
            # doesn't satisfy the reflection / ambiguity constraints, try again
            continue

        # Build output grid by drawing contours in background pixels
        region_default = {}
        for color, pixels in placed:
            leftmost = min(c for (r, c) in pixels)
            default = 3 if leftmost % 2 == 0 else 7
            region_default[color] = default

        outgrid = [row[:] for row in ingrid]
        for r in range(height):
            for c in range(width):
                if ingrid[r][c] != 0:
                    continue
                neighbors = set()
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and ingrid[nr][nc] != 0:
                        neighbors.add(ingrid[nr][nc])
                if not neighbors:
                    continue
                if len(neighbors) == 1:
                    color = next(iter(neighbors))
                    outgrid[r][c] = region_default[color]
                elif len(neighbors) == 2:
                    a, b = sorted(neighbors)
                    outgrid[r][c] = reflection_map[(a, b)]
                # we ruled out >=3 neighbors earlier

        return {"input": ingrid, "output": outgrid}

    # If we reach here, fail loudly
    raise RuntimeError("Could not generate a valid grid after many attempts")



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

# The same reflection map used by the generator (unordered pairs)
reflection_map = {
    (1, 2): 3,
    (1, 3): 4,
    (1, 4): 5,
    (1, 5): 6,
    (1, 6): 7,
    (1, 7): 8,
    (1, 8): 9,
    (1, 9): 2,
    (2, 3): 4,
    (2, 4): 9,
    (2, 5): 1,
    (2, 6): 2,
    (2, 7): 3,
    (2, 8): 4,
    (2, 9): 5,
    (3, 4): 5,
    (3, 5): 6,
    (3, 6): 7,
    (3, 7): 8,
    (3, 8): 9,
    (3, 9): 1,
    (4, 5): 6,
    (4, 6): 7,
    (4, 7): 8,
    (4, 8): 9,
    (4, 9): 2,
    (5, 6): 1,
    (5, 7): 2,
    (5, 8): 3,
    (5, 9): 4,
    (6, 7): 3,
    (6, 8): 4,
    (6, 9): 5,
    (7, 8): 4,
    (7, 9): 5,
    (8, 9): 6,
}


def p(input_grid):
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])

    visited = [[False] * w for _ in range(h)]
    regions = {}  # color -> list of pixels

    for r in range(h):
        for c in range(w):
            if grid[r][c] == 0 or visited[r][c]:
                continue
            color = grid[r][c]
            # BFS to collect the connected region
            q = deque()
            q.append((r, c))
            visited[r][c] = True
            pixels = []
            while q:
                cr, cc = q.popleft()
                pixels.append((cr, cc))
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] == color:
                        visited[nr][nc] = True
                        q.append((nr, nc))
            regions[color] = pixels

    # Determine default contour color per region based on leftmost column parity
    region_default = {}
    for color, pixels in regions.items():
        leftmost = min(c for (r, c) in pixels)
        region_default[color] = 3 if leftmost % 2 == 0 else 7

    # Create output by painting contours into background cells
    out = [row[:] for row in grid]
    for r in range(h):
        for c in range(w):
            if grid[r][c] != 0:
                continue
            neighbors = set()
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = r + dr, c + dc
                if 0 <= nr < h and 0 <= nc < w and grid[nr][nc] != 0:
                    neighbors.add(grid[nr][nc])
            if not neighbors:
                continue
            if len(neighbors) == 1:
                col = next(iter(neighbors))
                out[r][c] = region_default[col]
            else:
                a, b = sorted(neighbors)[:2]
                out[r][c] = reflection_map[(a, b)]

    return out

