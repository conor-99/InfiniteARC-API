# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: f3702982
Difficulty: very hard

=== Tags ===
- Mark wall impact
- Synchronized bounce
- Boolean color logic
- Multi agent path weaving

=== Description ===
## Task Name: Synchronized Agent Path Weaving  Tags: - Mark wall impact -
Synchronized bounce - Boolean color logic - Multi agent path weaving
Description: Input grids feature a background (color 0), walls (color 5), and
agents (colors 1–4 representing right, up, left, down movement directions).
Agents move simultaneously one cell per step in their direction. Upon hitting a
wall (color 5), an agent leaves a directional mark (color 6 for right, 7 for up,
8 for left, 9 for down) in the cell immediately before the wall, then reverses
direction. When two agents occupy the same cell, they merge into a new agent
using logical OR color logic (e.g., color 1 OR color 2 = color 3, color 3 OR
color 3 = color 3), and the merged agent’s movement direction aligns with its
new color’s direction. All movement, marking, and merging occur in parallel
synchronization across the grid. The output grid displays all wall impact marks,
merged agents, and final agent positions after all interactions stabilize, with
no input-output grid identity. Agents may weave through complex paths, create
new paths via merges, and leave directional marks at every wall collision,
requiring multi-step logical and spatial reasoning to deduce the transformation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import defaultdict

or_table = {
    (1, 1): 1, (1, 2): 3, (1, 3): 2, (1, 4): 4,
    (2, 1): 3, (2, 2): 2, (2, 3): 4, (2, 4): 1,
    (3, 1): 2, (3, 2): 4, (3, 3): 3, (3, 4): 1,
    (4, 1): 4, (4, 2): 1, (4, 3): 1, (4, 4): 4
}

directions = {
    1: (0, 1),  # right
    2: (-1, 0), # up
    3: (0, -1), # left
    4: (1, 0)   # down
}

mark_colors = {
    1: 6,  # right
    2: 7,  # up
    3: 8,  # left
    4: 9   # down
}

def simulate(grid):
    height = len(grid)
    width = len(grid[0])
    max_steps = 100  # Reduced from 1000 to 100
    for _ in range(max_steps):
        next_grid = [row[:] for row in grid]
        new_positions = defaultdict(list)
        changes = False

        for r in range(height):
            for c in range(width):
                color = grid[r][c]
                if color in [1, 2, 3, 4]:
                    dr, dc = directions[color]
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        if grid[nr][nc] == 5:
                            next_grid[r][c] = mark_colors[color]
                            changes = True
                        else:
                            next_grid[r][c] = 0
                            new_positions[(nr, nc)].append(color)
                            changes = True
                    else:
                        next_grid[r][c] = mark_colors[color]
                        changes = True

        for (nr, nc), colors in new_positions.items():
            if len(colors) > 1:
                merged_color = colors[0]
                for c in colors[1:]:
                    merged_color = or_table[(merged_color, c)]
                next_grid[nr][nc] = merged_color
                changes = True
            else:
                next_grid[nr][nc] = colors[0]
                changes = True

        if not changes:
            break
        grid = next_grid
    return grid

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    grid = [[0] * width for _ in range(height)]
    wall_count = random.randint(1, width * height // 4)
    for _ in range(wall_count):
        r, c = random.randint(0, height-1), random.randint(0, width-1)
        grid[r][c] = 5
    agent_count = random.randint(1, 10)
    for _ in range(agent_count):
        while True:
            r, c = random.randint(0, height-1), random.randint(0, width-1)
            if grid[r][c] == 0:
                grid[r][c] = random.randint(1, 4)
                break
    output = simulate(grid)
    if grid == output:
        output = simulate(grid)
        for _ in range(5):
            if grid != output:
                break
            output = simulate(grid)
    return {'input': grid, 'output': output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import defaultdict

or_table = {
    (1, 1): 1, (1, 2): 3, (1, 3): 2, (1, 4): 4,
    (2, 1): 3, (2, 2): 2, (2, 3): 4, (2, 4): 1,
    (3, 1): 2, (3, 2): 4, (3, 3): 3, (3, 4): 1,
    (4, 1): 4, (4, 2): 1, (4, 3): 1, (4, 4): 4
}

directions = {
    1: (0, 1),  # right
    2: (-1, 0), # up
    3: (0, -1), # left
    4: (1, 0)   # down
}

mark_colors = {
    1: 6,  # right
    2: 7,  # up
    3: 8,  # left
    4: 9   # down
}

def simulate(grid):
    height = len(grid)
    width = len(grid[0])
    max_steps = 100  # Reduced from 1000 to 100
    for _ in range(max_steps):
        next_grid = [row[:] for row in grid]
        new_positions = defaultdict(list)
        changes = False

        for r in range(height):
            for c in range(width):
                color = grid[r][c]
                if color in [1, 2, 3, 4]:
                    dr, dc = directions[color]
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        if grid[nr][nc] == 5:
                            next_grid[r][c] = mark_colors[color]
                            changes = True
                        else:
                            next_grid[r][c] = 0
                            new_positions[(nr, nc)].append(color)
                            changes = True
                    else:
                        next_grid[r][c] = mark_colors[color]
                        changes = True

        for (nr, nc), colors in new_positions.items():
            if len(colors) > 1:
                merged_color = colors[0]
                for c in colors[1:]:
                    merged_color = or_table[(merged_color, c)]
                next_grid[nr][nc] = merged_color
                changes = True
            else:
                next_grid[nr][nc] = colors[0]
                changes = True

        if not changes:
            break
        grid = next_grid
    return grid

def p(input_grid):
    grid = [list(row) for row in input_grid]
    return simulate(grid)
