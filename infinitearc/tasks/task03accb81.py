# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 03accb81
Difficulty: very hard

=== Tags ===
- Color particle emission
- Hierarchical reasoning

=== Description ===
Input grids feature three concentric rectangular frames, each enclosing a
distinct layer. Within each layer, colored cells (excluding background color 0)
represent particles that move in a direction determined by their color (e.g.,
red particles move right, blue particles move down). Particles move one cell per
step in their direction until they collide with another particle, reach a frame
boundary, or the grid edge. Upon collision, particles combine into a new color
based on a consistent rule (e.g., red + blue = green). When particles reach a
frame boundary, they transition to the next inner layer, with their movement
direction rotating 90 degrees clockwise. This process continues hierarchically
across all layers until no further movement or collisions occur. The output grid
displays the final configuration after all particles have completed their
movement and interactions across all layers, with background cells remaining
unchanged. The task requires recognizing the directional mapping, collision
rules, and hierarchical transformation sequence to accurately predict the
output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

FRAME = 5
PALETTE = [1,2,3,4,6,7,8,9]  # allowed particle colors (exclude FRAME=5)
PARTICLE_COLORS = [1,2,3,4]
DIRECTIONS = [(0,1),(1,0),(0,-1),(-1,0)]  # 0:right,1:down,2:left,3:up
DIR_MAP = {1:0, 2:1, 3:2, 4:3}


def draw_frame(g, top, left, bottom, right):
    # draw a one-pixel-thick rectangular frame (border)
    for c in range(left, right + 1):
        g[top][c] = FRAME
        g[bottom][c] = FRAME
    for r in range(top, bottom + 1):
        g[r][left] = FRAME
        g[r][right] = FRAME


def simulate(in_grid):
    # Simulate particle movement and collisions until stable.
    N = len(in_grid)
    base = [row[:] for row in in_grid]
    frames = set()
    for r in range(N):
        for c in range(N):
            if base[r][c] == FRAME:
                frames.add((r, c))

    # initialize particles: any cell that is non-zero and not a frame is a particle
    particles = []  # list of tuples (r, c, color, direction)
    for r in range(N):
        for c in range(N):
            val = base[r][c]
            if val != 0 and val != FRAME:
                color = val
                # initial colors 1..4 map to directions; combined colors carry direction separately
                direction = DIR_MAP.get(color, 0)
                particles.append((r, c, color, direction))

    max_steps = max(100, N * N)
    for _ in range(max_steps):
        if not particles:
            break
        desires = {}  # dest -> list of (idx, pr, pc, color, dir)
        for idx, (r, c, color, direction) in enumerate(particles):
            dr, dc = DIRECTIONS[direction]
            nr, nc = r + dr, c + dc
            # default: stay in place
            dest_r, dest_c = r, c
            new_dir = direction
            # attempt to move one step
            if not (0 <= nr < N and 0 <= nc < N):
                # out of bounds: stay
                dest_r, dest_c = r, c
            elif (nr, nc) in frames:
                # reached a frame boundary -> attempt to cross into next inner layer
                n2r, n2c = nr + dr, nc + dc
                if not (0 <= n2r < N and 0 <= n2c < N):
                    # cannot cross: stay
                    dest_r, dest_c = r, c
                elif (n2r, n2c) in frames:
                    # cannot cross into another frame: stay
                    dest_r, dest_c = r, c
                else:
                    # successful crossing: land one cell inside and rotate direction clockwise
                    dest_r, dest_c = n2r, n2c
                    new_dir = (direction + 1) % 4
            else:
                # normal step into interior cell (may collide)
                dest_r, dest_c = nr, nc
                new_dir = direction

            desires.setdefault((dest_r, dest_c), []).append((idx, r, c, color, new_dir))

        # resolve collisions and form new particle list
        new_particles = []
        for (dr_dest, dc_dest), coll in desires.items():
            if len(coll) == 1:
                _, pr, pc, color, ddir = coll[0]
                new_particles.append((dr_dest, dc_dest, color, ddir))
            else:
                # combine colors deterministically and pick direction of the earliest particle (by idx)
                sum_colors = sum(c[3] for c in coll)
                combined_color = PALETTE[sum_colors % len(PALETTE)]
                chosen = min(coll, key=lambda x: x[0])
                chosen_dir = chosen[4]
                new_particles.append((dr_dest, dc_dest, combined_color, chosen_dir))

        # if nothing changed (positions/colors/directions) then stable
        old_state = sorted(particles)
        new_state = sorted(new_particles)
        if old_state == new_state:
            particles = new_particles
            break
        particles = new_particles

    # build output grid: frames stay, background 0, particles with their colors
    out = [[0 for _ in range(N)] for _ in range(N)]
    for (r, c) in frames:
        out[r][c] = FRAME
    for (r, c, color, _) in particles:
        out[r][c] = color
    return out


def generate():
    # Create many different instances by randomizing N, particle counts and positions.
    tries = 0
    while True:
        tries += 1
        N = random.randint(15, 25)
        grid = [[0 for _ in range(N)] for _ in range(N)]

        # fixed concentric frames (one-pixel thick)
        f1_top, f1_left = 2, 2
        f1_bottom, f1_right = N - 3, N - 3
        f2_top, f2_left = 4, 4
        f2_bottom, f2_right = N - 5, N - 5
        f3_top, f3_left = 6, 6
        f3_bottom, f3_right = N - 7, N - 7

        # Safety: if frames overlap incorrectly (very small N) retry
        if not (f1_top < f1_bottom and f2_top < f2_bottom and f3_top < f3_bottom):
            if tries > 10:
                # fallback to safe sizes
                N = 15
                grid = [[0 for _ in range(N)] for _ in range(N)]
                f1_top, f1_left = 2, 2
                f1_bottom, f1_right = N - 3, N - 3
                f2_top, f2_left = 4, 4
                f2_bottom, f2_right = N - 5, N - 5
                f3_top, f3_left = 6, 6
                f3_bottom, f3_right = N - 7, N - 7
            else:
                continue

        # draw frames as borders
        draw_frame(grid, f1_top, f1_left, f1_bottom, f1_right)
        draw_frame(grid, f2_top, f2_left, f2_bottom, f2_right)
        draw_frame(grid, f3_top, f3_left, f3_bottom, f3_right)

        # compute layer cells (interiors excluding inner frames and their borders)
        layer1 = []
        for r in range(f1_top + 1, f1_bottom):
            for c in range(f1_left + 1, f1_right):
                # exclude interior of frame2 (including its border)
                if f2_top <= r <= f2_bottom and f2_left <= c <= f2_right:
                    continue
                layer1.append((r, c))

        layer2 = []
        for r in range(f2_top + 1, f2_bottom):
            for c in range(f2_left + 1, f2_right):
                if f3_top <= r <= f3_bottom and f3_left <= c <= f3_right:
                    continue
                layer2.append((r, c))

        layer3 = []
        for r in range(f3_top + 1, f3_bottom):
            for c in range(f3_left + 1, f3_right):
                layer3.append((r, c))

        # ensure each layer has at least one available cell
        if not layer1 or not layer2 or not layer3:
            continue

        # populate particles in each layer
        for layer in (layer1, layer2, layer3):
            max_places = min(6, len(layer))
            num = random.randint(1, max(1, max_places))
            choices = random.sample(layer, num)
            for (r, c) in choices:
                color = random.choice(PARTICLE_COLORS)
                grid[r][c] = color

        # make copies so simulate doesn't modify the input we return
        input_grid = [row[:] for row in grid]
        output_grid = simulate(input_grid)

        # ensure output differs from input (so task is non-trivial)
        if output_grid != input_grid:
            return {"input": input_grid, "output": output_grid}
        # else try again (rare)



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Solver mirrors the generator's simulation logic exactly.
    import random

    FRAME = 5
    PALETTE = [1,2,3,4,6,7,8,9]
    DIRECTIONS = [(0,1),(1,0),(0,-1),(-1,0)]
    DIR_MAP = {1:0, 2:1, 3:2, 4:3}

    def simulate(in_grid):
        N = len(in_grid)
        base = [row[:] for row in in_grid]
        frames = set()
        for r in range(N):
            for c in range(N):
                if base[r][c] == FRAME:
                    frames.add((r, c))

        particles = []
        for r in range(N):
            for c in range(N):
                val = base[r][c]
                if val != 0 and val != FRAME:
                    color = val
                    direction = DIR_MAP.get(color, 0)
                    particles.append((r, c, color, direction))

        max_steps = max(100, N * N)
        for _ in range(max_steps):
            if not particles:
                break
            desires = {}
            for idx, (r, c, color, direction) in enumerate(particles):
                dr, dc = DIRECTIONS[direction]
                nr, nc = r + dr, c + dc
                dest_r, dest_c = r, c
                new_dir = direction
                if not (0 <= nr < N and 0 <= nc < N):
                    dest_r, dest_c = r, c
                elif (nr, nc) in frames:
                    n2r, n2c = nr + dr, nc + dc
                    if not (0 <= n2r < N and 0 <= n2c < N):
                        dest_r, dest_c = r, c
                    elif (n2r, n2c) in frames:
                        dest_r, dest_c = r, c
                    else:
                        dest_r, dest_c = n2r, n2c
                        new_dir = (direction + 1) % 4
                else:
                    dest_r, dest_c = nr, nc
                    new_dir = direction

                desires.setdefault((dest_r, dest_c), []).append((idx, r, c, color, new_dir))

            new_particles = []
            for (dr_dest, dc_dest), coll in desires.items():
                if len(coll) == 1:
                    _, pr, pc, color, ddir = coll[0]
                    new_particles.append((dr_dest, dc_dest, color, ddir))
                else:
                    sum_colors = sum(c[3] for c in coll)
                    combined_color = PALETTE[sum_colors % len(PALETTE)]
                    chosen = min(coll, key=lambda x: x[0])
                    chosen_dir = chosen[4]
                    new_particles.append((dr_dest, dc_dest, combined_color, chosen_dir))

            old_state = sorted(particles)
            new_state = sorted(new_particles)
            if old_state == new_state:
                particles = new_particles
                break
            particles = new_particles

        out = [[0 for _ in range(N)] for _ in range(N)]
        for (r, c) in frames:
            out[r][c] = FRAME
        for (r, c, color, _) in particles:
            out[r][c] = color
        return out

    grid = [list(row) for row in input_grid]
    return simulate(grid)

