# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 5a6d838e
Difficulty: hard

=== Tags ===
- State transition by contact
- Pattern analogy
- Color by distance to center

=== Description ===
The input grid is a 2D grid of dimensions between 15×15 and 30×30, with each
cell containing a color value between 0 and 9. The grid features a central point
(calculated as the geometric center of the grid), and each cell's base color is
determined by its Manhattan distance to this center, following a predefined
color sequence (e.g., distance 0: color 1, distance 1: color 2, distance 2:
color 3, etc.). However, the grid also contains multiple distinct, non-
overlapping contiguous patterns (each pattern being a single-color region) that
override the base distance-based color. These patterns are placed such that they
do not overlap the central point and form irregular shapes (e.g., squares,
spirals, or abstract clusters) with no internal gaps.  The output grid is
generated through three layered transformations:  1. **Color by Distance to
Center**: All background cells (those not part of any pattern) are recolored
based on their Manhattan distance to the grid's center, using the predefined
sequence. The central cell (distance 0) is always color 1, the immediate ring
(distance 1) color 2, and so on.  2. **Pattern Analogy**: The top-left corner of
the input grid contains a 2×2 pattern block that defines a cyclic color sequence
(e.g., [3, 7, 2, 5]). This sequence dictates the transition logic for adjacent
patterns in the output. The sequence is cyclic, meaning it repeats indefinitely
(e.g., 3 → 7 → 2 → 5 → 3 → ...).  3. **State Transition by Contact**: For any
two adjacent cells (horizontally or vertically) that belong to different
patterns (i.e., pattern A and pattern B), the cells at their shared boundary
transition to the next color in the top-left sequence. Specifically, if pattern
A uses color X and pattern B uses color Y, and X precedes Y in the sequence, the
boundary cells transition to the color immediately following Y in the sequence.
For example, if the sequence is [3, 7, 2] and adjacent patterns use colors 3 and
7, the boundary transitions to 2. This transition applies only once per
boundary, and the new color persists for the output grid. Patterns not in
contact with other patterns retain their original color.  The output grid must
preserve all non-contact pattern regions, correctly apply distance-based
coloring to background cells, and implement boundary transitions based on the
top-left sequence. No two patterns may overlap, and all transitions must
strictly follow the cyclic sequence defined by the top-left pattern. The task
requires recognizing the sequence, identifying pattern boundaries, and applying
the transition logic in a way that is not immediately obvious from the input
grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, connected, random_colors, grid

def generate():
    width = random.randint(15, 30)
    height = random.randint(15, 30)
    r_center = height // 2
    c_center = width // 2
    
    # Create base grid
    base_grid = [[(abs(r - r_center) + abs(c - c_center)) % 9 + 1 for c in range(width)] for r in range(height)]
    input_grid = [row[:] for row in base_grid]
    
    # Get S from top-left 2x2
    S = random.sample(list(range(1, 10)), 4)
    input_grid[0][0] = S[0]
    input_grid[0][1] = S[1]
    input_grid[1][0] = S[2]
    input_grid[1][1] = S[3]
    
    # Place additional patterns
    patterns = []
    for _ in range(random.randint(1, 3)):
        color = random.choice(S)
        # Generate random connected region
        pixels = []
        while len(pixels) < random.randint(3, 5):
            r, c = random.randint(0, height-1), random.randint(0, width-1)
            if (r, c) == (r_center, c_center) or (r, c) in [(0,0), (0,1), (1,0), (1,1)]:
                continue
            pixels.append((r, c))
        if not connected(pixels):
            continue
        for r, c in pixels:
            input_grid[r][c] = color
        patterns.append((color, pixels))
    
    # Create output grid
    output_grid = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width):
            for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    if input_grid[r][c] != base_grid[r][c] and input_grid[nr][nc] != base_grid[nr][nc]:
                        X = input_grid[r][c]
                        Y = input_grid[nr][nc]
                        if X != Y and X in S and Y in S:
                            idx_X = S.index(X)
                            idx_Y = S.index(Y)
                            if idx_X < idx_Y:
                                new_color = S[(idx_Y + 1) % 4]
                                output_grid[r][c] = new_color
                                output_grid[nr][nc] = new_color
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    r_center = height // 2
    c_center = width // 2
    base_grid = [[(abs(r - r_center) + abs(c - c_center)) % 9 + 1 for c in range(width)] for r in range(height)]
    S = [input_grid[0][0], input_grid[0][1], input_grid[1][0], input_grid[1][1]]
    output_grid = [row[:] for row in input_grid]
    
    for r in range(height):
        for c in range(width):
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    if input_grid[r][c] != base_grid[r][c] and input_grid[nr][nc] != base_grid[nr][nc]:
                        X = input_grid[r][c]
                        Y = input_grid[nr][nc]
                        if X != Y and X in S and Y in S:
                            idx_X = S.index(X)
                            idx_Y = S.index(Y)
                            if idx_X < idx_Y:
                                new_color = S[(idx_Y + 1) % 4]
                                output_grid[r][c] = new_color
                                output_grid[nr][nc] = new_color
    return tuple(tuple(row) for row in output_grid)
