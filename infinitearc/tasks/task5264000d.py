# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 5264000d
Difficulty: very hard

=== Tags ===
- Bidirectional escape
- Beam reflection

=== Description ===
Input grids feature a large background (0) with scattered colored mirrors (2, 3,
4) and beams (1) positioned along grid edges. Beams move away from their
starting edge (left→right, top→down, right→left, bottom→up). Upon hitting a
mirror: color 2 reflects 90° clockwise, color 3 reflects 90° counterclockwise,
color 4 reverses direction. The beam path is drawn over background cells as
color 1 in the output, while mirrors remain unchanged. Paths extend until beams
exit the grid, with no loops or overlaps. Output shows all completed paths and
preserved mirrors, with background cells unchanged except for the drawn paths.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    """Generate a single ARC-style input/output pair for the beam-and-mirrors task.

    The generator creates a random grid with one beam (1) starting on an edge (not a corner),
    and then simulates the beam moving through the grid. Mirrors (2,3,4) can be placed on
    cells the beam visits to change its direction: 2 = 90deg clockwise, 3 = 90deg counterclockwise,
    4 = reverse. The input grid contains the beam start (1) on the edge and the mirrors (2/3/4).
    The output grid draws the complete beam path as 1 over background cells, while mirrors remain
    unchanged. The generator ensures the beam exits the grid (no stuck paths) and that the input
    differs from the output (there is at least one traversed non-mirror cell).
    """
    max_attempts = 200
    attempts = 0
    while True:
        attempts += 1
        if attempts > max_attempts:
            # Fallback deterministic small valid case (should almost never be used)
            width, height = 10, 10
            side = 'left'
            r, c = height // 2, 0
            cur_dir = (0, 1)
            input_grid = [[0] * width for _ in range(height)]
            input_grid[r][c] = 1
            output_grid = [row[:] for row in input_grid]
            # draw a short straight path to the right
            for cc in range(1, 4):
                output_grid[r][cc] = 1
            return {'input': input_grid, 'output': output_grid}

        width = random.randint(9, 20)
        height = random.randint(9, 20)

        # Choose a starting edge and a position on that edge, avoid corners to keep direction unambiguous
        side = random.choice(['left', 'right', 'top', 'bottom'])
        if side == 'left':
            r = random.randint(1, height - 2)
            c = 0
            cur_dir = (0, 1)
        elif side == 'right':
            r = random.randint(1, height - 2)
            c = width - 1
            cur_dir = (0, -1)
        elif side == 'top':
            r = 0
            c = random.randint(1, width - 2)
            cur_dir = (1, 0)
        else:
            r = height - 1
            c = random.randint(1, width - 2)
            cur_dir = (-1, 0)

        input_grid = [[0] * width for _ in range(height)]
        input_grid[r][c] = 1

        path = [(r, c)]
        visited = set(path)
        mirrors = {}
        current = (r, c)
        first_step = True
        exited = False
        steps = 0
        max_steps = width * height  # safety bound

        while steps < max_steps:
            next_r = current[0] + cur_dir[0]
            next_c = current[1] + cur_dir[1]

            # If the beam would leave the grid, we're done successfully
            if not (0 <= next_r < height and 0 <= next_c < width):
                exited = True
                break

            # Avoid stepping into a previously visited cell (would cause overlap/loop)
            if (next_r, next_c) in visited:
                # This path got into a tight situation; abort and try a fresh generation
                break

            # Decide whether to place a mirror at the next cell. Force the very first move to be
            # a non-mirror so that there's at least one traversed non-mirror cell (ensures input != output).
            if first_step:
                place_mirror = False
                first_step = False
            else:
                place_mirror = random.random() < 0.55

            chosen_mirror = None
            new_dir = None

            if place_mirror:
                # Try mirror types in random order; accept the first that does not immediately revisit
                # an already visited cell (the cell after the mirror). It's okay if the beam would exit
                # immediately after the mirror.
                choices = [2, 3, 4]
                random.shuffle(choices)
                for m in choices:
                    if m == 2:
                        nd = (cur_dir[1], -cur_dir[0])  # 90 deg clockwise
                    elif m == 3:
                        nd = (-cur_dir[1], cur_dir[0])  # 90 deg counterclockwise
                    else:
                        nd = (-cur_dir[0], -cur_dir[1])  # reverse
                    after_r = next_r + nd[0]
                    after_c = next_c + nd[1]
                    # If the cell after the mirror is inside the grid and already visited, placing
                    # this mirror would immediately cause a revisit; skip it.
                    if (0 <= after_r < height and 0 <= after_c < width) and ((after_r, after_c) in visited):
                        continue
                    chosen_mirror = m
                    new_dir = nd
                    break

                if chosen_mirror is None:
                    # No mirror choice was safe here; fall back to no mirror (straight)
                    place_mirror = False

            # Step the beam into the next cell
            path.append((next_r, next_c))
            visited.add((next_r, next_c))

            if place_mirror:
                mirrors[(next_r, next_c)] = chosen_mirror
                cur_dir = new_dir
            # else continue straight

            current = (next_r, next_c)
            steps += 1

        # Require the beam to have exited the grid; otherwise restart generation
        if not exited:
            continue

        # Fill input grid with mirrors encountered along the path (start stays as 1)
        for (mr, mc), color in mirrors.items():
            input_grid[mr][mc] = color

        # Add a few scattered distractor mirrors that are not on the beam path
        max_distractors = max(0, (width * height) // 40)
        num_distractors = random.randint(0, max_distractors)
        placed = 0
        tries = 0
        while placed < num_distractors and tries < 200:
            tries += 1
            rr = random.randrange(0, height)
            cc = random.randrange(0, width)
            if (rr, cc) in visited:
                continue
            if input_grid[rr][cc] != 0:
                continue
            input_grid[rr][cc] = random.choice([2, 3, 4])
            placed += 1

        # Build the output grid: draw the beam path as 1 on non-mirror cells, mirrors remain unchanged
        output_grid = [row[:] for row in input_grid]
        for (pr, pc) in path:
            if (pr, pc) in mirrors:
                output_grid[pr][pc] = mirrors[(pr, pc)]
            else:
                output_grid[pr][pc] = 1

        # Sanity check: ensure input != output (there is at least one traversed non-mirror cell)
        if input_grid == output_grid:
            continue

        return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert tuple-of-tuples grid into a mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # Start with a copy of the input; we'll draw beam paths onto this copy
    output = [row[:] for row in grid]

    # Collect all beam starts located on the grid edges (value == 1)
    starts = set()
    if height == 0 or width == 0:
        return output

    # Top and bottom rows
    for c in range(width):
        if grid[0][c] == 1:
            starts.add((0, c))
        if grid[height - 1][c] == 1:
            starts.add((height - 1, c))
    # Left and right columns
    for r in range(height):
        if grid[r][0] == 1:
            starts.add((r, 0))
        if grid[r][width - 1] == 1:
            starts.add((r, width - 1))

    # Simulate each beam from its edge start
    for start in starts:
        sr, sc = start
        # Determine initial direction pointing into the grid away from the edge
        if sc == 0:
            cur_dir = (0, 1)
        elif sc == width - 1:
            cur_dir = (0, -1)
        elif sr == 0:
            cur_dir = (1, 0)
        else:
            cur_dir = (-1, 0)

        # Ensure the starting cell is shown as beam (1)
        output[sr][sc] = 1

        current = (sr, sc)
        visited = {current}
        steps = 0
        max_steps = height * width * 4

        # Move the beam until it exits the grid
        while steps < max_steps:
            nr = current[0] + cur_dir[0]
            nc = current[1] + cur_dir[1]

            # If beam leaves the grid, stop this beam
            if not (0 <= nr < height and 0 <= nc < width):
                break

            val = grid[nr][nc]
            if val in (2, 3, 4):
                # Mirror encountered: update direction but keep mirror color in output
                if val == 2:
                    cur_dir = (cur_dir[1], -cur_dir[0])
                elif val == 3:
                    cur_dir = (-cur_dir[1], cur_dir[0])
                else:  # val == 4
                    cur_dir = (-cur_dir[0], -cur_dir[1])
            else:
                # Draw the beam path on non-mirror cell
                output[nr][nc] = 1

            current = (nr, nc)
            # Safety check: if we revisit a cell, stop to avoid infinite loops
            if current in visited:
                break
            visited.add(current)
            steps += 1

    return output

