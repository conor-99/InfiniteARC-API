# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 3e53bf26
Difficulty: insane

=== Tags ===
- Pattern to sequence mapping
- Infer hidden grid
- Wraparound copy
- Diagonal symmetry

=== Description ===
Input grids are 20×20 grids with colors 0–9, featuring overlapping diagonal wave
patterns that obscure the primary diagonal. Each wave follows a consistent
diagonal path (top-left to bottom-right) and alternates between two colors,
forming a visible sequence along secondary diagonals. The hidden grid is
inferred by tracing these wave patterns to reconstruct the primary diagonal's
color sequence, where the dominant color of each wave corresponds to the primary
diagonal's value at that position.   The output grid is generated through a
multi-step transformation: First, the primary diagonal sequence is mapped to
shift amounts (color 0 = shift 0, color 1 = shift 1, ..., color 9 = shift 9).
Each row is then cyclically shifted left by its corresponding shift amount, with
wraparound (e.g., shifting row 5 by 7 positions in a 20-column grid wraps to
position 12). Crucially, the shift amounts are symmetric along the anti-diagonal
(row i uses the same shift as row 19-i), enforcing diagonal symmetry in the
output. Finally, a wraparound copy operation copies the grid's content to its
diagonal reflection, ensuring all cells (i,j) match (j,i) after shifting, with
wraparound preserving continuity across grid edges. The output grid must
maintain all original colors while fulfilling the symmetry and shift
constraints.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import Counter

def generate():
    # Generate symmetric shift sequence d[0..19]
    d0 = [random.randint(0, 9) for _ in range(10)]
    d = d0 + d0[::-1]
    
    # Create input grid
    input_grid = [[0] * 20 for _ in range(20)]
    for k in range(-19, 20):
        cells = []
        for i in range(20):
            j = i - k
            if 0 <= j < 20:
                cells.append((i, j))
        L = len(cells)
        num_dominant = (L + 1) // 2
        dominant_color = d[(k + 20) % 20]
        alternate_color = (dominant_color + 1) % 10
        for idx, (i, j) in enumerate(cells):
            if idx < num_dominant:
                input_grid[i][j] = dominant_color
            else:
                input_grid[i][j] = alternate_color

    # Create output grid
    shifted = [[0] * 20 for _ in range(20)]
    for i in range(20):
        s = d[i]
        for j in range(20):
            shifted[i][j] = input_grid[i][(j + s) % 20]
    
    output_grid = [[shifted[j][i] for j in range(20)] for i in range(20)]
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to list of lists
    grid = [list(row) for row in input_grid]
    d = [0] * 20
    
    # Infer d from input grid
    for k in range(-19, 20):
        cells = []
        for i in range(20):
            j = i - k
            if 0 <= j < 20:
                cells.append(grid[i][j])
        count = {}
        for color in cells:
            count[color] = count.get(color, 0) + 1
        dominant_color = max(count.items(), key=lambda x: x[1])[0]
        idx = (k + 20) % 20
        d[idx] = dominant_color
    
    # Shift rows
    shifted = [[0] * 20 for _ in range(20)]
    for i in range(20):
        s = d[i]
        for j in range(20):
            shifted[i][j] = grid[i][(j + s) % 20]
    
    # Transpose
    output = [[shifted[j][i] for j in range(20)] for i in range(20)]
    return output
