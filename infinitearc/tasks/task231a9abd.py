# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 231a9abd
Difficulty: easy

=== Tags ===
- Draw line from border
- Image filling
- Maze

=== Description ===
The input grid displays a simple maze-like structure where a single contiguous
path of identical color cells extends from the top border to the bottom border.
This path forms a continuous vertical or diagonal line through the grid, with
walls or other colors surrounding it. The output grid transforms this input by
replacing all cells along the path (the contiguous region connected to the top
border) with a new, consistent color, creating a clear, unbroken line that spans
from the top to the bottom of the grid. The transformation relies solely on
visual connectivity and spatial reasoning, with no numerical or color-based
dependencies, making it intuitive for an "easy" difficulty task.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    Y = random.randint(0, 9)
    X = random.randint(0, 9)
    while X == Y or X == 3:
        X = random.randint(0, 9)
    # Generate path that blocks background connection
    pixels = [(r, 0) for r in range(height)]  # Vertical left path
    mid_row = height // 2
    # Add horizontal segment in middle row to block background
    for c in range(1, width):
        if (mid_row, c) not in pixels:
            pixels.append((mid_row, c))
    # Add random variations to ensure connectivity
    for _ in range(random.randint(0, 3)):
        r = random.randint(0, height - 1)
        c = random.randint(0, width - 1)
        if (r, c) not in pixels:
            pixels.append((r, c))
    pixels = list(set(pixels))
    input_grid = common.grid(width, height, Y)
    for (r, c) in pixels:
        if r < height and c < width:
            input_grid[r][c] = X
    output_grid = common.grid(width, height, Y)
    for (r, c) in pixels:
        if r < height and c < width:
            output_grid[r][c] = 3
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    top_colors = set(input_grid[0])
    path_color = None
    for color in top_colors:
        visited = [[False] * width for _ in range(height)]
        queue = []
        for c in range(width):
            if input_grid[0][c] == color:
                queue.append((0, c))
                visited[0][c] = True
        while queue and path_color is None:
            r, c = queue.pop(0)
            if r == height - 1:
                path_color = color
                break
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                    visited[nr][nc] = True
                    queue.append((nr, nc))
        if path_color is not None:
            break
    output = [list(row) for row in input_grid]
    for r in range(height):
        for c in range(width):
            if output[r][c] == path_color:
                output[r][c] = 3
    return output
