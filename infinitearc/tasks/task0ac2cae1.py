# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 0ac2cae1
Difficulty: very hard

=== Tags ===
- State machine grid
- Pairwise rule matching
- Dependency topological sort

=== Description ===
Task: State Machine Grid with Pairwise Rule Dependencies  Input grids are
composed of multiple contiguous regions (each region consists of one or more
connected cells sharing the same color value between 0 and 9), arranged such
that adjacent regions (sharing a horizontal or vertical edge) form pairwise
relationships. Each region appears as a distinct color, and no two regions share
the same color. The grid contains between 5 and 15 regions, with regions of
varying sizes and shapes, distributed across the grid without overlapping.  The
transformation rules for adjacent region pairs are determined by their initial
color values: a pair of colors (X, Y) transforms into a new color pair (A, B)
according to a predefined mapping. However, these transformations are not
independentâ€”some rules depend on the outcome of others. Specifically, a
transformation rule for a pair (X, Y) cannot be applied until the transformation
rule for a pair (Y, Z) has been applied, because the color Y in the pair (X, Y)
must first be updated to its transformed state (B) by the (Y, Z) transformation.
The dependency graph is constructed as follows: each node represents a
transformation rule for an adjacent region pair, and a directed edge exists from
node (Y, Z) to node (X, Y) if the color Y appears in both pairs (i.e., the
transformation of (Y, Z) affects the color used in (X, Y)). This dependency
graph forms a directed acyclic graph (DAG), requiring a topological sort to
determine the correct application order.  The output grid is generated by: 1.
Identifying all adjacent region pairs in the input grid. 2. Determining the
dependency graph based on shared colors between pairs. 3. Performing a
topological sort of the transformation rules. 4. Applying each transformation
rule in topological order, updating the grid after each step (so subsequent
rules use the updated color values). 5. Ensuring that transformations only
affect the two regions involved in the pair, leaving all other regions
unchanged.  The output grid must reflect the final state after all
transformations have been applied in the correct order. No two transformation
rules should conflict or produce ambiguous results. The grid must maintain all
regions as contiguous blocks of color, with no color values overlapping or being
overwritten in unexpected ways. The dependency structure must be non-trivial,
requiring multiple layers of reasoning to resolve the correct sequence, with the
topological sort order determined solely from the initial grid's region
adjacencies and color values.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import defaultdict
from common import grid

def generate():
    """
    Generate a grid composed of contiguous, uniquely-colored vertical regions (stripes).
    Build oriented adjacency pairs (right/down), construct the dependency DAG where
    (Y,Z) -> (X,Y), topologically sort it, and apply pairwise transformations in order.

    Each transformation for a pair (X,Y) sets all cells of the original region X to the
    current color of region Y (so it depends on earlier updates to Y) and sets all cells
    of the original region Y to a deterministic new color computed from (X,Y).
    """
    # Try several times in case we accidentally create cycles or no-change outputs
    for attempt in range(200):
        # number of regions (unique colors) between 5 and 9 (limited by 1..9 colors)
        num_regions = random.randint(5, 9)
        colors = random.sample(range(1, 10), num_regions)

        # choose small widths so total width stays <= 30
        widths = [random.randint(1, 3) for _ in range(num_regions)]
        total_width = sum(widths)
        if total_width > 30:
            continue

        height = random.randint(6, min(20, 30))
        width = total_width

        # start with background 0
        ingrid = grid(width, height, 0)
        region_cells = {}

        # Place vertical stripe regions left-to-right. Each region is contiguous.
        col_start = 0
        for i, color in enumerate(colors):
            w = widths[i]
            cells = []
            for c in range(col_start, col_start + w):
                for r in range(height):
                    ingrid[r][c] = color
                    cells.append((r, c))
            region_cells[color] = cells
            col_start += w

        # Find oriented adjacent pairs (right and down neighbors)
        adjacent_pairs = set()
        for r in range(height):
            for c in range(width):
                if ingrid[r][c] == 0:
                    continue
                for dr, dc in ((0, 1), (1, 0)):
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and ingrid[nr][nc] != 0:
                        if ingrid[r][c] != ingrid[nr][nc]:
                            adjacent_pairs.add((ingrid[r][c], ingrid[nr][nc]))

        # Build dependency graph: edge from (Y,Z) -> (X,Y)
        pairs = list(adjacent_pairs)
        graph = defaultdict(list)
        for a in pairs:
            x, y = a
            for b in pairs:
                # b = (Y,Z) should point to a = (X,Y)
                if b[0] == y and b != a:
                    graph[b].append(a)

        # Topological sort (Kahn)
        in_degree = {p: 0 for p in pairs}
        for u in graph:
            for v in graph[u]:
                in_degree[v] += 1
        queue = [p for p in in_degree if in_degree[p] == 0]
        sorted_pairs = []
        while queue:
            node = queue.pop(0)
            sorted_pairs.append(node)
            for nb in graph.get(node, []):
                in_degree[nb] -= 1
                if in_degree[nb] == 0:
                    queue.append(nb)

        # If we have a cycle, retry
        if len(sorted_pairs) != len(pairs):
            continue

        # deterministic mapping for the 'second' region of a pair
        def map_newY(x, y):
            # returns value in 1..9
            return ((x * 3 + y * 7) % 9) + 1

        # Apply transformations in topological order, updating only the two involved regions
        output_grid = [row[:] for row in ingrid]
        region_current = {color: color for color in colors}  # track current color for each original region
        for (x, y) in sorted_pairs:
            # x and y are the original region colors used as IDs
            if x not in region_cells or y not in region_cells:
                continue
            new_y = map_newY(x, y)
            new_x = region_current[y]
            # update cells for region x and region y (original region sets)
            for (r, c) in region_cells[x]:
                output_grid[r][c] = new_x
            for (r, c) in region_cells[y]:
                output_grid[r][c] = new_y
            region_current[x] = new_x
            region_current[y] = new_y

        # Ensure the output differs from the input
        if output_grid != ingrid:
            return {"input": ingrid, "output": output_grid}
    raise RuntimeError('Failed to generate a valid puzzle after many attempts')



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import defaultdict

def p(input_grid):
    # Convert to mutable list-of-lists
    ingrid = [list(row) for row in input_grid]
    height = len(ingrid)
    width = len(ingrid[0]) if height > 0 else 0

    # Collect original regions by color (spec guarantees each region has a distinct color)
    region_cells = {}
    for r in range(height):
        for c in range(width):
            val = ingrid[r][c]
            if val == 0:
                continue
            region_cells.setdefault(val, []).append((r, c))

    # Find oriented adjacent pairs (right and down neighbors)
    adjacent_pairs = set()
    for r in range(height):
        for c in range(width):
            if ingrid[r][c] == 0:
                continue
            for dr, dc in ((0, 1), (1, 0)):
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and ingrid[nr][nc] != 0:
                    if ingrid[r][c] != ingrid[nr][nc]:
                        adjacent_pairs.add((ingrid[r][c], ingrid[nr][nc]))

    # Build dependency graph: edge from (Y,Z) -> (X,Y)
    pairs = list(adjacent_pairs)
    graph = defaultdict(list)
    for a in pairs:
        x, y = a
        for b in pairs:
            if b[0] == y and b != a:
                graph[b].append(a)

    # Topological sort
    in_degree = {p: 0 for p in pairs}
    for u in graph:
        for v in graph[u]:
            in_degree[v] += 1
    queue = [p for p in in_degree if in_degree[p] == 0]
    sorted_pairs = []
    while queue:
        node = queue.pop(0)
        sorted_pairs.append(node)
        for nb in graph.get(node, []):
            in_degree[nb] -= 1
            if in_degree[nb] == 0:
                queue.append(nb)

    # deterministic mapping used by generator
    def map_newY(x, y):
        return ((x * 3 + y * 7) % 9) + 1

    # Apply transformations in topological order, updating only the original region cells
    output = [row[:] for row in ingrid]
    region_current = {col: col for col in region_cells.keys()}
    for (x, y) in sorted_pairs:
        if x not in region_cells or y not in region_cells:
            continue
        new_y = map_newY(x, y)
        new_x = region_current[y]
        for (r, c) in region_cells[x]:
            output[r][c] = new_x
        for (r, c) in region_cells[y]:
            output[r][c] = new_y
        region_current[x] = new_x
        region_current[y] = new_y

    return output

