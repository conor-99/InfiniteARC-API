# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 08899f68
Difficulty: hard

=== Tags ===
- Proximity guessing

=== Description ===
The input grid consists of multiple disconnected color clusters (connected
regions of the same color) arranged across a 2D grid. The output grid is
generated by transforming each cell based on the proximity of neighboring
clusters: for each cell, if there exists at least one cell of a different color
within a Manhattan distance of 2 (i.e., within a 3Ã—3 neighborhood centered on
the cell), the cell's color is replaced with the color of the nearest such cell.
Nearest is determined by minimal Manhattan distance, with ties resolved by
selecting the cell with the smallest row index first, then smallest column
index. Cells entirely surrounded by their own color (no neighboring clusters
within distance 2) remain unchanged. This task requires identifying spatial
relationships between clusters and applying a consistent proximity-based
transformation rule across the grid, with complex input configurations
containing overlapping, nested, or interwoven clusters to challenge the solver's
ability to discern distance-based color interactions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    from common import randint, rand_sprite

    width = randint(10, 20)
    height = randint(10, 20)
    grid = [[0] * width for _ in range(height)]
    colors = list(range(1, 10))
    used_colors = random.sample(colors, 3)

    for color in used_colors:
        sprite_width = randint(3, 5)
        sprite_height = randint(3, 5)
        pixels = rand_sprite('el', sprite_width, sprite_height)
        for r, c in pixels:
            if 0 <= r < height and 0 <= c < width:
                grid[r][c] = color

    def apply_proximity(g):
        rows = len(g)
        cols = len(g[0])
        out = [[0] * cols for _ in range(rows)]
        for r in range(rows):
            for c in range(cols):
                current = g[r][c]
                min_dist = 10
                nearest_color = current
                nearest_pos = (float('inf'), float('inf'))
                for dr in range(-2, 3):
                    for dc in range(-2, 3):
                        nr, nc = r + dr, c + dc
                        if not (0 <= nr < rows and 0 <= nc < cols):
                            continue
                        if g[nr][nc] == current:
                            continue
                        dist = abs(dr) + abs(dc)
                        if dist < min_dist or (dist == min_dist and (nr < nearest_pos[0] or (nr == nearest_pos[0] and nc < nearest_pos[1]))):
                            min_dist = dist
                            nearest_color = g[nr][nc]
                            nearest_pos = (nr, nc)
                out[r][c] = nearest_color if min_dist != 10 else current
        return out

    output = apply_proximity(grid)
    while grid == output:
        grid = [[0] * width for _ in range(height)]
        for color in used_colors:
            sprite_width = randint(3, 5)
            sprite_height = randint(3, 5)
            pixels = rand_sprite('el', sprite_width, sprite_height)
            for r, c in pixels:
                if 0 <= r < height and 0 <= c < width:
                    grid[r][c] = color
        output = apply_proximity(grid)
    return {'input': grid, 'output': output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    rows = len(input_grid)
    cols = len(input_grid[0])
    output = [[0] * cols for _ in range(rows)]
    for r in range(rows):
        for c in range(cols):
            current = input_grid[r][c]
            min_dist = 10
            nearest_color = current
            nearest_pos = (float('inf'), float('inf'))
            for dr in range(-2, 3):
                for dc in range(-2, 3):
                    nr, nc = r + dr, c + dc
                    if nr < 0 or nr >= rows or nc < 0 or nc >= cols:
                        continue
                    if input_grid[nr][nc] == current:
                        continue
                    dist = abs(dr) + abs(dc)
                    if dist < min_dist or (dist == min_dist and (nr < nearest_pos[0] or (nr == nearest_pos[0] and nc < nearest_pos[1]))):
                        min_dist = dist
                        nearest_color = input_grid[nr][nc]
                        nearest_pos = (nr, nc)
            output[r][c] = nearest_color if min_dist != 10 else current
    return output
