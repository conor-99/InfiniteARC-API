# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 8f62df38
Difficulty: medium–hard

=== Tags ===
- Folded grid reasoning
- Paint on collision
- Recursive path tracing

=== Description ===
# Folded Path Collision  Input grids are medium-sized (15×15 to 25×25) with a
single background color. The grid contains a vertical fold line (a continuous
column of a distinct color, e.g., color 5) running through the middle, a wall
structure (a contiguous region of a different color, e.g., color 2) forming
obstacles, and a single path starting from the left edge (color 1). The path
moves rightward through background cells until encountering either a wall or the
fold line.  The output grid transforms the input by tracing the path's movement
according to the following rules: - When the path encounters a wall (color 2),
the wall cell is recolored to a distinct collision color (e.g., color 3), and
the path direction reverses 90° (e.g., right → up). - When the path encounters
the fold line (color 5), the fold line cell is recolored to a different
collision color (e.g., color 4), and the path direction is mirrored horizontally
(e.g., right → left). - The path continues moving in the new direction until
exiting the grid (reaching any edge), with collisions painting only the specific
cells where the path collides with walls or the fold line. - All other cells
remain unchanged, including the original path start cell and background cells
traversed without collision.  The transformation requires understanding the
grid's folded structure, recognizing the fold line as a directional mirror, and
tracking recursive path changes through multiple collisions before the path
exits. The output reveals the path's trajectory through the grid with painted
collision points, demonstrating both folded grid reasoning and sequential
collision-based painting.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

CALL_COUNT = 0

def generate():
    global CALL_COUNT
    import random
    CALL_COUNT += 1
    # grid size
    width = random.randint(15, 25)
    height = random.randint(15, 25)
    grid = [[0 for _ in range(width)] for _ in range(height)]

    # fold line through the middle
    mid_col = width // 2
    for r in range(height):
        grid[r][mid_col] = 5

    # pick a start row away from the very edges
    min_row = 2
    max_row = height - 3
    if max_row < min_row:
        path_row = random.randint(1, height - 2)
    else:
        path_row = ((random.randint(min_row, max_row) + CALL_COUNT) % (max_row - min_row + 1)) + min_row

    # choose a path length so the next cell (the collision) is left of the fold
    max_path_len = mid_col - 1
    if max_path_len < 1:
        path_length = 1
    else:
        path_length = ((random.randint(1, max_path_len) + CALL_COUNT * 3) % max_path_len) + 1

    # paint the path starting from the left edge
    for c in range(path_length):
        grid[path_row][c] = 1

    # place a contiguous vertical wall starting at the collision cell (downwards)
    max_down = height - path_row - 1
    if max_down < 1:
        wall_length = 1
    else:
        wall_length = ((random.randint(1, min(5, max_down)) + CALL_COUNT) % max(1, min(5, max_down))) + 1
    wall_col = path_length
    for i in range(wall_length):
        grid[path_row + i][wall_col] = 2

    # optionally add another separate wall cluster (keeps the wall structure more interesting)
    if width - mid_col - 2 > 1:
        extra_col = mid_col + 2 + (CALL_COUNT % max(1, width - mid_col - 3))
        extra_len = min(3, height - 2)
        for i in range(extra_len):
            grid[1 + i][extra_col] = 2

    # simulate the path and paint collisions into the output
    output = [row[:] for row in grid]
    r, c = path_row, path_length - 1
    dr, dc = 0, 1
    steps = 0
    max_steps = width * height * 8
    while True:
        nr, nc = r + dr, c + dc
        if not (0 <= nr < height and 0 <= nc < width):
            break
        cell = grid[nr][nc]
        if cell == 2:
            output[nr][nc] = 3
            # rotate 90 degrees: (dr,dc) -> (-dc, dr)
            dr, dc = -dc, dr
        elif cell == 5:
            output[nr][nc] = 4
            # mirror horizontally: (dr,dc) -> (dr, -dc)
            dr, dc = dr, -dc
        r, c = nr, nc
        steps += 1
        if steps > max_steps:
            break

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # convert to mutable grid
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # find the path start on the left edge
    path_row = None
    for r in range(height):
        if grid[r][0] == 1:
            path_row = r
            break
    if path_row is None:
        return [row[:] for row in grid]

    # measure the contiguous run of 1s from the left
    path_length = 0
    while path_length < width and grid[path_row][path_length] == 1:
        path_length += 1

    r, c = path_row, path_length - 1
    dr, dc = 0, 1
    output = [row[:] for row in grid]
    steps = 0
    max_steps = width * height * 8
    while True:
        nr, nc = r + dr, c + dc
        if not (0 <= nr < height and 0 <= nc < width):
            break
        cell = grid[nr][nc]
        if cell == 2:
            output[nr][nc] = 3
            dr, dc = -dc, dr
        elif cell == 5:
            output[nr][nc] = 4
            dr, dc = dr, -dc
        r, c = nr, nc
        steps += 1
        if steps > max_steps:
            break
    return output

