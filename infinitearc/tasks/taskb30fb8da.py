# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: b30fb8da
Difficulty: medium–hard

=== Tags ===
- Fractal growth
- Recursive pattern copy
- Refraction simulation
- Rule switch on context

=== Description ===
Input grids feature a single seed pattern (typically a 1×1 or 2×2 block of color
1) positioned on a grid with background color 0. Scattered throughout the grid
are refractor cells (color 5) that serve as directional change points. The
output grid is generated through recursive fractal growth: starting from the
seed, the pattern expands outward in all four cardinal directions (up, down,
left, right) one cell per step. When expansion would encounter a refractor cell,
the direction of growth changes to the next perpendicular direction in a
clockwise cycle (e.g., right → down → left → up → right), and the refractor cell
itself becomes the origin for a new recursive branch in all four directions.
Each recursive branch maintains the same growth pattern but is offset from the
original seed. The process continues until all possible branches reach grid
boundaries or overlap with existing pattern cells. The resulting output exhibits
a self-similar, fractal-like structure where refractor cells act as branching
points, creating a complex network of interconnected pattern segments that grow
outward in a non-linear, direction-switching manner. The background (color 0)
remains visible between pattern segments, and no two pattern segments overlap.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque

def generate():
    size = random.randint(5, 30)
    grid = [[0] * size for _ in range(size)]
    
    seed_r = random.randint(2, size - 3)
    seed_c = random.randint(2, size - 3)
    grid[seed_r][seed_c] = 1
    
    num_refractors = random.randint(1, 5)
    for _ in range(num_refractors):
        r = random.randint(1, size - 2)
        c = random.randint(1, size - 2)
        while grid[r][c] != 0:
            r = random.randint(1, size - 2)
            c = random.randint(1, size - 2)
        grid[r][c] = 5
    
    output = simulate_growth(grid)
    return {"input": grid, "output": output}

def simulate_growth(input_grid):
    size = len(input_grid)
    output = [[0] * size for _ in range(size)]
    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]
    queue = deque()
    visited = set()
    
    for r in range(size):
        for c in range(size):
            if input_grid[r][c] == 1:
                for d in range(4):
                    queue.append((r, c, d))
    
    while queue:
        r, c, d = queue.popleft()
        if (r, c, d) in visited:
            continue
        visited.add((r, c, d))
        dr, dc = directions[d]
        nr, nc = r + dr, c + dc
        if 0 <= nr < size and 0 <= nc < size:
            if input_grid[nr][nc] == 5:
                output[nr][nc] = 1
                new_d = (d + 1) % 4
                for new_d2 in range(4):
                    if (nr, nc, new_d2) not in visited:
                        queue.append((nr, nc, new_d2))
                if (nr, nc, new_d) not in visited:
                    queue.append((nr, nc, new_d))
            elif input_grid[nr][nc] == 0:
                output[nr][nc] = 1
                if (nr, nc, d) not in visited:
                    queue.append((nr, nc, d))
    
    for r in range(size):
        for c in range(size):
            if input_grid[r][c] == 1:
                output[r][c] = 1
    
    return output

def p(input_grid):
    return simulate_growth(input_grid)


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random
from collections import deque

def generate():
    size = random.randint(5, 30)
    grid = [[0] * size for _ in range(size)]
    
    seed_r = random.randint(2, size - 3)
    seed_c = random.randint(2, size - 3)
    grid[seed_r][seed_c] = 1
    
    num_refractors = random.randint(1, 5)
    for _ in range(num_refractors):
        r = random.randint(1, size - 2)
        c = random.randint(1, size - 2)
        while grid[r][c] != 0:
            r = random.randint(1, size - 2)
            c = random.randint(1, size - 2)
        grid[r][c] = 5
    
    output = simulate_growth(grid)
    return {"input": grid, "output": output}

def simulate_growth(input_grid):
    size = len(input_grid)
    output = [[0] * size for _ in range(size)]
    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]
    queue = deque()
    visited = set()
    
    for r in range(size):
        for c in range(size):
            if input_grid[r][c] == 1:
                for d in range(4):
                    queue.append((r, c, d))
    
    while queue:
        r, c, d = queue.popleft()
        if (r, c, d) in visited:
            continue
        visited.add((r, c, d))
        dr, dc = directions[d]
        nr, nc = r + dr, c + dc
        if 0 <= nr < size and 0 <= nc < size:
            if input_grid[nr][nc] == 5:
                output[nr][nc] = 1
                new_d = (d + 1) % 4
                for new_d2 in range(4):
                    if (nr, nc, new_d2) not in visited:
                        queue.append((nr, nc, new_d2))
                if (nr, nc, new_d) not in visited:
                    queue.append((nr, nc, new_d))
            elif input_grid[nr][nc] == 0:
                output[nr][nc] = 1
                if (nr, nc, d) not in visited:
                    queue.append((nr, nc, d))
    
    for r in range(size):
        for c in range(size):
            if input_grid[r][c] == 1:
                output[r][c] = 1
    
    return output

def p(input_grid):
    return simulate_growth(input_grid)
