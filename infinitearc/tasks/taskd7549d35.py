# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: d7549d35
Difficulty: very hard

=== Tags ===
- Multi source interaction
- Relational projection
- Modular sequence
- Detect enclosure
- Draw x on largest object
- Jigsaw

=== Description ===
The input grid consists of multiple distinct colored objects (represented by
values 1-9) on a 0-background, each forming a connected region. Objects may
enclose other objects (completely surrounded without touching the grid
boundary), and the largest object is defined by its cell count. The task
requires identifying the largest object that encloses at least one other object;
if no such object exists, the largest object overall is selected. To determine
enclosure, each object's interior must be verified via flood-fill to ensure no
path exists to the grid boundary without crossing the enclosing object's
boundary. Once identified, the output grid replicates the input but replaces the
centroid cell (calculated as the average row and column of all object cells,
rounded to integers) with a cross-shaped 'X' represented by color 9. This 'X' is
drawn using four diagonal cells around the centroid (top-left, top-right,
bottom-left, bottom-right) to form a visible cross, ensuring it does not overlap
with other object cells. The transformation sequence involves relational
enclosure detection, modular object analysis, and precise positional projection.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    size = random.randint(5, 30)
    ingrid = grid(size, size, 0)
    
    # Create frame (enclosing object)
    r1 = random.randint(1, size - 4)
    c1 = random.randint(1, size - 4)
    r2 = r1 + 4 + random.randint(0, 5)
    c2 = c1 + 4 + random.randint(0, 5)
    if r2 >= size - 1 or c2 >= size - 1:
        r2 = size - 2
        c2 = size - 2

    # Draw frame perimeter
    for c in range(c1, c2 + 1):
        ingrid[r1][c] = 1
        ingrid[r2][c] = 1
    for r in range(r1 + 1, r2):
        ingrid[r][c1] = 1
        ingrid[r][c2] = 1

    # Compute frame centroid
    frame_cells = []
    for c in range(c1, c2 + 1):
        frame_cells.append((r1, c))
        frame_cells.append((r2, c))
    for r in range(r1 + 1, r2):
        frame_cells.append((r, c1))
        frame_cells.append((r, c2))
    
    centroid_r = sum(r for r, c in frame_cells) // len(frame_cells)
    centroid_c = sum(c for r, c in frame_cells) // len(frame_cells)
    
    # Place inner object at centroid
    ingrid[centroid_r][centroid_c] = 2
    
    # Verify diagonals are background (0)
    diagonals = [(centroid_r - 1, centroid_c - 1),
                 (centroid_r - 1, centroid_c + 1),
                 (centroid_r + 1, centroid_c - 1),
                 (centroid_r + 1, centroid_c + 1)]
    
    for r, c in diagonals:
        if r < 0 or r >= size or c < 0 or c >= size or ingrid[r][c] != 0:
            # Adjust frame if needed
            return generate()

    # Create output grid
    output = [row[:] for row in ingrid]
    for r, c in diagonals:
        output[r][c] = 9
    
    return {
        "input": ingrid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    # Ensure input is list of lists
    if isinstance(input_grid[0], tuple):
        input_grid = [list(row) for row in input_grid]
    
    size = len(input_grid)
    
    # Find all connected components
    def get_components(grid):
        components = []
        visited = [[0] * size for _ in range(size)]
        for r in range(size):
            for c in range(size):
                if grid[r][c] != 0 and not visited[r][c]:
                    stack = [(r, c)]
                    comp = []
                    visited[r][c] = 1
                    while stack:
                        cr, cc = stack.pop()
                        comp.append((cr, cc))
                        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < size and 0 <= nc < size and grid[nr][nc] == grid[r][c] and not visited[nr][nc]:
                                visited[nr][nc] = 1
                                stack.append((nr, nc))
                    components.append(comp)
        return components

    # Check if component is enclosed
    def is_enclosed(comp, grid):
        visited = [[0] * size for _ in range(size)]
        queue = [(r, c) for r, c in comp]
        while queue:
            r, c = queue.pop(0)
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < size and 0 <= nc < size and grid[nr][nc] == 0 and not visited[nr][nc]:
                    visited[nr][nc] = 1
                    queue.append((nr, nc))
        # Check if any edge cell was reached
        for r in range(size):
            for c in range(size):
                if (r == 0 or r == size - 1 or c == 0 or c == size - 1) and visited[r][c] == 1:
                    return False
        return True

    # Get components and sort by size
    components = get_components(input_grid)
    components.sort(key=lambda comp: len(comp), reverse=True)

    # Find largest enclosing component
    target_comp = None
    for comp in components:
        if is_enclosed(comp, input_grid):
            target_comp = comp
            break
    
    if not target_comp:
        target_comp = components[0]

    # Compute centroid
    centroid_r = sum(r for r, c in target_comp) // len(target_comp)
    centroid_c = sum(c for r, c in target_comp) // len(target_comp)

    # Draw X at diagonals
    output = [row[:] for row in input_grid]
    diagonals = [(centroid_r - 1, centroid_c - 1),
                 (centroid_r - 1, centroid_c + 1),
                 (centroid_r + 1, centroid_c - 1),
                 (centroid_r + 1, centroid_c + 1)]
    
    for r, c in diagonals:
        if 0 <= r < size and 0 <= c < size:
            output[r][c] = 9
    
    return output
