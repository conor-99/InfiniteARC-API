# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: a316ee49
Difficulty: hard

=== Tags ===
- Solve sokoban puzzle
- Order numbers
- Homeomorphism
- Color by manhattan distance

=== Description ===
The task involves solving a Sokoban-like puzzle within a grid where a single
movable block (color 1) must be pushed to a target cell (color 2) while
navigating obstacles (color 0). The input grid contains a unique valid path for
the block to reach the target, with additional non-essential elements (colors
3–9) forming a complex spatial structure. The output grid is generated through
two sequential transformations: first, the block is moved to the target cell
(replacing its original position with the target's color), then all cells are
recolored based on their Manhattan distance from the target cell. The color
mapping cycles through colors 3–9 (e.g., distance 0 → color 3, distance 1 →
color 4, ..., distance 6 → color 9, distance 7 → color 3, etc.), ensuring all
colors remain within 0–9. The transformation must preserve topological
connectivity (homeomorphism), meaning regions of similar colors in the output
correspond to spatially connected areas in the input's path structure. The
"Order numbers" tag refers to the spatial ordering of colors by increasing
Manhattan distance from the target, creating concentric color rings that reflect
the grid's geometry. This requires the solver to first deduce the Sokoban
solution path, then apply a distance-based color transformation, combining
logical movement with spatial pattern recognition.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid_input = common.grid(width, height, 0)
    
    target_r = random.randint(0, height - 1)
    target_c = random.randint(0, width - 1)
    grid_input[target_r][target_c] = 2
    
    direction = random.choice(['row', 'col'])
    if direction == 'row':
        block_c = random.randint(0, width - 1)
        while abs(block_c - target_c) < 2:
            block_c = random.randint(0, width - 1)
        block_r = target_r
    else:
        block_r = random.randint(0, height - 1)
        while abs(block_r - target_r) < 2:
            block_r = random.randint(0, height - 1)
        block_c = target_c
    
    grid_input[block_r][block_c] = 1
    
    if direction == 'row':
        start_c = min(block_c, target_c) + 1
        end_c = max(block_c, target_c)
        for c in range(start_c, end_c):
            grid_input[block_r][c] = 3
    else:
        start_r = min(block_r, target_r) + 1
        end_r = max(block_r, target_r)
        for r in range(start_r, end_r):
            grid_input[r][target_c] = 3
    
    for r in range(height):
        for c in range(width):
            if (r == block_r and c == block_c) or (r == target_r and c == target_c):
                continue
            if direction == 'row' and r == block_r and start_c <= c < end_c:
                continue
            if direction == 'col' and c == target_c and start_r <= r < end_r:
                continue
            color = random.choice([0] + list(range(3, 10)))
            grid_input[r][c] = color
    
    output = []
    for r in range(height):
        output_row = []
        for c in range(width):
            d = abs(r - target_r) + abs(c - target_c)
            color = 3 + (d % 7)
            output_row.append(color)
        output.append(output_row)
    
    return {
        "input": grid_input,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    target_pos = None
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] == 2:
                target_pos = (r, c)
                break
        if target_pos:
            break
    if not target_pos:
        target_pos = (0, 0)
    target_r, target_c = target_pos
    height = len(input_grid)
    width = len(input_grid[0])
    output = [[0] * width for _ in range(height)]
    
    for r in range(height):
        for c in range(width):
            d = abs(r - target_r) + abs(c - target_c)
            output[r][c] = 3 + (d % 7)
    
    return output
