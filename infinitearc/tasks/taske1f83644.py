# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: e1f83644
Difficulty: medium

=== Tags ===
- Homeomorphism
- Separate shapes
- Orthogonal path planning
- Even or odd

=== Description ===
The input grid contains multiple disconnected shapes, where each shape is a
connected region of non-zero values (orthogonally connected). The output grid
must connect all shapes using orthogonal paths (moving only horizontally or
vertically) such that the length of each connecting path (measured in the number
of cells traversed) matches the parity of the total number of shapes in the
input. Specifically, if the input contains an even number of shapes, all
connecting paths must have an even length; if the input contains an odd number
of shapes, all connecting paths must have an odd length. The paths are
constructed to be the shortest possible while adhering to the parity constraint,
with minimal detours added to adjust path length when necessary.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    N = random.randint(2, 5)
    step = 3 if N % 2 == 0 else 2
    max_column = (N - 1) * step
    width = max(5, max_column + 1)
    width = min(width, 30)
    height = random.randint(5, 30)
    grid = [[0] * width for _ in range(height)]
    color = random.randint(1, 9)
    positions = []
    for i in range(N):
        c = i * step
        positions.append((0, c))
        grid[0][c] = color
    output = [row[:] for row in grid]
    for i in range(1, N):
        r1, c1 = positions[i-1]
        r2, c2 = positions[i]
        if c1 != c2:
            step_val = 1 if c2 > c1 else -1
            for c in range(c1 + step_val, c2, step_val):
                output[0][c] = color
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Ensure input is list of lists
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    color = None
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                color = input_grid[r][c]
                break
        if color is not None:
            break
    if color is None:
        return input_grid
    visited = [[False] * width for _ in range(height)]
    shapes = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == color and not visited[r][c]:
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop()
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == color and not visited[nr][nc]:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                shapes.append(component)
    N = len(shapes)
    shapes.sort(key=lambda s: (min(r for r, c in s), min(c for r, c in s)))
    output = [row[:] for row in input_grid]
    for i in range(1, N):
        shape1 = shapes[i-1]
        shape2 = shapes[i]
        min_dist = float('inf')
        pair = None
        for (r1, c1) in shape1:
            for (r2, c2) in shape2:
                dist = abs(r1 - r2) + abs(c1 - c2)
                if dist < min_dist:
                    min_dist = dist
                    pair = ((r1, c1), (r2, c2))
        (r1, c1), (r2, c2) = pair
        if c1 != c2:
            step_val = 1 if c2 > c1 else -1
            for c in range(c1 + step_val, c2, step_val):
                output[r1][c] = color
        if r1 != r2:
            step_val = 1 if r2 > r1 else -1
            for r in range(r1 + step_val, r2, step_val):
                output[r][c2] = color
    return output
