# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: f4c9ab0c
Difficulty: medium–hard

=== Tags ===
- Embedded rule repetition
- Phase shift
- Circuit reflection
- Local convolution rule
- Expand repeating unit
- Pattern expansion

=== Description ===
Input grids feature a background color (e.g., gray) with multiple disjoint 3×3
circuit segments arranged in a grid. Each segment contains a unique pattern of
non-background colors (e.g., red, blue, green) forming a small "circuit" shape
(e.g., L-shape, diagonal line, or T-junction) within its 3×3 bounds. The
segments are separated by background cells and may be oriented in different
directions. Embedded in the top-left corner of the grid is a 2×2 phase key,
where each cell contains a distinct color. The first color in the key (top-left
cell) encodes a phase shift direction (e.g., red = right, blue = down), while
the second color (top-right cell) encodes a reflection axis (e.g., green =
horizontal reflection, yellow = vertical reflection).    The output grid is
generated by applying the phase shift and reflection rules to each circuit
segment. For every segment, the phase shift moves the entire segment by one cell
in the direction specified by the key (e.g., a right shift moves the segment one
column to the right), and the reflection flips the segment's internal pattern
across the axis defined by the second key color (e.g., horizontal reflection
reverses left-right orientation). Segments are placed in their new positions
without overlapping, maintaining their internal color patterns. The background
remains unchanged, and the phase key remains visible in the top-left corner. The
output grid expands in size to accommodate the shifted segments, with no
segments overlapping or overwriting the background. The transformation requires
inferring the key's color-to-direction mapping, applying localized
transformations to each segment, and handling the expanded grid geometry.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, continuous_creature, random_color


def generate():
    """
    Generate an input/output pair where the input contains a 2x2 key in the top-left
    and a grid of disjoint 3x3 segments (each with a contiguous circuit-shaped pattern).
    The first key color encodes the shift direction (2: right, 3: down, 4: left, 5: up).
    The second key color encodes the reflection axis (6: horizontal mirror, 7: vertical mirror).
    Segments are placed starting at row/col >= 3 so that shifting by one cell never
    collides with the key. The output applies the reflection to each 3x3 internal
    pattern and then shifts the 3x3 block by one cell in the direction indicated,
    expanding the output grid as necessary.
    """
    # Background color
    b = random.randint(0, 9)

    # Fixed encoding (kept consistent so solver can decode):
    direction_choices = [2, 3, 4, 5]  # right, down, left, up
    reflection_choices = [6, 7]       # horizontal, vertical

    # Pick direction and reflection colors distinct from background
    d_color = random.choice(direction_choices)
    while d_color == b:
        d_color = random.choice(direction_choices)
    r_color = random.choice(reflection_choices)
    while r_color == b or r_color == d_color:
        r_color = random.choice(reflection_choices)

    # Two additional key colors (to fill the 2x2 key) distinct from b, d_color, r_color
    key_c2 = random_color(exclude=[b, d_color, r_color])
    key_c3 = random_color(exclude=[b, d_color, r_color, key_c2])

    # Choose layout: at least 2 segments in total to make the task meaningful
    num_rows = random.randint(1, 3)
    num_cols = random.randint(1, 3)
    if num_rows * num_cols == 1:
        # force at least two segments
        if random.random() < 0.5:
            num_cols = 2
        else:
            num_rows = 2

    # Spacing between 3x3 blocks (background columns/rows)
    spacing = random.choice([1, 2])

    # Start offset to keep the 2x2 key area free and avoid collision after shifting
    start_offset = 3

    # Compute input grid size
    last_col_pos = start_offset + (num_cols - 1) * (3 + spacing)
    last_row_pos = start_offset + (num_rows - 1) * (3 + spacing)
    rightmost = last_col_pos + 2
    bottommost = last_row_pos + 2
    width_in = max(2, rightmost + 1)
    height_in = max(2, bottommost + 1)

    # Create input grid
    input_grid = grid(width_in, height_in, b)

    # Place the 2x2 key in the top-left corner
    input_grid[0][0] = d_color
    input_grid[0][1] = r_color
    input_grid[1][0] = key_c2
    input_grid[1][1] = key_c3

    # Place segments. Each segment is a contiguous creature that spans all 3 rows and cols
    segments = []  # each entry: (top_r, top_c)

    for ri in range(num_rows):
        for ci in range(num_cols):
            top_r = start_offset + ri * (3 + spacing)
            top_c = start_offset + ci * (3 + spacing)

            # choose a color for this segment (may repeat across segments but not equal to key/background)
            exclude_colors = [b, d_color, r_color, key_c2, key_c3]
            seg_color = random_color(exclude=exclude_colors)

            # generate a contiguous creature that covers all 3 rows and all 3 cols
            tries = 0
            while True:
                tries += 1
                size = random.randint(4, 8)
                pixels = continuous_creature(size, width=3, height=3)
                rows = set(p[0] for p in pixels)
                cols = set(p[1] for p in pixels)
                # accept only if every row and column inside 3x3 has at least one pixel
                if rows == {0, 1, 2} and cols == {0, 1, 2}:
                    break
                if tries > 40:
                    # fallback: pick a full 3x3 fill (guarantees the condition)
                    pixels = [(r, c) for r in range(3) for c in range(3)]
                    break

            # paint the segment in the input grid
            for (pr, pc) in pixels:
                input_grid[top_r + pr][top_c + pc] = seg_color

            segments.append((top_r, top_c))

    # Determine shift vector from d_color
    dir_map = {2: (0, 1), 3: (1, 0), 4: (0, -1), 5: (-1, 0)}
    shift = dir_map.get(d_color, (0, 1))

    # Reflection choice from r_color
    reflect_h = (r_color == 6)  # horizontal (mirror left-right)
    reflect_v = (r_color == 7)  # vertical (mirror top-bottom)

    # Compute output grid size to accommodate shifted blocks
    new_tops = []
    max_r_idx = 1  # at least include key rows 0..1
    max_c_idx = 1
    for (top_r, top_c) in segments:
        new_r = top_r + shift[0]
        new_c = top_c + shift[1]
        new_tops.append((top_r, top_c, new_r, new_c))
        max_r_idx = max(max_r_idx, new_r + 2)
        max_c_idx = max(max_c_idx, new_c + 2)

    height_out = max(max_r_idx + 1, 2)
    width_out = max(max_c_idx + 1, 2)

    # Create output grid and copy key
    output_grid = grid(width_out, height_out, b)
    output_grid[0][0] = d_color
    output_grid[0][1] = r_color
    output_grid[1][0] = key_c2
    output_grid[1][1] = key_c3

    # For each original 3x3 block, reflect its internal contents and place at shifted position
    for (top_r, top_c, new_r, new_c) in new_tops:
        for rr in range(3):
            for cc in range(3):
                val = input_grid[top_r + rr][top_c + cc]
                # apply reflection inside the 3x3 block
                rr_ref = 2 - rr if reflect_v else rr
                cc_ref = 2 - cc if reflect_h else cc
                output_grid[new_r + rr_ref][new_c + cc_ref] = val

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    ingrid = [list(row) for row in input_grid]
    height = len(ingrid)
    width = len(ingrid[0])

    # Find background color (most frequent)
    flat = [v for row in ingrid for v in row]
    b = max(set(flat), key=flat.count)

    # Read key
    d_color = ingrid[0][0]
    r_color = ingrid[0][1]

    # Decode shift and reflection using the fixed encoding used by the generator
    dir_map = {2: (0, 1), 3: (1, 0), 4: (0, -1), 5: (-1, 0)}
    shift = dir_map.get(d_color, (0, 1))
    reflect_h = (r_color == 6)
    reflect_v = (r_color == 7)

    # Find connected components of non-background pixels, ignoring the 2x2 key area
    visited = [[False] * width for _ in range(height)]
    key_positions = {(0, 0), (0, 1), (1, 0), (1, 1)}
    components = []

    for r in range(height):
        for c in range(width):
            if (r, c) in key_positions:  # skip key cells
                visited[r][c] = True
                continue
            if visited[r][c]:
                continue
            if ingrid[r][c] == b:
                visited[r][c] = True
                continue
            # BFS to collect component
            stack = [(r, c)]
            visited[r][c] = True
            comp = []
            while stack:
                cr, cc = stack.pop()
                comp.append((cr, cc))
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and ingrid[nr][nc] != b and (nr, nc) not in key_positions:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            components.append(comp)

    # From components, determine 3x3 segment top-lefts (we expect each component to have a 3x3 bounding box)
    segments = []  # list of (top_r, top_c)
    for comp in components:
        rows = [p[0] for p in comp]
        cols = [p[1] for p in comp]
        min_r, max_r = min(rows), max(rows)
        min_c, max_c = min(cols), max(cols)
        # The generator guarantees a 3x3 bounding box for each segment
        # (i.e., max_r - min_r == 2 and max_c - min_c == 2)
        if max_r - min_r <= 2 and max_c - min_c <= 2:
            # If bounding box is smaller than 3x3 (unlikely with the generator),
            # expand to a 3x3 block anchored at min_r/min_c if possible.
            top_r = min_r
            top_c = min_c
            # Ensure block fits in input
            if top_r + 2 >= height:
                top_r = max(0, height - 3)
            if top_c + 2 >= width:
                top_c = max(0, width - 3)
            segments.append((top_r, top_c))

    # Compute new extents after shifting
    new_positions = []
    max_row_idx = 1
    max_col_idx = 1
    for (top_r, top_c) in segments:
        new_r = top_r + shift[0]
        new_c = top_c + shift[1]
        new_positions.append((top_r, top_c, new_r, new_c))
        max_row_idx = max(max_row_idx, new_r + 2)
        max_col_idx = max(max_col_idx, new_c + 2)

    height_out = max(max_row_idx + 1, 2)
    width_out = max(max_col_idx + 1, 2)

    # Create output grid filled with background
    out = [[b for _ in range(width_out)] for _ in range(height_out)]

    # Copy key (keep the same top-left 2x2)
    out[0][0] = d_color
    out[0][1] = r_color
    out[1][0] = ingrid[1][0]
    out[1][1] = ingrid[1][1]

    # Place transformed segments
    for (top_r, top_c, new_r, new_c) in new_positions:
        for rr in range(3):
            for cc in range(3):
                val = ingrid[top_r + rr][top_c + cc]
                rr_ref = 2 - rr if reflect_v else rr
                cc_ref = 2 - cc if reflect_h else cc
                out_r = new_r + rr_ref
                out_c = new_c + cc_ref
                # Bounds check (should not be needed if sizes computed correctly)
                if 0 <= out_r < height_out and 0 <= out_c < width_out:
                    out[out_r][out_c] = val

    # Return as tuple-of-tuples
    return tuple(tuple(row) for row in out)

