# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 9a87adfa
Difficulty: easy

=== Tags ===
- Algebra
- Contouring
- Take intersection
- Pattern rotation

=== Description ===
The task involves transforming an input grid into an output grid by applying a
specific sequence of operations. Each input grid contains a single contiguous
shape (connected via edge-adjacent cells) defined by non-zero values (colors
1â€“9), surrounded by zeros (background). The transformation follows these steps:
(1) rotate the input grid 90 degrees clockwise, (2) compute the intersection
between the original input grid and the rotated grid (retaining only cells that
are non-zero in both grids), and (3) output the resulting grid. The intersection
operation ensures that only overlapping non-zero cells from the original and
rotated grids are preserved in the output. This task combines pattern rotation
(rotating the shape), intersection (combining overlapping regions), contouring
(the output shape outlines the intersection of the original and rotated
patterns), and algebraic set operations (logical intersection of two grids). The
input and output grids are guaranteed to differ, as symmetric shapes (e.g., a
centered square) are excluded during generation to avoid identical inputs and
outputs.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    n = random.randint(2, 30)
    size = random.randint(2, n*n - 1)
    pixels = common.continuous_creature(size, n, n)
    input_grid = common.grid(n, n, 0)
    color = common.random_color()
    for (r, c) in pixels:
        input_grid[r][c] = color
    rotated = [row[::-1] for row in zip(*input_grid)]
    if input_grid == rotated:
        for _ in range(10):
            size = random.randint(2, n*n - 1)
            pixels = common.continuous_creature(size, n, n)
            input_grid = common.grid(n, n, 0)
            color = common.random_color()
            for (r, c) in pixels:
                input_grid[r][c] = color
            rotated = [row[::-1] for row in zip(*input_grid)]
            if input_grid != rotated:
                break
    output_grid = common.grid(n, n, 0)
    for r in range(n):
        for c in range(n):
            if input_grid[r][c] != 0 and rotated[r][c] != 0:
                output_grid[r][c] = input_grid[r][c]
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    n = len(input_grid)
    rotated = [row[::-1] for row in zip(*input_grid)]
    output = [[0] * n for _ in range(n)]
    for r in range(n):
        for c in range(n):
            if input_grid[r][c] != 0 and rotated[r][c] != 0:
                output[r][c] = input_grid[r][c]
    return output
