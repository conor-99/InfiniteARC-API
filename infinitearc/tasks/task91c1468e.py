# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 91c1468e
Difficulty: mediumâ€“hard

=== Tags ===
- Pattern analogy
- Reconstruct checkerboard from hint
- Modular sequence

=== Description ===
Input grids consist of a background color (0) and two other colors (e.g., 1 and
2) arranged in a checkerboard pattern. However, specific cells within the grid
are replaced with a fourth color (5), forming a "hint" that indicates missing
elements of a modular color sequence. The hint cells are positioned along a
diagonal line starting from the top-left corner, and their order corresponds to
a repeating sequence of colors (e.g., [3, 4, 5, 3, 4, 5, ...]). The output grid
replaces all hint cells (5) with the next color in the sequence, cycling through
the sequence as needed, while maintaining the underlying checkerboard pattern
for non-hint cells. The sequence length is determined by the number of unique
colors in the diagonal hint, and the output extends this sequence across the
grid by progressing diagonally through the hint positions. The reconstructed
checkerboard follows the modular sequence pattern, with the sequence advancing
one step for each subsequent hint cell along the diagonal, ensuring the output
grid contains a complete, visually consistent checkerboard pattern that adheres
to the modular sequence.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    size = random.randint(5, 30)
    grid_in = [[0] * size for _ in range(size)]
    
    checker_size = 5
    for r in range(min(size, checker_size)):
        for c in range(min(size, checker_size)):
            if (r + c) % 2 == 0:
                grid_in[r][c] = 1
            else:
                grid_in[r][c] = 2
    
    diagonal = [(r, r) for r in range(min(size, checker_size))]
    num_hints = random.randint(3, len(diagonal))
    hint_positions = random.sample(diagonal, num_hints)
    
    for r, c in hint_positions:
        grid_in[r][c] = 5
    
    grid_out = [row[:] for row in grid_in]
    hint_positions_sorted = sorted(hint_positions, key=lambda x: x[0])
    sequence = [3, 4, 5]
    for idx, (r, c) in enumerate(hint_positions_sorted):
        grid_out[r][c] = sequence[idx % len(sequence)]
    
    return {
        "input": grid_in,
        "output": grid_out
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    n = min(len(input_list), len(input_list[0]))
    hint_positions = []
    for r in range(n):
        if input_list[r][r] == 5:
            hint_positions.append((r, r))
    
    hint_positions.sort(key=lambda x: x[0])
    sequence = [3, 4, 5]
    for idx, (r, c) in enumerate(hint_positions):
        input_list[r][c] = sequence[idx % len(sequence)]
    
    return input_list
