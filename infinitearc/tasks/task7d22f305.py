# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 7d22f305
Difficulty: hard

=== Tags ===
- Detect grid
- Bring patterns close
- Pairwise analogy

=== Description ===
This task involves input grids containing two distinct connected regions
(patterns) of the same non-zero color. The output grid is generated by
translating each region towards the other along the shortest axis-aligned path
(horizontal or vertical) until the regions become adjacent (sharing at least one
edge). The direction of translation (left/right or up/down) is determined by the
relative horizontal or vertical separation between the regions. The translation
distance is precisely calculated to achieve adjacency without overlapping other
regions. For horizontally separated regions, the left region moves right and the
right region moves left; for vertically separated regions, the top region moves
down and the bottom region moves up. All other elements in the grid remain
unchanged. The solver must identify the correct pair of regions, compute their
relative positions, and apply the exact translation required for adjacency,
requiring multi-step reasoning about spatial relationships and connected
components.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(7, 30)
    height = random.randint(5, 30)
    color = random.randint(1, 9)
    
    grid = [[0] * width for _ in range(height)]
    
    region1 = [(0, 0), (1, 0), (0, 1)]
    region2 = [(0, width - 4), (1, width - 4), (0, width - 3)]

    for r, c in region1:
        if 0 <= r < height and 0 <= c < width:
            grid[r][c] = color

    for r, c in region2:
        if 0 <= r < height and 0 <= c < width:
            grid[r][c] = color

    region1_cols = [c for r, c in region1]
    region1_rows = [r for r, c in region1]
    region2_cols = [c for r, c in region2]
    region2_rows = [r for r, c in region2]

    left_region = region1 if min(region1_cols) < min(region2_cols) else region2
    right_region = region2 if min(region1_cols) < min(region2_cols) else region1
    left_col_max = max(c for r, c in left_region)
    right_col_min = min(c for r, c in right_region)
    horiz_dist = right_col_min - left_col_max - 1

    top_region = region1 if min(region1_rows) < min(region2_rows) else region2
    bottom_region = region2 if min(region1_rows) < min(region2_rows) else region1
    top_row_max = max(r for r, c in top_region)
    bottom_row_min = min(r for r, c in bottom_region)
    vert_dist = bottom_row_min - top_row_max - 1

    output_grid = [row[:] for row in grid]
    if horiz_dist < vert_dist and horiz_dist > 0:
        move_left = horiz_dist // 2
        move_right = horiz_dist - move_left
        for r, c in left_region:
            output_grid[r][c] = 0
            new_c = c + move_left
            if 0 <= new_c < width:
                output_grid[r][new_c] = color
        for r, c in right_region:
            output_grid[r][c] = 0
            new_c = c - move_right
            if 0 <= new_c < width:
                output_grid[r][new_c] = color
    else:
        move_top = vert_dist // 2
        move_bottom = vert_dist - move_top
        for r, c in top_region:
            output_grid[r][c] = 0
            new_r = r + move_top
            if 0 <= new_r < height:
                output_grid[new_r][c] = color
        for r, c in bottom_region:
            output_grid[r][c] = 0
            new_r = r - move_bottom
            if 0 <= new_r < height:
                output_grid[new_r][c] = color

    return {
        "input": grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def find_components(grid, color):
    height = len(grid)
    width = len(grid[0])
    visited = set()
    components = []
    directions = [(1,0), (-1,0), (0,1), (0,-1)]
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] == color and (r, c) not in visited:
                stack = [(r, c)]
                visited.add((r, c))
                component = []
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in directions:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == color and (nr, nc) not in visited:
                            visited.add((nr, nc))
                            stack.append((nr, nc))
                components.append(component)
    return components

def p(input_grid):
    # Convert input to list of lists if it's a tuple
    if isinstance(input_grid[0], tuple):
        input_grid = [list(row) for row in input_grid]
    
    color = None
    for c in range(1, 10):
        comps = find_components(input_grid, c)
        if len(comps) == 2:
            color = c
            region1, region2 = comps
            break
    if color is None:
        color = 1
        comps = find_components(input_grid, color)
        region1, region2 = comps[:2]

    region1_cols = [c for r, c in region1]
    region1_rows = [r for r, c in region1]
    region2_cols = [c for r, c in region2]
    region2_rows = [r for r, c in region2]

    left_region = region1 if min(region1_cols) < min(region2_cols) else region2
    right_region = region2 if min(region1_cols) < min(region2_cols) else region1
    left_col_max = max(c for r, c in left_region)
    right_col_min = min(c for r, c in right_region)
    horiz_dist = right_col_min - left_col_max - 1

    top_region = region1 if min(region1_rows) < min(region2_rows) else region2
    bottom_region = region2 if min(region1_rows) < min(region2_rows) else region1
    top_row_max = max(r for r, c in top_region)
    bottom_row_min = min(r for r, c in bottom_region)
    vert_dist = bottom_row_min - top_row_max - 1

    output_grid = [row[:] for row in input_grid]
    if horiz_dist < vert_dist and horiz_dist > 0:
        move_left = horiz_dist // 2
        move_right = horiz_dist - move_left
        for r, c in left_region:
            output_grid[r][c] = 0
            new_c = c + move_left
            if 0 <= new_c < len(output_grid[0]):
                output_grid[r][new_c] = color
        for r, c in right_region:
            output_grid[r][c] = 0
            new_c = c - move_right
            if 0 <= new_c < len(output_grid[0]):
                output_grid[r][new_c] = color
    else:
        move_top = vert_dist // 2
        move_bottom = vert_dist - move_top
        for r, c in top_region:
            output_grid[r][c] = 0
            new_r = r + move_top
            if 0 <= new_r < len(output_grid):
                output_grid[new_r][c] = color
        for r, c in bottom_region:
            output_grid[r][c] = 0
            new_r = r - move_bottom
            if 0 <= new_r < len(output_grid):
                output_grid[new_r][c] = color
    return output_grid
