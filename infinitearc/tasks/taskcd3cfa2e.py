# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: cd3cfa2e
Difficulty: hard

=== Tags ===
- Pattern concatenation

=== Description ===
Input grids consist of multiple non-overlapping, compact patterns (each a
connected region of a single color from 1-9) embedded within a background of
color 0. Patterns are separated by at least one background cell and do not touch
grid edges. Each pattern has a distinct shape (e.g., diagonal lines, L-shapes,
squares) with no two patterns sharing the same visual orientation or structural
complexity.  The output grid is formed by concatenating all patterns
horizontally from left to right, following a specific sequence determined by the
visual properties of each pattern. Patterns are sorted first by the vertical
position of their centroid (computed as the average row coordinate of all cells
in the pattern), with ties broken by horizontal position (average column
coordinate). Each pattern is then rotated 90 degrees clockwise if its bounding
box appears taller than wide when viewed in the input grid (e.g., vertical lines
rotate to horizontal), otherwise it remains unrotated. The background cells
between patterns in the input are removed in the output, resulting in a seamless
horizontal concatenation of all transformed patterns. No two patterns overlap or
touch in the output, and all internal pattern structures are preserved except
for the rotation adjustment.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, continuous_creature, random_color


def _normalize_shape(pixels):
    """Return a canonical tuple representation of a shape (translated to origin)."""
    if not pixels:
        return ()
    min_r = min(r for r, c in pixels)
    min_c = min(c for r, c in pixels)
    normalized = tuple(sorted(((r - min_r, c - min_c) for r, c in pixels)))
    return normalized


def _placeable(occupancy, abs_cells, height, width):
    """Check abs_cells can be placed without touching existing occupancy (8-neighborhood) and within bounds."""
    for r, c in abs_cells:
        if r < 0 or r >= height or c < 0 or c >= width:
            return False
        # check 8-neighborhood for existing occupied cells
        for dr in (-1, 0, 1):
            for dc in (-1, 0, 1):
                nr, nc = r + dr, c + dc
                if (nr, nc) in occupancy:
                    return False
    return True


def generate():
    # Try a few times to build a valid scene; if placement fails, restart.
    for _attempt in range(40):
        width = random.randint(10, 18)
        height = random.randint(10, 18)
        input_grid = grid(width, height, 0)

        occupancy = set()  # occupied cells (absolute coordinates)
        used_colors = []
        patterns = []  # list of (color, list of abs cells)

        num_patterns = random.randint(2, 5)

        success = True
        shape_signatures = set()

        for pi in range(num_patterns):
            placed = False
            # Try several times to generate and place a pattern
            for trial in range(250):
                # Sprite (local) dimensions
                sprite_w = random.randint(2, 6)
                sprite_h = random.randint(2, 6)
                max_size = min(sprite_w * sprite_h, 8)
                size = random.randint(3, max(3, max_size))

                sprite = continuous_creature(size, sprite_w, sprite_h)
                # sprite is given in local coords: (r,c) with 0<=r<sprite_h, 0<=c<sprite_w
                # Normalize shape signature to avoid duplicate shapes
                sig = _normalize_shape(sprite)
                if sig in shape_signatures:
                    continue

                # choose a color not used yet
                color = random_color(exclude=used_colors)

                # Determine possible placements that keep at least one cell margin to grid edges
                min_row = 1
                max_row = height - sprite_h - 1
                min_col = 1
                max_col = width - sprite_w - 1
                if max_row < min_row or max_col < min_col:
                    # sprite too large for this canvas
                    continue

                # Try some random candidate offsets
                offsets = [(random.randint(min_row, max_row), random.randint(min_col, max_col)) for _ in range(40)]
                # add a few deterministic offsets for coverage
                offsets += [(min_row, min_col), (min_row, max_col), (max_row, min_col), (max_row, max_col)]

                placed_here = False
                for r0, c0 in offsets:
                    abs_cells = [(r0 + r, c0 + c) for r, c in sprite]
                    if not _placeable(occupancy, abs_cells, height, width):
                        continue
                    # also ensure none of the pattern cells touch the grid edges
                    touch_edge = any(r == 0 or r == height - 1 or c == 0 or c == width - 1 for r, c in abs_cells)
                    if touch_edge:
                        continue
                    # OK place it
                    for r, c in abs_cells:
                        input_grid[r][c] = color
                        occupancy.add((r, c))
                    used_colors.append(color)
                    patterns.append((color, abs_cells))
                    shape_signatures.add(sig)
                    placed_here = True
                    break

                if placed_here:
                    placed = True
                    break

            if not placed:
                success = False
                break

        if not success or len(patterns) < 2:
            # try again
            continue

        # Build the output by sorting patterns by centroid (vertical then horizontal)
        pattern_data = []
        for color, abs_cells in patterns:
            r_coords = [r for r, c in abs_cells]
            c_coords = [c for r, c in abs_cells]
            centroid_r = sum(r_coords) / len(abs_cells)
            centroid_c = sum(c_coords) / len(abs_cells)

            min_r, max_r = min(r_coords), max(r_coords)
            min_c, max_c = min(c_coords), max(c_coords)
            height_b = max_r - min_r + 1
            width_b = max_c - min_c + 1
            rotate = height_b > width_b

            # compute rotated (or not) cells relative to top-left of their bounding box
            rotated = []
            for r, c in abs_cells:
                r_rel = r - min_r
                c_rel = c - min_c
                if rotate:
                    # 90 degrees clockwise: (r_rel, c_rel) -> (c_rel, height_b - 1 - r_rel)
                    new_r = c_rel
                    new_c = height_b - 1 - r_rel
                else:
                    new_r = r_rel
                    new_c = c_rel
                rotated.append((new_r, new_c))

            pattern_data.append((centroid_r, centroid_c, rotated, color))

        pattern_data.sort(key=lambda x: (x[0], x[1]))

        # compute output dimensions
        total_width = 0
        max_height_rot = 0
        dims = []  # store individual dims
        for _, _, rot_cells, _ in pattern_data:
            r_coords = [r for r, c in rot_cells]
            c_coords = [c for r, c in rot_cells]
            h = max(r_coords) - min(r_coords) + 1
            w = max(c_coords) - min(c_coords) + 1
            dims.append((h, w))
            max_height_rot = max(max_height_rot, h)
            total_width += w

        output_grid = grid(total_width, max_height_rot, 0)

        # place patterns left-to-right flush to top
        current_col = 0
        for (h, w), (_, _, rot_cells, color) in zip(dims, pattern_data):
            min_c = min(c for r, c in rot_cells)
            for r, c in rot_cells:
                out_r = r  # top-aligned
                out_c = current_col + (c - min_c)
                output_grid[out_r][out_c] = color
            current_col += w

        return {"input": input_grid, "output": output_grid}

    # Fallback (very unlikely)
    # Return a trivial valid example if all attempts failed
    input_grid = grid(12, 12, 0)
    input_grid[3][3] = 1
    input_grid[3][4] = 1
    input_grid[4][3] = 1
    output_grid = [[0]*3 for _ in range(3)]
    output_grid[0][0] = 1
    output_grid[0][1] = 1
    output_grid[1][0] = 1
    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable list of lists
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])

    visited = [[False]*width for _ in range(height)]
    components = []  # list of (color, list of (r,c))

    for r in range(height):
        for c in range(width):
            if grid_in[r][c] == 0 or visited[r][c]:
                continue
            color = grid_in[r][c]
            # BFS/DFS to collect connected component (4-connected)
            stack = [(r, c)]
            comp = []
            while stack:
                pr, pc = stack.pop()
                if visited[pr][pc]:
                    continue
                if grid_in[pr][pc] != color:
                    continue
                visited[pr][pc] = True
                comp.append((pr, pc))
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = pr + dr, pc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid_in[nr][nc] == color:
                        stack.append((nr, nc))
            components.append((color, comp))

    if not components:
        return [[0]]

    # For each component compute centroid, rotate if bounding box taller than wide
    pattern_data = []  # (centroid_r, centroid_c, rotated_cells, color)
    for color, cells in components:
        r_coords = [r for r, c in cells]
        c_coords = [c for r, c in cells]
        centroid_r = sum(r_coords) / len(cells)
        centroid_c = sum(c_coords) / len(cells)

        min_r, max_r = min(r_coords), max(r_coords)
        min_c, max_c = min(c_coords), max(c_coords)
        height_b = max_r - min_r + 1
        width_b = max_c - min_c + 1
        rotate = height_b > width_b

        rotated = []
        for r, c in cells:
            r_rel = r - min_r
            c_rel = c - min_c
            if rotate:
                new_r = c_rel
                new_c = height_b - 1 - r_rel
            else:
                new_r = r_rel
                new_c = c_rel
            rotated.append((new_r, new_c))

        pattern_data.append((centroid_r, centroid_c, rotated, color))

    # Sort by vertical centroid then horizontal centroid
    pattern_data.sort(key=lambda x: (x[0], x[1]))

    # Compute output dimensions
    total_width = 0
    max_height_rot = 0
    dims = []
    for _, _, rot_cells, _ in pattern_data:
        r_coords = [r for r, c in rot_cells]
        c_coords = [c for r, c in rot_cells]
        h = max(r_coords) - min(r_coords) + 1
        w = max(c_coords) - min(c_coords) + 1
        dims.append((h, w))
        total_width += w
        if h > max_height_rot:
            max_height_rot = h

    # Build output grid and place patterns left-to-right, top-aligned
    output = [[0 for _ in range(total_width)] for _ in range(max_height_rot)]
    current_col = 0
    for (h, w), (_, _, rot_cells, color) in zip(dims, pattern_data):
        min_c = min(c for r, c in rot_cells)
        for r, c in rot_cells:
            out_r = r
            out_c = current_col + (c - min_c)
            output[out_r][out_c] = color
        current_col += w

    return output

