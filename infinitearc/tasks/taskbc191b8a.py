# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: bc191b8a
Difficulty: hard

=== Tags ===
- Emergent behavior
- Source target routing
- Reactive surface

=== Description ===
Task Name: Reactive Path Network  Description: Input grids feature red sources,
blue targets, and a yellow reactive surface overlaying a gray obstacle
background. The yellow cells form a continuous network allowing paths between
sources and targets, with gray cells acting as impassable barriers. Each red
source must connect to its nearest blue target via the shortest path through
yellow cells, avoiding obstacles and other sources/targets. The output grid
transforms each yellow cell along a path: cells traversed by exactly one path
become red, while cells traversed by exactly two paths become green. Sources
remain red, targets remain blue, and obstacles retain gray. This creates
emergent visual patterns where the reactive surface dynamically encodes path
density through color changes, requiring the solver to identify multiple path
routes, count overlapping intersections, and apply color transformations based
on visual density rather than numerical values.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque
import common

# Keep track of generated pairs to ensure uniqueness across calls
_SEEN_PAIRS = set()

# deterministic neighbor order used by both generator and solver
_NEIGHBORS = [(-1, 0), (0, -1), (0, 1), (1, 0)]  # up, left, right, down


def _is_yellow_connected(grid):
    """Return True if all yellow cells (color 4) form a single 4-connected component."""
    h = len(grid)
    w = len(grid[0])
    yellow_cells = [(r, c) for r in range(h) for c in range(w) if grid[r][c] == 4]
    if not yellow_cells:
        return False
    start = yellow_cells[0]
    q = deque([start])
    seen = {start}
    while q:
        r, c = q.popleft()
        for dr, dc in _NEIGHBORS:
            nr, nc = r + dr, c + dc
            if 0 <= nr < h and 0 <= nc < w and (nr, nc) not in seen and grid[nr][nc] == 4:
                seen.add((nr, nc))
                q.append((nr, nc))
    return len(seen) == len(yellow_cells)


def _bfs_find_nearest_target(grid, start, targets_set, sources_set):
    """BFS from start to find the nearest target (by path length).
    Traversal rules:
      - Can move on yellow cells (4).
      - Can land on a target cell (1) to finish but do not traverse through it.
      - Do NOT traverse through other sources (2) or other targets (1) except when landing on a target to finish.
    Returns: (target_coord, parent_grid) or (None, parent_grid) if no reachable target.
    parent_grid is a 2D array of parent coordinates used for path reconstruction.
    """
    h = len(grid)
    w = len(grid[0])
    sr, sc = start
    visited = [[False] * w for _ in range(h)]
    parent = [[None] * w for _ in range(h)]
    q = deque()
    q.append((sr, sc))
    visited[sr][sc] = True
    while q:
        r, c = q.popleft()
        for dr, dc in _NEIGHBORS:
            nr, nc = r + dr, c + dc
            if not (0 <= nr < h and 0 <= nc < w):
                continue
            if visited[nr][nc]:
                continue
            # If this neighbor is one of the target coordinates, we found the nearest target.
            if (nr, nc) in targets_set:
                parent[nr][nc] = (r, c)
                return (nr, nc), parent
            val = grid[nr][nc]
            # allow traversal only on yellow cells and avoid stepping onto other endpoints
            if val == 4 and (nr, nc) not in sources_set and (nr, nc) not in targets_set:
                visited[nr][nc] = True
                parent[nr][nc] = (r, c)
                q.append((nr, nc))
            # otherwise skip (obstacle, another source/target, or non-traversable)
    return None, parent


def _reconstruct_path(parent, start, end):
    if end is None:
        return None
    path = []
    r, c = end
    # If parent chain is broken we will detect and return None
    tries = 0
    while (r, c) != start and tries < 10000:
        path.append((r, c))
        p = parent[r][c]
        if p is None:
            return None
        r, c = p
        tries += 1
    path.append(start)
    path.reverse()
    return path


def generate():
    """Generate an input-output pair describing a reactive path network.

    Input colors:
      4 = yellow (reactive surface),
      5 = gray (obstacle),
      2 = red (source),
      1 = blue (target)

    Output: yellow cells used by exactly one path -> 2 (red), used by exactly two -> 3 (green).
    Sources and targets keep their colors and obstacles remain gray.
    """
    global _SEEN_PAIRS
    tries_overall = 0
    while True:
        tries_overall += 1
        if tries_overall > 200:
            # fallback: reset seen to avoid infinite loops in pathological situations
            _SEEN_PAIRS.clear()
        width = random.randint(10, 20)
        height = random.randint(10, 20)
        # start with a fully reactive surface (yellow)
        grid = common.grid(width, height, 4)
        # place obstacles but always preserve yellow connectivity
        total_cells = width * height
        max_obstacles = max(5, total_cells // 8)
        obstacle_count = random.randint(5, max_obstacles)
        placed = 0
        attempts = 0
        while placed < obstacle_count and attempts < obstacle_count * 6:
            attempts += 1
            r = random.randrange(height)
            c = random.randrange(width)
            if grid[r][c] != 4:
                continue
            # try placing an obstacle and keep it only if yellow network remains connected
            grid[r][c] = 5
            if _is_yellow_connected(grid):
                placed += 1
            else:
                grid[r][c] = 4
        # ensure we still have enough yellow cells
        yellow_cells = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == 4]
        if len(yellow_cells) < 6:
            # too few yellow cells; restart
            continue
        num_sources = random.randint(2, 4)
        success = False
        placement_attempts = 0
        while not success and placement_attempts < 300:
            placement_attempts += 1
            # pick distinct cells for sources and targets
            if len(yellow_cells) < 2 * num_sources:
                break
            chosen = random.sample(yellow_cells, 2 * num_sources)
            sources = chosen[:num_sources]
            targets = chosen[num_sources:]
            sources_set = set(sources)
            targets_set = set(targets)
            # For each source, find a shortest path to its nearest target (by path length) avoiding other endpoints
            all_paths = []
            failed = False
            for s in sources:
                found_target, parent = _bfs_find_nearest_target(grid, s, targets_set, sources_set)
                if found_target is None:
                    failed = True
                    break
                path = _reconstruct_path(parent, s, found_target)
                if path is None:
                    failed = True
                    break
                all_paths.append((s, found_target, path))
            if failed:
                continue
            # we succeeded in finding paths for all sources
            success = True
        if not success:
            # start over generating obstacles and layout
            continue
        # compute path counts
        path_counts = [[0] * width for _ in range(height)]
        for s, t, path in all_paths:
            for (r, c) in path:
                path_counts[r][c] += 1
        # build input grid and output grid
        input_grid = [list(row) for row in grid]
        for r, c in sources:
            input_grid[r][c] = 2
        for r, c in targets:
            input_grid[r][c] = 1
        output_grid = [list(row) for row in input_grid]
        for r in range(height):
            for c in range(width):
                # Use the input grid to determine which cells are reactive surface cells (yellow)
                if input_grid[r][c] == 4:
                    cnt = path_counts[r][c]
                    if cnt == 1:
                        output_grid[r][c] = 2
                    elif cnt == 2:
                        output_grid[r][c] = 3
                    else:
                        output_grid[r][c] = 4
                # else keep input colors for obstacles, sources, and targets
        # ensure input != output
        if input_grid == output_grid:
            continue
        # ensure uniqueness of pair
        key = (tuple(tuple(row) for row in input_grid), tuple(tuple(row) for row in output_grid))
        if key in _SEEN_PAIRS:
            # try again to produce a unique pair
            continue
        _SEEN_PAIRS.add(key)
        return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

# The solver must replicate the same path-finding rules as the generator.
_NEIGHBORS = [(-1, 0), (0, -1), (0, 1), (1, 0)]  # up, left, right, down


def _bfs_find_nearest_target(grid, start, targets_set, sources_set):
    h = len(grid)
    w = len(grid[0])
    sr, sc = start
    visited = [[False] * w for _ in range(h)]
    parent = [[None] * w for _ in range(h)]
    q = deque()
    q.append((sr, sc))
    visited[sr][sc] = True
    while q:
        r, c = q.popleft()
        for dr, dc in _NEIGHBORS:
            nr, nc = r + dr, c + dc
            if not (0 <= nr < h and 0 <= nc < w):
                continue
            if visited[nr][nc]:
                continue
            if (nr, nc) in targets_set:
                parent[nr][nc] = (r, c)
                return (nr, nc), parent
            val = grid[nr][nc]
            if val == 4 and (nr, nc) not in sources_set and (nr, nc) not in targets_set:
                visited[nr][nc] = True
                parent[nr][nc] = (r, c)
                q.append((nr, nc))
    return None, parent


def _reconstruct_path(parent, start, end):
    if end is None:
        return None
    path = []
    r, c = end
    tries = 0
    while (r, c) != start and tries < 10000:
        path.append((r, c))
        p = parent[r][c]
        if p is None:
            return None
        r, c = p
        tries += 1
    path.append(start)
    path.reverse()
    return path


def p(input_grid):
    # convert tuple-of-tuples to list-of-lists if necessary
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])
    sources = []
    targets = []
    for r in range(h):
        for c in range(w):
            if grid[r][c] == 2:
                sources.append((r, c))
            elif grid[r][c] == 1:
                targets.append((r, c))
    if not sources or not targets:
        return grid
    sources_set = set(sources)
    targets_set = set(targets)
    path_counts = [[0] * w for _ in range(h)]
    for s in sources:
        found_target, parent = _bfs_find_nearest_target(grid, s, targets_set, sources_set)
        if found_target is None:
            # if generator guaranteed a path this should not happen; but keep grid unchanged
            continue
        path = _reconstruct_path(parent, s, found_target)
        if path is None:
            continue
        for (r, c) in path:
            path_counts[r][c] += 1
    # produce output grid
    output = [list(row) for row in grid]
    for r in range(h):
        for c in range(w):
            if grid[r][c] == 4:
                cnt = path_counts[r][c]
                if cnt == 1:
                    output[r][c] = 2
                elif cnt == 2:
                    output[r][c] = 3
                else:
                    output[r][c] = 4
            # sources, targets, obstacles remain unchanged
    return output

