# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: bc75db14
Difficulty: hard

=== Tags ===
- Layered occlusion unfolding

=== Description ===
The input grids are 2D grids of integers between 0 and 9, representing a layered
occlusion where a continuous vertical or horizontal line of color 9 acts as a
fold line. This fold line divides the grid into two regions: one containing a
pattern of non-zero values (the visible layer), and the other entirely filled
with 0 (the occluded region). The output grid is generated by mirroring the
pattern from the non-zero side of the fold line across the fold line to the
0-filled side, preserving the fold line's color 9. The mirroring direction
(left/right for vertical folds, top/bottom for horizontal folds) is determined
by the side containing the pattern. The task requires identifying the fold line,
recognizing the pattern's location, and applying symmetric reflection to reveal
the occluded layer. This involves multi-step reasoning about spatial
relationships and deterministic symmetry operations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    is_vertical = random.choice([True, False])
    
    if is_vertical:
        c = random.randint(1, (width - 1) // 2)
        input_grid = common.grid(width, height, 0)
        for r in range(height):
            input_grid[r][c] = 9
        size = random.randint(1, c * height)
        pixels = common.continuous_creature(size, c, height)
        for r, c_idx in pixels:
            color = random.randint(1, 8)
            input_grid[r][c_idx] = color
        output_grid = [row[:] for row in input_grid]
        for r in range(height):
            for j in range(c):
                mirror_col = 2 * c - j
                if mirror_col < width:
                    output_grid[r][mirror_col] = input_grid[r][j]
        for r in range(height):
            output_grid[r][c] = 9
        return {"input": input_grid, "output": output_grid}
    else:
        r = random.randint(1, (height - 1) // 2)
        input_grid = common.grid(width, height, 0)
        for c in range(width):
            input_grid[r][c] = 9
        size = random.randint(1, width * r)
        pixels = common.continuous_creature(size, width, r)
        for r_idx, c_idx in pixels:
            color = random.randint(1, 8)
            input_grid[r_idx][c_idx] = color
        output_grid = [row[:] for row in input_grid]
        for c in range(width):
            for i in range(r):
                mirror_row = 2 * r - i
                if mirror_row < height:
                    output_grid[mirror_row][c] = input_grid[i][c]
        for c in range(width):
            output_grid[r][c] = 9
        return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to list of lists if it's a tuple
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    
    vertical_fold = None
    for c in range(width):
        if all(input_grid[r][c] == 9 for r in range(height)):
            vertical_fold = c
            break
    
    if vertical_fold is not None:
        left_nonzero = False
        for r in range(height):
            for c in range(vertical_fold):
                if input_grid[r][c] > 0:
                    left_nonzero = True
                    break
            if left_nonzero:
                break
        if left_nonzero:
            output = [row[:] for row in input_grid]
            for r in range(height):
                for j in range(vertical_fold):
                    mirror_col = 2 * vertical_fold - j
                    if mirror_col < width:
                        output[r][mirror_col] = input_grid[r][j]
            for r in range(height):
                output[r][vertical_fold] = 9
            return output
        else:
            output = [row[:] for row in input_grid]
            for r in range(height):
                for j in range(vertical_fold + 1, width):
                    mirror_col = 2 * vertical_fold - j
                    if mirror_col >= 0:
                        output[r][mirror_col] = input_grid[r][j]
            for r in range(height):
                output[r][vertical_fold] = 9
            return output
    
    horizontal_fold = None
    for r in range(height):
        if all(input_grid[r][c] == 9 for c in range(width)):
            horizontal_fold = r
            break
    
    if horizontal_fold is not None:
        top_nonzero = False
        for c in range(width):
            for r in range(horizontal_fold):
                if input_grid[r][c] > 0:
                    top_nonzero = True
                    break
            if top_nonzero:
                break
        if top_nonzero:
            output = [row[:] for row in input_grid]
            for c in range(width):
                for i in range(horizontal_fold):
                    mirror_row = 2 * horizontal_fold - i
                    if mirror_row < height:
                        output[mirror_row][c] = input_grid[i][c]
            for c in range(width):
                output[horizontal_fold][c] = 9
            return output
        else:
            output = [row[:] for row in input_grid]
            for c in range(width):
                for i in range(horizontal_fold + 1, height):
                    mirror_row = 2 * horizontal_fold - i
                    if mirror_row >= 0:
                        output[mirror_row][c] = input_grid[i][c]
            for c in range(width):
                output[horizontal_fold][c] = 9
            return output
    
    return input_grid
