# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 24c94f88
Difficulty: medium–hard

=== Tags ===
- Pattern rotation
- Compositional reflection
- Shape to color encoding

=== Description ===
Task: Rotated Reflection Encoding  Input grids are composed of a background
color (0) and multiple distinct shapes, each formed by a connected component of
non-background cells. Shapes are oriented along the grid's cardinal axes
(horizontal or vertical), with their orientation determined by the primary axis
of their bounding box: a shape with a width greater than its height is
horizontal (0°), height greater than width is vertical (90°), and square shapes
(equal width/height) are classified as horizontal (0°). Each shape's color is
irrelevant to its transformation.  The output grid is generated through two
sequential transformations: 1. **Color Encoding**: Each shape's original color
is replaced by a new color based on its orientation:    - Horizontal shapes →
color 1    - Vertical shapes → color 2    - Square shapes → color 1 (treated as
horizontal) 2. **Compositional Reflection**: The entire grid is reflected across
the vertical axis (left-right mirror), preserving all shape orientations. For
example, a horizontal shape on the left edge reflects to the right edge while
maintaining its horizontal classification and color (1).  Background cells (0)
remain unchanged throughout both transformations. Shapes must be identified as
connected components, their bounding boxes analyzed for orientation, colors
remapped, and the grid reflected. No new shapes are introduced, and all
transformations are deterministic based solely on shape orientation and spatial
position.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    # Grid size
    width = random.randint(6, 20)
    height = random.randint(6, 20)
    input_grid = common.grid(width, height, 0)

    num_shapes = random.randint(2, 4)
    shapes = []  # list of lists of absolute (r,c) pixels for each shape
    shape_colors = []

    occupied = set()  # occupied pixels by previously placed shapes

    # Try to place shapes without 4-neighbor contact so they remain distinct components
    for _ in range(num_shapes):
        placed = False
        for attempt in range(400):
            # sprite box size (keeps creatures reasonably small relative to grid)
            sprite_w = random.randint(1, min(6, width))
            sprite_h = random.randint(1, min(6, height))
            max_pixels = sprite_w * sprite_h
            if max_pixels < 3:
                continue
            size = random.randint(3, min(max_pixels, 12))

            # Create a connected sprite within the small box
            sprite = common.continuous_creature(size, sprite_w, sprite_h)

            # choose an offset so sprite fits in the big grid
            r_off = random.randint(0, height - sprite_h)
            c_off = random.randint(0, width - sprite_w)

            # Check for conflicts with existing shapes (no 4-neighbor adjacency allowed)
            conflict = False
            for (sr, sc) in sprite:
                ar = sr + r_off
                ac = sc + c_off
                for dr, dc in [(0,0),(1,0),(-1,0),(0,1),(0,-1)]:
                    if (ar + dr, ac + dc) in occupied:
                        conflict = True
                        break
                if conflict:
                    break
            if conflict:
                continue

            # Place the sprite
            color = random.randint(1, 9)
            abs_pixels = []
            for (sr, sc) in sprite:
                ar = sr + r_off
                ac = sc + c_off
                input_grid[ar][ac] = color
                occupied.add((ar, ac))
                abs_pixels.append((ar, ac))

            shapes.append(abs_pixels)
            shape_colors.append(color)
            placed = True
            break
        if not placed:
            # Failed to place this shape; restart generation to keep things simple
            return generate()

    # Create intermediate grid where each shape is recolored according to its orientation
    intermediate = common.grid(width, height, 0)
    for pixels in shapes:
        rows = [p[0] for p in pixels]
        cols = [p[1] for p in pixels]
        min_r, max_r = min(rows), max(rows)
        min_c, max_c = min(cols), max(cols)
        w = max_c - min_c + 1
        h = max_r - min_r + 1
        # Square shapes are treated as horizontal => color 1
        new_color = 1 if w >= h else 2
        for (r, c) in pixels:
            intermediate[r][c] = new_color

    # Reflect intermediate across vertical axis
    output_grid = [row[::-1] for row in intermediate]

    # Ensure input and output are not identical (rare, but possible if coloring and reflection
    # accidentally reproduce the input); regenerate in that case.
    if input_grid == output_grid:
        return generate()

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    visited = [[False] * width for _ in range(height)]
    components = []

    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and not visited[r][c]:
                # Flood-fill to get the connected component (4-connectivity)
                stack = [(r, c)]
                visited[r][c] = True
                comp = []
                while stack:
                    cr, cc = stack.pop()
                    comp.append((cr, cc))
                    for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append(comp)

    # Recolor components according to orientation (bounding box)
    intermediate = common.grid(width, height, 0)
    for comp in components:
        rows = [p[0] for p in comp]
        cols = [p[1] for p in comp]
        min_r, max_r = min(rows), max(rows)
        min_c, max_c = min(cols), max(cols)
        w = max_c - min_c + 1
        h = max_r - min_r + 1
        new_color = 1 if w >= h else 2
        for (r, c) in comp:
            intermediate[r][c] = new_color

    # Reflect across vertical axis
    output = [row[::-1] for row in intermediate]
    return output

