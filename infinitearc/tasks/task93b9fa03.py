# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 93b9fa03
Difficulty: hard

=== Tags ===
- Pattern to sequence mapping
- Gas expansion
- Stacked layer alignment
- Dependency topological sort
- Diagonals
- Complete the 2x2 color pattern

=== Description ===
Input grids are large (15×15 or larger) composed of overlapping 2×2 blocks
arranged in a grid pattern. Each 2×2 block contains three distinct colored cells
(values 1–9) and one missing cell (value 0). The missing cell's color is
determined by a diagonal dependency rule: for a missing cell at position (i,j)
within a block, its color matches the color of the cell diagonally opposite in
the adjacent block located in the direction of the missing cell's corner. For
example, a missing top-left cell in a block depends on the bottom-right cell of
the block to the bottom-right (i+1,j+1). These dependencies form a directed
acyclic graph (DAG) where some cells must be resolved before others.  The
transformation process requires a topological sort of the dependency DAG to
determine the order of filling missing cells. The "gas expansion" aspect
manifests as color propagation along diagonal paths: once a cell's value is
determined, it "expands" diagonally to resolve dependencies in adjacent blocks,
much like gas filling space. Stacked layer alignment refers to processing the
grid in layers (e.g., row-wise or diagonal-wise) where each layer's resolution
depends on the previous. The output grid completes all 2×2 blocks by filling
missing cells with colors derived from diagonal dependencies, ensuring no
conflicts and satisfying all topological constraints. The solution requires
recognizing diagonal patterns, resolving dependencies sequentially, and
verifying that all completed 2×2 blocks follow the color-matching rule.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Grid size: choose an even size >= 16 and <= 22 for variety
    N = random.choice([16, 18, 20, 22])
    # Initialize grid with zeros
    grid = [[0 for _ in range(N)] for _ in range(N)]

    # Fill the last two rows and last two columns (the border "sink" region)
    # with non-zero colors so dependencies can terminate there.
    for r in range(N - 2, N):
        for c in range(N):
            grid[r][c] = random.randint(1, 9)
    for r in range(N):
        for c in range(N - 2, N):
            grid[r][c] = random.randint(1, 9)

    # Create an interior tiling of 2x2 blocks whose top-left starts at
    # indices 0,2,4,...,N-4. For each such block place exactly one missing cell (0)
    # at the top-left corner (dr=0,dc=0) and fill the other three cells with
    # distinct non-zero colors. This arrangement makes the dependency point
    # diagonally down-right (to block br+2,bc+2) and thus forms an acyclic
    # dependency structure that terminates in the border region.
    for br in range(0, N - 2, 2):  # goes up to N-4
        for bc in range(0, N - 2, 2):
            # Missing corner: top-left (0,0) for a consistent diagonal dependency
            dr, dc = 0, 0
            colors = random.sample(range(1, 10), 3)  # three distinct non-zero colors
            idx = 0
            for r in range(2):
                for c in range(2):
                    if r == dr and c == dc:
                        grid[br + r][bc + c] = 0
                    else:
                        grid[br + r][bc + c] = colors[idx]
                        idx += 1

    # Build the output by filling each missing cell according to the diagonal
    # dependency rule. For a missing cell at (i,j):
    #   if i%2==0 -> dependency row = i + 3 else i - 3
    #   if j%2==0 -> dependency col = j + 3 else j - 3
    # (This follows from the 2x2 block tiling and the corner -> opposite corner
    # rule across adjacent blocks separated by 2.)
    output = [row[:] for row in grid]
    for i in range(N):
        for j in range(N):
            if output[i][j] == 0:
                rel_i = i % 2
                rel_j = j % 2
                dep_i = i + (3 if rel_i == 0 else -3)
                dep_j = j + (3 if rel_j == 0 else -3)
                # Safety check (should not occur given the construction):
                if not (0 <= dep_i < N and 0 <= dep_j < N):
                    raise RuntimeError("Dependency out of bounds")
                output[i][j] = grid[dep_i][dep_j]

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    n = len(grid)

    # Collect zero positions
    zeros = [(i, j) for i in range(n) for j in range(n) if grid[i][j] == 0]
    pos_to_idx = {pos: idx for idx, pos in enumerate(zeros)}

    # Build dependency graph among zeros. If a zero depends on another zero,
    # add an edge (dep -> node) so dep must be filled first.
    graph = [[] for _ in zeros]
    indeg = [0] * len(zeros)
    dep_coords = {}

    for idx, (i, j) in enumerate(zeros):
        rel_i = i % 2
        rel_j = j % 2
        dep_i = i + (3 if rel_i == 0 else -3)
        dep_j = j + (3 if rel_j == 0 else -3)
        dep_coords[idx] = (dep_i, dep_j)
        if (dep_i, dep_j) in pos_to_idx:
            dep_idx = pos_to_idx[(dep_i, dep_j)]
            graph[dep_idx].append(idx)
            indeg[idx] += 1

    # Topological sort (Kahn). If there is a cycle (shouldn't be for our generator),
    # fall back to iterative propagation until stable.
    from collections import deque
    q = deque([i for i, d in enumerate(indeg) if d == 0])
    order = []
    while q:
        v = q.popleft()
        order.append(v)
        for u in graph[v]:
            indeg[u] -= 1
            if indeg[u] == 0:
                q.append(u)

    if len(order) != len(zeros):
        # Fallback: repeatedly fill any zero whose dependency is already non-zero
        changed = True
        while changed:
            changed = False
            for (i, j) in zeros:
                if grid[i][j] != 0:
                    continue
                rel_i = i % 2
                rel_j = j % 2
                dep_i = i + (3 if rel_i == 0 else -3)
                dep_j = j + (3 if rel_j == 0 else -3)
                if 0 <= dep_i < n and 0 <= dep_j < n and grid[dep_i][dep_j] != 0:
                    grid[i][j] = grid[dep_i][dep_j]
                    changed = True
        return tuple(tuple(row) for row in grid)

    # Fill zeros in topological order
    for idx in order:
        i, j = zeros[idx]
        di, dj = dep_coords[idx]
        grid[i][j] = grid[di][dj]

    return tuple(tuple(row) for row in grid)

