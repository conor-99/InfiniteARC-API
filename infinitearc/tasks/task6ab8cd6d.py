# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 6ab8cd6d
Difficulty: very hard

=== Tags ===
- Gas expansion
- Rotational pattern mapping

=== Description ===
**Task Description:**  Input grids feature a sparse distribution of "gas" cells
(distinct color value) scattered across the grid, each representing the starting
point of a unique expansion process. The gas expansion follows a deterministic
rotational pattern: each gas cell initiates a clockwise spiral outward,
expanding one cell per step in the sequence east → south → west → north,
repeating this cycle. The expansion proceeds as follows: from the current cell,
move in the current direction to fill the next cell (if within grid bounds and
unoccupied), then rotate direction 90° clockwise. This continues until the next
cell to be filled is outside the grid or already occupied by a cell expanded
from a different gas source.   The output grid displays the union of all
expanded cells, with each cell colored according to the gas source that first
reached it. Gas sources are prioritized by their row-major order (top-left to
bottom-right), meaning earlier sources in the grid order take precedence over
later ones when conflicts arise. The background remains unchanged for cells not
expanded by any gas source.   The challenge lies in recognizing the spiral
expansion pattern from the input, simulating the step-by-step directional
rotation for each gas source, and resolving overlapping expansions through row-
major priority. The task requires simultaneous tracking of multiple independent
spiral sequences, directional rotation logic, and conflict resolution based on
source position, making it highly non-trivial to deduce from minimal examples.
The visual complexity increases with grid size and the number of gas sources,
demanding combinatorial reasoning about spatial relationships and dynamic
direction changes.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import random_colors

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    max_gas = min(5, width * height // 2)
    num_gas = random.randint(1, max_gas)
    positions = []
    while len(positions) < num_gas:
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        if (r, c) not in positions:
            positions.append((r, c))
    positions.sort(key=lambda x: (x[0], x[1]))
    can_expand = any(c < width-1 for r, c in positions)
    while not can_expand:
        positions = []
        while len(positions) < num_gas:
            r = random.randint(0, height-1)
            c = random.randint(0, width-1)
            if (r, c) not in positions:
                positions.append((r, c))
        positions.sort(key=lambda x: (x[0], x[1]))
        can_expand = any(c < width-1 for r, c in positions)
    colors = random_colors(num_gas, exclude=[0])
    input_grid = [[0]*width for _ in range(height)]
    for (r, c), color in zip(positions, colors):
        input_grid[r][c] = color
    output_grid = [[0]*width for _ in range(height)]
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    for (r, c), color in zip(positions, colors):
        if output_grid[r][c] == 0:
            output_grid[r][c] = color
        cr, cc = r, c
        d = 0
        while True:
            dr, dc = directions[d]
            nr, nc = cr + dr, cc + dc
            if 0 <= nr < height and 0 <= nc < width and output_grid[nr][nc] == 0:
                output_grid[nr][nc] = color
                cr, cc = nr, nc
                d = (d + 1) % 4
            else:
                break
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = [[0] * width for _ in range(height)]
    gas_cells = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] > 0:
                gas_cells.append((r, c, input_grid[r][c]))
    gas_cells.sort(key=lambda x: (x[0], x[1]))
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    for r, c, color in gas_cells:
        if output_grid[r][c] == 0:
            output_grid[r][c] = color
        cr, cc = r, c
        d = 0
        while True:
            dr, dc = directions[d]
            nr, nc = cr + dr, cc + dc
            if 0 <= nr < height and 0 <= nc < width and output_grid[nr][nc] == 0:
                output_grid[nr][nc] = color
                cr, cc = nr, nc
                d = (d + 1) % 4
            else:
                break
    return tuple(tuple(row) for row in output_grid)
