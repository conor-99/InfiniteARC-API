# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 30256904
Difficulty: hard

=== Tags ===
- Holes
- Homeomorphism
- Separate shapes
- Sort rows by criteria

=== Description ===
The input grid consists of multiple distinct, separate shapes (connected
components) each represented by a unique non-zero color. Some shapes contain one
or more enclosed holesâ€”empty regions completely surrounded by the shape's color.
The transformation involves two key steps: first, filling all holes within each
shape to create solid, hole-free components (a topological operation equivalent
to removing enclosed voids while preserving connectivity), and second, sorting
the rows of the grid based on the count of non-zero cells in each row after
hole-filling, ordered from least to most filled cells. The output grid reflects
these changes, with rows rearranged to satisfy the sorting criterion while
maintaining the filled shapes. This task requires recognizing enclosed regions
within complex, multi-shape configurations and applying a multi-step
transformation that combines topological processing with combinatorial sorting.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque
import common

def fill_holes(grid):
    height = len(grid)
    width = len(grid[0])
    visited = [[False] * width for _ in range(height)]
    queue = deque()
    
    for i in range(width):
        if grid[0][i] == 0 and not visited[0][i]:
            visited[0][i] = True
            queue.append((0, i))
        if grid[height-1][i] == 0 and not visited[height-1][i]:
            visited[height-1][i] = True
            queue.append((height-1, i))
    for j in range(height):
        if grid[j][0] == 0 and not visited[j][0]:
            visited[j][0] = True
            queue.append((j, 0))
        if grid[j][width-1] == 0 and not visited[j][width-1]:
            visited[j][width-1] = True
            queue.append((j, width-1))
    
    while queue:
        r, c = queue.popleft()
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == 0:
                visited[nr][nc] = True
                queue.append((nr, nc))
    
    filled = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 and not visited[r][c]:
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                        filled[r][c] = grid[nr][nc]
                        break
    return filled

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = [[0] * width for _ in range(height)]
    
    colors = random.sample([1, 2, 3, 4, 5, 6, 7, 8, 9], 2)
    
    hollow_rows, hollow_cols = common.hollow_conway(3, 3, 5)
    top = random.randint(0, height - 3)
    left = random.randint(0, width - 3)
    for r, c in zip(hollow_rows, hollow_cols):
        grid[top + r][left + c] = colors[0]
    
    solid_rows, solid_cols = common.conway_sprite(2, 2, 1)
    top2 = random.randint(0, height - 2)
    left2 = random.randint(0, width - 2)
    for r, c in zip(solid_rows, solid_cols):
        grid[top2 + r][left2 + c] = colors[1]
    
    filled_grid = fill_holes(grid)
    row_counts = [sum(1 for cell in row if cell != 0) for row in filled_grid]
    sorted_grid = [row for _, row in sorted(zip(row_counts, filled_grid), key=lambda x: x[0])]
    
    return {"input": grid, "output": sorted_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
from collections import deque

def fill_holes(grid):
    height = len(grid)
    width = len(grid[0])
    visited = [[False] * width for _ in range(height)]
    queue = deque()
    
    for i in range(width):
        if grid[0][i] == 0 and not visited[0][i]:
            visited[0][i] = True
            queue.append((0, i))
        if grid[height-1][i] == 0 and not visited[height-1][i]:
            visited[height-1][i] = True
            queue.append((height-1, i))
    for j in range(height):
        if grid[j][0] == 0 and not visited[j][0]:
            visited[j][0] = True
            queue.append((j, 0))
        if grid[j][width-1] == 0 and not visited[j][width-1]:
            visited[j][width-1] = True
            queue.append((j, width-1))
    
    while queue:
        r, c = queue.popleft()
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == 0:
                visited[nr][nc] = True
                queue.append((nr, nc))
    
    filled = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 and not visited[r][c]:
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                        filled[r][c] = grid[nr][nc]
                        break
    return filled

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    filled_grid = fill_holes(input_grid)
    row_counts = [sum(1 for cell in row if cell != 0) for row in filled_grid]
    sorted_grid = [row for _, row in sorted(zip(row_counts, filled_grid), key=lambda x: x[0])]
    return sorted_grid
