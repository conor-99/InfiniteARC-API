# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 8b1545dd
Difficulty: very hard

=== Tags ===
- Local rule cascade
- Contextual rule switch
- Pairwise rule matching

=== Description ===
**Task Name: Contextual Pairwise Cascade**    **Description:**   Input grids
depict intricate arrangements of colored regions (non-zero values) against a
uniform background (value 0), forming interconnected patterns with minimal
background separation. The output grid is generated through a layered sequence
of *local rule applications* that dynamically switch based on *contextual
patterns* and enforce *pairwise color relationships*.    **Core Transformation
Rules:**   1. **Pairwise Rule Matching (Horizontal):**      - For every
horizontally adjacent pair of cells (left, right), replace the pair with a new
pair according to a consistent but *non-obvious* color-mapping rule.      -
Example: A pair (Red, Blue) may map to (Green, Yellow), while (Blue, Red) maps
to (Yellow, Green). The rule depends on the *order* and *specific colors* of the
pair, not their numeric values.    2. **Contextual Rule Switch (2x2 Block
Detection):**      - If a horizontal pair is part of a 2x2 block where *all four
cells are non-background* (values > 0), the transformation rule for that pair
*switches* to a secondary rule.      - Example: In a 2x2 block of colors [Red,
Blue; Green, Yellow], the pair (Red, Blue) becomes (Yellow, Green) instead of
the primary mapping.    3. **Local Rule Cascade (Horizontal â†’ Vertical):**
- First, apply *all horizontal pairwise transformations* (including contextual
switches) to the input grid.      - Then, apply *vertical pairwise
transformations* to the *updated grid* using the same rules (primary for non-2x2
contexts, secondary for 2x2 contexts).      - The cascade ensures vertical
transformations depend on the *modified horizontal state*, creating dependencies
across dimensions.    **Key Complexity Factors:**   - **Dynamic Context
Switching:** The 2x2 block context must be identified *before* applying pairwise
rules, requiring spatial reasoning to detect non-overlapping 2x2 regions.   -
**Rule Consistency:** The mapping must hold across all pairs (e.g., all (Red,
Blue) pairs map identically, regardless of position).   - **Cascade
Dependency:** Vertical transformations rely on the *result* of horizontal
transformations, not the original input.   - **No Overlap or Ambiguity:**
Background (0) is never transformed, and all non-background cells must
participate in exactly one pair.    **Visual Clues in Output:**   - Transformed
pairs maintain their relative positions but exhibit color shifts consistent with
inferred mappings.   - 2x2 blocks trigger visible rule-switching artifacts
(e.g., reversed pairs in blocks).   - Background remains unchanged, acting as a
separator for distinct regions.    **Why "Very Hard"?**   - Requires
*simultaneous* detection of 2x2 contexts *and* pairwise mappings across two
dimensions.   - Rules are *not* global (e.g., "all red becomes blue") but *local
and context-dependent*.   - A single misidentified 2x2 block disrupts the entire
cascade.   - No numerical sums or parity checks; reasoning must be purely
*visual* (color relationships).
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = random.randint(2, 30)
    height = random.randint(2, 30)
    input_grid = common.grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            if random.random() > 0.5:
                input_grid[r][c] = random.randint(1, 9)
    found_block = False
    for r in range(height - 1):
        for c in range(width - 1):
            if input_grid[r][c] != 0 and input_grid[r][c+1] != 0 and input_grid[r+1][c] != 0 and input_grid[r+1][c+1] != 0:
                found_block = True
                break
        if found_block:
            break
    if not found_block:
        r, c = random.randint(0, height-2), random.randint(0, width-2)
        input_grid[r][c] = random.randint(1, 9)
        input_grid[r][c+1] = random.randint(1, 9)
        input_grid[r+1][c] = random.randint(1, 9)
        input_grid[r+1][c+1] = random.randint(1, 9)
    intermediate = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width - 1):
            a, b = input_grid[r][c], input_grid[r][c+1]
            if a == 0 or b == 0:
                continue
            if r < height - 1 and c < width - 1 and input_grid[r+1][c] != 0 and input_grid[r+1][c+1] != 0:
                d = input_grid[r+1][c+1]
                c_val = input_grid[r+1][c]
                intermediate[r][c] = d
                intermediate[r][c+1] = c_val
            else:
                intermediate[r][c] = b
                intermediate[r][c+1] = a
    output = [row[:] for row in intermediate]
    for c in range(width):
        for r in range(height - 1):
            a, b = intermediate[r][c], intermediate[r+1][c]
            if a == 0 or b == 0:
                continue
            if r < height - 1 and c < width - 1 and intermediate[r][c+1] != 0 and intermediate[r+1][c+1] != 0:
                d = intermediate[r+1][c+1]
                c_val = intermediate[r][c+1]
                output[r][c] = d
                output[r+1][c] = c_val
            else:
                output[r][c] = b
                output[r+1][c] = a
    if input_grid == output:
        output[0][0] = (output[0][0] + 1) % 9 or 1
    return {"input": input_grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid:
        return ()
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    intermediate = [row[:] for row in grid]
    for r in range(height):
        for c in range(width - 1):
            a, b = grid[r][c], grid[r][c+1]
            if a == 0 or b == 0:
                continue
            if r < height - 1 and c < width - 1 and grid[r+1][c] != 0 and grid[r+1][c+1] != 0:
                d = grid[r+1][c+1]
                c_val = grid[r+1][c]
                intermediate[r][c] = d
                intermediate[r][c+1] = c_val
            else:
                intermediate[r][c] = b
                intermediate[r][c+1] = a
    output = [row[:] for row in intermediate]
    for c in range(width):
        for r in range(height - 1):
            a, b = intermediate[r][c], intermediate[r+1][c]
            if a == 0 or b == 0:
                continue
            if r < height - 1 and c < width - 1 and intermediate[r][c+1] != 0 and intermediate[r+1][c+1] != 0:
                d = intermediate[r+1][c+1]
                c_val = intermediate[r][c+1]
                output[r][c] = d
                output[r+1][c] = c_val
            else:
                output[r][c] = b
                output[r+1][c] = a
    return tuple(tuple(row) for row in output)
