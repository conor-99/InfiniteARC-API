# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: e6388593
Difficulty: easy

=== Tags ===
- Color the column with fewest dots
- Extend line to edge
- Pattern expansion
- Associate colors to images

=== Description ===
The task involves transforming an input grid into an output grid through two
primary visual operations. First, identify the column with the fewest non-zero
cells (dots), where non-zero values represent distinct colors. If multiple
columns share the minimum count, select the leftmost such column. Second, for
any horizontal sequence of identical non-zero colors within a row that does not
span the entire row, extend this sequence to cover the full row. The output grid
combines these steps: the identified column is uniformly recolored using a new
color not present in the input, and all horizontal color sequences are extended
to the grid edges. This transformation relies solely on visual pattern
recognition and spatial relationships, avoiding numerical calculations or pixel-
level comparisons. The rules are consistent, deterministic, and require only
basic observation of column density and line continuity.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(3, 10)
    height = random.randint(3, 10)
    input_grid = [[0] * width for _ in range(height)]
    for i in range(height):
        color = random.randint(1, 4)
        start = 1
        length = random.randint(2, width - 1)
        for j in range(start, start + length):
            input_grid[i][j] = color
    colors_present = set()
    for row in input_grid:
        for cell in row:
            if cell != 0:
                colors_present.add(cell)
    available_colors = [c for c in range(1, 10) if c not in colors_present]
    new_color = min(available_colors)
    output_grid = [[0] * width for _ in range(height)]
    for i in range(height):
        color = 0
        for j in range(width):
            if input_grid[i][j] != 0:
                color = input_grid[i][j]
                break
        if color != 0:
            if all(x == color for x in input_grid[i]):
                output_grid[i] = input_grid[i][:]
            else:
                output_grid[i] = [color] * width
        else:
            output_grid[i] = input_grid[i][:]
    for i in range(height):
        output_grid[i][0] = new_color
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input):
    width = len(input[0])
    height = len(input)
    col_counts = [0] * width
    for j in range(width):
        for i in range(height):
            if input[i][j] != 0:
                col_counts[j] += 1
    min_count = min(col_counts)
    target_col = 0
    for j in range(width):
        if col_counts[j] == min_count:
            target_col = j
            break
    output = [[0] * width for _ in range(height)]
    for i in range(height):
        color = 0
        for j in range(width):
            if input[i][j] != 0:
                color = input[i][j]
                break
        if color != 0:
            if all(x == color for x in input[i]):
                output[i] = input[i][:]
            else:
                output[i] = [color] * width
        else:
            output[i] = input[i][:]
    colors_present = set()
    for row in input:
        for cell in row:
            if cell != 0:
                colors_present.add(cell)
    available_colors = [c for c in range(1, 10) if c not in colors_present]
    new_color = min(available_colors)
    for i in range(height):
        output[i][target_col] = new_color
    return output
