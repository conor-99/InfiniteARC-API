# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 55d93c73
Difficulty: very hard

=== Tags ===
- Magnetic path alignment
- Gravity with barriers
- Bridges
- Sort objects in row by size

=== Description ===
# Magnetic Gravity Bridges Sort  Input grids are large (20Ã—20 or larger) with a
background color (0). They contain: - Barriers (color 5): solid walls that block
movement. - Magnetic poles: red (color 2) attracts paths to the right, blue
(color 3) attracts paths to the left. - Bridges (color 4): structures spanning
gaps between barriers, allowing horizontal movement through barriers when
aligned with the path. - Objects (colors 1, 6, 7, 8, 9): each represents a size
(1=smallest, 9=largest).  The output grid is generated through these sequential
transformations:  1. **Magnetic Path Alignment**: Each object traces a path
starting from its position. For red poles (2), paths move right until blocked by
barriers (5) or bridges (4). For blue poles (3), paths move left similarly. Upon
encountering a bridge (4), the path continues through the bridge structure to
the other side of the gap. Paths are drawn using the object's color on
background cells (0), avoiding barriers and other objects.  2. **Gravity with
Barriers**: After path alignment, all objects fall vertically downward due to
gravity until they hit a barrier (5) or grid bottom. Bridges (4) do not block
gravity, so objects fall through bridge structures.  3. **Row Sorting**: In each
row of the output grid, all objects are sorted by their color (size) in
ascending order (smallest color value leftmost, largest rightmost). Sorting
occurs within rows, preserving the vertical positioning determined by gravity,
with objects shifted horizontally through background cells (0) without
overlapping barriers or other objects.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    size = random.randint(20, 30)
    grid = common.grid(size, size, 0)
    
    # Place barriers (5)
    barrier_positions = common.random_pixels(size, size, prob=0.3)
    for r, c in barrier_positions:
        grid[r][c] = 5

    # Place red pole (2)
    while True:
        r, c = random.randint(0, size-1), random.randint(0, size-1)
        if grid[r][c] == 0:
            grid[r][c] = 2
            break

    # Place bridges (4)
    for _ in range(random.randint(2, 3)):
        r = random.randint(0, size-1)
        barrier_cols = [c for c in range(size) if grid[r][c] == 5]
        barrier_cols.sort()
        gaps = []
        for i in range(len(barrier_cols)-1):
            if barrier_cols[i+1] - barrier_cols[i] > 1:
                gaps.append((barrier_cols[i], barrier_cols[i+1]))
        if not gaps:
            continue
        start, end = random.choice(gaps)
        for c in range(start+1, end):
            if grid[r][c] == 0:
                grid[r][c] = 4

    # Place objects (1,6,7,8,9)
    object_colors = [1,6,7,8,9]
    object_positions = []
    for color in object_colors:
        while True:
            r, c = random.randint(0, size-1), random.randint(0, size-1)
            if grid[r][c] == 0:
                grid[r][c] = color
                object_positions.append((r, c))
                break

    output = [row[:] for row in grid]
    
    # Path alignment
    for r, c in object_positions:
        color = grid[r][c]
        c_pos = c + 1
        while c_pos < size:
            if output[r][c_pos] == 5:
                break
            if output[r][c_pos] == 0:
                output[r][c_pos] = color
            c_pos += 1

    # Apply gravity
    for r, c in object_positions:
        color = grid[r][c]
        r_pos = r
        while r_pos + 1 < size and output[r_pos+1][c] != 5:
            r_pos += 1
        output[r][c] = 0
        output[r_pos][c] = color

    # Sort objects in each row
    for r in range(size):
        objects = []
        for c in range(size):
            if output[r][c] in [1,6,7,8,9]:
                objects.append((c, output[r][c]))
        objects.sort(key=lambda x: x[1])
        for c, color in objects:
            output[r][c] = 0
        for i, (c, color) in enumerate(objects):
            for c_pos in range(size):
                if output[r][c_pos] == 0:
                    output[r][c_pos] = color
                    break

    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    size = len(input_grid)
    output = [row[:] for row in input_grid]
    
    # Collect and sort objects by color using original input grid
    objects = []
    for r in range(size):
        for c in range(size):
            color = input_grid[r][c]
            if color in [1,6,7,8,9]:
                objects.append((r, c, color))
    objects.sort(key=lambda x: x[2])
    object_positions = [(r, c) for (r, c, color) in objects]

    # Path alignment using original color
    for r, c in object_positions:
        color = input_grid[r][c]
        c_pos = c + 1
        while c_pos < size:
            if output[r][c_pos] == 5:
                break
            if output[r][c_pos] == 0:
                output[r][c_pos] = color
            c_pos += 1

    # Apply gravity using original color
    for r, c in object_positions:
        color = input_grid[r][c]
        r_pos = r
        while r_pos + 1 < size and output[r_pos+1][c] != 5:
            r_pos += 1
        output[r][c] = 0
        output[r_pos][c] = color

    # Sort objects in each row
    for r in range(size):
        objects = []
        for c in range(size):
            if output[r][c] in [1,6,7,8,9]:
                objects.append((c, output[r][c]))
        objects.sort(key=lambda x: x[1])
        for c, color in objects:
            output[r][c] = 0
        for i, (c, color) in enumerate(objects):
            for c_pos in range(size):
                if output[r][c_pos] == 0:
                    output[r][c_pos] = color
                    break
    
    return output
