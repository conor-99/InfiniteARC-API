# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: f2c3a78d
Difficulty: hard

=== Tags ===
- Pattern activation
- Blockwise rule application

=== Description ===
Task Name: Activated Block Patterns  Description: Input grids consist of a
background color (0) with non-overlapping 2×2 blocks of solid colors (1–9), each
separated by at least one background cell in all directions. A horizontal
sequence of 2×2 blocks along the top row (the "activation pattern") defines a
cyclic color sequence (e.g., [3, 7, 2] meaning 3 → 7 → 2 → 3...).  In the output
grid: 1. **Pattern Activation**: For each 2×2 block not in the activation
pattern, if it has a block of color A immediately to its right and a block of
color B immediately below it, the block is "activated." The activation color is
the next color in the activation cycle after A. 2. **Blockwise Expansion**:
Activated blocks are expanded to 3×3 blocks of their activation color, replacing
the original 2×2 block and its surrounding background cells. All other blocks
and background remain unchanged.  The activation pattern itself (top row) is
preserved in the output. Expansion does not overlap with other blocks, as input
blocks are spaced with background cells.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Choose grid size ensuring enough space for 2x2 blocks on a 3-grid spacing
    width = random.randint(11, 20)
    height = random.randint(8, 20)

    # All block top-left positions will lie on a 3-grid (0, 3, 6, ...)
    cols = [c for c in range(0, width - 1, 3)]
    rows = [r for r in range(0, height - 1, 3)]

    # Ensure there are enough top columns for the activation pattern
    max_n = min(4, len(cols))
    n = random.randint(2, max_n)

    # Choose a contiguous run of n block-columns along the top row for the activation pattern
    start_idx = random.randint(0, len(cols) - n)
    activation_cols = [cols[start_idx + i] for i in range(n)]

    # Pick distinct activation colors (cycle) in left-to-right order
    activation_colors = random.sample(list(range(1, 10)), n)

    # Initialize grid
    input_grid = grid(width, height, 0)

    # Place the activation pattern (top row, rows 0 and 1)
    blocks = {}  # map from (r,c) -> color for all 2x2 blocks placed
    for col, color in zip(activation_cols, activation_colors):
        r, c = 0, col
        input_grid[r][c] = color
        input_grid[r][c + 1] = color
        input_grid[r + 1][c] = color
        input_grid[r + 1][c + 1] = color
        blocks[(r, c)] = color

    # Candidate positions for creating an activatable configuration:
    # we need a block at (r,c) with a block at (r,c+3) (right) and at (r+3,c) (below)
    candidate_positions = []
    for r in rows:
        if r == 0:  # skip top activation row
            continue
        if (r + 3) not in rows:
            continue
        for c in cols:
            if (c + 3) not in cols:
                continue
            candidate_positions.append((r, c))

    # Always try to place at least one activatable configuration
    placed_positions = set(blocks.keys())
    if candidate_positions:
        base = random.choice(candidate_positions)
        br, bc = base
        center_color = random.randint(1, 9)
        right_color = random.choice(activation_colors)  # must match activation pattern to trigger activation
        below_color = random.randint(1, 9)

        center_pos = (br, bc)
        right_pos = (br, bc + 3)
        below_pos = (br + 3, bc)

        for (pr, pc), color in [(center_pos, center_color), (right_pos, right_color), (below_pos, below_color)]:
            # place 2x2 block if spot free
            if (pr, pc) not in placed_positions:
                input_grid[pr][pc] = color
                input_grid[pr][pc + 1] = color
                input_grid[pr + 1][pc] = color
                input_grid[pr + 1][pc + 1] = color
                blocks[(pr, pc)] = color
                placed_positions.add((pr, pc))
    # Add some additional random blocks (but keep them aligned on the 3-grid)
    # Do not place extra blocks on the top row (row 0) so the activation pattern is unambiguous
    remaining = [(r, c) for r in rows if r != 0 for c in cols if (r, c) not in placed_positions]
    random.shuffle(remaining)
    extra_count = random.randint(0, min(6, len(remaining)))
    for i in range(extra_count):
        pr, pc = remaining[i]
        color = random.randint(1, 9)
        input_grid[pr][pc] = color
        input_grid[pr][pc + 1] = color
        input_grid[pr + 1][pc] = color
        input_grid[pr + 1][pc + 1] = color
        blocks[(pr, pc)] = color
        placed_positions.add((pr, pc))

    # Create output by expanding activated blocks to 3x3 using the activation cycle
    output_grid = [row[:] for row in input_grid]

    # Build activation color list in left-to-right order along the top row
    top_blocks = sorted([(c, blocks[(0, c)]) for c in activation_cols], key=lambda x: x[0])
    activation_cycle = [color for (_, color) in top_blocks]

    # For every block not on top row, check right and below neighbors at offsets +3
    for (r, c), color in list(blocks.items()):
        if r == 0:
            continue  # top row is preserved
        right = (r, c + 3)
        below = (r + 3, c)
        if right in blocks and below in blocks:
            A = blocks[right]
            # A must be part of the activation cycle to activate
            if A in activation_cycle:
                idx = activation_cycle.index(A)
                activation_color = activation_cycle[(idx + 1) % len(activation_cycle)]
                # Expand to 3x3 centered on the original 2x2 area (i.e., top-left moves by -1,-1)
                for dr in (-1, 0, 1):
                    for dc in (-1, 0, 1):
                        rr = r + dr
                        cc = c + dc
                        if 0 <= rr < height and 0 <= cc < width:
                            output_grid[rr][cc] = activation_color

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Find all 2x2 solid blocks (top-left coordinates)
    blocks = {}
    for r in range(height - 1):
        for c in range(width - 1):
            v = grid[r][c]
            if v == 0:
                continue
            if grid[r][c + 1] == v and grid[r + 1][c] == v and grid[r + 1][c + 1] == v:
                blocks[(r, c)] = v

    # Identify activation pattern: all top-row blocks (r == 0) ordered left-to-right
    top_positions = sorted([c for (r, c) in blocks.keys() if r == 0])
    activation_cycle = [blocks[(0, c)] for c in top_positions]

    # If there is no activation cycle, nothing changes
    if len(activation_cycle) < 2:
        return tuple(tuple(row) for row in grid)

    output = [row[:] for row in grid]

    # For every non-top block, check for a right neighbor at +3 cols and below neighbor at +3 rows
    for (r, c), color in list(blocks.items()):
        if r == 0:
            continue
        right_pos = (r, c + 3)
        below_pos = (r + 3, c)
        if right_pos in blocks and below_pos in blocks:
            A = blocks[right_pos]
            if A in activation_cycle:
                idx = activation_cycle.index(A)
                activation_color = activation_cycle[(idx + 1) % len(activation_cycle)]
                # Expand to 3x3 around the original 2x2 block
                for dr in (-1, 0, 1):
                    for dc in (-1, 0, 1):
                        rr = r + dr
                        cc = c + dc
                        if 0 <= rr < height and 0 <= cc < width:
                            output[rr][cc] = activation_color

    return tuple(tuple(row) for row in output)

