# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 54b0dad3
Difficulty: insane

=== Tags ===
- Guided flow
- Pathfinding with state
- Temporal wave step

=== Description ===
# Wave Confluence Cascade  Input grids feature a 2D arrangement of colored cells
(0-9) representing a background (0), fixed obstacles (e.g., color 5), multiple
wave sources (colors 1-4), and dynamic wave modifiers (colors 6-9). Each wave
source has a fixed propagation direction (e.g., red = right, green = down, blue
= left, yellow = up) and emits a wave that moves through background cells (0) in
its direction. The grid contains no overlapping wave sources or obstacles that
would block all propagation paths.  Wave modifiers alter propagation when
encountered: - Color 6: Shifts wave color to the next sequential color (1→2,
2→3, 3→4, 4→1) - Color 7: Reverses wave direction (right→left, up→down, etc.) -
Color 8: Splits the wave into two perpendicular directions (e.g., right splits
into up and down) - Color 9: Absorbs the wave (removes it from propagation)
Wave propagation rules: 1. Waves propagate simultaneously in their current
direction at each temporal step 2. A wave cell replaces background (0) cells it
moves into 3. Waves stop at obstacles (color 5), grid boundaries, or when
absorbed (color 9) 4. When waves of different colors meet in a cell, they merge
into a new color using a fixed deterministic mapping (e.g., red + green =
purple, defined by the task) 5. Wave color changes (via color 6) or direction
changes (via color 7) occur when the wave enters a modifier cell 6. Splits
(color 8) create two independent wave paths with the current wave color  The
output grid represents the final state after all propagation has completed (all
possible waves have settled). The background (0), obstacles (5), and wave
modifiers (6-9) remain visible but unchanged. The grid shows the final color of
each cell after all wave interactions, with wave paths drawn using the merged
color values that reflect the temporal sequence of propagation. No loops or
infinite propagation occurs, and all wave sources are fully accounted for in the
final configuration.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque, defaultdict

def merge_colors(colors):
    if len(colors) == 1:
        return colors[0]
    colors = sorted(colors)
    if colors == [1, 2]:
        return 7
    if colors == [1, 3]:
        return 8
    if colors == [1, 4]:
        return 9
    if colors == [2, 3]:
        return 6
    if colors == [2, 4]:
        return 7
    if colors == [3, 4]:
        return 8
    return 0

def simulate_wave(grid):
    state = [row[:] for row in grid]
    directions = {
        1: (0, 1),
        2: (1, 0),
        3: (0, -1),
        4: (-1, 0)
    }
    queue = deque()
    rows, cols = len(grid), len(grid[0])
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] in [1, 2, 3, 4]:
                dr, dc = directions[grid[r][c]]
                nr, nc = r + dr, c + dc
                if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0:
                    queue.append((nr, nc, grid[r][c], grid[r][c]))
    while queue:
        next_queue = []
        updates = defaultdict(list)
        for r, c, color, direction in queue:
            dr, dc = directions[direction]
            nr, nc = r + dr, c + dc
            if nr < 0 or nr >= rows or nc < 0 or nc >= cols:
                continue
            cell_val = grid[nr][nc]
            if cell_val == 5:
                continue
            if 6 <= cell_val <= 9:
                if cell_val == 6:
                    color = color % 4 + 1
                elif cell_val == 7:
                    if direction == 1:
                        direction = 3
                    elif direction == 3:
                        direction = 1
                    elif direction == 2:
                        direction = 4
                    elif direction == 4:
                        direction = 2
                elif cell_val == 8:
                    if direction == 1 or direction == 3:
                        next_queue.append((nr, nc, color, 4))
                        next_queue.append((nr, nc, color, 2))
                    else:
                        next_queue.append((nr, nc, color, 3))
                        next_queue.append((nr, nc, color, 1))
                    continue
                elif cell_val == 9:
                    continue
                next_queue.append((nr, nc, color, direction))
            else:
                updates[(nr, nc)].append(color)
        for (r, c), colors in updates.items():
            merged = merge_colors(colors)
            state[r][c] = merged
        queue = next_queue
    return state

def generate():
    width = random.randint(15, 30)
    height = random.randint(15, 30)
    grid = [[0] * width for _ in range(height)]
    
    num_obstacles = random.randint(10, 20)
    for _ in range(num_obstacles):
        r, c = random.randint(0, height-1), random.randint(0, width-1)
        grid[r][c] = 5
    
    directions = {1: (0, 1), 2: (1, 0), 3: (0, -1), 4: (-1, 0)}
    for _ in range(random.randint(3, 5)):
        color = random.choice([1, 2, 3, 4])
        while True:
            r, c = random.randint(0, height-1), random.randint(0, width-1)
            if grid[r][c] == 0:
                dr, dc = directions[color]
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0:
                    grid[r][c] = color
                    break
    
    num_modifiers = random.randint(5, 10)
    for _ in range(num_modifiers):
        while True:
            r, c = random.randint(0, height-1), random.randint(0, width-1)
            if grid[r][c] == 0:
                grid[r][c] = random.randint(6, 9)
                break
    
    input_grid = grid
    output_grid = simulate_wave(grid)
    
    if input_grid == output_grid:
        return generate()
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque, defaultdict

def merge_colors(colors):
    if len(colors) == 1:
        return colors[0]
    colors = sorted(colors)
    if colors == [1, 2]:
        return 7
    if colors == [1, 3]:
        return 8
    if colors == [1, 4]:
        return 9
    if colors == [2, 3]:
        return 6
    if colors == [2, 4]:
        return 7
    if colors == [3, 4]:
        return 8
    return 0

def simulate_wave(grid):
    state = [row[:] for row in grid]
    directions = {
        1: (0, 1),
        2: (1, 0),
        3: (0, -1),
        4: (-1, 0)
    }
    queue = deque()
    rows, cols = len(grid), len(grid[0])
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] in [1, 2, 3, 4]:
                dr, dc = directions[grid[r][c]]
                nr, nc = r + dr, c + dc
                if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0:
                    queue.append((nr, nc, grid[r][c], grid[r][c]))
    while queue:
        next_queue = []
        updates = defaultdict(list)
        for r, c, color, direction in queue:
            dr, dc = directions[direction]
            nr, nc = r + dr, c + dc
            if nr < 0 or nr >= rows or nc < 0 or nc >= cols:
                continue
            cell_val = grid[nr][nc]
            if cell_val == 5:
                continue
            if 6 <= cell_val <= 9:
                if cell_val == 6:
                    color = color % 4 + 1
                elif cell_val == 7:
                    if direction == 1:
                        direction = 3
                    elif direction == 3:
                        direction = 1
                    elif direction == 2:
                        direction = 4
                    elif direction == 4:
                        direction = 2
                elif cell_val == 8:
                    if direction == 1 or direction == 3:
                        next_queue.append((nr, nc, color, 4))
                        next_queue.append((nr, nc, color, 2))
                    else:
                        next_queue.append((nr, nc, color, 3))
                        next_queue.append((nr, nc, color, 1))
                    continue
                elif cell_val == 9:
                    continue
                next_queue.append((nr, nc, color, direction))
            else:
                updates[(nr, nc)].append(color)
        for (r, c), colors in updates.items():
            merged = merge_colors(colors)
            state[r][c] = merged
        queue = next_queue
    return state

def p(input_grid):
    grid = [list(row) for row in input_grid]
    output = simulate_wave(grid)
    return tuple(tuple(row) for row in output)
