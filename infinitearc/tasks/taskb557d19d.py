# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: b557d19d
Difficulty: insane

=== Tags ===
- If then color switch
- Pattern mirroring chain
- Draw line from border
- Image rotation

=== Description ===
Input grids feature a central motif composed of contiguous colored cells (1-9)
surrounded by a uniform background (0). Four borders contain sequential color
codes: top border (row 0) for horizontal mirroring triggers, right border
(column max) for vertical mirroring triggers, bottom border (row max) for
horizontal anti-mirroring triggers, and left border (column 0) for rotation
triggers. Each sequence consists of 1-3 distinct colors that dictate the
transformation chain.  The output grid is generated through a deterministic
sequence: 1. **Mirroring Chain**: Starting with the top border sequence, each
color triggers a horizontal mirror (left-right) of non-background elements, with
the mirror axis shifting inward by one cell per trigger. The right border
sequence then triggers vertical mirrors (top-bottom), followed by bottom border
anti-mirrors (reversing horizontal direction), and left border rotation triggers
(rotating the grid 90° clockwise after each mirror operation). 2. **Color
Switch**: After each mirror operation, all newly mirrored cells undergo an "if
then" color switch: if a cell's color matches the current trigger color, it
switches to the next color in the sequence (mod 9, with 9 wrapping to 1). 3.
**Border Line Drawing**: For each mirror direction, draw a 1-cell-wide line from
the corresponding border (top/bottom for horizontal mirrors, left/right for
vertical mirrors) toward the grid center using the final switched color of the
mirrored region. 4. **Final Rotation**: Rotate the entire grid 90° clockwise,
preserving all transformed elements.  Transformations proceed in strict sequence
based on border codes, with no overlapping elements. The output reflects all
chained operations, including mirrored patterns, color-switched cells, border
lines, and final rotation, with all visual features preserved and background
cells unchanged.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, continuous_creature


def rotate_clockwise(g):
    return [list(row) for row in zip(*g[::-1])]


def generate():
    # Random grid size (keep within ARC limits)
    W = random.randint(5, 20)
    H = random.randint(5, 20)

    # Ensure minimum sizes
    W = max(5, W)
    H = max(5, H)

    # Create empty background
    input_grid = grid(W, H, 0)

    inner_w = W - 2
    inner_h = H - 2

    # Create a contiguous motif inside the inner area
    max_motif = max(3, min(inner_w * inner_h, 10))
    motif_size = random.randint(3, max_motif)
    pixels = continuous_creature(motif_size, inner_w, inner_h)

    # Choose 1-3 colors for the motif
    motif_colors_count = random.randint(1, min(3, 9))
    motif_colors = random.sample(list(range(1, 10)), motif_colors_count)

    # Paint the motif into the inner area (offset by 1 because of border)
    for idx, (r, c) in enumerate(pixels):
        color = motif_colors[idx % motif_colors_count]
        input_grid[r + 1][c + 1] = color

    motif_primary = motif_colors[0]

    # Generate border sequences lengths (1-3, but no longer than available space)
    top_len = random.randint(1, min(3, inner_w))
    right_len = random.randint(1, min(3, inner_h))
    bottom_len = random.randint(1, min(3, inner_w))
    left_len = random.randint(1, min(3, inner_h))

    # Ensure top sequence contains at least one motif color so the transformation will change the motif
    # Build top sequence with distinct colors
    available_colors = [c for c in range(1, 10) if c != motif_primary]
    if top_len == 1:
        top_seq = [motif_primary]
    else:
        top_seq_rest = random.sample(available_colors, top_len - 1)
        top_seq = top_seq_rest + [motif_primary]
        random.shuffle(top_seq)

    # Other sequences (distinct within themselves)
    def rand_seq(length):
        return random.sample(list(range(1, 10)), length)

    right_seq = rand_seq(right_len)
    bottom_seq = rand_seq(bottom_len)
    left_seq = rand_seq(left_len)

    # Place border sequences on the edges (skipping corners)
    for i, color in enumerate(top_seq):
        if i < inner_w:
            input_grid[0][i + 1] = color
    for i, color in enumerate(right_seq):
        if i < inner_h:
            input_grid[i + 1][W - 1] = color
    for i, color in enumerate(bottom_seq):
        if i < inner_w:
            input_grid[H - 1][i + 1] = color
    for i, color in enumerate(left_seq):
        if i < inner_h:
            input_grid[i + 1][0] = color

    # Start building the output by applying the described chained operations
    output_grid = [row[:] for row in input_grid]

    def inner_rows(h):
        return range(1, h - 1)

    def inner_cols(w):
        return range(1, w - 1)

    # Horizontal mirroring triggered by top_seq
    for i, color in enumerate(top_seq):
        axis_col = 1 + i  # axis shifts inward one column per trigger
        pre = [row[:] for row in output_grid]
        # Mirror cells from the snapshot pre into output if target is empty
        for r in inner_rows(H):
            for c in inner_cols(W):
                v = pre[r][c]
                if v == 0:
                    continue
                target_c = 2 * axis_col - c
                if target_c < 1 or target_c > W - 2:
                    continue
                if pre[r][target_c] != 0:
                    continue
                output_grid[r][target_c] = pre[r][c]
        # Color switch across the inner area (next color is next in the same border sequence)
        next_color = top_seq[(i + 1) % len(top_seq)]
        for r in inner_rows(H):
            for c in inner_cols(W):
                if output_grid[r][c] == color:
                    output_grid[r][c] = next_color
        # Draw a 1-cell-wide vertical line from the top border toward center in columns that got new pixels
        cols_with_new = set()
        for r in inner_rows(H):
            for c in inner_cols(W):
                if pre[r][c] == 0 and output_grid[r][c] != 0:
                    cols_with_new.add(c)
        for c in sorted(cols_with_new):
            for r in range(0, H // 2):
                if output_grid[r][c] == 0:
                    output_grid[r][c] = next_color
                else:
                    break

    # Vertical mirroring triggered by right_seq
    for i, color in enumerate(right_seq):
        axis_row = 1 + i  # axis shifts inward one row per trigger
        pre = [row[:] for row in output_grid]
        for r in inner_rows(H):
            for c in inner_cols(W):
                v = pre[r][c]
                if v == 0:
                    continue
                target_r = 2 * axis_row - r
                if target_r < 1 or target_r > H - 2:
                    continue
                if pre[target_r][c] != 0:
                    continue
                output_grid[target_r][c] = pre[r][c]
        next_color = right_seq[(i + 1) % len(right_seq)]
        for r in inner_rows(H):
            for c in inner_cols(W):
                if output_grid[r][c] == color:
                    output_grid[r][c] = next_color
        rows_with_new = set()
        for r in inner_rows(H):
            for c in inner_cols(W):
                if pre[r][c] == 0 and output_grid[r][c] != 0:
                    rows_with_new.add(r)
        for r in sorted(rows_with_new):
            for c in range(W - 1, W // 2, -1):
                if output_grid[r][c] == 0:
                    output_grid[r][c] = next_color
                else:
                    break

    # Horizontal anti-mirroring triggered by bottom_seq (axis moves from right inward)
    for i, color in enumerate(bottom_seq):
        axis_col = (W - 2) - i
        pre = [row[:] for row in output_grid]
        for r in inner_rows(H):
            for c in inner_cols(W):
                v = pre[r][c]
                if v == 0:
                    continue
                target_c = 2 * axis_col - c
                if target_c < 1 or target_c > W - 2:
                    continue
                if pre[r][target_c] != 0:
                    continue
                output_grid[r][target_c] = pre[r][c]
        next_color = bottom_seq[(i + 1) % len(bottom_seq)]
        for r in inner_rows(H):
            for c in inner_cols(W):
                if output_grid[r][c] == color:
                    output_grid[r][c] = next_color
        cols_with_new = set()
        for r in inner_rows(H):
            for c in inner_cols(W):
                if pre[r][c] == 0 and output_grid[r][c] != 0:
                    cols_with_new.add(c)
        for c in sorted(cols_with_new):
            for r in range(H - 1, H // 2, -1):
                if output_grid[r][c] == 0:
                    output_grid[r][c] = next_color
                else:
                    break

    # Rotation triggers from left_seq: rotate whole grid 90deg clockwise per trigger,
    # then apply color switch across the whole grid
    for i, color in enumerate(left_seq):
        output_grid = rotate_clockwise(output_grid)
        H = len(output_grid)
        W = len(output_grid[0])
        next_color = left_seq[(i + 1) % len(left_seq)]
        for r in range(H):
            for c in range(W):
                if output_grid[r][c] == color:
                    output_grid[r][c] = next_color

    # Final rotation of the entire grid
    output_grid = rotate_clockwise(output_grid)

    return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input (tuple of tuples) to mutable list of lists
    grid = [list(row) for row in input_grid]

    def rotate_clockwise(g):
        return [list(row) for row in zip(*g[::-1])]

    H = len(grid)
    W = len(grid[0])

    # Extract border sequences in the same order the generator wrote them
    top_seq = [grid[0][c] for c in range(1, W - 1) if grid[0][c] != 0]
    right_seq = [grid[r][W - 1] for r in range(1, H - 1) if grid[r][W - 1] != 0]
    bottom_seq = [grid[H - 1][c] for c in range(1, W - 1) if grid[H - 1][c] != 0]
    left_seq = [grid[r][0] for r in range(1, H - 1) if grid[r][0] != 0]

    output = [row[:] for row in grid]

    def inner_rows(h):
        return range(1, h - 1)

    def inner_cols(w):
        return range(1, w - 1)

    # Apply the same sequence of operations as the generator
    # Top horizontal mirrors
    for i, color in enumerate(top_seq):
        axis_col = 1 + i
        pre = [row[:] for row in output]
        for r in inner_rows(H):
            for c in inner_cols(W):
                v = pre[r][c]
                if v == 0:
                    continue
                target_c = 2 * axis_col - c
                if target_c < 1 or target_c > W - 2:
                    continue
                if pre[r][target_c] != 0:
                    continue
                output[r][target_c] = pre[r][c]
        next_color = top_seq[(i + 1) % len(top_seq)]
        for r in inner_rows(H):
            for c in inner_cols(W):
                if output[r][c] == color:
                    output[r][c] = next_color
        cols_with_new = set()
        for r in inner_rows(H):
            for c in inner_cols(W):
                if pre[r][c] == 0 and output[r][c] != 0:
                    cols_with_new.add(c)
        for c in sorted(cols_with_new):
            for r in range(0, H // 2):
                if output[r][c] == 0:
                    output[r][c] = next_color
                else:
                    break

    # Right vertical mirrors
    for i, color in enumerate(right_seq):
        axis_row = 1 + i
        pre = [row[:] for row in output]
        for r in inner_rows(H):
            for c in inner_cols(W):
                v = pre[r][c]
                if v == 0:
                    continue
                target_r = 2 * axis_row - r
                if target_r < 1 or target_r > H - 2:
                    continue
                if pre[target_r][c] != 0:
                    continue
                output[target_r][c] = pre[r][c]
        next_color = right_seq[(i + 1) % len(right_seq)]
        for r in inner_rows(H):
            for c in inner_cols(W):
                if output[r][c] == color:
                    output[r][c] = next_color
        rows_with_new = set()
        for r in inner_rows(H):
            for c in inner_cols(W):
                if pre[r][c] == 0 and output[r][c] != 0:
                    rows_with_new.add(r)
        for r in sorted(rows_with_new):
            for c in range(W - 1, W // 2, -1):
                if output[r][c] == 0:
                    output[r][c] = next_color
                else:
                    break

    # Bottom anti-mirrors
    for i, color in enumerate(bottom_seq):
        axis_col = (W - 2) - i
        pre = [row[:] for row in output]
        for r in inner_rows(H):
            for c in inner_cols(W):
                v = pre[r][c]
                if v == 0:
                    continue
                target_c = 2 * axis_col - c
                if target_c < 1 or target_c > W - 2:
                    continue
                if pre[r][target_c] != 0:
                    continue
                output[r][target_c] = pre[r][c]
        next_color = bottom_seq[(i + 1) % len(bottom_seq)]
        for r in inner_rows(H):
            for c in inner_cols(W):
                if output[r][c] == color:
                    output[r][c] = next_color
        cols_with_new = set()
        for r in inner_rows(H):
            for c in inner_cols(W):
                if pre[r][c] == 0 and output[r][c] != 0:
                    cols_with_new.add(c)
        for c in sorted(cols_with_new):
            for r in range(H - 1, H // 2, -1):
                if output[r][c] == 0:
                    output[r][c] = next_color
                else:
                    break

    # Left rotations
    for i, color in enumerate(left_seq):
        output = rotate_clockwise(output)
        H = len(output)
        W = len(output[0])
        next_color = left_seq[(i + 1) % len(left_seq)]
        for r in range(H):
            for c in range(W):
                if output[r][c] == color:
                    output[r][c] = next_color

    # Final rotation
    output = rotate_clockwise(output)

    return output

