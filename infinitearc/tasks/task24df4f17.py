# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 24df4f17
Difficulty: medium

=== Tags ===
- Direction guesingcrop
- Align by centroid pairs

=== Description ===
The input grids consist of two distinct connected shapes (each composed of non-
zero pixels connected via 4-directional adjacency) on a background of zeros. For
each shape, the centroid is calculated as the average row and column position of
all its pixels. The output grid is a cropped version of the input such that the
midpoint between the two centroids is positioned at the center of the output
grid. The crop size is determined by the minimal bounding box that contains all
pixels of both shapes, adjusted to center the midpoint. The transformation
requires identifying the shapes, computing their centroids, calculating the
midpoint, and cropping to align this midpoint to the output grid's center,
ensuring the output grid is smaller than or equal in size to the input.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, rand_sprite

def generate():
    max_attempts = 1000
    for _ in range(max_attempts):
        width = random.randint(5, 30)
        height = random.randint(5, 30)
        input_grid = grid(width, height, 0)
        
        # Generate two shapes
        shape1 = rand_sprite('el', width, height)
        shape2 = rand_sprite('aitch', width, height)
        
        # Place shape1
        for r, c in shape1:
            input_grid[r][c] = 1
        
        # Place shape2 without overlapping
        for r, c in shape2:
            if input_grid[r][c] == 0:
                input_grid[r][c] = 2
        
        # Get all non-zero pixels
        all_pixels = []
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] > 0:
                    all_pixels.append((r, c))
        
        if not all_pixels:
            continue
        
        # Find connected components
        visited = set()
        components = []
        from collections import deque
        for r, c in all_pixels:
            if (r, c) not in visited:
                component = []
                queue = deque([(r, c)])
                visited.add((r, c))
                while queue:
                    cr, cc = queue.popleft()
                    component.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] > 0 and (nr, nc) not in visited:
                            visited.add((nr, nc))
                            queue.append((nr, nc))
                components.append(component)
        
        if len(components) != 2:
            continue
        
        # Compute centroids
        def centroid(pixels):
            r_sum = sum(r for r, c in pixels)
            c_sum = sum(c for r, c in pixels)
            return (r_sum / len(pixels), c_sum / len(pixels))
        
        c1 = centroid(components[0])
        c2 = centroid(components[1])
        midpoint = ((c1[0] + c2[0]) / 2, (c1[1] + c2[1]) / 2)
        
        # Get bounding box
        min_row = min(r for r, c in all_pixels)
        max_row = max(r for r, c in all_pixels)
        min_col = min(c for r, c in all_pixels)
        max_col = max(c for r, c in all_pixels)
        
        # Check output is strictly smaller
        output_width = max_col - min_col + 1
        output_height = max_row - min_row + 1
        if output_width >= width or output_height >= height:
            continue
        
        # Check alignment with relaxed tolerance
        box_center = ((min_row + max_row) / 2, (min_col + max_col) / 2)
        if abs(midpoint[0] - box_center[0]) < 1.0 and abs(midpoint[1] - box_center[1]) < 1.0:
            output_grid = [row[min_col:max_col+1] for row in input_grid[min_row:max_row+1]]
            return {
                'input': input_grid,
                'output': output_grid
            }
    
    # Fallback with unique grid
    width = random.randint(6, 30)
    height = random.randint(6, 30)
    input_grid = grid(width, height, 0)
    input_grid[0][0] = 1
    input_grid[height-2][width-2] = 2
    output_grid = [row[0:width-1] for row in input_grid[0:height-1]]
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    from collections import deque
    
    # Find all non-zero pixels
    all_pixels = []
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] > 0:
                all_pixels.append((r, c))
    
    if not all_pixels:
        return input_grid
    
    # Find connected components
    visited = set()
    components = []
    for r, c in all_pixels:
        if (r, c) not in visited:
            component = []
            queue = deque([(r, c)])
            visited.add((r, c))
            while queue:
                cr, cc = queue.popleft()
                component.append((cr, cc))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < len(input_grid) and 0 <= nc < len(input_grid[0]) and input_grid[nr][nc] > 0 and (nr, nc) not in visited:
                        visited.add((nr, nc))
                        queue.append((nr, nc))
            components.append(component)
    
    # Get bounding box of all non-zero pixels
    min_row = min(r for r, c in all_pixels)
    max_row = max(r for r, c in all_pixels)
    min_col = min(c for r, c in all_pixels)
    max_col = max(c for r, c in all_pixels)
    
    # Crop to bounding box
    output_grid = [row[min_col:max_col+1] for row in input_grid[min_row:max_row+1]]
    return output_grid
