# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 9ab0e6fe
Difficulty: hard

=== Tags ===
- One yes one no
- Count patterns
- Occlusion reasoning
- Size guessing

=== Description ===
The task involves transforming an input grid into an output grid by applying
occlusion reasoning and pattern counting. The input grid contains values between
0 and 9, where 0 represents occluded (hidden) cells. The transformation requires
identifying all 2×2 blocks in the input grid that either: (a) are fully visible
(all non-zero cells) and monochromatic (all cells have the same color), or (b)
have partially visible cells (some 0s) but the visible cells are all the same
color (allowing inference of the occluded cells as matching the visible color).
The count of such valid blocks (N) determines the size of the output grid (N×N).
Each cell in the output grid is filled with the color of the corresponding valid
block in row-major order (top-left to bottom-right). This process demands
careful pattern recognition, occlusion inference, and size determination based
on the count, making it a challenging task requiring multi-step abstract
reasoning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    input_grid = [[0] * width for _ in range(height)]
    c = random.randint(1, 9)
    input_grid[0][0] = c
    input_grid[0][1] = c
    input_grid[1][0] = c
    input_grid[1][1] = c
    for i in range(height):
        for j in range(width):
            if (i == 0 and j in [0, 1]) or (i == 1 and j in [0, 1]):
                continue
            input_grid[i][j] = random.randint(0, 9)
    valid_colors = []
    for i in range(height - 1):
        for j in range(width - 1):
            block = [
                input_grid[i][j],
                input_grid[i][j+1],
                input_grid[i+1][j],
                input_grid[i+1][j+1]
            ]
            non_zero = [x for x in block if x != 0]
            if non_zero and all(x == non_zero[0] for x in non_zero):
                valid_colors.append(non_zero[0])
    N = len(valid_colors)
    output_grid = []
    for i in range(N):
        row = []
        for j in range(N):
            row.append(valid_colors[(i * N + j) % N])
        output_grid.append(row)
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    valid_colors = []
    for i in range(height - 1):
        for j in range(width - 1):
            block = [
                input_grid[i][j],
                input_grid[i][j+1],
                input_grid[i+1][j],
                input_grid[i+1][j+1]
            ]
            non_zero = [x for x in block if x != 0]
            if non_zero and all(x == non_zero[0] for x in non_zero):
                valid_colors.append(non_zero[0])
    N = len(valid_colors)
    if N == 0:
        N = 1
        valid_colors = [0]
    output_grid = []
    for i in range(N):
        row = []
        for j in range(N):
            row.append(valid_colors[(i * N + j) % N])
        output_grid.append(row)
    return output_grid
