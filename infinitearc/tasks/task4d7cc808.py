# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 4d7cc808
Difficulty: insane

=== Tags ===
- Area based reconstruction
- Separate shapes
- Move object based on arrow

=== Description ===
Input grids contain multiple distinct, non-overlapping shapes (each a connected
region of non-background color) on a uniform background. Each shape is adjacent
to a small directional indicator (a single cell of a unique color placed
directly next to the shape's perimeter), pointing in one of four cardinal
directions. The output grid is formed by moving each shape in the direction of
its indicator, displacing it by a number of steps equal to the shape's smallest
bounding dimension (e.g., a shape spanning 4 rows and 3 columns moves 3 steps).
Movement stops if the next position would overlap another shape or exceed grid
boundaries, with shapes placed as far as possible in the designated direction.
Directional indicators are removed from the output, leaving the repositioned
shapes and background unchanged. All shapes retain their original size, color,
and internal structure during relocation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    import math
    from common import grid, continuous_creature, random_colors

    MAX_GLOBAL_TRIES = 200
    for attempt in range(MAX_GLOBAL_TRIES):
        width = random.randint(12, 22)
        height = random.randint(12, 22)
        bg = 0
        input_grid = grid(width, height, bg)

        num_shapes = random.randint(2, 4)
        shape_colors = random_colors(num_shapes, exclude=[bg])

        # keep track of positions reserved (shapes and indicators)
        occupied_by_shapes = set()
        indicator_positions = set()
        used_indicator_colors = set()

        shapes = []  # will hold dicts: {color, pixels(set), direction, bbox}
        success = True

        for color in shape_colors:
            placed = False
            # Try multiple attempts to place this shape with a valid indicator
            for _ in range(400):
                size = random.randint(3, 10)
                # choose a small bounding box for the sprite such that area >= size
                max_box_w = min(7, width)
                max_box_h = min(7, height)
                w = random.randint(2, max_box_w)
                h = random.randint(2, max_box_h)
                if w * h < size:
                    # try to increase dimensions to accommodate size
                    w = min(max_box_w, max(2, int(math.ceil(math.sqrt(size)))))
                    h = min(max_box_h, max(2, int(math.ceil(size / float(w)))))
                    if w * h < size:
                        continue

                sprite = continuous_creature(size, w, h)
                # normalize sprite to start at (0,0)
                min_r = min(r for r, c in sprite)
                min_c = min(c for r, c in sprite)
                max_r = max(r for r, c in sprite)
                max_c = max(c for r, c in sprite)
                spr_h = max_r - min_r + 1
                spr_w = max_c - min_c + 1

                if spr_h > height or spr_w > width:
                    continue

                # pick random offset where the sprite fits
                row_off = random.randint(0, height - spr_h)
                col_off = random.randint(0, width - spr_w)

                placed_coords = set(((r - min_r) + row_off, (c - min_c) + col_off) for r, c in sprite)

                # must not overlap any already reserved cell
                reserved_cells = occupied_by_shapes.union(indicator_positions)
                if placed_coords & reserved_cells:
                    continue

                # new shape must not be adjacent (4-neighbor) to any existing indicator (so indicators remain unambiguous)
                conflict = False
                for (r, c) in placed_coords:
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        if (r + dr, c + dc) in indicator_positions:
                            conflict = True
                            break
                    if conflict:
                        break
                if conflict:
                    continue

                # compute bounding box coordinates of the placed sprite
                min_rr = min(r for r, c in placed_coords)
                max_rr = max(r for r, c in placed_coords)
                min_cc = min(c for r, c in placed_coords)
                max_cc = max(c for r, c in placed_coords)

                # collect candidate indicator positions on each side; ensure the chosen pos is adjacent to an actual shape pixel
                candidate_dirs = {}

                # helper to check candidate position validity
                def pos_ok(pr, pc):
                    if pr < 0 or pr >= height or pc < 0 or pc >= width:
                        return False
                    if (pr, pc) in reserved_cells:
                        return False
                    # indicator should not be adjacent to any previously placed shape (other than this one)
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        if (pr + dr, pc + dc) in occupied_by_shapes:
                            return False
                    return True

                # up: candidate positions above any actual top-edge shape pixel
                if min_rr - 1 >= 0:
                    poss = []
                    for c in range(min_cc, max_cc + 1):
                        if (min_rr, c) not in placed_coords:
                            continue
                        if pos_ok(min_rr - 1, c):
                            poss.append((min_rr - 1, c))
                    if poss:
                        candidate_dirs['up'] = poss

                # down
                if max_rr + 1 < height:
                    poss = []
                    for c in range(min_cc, max_cc + 1):
                        if (max_rr, c) not in placed_coords:
                            continue
                        if pos_ok(max_rr + 1, c):
                            poss.append((max_rr + 1, c))
                    if poss:
                        candidate_dirs['down'] = poss

                # left
                if min_cc - 1 >= 0:
                    poss = []
                    for r in range(min_rr, max_rr + 1):
                        if (r, min_cc) not in placed_coords:
                            continue
                        if pos_ok(r, min_cc - 1):
                            poss.append((r, min_cc - 1))
                    if poss:
                        candidate_dirs['left'] = poss

                # right
                if max_cc + 1 < width:
                    poss = []
                    for r in range(min_rr, max_rr + 1):
                        if (r, max_cc) not in placed_coords:
                            continue
                        if pos_ok(r, max_cc + 1):
                            poss.append((r, max_cc + 1))
                    if poss:
                        candidate_dirs['right'] = poss

                if not candidate_dirs:
                    # cannot place an indicator for this placement; try another placement
                    continue

                # choose a random direction and position for the indicator
                direction = random.choice(list(candidate_dirs.keys()))
                indicator_pos = random.choice(candidate_dirs[direction])

                # pick an indicator color distinct from bg and shape colors and other indicators
                used_colors = set([bg]) | set(shape_colors) | used_indicator_colors
                available = [c for c in range(1, 10) if c not in used_colors]
                if not available:
                    # fallback (very unlikely)
                    available = [c for c in range(1, 10) if c != bg and c not in used_indicator_colors]
                indicator_color = random.choice(available)

                # commit placement to input grid
                for (r, c) in placed_coords:
                    input_grid[r][c] = color
                ir, ic = indicator_pos
                input_grid[ir][ic] = indicator_color

                # update bookkeeping
                occupied_by_shapes.update(placed_coords)
                indicator_positions.add(indicator_pos)
                used_indicator_colors.add(indicator_color)
                shapes.append({
                    'color': color,
                    'pixels': set(placed_coords),
                    'direction': direction,
                    'bbox': (min_rr, min_cc, max_rr, max_cc),
                    'indicator': (indicator_pos, indicator_color)
                })
                placed = True
                break

            if not placed:
                success = False
                break

        if not success:
            continue

        # Now compute final positions by moving shapes. Use deterministic order: sort by shape color
        shapes_sorted = sorted(shapes, key=lambda s: s['color'])
        occupancy = set()
        for s in shapes_sorted:
            occupancy.update(s['pixels'])

        final_positions = {}
        moved_any = False

        dir_map = {
            'up': (-1, 0),
            'down': (1, 0),
            'left': (0, -1),
            'right': (0, 1)
        }

        for s in shapes_sorted:
            color = s['color']
            pixels = s['pixels']
            min_rr, min_cc, max_rr, max_cc = s['bbox']
            width_bbox = max_cc - min_cc + 1
            height_bbox = max_rr - min_rr + 1
            steps = min(width_bbox, height_bbox)

            dr, dc = dir_map[s['direction']]

            # temporarily free this shape's original cells for collision checks
            occupancy_minus_self = occupancy - pixels

            best_move = 0
            for step in range(1, steps + 1):
                candidate = set((r + dr * step, c + dc * step) for (r, c) in pixels)
                # check bounds
                out_of_bounds = any(r < 0 or r >= height or c < 0 or c >= width for (r, c) in candidate)
                if out_of_bounds:
                    break
                # indicators do not block movement (they will be removed), so only check against shapes
                if candidate & occupancy_minus_self:
                    break
                best_move = step

            if best_move > 0:
                moved_any = True

            new_pixels = set((r + dr * best_move, c + dc * best_move) for (r, c) in pixels)
            final_positions[color] = new_pixels

            # update occupancy: remove self, add new
            occupancy = occupancy_minus_self | new_pixels

        # Ensure at least one shape moved; otherwise try again to produce a non-trivial example
        if not moved_any:
            continue

        # Build output grid: start from input, clear original shapes and indicators, then place moved shapes
        output_grid = [row[:] for row in input_grid]

        for s in shapes:
            for (r, c) in s['pixels']:
                output_grid[r][c] = bg
            (ir, ic), icolor = s['indicator']
            output_grid[ir][ic] = bg

        for color, new_pixels in final_positions.items():
            for (r, c) in new_pixels:
                output_grid[r][c] = color

        # Final safety: input must not equal output
        if output_grid == input_grid:
            continue

        return {"input": input_grid, "output": output_grid}

    # If we fail to generate within many attempts, fall back to a simple deterministic example
    width, height = 12, 12
    bg = 0
    input_grid = grid(width, height, bg)
    input_grid[4][4] = 2
    input_grid[4][5] = 2
    input_grid[3][4] = 3  # indicator above -> move up
    output_grid = [row[:] for row in input_grid]
    output_grid[4][4] = bg
    output_grid[4][5] = bg
    output_grid[3][4] = bg
    output_grid[2][4] = 2
    output_grid[2][5] = 2
    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    from collections import deque, Counter
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Determine background color as the most frequent color
    counts = Counter()
    for r in range(height):
        for c in range(width):
            counts[grid[r][c]] += 1
    bg = counts.most_common(1)[0][0]

    # Find connected components (4-neighbor) for non-background cells
    visited = [[False] * width for _ in range(height)]
    components = []  # list of (color, list_of_pixels)

    for r in range(height):
        for c in range(width):
            if grid[r][c] == bg or visited[r][c]:
                continue
            color = grid[r][c]
            q = deque()
            q.append((r, c))
            visited[r][c] = True
            pixels = []
            while q:
                x, y = q.popleft()
                pixels.append((x, y))
                for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nx, ny = x + dx, y + dy
                    if 0 <= nx < height and 0 <= ny < width and not visited[nx][ny] and grid[nx][ny] == color:
                        visited[nx][ny] = True
                        q.append((nx, ny))
            components.append((color, pixels))

    # Classify components: single-cell components are indicators; multi-cell are shapes
    indicators = []  # list of (color, (r,c))
    shapes = []  # list of dicts: {color, pixels(set), bbox}

    for color, pixels in components:
        if len(pixels) == 1:
            indicators.append((color, pixels[0]))
        else:
            sset = set(pixels)
            min_r = min(r for r, c in sset)
            max_r = max(r for r, c in sset)
            min_c = min(c for r, c in sset)
            max_c = max(c for r, c in sset)
            shapes.append({'color': color, 'pixels': sset, 'bbox': (min_r, min_c, max_r, max_c)})

    # Map each indicator to its adjacent shape and deduce direction
    # We'll treat the indicator position as giving the direction from the shape to the indicator
    shape_by_color = {s['color']: s for s in shapes}

    # Build a mapping from shape color to its direction
    directions = {}
    for icolor, ipos in indicators:
        ir, ic = ipos
        found = False
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = ir + dr, ic + dc
            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != bg and grid[nr][nc] != icolor:
                shape_color = grid[nr][nc]
                # direction is vector from shape cell to indicator
                d_r = ir - nr
                d_c = ic - nc
                if (d_r, d_c) == (-1, 0):
                    dir_str = 'up'
                elif (d_r, d_c) == (1, 0):
                    dir_str = 'down'
                elif (d_r, d_c) == (0, -1):
                    dir_str = 'left'
                elif (d_r, d_c) == (0, 1):
                    dir_str = 'right'
                else:
                    # default fallback (should not happen)
                    dir_str = 'up'
                directions[shape_color] = dir_str
                found = True
                break
        if not found:
            # No adjacent shape found; skip (shouldn't happen in valid tasks)
            continue

    # Attach directions to shapes
    shape_list = []
    for s in shapes:
        col = s['color']
        if col in directions:
            s['direction'] = directions[col]
            shape_list.append(s)
        else:
            # If no direction found, treat as no movement
            s['direction'] = None
            shape_list.append(s)

    # Movement: same deterministic order as generator (sort by color)
    shape_list = sorted(shape_list, key=lambda x: x['color'])

    occupancy = set()
    for s in shape_list:
        occupancy.update(s['pixels'])

    dir_map = {'up': (-1, 0), 'down': (1, 0), 'left': (0, -1), 'right': (0, 1)}

    final_positions = {}
    for s in shape_list:
        color = s['color']
        pixels = s['pixels']
        min_r, min_c, max_r, max_c = s['bbox']
        width_bbox = max_c - min_c + 1
        height_bbox = max_r - min_r + 1
        steps = min(width_bbox, height_bbox)

        direction = s.get('direction')
        if not direction:
            # no movement
            final_positions[color] = set(pixels)
            continue

        dr, dc = dir_map[direction]

        occupancy_minus_self = occupancy - pixels

        best_move = 0
        for step in range(1, steps + 1):
            candidate = set((r + dr * step, c + dc * step) for (r, c) in pixels)
            # check bounds
            out_of_bounds = any(r < 0 or r >= height or c < 0 or c >= width for (r, c) in candidate)
            if out_of_bounds:
                break
            if candidate & occupancy_minus_self:
                break
            best_move = step

        new_pixels = set((r + dr * best_move, c + dc * best_move) for (r, c) in pixels)
        final_positions[color] = new_pixels
        occupancy = occupancy_minus_self | new_pixels

    # Build output grid: clear original shapes and indicators then place moved shapes
    out = [row[:] for row in grid]
    # clear original shapes and indicators
    for s in shapes:
        for (r, c) in s['pixels']:
            out[r][c] = bg
    for icolor, ipos in indicators:
        ir, ic = ipos
        out[ir][ic] = bg

    for color, new_pixels in final_positions.items():
        for (r, c) in new_pixels:
            out[r][c] = color

    return tuple(tuple(row) for row in out)

