# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: e9dcf387
Difficulty: medium–hard

=== Tags ===
- Shape to color encoding
- Threshold by area

=== Description ===
Input grids feature a background of color 0 with multiple disconnected regions
of non-zero colors, each region forming a contiguous 4-connected area. The
output grid replaces each non-background region with color 5 if its area exceeds
5, otherwise with color 1. Background cells (0) remain unchanged. The
transformation is applied uniformly across all regions, regardless of their
original color, and the grid dimensions are preserved. Input grids contain
regions of varying sizes, including both small regions (area ≤ 5) and large
regions (area > 5), requiring the solver to identify the area-based threshold
and apply the color encoding rule consistently.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common
from common import continuous_creature, random_color, randint

def generate():
    width = randint(4, 30)
    height = randint(4, 30)
    grid_input = [[0] * width for _ in range(height)]
    regions = []  # (color, pixels, area)
    
    num_regions = randint(2, 4)
    small_regions = randint(1, num_regions - 1)
    large_regions = num_regions - small_regions
    
    # Generate small regions
    for _ in range(small_regions):
        size = randint(3, 5)
        pixels = continuous_creature(size, width, height)
        min_r = min(p[0] for p in pixels)
        max_r = max(p[0] for p in pixels)
        min_c = min(p[1] for p in pixels)
        max_c = max(p[1] for p in pixels)
        region_height = max_r - min_r + 1
        region_width = max_c - min_c + 1
        dx = randint(0, width - region_width)
        dy = randint(0, height - region_height)
        shifted_pixels = [(r + dy, c + dx) for r, c in pixels]  # Fixed: swapped dx/dy
        
        if any(grid_input[r][c] != 0 for r, c in shifted_pixels):
            continue
        color = random_color()
        for r, c in shifted_pixels:
            grid_input[r][c] = color
        regions.append((color, shifted_pixels, size))
    
    # Generate large regions
    for _ in range(large_regions):
        size = randint(6, 10)
        pixels = continuous_creature(size, width, height)
        min_r = min(p[0] for p in pixels)
        max_r = max(p[0] for p in pixels)
        min_c = min(p[1] for p in pixels)
        max_c = max(p[1] for p in pixels)
        region_height = max_r - min_r + 1
        region_width = max_c - min_c + 1
        dx = randint(0, width - region_width)
        dy = randint(0, height - region_height)
        shifted_pixels = [(r + dy, c + dx) for r, c in pixels]  # Fixed: swapped dx/dy
        if any(grid_input[r][c] != 0 for r, c in shifted_pixels):
            continue
        color = random_color()
        for r, c in shifted_pixels:
            grid_input[r][c] = color
        regions.append((color, shifted_pixels, size))
    
    grid_output = [[0] * width for _ in range(height)]
    for _, pixels, area in regions:
        replacement = 1 if area <= 5 else 5
        for r, c in pixels:
            grid_output[r][c] = replacement
    
    if grid_input == grid_output:
        return generate()
    
    return {"input": grid_input, "output": grid_output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    rows = len(grid)
    cols = len(grid[0])
    visited = [[False] * cols for _ in range(rows)]
    output = [[0] * cols for _ in range(rows)]
    
    for r in range(rows):
        for c in range(cols):
            if not visited[r][c] and grid[r][c] != 0:
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and grid[nr][nc] == grid[r][c]:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                area = len(component)
                color = 1 if area <= 5 else 5
                for (cr, cc) in component:
                    output[cr][cc] = color
    return output
