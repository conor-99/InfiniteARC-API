# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: e126ff6a
Difficulty: hard

=== Tags ===
- Latent rule switching
- Image reflection
- Rectangle guessing
- Associate color to bools

=== Description ===
The input grid consists of multiple distinct colored rectangles (contiguous
regions of uniform color value) embedded within a background. Each rectangle's
color value (0â€“9) corresponds to a boolean state (True/False), which determines
the axis of reflection applied to the entire grid in the output. The largest
rectangle (by cell count) is identified; if multiple rectangles share the same
maximum size, the one with the highest color value is selected. The boolean
associated with this rectangle's color dictates the reflection direction: True
triggers horizontal reflection, False triggers vertical reflection. The color-
to-boolean mapping must be inferred from the provided examples, as it is not
explicitly defined. Solvers must accurately identify the largest rectangle
(requiring careful counting of contiguous regions), deduce the color-boolean
association through pattern recognition, and apply the correct reflection. This
task demands simultaneous attention to spatial reasoning (rectangle
identification), abstract pattern learning (color-boolean mapping), and multi-
step transformation logic, making it challenging due to the interplay of these
elements and the need to resolve ambiguous cases (e.g., tied rectangle sizes).
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = random.randint(5, 20)
    height = random.randint(5, 20)
    grid = [[0] * width for _ in range(height)]
    
    regions = []
    colors = list(range(1, 10))
    random.shuffle(colors)
    num_regions = random.randint(2, 4)
    
    for i in range(num_regions):
        color = colors[i % len(colors)]
        if i % 3 == 0:
            pixels = common.random_el(width, height)
        elif i % 3 == 1:
            pixels = common.random_you(width, height)
        else:
            pixels = common.random_aitch(width, height)
        
        valid_pixels = [(r, c) for r, c in pixels if 0 <= r < height and 0 <= c < width]
        if valid_pixels:
            regions.append((color, valid_pixels))
    
    # Place regions only on background (0)
    for color, pixels in regions:
        for r, c in pixels:
            if 0 <= r < height and 0 <= c < width and grid[r][c] == 0:
                grid[r][c] = color
    
    # Find largest region
    largest_size = 0
    largest_color = 0
    for color, pixels in regions:
        size = sum(1 for r, c in pixels if 0 <= r < height and 0 <= c < width and grid[r][c] == color)
        if size > largest_size or (size == largest_size and color > largest_color):
            largest_size = size
            largest_color = color
    
    reflect_horiz = (largest_color % 2 == 1)
    output = [row[:] for row in grid]
    if reflect_horiz:
        output = [row[::-1] for row in output]
    else:
        output = output[::-1]
    
    # Ensure input != output
    if grid == output:
        grid[0][0] = (grid[0][0] + 1) % 10
        if reflect_horiz:
            output = [row[::-1] for row in grid]
        else:
            output = grid[::-1]
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    visited = [[False] * width for _ in range(height)]
    regions = []  # (color, size)
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and input_grid[r][c] > 0:
                color = input_grid[r][c]
                stack = [(r, c)]
                count = 0
                visited[r][c] = True
                while stack:
                    r1, c1 = stack.pop()
                    count += 1
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        r2, c2 = r1 + dr, c1 + dc
                        if 0 <= r2 < height and 0 <= c2 < width and not visited[r2][c2] and input_grid[r2][c2] == color:
                            visited[r2][c2] = True
                            stack.append((r2, c2))
                regions.append((color, count))
    
    # Find largest region (size, then highest color)
    largest_region = max(regions, key=lambda x: (x[1], x[0]))
    color = largest_region[0]
    reflect_horiz = (color % 2 == 1)
    
    if reflect_horiz:
        return [row[::-1] for row in input_grid]
    else:
        return input_grid[::-1]
