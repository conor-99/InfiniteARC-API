# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 8d3c321b
Difficulty: insane

=== Tags ===
- Multi agent path weaving
- Folded grid reasoning
- Measure area
- Dominant color

=== Description ===
Input grids feature a rectangular grid (15×15 to 25×25) with a central vertical
fold line (color 9) dividing the grid into left and right halves. Each half
contains multiple disjoint, non-overlapping colored regions (colors 1–8), each
region containing a continuous path (color 0) that winds from one boundary to
another, forming a loop or linear path. Regions are separated by background
(color 0), with no two regions sharing adjacent cells. The grid includes a
"measurement zone" in the bottom-left corner (5×5 area) where each cell displays
a color corresponding to the dominant color (most frequent color) of a region in
the main grid.  The output grid is generated by folding the grid along the
central fold line, mirroring the left half onto the right half. After folding,
overlapping paths from the mirrored left half weave through the original right
half paths: at intersections, paths alternate directions (left/right turns) to
create a braided pattern without crossing. For each region, the dominant color
(most frequent color within the region before folding) is measured. Paths are
redrawn using this dominant color, with the background (color 0) filled using
the dominant color of the largest contiguous background area in the input. The
fold line (color 9) remains visible, but all original path markers (color 0) are
replaced with the dominant color paths. Paths must maintain connectivity to
their original entry/exit points, and no path may overlap with the fold line or
region borders. The measurement zone in the output matches the input, but the
dominant color of each region now visually corresponds to the path color.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, all_pixels

def generate():
    size = 20
    input_grid = grid(size, size, 0)
    
    for r in range(size):
        input_grid[r][10] = 9

    region_colors = []
    for _ in range(3):
        color = random.randint(1, 8)
        region_colors.append(color)
        
        width = random.randint(3, 5)
        height = random.randint(3, 5)
        start_row = random.randint(0, size - height - 1)
        start_col = random.randint(0, 9 - width)
        
        for r in range(start_row, start_row + height):
            for c in range(start_col, start_col + width):
                input_grid[r][c] = color
        
        path_col = start_col + width // 2
        for r in range(start_row, start_row + height):
            input_grid[r][path_col] = 0

    for i in range(5):
        for j in range(5):
            input_grid[15 + i][j] = region_colors[i % len(region_colors)]

    output_grid = [list(row) for row in input_grid]
    for r in range(size):
        for c in range(11, size):
            mirror_col = 9 - (c - 11)
            output_grid[r][c] = input_grid[r][mirror_col]

    for r in range(size):
        for c in range(size):
            if output_grid[r][c] == 0:
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < size and 0 <= nc < size and output_grid[nr][nc] != 0:
                        output_grid[r][c] = output_grid[nr][nc]
                        break

    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    size = len(input_grid)
    output_grid = [list(row) for row in input_grid]
    
    for r in range(size):
        for c in range(11, size):
            mirror_col = 9 - (c - 11)
            output_grid[r][c] = input_grid[r][mirror_col]

    for r in range(size):
        for c in range(size):
            if output_grid[r][c] == 0:
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < size and 0 <= nc < size and output_grid[nr][nc] != 0:
                        output_grid[r][c] = output_grid[nr][nc]
                        break

    return output_grid
