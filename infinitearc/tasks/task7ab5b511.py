# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 7ab5b511
Difficulty: hard

=== Tags ===
- Boolean color logic
- Compositional reflection

=== Description ===
# Symmetric Boolean Reflection  Input grids are 2D grids with dimensions between
5×5 and 30×30. The grids contain a continuous, possibly non-straight vertical
path composed of cells with color value 5 that serves as the reflection axis.
This axis must be a continuous path with no gaps, separating the grid into left
and right regions. The left region contains background (0) and colored cells,
while the right region mirrors the left region but with color variations.  The
output grid is generated through the following steps:  1. Identify the
reflection axis: Locate the continuous path of color 5 that forms the vertical
axis. This path may twist but must remain connected without crossing itself.  2.
Reflect the grid: For each cell (r, c) in the left region (to the left of the
axis), find its reflection across the axis. The reflection position must be
determined based on the axis path, not a fixed column.  3. Apply Boolean color
logic: For each reflected cell pair (original left cell and its reflection on
the right):    - If both the original cell and its reflection cell are non-zero
(colored), set the reflected position to color 7.    - If exactly one cell is
non-zero, set the reflected position to color 8.    - If both cells are zero
(background), leave the reflected position as zero.  4. Preserve the axis: Cells
along the reflection axis (color 5) remain unchanged in the output.  The
reflection axis itself remains visible as a continuous path of color 5 in the
output. The transformation requires identifying the non-straight axis, applying
reflection based on the axis path, and applying the Boolean color logic to
determine the output colors for all non-axis cells. The complexity arises from
determining the reflection axis path, handling non-straight reflection, and
correctly applying the color logic to each cell pair.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

_seen = set()

def _grid_to_tuple(g):
    return tuple(tuple(row) for row in g)


def generate():
    global _seen
    # try multiple attempts to produce unique pair
    for _ in range(2000):
        width = random.randint(5, 30)
        height = random.randint(5, 30)
        # ensure axis column has space on both sides: at least 1 col left and right -> axis col in range 1..width-2
        if width < 3:
            continue
        start_col = random.randint(1, width - 2)
        c = start_col
        axis = []
        for r in range(height):
            axis.append((r, c))
            c += random.choice([-1, 0, 1])
            c = max(1, min(width - 2, c))
        # create grid
        input_grid = grid(width, height, 0)
        # set axis cells to 5
        for r, col in axis:
            input_grid[r][col] = 5
        # allowed colors exclude axis color 5 and result colors 7 and 8
        allowed = [1, 2, 3, 4, 6, 9]
        # fill left and right regions
        for r, col in axis:
            # left side
            for cc in range(col):
                if random.random() < 0.6:
                    input_grid[r][cc] = random.choice(allowed)
            # right side
            for cc in range(col + 1, width):
                if random.random() < 0.5:
                    input_grid[r][cc] = random.choice(allowed)
        # ensure at least one non-axis non-zero cell exists
        nonaxis_nonzero = any(input_grid[r][c] != 0 and input_grid[r][c] != 5 for r in range(height) for c in range(width))
        if not nonaxis_nonzero:
            # force one left or right cell to be non-zero
            r, col = random.choice(axis)
            # choose side
            if col > 0 and random.random() < 0.5:
                input_grid[r][random.randint(0, col - 1)] = random.choice(allowed)
            elif col < width - 1:
                input_grid[r][random.randint(col + 1, width - 1)] = random.choice(allowed)
            else:
                # fallback
                input_grid[r][col - 1] = random.choice(allowed)
        # compute output grid
        output_grid = [row[:] for row in input_grid]
        for r, col in axis:
            for cc in range(col):
                refl = 2 * col - cc
                if refl < 0 or refl >= width:
                    continue
                left_val = input_grid[r][cc]
                right_val = input_grid[r][refl]
                if left_val != 0 and right_val != 0:
                    output_grid[r][refl] = 7
                elif left_val != 0 or right_val != 0:
                    output_grid[r][refl] = 8
                else:
                    output_grid[r][refl] = 0
        inp_t = _grid_to_tuple(input_grid)
        out_t = _grid_to_tuple(output_grid)
        key = (inp_t, out_t)
        if key in _seen:
            continue
        _seen.add(key)
        return {'input': input_grid, 'output': output_grid}
    raise RuntimeError("Failed to generate unique grid pair")



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert tuple-of-tuples to a mutable list-of-lists
    ingrid = [list(row) for row in input_grid]
    height = len(ingrid)
    width = len(ingrid[0]) if height > 0 else 0
    # Make a copy for output
    output_grid = [row[:] for row in ingrid]
    # Find axis columns per row (value 5)
    axis_cols = {}
    for r in range(height):
        for c in range(width):
            if ingrid[r][c] == 5:
                if r not in axis_cols:
                    axis_cols[r] = c
                else:
                    # Keep the first found axis cell in the row
                    pass
    # Apply reflection and boolean color logic
    for r, c_axis in axis_cols.items():
        for col in range(c_axis):
            refl_col = 2 * c_axis - col
            if refl_col < 0 or refl_col >= width:
                continue
            left_val = ingrid[r][col]
            right_val = ingrid[r][refl_col]
            if left_val != 0 and right_val != 0:
                output_grid[r][refl_col] = 7
            elif left_val != 0 or right_val != 0:
                output_grid[r][refl_col] = 8
            else:
                output_grid[r][refl_col] = 0
    return output_grid

