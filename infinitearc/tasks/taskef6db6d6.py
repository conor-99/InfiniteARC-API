# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: ef6db6d6
Difficulty: medium

=== Tags ===
- Color palette
- Shape guessing
- Take half

=== Description ===
The input grid contains a single connected shape (a contiguous region of non-
zero cells with the same color), surrounded by background (zero) cells. The
output grid is derived by preserving only the top half of the shape's vertical
extent. The vertical extent is determined by the minimum and maximum row indices
of the shape's bounding box. The number of rows retained is calculated as the
floor division of the vertical extent height by two. Specifically, if the
vertical extent spans `h` rows (from top to bottom), the output retains the
first `h // 2` rows of this extent, with all other cells set to zero. This
transformation requires identifying the shape's structure, determining its
bounding box, and applying a consistent halving operation to its vertical
dimension.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
from common import continuous_creature, grid
def generate():
    width = common.randint(1, 30)
    height = common.randint(1, 30)
    color = common.randint(1, 9)
    size = common.randint(3, width * height)
    pixels = continuous_creature(size, width, height)
    input_grid = grid(width, height, 0)
    for (r, c) in pixels:
        input_grid[r][c] = color
    min_row = min(r for r, c in pixels)
    max_row = max(r for r, c in pixels)
    h = max_row - min_row + 1
    top_rows = h // 2
    output_grid = grid(width, height, 0)
    for (r, c) in pixels:
        if r >= min_row and r < min_row + top_rows:
            output_grid[r][c] = color
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
from common import grid
def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    non_zero = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                non_zero.append((r, c))
    if not non_zero:
        return grid(width, height, 0)
    min_row = min(r for r, c in non_zero)
    max_row = max(r for r, c in non_zero)
    h = max_row - min_row + 1
    top_rows = h // 2
    output = grid(width, height, 0)
    for (r, c) in non_zero:
        if r >= min_row and r < min_row + top_rows:
            output[r][c] = input_grid[r][c]
    return output
