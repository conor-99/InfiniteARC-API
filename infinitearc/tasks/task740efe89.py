# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 740efe89
Difficulty: hard

=== Tags ===
- Temporal wave step
- Background filling
- X marks the spot

=== Description ===
Input grids feature a background color (0) with scattered "X" markers (color 9)
and static obstacles (colors 1-8) that block wave propagation. The output grid
fills all background cells (0) with a color determined by the shortest path
length (in steps) from each cell to the nearest X marker, traversing only
background cells. The color assignment uses the formula (path_length % 9) + 1,
cycling through colors 1-9. Obstacles (non-background, non-X colors) and X
markers (color 9) remain unchanged. The transformation requires computing
shortest paths through background corridors, avoiding obstacles, with the output
visualizing the wave's "temporal step" progression across the grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    grid = [[0] * width for _ in range(height)]
    
    # Place Xs (color 9)
    for _ in range(random.randint(2, 5)):
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        grid[r][c] = 9
    
    # Place obstacles (colors 1-8)
    for _ in range(random.randint(10, 50)):
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        if grid[r][c] == 0:
            grid[r][c] = random.randint(1, 8)
    
    def compute_output(grid):
        width = len(grid[0])
        height = len(grid)
        dist = [[-1] * width for _ in range(height)]
        q = deque()
        for r in range(height):
            for c in range(width):
                if grid[r][c] == 9:
                    dist[r][c] = 0
                    q.append((r, c))
        while q:
            r, c = q.popleft()
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    if grid[nr][nc] == 0 and dist[nr][nc] == -1:
                        dist[nr][nc] = dist[r][c] + 1
                        q.append((nr, nc))
        output = [[0] * width for _ in range(height)]
        for r in range(height):
            for c in range(width):
                if grid[r][c] != 0:
                    output[r][c] = grid[r][c]
                else:
                    if dist[r][c] == -1:
                        output[r][c] = 0
                    else:
                        output[r][c] = (dist[r][c] % 9) + 1
        return output
    
    output_grid = compute_output(grid)
    return {"input": grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque
def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    dist = [[-1] * width for _ in range(height)]
    q = deque()
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 9:
                dist[r][c] = 0
                q.append((r, c))
    while q:
        r, c = q.popleft()
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width:
                if input_grid[nr][nc] == 0 and dist[nr][nc] == -1:
                    dist[nr][nc] = dist[r][c] + 1
                    q.append((nr, nc))
    output = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                output[r][c] = input_grid[r][c]
            else:
                if dist[r][c] == -1:
                    output[r][c] = 0
                else:
                    output[r][c] = (dist[r][c] % 9) + 1
    return output
