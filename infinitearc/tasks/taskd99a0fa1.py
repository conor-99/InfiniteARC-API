# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: d99a0fa1
Difficulty: insane

=== Tags ===
- Laser diffusion

=== Description ===
# Laser Diffusion Grid  Input grids feature a background color (0), walls of
colors 1-4 (reflective), and color 5 (diffusive), along with L-shaped laser
clusters. Each laser's L-shape defines its origin (the uncolored cell at the
tip) and direction (the diagonal direction the L faces). The grid also includes
multiple lasers and walls positioned such that their beams interact with
diffusive walls. All walls are 1-cell-thick and do not touch each other or
lasers.  Transformation rules require the following sequence of operations:  1.
**Beam Emission:** Each laser emits a single diagonal beam starting at its
origin, traveling in the direction indicated by the L's orientation (e.g., L
facing northeast means beam moves northeast).  2. **Beam Travel:** Beams move
diagonally one cell at a time through background cells until hitting a non-
background cell (a wall).  3. **Reflective Walls (Colors 1-4):** Upon hitting a
reflective wall, beams reflect according to standard mirror reflection rules
(vertical walls reverse horizontal movement, horizontal walls reverse vertical
movement), and the beam's color changes to the wall's color.  4. **Diffusive
Walls (Color 5):** Upon hitting a diffusive wall, beams **split into two new
beams**:    - **Primary Beam:** Continues in the original direction with color
changed to the wall's color.    - **Secondary Beam:** Reflects off the wall in
the standard mirror direction with color changed to the wall's color.  5.
**Cascade Effects:** Both primary and secondary beams continue traveling,
potentially hitting additional walls, causing further splits or reflections,
with color changes propagating through each interaction.  6. **Non-Overlapping
Constraint:** Beams never overlap or intersect, and all paths exit the grid
after finite reflections/splits.  7. **Output Grid:** Contains all original grid
elements (walls, lasers) unchanged, with all beams drawn as single-cell-wide
diagonal lines following the transformation rules. The output must maintain the
exact grid dimensions as the input, with beams only drawn over background cells.
The task requires users to simultaneously track multiple beam paths, manage
color transformations, predict beam splits, and handle cascading
reflectionsâ€”creating a visually complex transformation that demands hierarchical
reasoning across multiple beam interactions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque
from common import grid

# Helper: find lasers and simulate beam propagation

def find_laser_beams(grid):
    """Detect L-shaped laser patterns: a 2x2 block with exactly three equal colors in 6..9 and one zero.

    Returns list of beams as tuples (origin_r, origin_c, dr, dc, color).
    Origin is the empty (0) cell in the 2x2; direction maps to that corner's diagonal:
      top-left missing -> NW (-1, -1)
      top-right missing -> NE (-1, +1)
      bottom-left missing -> SW (+1, -1)
      bottom-right missing -> SE (+1, +1)
    """
    beams = []
    seen = set()
    rows = len(grid)
    cols = len(grid[0])
    for r in range(rows - 1):
        for c in range(cols - 1):
            cells = [(r, c), (r, c + 1), (r + 1, c), (r + 1, c + 1)]
            vals = [grid[rr][cc] for rr, cc in cells]
            zeros = [i for i, v in enumerate(vals) if v == 0]
            if len(zeros) != 1:
                continue
            # other three must be laser color in 6..9 and all equal
            others = [v for v in vals if v != 0]
            if any(v < 6 or v > 9 for v in others):
                continue
            if not (others[0] == others[1] == others[2]):
                continue
            color = others[0]
            miss = zeros[0]
            if miss == 0:
                origin = (r, c); dr, dc = -1, -1
            elif miss == 1:
                origin = (r, c + 1); dr, dc = -1, 1
            elif miss == 2:
                origin = (r + 1, c); dr, dc = 1, -1
            else:
                origin = (r + 1, c + 1); dr, dc = 1, 1
            key = (origin[0], origin[1], dr, dc, color)
            if key in seen:
                continue
            seen.add(key)
            beams.append((origin[0], origin[1], dr, dc, color))
    return beams


def simulate_beams(ingrid):
    """Simulate beams according to rules in task description."""
    rows = len(ingrid)
    cols = len(ingrid[0])
    grid_copy = [row[:] for row in ingrid]
    output = [row[:] for row in grid_copy]

    beams = find_laser_beams(grid_copy)
    q = deque()
    for b in beams:
        q.append(b)

    visited = set()  # avoid infinite loops: (r,c,dr,dc,color)

    while q:
        r, c, dr, dc, color = q.popleft()
        state = (r, c, dr, dc, color)
        if state in visited:
            continue
        visited.add(state)

        nr, nc = r + dr, c + dc
        if nr < 0 or nr >= rows or nc < 0 or nc >= cols:
            # beam leaves the grid
            continue

        if grid_copy[nr][nc] == 0:
            # travel through background cell and paint it if not already painted
            if output[nr][nc] == 0:
                output[nr][nc] = color
            q.append((nr, nc, dr, dc, color))
            continue

        # we hit a non-background cell (a wall or other colored cell)
        wall_color = grid_copy[nr][nc]

        # determine orientation of the wall cell by checking neighbors of the same color
        is_horizontal = False
        is_vertical = False
        if nc - 1 >= 0 and grid_copy[nr][nc - 1] == wall_color:
            is_horizontal = True
        if nc + 1 < cols and grid_copy[nr][nc + 1] == wall_color:
            is_horizontal = True
        if nr - 1 >= 0 and grid_copy[nr - 1][nc] == wall_color:
            is_vertical = True
        if nr + 1 < rows and grid_copy[nr + 1][nc] == wall_color:
            is_vertical = True

        # Diffusive wall: split into primary (same direction) and secondary (reflected)
        if wall_color == 5:
            # primary beam continues straight but color becomes 5
            q.append((nr, nc, dr, dc, 5))
            # secondary beam reflects
            if is_horizontal and not is_vertical:
                new_dr, new_dc = -dr, dc
            elif is_vertical and not is_horizontal:
                new_dr, new_dc = dr, -dc
            else:
                # ambiguous (small wall cell or corner), default to flipping vertical movement
                new_dr, new_dc = -dr, dc
            q.append((nr, nc, new_dr, new_dc, 5))
        else:
            # reflective wall (colors 1-4): reflect and change beam color
            if is_horizontal and not is_vertical:
                new_dr, new_dc = -dr, dc
            elif is_vertical and not is_horizontal:
                new_dr, new_dc = dr, -dc
            else:
                # ambiguous: default to flipping vertical movement
                new_dr, new_dc = -dr, dc
            q.append((nr, nc, new_dr, new_dc, wall_color))

    return output


def generate():
    # Build grids until we have a valid scenario where at least one diffusive split occurs
    for attempt in range(300):
        width = random.randint(8, 20)
        height = random.randint(8, 20)
        grid_input = grid(width, height, 0)

        # occupancy map: once an object or its immediate neighbours are occupied we mark them
        occupied = [[False] * width for _ in range(height)]

        def in_bounds(rr, cc):
            return 0 <= rr < height and 0 <= cc < width

        def neighbours8(cells):
            s = set()
            for (rr, cc) in cells:
                for dr in (-1, 0, 1):
                    for dc in (-1, 0, 1):
                        nr, nc = rr + dr, cc + dc
                        if in_bounds(nr, nc):
                            s.add((nr, nc))
            return s

        # place lasers (2x2 with one missing corner)
        lasers = []
        laser_colors = [6, 7, 8, 9]
        random.shuffle(laser_colors)
        num_lasers = random.randint(1, 3)
        ok = True
        for i in range(num_lasers):
            placed = False
            for _ in range(300):
                # choose a 2x2 block somewhere with a margin so beams can go out
                r0 = random.randint(1, height - 3)
                c0 = random.randint(1, width - 3)
                positions = [(r0, c0), (r0, c0 + 1), (r0 + 1, c0), (r0 + 1, c0 + 1)]
                miss = random.randint(0, 3)
                colored = [pos for idx, pos in enumerate(positions) if idx != miss]
                missing = positions[miss]

                # colored cells must be free and the block must not be adjacent to previously placed objects
                conflict = False
                for (rr, cc) in colored:
                    if grid_input[rr][cc] != 0 or occupied[rr][cc]:
                        conflict = True
                        break
                if conflict:
                    continue
                if grid_input[missing[0]][missing[1]] != 0 or occupied[missing[0]][missing[1]]:
                    continue

                # ensure the 2x2 and its neighbours are free
                nb = neighbours8(colored + [missing])
                if any(occupied[rr][cc] for (rr, cc) in nb):
                    continue

                color = laser_colors[i % len(laser_colors)]
                for (rr, cc) in colored:
                    grid_input[rr][cc] = color
                for (rr, cc) in nb:
                    occupied[rr][cc] = True

                if miss == 0:
                    origin = (r0, c0); dr, dc = -1, -1
                elif miss == 1:
                    origin = (r0, c0 + 1); dr, dc = -1, 1
                elif miss == 2:
                    origin = (r0 + 1, c0); dr, dc = 1, -1
                else:
                    origin = (r0 + 1, c0 + 1); dr, dc = 1, 1
                lasers.append((origin[0], origin[1], dr, dc, color))
                placed = True
                break
            if not placed:
                ok = False
                break
        if not ok:
            continue

        # For each laser ensure there is a diffusive wall (color 5) on its diagonal path so splits are guaranteed
        walls = []
        for (origin_r, origin_c, dr, dc, lcolor) in lasers:
            # compute candidate k values where an intersection with the grid exists
            ks = []
            for k in range(2, max(width, height)):
                hr = origin_r + k * dr
                hc = origin_c + k * dc
                if not in_bounds(hr, hc):
                    break
                ks.append(k)
            if not ks:
                ok = False
                break
            k = random.choice(ks)
            hit_r = origin_r + k * dr
            hit_c = origin_c + k * dc

            # try place a diffusive wall including (hit_r, hit_c)
            placed_wall = False
            for orient in random.sample(["h", "v"], 2):
                for Llen in (2, 3, 4):
                    if orient == "h":
                        for s in range(Llen):
                            start_c = hit_c - s
                            start_r = hit_r
                            if start_c < 0 or start_c + Llen - 1 >= width:
                                continue
                            cell_list = [(start_r, start_c + i) for i in range(Llen)]
                            nb = neighbours8(cell_list)
                            if any(grid_input[rr][cc] != 0 for (rr, cc) in cell_list):
                                continue
                            if any(occupied[rr][cc] for (rr, cc) in nb):
                                continue
                            for (rr, cc) in cell_list:
                                grid_input[rr][cc] = 5
                            for (rr, cc) in nb:
                                occupied[rr][cc] = True
                            walls.append((cell_list, 5))
                            placed_wall = True
                            break
                        if placed_wall:
                            break
                    else:
                        for s in range(Llen):
                            start_r = hit_r - s
                            start_c = hit_c
                            if start_r < 0 or start_r + Llen - 1 >= height:
                                continue
                            cell_list = [(start_r + i, start_c) for i in range(Llen)]
                            nb = neighbours8(cell_list)
                            if any(grid_input[rr][cc] != 0 for (rr, cc) in cell_list):
                                continue
                            if any(occupied[rr][cc] for (rr, cc) in nb):
                                continue
                            for (rr, cc) in cell_list:
                                grid_input[rr][cc] = 5
                            for (rr, cc) in nb:
                                occupied[rr][cc] = True
                            walls.append((cell_list, 5))
                            placed_wall = True
                            break
                        if placed_wall:
                            break
                if placed_wall:
                    break
            if not placed_wall:
                ok = False
                break
        if not ok:
            continue

        # add some additional reflective walls for complexity
        extra = random.randint(0, 3)
        for _ in range(extra):
            placed_extra = False
            for _ in range(300):
                orient = random.choice(["h", "v"])
                Llen = random.choice([2, 3, 4])
                if orient == "h":
                    rr = random.randint(1, height - 2)
                    cc = random.randint(0, width - Llen)
                    cell_list = [(rr, cc + i) for i in range(Llen)]
                else:
                    rr = random.randint(0, height - Llen)
                    cc = random.randint(1, width - 2)
                    cell_list = [(rr + i, cc) for i in range(Llen)]
                nb = neighbours8(cell_list)
                if any(grid_input[r0][c0] != 0 for (r0, c0) in cell_list):
                    continue
                if any(occupied[r0][c0] for (r0, c0) in nb):
                    continue
                wcol = random.choice([1, 2, 3, 4])
                for (r0, c0) in cell_list:
                    grid_input[r0][c0] = wcol
                for (r0, c0) in nb:
                    occupied[r0][c0] = True
                walls.append((cell_list, wcol))
                placed_extra = True
                break
            if not placed_extra:
                pass

        output = simulate_beams(grid_input)

        # must have drawn at least one beam cell (some background changed) and at least one diffusive split
        drew_beam = False
        diffused = False
        for rr in range(height):
            for cc in range(width):
                if grid_input[rr][cc] == 0 and output[rr][cc] != 0:
                    drew_beam = True
                # a beam resulting in color 5 that wasn't an original wall cell is evidence of split
                if grid_input[rr][cc] != 5 and output[rr][cc] == 5:
                    diffused = True
            if drew_beam and diffused:
                break

        if drew_beam and diffused:
            return {"input": grid_input, "output": output}

    # fallback deterministic small scenario if the randomized attempts failed
    width, height = 8, 8
    grid_input = grid(width, height, 0)
    # place a single laser at center with missing bottom-right (so it shoots SE)
    grid_input[3][3] = 6
    grid_input[3][4] = 6
    grid_input[4][3] = 6
    # diffusive wall directly on its diagonal
    grid_input[6][6] = 5
    output = simulate_beams(grid_input)
    return {"input": grid_input, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque


def find_laser_beams(grid):
    beams = []
    seen = set()
    rows = len(grid)
    cols = len(grid[0])
    for r in range(rows - 1):
        for c in range(cols - 1):
            cells = [(r, c), (r, c + 1), (r + 1, c), (r + 1, c + 1)]
            vals = [grid[rr][cc] for rr, cc in cells]
            zeros = [i for i, v in enumerate(vals) if v == 0]
            if len(zeros) != 1:
                continue
            others = [v for v in vals if v != 0]
            if any(v < 6 or v > 9 for v in others):
                continue
            if not (others[0] == others[1] == others[2]):
                continue
            color = others[0]
            miss = zeros[0]
            if miss == 0:
                origin = (r, c); dr, dc = -1, -1
            elif miss == 1:
                origin = (r, c + 1); dr, dc = -1, 1
            elif miss == 2:
                origin = (r + 1, c); dr, dc = 1, -1
            else:
                origin = (r + 1, c + 1); dr, dc = 1, 1
            key = (origin[0], origin[1], dr, dc, color)
            if key in seen:
                continue
            seen.add(key)
            beams.append((origin[0], origin[1], dr, dc, color))
    return beams


def p(input_grid):
    # convert tuple-of-tuples to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    rows = len(grid)
    cols = len(grid[0])
    output = [row[:] for row in grid]

    beams = find_laser_beams(grid)
    q = deque()
    for b in beams:
        q.append(b)

    visited = set()

    while q:
        r, c, dr, dc, color = q.popleft()
        state = (r, c, dr, dc, color)
        if state in visited:
            continue
        visited.add(state)

        nr, nc = r + dr, c + dc
        if nr < 0 or nr >= rows or nc < 0 or nc >= cols:
            continue

        if grid[nr][nc] == 0:
            if output[nr][nc] == 0:
                output[nr][nc] = color
            q.append((nr, nc, dr, dc, color))
            continue

        wall_color = grid[nr][nc]
        is_horizontal = False
        is_vertical = False
        if nc - 1 >= 0 and grid[nr][nc - 1] == wall_color:
            is_horizontal = True
        if nc + 1 < cols and grid[nr][nc + 1] == wall_color:
            is_horizontal = True
        if nr - 1 >= 0 and grid[nr - 1][nc] == wall_color:
            is_vertical = True
        if nr + 1 < rows and grid[nr + 1][nc] == wall_color:
            is_vertical = True

        if wall_color == 5:
            q.append((nr, nc, dr, dc, 5))
            if is_horizontal and not is_vertical:
                new_dr, new_dc = -dr, dc
            elif is_vertical and not is_horizontal:
                new_dr, new_dc = dr, -dc
            else:
                new_dr, new_dc = -dr, dc
            q.append((nr, nc, new_dr, new_dc, 5))
        else:
            if is_horizontal and not is_vertical:
                new_dr, new_dc = -dr, dc
            elif is_vertical and not is_horizontal:
                new_dr, new_dc = dr, -dc
            else:
                new_dr, new_dc = -dr, dc
            q.append((nr, nc, new_dr, new_dc, wall_color))

    return output

