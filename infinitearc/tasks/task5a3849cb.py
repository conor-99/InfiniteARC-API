# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 5a3849cb
Difficulty: hard

=== Tags ===
- Multi condition recolor
- Loopless path
- Trail memory
- Pattern activation

=== Description ===
Input grids feature a single continuous loopless path composed of a distinct
color (e.g., color 3), traversing 5–15 cells without self-intersection. The path
is surrounded by a uniform background (color 0), with sparse non-path elements:
isolated 2×2 blocks of color 5 (activation pattern A) and color 7 (activation
pattern B) placed at varying positions. These blocks are never adjacent to the
path or overlapping.   The output grid transforms the path by recoloring each
cell based on two interdependent conditions: 1. **Direction of movement**:
Determined by the vector from the previous path cell to the current cell (e.g.,
east, south-east, north). Each direction maps to a base color (e.g., east →
color 4, south → color 6). 2. **Activation pattern proximity**: For each path
cell, check a fixed relative offset (e.g., "northeast" position relative to the
cell). If an activation pattern A (color 5) exists in this offset, add 1 to the
base color; if pattern B (color 7) exists, add 2. If both patterns exist, add 3.
The recoloring rule is strictly deterministic:   - Base direction → color X   -
Pattern A present → X + 1   - Pattern B present → X + 2   - Both patterns → X +
3    Activation patterns must be fully contained within grid boundaries and
cannot overlap with the path. Background elements and activation patterns remain
unchanged. The path is traversed sequentially, with direction determined by
consecutive path cell coordinates (e.g., from (r,c) to (r+1,c) = south). Output
grids must maintain path continuity while applying multi-condition recoloring,
requiring recognition of directional vectors, distant pattern placement, and
combinatorial rule application without memorization.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    grid = [[0 for _ in range(width)] for _ in range(height)]
    path_length = random.randint(5, 15)

    # Helper to try to build path by DFS/backtracking
    from random import shuffle
    def build_path(start, target):
        path = [start]
        visited = set(path)
        def backtrack():
            if len(path) >= target:
                return True
            r,c = path[-1]
            neigh = [(r+1,c),(r-1,c),(r,c+1),(r,c-1)]
            shuffle(neigh)
            for nr,nc in neigh:
                if not (0 <= nr < height and 0 <= nc < width):
                    continue
                if (nr,nc) in visited:
                    continue
                visited.add((nr,nc))
                path.append((nr,nc))
                if backtrack():
                    return True
                path.pop()
                visited.remove((nr,nc))
            return False
        success = backtrack()
        return path if success else None

    # Try multiple starts until we get a path
    attempts = 0
    path = None
    while attempts < 200:
        start = (random.randint(0, height-1), random.randint(0, width-1))
        res = build_path(start, path_length)
        if res is not None:
            path = res
            break
        attempts += 1
    if path is None:
        # fallback: create simple straight path horizontally
        r = random.randint(2, height-3)
        c = random.randint(2, width - path_length - 2)
        path = [(r, c+i) for i in range(path_length)]

    for r,c in path:
        grid[r][c] = 3

    # Block placement utilities
    def can_place_block(br, bc, color):
        if br < 0 or bc < 0 or br+1 >= height or bc+1 >= width:
            return False
        # ensure the 2x2 cells are empty
        for dr in (0,1):
            for dc in (0,1):
                if grid[br+dr][bc+dc] != 0:
                    return False
        # ensure no path cells or other blocks are adjacent (8-neighborhood) to the block
        for rr in range(br-1, br+3):
            for cc in range(bc-1, bc+3):
                if 0 <= rr < height and 0 <= cc < width:
                    if grid[rr][cc] == 3:
                        return False
        return True

    # offsets relative to a path cell for activation pattern checks
    OFF_A = (-2, 2)
    OFF_B = (2, 2)

    # try to place at least one A and one B block; try to place both anchored to same path cell if possible
    placed_A = False
    placed_B = False

    path_shuffled = path[:]  # copy
    random.shuffle(path_shuffled)
    anchored = False
    for (pr,pc) in path_shuffled:
        brA = pr + OFF_A[0]; bcA = pc + OFF_A[1]
        brB = pr + OFF_B[0]; bcB = pc + OFF_B[1]
        if can_place_block(brA, bcA, 5) and can_place_block(brB, bcB, 7):
            # place both blocks
            for dr in (0,1):
                for dc in (0,1):
                    grid[brA+dr][bcA+dc] = 5
                    grid[brB+dr][bcB+dc] = 7
            placed_A = True; placed_B = True
            anchored = True
            break

    # If not anchored, place A and B separately at random safe positions, ensuring at least one of each
    # collect all possible placements
    possible_positions = []
    for br in range(0, height-1):
        for bc in range(0, width-1):
            if can_place_block(br,bc,5):
                possible_positions.append((br,bc))
    random.shuffle(possible_positions)
    if not placed_A:
        if possible_positions:
            br,bc = possible_positions.pop()
            for dr in (0,1):
                for dc in (0,1):
                    grid[br+dr][bc+dc] = 5
            placed_A = True

    # For B choose similarly
    possible_positions_B = []
    for br in range(0, height-1):
        for bc in range(0, width-1):
            # ensure not overlapping with existing 5-blocks by checking zeros
            ok = True
            if br < 0 or bc < 0 or br+1 >= height or bc+1 >= width:
                ok = False
            if ok:
                for dr in (0,1):
                    for dc in (0,1):
                        if grid[br+dr][bc+dc] != 0:
                            ok = False
            if not ok:
                continue
            # ensure no adjacency to path
            isolated = True
            for rr in range(br-1, br+3):
                for cc in range(bc-1, bc+3):
                    if 0 <= rr < height and 0 <= cc < width and grid[rr][cc] == 3:
                        isolated = False
            if isolated:
                possible_positions_B.append((br,bc))
    random.shuffle(possible_positions_B)
    if not placed_B and possible_positions_B:
        br,bc = possible_positions_B.pop()
        for dr in (0,1):
            for dc in (0,1):
                grid[br+dr][bc+dc] = 7
        placed_B = True

    # Optionally add a few more sparse blocks of either type to increase variety
    extra_blocks = random.randint(0, 2)
    for _ in range(extra_blocks):
        # choose color randomly 5 or 7
        color = random.choice((5,7))
        # find a placement for it
        tried = 0
        all_positions = [(br,bc) for br in range(0, height-1) for bc in range(0, width-1)]
        random.shuffle(all_positions)
        for br,bc in all_positions:
            if all(grid[br+dr][bc+dc]==0 for dr in (0,1) for dc in (0,1)):
                # ensure no adjacency to path
                adjacent_path = False
                for rr in range(br-1, br+3):
                    for cc in range(bc-1, bc+3):
                        if 0<=rr<height and 0<=cc<width and grid[rr][cc]==3:
                            adjacent_path = True
                if adjacent_path:
                    continue
                # ensure not adjacent to other blocks
                # simply ensure the 2x2 area and its neighbors are zero (not 5 or 7)
                conflict=False
                for rr in range(br-1, br+3):
                    for cc in range(bc-1, bc+3):
                        if 0 <= rr < height and 0 <= cc < width and grid[rr][cc] in (5,7):
                            conflict=True
                if conflict:
                    continue
                for dr in (0,1):
                    for dc in (0,1):
                        grid[br+dr][bc+dc] = color
                break

    input_grid = [row[:] for row in grid]
    output_grid = [row[:] for row in grid]

    # Now recolor the path cells deterministically based on local geometry and pattern proximity
    def is_A_at(r,c):
        br = r + OFF_A[0]; bc = c + OFF_A[1]
        if br < 0 or bc < 0 or br+1 >= height or bc+1 >= width:
            return False
        for dr in (0,1):
            for dc in (0,1):
                if grid[br+dr][bc+dc] != 5: return False
        return True

    def is_B_at(r,c):
        br = r + OFF_B[0]; bc = c + OFF_B[1]
        if br < 0 or bc < 0 or br+1 >= height or bc+1 >= width:
            return False
        for dr in (0,1):
            for dc in (0,1):
                if grid[br+dr][bc+dc] != 7: return False
        return True

    for (r,c) in path:
        # find 4-neighbor path neighbors
        neighbors = []
        for dr,dc in ((1,0),(-1,0),(0,1),(0,-1)):
            nr, nc = r+dr, c+dc
            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 3:
                neighbors.append((nr,nc))
        # determine base color based on local geometry (straight horizontal/vertical or corner/endpoint)
        base = 4
        if len(neighbors) == 2:
            n0, n1 = neighbors[0], neighbors[1]
            if n0[0] == n1[0]:
                base = 4  # horizontal
            elif n0[1] == n1[1]:
                base = 6  # vertical
            else:
                base = 5  # corner (use 5 so base+3<=9)
        elif len(neighbors) == 1:
            n0 = neighbors[0]
            if n0[0] == r:
                base = 4
            else:
                base = 6
        else:
            base = 4

        hasA = is_A_at(r,c)
        hasB = is_B_at(r,c)
        new_color = base + (1 if hasA else 0) + (2 if hasB else 0)
        # ensure color stays in 0-9 (it will)
        new_color = new_color
        output_grid[r][c] = new_color

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    OFF_A = (-2, 2)
    OFF_B = (2, 2)

    path = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 3:
                path.append((r, c))

    output = [row[:] for row in grid]

    def has_block_at(br, bc, color):
        if br < 0 or bc < 0 or br+1 >= height or bc+1 >= width:
            return False
        for dr in (0,1):
            for dc in (0,1):
                if grid[br+dr][bc+dc] != color:
                    return False
        return True

    for (r, c) in path:
        neighbors = []
        for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):
            nr, nc = r+dr, c+dc
            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 3:
                neighbors.append((nr, nc))

        if len(neighbors) == 2:
            n0, n1 = neighbors[0], neighbors[1]
            if n0[0] == n1[0]:
                base = 4
            elif n0[1] == n1[1]:
                base = 6
            else:
                base = 5
        elif len(neighbors) == 1:
            n0 = neighbors[0]
            if n0[0] == r:
                base = 4
            else:
                base = 6
        else:
            base = 4

        hasA = has_block_at(r+OFF_A[0], c+OFF_A[1], 5)
        hasB = has_block_at(r+OFF_B[0], c+OFF_B[1], 7)
        new_color = base + (1 if hasA else 0) + (2 if hasB else 0)
        output[r][c] = new_color

    return output

