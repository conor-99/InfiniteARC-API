# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 15691142
Difficulty: mediumâ€“hard

=== Tags ===
- Heat map draw
- Directed field
- Assemble from parts

=== Description ===
Task Name: Directed Heat Flow Assembly  Input grids feature a background color
(0) and multiple distinct, connected regions of non-zero colors (heat sources,
1-9), each region being a contiguous group of cells. Scattered throughout the
grid are directional markers (colors 5-8), where each marker color corresponds
to a specific movement direction: 5 = right, 6 = up, 7 = left, 8 = down. Each
heat source region is orthogonally adjacent to exactly one directional marker,
with the marker located in a neighboring cell (e.g., a right marker directly to
the left of a heat source).  The output grid is generated by tracing the path of
each heat source as it moves through the grid, following the direction of each
directional marker encountered in sequence. Starting from the initial position
of a heat source, the path moves one cell in the direction indicated by the
adjacent marker, then continues moving in the direction of the marker in the new
cell, repeating this process until the path exits the grid. The directional
markers are removed from the output, and the background remains color 0. Each
cell along a heat source's path is colored with the original heat source's
color. Paths do not overlap, and all paths exit the grid within a finite number
of steps. The output visually represents the "heat map" of accumulated movement
paths, with the color intensity implied by the visual density of overlapping
paths (though no explicit sums are used), and the grid is assembled from the
constituent paths of each heat source.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from typing import List, Dict, Tuple, Set

# Generator for "Directed Heat Flow Assembly"

def generate() -> Dict[str, List[List[int]]]:
    # Direction marker mapping: value -> (dr, dc)
    DIRS = {5: (0, 1), 6: (-1, 0), 7: (0, -1), 8: (1, 0)}
    marker_values = set(DIRS.keys())
    heat_colors_pool = [1, 2, 3, 4, 9]

    # Try to build a valid puzzle; if failure, retry a limited number of times
    for global_try in range(200):
        width = random.randint(6, 20)
        height = random.randint(6, 20)
        grid_input = [[0 for _ in range(width)] for _ in range(height)]

        occupied: Set[Tuple[int, int]] = set()  # cells already used (regions or markers)
        occupied_regions: Set[Tuple[int, int]] = set()  # only region cells
        sources_info = []  # will store tuples: (color, region_cells_set, start_cell, chain_positions)

        num_sources = random.randint(3, 5)
        if num_sources > len(heat_colors_pool):
            num_sources = len(heat_colors_pool)
        colors = random.sample(heat_colors_pool, num_sources)

        failed = False
        for color in colors:
            placed = False
            # Try multiple attempts to place this region + chain
            for attempt in range(400):
                # Choose a candidate starting cell for the region (avoid touching border directly to give room)
                r = random.randint(1, height - 2)
                c = random.randint(1, width - 2)
                if (r, c) in occupied:
                    continue

                # build a small contiguous region
                region_size = random.randint(1, 4)
                region = {(r, c)}
                # expand the region randomly
                tries_expand = 0
                while len(region) < region_size and tries_expand < region_size * 4:
                    tries_expand += 1
                    base = random.choice(list(region))
                    nbrs = []
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = base[0] + dr, base[1] + dc
                        if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in occupied and (nr, nc) not in region:
                            nbrs.append((nr, nc))
                    if not nbrs:
                        break
                    region.add(random.choice(nbrs))

                # ensure region doesn't touch already-occupied cells (safety)
                if any(p in occupied for p in region):
                    continue

                # Now find candidate start cells within region that have an adjacent free cell to host the first marker
                candidates = []
                for cell in region:
                    r0, c0 = cell
                    for mval, (dr, dc) in DIRS.items():
                        p0 = (r0 + dr, c0 + dc)  # marker position
                        # marker must be inside grid and not occupied and not part of the region itself
                        if not (0 <= p0[0] < height and 0 <= p0[1] < width):
                            continue
                        if p0 in occupied or p0 in region:
                            continue
                        # ensure p0 is not adjacent to previously placed regions (would create extra adjacency)
                        adjacent_to_other_region = False
                        for ar, ac in [(p0[0] + 1, p0[1]), (p0[0] - 1, p0[1]), (p0[0], p0[1] + 1), (p0[0], p0[1] - 1)]:
                            if (ar, ac) in occupied_regions and (ar, ac) not in region:
                                adjacent_to_other_region = True
                                break
                        if adjacent_to_other_region:
                            continue

                        # Ensure none of the cells in this region are adjacent to any previously placed occupied cell
                        # except for the candidate marker p0 (we allow that one)
                        conflict_adj = False
                        for rc in region:
                            for ar, ac in [(rc[0] + 1, rc[1]), (rc[0] - 1, rc[1]), (rc[0], rc[1] + 1), (rc[0], rc[1] - 1)]:
                                if (ar, ac) in occupied and (ar, ac) != p0:
                                    conflict_adj = True
                                    break
                            if conflict_adj:
                                break
                        if conflict_adj:
                            continue

                        candidates.append((cell, mval, p0))

                random.shuffle(candidates)

                # Try candidate start cells and build a straight-line chain in the chosen direction until exit
                for start_cell, mval, p0 in candidates:
                    dr, dc = DIRS[mval]
                    # build positions of chain along the same direction until leaving grid
                    chain = []
                    pos = p0
                    valid = True
                    while 0 <= pos[0] < height and 0 <= pos[1] < width:
                        # must not overlap occupied cells or this region
                        if pos in occupied or pos in region:
                            valid = False
                            break
                        # For any chain cell except the first, we require it NOT be adjacent to this region
                        if pos != p0:
                            for ar, ac in [(pos[0] + 1, pos[1]), (pos[0] - 1, pos[1]), (pos[0], pos[1] + 1), (pos[0], pos[1] - 1)]:
                                if (ar, ac) in region:
                                    valid = False
                                    break
                            if not valid:
                                break
                        # also ensure chain is not adjacent to previously placed regions (to prevent creating extra adjacency)
                        for ar, ac in [(pos[0] + 1, pos[1]), (pos[0] - 1, pos[1]), (pos[0], pos[1] + 1), (pos[0], pos[1] - 1)]:
                            if (ar, ac) in occupied_regions and (ar, ac) not in region and (ar, ac) != start_cell:
                                # If it's adjacent to other regions it may create additional adjacency - disallow
                                valid = False
                                break
                        if not valid:
                            break
                        chain.append(pos)
                        pos = (pos[0] + dr, pos[1] + dc)

                    if not valid or len(chain) == 0:
                        continue

                    # Ensure that the first marker (p0) is adjacent to exactly one cell of this region (the chosen start_cell)
                    adj_count = 0
                    for ar, ac in [(p0[0] + 1, p0[1]), (p0[0] - 1, p0[1]), (p0[0], p0[1] + 1), (p0[0], p0[1] - 1)]:
                        if (ar, ac) in region:
                            adj_count += 1
                    if adj_count != 1:
                        continue

                    # All checks passed: place region cells and chain markers
                    for (rr, cc) in region:
                        grid_input[rr][cc] = color
                        occupied.add((rr, cc))
                        occupied_regions.add((rr, cc))

                    for (rr, cc) in chain:
                        grid_input[rr][cc] = mval
                        occupied.add((rr, cc))

                    sources_info.append((color, set(region), start_cell, chain))
                    placed = True
                    break

                if placed:
                    break

            if not placed:
                failed = True
                break

        if failed or len(sources_info) != len(colors):
            # Try a fresh layout
            continue

        # Build the output grid by tracing each source's movement
        grid_output = [[0 for _ in range(width)] for _ in range(height)]
        for color, region_set, start_cell, chain in sources_info:
            # paint the whole region
            for (rr, cc) in region_set:
                grid_output[rr][cc] = color

            # start walking: from the start cell, look at the adjacent marker (must be unique)
            cur = start_cell
            # Find the marker adjacent to cur
            marker_pos = None
            marker_val = None
            for dr, dc in [(0, 1), (-1, 0), (0, -1), (1, 0)]:
                nr, nc = cur[0] + dr, cur[1] + dc
                if 0 <= nr < height and 0 <= nc < width and grid_input[nr][nc] in marker_values:
                    marker_pos = (nr, nc)
                    marker_val = grid_input[nr][nc]
                    break
            if marker_pos is None:
                # should not happen; safety
                continue

            dr, dc = DIRS[marker_val]
            nxt = (cur[0] + dr, cur[1] + dc)
            # Walk following markers until we step out of the grid
            while 0 <= nxt[0] < height and 0 <= nxt[1] < width:
                grid_output[nxt[0]][nxt[1]] = color
                # If the input has a marker here, follow it; otherwise stop (generator ensures markers along chain)
                if grid_input[nxt[0]][nxt[1]] in marker_values:
                    mv = grid_input[nxt[0]][nxt[1]]
                    dr, dc = DIRS[mv]
                    cur = nxt
                    nxt = (cur[0] + dr, cur[1] + dc)
                else:
                    break

        # Final validation sanity checks (internal): ensure markers exist in input and are removed in output
        # and no marker color remains in output
        ok = True
        for r in range(height):
            for c in range(width):
                if grid_output[r][c] in marker_values:
                    ok = False
        if not ok:
            continue

        return {"input": grid_input, "output": grid_output}

    # As a fallback (shouldn't normally happen), return a trivial example hard-coded
    grid_input = [
        [0, 5, 0, 0, 0],
        [0, 1, 6, 0, 0],
        [0, 0, 0, 7, 0],
        [0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0]
    ]
    grid_output = [[0 for _ in range(5)] for _ in range(5)]
    grid_output[1][1] = 1
    grid_output[1][2] = 1
    grid_output[1][3] = 1
    return {"input": grid_input, "output": grid_output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from typing import List, Tuple


def p(input_grid: Tuple[Tuple[int, ...], ...]) -> List[List[int]]:
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # Directions mapping for markers
    DIRS = {5: (0, 1), 6: (-1, 0), 7: (0, -1), 8: (1, 0)}
    marker_values = set(DIRS.keys())

    # Prepare output grid with background zeros
    output = [[0 for _ in range(width)] for _ in range(height)]

    # Identify source colors (non-zero and not markers)
    source_colors = set()
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if v != 0 and v not in marker_values:
                source_colors.add(v)

    # For each source color, find its connected region cells and the start cell (the one adjacent to a marker)
    for color in source_colors:
        region_cells = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == color]
        # Paint entire region into output
        for (r, c) in region_cells:
            output[r][c] = color

        # Find the unique start cell in the region that has an adjacent marker
        start_cell = None
        for (r, c) in region_cells:
            adj_markers = 0
            for dr, dc in [(0, 1), (-1, 0), (0, -1), (1, 0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] in marker_values:
                    adj_markers += 1
            if adj_markers == 1:
                start_cell = (r, c)
                break
        # If not found, try to pick a cell that has at least one adjacent marker (robustness)
        if start_cell is None:
            for (r, c) in region_cells:
                for dr, dc in [(0, 1), (-1, 0), (0, -1), (1, 0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] in marker_values:
                        start_cell = (r, c)
                        break
                if start_cell is not None:
                    break

        if start_cell is None:
            # No adjacent marker found (shouldn't happen with valid generator), skip
            continue

        # From the start cell, find the adjacent marker (unique) and begin following the markers
        r0, c0 = start_cell
        marker_pos = None
        marker_val = None
        for dr, dc in [(0, 1), (-1, 0), (0, -1), (1, 0)]:
            nr, nc = r0 + dr, c0 + dc
            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] in marker_values:
                marker_pos = (nr, nc)
                marker_val = grid[nr][nc]
                break

        if marker_pos is None:
            continue

        # Move one step in the marker's direction and continue following markers until exit
        dr, dc = DIRS[marker_val]
        cur = (r0 + dr, c0 + dc)
        # Walk until we step out of bounds
        while 0 <= cur[0] < height and 0 <= cur[1] < width:
            # Color the path cell
            output[cur[0]][cur[1]] = color
            # If there's a marker in this cell, change direction accordingly
            val = grid[cur[0]][cur[1]]
            if val in marker_values:
                dr, dc = DIRS[val]
                cur = (cur[0] + dr, cur[1] + dc)
                continue
            # If no marker present here, we stop (generator ensures markers along the chain)
            break

    return output

