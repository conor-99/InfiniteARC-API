# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 09e0f4ee
Difficulty: insane

=== Tags ===
- State transfer chain
- Coordinate warp

=== Description ===
Input grids feature a large canvas (20×20 or larger) with a uniform background
color (0) and a single token positioned along the left edge (column 0) facing
right. The token is a 1×1 cell of a distinct color (C₀, 1–9), and the grid
contains multiple warp nodes—each a single cell of a unique color (1–9), with no
two nodes sharing the same color. Each warp node color corresponds to a fixed
displacement vector (e.g., color 1 always displaces (0, +2), color 2 always
displaces (+1, 0)), though this mapping is not explicitly given.   The token
moves cell-by-cell in its current direction (initially right) until it collides
with a warp node. Upon collision, the token’s color updates to the node’s color,
and it instantly warps to (current position + displacement vector of the node’s
color). The path from the previous position to the warp node is drawn in the
token’s color *before* collision. The token then moves in the direction of the
displacement vector (e.g., if displacement is (0, +2), direction remains right;
if (+1, 0), direction becomes down). This process repeats with the new color and
direction, drawing each segment in the color held *before* the next warp
collision, until the token exits the grid.   Output grids display the complete
path (color-coded by the token’s state during each segment), all warp nodes
preserved at their original positions, and the token’s starting position visible
as part of the path. The path never overlaps itself, warp nodes, or the token’s
starting cell, and no loops occur. The task requires tracking sequential color-
state transitions and coordinate displacements to reconstruct the path, with the
displacement vectors inferred solely from visual patterns across examples.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

displacement_map = {
    1: (0, 2),
    2: (1, 0),
    3: (0, -2),
    4: (-1, 0),
    5: (1, 1),
    6: (-1, 1),
    7: (1, -1),
    8: (-1, -1),
    9: (2, 0)
}

def generate():
    size = random.randint(20, 30)
    input_grid = grid(size, size)
    output_grid = [row[:] for row in input_grid]

    start_row = random.randint(5, size-6)
    token_color = random.randint(1, 9)
    input_grid[start_row][0] = token_color
    output_grid[start_row][0] = token_color

    warp_colors = [c for c in range(1, 10) if c != token_color]
    random.shuffle(warp_colors)
    num_warps = random.randint(1, 5)
    warp_sequence = warp_colors[:num_warps]

    current_pos = (start_row, 0)
    current_dir = (0, 1)
    current_color = token_color

    while True:
        next_pos = (current_pos[0] + current_dir[0], current_pos[1] + current_dir[1])
        if not (0 <= next_pos[0] < size and 0 <= next_pos[1] < size):
            break
        
        if next_pos == (start_row, 0):
            current_pos = next_pos
            current_dir = (0, 1)
            continue

        if input_grid[next_pos[0]][next_pos[1]] != 0 and input_grid[next_pos[0]][next_pos[1]] != token_color:
            # Draw path segment before warp
            p = (current_pos[0] + current_dir[0], current_pos[1] + current_dir[1])
            while p != next_pos:
                output_grid[p[0]][p[1]] = current_color
                p = (p[0] + current_dir[0], p[1] + current_dir[1])
            
            warp_color = input_grid[next_pos[0]][next_pos[1]]
            displacement = displacement_map[warp_color]
            current_color = warp_color
            new_pos = (next_pos[0] + displacement[0], next_pos[1] + displacement[1])
            
            dx, dy = displacement
            current_dir = (dx // abs(dx) if dx != 0 else 0, dy // abs(dy) if dy != 0 else 0)
            current_pos = new_pos
        else:
            # Draw the cell we're moving to (background cell)
            output_grid[next_pos[0]][next_pos[1]] = current_color
            current_pos = next_pos

    return {
        'input': input_grid,
        'output': output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

displacement_map = {
    1: (0, 2),
    2: (1, 0),
    3: (0, -2),
    4: (-1, 0),
    5: (1, 1),
    6: (-1, 1),
    7: (1, -1),
    8: (-1, -1),
    9: (2, 0)
}

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = [list(row) for row in input_grid]

    start_pos = None
    token_color = None
    for r in range(height):
        if input_grid[r][0] != 0:
            start_pos = (r, 0)
            token_color = input_grid[r][0]
            break
    if start_pos is None:
        return output_grid

    current_pos = start_pos
    current_dir = (0, 1)
    current_color = token_color

    while True:
        next_pos = (current_pos[0] + current_dir[0], current_pos[1] + current_dir[1])
        if not (0 <= next_pos[0] < height and 0 <= next_pos[1] < width):
            break
        
        if input_grid[next_pos[0]][next_pos[1]] != 0 and input_grid[next_pos[0]][next_pos[1]] != token_color:
            # Draw path segment before warp
            p = (current_pos[0] + current_dir[0], current_pos[1] + current_dir[1])
            while p != next_pos:
                output_grid[p[0]][p[1]] = current_color
                p = (p[0] + current_dir[0], p[1] + current_dir[1])
            
            warp_color = input_grid[next_pos[0]][next_pos[1]]
            displacement = displacement_map[warp_color]
            current_color = warp_color
            new_pos = (next_pos[0] + displacement[0], next_pos[1] + displacement[1])
            
            dx, dy = displacement
            current_dir = (dx // abs(dx) if dx != 0 else 0, dy // abs(dy) if dy != 0 else 0)
            current_pos = new_pos
        else:
            # Draw the cell we're moving to (background cell)
            output_grid[next_pos[0]][next_pos[1]] = current_color
            current_pos = next_pos

    return output_grid
