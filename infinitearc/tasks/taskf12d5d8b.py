# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: f12d5d8b
Difficulty: medium–hard

=== Tags ===
- Binary rule overlay
- Procedural painting
- Friction path
- Elastic reflection
- Order numbers

=== Description ===
The input grid features a background of color 0 with a starting path segment at
the top-left corner (color 7) moving eastward. Scattered throughout the grid are
friction cells (color 1: turn 90° left, color 2: turn 90° right), reflection
cells (color 3: reflect direction horizontally, color 4: reflect vertically),
and a vertical pattern strip on the left edge containing a sequence of order
numbers (colors 5–9, where 5=left turn, 6=right turn, 7=continue straight,
8=reverse direction, 9=turn 90°). The path moves step by step, and each time it
enters a friction or reflection cell, it applies the next order number in the
sequence (5, 6, 7, 8, 9, cycling as needed) to determine the direction change.
Elastic reflection occurs when the path hits grid boundaries (e.g., east-bound
movement hitting the right edge reverses to west-bound). The output grid is
generated through procedural painting: the path is drawn with colors matching
the entered cells (1–4), while the pattern strip (5–9) remains visible but does
not affect the path. All segments are drawn without overlapping, and the path
terminates when it exits the grid. The sequence of order numbers ensures
deterministic direction changes, with the output reflecting the cumulative
effect of friction, reflection, and ordered progression.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    size = random.randint(10, 30)
    grid = [[0] * size for _ in range(size)]
    grid[0][0] = 7
    for i in range(1, 6):
        if i < size:
            grid[i][0] = 5 + (i-1) % 5
    friction_col = random.randint(3, size - 2)
    friction_color = random.choice([1,2,3,4])
    grid[0][friction_col] = friction_color
    output = [row[:] for row in grid]
    direction = (0, 1)
    current = (0, 0)
    path = [current]
    order_idx = 0
    pattern_strip = [grid[i][0] for i in range(1, 6)]
    while True:
        next_r = current[0] + direction[0]
        next_c = current[1] + direction[1]
        if next_r < 0 or next_r >= size or next_c < 0 or next_c >= size:
            break
        current = (next_r, next_c)
        path.append(current)
        if grid[current[0]][current[1]] in [1,2,3,4]:
            order_num = pattern_strip[order_idx % len(pattern_strip)]
            order_idx += 1
            if order_num in [5,9]:
                direction = (-direction[1], direction[0])
            elif order_num == 6:
                direction = (direction[1], -direction[0])
            elif order_num == 8:
                direction = (-direction[0], -direction[1])
    for (r, c) in path:
        if grid[r][c] == 0:
            output[r][c] = 7
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    size = len(input_list)
    pattern_strip = []
    for i in range(1, 6):
        if i < size:
            pattern_strip.append(input_list[i][0])
    direction = (0, 1)
    current = (0, 0)
    path = [(0, 0)]
    order_idx = 0
    while True:
        next_r = current[0] + direction[0]
        next_c = current[1] + direction[1]
        if next_r < 0 or next_r >= size or next_c < 0 or next_c >= size:
            break
        current = (next_r, next_c)
        path.append(current)
        if input_list[current[0]][current[1]] in [1,2,3,4]:
            order_num = pattern_strip[order_idx % len(pattern_strip)]
            order_idx += 1
            if order_num in [5,9]:
                direction = (-direction[1], direction[0])
            elif order_num == 6:
                direction = (direction[1], -direction[0])
            elif order_num == 8:
                direction = (-direction[0], -direction[1])
    output = [row[:] for row in input_list]
    for (r, c) in path:
        if input_list[r][c] == 0:
            output[r][c] = 7
    return output
