# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: f10ebc14
Difficulty: medium–hard

=== Tags ===
- Momentum transfer
- Deterministic reflection
- Cascade fountain
- Role dependent behavior
- Find the odd shape out
- Pattern modification

=== Description ===
Input grids feature vertical columns of colored blocks (0-9), with background
color 0. Each column contains a topmost **source** block (color 2) initiating
downward momentum. Non-background blocks have **role-dependent behaviors** based
on color: **blue (1)** reflects momentum rightward, **green (3)** reflects
leftward, **purple (6)** triggers a new source (color 2) in the adjacent right
column (if background), and **yellow (4)** absorbs momentum without reflection.
Momentum propagates downward through background cells until encountering a non-
background block. Upon impact: blue/green blocks become purple (6) in the
output, purple blocks trigger a new source (if possible), and yellow blocks halt
momentum. The output grid reflects all momentum-induced transformations:
reflected blocks are recolored purple, and cascade-triggered sources are added
in valid rightward columns. The transformation applies only to initial sources
(no recursive cascades), with all changes deterministic. Grids must contain ≥2
columns to enable cascades, and background remains unchanged except where
modified by momentum rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(2, 30)
    height = random.randint(2, 30)
    grid = [[0] * width for _ in range(height)]
    for c in range(width):
        grid[0][c] = 2

    for r in range(1, height):
        for c in range(width):
            if random.random() < 0.2:
                grid[r][c] = random.choice([1, 3, 6])

    output = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 6:
                if c + 1 < width and output[r][c+1] == 0:
                    output[r][c+1] = 2
    for c in range(width):
        for r in range(1, height):
            if grid[r][c] != 0:
                if grid[r][c] in [1, 3]:
                    output[r][c] = 6
                break
    if grid == output:
        return generate()
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    grid = [list(row) for row in input_grid]
    output = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 6:
                if c + 1 < width and output[r][c+1] == 0:
                    output[r][c+1] = 2
    for c in range(width):
        for r in range(1, height):
            if grid[r][c] != 0:
                if grid[r][c] in [1, 3]:
                    output[r][c] = 6
                break
    return output
