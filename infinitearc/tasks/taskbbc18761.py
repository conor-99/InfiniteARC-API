# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: bbc18761
Difficulty: very hard

=== Tags ===
- Fluid spread
- Bounce marking
- Repaint border

=== Description ===
**Task Name**: Bouncing Fluid Path    **Tags**: Fluid spread, Bounce marking,
Repaint border    **Description**:    Input grids depict a large, maze-like cave
structure on a background (color 0), composed of irregular wall segments (non-
zero colors) forming interconnected corridors. A single source cell of a
distinct color (e.g., red) is positioned on the left edge within an open
background corridor, while a 2×2 "bounce indicator" block of a fixed color
(e.g., cyan) is embedded within a wall segment near the bottom-right. The cave
guarantees a continuous background path from the source to the grid's top or
right edge, with no dead ends.    The transformation simulates a fluid's
trajectory originating at the source, moving rightward through background cells
until colliding with a wall. Upon collision, the wall cell is repainted to the
bounce indicator's color (cyan), and the fluid's direction rotates 90° clockwise
(right → up → left → down → right). The fluid continues moving through
background cells in the new direction, repeating the collision and repainting
process at each wall encounter. This sequence persists until the fluid exits the
grid via the top or right edge.    The output grid retains all original elements
(source, indicator, unhit walls, background) unchanged, with only the wall cells
struck by the fluid path repainted to the bounce indicator's color. Background
cells traversed by the fluid remain unmodified, and no wall segments are
overwritten beyond the bounce marking. The task requires precise tracking of
direction changes and wall collisions across a complex, multi-bounce path, with
no ambiguity in corridor navigation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Choose grid size (reasonable for complex path but fast to generate)
    width = random.randint(12, 28)
    height = random.randint(12, 28)

    # Wall colors (avoid 2 and 4)
    wall_colors = [1, 3, 5, 6, 7, 8, 9]

    # Create a wall-filled grid (we will carve a background path)
    input_grid = [[random.choice(wall_colors) for _ in range(width)] for _ in range(height)]

    # Choose a source row on the left edge (away from corners)
    r_source = random.randint(3, max(3, height - 4))

    # We'll deterministically construct a 5-segment clockwise-turning path
    # so that collisions occur at each turn and the final exit is to the right.
    carved = set()
    carved.add((r_source, 0))

    # Choose parameters with safe margins. If any range is invalid, we'll fall back
    try:
        c1_min = 3
        c1_max = max(3, width - 6)
        if c1_min > c1_max:
            raise ValueError
        c1 = random.randint(c1_min, c1_max)

        r2_min = 1
        r2_max = max(1, r_source - 2)
        if r2_min > r2_max:
            raise ValueError
        r2 = random.randint(r2_min, r2_max)

        c3_min = 1
        c3_max = min(c1 - 2, width - 3)
        if c3_min > c3_max:
            raise ValueError
        c3 = random.randint(c3_min, c3_max)

        r4_min = max(r2 + 2, r_source + 1)
        r4_max = max(r4_min, height - 2)
        if r4_min > r4_max:
            raise ValueError
        r4 = random.randint(r4_min, r4_max)

        # Segment 0: move right from (r_source,0) to (r_source,c1)
        for c in range(1, c1 + 1):
            carved.add((r_source, c))

        # Segment 1: move up from (r_source-1,c1) to (r2,c1)
        for r in range(r_source - 1, r2 - 1, -1):
            carved.add((r, c1))

        # Segment 2: move left from (r2, c1-1) down to (r2, c3)
        for c in range(c1 - 1, c3 - 1, -1):
            carved.add((r2, c))

        # Segment 3: move down from (r2+1, c3) to (r4, c3)
        for r in range(r2 + 1, r4 + 1):
            carved.add((r, c3))

        # After segment3 we turn right into (r4, c3+1)
        carved.add((r4, c3 + 1))

        # Segment 4 (final): move right from (r4, c3+2) up to rightmost column (width-1)
        # ensuring the path will exit to the right (next step would be col==width)
        for c in range(c3 + 2, width):
            carved.add((r4, c))

    except Exception:
        # Fallback simple path: go right a bit, then up to top (guaranteed exit via top)
        carved = set()
        carved.add((r_source, 0))
        midc = min(3, width - 2)
        for c in range(1, midc + 1):
            carved.add((r_source, c))
        for r in range(r_source - 1, -1, -1):
            carved.add((r, midc))
        # This fallback will exit via top

    # Carve into the input grid (0 = background). The source stays color 2.
    for (r, c) in carved:
        if (r, c) == (r_source, 0):
            input_grid[r][c] = 2
        else:
            input_grid[r][c] = 0

    # Ensure source cell is explicitly 2
    input_grid[r_source][0] = 2

    # Place the 2x2 bounce indicator (color 4) in a wall area near the bottom-right
    placed = False
    for _ in range(300):
        r_ind = random.randint(max(0, height // 2), height - 2)
        c_ind = random.randint(max(0, width // 2), width - 2)
        positions = [(r_ind, c_ind), (r_ind, c_ind + 1), (r_ind + 1, c_ind), (r_ind + 1, c_ind + 1)]
        if any(p in carved for p in positions):
            continue
        for (rr, cc) in positions:
            input_grid[rr][cc] = 4
        placed = True
        break

    if not placed:
        # fallback scan for a suitable 2x2 location
        for r_ind in range(height - 2, -1, -1):
            for c_ind in range(width - 2, -1, -1):
                positions = [(r_ind, c_ind), (r_ind, c_ind + 1), (r_ind + 1, c_ind), (r_ind + 1, c_ind + 1)]
                if any(p in carved for p in positions):
                    continue
                for (rr, cc) in positions:
                    input_grid[rr][cc] = 4
                placed = True
                break
            if placed:
                break

    # Create the output grid by simulating the fluid path on the original input
    output_grid = [row[:] for row in input_grid]

    drs_list = [(0, 1), (-1, 0), (0, -1), (1, 0)]
    current = (r_source, 0)
    direction = 0  # start moving right

    # Use the original input_grid to decide where walls are (non-zero)
    while True:
        dr, dc = drs_list[direction]
        nr = current[0] + dr
        nc = current[1] + dc
        # exit if moving out of bounds
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        if input_grid[nr][nc] != 0:
            # repaint hit wall to cyan (4) in the output and rotate clockwise
            output_grid[nr][nc] = 4
            direction = (direction + 1) % 4
        else:
            current = (nr, nc)

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable lists
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])

    # Find the source (color 2) on the left edge
    source_r = None
    for r in range(height):
        if grid_in[r][0] == 2:
            source_r = r
            break
    if source_r is None:
        return tuple(tuple(row) for row in grid_in)

    # Output copy; use original grid_in to detect walls
    out = [row[:] for row in grid_in]
    drs = [(0, 1), (-1, 0), (0, -1), (1, 0)]

    current = (source_r, 0)
    direction = 0

    while True:
        dr, dc = drs[direction]
        nr = current[0] + dr
        nc = current[1] + dc
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        if grid_in[nr][nc] != 0:
            out[nr][nc] = 4
            direction = (direction + 1) % 4
        else:
            current = (nr, nc)

    return tuple(tuple(row) for row in out)

