# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 357e04a3
Difficulty: hard

=== Tags ===
- Order numbers
- Latent rule switching
- Hypothesis selection from ambiguity
- Measure distance from side

=== Description ===
The input grid is a 2D arrangement of colored cells (0-9), where the background
color (often 0) forms the base layer. Each grid contains exactly two distinct
colors that appear only once (unique colors), while all other colors appear at
least twice. The output grid transforms based on a latent rule determined by the
position of one of these unique colors.   The solver must first identify the two
unique colors. Then, for each cell in the input grid, the distance to the
nearest vertical edge (top or bottom) is measured based on the row position of
the *correct* unique color: if the unique color resides in the top half of the
grid (row < grid height/2), the distance to the top edge (row index) is used; if
in the bottom half (row â‰¥ grid height/2), the distance to the bottom edge (grid
height - 1 - row index) is used. The output color for each cell is derived by
taking this distance modulo 5, then adding 1 (resulting in values 1-5).   The
challenge lies in selecting the correct unique color to determine the distance
direction. The grid contains two unique colors, but only one is the valid
trigger for the rule. The solver must infer which trigger aligns with the output
pattern through hypothesis testing, as the other unique color would produce
inconsistent results. This requires resolving ambiguity between the two
candidates by examining how their positions correlate with the output
transformation. The rule is consistent across all examples: the correct unique
color's position dictates the edge from which distance is measured, and all
cells use this distance calculation uniformly.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    h = random.randint(5, 30)
    w = random.randint(5, 30)
    input_grid = [[0] * w for _ in range(h)]
    col1 = random.randint(1, 9)
    col2 = random.randint(1, 9)
    while col2 == col1:
        col2 = random.randint(1, 9)
    
    r1, c1 = random.randint(0, h-1), random.randint(0, w-1)
    r2, c2 = random.randint(0, h-1), random.randint(0, w-1)
    while (r2, c2) == (r1, c1):
        r2, c2 = random.randint(0, h-1), random.randint(0, w-1)
    
    positions = sorted([(r1, c1), (r2, c2)])
    (r_correct, c_correct) = positions[0]
    input_grid[r_correct][c_correct] = col1
    input_grid[positions[1][0]][positions[1][1]] = col2
    
    output_grid = [[0] * w for _ in range(h)]
    if r_correct < h / 2:
        for r in range(h):
            for c in range(w):
                output_grid[r][c] = (r % 5) + 1
    else:
        for r in range(h):
            for c in range(w):
                output_grid[r][c] = ((h - 1 - r) % 5) + 1
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    from collections import defaultdict
    color_count = defaultdict(int)
    for row in input_grid:
        for color in row:
            color_count[color] += 1
    
    unique_colors = [color for color, count in color_count.items() if count == 1]
    if len(unique_colors) < 2:
        unique_colors = sorted(color_count.keys())[:2]
    
    positions = []
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] in unique_colors:
                positions.append((r, c))
    
    positions.sort()
    r_correct, _ = positions[0]
    
    h = len(input_grid)
    w = len(input_grid[0])
    output_grid = [[0] * w for _ in range(h)]
    if r_correct < h / 2:
        for r in range(h):
            for c in range(w):
                output_grid[r][c] = (r % 5) + 1
    else:
        for r in range(h):
            for c in range(w):
                output_grid[r][c] = ((h - 1 - r) % 5) + 1
    
    return output_grid
