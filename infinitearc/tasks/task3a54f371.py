# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 3a54f371
Difficulty: hard

=== Tags ===
- Hierarchical agent routing
- Trail memory
- Dynamic environment
- Pattern juxtaposition

=== Description ===
Input grids are complex 2D arrangements featuring a background color (0),
distinct obstacle cells (color 6), and multiple mobile agents represented by
unique colors (1-5). Each agent occupies a single cell and has a priority
determined by its color (higher numbers = higher priority). The grid also
contains no predefined paths or boundaries beyond the initial obstacles.  The
transformation process involves simulating hierarchical agent movement through a
dynamic environment where each agent's path leaves a memory trail that affects
subsequent movement. Agents move in priority order (highest to lowest), with
each agent attempting to advance as far as possible in a deterministic sequence
of directions (North → East → South → West) while adhering to these rules: 1)
Agents cannot move into obstacle cells or trails left by higher-priority agents;
2) Agents cannot backtrack (e.g., if their last move was East, they cannot move
West next); 3) Movement stops when no valid directions remain. The output grid
retains all obstacles, displays the complete movement trails for each agent
(drawn in their original color), and shows the final positions of agents as the
endpoints of their trails. The trails form a visually distinct pattern that
results from the interplay of hierarchical routing, directional memory, and
evolving environmental constraints, with no overlap between trails or with
obstacles.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, all_pixels
def generate():
    for _ in range(100):
        width = random.randint(10, 30)
        height = random.randint(10, 30)
        input_grid = grid(width, height, 0)
        obstacle_count = random.randint(10, 20)
        pixels = all_pixels(width, height)
        obstacles = random.sample(pixels, obstacle_count)
        for r, c in obstacles:
            input_grid[r][c] = 6
        agent_colors = random.sample(range(1, 6), random.randint(1, 5))
        agents = []
        for color in agent_colors:
            while True:
                r = random.randint(0, height-1)
                c = random.randint(0, width-1)
                if input_grid[r][c] == 0:
                    input_grid[r][c] = color
                    agents.append((r, c, color))
                    break
        agents.sort(key=lambda x: x[2], reverse=True)
        output_grid = [row[:] for row in input_grid]
        directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        for r, c, color in agents:
            current_r, current_c = r, c
            for dr, dc in directions:
                while True:
                    nr = current_r + dr
                    nc = current_c + dc
                    if nr < 0 or nr >= height or nc < 0 or nc >= width:
                        break
                    if output_grid[nr][nc] != 0:
                        break
                    output_grid[nr][nc] = color
                    current_r, current_c = nr, nc
        if input_grid != output_grid:
            return {"input": input_grid, "output": output_grid}
    return generate()


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    height = len(input_list)
    width = len(input_list[0]) if height > 0 else 0
    agents = []
    for r in range(height):
        for c in range(width):
            if 1 <= input_list[r][c] <= 5:
                agents.append((r, c, input_list[r][c]))
    agents.sort(key=lambda x: x[2], reverse=True)
    output_grid = [row[:] for row in input_list]
    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]
    for r, c, color in agents:
        current_r, current_c = r, c
        for dr, dc in directions:
            while True:
                nr = current_r + dr
                nc = current_c + dc
                if nr < 0 or nr >= height or nc < 0 or nc >= width:
                    break
                if output_grid[nr][nc] != 0:
                    break
                output_grid[nr][nc] = color
                current_r, current_c = nr, nc
    return tuple(tuple(row) for row in output_grid)
