# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 2209f015
Difficulty: very hard

=== Tags ===
- Obstacles
- Duplicate row pattern
- Find the two identical shapes

=== Description ===
Input grids feature a background color (0) with multiple colored obstacles (non-
zero, non-background) and exactly two identical shapes. The identical shapes are
connected components of the same color, identical in size, structure, and
orientation (4-connected, same pixel arrangement relative to their top-left
corners), and distinct from all other obstacles. Obstacles are all other colored
regions that do not match the identical shapes.  The output grid is generated
through three sequential steps:   1. **Identify the two identical shapes** by
comparing all connected components of the same color. The shapes must have
identical dimensions and pixel positions relative to their top-left corners.
2. **Replace all obstacles within the minimal bounding rectangle** that contains
both shapes with the color of the identical shapes. This rectangle is defined by
the topmost and bottommost rows and leftmost and rightmost columns occupied by
either shape.   3. **Duplicate the row pattern** of the first shape's rows to
the corresponding rows of the second shape. Specifically, for each row in the
bounding rectangle that contains part of the second shape, replace obstacle
pixels with the shape's color to match the pattern of the corresponding row in
the first shape.    This transformation ensures the output grid visually aligns
the two shapes through obstacle removal and row-based pattern duplication, while
preserving all other grid elements outside the bounding rectangle. The task
requires recognizing the identical shapes amid complex obstacle patterns and
applying multi-step geometric reasoning to the row structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import continuous_creature

def generate():
    width, height = 15, 15
    grid = [[0]*width for _ in range(height)]
    
    C = 1
    shape = continuous_creature(5, 5, 5)
    shape_rows = [r for r, c in shape]
    shape_cols = [c for r, c in shape]
    min_shape_r, min_shape_c = min(shape_rows), min(shape_cols)
    shape_rel = [(r - min_shape_r, c - min_shape_c) for r, c in shape]
    
    x1 = random.randint(2, 5)
    y1 = random.randint(2, 5)
    for r, c in shape:
        grid[r + x1][c + y1] = C
    
    x2 = x1 + random.randint(5, 10)
    y2 = y1 + random.randint(5, 10)
    if x2 + max(shape_rows) >= height or y2 + max(shape_cols) >= width:
        x2 = height - max(shape_rows) - 1
        y2 = width - max(shape_cols) - 1
    for r, c in shape:
        grid[r + x2][c + y2] = C
    
    colors = list(range(2, 10))
    for color in colors:
        placed = False
        while not placed:
            r = random.randint(0, height-1)
            c = random.randint(0, width-1)
            if grid[r][c] == 0:
                grid[r][c] = color
                placed = True
    
    all_pixels = [(r + x1, c + y1) for r, c in shape] + [(r + x2, c + y2) for r, c in shape]
    all_rows = [r for r, c in all_pixels]
    all_cols = [c for r, c in all_pixels]
    min_r, max_r = min(all_rows), max(all_rows)
    min_c, max_c = min(all_cols), max(all_cols)
    
    output = [row[:] for row in grid]
    for r in range(min_r, max_r + 1):
        for c in range(min_c, max_c + 1):
            if output[r][c] != 0 and output[r][c] != C:
                output[r][c] = C
    
    comp1 = [(r + x1, c + y1) for r, c in shape]
    min_r1, min_c1 = min(r for r, c in comp1), min(c for r, c in comp1)
    rel_comp1 = set((r - min_r1, c - min_c1) for r, c in comp1)
    
    for r in range(min_r, max_r + 1):
        for c in range(min_c, max_c + 1):
            if output[r][c] == 0:
                rel_r = r - min_r1
                rel_c = c - min_c1
                if (rel_r, rel_c) in rel_comp1:
                    output[r][c] = C
    
    return {"input": [tuple(row) for row in grid], "output": [tuple(row) for row in output]}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    visited = [[False] * width for _ in range(height)]
    components = {}
    
    def dfs(r, c, color):
        stack = [(r, c)]
        comp = []
        while stack:
            r, c = stack.pop()
            if visited[r][c] or grid[r][c] != color:
                continue
            visited[r][c] = True
            comp.append((r, c))
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                    stack.append((nr, nc))
        return comp
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and grid[r][c] != 0:
                color = grid[r][c]
                comp = dfs(r, c, color)
                if color not in components:
                    components[color] = []
                components[color].append(comp)
    
    target_color = None
    comp1 = None
    comp2 = None
    for color, comps in components.items():
        if len(comps) == 2:
            comp_a, comp_b = comps
            min_r_a, min_c_a = min(r for r, c in comp_a), min(c for r, c in comp_a)
            min_r_b, min_c_b = min(r for r, c in comp_b), min(c for r, c in comp_b)
            rel_a = set((r - min_r_a, c - min_c_a) for r, c in comp_a)
            rel_b = set((r - min_r_b, c - min_c_b) for r, c in comp_b)
            if rel_a == rel_b:
                target_color = color
                comp1 = comp_a
                comp2 = comp_b
                break
    
    if target_color is None:
        return input_grid
    
    all_pixels = comp1 + comp2
    all_rows = [r for r, c in all_pixels]
    all_cols = [c for r, c in all_pixels]
    min_r, max_r = min(all_rows), max(all_rows)
    min_c, max_c = min(all_cols), max(all_cols)
    
    output = [row[:] for row in grid]
    for r in range(min_r, max_r + 1):
        for c in range(min_c, max_c + 1):
            if output[r][c] != 0 and output[r][c] != target_color:
                output[r][c] = target_color
    
    min_r1, min_c1 = min(r for r, c in comp1), min(c for r, c in comp1)
    rel_comp1 = set((r - min_r1, c - min_c1) for r, c in comp1)
    
    for r in range(min_r, max_r + 1):
        for c in range(min_c, max_c + 1):
            if output[r][c] == 0:
                rel_r = r - min_r1
                rel_c = c - min_c1
                if (rel_r, rel_c) in rel_comp1:
                    output[r][c] = target_color
    
    return [tuple(row) for row in output]
