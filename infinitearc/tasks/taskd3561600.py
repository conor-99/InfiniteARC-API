# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: d3561600
Difficulty: medium–hard

=== Tags ===
- Wavefront timing
- Stacked layer alignment
- Modular sequence
- Pattern to sequence mapping
- Pattern repetition

=== Description ===
Input grids consist of a single background color overlaid with multiple
horizontal rows, each containing a repeating color pattern of varying periods
(repetition lengths). The patterns are visually distinct and do not align
vertically in the input. Each row's pattern period is the smallest integer such
that the sequence repeats exactly across the row width. The output grid is
generated by shifting each row horizontally by an amount equal to (row index ×
row pattern period) modulo the grid width, moving the pattern to the right
(wrapping around as needed). This transformation aligns all repeating patterns
vertically so that the first occurrence of each pattern's cycle begins at the
same column across all rows. The alignment ensures that the visual repetition of
colors forms a coherent, vertically consistent structure in the output, with no
overlap or distortion of pattern elements. The task requires identifying the
period of each row's pattern, applying modular arithmetic to determine the
shift, and executing the horizontal shift to achieve vertical pattern
synchronization.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def minimal_period(seq):
    n = len(seq)
    if n == 0:
        return 0
    for d in range(1, n):
        ok = True
        for i in range(n):
            if seq[i] != seq[i % d]:
                ok = False
                break
        if ok:
            return d
    return n


def generate_base_pattern(p, colors):
    if p == 1:
        return [random.choice(colors)]
    # Try a number of random tries to find a non-periodic pattern of length p
    for _ in range(500):
        pattern = [random.choice(colors) for _ in range(p)]
        if minimal_period(pattern) == p:
            return pattern
    # Fallback deterministic attempt: cycle the palette and then tweak to break small periods
    pattern = [colors[i % len(colors)] for i in range(p)]
    for d in range(1, p):
        if all(pattern[i] == pattern[i % d] for i in range(p)):
            for c in colors:
                if c != pattern[(p - 1) % d]:
                    pattern[p - 1] = c
                    break
    return pattern


def rotate_right(row, s):
    if not row:
        return []
    s = s % len(row)
    if s == 0:
        return list(row)
    return row[-s:] + row[:-s]


def generate():
    # pick a composite width with at least one proper divisor d where d^2 does not divide the width
    composites = []
    for n in range(4, 31):
        proper_divs = [d for d in range(2, n) if n % d == 0]
        if not proper_divs:
            continue
        # require at least one divisor d with d^2 not dividing n to avoid degenerate squares like 4,9,25
        if any(n % (d * d) != 0 for d in proper_divs):
            composites.append(n)
    W = random.choice(composites)
    H = random.randint(2, min(12, 30))
    bg = random.randint(0, 9)
    allowed_colors = [c for c in range(0, 10) if c != bg]
    proper_divs = [d for d in range(2, W) if W % d == 0]
    # prefer divisors p where p^2 does not divide W so that shifting by cycles-per-row changes the row
    proper_divs_non_square = [d for d in proper_divs if W % (d * d) != 0]
    if proper_divs_non_square:
        nontrivial_choices = proper_divs_non_square
    else:
        nontrivial_choices = proper_divs
    # ensure at least one row (not the top row) has a nontrivial period so the output differs
    idx_nontrivial = random.randint(1, H - 1)

    input_grid = []
    output_grid = []
    for i in range(H):
        if i == idx_nontrivial and nontrivial_choices:
            p = random.choice(nontrivial_choices)
        else:
            choices = proper_divs[:]
            if random.random() < 0.2:
                choices.append(1)
            if random.random() < 0.1:
                choices.append(W)
            if not choices:
                choices = [W]
            p = random.choice(choices)
        if p == 1:
            color = random.choice(allowed_colors)
            row = [color] * W
            period = 1
        else:
            palette_size = min(len(allowed_colors), max(2, p))
            palette = random.sample(allowed_colors, palette_size)
            base = generate_base_pattern(p, palette)
            row = (base * (W // p))[:W]
            start_offset = random.randint(0, p - 1)
            row = rotate_right(row, start_offset)
            period = p
        input_grid.append(list(row))
        cycles = W // period if period > 0 else 0
        shift = (i * cycles) % W if W > 0 else 0
        output_grid.append(rotate_right(row, shift))

    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def find_minimal_period(row):
    n = len(row)
    if n == 0:
        return 0
    for d in range(1, n + 1):
        ok = True
        for i in range(n):
            if row[i] != row[i % d]:
                ok = False
                break
        if ok:
            return d
    return n


def p(input_grid):
    # Convert to list of lists in case input is a tuple of tuples
    grid = [list(r) for r in input_grid]
    if not grid:
        return []
    H = len(grid)
    W = len(grid[0])
    output = []
    for i, row in enumerate(grid):
        period = find_minimal_period(row)
        cycles = W // period if period > 0 else 0
        shift = (i * cycles) % W if W > 0 else 0
        if shift == 0:
            output.append(list(row))
        else:
            output.append(row[-shift:] + row[:-shift])
    return output
