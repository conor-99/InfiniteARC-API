# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 2ee1a5bb
Difficulty: insane

=== Tags ===
- Energy field diffusion
- Count touches

=== Description ===
Energy Field Convergence  Input grids are 20×20 or larger, featuring a single
background color (0) overlaid with two key elements: energy sources and fixed
walls. Energy sources appear as isolated cells of distinct colors (1-4), each
representing a unique energy field origin. Walls are solid 1-cell-thick barriers
of color 5, arranged in intricate maze-like patterns that create narrow passages
and dead ends, never forming enclosed rooms without exit paths. Sources are
positioned such that their diffusion paths interact with walls through
reflection, and no two sources are adjacent or within 3 cells of each other.
The output grid transforms the input by applying two sequential processes.
First, each energy source diffuses outward in all four orthogonal directions
(up, down, left, right), propagating through background cells until encountering
a wall (color 5) or grid boundary. Upon hitting a wall, the diffusion reflects
at a 90° angle (e.g., upward becomes rightward), continuing its path through
background cells. Second, for every background cell, the output color is
determined by counting how many distinct energy fields reach it via any path
(including reflected paths), with the count capped at 9 (e.g., a cell touched by
3 fields becomes color 3, 10 fields becomes color 9). Walls (color 5) and energy
sources (colors 1-4) remain visually unchanged in the output. The transformation
requires recognizing reflection patterns, tracing multi-path interactions, and
mapping touch counts to visual color indicators, with the most complex examples
demanding simultaneous analysis of 4+ energy fields navigating a wall maze with
15+ reflection points.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Maze-based wall generation to create 1-cell-thick barriers with passages and dead-ends.
    # Choose an odd size between 21 and 29 (inclusive) to allow classic maze carving.
    size = random.choice([21, 23, 25, 27, 29])

    # Initialize everything as wall color 5, passages will be 0.
    ingrid = [[5 for _ in range(size)] for _ in range(size)]

    # Carve a perfect maze using randomized DFS on odd coordinates.
    cell_rows = list(range(1, size, 2))
    cell_cols = list(range(1, size, 2))

    start_r = random.choice(cell_rows)
    start_c = random.choice(cell_cols)
    ingrid[start_r][start_c] = 0
    visited = {(start_r, start_c)}
    stack = [(start_r, start_c)]

    neighbors_dirs = [(-2, 0), (2, 0), (0, -2), (0, 2)]
    while stack:
        r, c = stack[-1]
        nbrs = []
        for dr, dc in neighbors_dirs:
            nr, nc = r + dr, c + dc
            if 1 <= nr < size - 1 and 1 <= nc < size - 1 and (nr, nc) not in visited:
                nbrs.append((nr, nc, dr, dc))
        if nbrs:
            nr, nc, dr, dc = random.choice(nbrs)
            # remove wall between
            wall_r, wall_c = r + dr // 2, c + dc // 2
            ingrid[wall_r][wall_c] = 0
            ingrid[nr][nc] = 0
            visited.add((nr, nc))
            stack.append((nr, nc))
        else:
            stack.pop()

    # Now pick 2-4 energy sources (distinct colors 1..4) placed on passage cells (0).
    passage_cells = [(r, c) for r in range(size) for c in range(size) if ingrid[r][c] == 0]

    # If passages are too few (unlikely), fallback to a slightly different size.
    if len(passage_cells) < 10:
        # Very small chance; fallback to a simple open grid with a few walls
        ingrid = grid(size, size, 0)
        # add a sparse border of walls
        for i in range(size):
            ingrid[0][i] = 5
            ingrid[size - 1][i] = 5
            ingrid[i][0] = 5
            ingrid[i][size - 1] = 5
        passage_cells = [(r, c) for r in range(size) for c in range(size) if ingrid[r][c] == 0]

    max_attempts = 500
    sources = []
    colors_available = [1, 2, 3, 4]
    num_sources = random.randint(2, 4)

    attempts = 0
    while len(sources) < num_sources and attempts < max_attempts:
        attempts += 1
        r, c = random.choice(passage_cells)
        # Do not place on the border cell to encourage reflections
        if r == 0 or c == 0 or r == size - 1 or c == size - 1:
            continue
        # avoid placing on existing source
        if any(r == sr and c == sc for (sr, sc, _) in sources):
            continue
        # ensure Manhattan distance > 3 to other sources
        too_close = False
        for (sr, sc, _) in sources:
            if abs(r - sr) + abs(c - sc) <= 3:
                too_close = True
                break
        if too_close:
            continue
        color = colors_available[len(sources)]
        ingrid[r][c] = color
        sources.append((r, c, color))

    # If we failed to place at least 2 sources, retry generation (should be rare)
    if len(sources) < 2:
        return generate()

    # Helper: simulate rays with 90-degree clockwise reflection on wall hits.
    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]  # up, right, down, left

    size_r = size
    count_grid = [[0] * size_r for _ in range(size_r)]

    for (sr, sc, color) in sources:
        reached = set()
        for d in range(4):
            r, c = sr, sc
            dir_idx = d
            visited_states = set()
            # Walk until we hit boundary or return to a visited state
            while True:
                state = (r, c, dir_idx)
                if state in visited_states:
                    break
                visited_states.add(state)
                nr = r + directions[dir_idx][0]
                nc = c + directions[dir_idx][1]
                # stop at grid boundary
                if not (0 <= nr < size_r and 0 <= nc < size_r):
                    break
                if ingrid[nr][nc] == 5:
                    # reflect 90 degrees clockwise
                    dir_idx = (dir_idx + 1) % 4
                    continue
                # move into next cell
                if ingrid[nr][nc] == 0:
                    reached.add((nr, nc))
                r, c = nr, nc
        for (r, c) in reached:
            count_grid[r][c] += 1

    output = [row[:] for row in ingrid]
    any_touched = False
    for r in range(size_r):
        for c in range(size_r):
            if ingrid[r][c] == 0:
                if count_grid[r][c] > 0:
                    any_touched = True
                output[r][c] = min(count_grid[r][c], 9)

    # Ensure at least one background cell changed; otherwise regenerate once.
    if not any_touched:
        return generate()

    return {"input": ingrid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    size = len(grid)

    # Find sources
    sources = []
    for r in range(size):
        for c in range(size):
            if grid[r][c] in (1, 2, 3, 4):
                sources.append((r, c, grid[r][c]))

    # directions: up, right, down, left
    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]

    count_grid = [[0] * size for _ in range(size)]

    for (sr, sc, color) in sources:
        reached = set()
        for d in range(4):
            r, c = sr, sc
            dir_idx = d
            visited_states = set()
            while True:
                state = (r, c, dir_idx)
                if state in visited_states:
                    break
                visited_states.add(state)
                nr = r + directions[dir_idx][0]
                nc = c + directions[dir_idx][1]
                if not (0 <= nr < size and 0 <= nc < size):
                    break
                if grid[nr][nc] == 5:
                    dir_idx = (dir_idx + 1) % 4
                    continue
                if grid[nr][nc] == 0:
                    reached.add((nr, nc))
                r, c = nr, nc
        for (r, c) in reached:
            count_grid[r][c] += 1

    output = [[0] * size for _ in range(size)]
    for r in range(size):
        for c in range(size):
            if grid[r][c] in (1, 2, 3, 4, 5):
                output[r][c] = grid[r][c]
            else:
                output[r][c] = min(count_grid[r][c], 9)

    return output

