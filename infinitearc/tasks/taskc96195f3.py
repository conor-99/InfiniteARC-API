# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: c96195f3
Difficulty: insane

=== Tags ===
- Pairwise analogy
- Background filling

=== Description ===
The input grid features multiple distinct foreground objects (connected regions
of non-zero colors), each occupying a unique area. The output grid preserves
these foreground objects while filling the background (originally empty cells)
with lines that connect the centroids of every pair of objects. Each line is
colored according to the source object's color (the object from which the line
originates), creating a network of colored lines across the background. The
centroid of each object is calculated as the average position of all its cells.
Background cells intersected by multiple lines are filled with the color of the
earliest pair in a predefined order (e.g., sorted by the x-coordinate of the
centroid). The transformation requires recognizing pairwise geometric
relationships between all objects and mapping these relationships into a
structured background pattern through visual analogy.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def compute_centroid(pixels):
    sum_r = sum(r for r, c in pixels)
    sum_c = sum(c for r, c in pixels)
    n = len(pixels)
    return (sum_r / n, sum_c / n)

def bresenham_line(start, end):
    x1, y1 = start
    x2, y2 = end
    dx = abs(x2 - x1)
    dy = abs(y2 - y1)
    sx = 1 if x1 < x2 else -1
    sy = 1 if y1 < y2 else -1
    err = dx - dy
    line = []
    while True:
        line.append((x1, y1))
        if x1 == x2 and y1 == y2:
            break
        e2 = 2 * err
        if e2 > -dy:
            err -= dy
            x1 += sx
        if e2 < dx:
            err += dx
            y1 += sy
    return line

def generate():
    width = 15
    height = 15
    input_grid = common.grid(width, height, 0)
    num_objects = random.randint(3, 5)
    colors = random.sample(range(1, 10), num_objects)
    objects = []
    for i in range(num_objects):
        sprite_pixels = common.rand_sprite('el', 3, 3)
        while True:
            x = random.randint(0, width - 4)
            y = random.randint(0, height - 4)
            placed_pixels = [(r + x, c + y) for r, c in sprite_pixels]
            placed_pixels = [(r, c) for r, c in placed_pixels if 0 <= r < height and 0 <= c < width]
            if all(input_grid[r][c] == 0 for r, c in placed_pixels):
                break
        objects.append((colors[i], placed_pixels))
        for r, c in placed_pixels:
            input_grid[r][c] = colors[i]
    centroids = []
    for color, pixels in objects:
        centroid = compute_centroid(pixels)
        centroids.append((color, centroid))
    centroids.sort(key=lambda x: (x[1][0], x[1][1]))
    all_pairs = []
    for i in range(len(centroids)):
        for j in range(i + 1, len(centroids)):
            all_pairs.append((i, j))
    all_pairs.sort(key=lambda pair: (centroids[pair[0]][1][0], centroids[pair[0]][1][1]))
    output_grid = [list(row) for row in input_grid]
    for i, j in all_pairs:
        color_i, centroid_i = centroids[i]
        color_j, centroid_j = centroids[j]
        x1, y1 = map(round, centroid_i)
        x2, y2 = map(round, centroid_j)
        line_cells = bresenham_line((x1, y1), (x2, y2))
        for r, c in line_cells:
            if 0 <= r < height and 0 <= c < width and output_grid[r][c] == 0:
                output_grid[r][c] = color_i
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
import random

def compute_centroid(pixels):
    sum_r = sum(r for r, c in pixels)
    sum_c = sum(c for r, c in pixels)
    n = len(pixels)
    return (sum_r / n, sum_c / n)

def bresenham_line(start, end):
    x1, y1 = start
    x2, y2 = end
    dx = abs(x2 - x1)
    dy = abs(y2 - y1)
    sx = 1 if x1 < x2 else -1
    sy = 1 if y1 < y2 else -1
    err = dx - dy
    line = []
    while True:
        line.append((x1, y1))
        if x1 == x2 and y1 == y2:
            break
        e2 = 2 * err
        if e2 > -dy:
            err -= dy
            x1 += sx
        if e2 < dx:
            err += dx
            y1 += sy
    return line

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    visited = set()
    components = {}
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] > 0 and (r, c) not in visited:
                color = input_grid[r][c]
                component = []
                queue = [(r, c)]
                visited.add((r, c))
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == color and (nr, nc) not in visited:
                            visited.add((nr, nc))
                            queue.append((nr, nc))
                components[color] = component
    centroids = []
    for color, pixels in components.items():
        centroid = compute_centroid(pixels)
        centroids.append((color, centroid))
    centroids.sort(key=lambda x: (x[1][0], x[1][1]))
    all_pairs = []
    for i in range(len(centroids)):
        for j in range(i + 1, len(centroids)):
            all_pairs.append((i, j))
    all_pairs.sort(key=lambda pair: (centroids[pair[0]][1][0], centroids[pair[0]][1][1]))
    output_grid = [list(row) for row in input_grid]
    for i, j in all_pairs:
        color_i, centroid_i = centroids[i]
        color_j, centroid_j = centroids[j]
        x1, y1 = map(round, centroid_i)
        x2, y2 = map(round, centroid_j)
        line_cells = bresenham_line((x1, y1), (x2, y2))
        for r, c in line_cells:
            if 0 <= r < height and 0 <= c < width and output_grid[r][c] == 0:
                output_grid[r][c] = color_i
    return output_grid
