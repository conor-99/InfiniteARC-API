# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 9cfcb9fa
Difficulty: hard

=== Tags ===
- Fluid spread
- Non rectangular tiling

=== Description ===
Input grids are large (20×20 or larger) with a single background color (0).
Overlaid are multiple non-rectangular tiles, each a connected region of a
distinct color (1-9), forming irregular shapes (e.g., L, T, cross, or fragmented
forms) that are not axis-aligned rectangles. Tiles are arranged in a connected
network where each tile shares at least one edge with another tile, and no two
tiles overlap. The top-leftmost tile (closest to the grid's top-left corner)
serves as the fluid source.   The fluid spreads from the source tile to adjacent
tiles (sharing an edge) in a clockwise spiral order, determined by the current
tile's position and the sequence of directions (right → down → left → up),
rotating clockwise after each tile. Each tile reached during the spread
(excluding the source) changes its color to the next in a fixed cyclic sequence
(1 → 2 → 3 → 4 → 1 → 2...), with the source tile retaining its original color.
The output grid preserves all original tile shapes, background, and relative
positions, with only the tile colors updated according to the spread order. The
spread continues until all tiles are visited, and the sequence cycles through
1-4 for each subsequent tile.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, continuous_creature


def generate():
    """
    Generate an ARC-like input/output pair according to the specification.
    Grid size between 20 and 25. Multiple non-rectangular connected tiles (4-5)
    are placed; the top-leftmost tile serves as the fluid source. Tiles are
    connected into a single adjacency network by construction. The output
    recolors every visited tile (except the source) according to a clockwise
    spiral traversal order (right→down→left→up) that rotates after each
    processed tile. Colors used for input tiles are chosen from 5..9 so that
    recoloring to 1..4 always produces a visible change.
    """
    # Helper to test rectangularity of a pixel set (pixels are (r,c))
    def is_rectangular_pixels(pixels):
        if not pixels:
            return True
        rows = [p[0] for p in pixels]
        cols = [p[1] for p in pixels]
        min_r, max_r = min(rows), max(rows)
        min_c, max_c = min(cols), max(cols)
        area = (max_r - min_r + 1) * (max_c - min_c + 1)
        return len(pixels) == area

    # Attempt generation; if layout fails constraints, retry quickly
    for attempt in range(100):
        width = random.randint(20, 25)
        height = random.randint(20, 25)
        bg = 0
        ingrid = [[bg for _ in range(width)] for _ in range(height)]

        # Number of tiles (keep modest so we can guarantee distinct colors >4)
        num_tiles = random.randint(4, 5)

        # Choose distinct input colors from 5..9 so recoloring to 1..4 always changes them
        available_colors = list(range(5, 10))
        if num_tiles > len(available_colors):
            # fallback (shouldn't happen with num_tiles <= 5)
            available_colors = list(range(1, 10))
        tile_colors = random.sample(available_colors, num_tiles)

        tiles = []        # list of sets of (r,c)
        occupied = set()  # occupied cells on grid

        # Create the source tile anchored at the top-left area to ensure it is top-leftmost
        size0 = random.randint(4, 8)
        # create a compact sprite and ensure it's not rectangular
        tries = 0
        sprite = continuous_creature(size0, 6, 6)
        while is_rectangular_pixels(sprite) and tries < 50:
            sprite = continuous_creature(size0, 6, 6)
            tries += 1

        # Anchor source at (0,0) so it will be the top-leftmost tile
        anchor_r0, anchor_c0 = 0, 0
        placed0 = set()
        valid_place = True
        for (r, c) in sprite:
            rr, cc = r + anchor_r0, c + anchor_c0
            if rr < 0 or rr >= height or cc < 0 or cc >= width:
                valid_place = False
                break
            placed0.add((rr, cc))
        if not valid_place:
            continue
        for (rr, cc) in placed0:
            ingrid[rr][cc] = tile_colors[0]
            occupied.add((rr, cc))
        tiles.append(placed0)

        # Place subsequent tiles, each attached to the growing connected network
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        success_all = True

        for t_idx in range(1, num_tiles):
            placed = False
            # Try many random placement attempts to find a valid non-overlapping attachment
            for _ in range(600):
                size = random.randint(4, 8)
                # random sprite box to make varied shapes
                sprite_w = random.randint(3, 8)
                sprite_h = random.randint(3, 8)
                sprite = continuous_creature(size, sprite_w, sprite_h)
                if is_rectangular_pixels(sprite):
                    continue

                # pick a base tile and a base pixel to attach to
                base_tile = random.choice(tiles)
                base_pixel = random.choice(list(base_tile))
                dr, dc = random.choice(directions)
                target = (base_pixel[0] + dr, base_pixel[1] + dc)
                # target must be inside and free
                if not (0 <= target[0] < height and 0 <= target[1] < width):
                    continue
                if target in occupied:
                    continue

                # pick a pixel from the sprite that will map to target
                p_s = random.choice(sprite)
                anchor_r = target[0] - p_s[0]
                anchor_c = target[1] - p_s[1]

                placed_coords = set()
                ok = True
                for (sr, sc) in sprite:
                    rr, cc = sr + anchor_r, sc + anchor_c
                    if rr < 0 or rr >= height or cc < 0 or cc >= width:
                        ok = False
                        break
                    if (rr, cc) in occupied:
                        ok = False
                        break
                    placed_coords.add((rr, cc))
                if not ok:
                    continue
                # ensure placed shape is non-rectangular
                if is_rectangular_pixels([(r - anchor_r, c - anchor_c) for (r, c) in placed_coords]):
                    continue

                # Accept placement
                color = tile_colors[t_idx]
                for (rr, cc) in placed_coords:
                    ingrid[rr][cc] = color
                    occupied.add((rr, cc))
                tiles.append(placed_coords)
                placed = True
                break

            if not placed:
                success_all = False
                break

        if not success_all:
            # Failed to place all tiles; retry whole generation
            continue

        # Build quick pixel->tile mapping and adjacency graph
        pixel_to_tile = {}
        for idx, tile in enumerate(tiles):
            for p in tile:
                pixel_to_tile[p] = idx

        adj = [set() for _ in range(len(tiles))]
        for idx, tile in enumerate(tiles):
            for (r, c) in tile:
                for (dr, dc) in directions:
                    n = (r + dr, c + dc)
                    if n in pixel_to_tile and pixel_to_tile[n] != idx:
                        adj[idx].add(pixel_to_tile[n])

        # Connectivity check
        seen = [False] * len(tiles)
        stack = [0]
        seen[0] = True
        while stack:
            u = stack.pop()
            for v in adj[u]:
                if not seen[v]:
                    seen[v] = True
                    stack.append(v)
        if not all(seen):
            # Not fully connected; regenerate
            continue

        # Determine the source tile as the tile containing the top-leftmost non-background cell
        min_cell = (height, width)
        source_idx = 0
        for idx, tile in enumerate(tiles):
            for (r, c) in tile:
                if (r, c) < min_cell:
                    min_cell = (r, c)
                    source_idx = idx

        # Compute spread order using BFS with rotating direction start per processed tile
        visited_tiles = [False] * len(tiles)
        queue = [source_idx]
        visited_tiles[source_idx] = True
        order = []
        dir_idx = 0
        while queue:
            cur = queue.pop(0)
            order.append(cur)
            # check neighbors in rotated clockwise order starting at dir_idx
            for dd in range(4):
                dr, dc = directions[(dir_idx + dd) % 4]
                # iterate pixels in a sorted deterministic order
                for (r, c) in sorted(tiles[cur]):
                    n = (r + dr, c + dc)
                    if n in pixel_to_tile:
                        nid = pixel_to_tile[n]
                        if not visited_tiles[nid]:
                            visited_tiles[nid] = True
                            queue.append(nid)
            dir_idx = (dir_idx + 1) % 4

        # Ensure we visited all tiles (should be true)
        if not all(visited_tiles):
            continue

        # Build the output grid by recoloring visited tiles (excluding source) according to sequence
        outgrid = [row[:] for row in ingrid]
        for i, tid in enumerate(order[1:], start=1):
            new_color = (i % 4) + 1
            for (r, c) in tiles[tid]:
                outgrid[r][c] = new_color

        # As a precaution ensure input != output
        if outgrid == ingrid:
            continue

        return {"input": ingrid, "output": outgrid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0
    bg = 0

    # Find connected tiles (4-connected components of non-background cells)
    visited = [[False] * width for _ in range(height)]
    tiles = []  # list of sets of (r,c)
    colors = []

    def dfs(r, c, color):
        stack = [(r, c)]
        comp = []
        while stack:
            rr, cc = stack.pop()
            if rr < 0 or rr >= height or cc < 0 or cc >= width:
                continue
            if visited[rr][cc]:
                continue
            if grid[rr][cc] == bg:
                continue
            if grid[rr][cc] != color:
                # different colored region (shouldn't happen for well-formed input)
                continue
            visited[rr][cc] = True
            comp.append((rr, cc))
            for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                stack.append((rr + dr, cc + dc))
        return comp

    for r in range(height):
        for c in range(width):
            if not visited[r][c] and grid[r][c] != bg:
                color = grid[r][c]
                comp = dfs(r, c, color)
                tiles.append(set(comp))
                colors.append(color)

    if not tiles:
        return grid

    # Map each pixel to its tile index for fast adjacency checks
    pixel_to_tile = {}
    for idx, tile in enumerate(tiles):
        for p in tile:
            pixel_to_tile[p] = idx

    # Determine source tile: the tile containing the top-leftmost non-background cell
    min_cell = (height, width)
    source_idx = 0
    for idx, tile in enumerate(tiles):
        for (r, c) in tile:
            if (r, c) < min_cell:
                min_cell = (r, c)
                source_idx = idx

    # BFS traversal with rotating starting direction per processed tile
    from collections import deque
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up

    visited_tiles = [False] * len(tiles)
    q = deque()
    q.append(source_idx)
    visited_tiles[source_idx] = True
    order = []
    dir_idx = 0

    while q:
        cur = q.popleft()
        order.append(cur)
        # explore neighbors in rotated clockwise order starting at dir_idx
        for dd in range(4):
            dr, dc = directions[(dir_idx + dd) % 4]
            # iterate pixels in deterministic order
            for (r, c) in sorted(tiles[cur]):
                nbr = (r + dr, c + dc)
                if nbr in pixel_to_tile:
                    nid = pixel_to_tile[nbr]
                    if not visited_tiles[nid]:
                        visited_tiles[nid] = True
                        q.append(nid)
        dir_idx = (dir_idx + 1) % 4

    # Recolor visited tiles (excluding source) according to the cyclic sequence
    out = [row[:] for row in grid]
    for i, tid in enumerate(order[1:], start=1):
        new_color = (i % 4) + 1
        for (r, c) in tiles[tid]:
            out[r][c] = new_color

    return out

