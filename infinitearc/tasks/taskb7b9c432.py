# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: b7b9c432
Difficulty: very hard

=== Tags ===
- Deterministic update
- Interleaved streams
- Progressive rule shift

=== Description ===
# Interleaved Stream Progression  Input grids feature a uniform background color
(0), overlaid with multiple non-overlapping horizontal and vertical "streams" of
contiguous cells. Each stream consists of three or more cells in a single row
(horizontal) or column (vertical), all sharing a unique non-background color
(1-9). Streams are strictly separated by at least one background cell in all
directions, ensuring no adjacency or overlap. Horizontal streams are sorted from
top to bottom (with leftmost streams prioritized in tied rows), and vertical
streams are sorted from left to right (with topmost streams prioritized in tied
columns).  The transformation processes streams in an interleaved sequence:
starting with the topmost horizontal stream, followed by the leftmost vertical
stream, then the next topmost horizontal stream, and so on. For each stream in
this order, the colors undergo a deterministic cyclic shift based on the
stream's position in the sequence: streams at even indices (0-based) shift right
for horizontal streams or down for vertical streams, while streams at odd
indices shift left for horizontal streams or up for vertical streams. Each shift
is a full rotation of the stream's color sequenceâ€”e.g., a horizontal stream [A,
B, C] shifted right becomes [C, A, B].  The output grid preserves all background
cells and unchanged elements, with only the stream color sequences modified
according to their specific shift direction. No streams overlap or interact
during transformation, and the progressive rule shift (alternating direction per
stream) creates a complex, multi-layered pattern that requires sequential
reasoning to decode. The task demands precise identification of stream order,
correct application of directional shifts, and recognition of the cyclical
nature of the transformation without visual aids like arrows or markers.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    """
    Generate an ARC-style input/output pair with interleaved horizontal and vertical streams.

    Streams are contiguous non-zero segments (length >= 3) placed so that they do
    not touch each other (there is at least one background cell in every direction
    between streams). Each stream has a sequence of colors (1-9). Streams are
    sorted (horizontals by row, then leftmost; verticals by column, then topmost)
    and then interleaved: H0, V0, H1, V1, ... For each stream at index i in the
    interleaved sequence, if i is even the stream is rotated right (horizontal)
    or down (vertical), otherwise rotated left (horizontal) or up (vertical).
    """

    # size
    width = random.randint(10, 20)
    height = random.randint(10, 20)

    input_grid = grid(width, height, 0)
    output_grid = [row[:] for row in input_grid]

    # occupancy map to ensure 1-cell padding (including diagonals) between streams
    occupancy = [[False for _ in range(width)] for _ in range(height)]

    horizontal_streams = []  # (row, start_col, length)
    vertical_streams = []    # (col, start_row, length)

    num_h = random.randint(2, 4)
    num_v = random.randint(2, 4)

    # Place horizontal streams
    for _ in range(num_h):
        placed = False
        attempts = 0
        while not placed and attempts < 300:
            attempts += 1
            # length must allow 1-cell padding on both sides: choose up to width-3
            max_len = min(6, max(3, width - 3))
            length = random.randint(3, max_len)
            # choose a row with one-cell padding above and below
            r = random.randint(1, height - 2)
            # start must allow one padding cell at left and right
            start_max = width - length - 1
            if start_max < 1:
                continue
            start = random.randint(1, start_max)

            # check padding area (r-1..r+1) x (start-1..start+length)
            ok = True
            for rr in range(r - 1, r + 2):
                for cc in range(start - 1, start + length + 1):
                    if occupancy[rr][cc]:
                        ok = False
                        break
                if not ok:
                    break
            if not ok:
                continue

            # generate a color sequence; avoid the trivial all-equal case
            colors = [random.randint(1, 9) for _ in range(length)]
            if all(c == colors[0] for c in colors):
                idx = random.randrange(length)
                colors[idx] = (colors[idx] % 9) + 1

            # place on input grid
            for i, col in enumerate(colors):
                input_grid[r][start + i] = col

            # mark occupancy including padding
            for rr in range(r - 1, r + 2):
                for cc in range(start - 1, start + length + 1):
                    occupancy[rr][cc] = True

            horizontal_streams.append((r, start, length))
            placed = True
        # if not placed after many attempts we just continue; grid sizes make this unlikely

    # Place vertical streams
    for _ in range(num_v):
        placed = False
        attempts = 0
        while not placed and attempts < 300:
            attempts += 1
            max_len = min(6, max(3, height - 3))
            length = random.randint(3, max_len)
            c = random.randint(1, width - 2)
            start_max = height - length - 1
            if start_max < 1:
                continue
            start = random.randint(1, start_max)

            # check padding area (start-1..start+length) x (c-1..c+1)
            ok = True
            for rr in range(start - 1, start + length + 1):
                for cc in range(c - 1, c + 2):
                    if occupancy[rr][cc]:
                        ok = False
                        break
                if not ok:
                    break
            if not ok:
                continue

            colors = [random.randint(1, 9) for _ in range(length)]
            if all(col == colors[0] for col in colors):
                idx = random.randrange(length)
                colors[idx] = (colors[idx] % 9) + 1

            for i, col in enumerate(colors):
                input_grid[start + i][c] = col

            for rr in range(start - 1, start + length + 1):
                for cc in range(c - 1, c + 2):
                    occupancy[rr][cc] = True

            vertical_streams.append((c, start, length))
            placed = True

    # sort streams in the canonical order required by the task
    horizontal_streams.sort(key=lambda x: (x[0], x[1]))  # top-to-bottom, then leftmost
    vertical_streams.sort(key=lambda x: (x[0], x[1]))    # left-to-right (col), then topmost

    # interleave: H0, V0, H1, V1, ...
    streams = []
    for i in range(max(len(horizontal_streams), len(vertical_streams))):
        if i < len(horizontal_streams):
            streams.append(('h', horizontal_streams[i]))
        if i < len(vertical_streams):
            streams.append(('v', vertical_streams[i]))

    def rot_right(lst):
        return [lst[-1]] + lst[:-1]

    def rot_left(lst):
        return lst[1:] + [lst[0]]

    # apply cyclic shifts to build the output grid
    for idx, (stype, st) in enumerate(streams):
        if stype == 'h':
            r, start, length = st
            colors = [input_grid[r][start + i] for i in range(length)]
            shifted = rot_right(colors) if idx % 2 == 0 else rot_left(colors)
            for i, val in enumerate(shifted):
                output_grid[r][start + i] = val
        else:
            c, start, length = st
            colors = [input_grid[start + i][c] for i in range(length)]
            shifted = rot_right(colors) if idx % 2 == 0 else rot_left(colors)
            for i, val in enumerate(shifted):
                output_grid[start + i][c] = val

    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to a mutable list-of-lists
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0]) if height > 0 else 0

    # Find horizontal streams: contiguous non-zero runs of length >= 3 in rows
    horizontal_streams = []  # (row, start_col, length)
    for r in range(height):
        c = 0
        while c < width:
            if grid_in[r][c] != 0:
                start = c
                c += 1
                while c < width and grid_in[r][c] != 0:
                    c += 1
                length = c - start
                if length >= 3:
                    horizontal_streams.append((r, start, length))
            else:
                c += 1

    # Find vertical streams: contiguous non-zero runs of length >= 3 in columns
    vertical_streams = []  # (col, start_row, length)
    for c in range(width):
        r = 0
        while r < height:
            if grid_in[r][c] != 0:
                start = r
                r += 1
                while r < height and grid_in[r][c] != 0:
                    r += 1
                length = r - start
                if length >= 3:
                    vertical_streams.append((c, start, length))
            else:
                r += 1

    # Sort streams in the canonical order
    horizontal_streams.sort(key=lambda x: (x[0], x[1]))
    vertical_streams.sort(key=lambda x: (x[0], x[1]))

    # Interleave: H0, V0, H1, V1, ...
    streams = []
    for i in range(max(len(horizontal_streams), len(vertical_streams))):
        if i < len(horizontal_streams):
            streams.append(('h', horizontal_streams[i]))
        if i < len(vertical_streams):
            streams.append(('v', vertical_streams[i]))

    # Prepare output as a copy and apply rotations
    output = [row[:] for row in grid_in]

    def rot_right(lst):
        return [lst[-1]] + lst[:-1]

    def rot_left(lst):
        return lst[1:] + [lst[0]]

    for idx, (stype, st) in enumerate(streams):
        if stype == 'h':
            r, start, length = st
            colors = [grid_in[r][start + i] for i in range(length)]
            shifted = rot_right(colors) if idx % 2 == 0 else rot_left(colors)
            for i, val in enumerate(shifted):
                output[r][start + i] = val
        else:
            c, start, length = st
            colors = [grid_in[start + i][c] for i in range(length)]
            shifted = rot_right(colors) if idx % 2 == 0 else rot_left(colors)
            for i, val in enumerate(shifted):
                output[start + i][c] = val

    return output
