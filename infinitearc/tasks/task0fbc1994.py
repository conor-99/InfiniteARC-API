# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 0fbc1994
Difficulty: very hard

=== Tags ===
- Beam reflection
- Multi step traversal

=== Description ===
Input grids are 20Ã—20 with a background color (value 0) and contain multiple
wall segments (single-cell-thick horizontal or vertical lines) of distinct
colors (values 1-9), positioned such that no walls touch each other or other
grid elements. Lasers are L-shaped clusters of three connected cells (forming a
right angle) of a single color, oriented to face one of four diagonal
directions; the uncolored corner cell (background) at the L's inner vertex is
the beam's origin. The grid is designed to ensure all laser beams will traverse
multiple reflections before exiting, with no beam paths intersecting.  The
output grid retains all walls and lasers unchanged. Each laser emits a diagonal
beam from its origin, traveling in the L's facing direction. Upon hitting a
wall, the beam reflects according to standard mirror physics (vertical walls
reverse horizontal direction, horizontal walls reverse vertical direction),
changes its color to match the wall it struck, and continues its path. Each
segment of the beam's path is drawn as a diagonal line of the current color,
never overwriting walls, lasers, or other beams. The beam's color updates
immediately upon reflection and persists for all subsequent segments until the
next wall interaction. All beams exit the grid within a finite number of
reflections, with the output showing the complete path sequence for each beam,
including all color transitions at reflection points. The challenge requires
simultaneously tracking multiple reflection paths, predicting direction changes
based on wall orientation, and correctly mapping color transitions at each
reflection point across a complex, multi-layered grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    width, height = 20, 20
    grid = [[0] * width for _ in range(height)]
    
    # Place walls (horizontal/vertical segments of length 2-3)
    for _ in range(random.randint(5, 10)):
        if random.choice([True, False]):
            # Horizontal wall
            row = random.randint(0, height - 1)
            start_col = random.randint(0, width - 3)
            length = random.randint(2, 3)
            color = random.randint(1, 9)
            for col in range(start_col, start_col + length):
                grid[row][col] = color
        else:
            # Vertical wall
            col = random.randint(0, width - 1)
            start_row = random.randint(0, height - 3)
            length = random.randint(2, 3)
            color = random.randint(1, 9)
            for row in range(start_row, start_row + length):
                grid[row][col] = color
    
    # Place lasers (L-shapes with origin background)
    for _ in range(random.randint(3, 5)):
        origin = None
        while origin is None:
            r = random.randint(1, height - 2)
            c = random.randint(1, width - 2)
            if grid[r][c] != 0:
                continue
            # Check L formation (top-left corner)
            if grid[r-1][c-1] == 0 and grid[r-1][c] == 0 and grid[r][c-1] == 0:
                origin = (r, c)
        color = random.randint(1, 9)
        grid[r-1][c-1] = color
        grid[r-1][c] = color
        grid[r][c-1] = color
    
    # Create output grid with beam paths
    output = [row[:] for row in grid]
    for r in range(1, height - 1):
        for c in range(1, width - 1):
            if grid[r][c] == 0:  # Potential origin
                color = grid[r-1][c-1]
                if color != 0 and grid[r-1][c] == color and grid[r][c-1] == color:
                    # Laser detected
                    dx, dy = 1, 1  # Southeast direction
                    cr, cc = r + 1, c + 1
                    current_color = color
                    steps = 0
                    while 0 <= cr < height and 0 <= cc < width and steps < 1000:
                        output[cr][cc] = current_color
                        nr, nc = cr + dx, cc + dy
                        if not (0 <= nr < height and 0 <= nc < width):
                            break
                        if grid[nr][nc] != 0:  # Hit wall
                            wall_color = grid[nr][nc]
                            # Determine wall orientation
                            is_horizontal = (nc > 0 and grid[nr][nc-1] != 0 and nc < width-1 and grid[nr][nc+1] != 0)
                            is_vertical = (nr > 0 and grid[nr-1][nc] != 0 and nr < height-1 and grid[nr+1][nc] != 0)
                            if is_horizontal:
                                dy = -dy
                            elif is_vertical:
                                dx = -dx
                            current_color = wall_color
                        else:
                            cr, cc = nr, nc
                        steps += 1
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    output = [row[:] for row in grid]
    
    for r in range(1, height - 1):
        for c in range(1, width - 1):
            if grid[r][c] == 0:  # Origin candidate
                color_val = grid[r-1][c-1]
                if color_val != 0 and grid[r-1][c] == color_val and grid[r][c-1] == color_val:
                    dx, dy = 1, 1  # Southeast direction
                    cr, cc = r + 1, c + 1
                    current_color = color_val
                    steps = 0
                    while 0 <= cr < height and 0 <= cc < width and steps < 1000:
                        output[cr][cc] = current_color
                        nr, nc = cr + dx, cc + dy
                        if not (0 <= nr < height and 0 <= nc < width):
                            break
                        if grid[nr][nc] != 0:  # Wall hit
                            wall_color = grid[nr][nc]
                            is_horizontal = (nc > 0 and grid[nr][nc-1] != 0 and nc < width-1 and grid[nr][nc+1] != 0)
                            is_vertical = (nr > 0 and grid[nr-1][nc] != 0 and nr < height-1 and grid[nr+1][nc] != 0)
                            if is_horizontal:
                                dy = -dy
                            elif is_vertical:
                                dx = -dx
                            current_color = wall_color
                        else:
                            cr, cc = nr, nc
                        steps += 1
    return output
