# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 96a794e9
Difficulty: hard

=== Tags ===
- Extrapolate image from grid
- Out of boundary

=== Description ===
The task involves input grids containing multiple connected regions of colors,
each representing a distinct visual object. The output grid is generated by
extending each region that touches the grid's boundary outward by one cell in
the direction of the boundary. Regions touching the top edge are extended
upward, right edge to the right, bottom edge downward, and left edge to the
left. The output grid size increases to accommodate these extensions, with new
cells filled using the color of the extending region. This requires the solver
to identify connected components (via 4-connectivity), determine which
boundaries each component touches, and apply directional extensions while
preserving all existing visual patterns. The complexity arises from handling
multiple overlapping extensions, ensuring directional accuracy, and maintaining
consistency across all regions without relying on numerical properties or pixel-
by-pixel matching.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    w = random.randint(1, 28)
    h = random.randint(1, 28)
    input_grid = [[random.randint(0, 9) for _ in range(w)] for _ in range(h)]
    output_grid = [[0] * (w + 2) for _ in range(h + 2)]
    for c in range(1, w + 1):
        output_grid[0][c] = input_grid[0][c - 1]
        output_grid[h + 1][c] = input_grid[h - 1][c - 1]
    for r in range(1, h + 1):
        output_grid[r][0] = input_grid[r - 1][0]
        output_grid[r][w + 1] = input_grid[r - 1][w - 1]
    for r in range(1, h + 1):
        for c in range(1, w + 1):
            output_grid[r][c] = input_grid[r - 1][c - 1]
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    h = len(input_grid)
    w = len(input_grid[0])
    output_grid = [[0] * (w + 2) for _ in range(h + 2)]
    for c in range(1, w + 1):
        output_grid[0][c] = input_grid[0][c - 1]
        output_grid[h + 1][c] = input_grid[h - 1][c - 1]
    for r in range(1, h + 1):
        output_grid[r][0] = input_grid[r - 1][0]
        output_grid[r][w + 1] = input_grid[r - 1][w - 1]
    for r in range(1, h + 1):
        for c in range(1, w + 1):
            output_grid[r][c] = input_grid[r - 1][c - 1]
    return output_grid
