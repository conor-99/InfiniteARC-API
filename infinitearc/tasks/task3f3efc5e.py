# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 3f3efc5e
Difficulty: hard

=== Tags ===
- Pattern mirroring chain
- Path merging
- Connect components by property
- Shape to color encoding
- Image expasion

=== Description ===
Input grids feature multiple disconnected geometric shapes (e.g., squares,
triangles, L-forms) scattered across a background of color 0. Each shape is
rendered in a distinct color that encodes its transformation property: red
shapes mirror horizontally, blue shapes mirror vertically, yellow shapes mirror
diagonally. Background cells remain color 0, and shapes never touch or overlap.
The output grid is generated through five sequential transformations:  1.
**Pattern Mirroring Chain**: Starting from the top-leftmost shape, apply a
repeating sequence of mirror operations (horizontal → vertical → diagonal →
horizontal...) to create a chain of mirrored shapes. Each mirror operation
replicates the shape in the specified direction, expanding outward while
maintaining identical coloring and avoiding overlaps with existing components.
2. **Path Merging**: Identify all orthogonal paths connecting shapes of the same
color. Where two paths intersect, merge them into a single path using the color
of the path that appears earliest in the grid (top-left to bottom-right scanning
order). Merged paths must not intersect walls or background.  3. **Connect
Components by Property**: Group shapes sharing identical geometric properties
(e.g., all squares, all triangles) and connect them with straight-line paths.
The connecting path uses the dominant color of the group, drawn orthogonally
between components with no gaps.  4. **Shape to Color Encoding**: Replace all
shapes with their canonical color: squares become red, triangles become green,
L-forms become blue. This overrides input colors for all shapes, preserving only
the geometric form.  5. **Image Expansion**: Double the grid width by mirroring
the entire transformed grid along its vertical midline. The right half is a
perfect mirror of the left half, preserving all colors, connections, and
mirrored patterns without gaps or misalignments.  The output grid must maintain
visual coherence, with no overlapping paths, invalid color mappings, or broken
connections. All transformations must be applied strictly in sequence, and the
expanded grid must reflect the full chain of mirrored patterns and merged paths.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid as make_grid

def generate():
    # We must ensure final expanded width <= 30, so base width <= 15. Use conservative range.
    attempts = 0
    while True:
        attempts += 1
        W = random.randint(6, 14)
        H = random.randint(6, 18)
        # Create spaced placement grid so paths can be drawn without crossing shapes.
        offset_r = random.randint(0, 2)
        offset_c = random.randint(0, 2)
        r_positions = [r for r in range(offset_r, H - 1, 3) if r + 1 < H]
        c_positions = [c for c in range(offset_c, W - 1, 3) if c + 1 < W]
        potential_positions = [(r, c) for r in r_positions for c in c_positions]
        if len(potential_positions) >= 3 or attempts > 60:
            break
    # Templates for shapes (fixed orientation)
    templates = {
        'square': [(0, 0), (0, 1), (1, 0), (1, 1)],
        'triangle': [(0, 0), (1, 0), (1, 1)],
        'L': [(0, 0), (0, 1), (1, 0)]
    }
    mirror_colors = [4, 5, 6]  # 4=horizontal(red),5=vertical(blue),6=diagonal(yellow)

    # Create empty input grid
    inp = [[0 for _ in range(W)] for _ in range(H)]

    # Place shapes on spaced positions
    random.shuffle(potential_positions)
    max_shapes = min(5, len(potential_positions))
    n_shapes = random.randint(3, max_shapes)
    shapes = []  # list of dicts: {'type','color','anchor','pixels'}

    pos_idx = 0
    placed = 0
    while placed < n_shapes and pos_idx < len(potential_positions):
        top_r, top_c = potential_positions[pos_idx]
        pos_idx += 1
        shape_type = random.choice(list(templates.keys()))
        pixels_rel = templates[shape_type]
        # Check space free
        ok = True
        for dr, dc in pixels_rel:
            r, c = top_r + dr, top_c + dc
            if r < 0 or r >= H or c < 0 or c >= W or inp[r][c] != 0:
                ok = False
                break
        if not ok:
            continue
        color = random.choice(mirror_colors)
        pixset = set()
        for dr, dc in pixels_rel:
            r, c = top_r + dr, top_c + dc
            inp[r][c] = color
            pixset.add((r, c))
        shapes.append({'type': shape_type, 'color': color, 'anchor': (top_r, top_c), 'pixels': pixset})
        placed += 1

    # Make a deep copy for output and a mapping of shape pixels to types/colors
    out = [row[:] for row in inp]
    shape_instances = list(shapes)  # will append mirrored instances here

    # Step 1: Pattern Mirroring Chain
    # Start from the top-leftmost original shape (scan order)
    if len(shapes) > 0:
        shapes_sorted = sorted(shapes, key=lambda s: (s['anchor'][0], s['anchor'][1]))
        start = shapes_sorted[0]
        last_group = set(start['pixels'])
        directions = ['h', 'v', 'd']  # horizontal, vertical, diagonal
        chain_len = max(1, len(shapes))  # deterministic based on number of shapes
        for i in range(chain_len):
            dirc = directions[i % 3]
            new_group = set()
            conflict = False
            for (r, c) in last_group:
                if dirc == 'h':
                    nr, nc = r, W - 1 - c
                elif dirc == 'v':
                    nr, nc = H - 1 - r, c
                else:
                    nr, nc = H - 1 - r, W - 1 - c
                # Out of bounds should not happen but check
                if nr < 0 or nr >= H or nc < 0 or nc >= W:
                    conflict = True
                    break
                # If target hits an existing non-shape cell (occupied by other original/mirrored shape), abort this step
                if out[nr][nc] != 0 and (nr, nc) not in last_group:
                    conflict = True
                    break
                new_group.add((nr, nc))
            if conflict:
                # Skip placing this mirrored group
                continue
            # Place mirrored group with same color and same shape type as the starter shape
            for (nr, nc) in new_group:
                out[nr][nc] = start['color']
            # Record new shape instance
            anchor_r = min(r for r, _ in new_group)
            anchor_c = min(c for _, c in new_group)
            shape_instances.append({'type': start['type'], 'color': start['color'], 'anchor': (anchor_r, anchor_c), 'pixels': set(new_group)})
            last_group = new_group

    # Step 2: Path Merging - connect shapes of the same color with orthogonal paths
    # Group shapes by color and sort groups by earliest anchor so earliest group's paths are drawn first
    from collections import defaultdict
    groups_by_color = defaultdict(list)
    for s in shape_instances:
        groups_by_color[s['color']].append(s)
    # Determine group draw order by earliest anchor in each group
    color_groups = sorted(list(groups_by_color.items()), key=lambda kv: min((sh['anchor'] for sh in kv[1]), key=lambda x: (x[0], x[1])))

    def draw_manhattan(out_grid, a, b, color):
        r1, c1 = a
        r2, c2 = b
        # horizontal first
        step = 1 if c2 >= c1 else -1
        for c in range(c1, c2 + step, step):
            if out_grid[r1][c] == 0:
                out_grid[r1][c] = color
        step = 1 if r2 >= r1 else -1
        for r in range(r1, r2 + step, step):
            if out_grid[r][c2] == 0:
                out_grid[r][c2] = color

    for color, slist in color_groups:
        slist_sorted = sorted(slist, key=lambda s: (s['anchor'][0], s['anchor'][1]))
        for i in range(len(slist_sorted) - 1):
            a = slist_sorted[i]['anchor']
            b = slist_sorted[i + 1]['anchor']
            draw_manhattan(out, a, b, color)

    # Step 3: Connect components by property (shape type)
    groups_by_type = defaultdict(list)
    for s in shape_instances:
        groups_by_type[s['type']].append(s)
    for stype, slist in groups_by_type.items():
        if len(slist) < 2:
            continue
        # Choose dominant color among members
        counts = {}
        for s in slist:
            counts[s['color']] = counts.get(s['color'], 0) + 1
        maxcount = max(counts.values())
        candidates = [col for col, cnt in counts.items() if cnt == maxcount]
        if len(candidates) == 1:
            dominant = candidates[0]
        else:
            # Tie break: earliest shape anchor
            earliest = min(slist, key=lambda s: (s['anchor'][0], s['anchor'][1]))
            dominant = earliest['color']
        slist_sorted = sorted(slist, key=lambda s: (s['anchor'][0], s['anchor'][1]))
        for i in range(len(slist_sorted) - 1):
            a = slist_sorted[i]['anchor']
            b = slist_sorted[i + 1]['anchor']
            draw_manhattan(out, a, b, dominant)

    # Step 4: Replace all shape pixels with canonical colors
    canonical = {'square': 1, 'triangle': 2, 'L': 3}  # square=red(1), triangle=green(2), L=blue(3)
    for s in shape_instances:
        newcol = canonical[s['type']]
        for (r, c) in s['pixels']:
            out[r][c] = newcol

    # Step 5: Image Expansion (mirror along vertical midline to double width)
    newW = W * 2
    expanded = [[0 for _ in range(newW)] for _ in range(H)]
    for r in range(H):
        for c in range(W):
            expanded[r][c] = out[r][c]
            expanded[r][newW - 1 - c] = out[r][c]

    return {'input': inp, 'output': expanded}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input tuple to mutable list of lists
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0])

    # Templates (must match generator)
    templates = {
        'square': {(0, 0), (0, 1), (1, 0), (1, 1)},
        'triangle': {(0, 0), (1, 0), (1, 1)},
        'L': {(0, 0), (0, 1), (1, 0)}
    }
    # Map template sets to names for detection
    template_map = {frozenset(v): k for k, v in templates.items()}

    # Find connected components (orthogonal adjacency) of non-zero pixels
    H = len(grid)
    W = len(grid[0])
    visited = [[False] * W for _ in range(H)]
    components = []  # list of dicts {pixels:set, color:int, anchor:(r,c), type:str}

    for r in range(H):
        for c in range(W):
            if grid[r][c] == 0 or visited[r][c]:
                continue
            color = grid[r][c]
            # BFS
            stack = [(r, c)]
            pixels = set()
            while stack:
                pr, pc = stack.pop()
                if pr < 0 or pr >= H or pc < 0 or pc >= W: continue
                if visited[pr][pc]: continue
                if grid[pr][pc] != color: continue
                visited[pr][pc] = True
                pixels.add((pr, pc))
                for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                    nr, nc = pr+dr, pc+dc
                    if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc] and grid[nr][nc] == color:
                        stack.append((nr, nc))
            # Determine anchor and type by normalizing pixels
            minr = min(p[0] for p in pixels)
            minc = min(p[1] for p in pixels)
            rel = frozenset(((pr - minr, pc - minc) for pr, pc in pixels))
            stype = template_map.get(rel, None)
            # If unknown shape, try to match by bounding box with possible missing pixels
            if stype is None:
                # Fallback: infer by pixel count and bounding box
                if len(pixels) == 4:
                    stype = 'square'
                elif len(pixels) == 3:
                    # Distinguish triangle vs L by positions
                    coords = set((pr - minr, pc - minc) for pr, pc in pixels)
                    if (0,1) in coords and (1,0) in coords:
                        stype = 'triangle'
                    else:
                        stype = 'L'
                else:
                    stype = 'square'
            components.append({'pixels': pixels, 'color': color, 'anchor': (minr, minc), 'type': stype})

    # Prepare output grid starting as a copy of input
    out = [row[:] for row in grid]
    shape_instances = list(components)

    # Step 1: Pattern Mirroring Chain
    if len(components) > 0:
        start = min(components, key=lambda s: (s['anchor'][0], s['anchor'][1]))
        last_group = set(start['pixels'])
        directions = ['h', 'v', 'd']
        chain_len = max(1, len(components))
        for i in range(chain_len):
            dirc = directions[i % 3]
            new_group = set()
            conflict = False
            for (r, c) in last_group:
                if dirc == 'h':
                    nr, nc = r, W - 1 - c
                elif dirc == 'v':
                    nr, nc = H - 1 - r, c
                else:
                    nr, nc = H - 1 - r, W - 1 - c
                if nr < 0 or nr >= H or nc < 0 or nc >= W:
                    conflict = True
                    break
                # If target is occupied by something not in last_group, conflict
                if out[nr][nc] != 0 and (nr, nc) not in last_group:
                    conflict = True
                    break
                new_group.add((nr, nc))
            if conflict:
                continue
            # Place mirrored group with same color and same type as starter
            for (nr, nc) in new_group:
                out[nr][nc] = start['color']
            anchor_r = min(r for r, _ in new_group)
            anchor_c = min(c for _, c in new_group)
            shape_instances.append({'type': start['type'], 'color': start['color'], 'anchor': (anchor_r, anchor_c), 'pixels': set(new_group)})
            last_group = new_group

    # Step 2: Path Merging
    from collections import defaultdict
    groups_by_color = defaultdict(list)
    for s in shape_instances:
        groups_by_color[s['color']].append(s)
    # sort color groups by earliest anchor
    def earliest_anchor(slist):
        return min((sh['anchor'] for sh in slist), key=lambda x: (x[0], x[1]))
    color_groups = sorted(list(groups_by_color.items()), key=lambda kv: earliest_anchor(kv[1]))

    def draw_manhattan(out_grid, a, b, color):
        r1, c1 = a
        r2, c2 = b
        step = 1 if c2 >= c1 else -1
        for c in range(c1, c2 + step, step):
            if out_grid[r1][c] == 0:
                out_grid[r1][c] = color
        step = 1 if r2 >= r1 else -1
        for r in range(r1, r2 + step, step):
            if out_grid[r][c2] == 0:
                out_grid[r][c2] = color

    for color, slist in color_groups:
        slist_sorted = sorted(slist, key=lambda s: (s['anchor'][0], s['anchor'][1]))
        for i in range(len(slist_sorted) - 1):
            a = slist_sorted[i]['anchor']
            b = slist_sorted[i + 1]['anchor']
            draw_manhattan(out, a, b, color)

    # Step 3: Connect by property (shape type)
    groups_by_type = defaultdict(list)
    for s in shape_instances:
        groups_by_type[s['type']].append(s)
    for stype, slist in groups_by_type.items():
        if len(slist) < 2:
            continue
        counts = {}
        for s in slist:
            counts[s['color']] = counts.get(s['color'], 0) + 1
        maxcount = max(counts.values())
        candidates = [col for col, cnt in counts.items() if cnt == maxcount]
        if len(candidates) == 1:
            dominant = candidates[0]
        else:
            earliest_shape = min(slist, key=lambda s: (s['anchor'][0], s['anchor'][1]))
            dominant = earliest_shape['color']
        slist_sorted = sorted(slist, key=lambda s: (s['anchor'][0], s['anchor'][1]))
        for i in range(len(slist_sorted) - 1):
            a = slist_sorted[i]['anchor']
            b = slist_sorted[i + 1]['anchor']
            draw_manhattan(out, a, b, dominant)

    # Step 4: Shape to Color Encoding
    canonical = {'square': 1, 'triangle': 2, 'L': 3}
    for s in shape_instances:
        newcol = canonical[s['type']]
        for (r, c) in s['pixels']:
            out[r][c] = newcol

    # Step 5: Image expansion (mirror vertically to double width)
    newW = W * 2
    expanded = [[0] * newW for _ in range(H)]
    for r in range(H):
        for c in range(W):
            val = out[r][c]
            expanded[r][c] = val
            expanded[r][newW - 1 - c] = val

    # Return as tuple-of-tuples
    return tuple(tuple(row) for row in expanded)

