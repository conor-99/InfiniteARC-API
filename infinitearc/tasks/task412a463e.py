# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 412a463e
Difficulty: medium–hard

=== Tags ===
- Pattern mirroring chain
- Path following
- Fill single gap

=== Description ===
Input grids feature a continuous path of a single color (e.g., color 1)
traversing a medium-sized grid (10×10 to 20×20), with exactly one background
cell (color 0) interrupting the path. This gap is positioned precisely on the
axis of symmetry for the path's overall pattern. The path is designed such that
its segments mirror across a vertical or horizontal axis determined by the
path's structure, with the gap located at the mirror point where the path should
connect. The output grid fills this single gap with the path color, restoring
continuity and completing the symmetric pattern. The path now extends
symmetrically across the axis, forming a chain of mirrored segments where each
segment mirrors the prior, creating a visually cohesive, non-overlapping path
that follows the mirrored pattern. The transformation requires identifying the
symmetry axis through the path's existing segments and recognizing that the gap
must be filled to maintain the mirrored chain structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    """
    Generate a grid with a symmetric path (vertical or horizontal symmetry) that has
    exactly one gap on the symmetry axis. The path color is 1 and background is 0.

    Returns:
      {'input': grid, 'output': grid_with_gap_filled}
    """
    # Choose odd dimensions between 11 and 19 (medium-sized grid)
    width = random.choice([11, 13, 15, 17, 19])
    height = random.choice([11, 13, 15, 17, 19])

    axis = random.choice(['vertical', 'horizontal'])
    path_color = 1

    g = grid(width, height, 0)

    if axis == 'vertical':
        mid = width // 2
        # Pick a start row on the left edge and a reachable gap row near the center column
        start_row = random.randint(0, height - 1)
        allowed_low = max(0, start_row - (mid - 1))
        allowed_high = min(height - 1, start_row + (mid - 1))
        gap_row = random.randint(allowed_low, allowed_high)

        # Build a target row for each column in the left half (0 .. mid-1)
        cols = mid
        r_target = [None] * cols
        r_target[0] = start_row
        # Ensure the last two target columns are the gap_row so the last column has only one cell
        r_target[-1] = gap_row
        r_target[-2] = gap_row
        for c in range(1, cols - 2):
            remaining = (cols - 1) - c
            min_row = max(0, gap_row - remaining)
            max_row = min(height - 1, gap_row + remaining)
            prev = r_target[c - 1]
            low = max(min_row, prev - 2)
            high = min(max_row, prev + 2)
            r_target[c] = random.randint(low, high)

        # Now build a 4-connected path that progresses to the right across the left half
        left_path = []
        cur_r = r_target[0]
        cur_c = 0
        left_path.append((cur_r, cur_c))
        for c in range(0, cols - 1):
            # horizontal step to next column at same row
            cur_c = c + 1
            left_path.append((cur_r, cur_c))
            # vertical moves in this new column until we reach the target row for that column
            target_r = r_target[cur_c]
            while cur_r < target_r:
                cur_r += 1
                left_path.append((cur_r, cur_c))
            while cur_r > target_r:
                cur_r -= 1
                left_path.append((cur_r, cur_c))

        # Sanity: path must end at the gap-adjacent cell
        assert left_path[-1] == (gap_row, mid - 1)

        # Mirror the left path to create the right path (reversed so it matches continuity when gap is filled)
        right_path = [(r, width - 1 - c) for (r, c) in reversed(left_path)]

        # Paint the path (leave the central column empty at the gap row)
        for (r, c) in left_path + right_path:
            g[r][c] = path_color

        # Ensure the single gap on the central column
        g[gap_row][mid] = 0
        output = [row[:] for row in g]
        output[gap_row][mid] = path_color

        return {'input': g, 'output': output}

    else:  # horizontal symmetry
        mid = height // 2
        # Pick a start column on the top edge and a reachable gap column near the center row
        start_col = random.randint(0, width - 1)
        allowed_low = max(0, start_col - (mid - 1))
        allowed_high = min(width - 1, start_col + (mid - 1))
        gap_col = random.randint(allowed_low, allowed_high)

        # Build a target column for each row in the top half (0 .. mid-1)
        rows = mid
        c_target = [None] * rows
        c_target[0] = start_col
        # Ensure the last two target rows are gap_col so the final top row has only one cell at gap_col
        c_target[-1] = gap_col
        c_target[-2] = gap_col
        for r in range(1, rows - 2):
            remaining = (rows - 1) - r
            min_col = max(0, gap_col - remaining)
            max_col = min(width - 1, gap_col + remaining)
            prev = c_target[r - 1]
            low = max(min_col, prev - 2)
            high = min(max_col, prev + 2)
            c_target[r] = random.randint(low, high)

        # Build a 4-connected path that progresses downward across the top half
        top_path = []
        cur_r = 0
        cur_c = c_target[0]
        top_path.append((cur_r, cur_c))
        for r in range(0, rows - 1):
            # step down to next row at same column
            cur_r = r + 1
            top_path.append((cur_r, cur_c))
            # horizontal moves in this row until we reach the target column
            target_c = c_target[cur_r]
            while cur_c < target_c:
                cur_c += 1
                top_path.append((cur_r, cur_c))
            while cur_c > target_c:
                cur_c -= 1
                top_path.append((cur_r, cur_c))

        # Sanity check: path should arrive at the cell adjacent to the central row
        assert top_path[-1] == (mid - 1, gap_col)

        # Mirror the top path to create the bottom path
        bottom_path = [(height - 1 - r, c) for (r, c) in reversed(top_path)]

        for (r, c) in top_path + bottom_path:
            g[r][c] = path_color

        # Ensure the single gap on the central row
        g[mid][gap_col] = 0
        output = [row[:] for row in g]
        output[mid][gap_col] = path_color

        return {'input': g, 'output': output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Helper to fill a gap at (r, c) with the color implied by its symmetric neighbors
    def fill_if_matches(r, c):
        # Prefer horizontal neighbors if they agree, otherwise vertical
        if c - 1 >= 0 and c + 1 < width:
            left = grid[r][c - 1]
            right = grid[r][c + 1]
            if left == right and left != 0:
                grid[r][c] = left
                return True
        if r - 1 >= 0 and r + 1 < height:
            up = grid[r - 1][c]
            down = grid[r + 1][c]
            if up == down and up != 0:
                grid[r][c] = up
                return True
        return False

    # Check vertical symmetry (compare left and right halves)
    is_vertical = True
    for r in range(height):
        for c in range(width // 2):
            if grid[r][c] != grid[r][width - 1 - c]:
                is_vertical = False
                break
        if not is_vertical:
            break

    if is_vertical:
        mid = width // 2
        # Identify left-half path cells
        left_cells = {(r, c) for r in range(height) for c in range(mid) if grid[r][c] != 0}
        if left_cells:
            max_col = max(c for (_, c) in left_cells)
            candidates = [(r, c) for (r, c) in left_cells if c == max_col]
            # Choose candidate that looks like an endpoint (degree 1) if possible
            chosen = None
            best_deg = 999
            for (r, c) in candidates:
                deg = 0
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    if (r + dr, c + dc) in left_cells:
                        deg += 1
                if deg == 1:
                    chosen = (r, c)
                    break
                if deg < best_deg:
                    best_deg = deg
                    chosen = (r, c)
            if chosen is not None:
                gap_row, gap_col_left = chosen
                color = grid[gap_row][gap_col_left]
                grid[gap_row][mid] = color
                return grid

        # Fallback: any zero in central column that can be filled from horizontal neighbors
        for r in range(height):
            if grid[r][mid] == 0 and fill_if_matches(r, mid):
                return grid

    # Check horizontal symmetry (compare top and bottom halves)
    is_horizontal = True
    for c in range(width):
        for r in range(height // 2):
            if grid[r][c] != grid[height - 1 - r][c]:
                is_horizontal = False
                break
        if not is_horizontal:
            break

    if is_horizontal:
        mid = height // 2
        # Identify top-half path cells
        top_cells = {(r, c) for r in range(mid) for c in range(width) if grid[r][c] != 0}
        if top_cells:
            max_row = max(r for (r, _) in top_cells)
            candidates = [(r, c) for (r, c) in top_cells if r == max_row]
            chosen = None
            best_deg = 999
            for (r, c) in candidates:
                deg = 0
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    if (r + dr, c + dc) in top_cells:
                        deg += 1
                if deg == 1:
                    chosen = (r, c)
                    break
                if deg < best_deg:
                    best_deg = deg
                    chosen = (r, c)
            if chosen is not None:
                gap_row_top, gap_col = chosen
                color = grid[gap_row_top][gap_col]
                grid[mid][gap_col] = color
                return grid

        # Fallback: any zero in central row that can be filled from vertical/horizontal neighbors
        for c in range(width):
            if grid[mid][c] == 0 and fill_if_matches(mid, c):
                return grid

    # General fallback: find any single gap that is between two identical non-zero neighbors horizontally or vertically
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 and fill_if_matches(r, c):
                return grid

    return grid

