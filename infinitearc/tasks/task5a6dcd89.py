# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 5a6dcd89
Difficulty: insane

=== Tags ===
- Bouncing

=== Description ===
The input grid features a dense arrangement of non-zero colored cells (values
1-9) distributed across a large 20×20 grid. Each cell's color dictates the
direction of a bouncing path: odd-colored cells (1, 3, 5, 7, 9) initiate
horizontal bouncing paths that reflect left-right between the grid's vertical
edges, while even-colored cells (2, 4, 6, 8) initiate vertical bouncing paths
that reflect up-down between the grid's horizontal edges. The path for each cell
begins at its position and propagates until it fills the grid with alternating
direction changes upon hitting boundaries. The output grid is constructed by
drawing all paths in their original colors, processed in strict row-major order
(top to bottom, left to right), where overlapping paths overwrite prior ones
with the color of the later-starting path. This task demands recognizing the
color-direction mapping, handling concurrent path propagation across a high-
density grid, and resolving overlapping path conflicts through deterministic
ordering—requiring multi-layered abstraction to decode the interplay of color
rules and spatial dynamics.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = 20
    height = 20
    while True:
        input_grid = [[random.randint(1, 9) for _ in range(width)] for _ in range(height)]
        output_grid = [[0] * width for _ in range(height)]
        for i in range(height):
            for j in range(width):
                color = input_grid[i][j]
                if color % 2 == 1:
                    for k in range(width):
                        output_grid[i][k] = color
                else:
                    for k in range(height):
                        output_grid[k][j] = color
        if input_grid != output_grid:
            return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = [[0] * width for _ in range(height)]
    for i in range(height):
        for j in range(width):
            color = input_grid[i][j]
            if color % 2 == 1:
                for k in range(width):
                    output_grid[i][k] = color
            else:
                for k in range(height):
                    output_grid[k][j] = color
    return output_grid
