# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 58e01243
Difficulty: hard

=== Tags ===
- Projection unto rectangle
- Take maximum
- Mimic pattern
- Multi agent path weaving

=== Description ===
The input grid contains multiple weaving paths (each path is a connected
sequence of cells with the same color, representing different agents), where
paths cross over each other. The output grid is the minimal bounding rectangle
that encompasses all cells from all paths. Within this rectangle, each cell's
value is the maximum color value among all paths that intersect that cell. The
output mimics the original path weaving pattern by reflecting the spatial
distribution of path overlaps through the maximum color assignments, ensuring
the arrangement of colors in the output mirrors the interaction points of the
input paths.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, continuous_creature

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    input_grid = grid(width, height, 0)
    colors = random.sample([1, 2, 3, 4, 5, 6, 7, 8, 9], 2)
    
    for color in colors:
        pixels = continuous_creature(random.randint(3, 8), 3, 3)
        r0 = random.randint(0, height - 3)
        c0 = random.randint(0, width - 3)
        
        while True:
            overlap = False
            for (r, c) in pixels:
                if input_grid[r0 + r][c0 + c] != 0:
                    overlap = True
                    break
            if not overlap:
                break
            r0 = random.randint(0, height - 3)
            c0 = random.randint(0, width - 3)
            
        for (r, c) in pixels:
            input_grid[r0 + r][c0 + c] = color

    non_zero = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                non_zero.append((r, c))
    
    min_row = min(r for r, c in non_zero)
    max_row = max(r for r, c in non_zero)
    min_col = min(c for r, c in non_zero)
    max_col = max(c for r, c in non_zero)
    
    output_grid = []
    for r in range(min_row, max_row + 1):
        output_grid.append(input_grid[r][min_col:max_col + 1])
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    non_zero = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                non_zero.append((r, c))
    
    if not non_zero:
        return input_grid
    
    min_row = min(r for r, c in non_zero)
    max_row = max(r for r, c in non_zero)
    min_col = min(c for r, c in non_zero)
    max_col = max(c for r, c in non_zero)
    
    output_grid = []
    for r in range(min_row, max_row + 1):
        output_grid.append(input_grid[r][min_col:max_col + 1])
    
    return output_grid
