# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: ef46b666
Difficulty: medium–hard

=== Tags ===
- Directional routing
- Copy paste patch
- One yes one no

=== Description ===
Input grids consist of 10×10 or larger 2D grids with background color 0 and
multiple non-background colored patches (connected regions of identical color).
Each patch is adjacent to a single directional arrow cell (a distinct color
indicating one of four cardinal directions: up, down, left, right). The
transformation rule follows a "one yes one no" condition: a patch is copied in
the direction of its arrow **only if** the patch's color differs from the
arrow's color. The original patch remains in place, and a copy is placed in the
adjacent cell in the indicated direction (with the same color), provided the
target cell is background. The input grid contains exactly two patches—one
meeting the "yes" condition (color mismatch with arrow) and one meeting the "no"
condition (color match with arrow). The output grid preserves all original
elements, includes the copied "yes" patch in the correct direction, and leaves
the "no" patch unchanged. This requires simultaneous recognition of color
relationships, directional indicators, and application of a conditional copy
operation without overlapping existing elements.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

# Keep track of seen examples to ensure uniqueness across multiple generate() calls
_SEEN = set()


def generate():
    """Generate a grid pair following the rule:

    - The grid contains two single-cell colored patches (non-zero colors).
    - Each patch has an adjacent arrow cell (colors 1..4) that encodes a direction:
        1: up, 2: down, 3: left, 4: right
    - Exactly one patch meets the "yes" condition: its color differs from the arrow's color.
      The other patch has the same numeric color as its arrow (the "no" condition).
    - When a patch meets the yes condition, a copy of that single-cell patch is placed
      two steps away from the patch in the arrow direction (i.e., with the arrow between
      the original and the copy). The original remains in place. The copy is only placed
      if the target cell is background (0).

    The function ensures the two patches/arrows/targets do not overlap and that the
    generated (input, output) pair is unique for repeated calls in the same process.
    """
    directions = {1: (-1, 0), 2: (1, 0), 3: (0, -1), 4: (0, 1)}

    attempts = 0
    while True:
        attempts += 1
        if attempts > 2000:
            # Extremely unlikely to get here; fallback to a deterministic small example
            width, height = 10, 10
            grid = common.grid(width, height, 0)
            # Simple deterministic placement
            r1, c1 = 3, 3
            D1 = 1
            C1 = 5
            grid[r1][c1] = C1
            grid[r1 - 1][c1] = D1
            r2, c2 = 6, 6
            D2 = 3
            C2 = D2
            grid[r2][c2] = C2
            grid[r2][c2 - 1] = D2
            output = [row[:] for row in grid]
            output[r1 - 2][c1] = C1
            key = (tuple(tuple(row) for row in grid), tuple(tuple(row) for row in output))
            if key not in _SEEN:
                _SEEN.add(key)
                return {"input": grid, "output": output}
            # otherwise fall through and try random generation

        width = random.randint(10, 15)
        height = random.randint(10, 15)
        grid = common.grid(width, height, 0)

        # Choose the first patch (the one that WILL be copied): pick an arrow direction
        D1 = random.randint(1, 4)
        dr1, dc1 = directions[D1]

        # Candidate cells for placing a single-cell patch such that arrow and target fit
        cand1 = []
        for r in range(height):
            for c in range(width):
                ar = r + dr1
                ac = c + dc1
                tr = r + 2 * dr1
                tc = c + 2 * dc1
                if 0 <= ar < height and 0 <= ac < width and 0 <= tr < height and 0 <= tc < width:
                    cand1.append((r, c))
        if not cand1:
            continue

        r1, c1 = random.choice(cand1)
        # Pick a patch color that is not an arrow color (5..9). This avoids ambiguity
        # between arrow-cells and patch-cells for the solver.
        C1 = random.choice(list(range(5, 10)))

        # Place patch1 and its arrow
        grid[r1][c1] = C1
        ar1, ac1 = r1 + dr1, c1 + dc1
        grid[ar1][ac1] = D1
        tr1, tc1 = r1 + 2 * dr1, c1 + 2 * dc1

        # Ensure target cell for the first patch is free
        if grid[tr1][tc1] != 0:
            continue

        # Now place the second patch which must NOT be copied: make its patch color equal to its arrow color
        D2 = random.randint(1, 4)
        dr2, dc2 = directions[D2]
        C2 = D2  # equality enforces the "no" condition

        # Build candidates for the second patch ensuring no overlap with the first patch/arrow/target
        cand2 = []
        for r in range(height):
            for c in range(width):
                ar = r + dr2
                ac = c + dc2
                tr = r + 2 * dr2
                tc = c + 2 * dc2
                if not (0 <= ar < height and 0 <= ac < width and 0 <= tr < height and 0 <= tc < width):
                    continue
                # Avoid placing any part (patch, arrow, or target) on top of the first patch's cells
                occupied = {(r1, c1), (ar1, ac1), (tr1, tc1)}
                if (r, c) in occupied or (ar, ac) in occupied or (tr, tc) in occupied:
                    continue
                # Keep a bit of distance to prevent accidental overlaps and to ensure a clear scanning order
                if abs(r - r1) < 3 and abs(c - c1) < 3:
                    continue
                cand2.append((r, c))
        if not cand2:
            # try a new random layout
            continue

        # Choose r2,c2 but ensure scanning order visits patch1 before patch2 (top-left first)
        random.shuffle(cand2)
        selected = None
        for (r2, c2) in cand2:
            # enforce (r1,c1) < (r2,c2) lexicographically to make solver find the yes-case first
            if (r1, c1) < (r2, c2):
                selected = (r2, c2)
                break
        if selected is None:
            # if none satisfy ordering, just pick the first candidate and restart (try again)
            continue
        else:
            r2, c2 = selected

        ar2, ac2 = r2 + dr2, c2 + dc2

        # Place second patch and its arrow
        grid[r2][c2] = C2
        grid[ar2][ac2] = D2

        # Double-check we haven't accidentally overwritten important cells
        if grid[tr1][tc1] != 0:
            continue

        # Build output: copy only the first (yes) patch into its target cell
        output = [row[:] for row in grid]
        output[tr1][tc1] = C1

        key = (tuple(tuple(row) for row in grid), tuple(tuple(row) for row in output))
        if key in _SEEN:
            # Try again to get a unique example
            continue
        _SEEN.add(key)
        return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    """Solver following the same rule as the generator:

    - Find a colored patch cell (nonzero) that has an adjacent arrow cell (value 1..4).
    - The arrow color encodes a direction: 1=up,2=down,3=left,4=right.
    - Copy the patch (single cell) two steps in the arrow direction (so the arrow sits between
      the original and the copy) only if the patch color differs from the arrow color and
      the destination cell is background (0).

    The function performs a row-major scan and performs the first valid copy it finds,
    returning the resulting grid as a tuple of tuples.
    """
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0
    directions = {1: (-1, 0), 2: (1, 0), 3: (0, -1), 4: (0, 1)}

    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0:
                continue
            color_patch = grid[r][c]
            # We treat only non-arrow colors as patches (generator places patches in 5..9)
            if not (5 <= color_patch <= 9):
                continue
            # Check four cardinal neighbors for an arrow cell
            for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                nr, nc = r + dr, c + dc
                if not (0 <= nr < height and 0 <= nc < width):
                    continue
                arrow_color = grid[nr][nc]
                if 1 <= arrow_color <= 4:
                    adr, adc = directions[arrow_color]
                    tr, tc = nr + adr, nc + adc
                    if 0 <= tr < height and 0 <= tc < width:
                        # Only copy if patch color differs from arrow color and target is background
                        if arrow_color != color_patch and grid[tr][tc] == 0:
                            # Copy single-cell patch
                            grid[tr][tc] = color_patch
                            return tuple(tuple(row) for row in grid)
    return tuple(tuple(row) for row in grid)

