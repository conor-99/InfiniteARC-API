# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 7db7758b
Difficulty: mediumâ€“hard

=== Tags ===
- Nonlocal dependency
- Cluster by shape
- Draw line to nearest object of same color

=== Description ===
The input grid contains multiple contiguous clusters of colored cells, each
forming a distinct shape (e.g., square, line, or irregular blob) with a single
non-background color. Clusters of the same color may appear multiple times as
separate shapes. The output grid connects each cluster to the nearest other
cluster of the same color with a straight line drawn using a fixed line color
(e.g., gray). The line is drawn only on background cells (value 0), connecting
the closest points between the two clusters. Clusters with no other cluster of
the same color remain unchanged. The background and cluster colors are preserved
except where lines are added, and lines do not overlap or modify non-background
cells.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, continuous_creature, connected, all_pixels

def generate():
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    input_grid = [[0] * width for _ in range(height)]
    line_color = 5
    
    # Choose 2-3 colors
    colors = random.sample(range(1, 10), random.randint(2, 3))
    
    # For each color, create two clusters
    for color in colors:
        for _ in range(2):
            size = random.randint(3, 5)
            try:
                pixels = continuous_creature(size, width, height)
                rows = [p[0] for p in pixels]
                cols = [p[1] for p in pixels]
            except:
                rows, cols = [], []
                while len(rows) < size or not connected([(r, c) for r, c in zip(rows, cols)]):
                    rows, cols = [], []
                    for _ in range(size):
                        r = random.randint(0, height-1)
                        c = random.randint(0, width-1)
                        rows.append(r)
                        cols.append(c)
            min_r, max_r = min(rows), max(rows)
            min_c, max_c = min(cols), max(cols)
            shift_r = random.randint(0, height - (max_r - min_r + 1))
            shift_c = random.randint(0, width - (max_c - min_c + 1))
            shifted_rows = [r + shift_r for r in rows]
            shifted_cols = [c + shift_c for c in cols]
            overlap = False
            for r, c in zip(shifted_rows, shifted_cols):
                if input_grid[r][c] != 0:
                    overlap = True
                    break
            if overlap:
                continue
            for r, c in zip(shifted_rows, shifted_cols):
                input_grid[r][c] = color

    output_grid = [row[:] for row in input_grid]
    
    visited = [[False] * width for _ in range(height)]
    clusters = {}
    for color in colors:
        clusters[color] = []
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and input_grid[r][c] != 0:
                color = input_grid[r][c]
                queue = [(r, c)]
                visited[r][c] = True
                cluster = []
                while queue:
                    cr, cc = queue.pop(0)
                    cluster.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                clusters[color].append(cluster)

    for color, cluster_list in clusters.items():
        if len(cluster_list) < 2:
            continue
        min_dist = float('inf')
        closest_pair = None
        for i in range(len(cluster_list)):
            for j in range(i+1, len(cluster_list)):
                dist = min_distance(cluster_list[i], cluster_list[j])
                if dist < min_dist:
                    min_dist = dist
                    closest_pair = (cluster_list[i], cluster_list[j])
        if closest_pair is None:
            continue
        cluster1, cluster2 = closest_pair
        a, b = find_closest_points(cluster1, cluster2)
        draw_line(output_grid, a, b, line_color)

    return {"input": input_grid, "output": output_grid}

def min_distance(cluster1, cluster2):
    min_dist = float('inf')
    for (r1, c1) in cluster1:
        for (r2, c2) in cluster2:
            dist = abs(r1 - r2) + abs(c1 - c2)
            if dist < min_dist:
                min_dist = dist
    return min_dist

def find_closest_points(cluster1, cluster2):
    min_dist = float('inf')
    closest_pair = None
    for (r1, c1) in cluster1:
        for (r2, c2) in cluster2:
            dist = abs(r1 - r2) + abs(c1 - c2)
            if dist < min_dist:
                min_dist = dist
                closest_pair = ((r1, c1), (r2, c2))
    return closest_pair

def draw_line(grid, a, b, color):
    x0, y0 = a
    x1, y1 = b
    dx = abs(x1 - x0)
    dy = abs(y1 - y0)
    sx = 1 if x0 < x1 else -1
    sy = 1 if y0 < y1 else -1
    err = dx - dy
    
    while True:
        if grid[x0][y0] == 0:
            grid[x0][y0] = color
        if x0 == x1 and y0 == y1:
            break
        e2 = 2 * err
        if e2 > -dy:
            err -= dy
            x0 += sx
        if e2 < dx:
            err += dx
            y0 += sy


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    line_color = 5
    
    visited = [[False] * width for _ in range(height)]
    clusters = {}
    for r in range(height):
        for c in range(width):
            color = grid[r][c]
            if color != 0:
                if color not in clusters:
                    clusters[color] = []
                if not visited[r][c]:
                    queue = [(r, c)]
                    visited[r][c] = True
                    cluster = []
                    while queue:
                        cr, cc = queue.pop(0)
                        cluster.append((cr, cc))
                        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                                visited[nr][nc] = True
                                queue.append((nr, nc))
                    clusters[color].append(cluster)

    for color, cluster_list in clusters.items():
        if len(cluster_list) < 2:
            continue
        min_dist = float('inf')
        closest_pair = None
        for i in range(len(cluster_list)):
            for j in range(i+1, len(cluster_list)):
                dist = min_distance(cluster_list[i], cluster_list[j])
                if dist < min_dist:
                    min_dist = dist
                    closest_pair = (cluster_list[i], cluster_list[j])
        if closest_pair is None:
            continue
        cluster1, cluster2 = closest_pair
        a, b = find_closest_points(cluster1, cluster2)
        draw_line(grid, a, b, line_color)

    return tuple(tuple(row) for row in grid)

def min_distance(cluster1, cluster2):
    min_dist = float('inf')
    for (r1, c1) in cluster1:
        for (r2, c2) in cluster2:
            dist = abs(r1 - r2) + abs(c1 - c2)
            if dist < min_dist:
                min_dist = dist
    return min_dist

def find_closest_points(cluster1, cluster2):
    min_dist = float('inf')
    closest_pair = None
    for (r1, c1) in cluster1:
        for (r2, c2) in cluster2:
            dist = abs(r1 - r2) + abs(c1 - c2)
            if dist < min_dist:
                min_dist = dist
                closest_pair = ((r1, c1), (r2, c2))
    return closest_pair

def draw_line(grid, a, b, color):
    x0, y0 = a
    x1, y1 = b
    dx = abs(x1 - x0)
    dy = abs(y1 - y0)
    sx = 1 if x0 < x1 else -1
    sy = 1 if y0 < y1 else -1
    err = dx - dy
    
    while True:
        if grid[x0][y0] == 0:
            grid[x0][y0] = color
        if x0 == x1 and y0 == y1:
            break
        e2 = 2 * err
        if e2 > -dy:
            err -= dy
            x0 += sx
        if e2 < dx:
            err += dx
            y0 += sy
