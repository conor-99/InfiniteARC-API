# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 811a979f
Difficulty: medium

=== Tags ===
- Cylindrical
- Even or odd
- Bring patterns close

=== Description ===
The input grid is a cylindrical grid where the left and right edges are
connected, creating a continuous loop. Two distinct patterns (connected regions
of the same color) are positioned such that they are separated by a gap. The
output grid is generated by moving one pattern horizontally to minimize the
distance between the two patterns. The direction of movement is determined by
the parity of the grid's width: if the width is even, the right pattern is
shifted left; if the width is odd, the left pattern is shifted right. The shift
amount is the minimal distance required to make the patterns adjacent on the
cylindrical grid, ensuring they are brought as close as possible without
overlapping.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import random_color

def generate():
    w = random.randint(3, 30)
    h = random.randint(1, 30)
    c1 = random_color(exclude=[0])
    c2 = random_color(exclude=[0, c1])
    gap = random.randint(1, w - 2)
    input_grid = [[0] * w for _ in range(h)]
    for i in range(h):
        input_grid[i][0] = c1
        input_grid[i][gap + 1] = c2
    output_grid = [[0] * w for _ in range(h)]
    if w % 2 == 0:
        for i in range(h):
            output_grid[i][0] = c1
            output_grid[i][1] = c2
    else:
        for i in range(h):
            output_grid[i][gap] = c1
            output_grid[i][gap + 1] = c2
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    w = len(input_grid[0])
    h = len(input_grid)
    colors = set()
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] != 0:
                colors.add(input_grid[r][c])
    colors = list(colors)
    if len(colors) != 2:
        colors = [1, 2]
    col_colors = {}
    for c in range(w):
        for r in range(h):
            if input_grid[r][c] != 0:
                col_colors[c] = input_grid[r][c]
                break
    cols = sorted(col_colors.keys())
    left_col = cols[0]
    right_col = cols[1]
    left_color = col_colors[left_col]
    right_color = col_colors[right_col]
    gap = right_col - left_col - 1
    output_grid = [[0] * w for _ in range(h)]
    if w % 2 == 0:
        for r in range(h):
            output_grid[r][left_col] = left_color
            output_grid[r][left_col + 1] = right_color
    else:
        new_left_col = left_col + gap
        for r in range(h):
            output_grid[r][new_left_col] = left_color
            output_grid[r][right_col] = right_color
    return output_grid
