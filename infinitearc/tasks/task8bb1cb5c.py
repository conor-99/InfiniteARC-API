# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 8bb1cb5c
Difficulty: very hard

=== Tags ===
- Momentum conservation path
- Hollow shape detection
- Contextual rule switch
- Collision marking
- Threshold by touch count

=== Description ===
# Momentum Conservation Path  Input grids feature a single background color (0),
multiple axis-aligned hollow rectangles (each with a solid border of color C and
empty interior of background), and a single moving token (a 1×1 cell of color T)
starting along the left edge facing right. Hollow rectangles must be at least
3×3 in size, with borders of uniform thickness (1 cell) and completely empty
interiors. The token's path begins moving right from its starting position.  The
output grid transforms the input by drawing the token's complete trajectory
using color T, with collision points marked using the hollow rectangle's border
color C. Each collision with a hollow rectangle's border triggers a direction
change based on two contextual rules: (1) the parity of the hollow rectangle's
border color (even: clockwise turn, odd: counterclockwise turn), and (2) a
threshold-based rule switch that reverses the turn direction after exactly three
collisions have occurred in the path.  Hollow rectangles are detected by
identifying closed rectangular borders where all interior cells are background,
and border cells are non-background. The token moves cell-by-cell until exiting
the grid, with direction changes occurring only upon touching a hollow
rectangle's border (not interior cells). The path never overlaps with hollow
rectangles' interiors, and collision marks appear only at border contact points.
No loops or self-intersections occur in the path, and all hollow rectangles
remain visually intact in the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from typing import List, Tuple, Dict


def generate() -> Dict[str, List[List[int]]]:
    """
    Generate an ARC-style input-output pair according to the task description.

    Strategy:
    - Pick a random grid size (moderate).
    - Place a token T on the left edge (column 0) at a row that is not on the edge.
    - Attempt to place a small set of non-overlapping hollow rectangles (border thickness 1,
      interior zeros, sizes >= 3x3) with random colors != T.
    - Simulate the token's motion (starting right) using the parity & threshold turning rule.
    - If the simulated path exits the grid without entering any rectangle interior and without
      self-intersections, accept this configuration and produce output by drawing the path
      (color T on background cells visited, border colors remain on collisions).

    The function resamples rectangle placements until a valid path is found (limited attempts).
    """
    # Helper functions
    def boxes_overlap(a_top, a_left, a_h, a_w, b_top, b_left, b_h, b_w) -> bool:
        # Return True if bounding boxes overlap (share any cell)
        if a_left + a_w - 1 < b_left: return False
        if b_left + b_w - 1 < a_left: return False
        if a_top + a_h - 1 < b_top: return False
        if b_top + b_h - 1 < a_top: return False
        return True

    def point_in_interior(r, c, rect) -> bool:
        # rect = (top, left, h, w)
        top, left, h, w = rect
        return (top < r < top + h - 1) and (left < c < left + w - 1)

    def simulate_path(grid, rects, start_r, T):
        height = len(grid)
        width = len(grid[0])
        x, y = 0, start_r
        dx, dy = 1, 0  # start moving right (east)
        path = [(x, y)]
        visited = { (x, y) }
        collisions = 0
        collision_points = []

        def rotate_cw(dx, dy):
            return (-dy, dx)
        def rotate_ccw(dx, dy):
            return (dy, -dx)

        # fast set of interior coordinates for quick test
        interiors = set()
        for rect in rects:
            top, left, h, w, col = rect
            for rr in range(top + 1, top + h - 1):
                for cc in range(left + 1, left + w - 1):
                    interiors.add((cc, rr))  # (x,col,row) store as (x,y)

        step_limit = width * height * 4  # generous safety
        steps = 0
        while True:
            steps += 1
            if steps > step_limit:
                return None  # failed (likely loop)
            nx, ny = x + dx, y + dy
            # Exit if next step leaves grid
            if not (0 <= nx < width and 0 <= ny < height):
                return {
                    'path': path,
                    'collision_points': collision_points,
                    'grid': grid,
                    'rects': rects,
                    'collisions': collisions
                }
            # If next cell is border (non-background and not token color), it's a collision
            val = grid[ny][nx]
            if val != 0 and val != T:
                collisions += 1
                collision_points.append((nx, ny))
                # determine rotation based on parity and threshold
                if collisions <= 3:
                    if val % 2 == 0:
                        dx, dy = rotate_cw(dx, dy)
                    else:
                        dx, dy = rotate_ccw(dx, dy)
                else:
                    # rule-switch: reverse the direction mapping
                    if val % 2 == 0:
                        dx, dy = rotate_ccw(dx, dy)
                    else:
                        dx, dy = rotate_cw(dx, dy)
                x, y = nx, ny
                if (x, y) in visited:
                    return None
                visited.add((x, y))
                path.append((x, y))
                # ensure we didn't move into an interior cell (shouldn't happen for border)
                if (x, y) in interiors:
                    return None
                continue
            else:
                # if next cell is background but lies inside some rectangle interior, invalid
                if (nx, ny) in interiors:
                    return None
                x, y = nx, ny
                if (x, y) in visited:
                    return None
                visited.add((x, y))
                path.append((x, y))
                continue

    # MAIN generation loop
    for overall_try in range(300):
        width = random.randint(14, 24)
        height = random.randint(14, 24)
        grid = [[0 for _ in range(width)] for _ in range(height)]

        # token color
        T = random.randint(1, 9)

        # place token on left edge at a row not on exact edges
        start_r = random.randint(1, height - 2)
        grid[start_r][0] = T

        # Place rectangles
        rects = []  # list of tuples (top, left, h, w, color)
        max_rects = random.randint(3, 6)
        rect_attempts = 0
        placed = 0
        while placed < max_rects and rect_attempts < 300:
            rect_attempts += 1
            h = random.randint(3, min(7, height - 2))
            w = random.randint(3, min(7, width - 2))
            # Avoid touching the leftmost column where token starts
            left = random.randint(1, max(1, width - w - 1))
            top = random.randint(1, max(1, height - h - 1))
            # Ensure non-overlap with existing rectangles and not cover the token start
            overlap = False
            for (rt, rl, rh, rw, rc) in rects:
                if boxes_overlap(top, left, h, w, rt, rl, rh, rw):
                    overlap = True
                    break
            if overlap:
                continue
            # do not place a rectangle that covers the starting token cell (even border)
            if left <= 0 <= left + w - 1 and top <= start_r <= top + h - 1:
                continue
            # choose a color not equal to T
            col = random.randint(1, 9)
            if col == T:
                col = (col % 9) + 1
                if col == T:
                    col = (col % 9) + 1
            # commit rectangle (border cells set to color, interior stays 0)
            for rr in range(top, top + h):
                for cc in range(left, left + w):
                    # border
                    if rr == top or rr == top + h - 1 or cc == left or cc == left + w - 1:
                        grid[rr][cc] = col
            rects.append((top, left, h, w, col))
            placed += 1

        if placed < 3:
            # failed to place enough rectangles; try again
            continue

        # Now simulate
        sim = simulate_path(grid, rects, start_r, T)
        if sim is None:
            continue
        path = sim['path']
        collision_points = sim['collision_points']

        # Ensure path visited at least one background cell (so output != input)
        changed = False
        for (x, y) in path:
            if not (0 <= x < width and 0 <= y < height):
                continue
            if grid[y][x] == 0:
                changed = True
                break
        if not changed:
            # try again
            continue

        # build output
        output = [row[:] for row in grid]
        for (x, y) in path:
            if not (0 <= x < width and 0 <= y < height):
                continue
            if (x, y) in collision_points:
                # keep the border color (collision point uses the rectangle color)
                continue
            if output[y][x] == 0:
                output[y][x] = T
        # final sanity: input must differ from output
        if output == grid:
            continue

        return { 'input': grid, 'output': output }

    # Fallback deterministic small puzzle (should rarely be used)
    width, height = 15, 15
    grid = [[0 for _ in range(width)] for _ in range(height)]
    T = 1
    start_r = height // 2
    grid[start_r][0] = T
    rects = [(3, 5, 3, 3, 2), (8, 9, 3, 3, 3), (4, 11, 3, 3, 4)]
    for top, left, h, w, col in rects:
        for rr in range(top, top + h):
            for cc in range(left, left + w):
                if rr == top or rr == top + h - 1 or cc == left or cc == left + w - 1:
                    grid[rr][cc] = col
    # simulate with same code
    sim = simulate_path(grid, [(r[0], r[1], r[2], r[3], r[4]) for r in rects], start_r, T)
    if sim is None:
        # extremely unlikely; just mark a horizontal path
        output = [row[:] for row in grid]
        for c in range(1, width):
            if output[start_r][c] == 0:
                output[start_r][c] = T
        return {'input': grid, 'output': output}

    path = sim['path']
    collision_points = sim['collision_points']
    output = [row[:] for row in grid]
    for (x, y) in path:
        if not (0 <= x < width and 0 <= y < height):
            continue
        if (x, y) in collision_points:
            continue
        if output[y][x] == 0:
            output[y][x] = T
    return {'input': grid, 'output': output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from typing import List, Tuple

def p(input_grid: Tuple[Tuple[int, ...], ...]) -> List[List[int]]:
    # Convert to mutable grid
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0
    # find token on left edge (first non-background in column 0)
    T = None
    start_r = None
    for r in range(height):
        if grid[r][0] != 0:
            T = grid[r][0]
            start_r = r
            break
    if start_r is None:
        # nothing to do
        return grid

    # helper rotations
    def rotate_cw(dx, dy):
        return (-dy, dx)
    def rotate_ccw(dx, dy):
        return (dy, -dx)

    x, y = 0, start_r
    dx, dy = 1, 0  # start moving right
    path = [(x, y)]
    visited = { (x, y) }
    collisions = 0
    collision_points = []

    # We don't need an explicit list of rectangles; interiors are signified only by the generator
    # but interior cells are zeros (background). According to the task, collisions happen only
    # on non-background border cells (non-zero and not T). So we simulate until the token leaves.

    step_limit = width * height * 4
    steps = 0
    while True:
        steps += 1
        if steps > step_limit:
            break
        nx, ny = x + dx, y + dy
        if not (0 <= nx < width and 0 <= ny < height):
            break
        val = grid[ny][nx]
        if val != 0 and val != T:
            # collision
            collisions += 1
            collision_points.append((nx, ny))
            if collisions <= 3:
                if val % 2 == 0:
                    dx, dy = rotate_cw(dx, dy)
                else:
                    dx, dy = rotate_ccw(dx, dy)
            else:
                # rule-switch after exactly three collisions: reverse mapping
                if val % 2 == 0:
                    dx, dy = rotate_ccw(dx, dy)
                else:
                    dx, dy = rotate_cw(dx, dy)
            x, y = nx, ny
            if (x, y) in visited:
                break
            visited.add((x, y))
            path.append((x, y))
        else:
            # step into background or token-color cell
            x, y = nx, ny
            if (x, y) in visited:
                break
            visited.add((x, y))
            path.append((x, y))

    # build output: draw T along path on background cells; collision points remain border color
    output = [row[:] for row in grid]
    for (px, py) in path:
        if not (0 <= px < width and 0 <= py < height):
            continue
        if (px, py) in collision_points:
            continue
        if output[py][px] == 0:
            output[py][px] = T
    return output

