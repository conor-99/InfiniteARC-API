# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 42b61c06
Difficulty: medium–hard

=== Tags ===
- Symmetry axis completion
- Alternating agents
- Motif extraction

=== Description ===
Input grids are 25×25 grids with a vertical symmetry axis. The left half
(including the central axis) contains a checkerboard pattern of two distinct
colors (e.g., red and blue), where adjacent cells horizontally and vertically
alternate between the two colors. The right half is completely empty.
Additionally, a 3×3 motif (a repeating pattern of three distinct colors arranged
in a triangular formation) is embedded in the bottom-left quadrant of the grid,
with the motif's colors not matching the checkerboard pattern.  The output grid
is generated by: 1. Completing vertical symmetry: mirroring the left half to the
right half across the central axis. 2. Alternating the colors of mirrored cells
such that the checkerboard alternation is preserved but the colors are swapped
(e.g., red becomes blue and blue becomes red in the mirrored half). 3.
Extracting the 3×3 motif from the bottom-left quadrant of the input, rotating it
90 degrees clockwise, and placing it at the exact center of the grid (position
(12,12) for 25×25), where it overlaps with the symmetry axis without disrupting
the checkerboard pattern. The motif's placement must align its rotational
orientation with the grid's axes.  The task requires identifying the
checkerboard pattern, applying the color swap during mirroring, and precisely
extracting and rotating the motif while maintaining all visual constraints. The
output grid must satisfy all three transformations simultaneously, with no
overlapping or conflicting color placements.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    size = 25
    colors = list(range(1, 10))
    c1, c2 = random.sample(colors, 2)
    motif_colors = random.sample([c for c in colors if c != c1 and c != c2], 3)
    motif = []
    for i in range(3):
        row = []
        for j in range(3):
            row.append(motif_colors[(i + j) % 3])
        motif.append(row)
    
    input_grid = [[0] * size for _ in range(size)]
    
    for r in range(size):
        for c in range(13):
            if (r + c) % 2 == 0:
                input_grid[r][c] = c1
            else:
                input_grid[r][c] = c2
    
    for r in range(22, 25):
        for c in range(3):
            input_grid[r][c] = motif[r - 22][c]
    
    output_grid = [row[:] for row in input_grid]
    
    for r in range(size):
        for c in range(13, size):
            mirror_col = 24 - c
            color = input_grid[r][mirror_col]
            output_grid[r][c] = c2 if color == c1 else c1
    
    motif_input = [input_grid[r][0:3] for r in range(22, 25)]
    rotated_motif = [[motif_input[2 - j][i] for j in range(3)] for i in range(3)]
    
    for r in range(3):
        for c in range(3):
            output_grid[12 + r][12 + c] = rotated_motif[r][c]
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    size = len(input_list)
    c1 = input_list[0][0]
    c2 = input_list[0][1]
    if c1 == c2:
        c2 = input_list[0][2]
    
    output_grid = [row[:] for row in input_list]
    
    for r in range(size):
        for c in range(13, size):
            mirror_col = 24 - c
            color = input_list[r][mirror_col]
            output_grid[r][c] = c2 if color == c1 else c1
    
    motif_input = [input_list[r][0:3] for r in range(22, 25)]
    rotated_motif = [[motif_input[2 - j][i] for j in range(3)] for i in range(3)]
    
    for r in range(3):
        for c in range(3):
            output_grid[12 + r][12 + c] = rotated_motif[r][c]
    
    return tuple(tuple(row) for row in output_grid)
