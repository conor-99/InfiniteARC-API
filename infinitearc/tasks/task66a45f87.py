# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 66a45f87
Difficulty: hard

=== Tags ===
- State transfer chain
- Mapping by size relation
- Surface unfolding
- Energy absorption
- Detect wall
- Count different colors

=== Description ===
Input grids consist of a folded surface with a central fold line (background
color) separating an original region and a folded region. The folded region
overlaps the original region such that each cell in the folded region
corresponds to a cell in the original region (e.g., mirrored across the fold
line). The background color (0) forms the fold line and is detectable as a
continuous wall separating the regions.   To generate the output grid: 1.
**Detect wall**: Identify the fold line as a continuous line of background cells
(0) that separates the original and folded regions. 2. **Count different
colors**: For each overlapping cell pair (folded cell and original cell), count
the number of distinct non-background colors present. If the count equals 1, the
folded cell's color is retained; if greater than 1, the folded cell is replaced
with a fixed absorption color (e.g., 5). 3. **State transfer chain**: Apply
color adjustments in a chain from the edge of the fold line toward the fold
line, ensuring each cell's adjustment depends on the current state of the
overlapping cell. 4. **Mapping by size relation**: Position the adjusted folded
region such that its placement distance from the fold line is proportional to
the size (width/height) of the folded region (e.g., shifted by half the region's
width). 5. **Surface unfolding**: Construct the output grid by placing the
original region followed by the adjusted folded region, creating a wider grid
(e.g., original width Ã— 2 for vertical folds).  The transformation requires
sequential application of these rules, where the count of distinct colors
determines energy absorption, the fold line detection enables surface unfolding,
and size relations govern the mapping of the folded region's new position. No
loops or self-intersections occur, and all transformations are deterministic
based on visual patterns rather than numerical properties.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    height = random.randint(3, 30)
    fold_col = random.randint(1, 14)
    width = 2 * fold_col + 1
    grid = [[0] * width for _ in range(height)]
    
    for r in range(height):
        for c in range(fold_col):
            grid[r][c] = random.randint(1, 9)
    
    for r in range(height):
        for c in range(fold_col + 1, width):
            grid[r][c] = random.randint(1, 9)
    
    output = [[0] * (2 * fold_col) for _ in range(height)]
    
    for r in range(height):
        for c in range(fold_col):
            output[r][c] = grid[r][c]
        
        for c in range(fold_col, 2 * fold_col):
            input_col = c + 1
            orig_col = 2 * fold_col - input_col
            orig_color = grid[r][orig_col]
            folded_color = grid[r][input_col]
            
            if orig_color != 0 and folded_color != 0 and orig_color != folded_color:
                output[r][c] = 5
            else:
                output[r][c] = folded_color
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    fold_col = None
    for c in range(1, width - 1):
        if all(grid[r][c] == 0 for r in range(height)):
            fold_col = c
            break
    
    if fold_col is None:
        fold_col = width // 2
    
    output_width = 2 * fold_col
    output = [[0] * output_width for _ in range(height)]
    
    for r in range(height):
        for c in range(fold_col):
            output[r][c] = grid[r][c]
    
    for r in range(height):
        for c in range(fold_col, output_width):
            input_col = c + 1
            orig_col = 2 * fold_col - input_col
            orig_color = grid[r][orig_col]
            folded_color = grid[r][input_col]
            
            if orig_color != 0 and folded_color != 0 and orig_color != folded_color:
                output[r][c] = 5
            else:
                output[r][c] = folded_color
    
    return output
