# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: ace297d1
Difficulty: insane

=== Tags ===
- Multi exit routes
- Procedural painting
- Color modulated motion

=== Description ===
Input grids feature a complex arrangement of contiguous colored regions (1-9) on
a neutral background (0), where each region is surrounded by background cells or
other regions. The regions are interconnected through potential path corridors
defined by their color adjacency. Each color encodes a base motion direction: 1
(red) = right, 2 (blue) = up, 3 (green) = left, 4 (yellow) = down, with colors
5-9 providing additional modulation rules.   The transformation applies a
procedural painting process where paths originate from each region's center,
moving in their base direction until encountering an adjacent cell of a
different color. Upon contact, the path direction modulates according to the
adjacent cell's color: for example, a red (1) path moving right into a blue (2)
cell reverses to up motion. This modulation continues iteratively, with each
direction change determined by the color of the cell being entered. Paths are
painted using the originating region's color, extending until grid boundaries
are reached or the path becomes trapped in a loop (which is avoided by the rule
that paths never revisit cells).   Multi exit routes manifest as distinct paths
emerging from regions with complex adjacency patterns, where a single region may
generate multiple paths due to branching modulation (e.g., a red region
encountering both blue and green cells in different directions). The output grid
preserves all original region boundaries while adding the painted paths, with no
path overlapping existing regions or other paths. Background cells remain
unchanged unless painted by a path, and all paths strictly follow the color-
modulated motion rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid as make_grid, randint, continuous_creature

# direction lists for encountered colors: each color maps to one or more absolute directions (dr,dc)
color_dir_lists = {
    1: [(0,1)],    # right
    2: [(-1,0)],   # up
    3: [(0,-1)],   # left
    4: [(1,0)],    # down
    5: [(0,1),(1,0)],   # right or down (branch)
    6: [(-1,0),(0,1)],  # up or right
    7: [(0,-1),(1,0)],  # left or down
    8: [(1,0),(-1,0)],  # down or up
    9: [(0,1),(0,-1)]   # right or left
}

# base directions for region colors - use first direction in the list
base_dir = {c: dirs[0] for c, dirs in color_dir_lists.items()}

def find_center(pixels):
    # choose pixel closest to centroid (tie-breaker by row, then col)
    avg_r = sum(p[0] for p in pixels) / len(pixels)
    avg_c = sum(p[1] for p in pixels) / len(pixels)
    best = min(pixels, key=lambda p: (abs(p[0]-avg_r) + abs(p[1]-avg_c), p[0], p[1]))
    return best

def generate():
    # try multiple times if collisions or degenerate grids occur
    for attempt in range(200):
        width = randint(7, 20)
        height = randint(7, 20)
        inp = make_grid(width, height, 0)
        num_regions = randint(3, 5)
        colors = random.sample(list(range(1,10)), num_regions)
        colors.sort()  # deterministic processing order
        regions = {}
        placed_ok = True
        for color in colors:
            placed = False
            for tries in range(200):
                region_w = randint(2, min(7, width-2))
                region_h = randint(2, min(7, height-2))
                size = randint(1, max(1, region_w*region_h//2))
                shape = continuous_creature(size, region_w, region_h)
                off_r = randint(0, height - region_h)
                off_c = randint(0, width - region_w)
                abs_pixels = [(r+off_r, c+off_c) for (r,c) in shape]
                if any(inp[r][c] != 0 for (r,c) in abs_pixels):
                    continue
                # place region
                for (r,c) in abs_pixels:
                    inp[r][c] = color
                regions[color] = abs_pixels
                placed = True
                break
            if not placed:
                placed_ok = False
                break
        if not placed_ok:
            continue
        # Now paint procedural paths according to rules
        out = [row[:] for row in inp]
        painted = set()  # cells painted by paths (global)
        # iterate colors in sorted order
        for color in colors:
            pixels = regions[color]
            start = find_center(pixels)
            # stack of walkers: each element is (r,c,(dr,dc))
            stack = [(start[0], start[1], base_dir[color])]
            visited_states = set()  # (r,c,dr,dc) visited for this origin
            max_steps = width * height * 4
            steps = 0
            while stack and steps < max_steps:
                r,c,dir_t = stack.pop()
                dr,dc = dir_t
                state = (r,c,dr,dc)
                if state in visited_states:
                    continue
                visited_states.add(state)
                cur_r, cur_c = r, c
                cur_dr, cur_dc = dr, dc
                local_steps = 0
                while True:
                    steps += 1
                    local_steps += 1
                    if steps > max_steps:
                        break
                    nr = cur_r + cur_dr
                    nc = cur_c + cur_dc
                    # out of bounds -> stop this walker
                    if nr < 0 or nr >= height or nc < 0 or nc >= width:
                        break
                    cell_val = inp[nr][nc]
                    if cell_val == color:
                        # inside same region -- move through it without painting
                        cur_r, cur_c = nr, nc
                        # detect revisiting same (pos,dir)
                        s2 = (cur_r, cur_c, cur_dr, cur_dc)
                        if s2 in visited_states:
                            break
                        visited_states.add(s2)
                        continue
                    if cell_val != 0 and cell_val != color:
                        # encountered a different colored region -> modulate direction(s) but do not enter it
                        next_dirs = color_dir_lists.get(cell_val, [(cur_dr, cur_dc)])
                        for nd in next_dirs:
                            ns = (cur_r, cur_c, nd[0], nd[1])
                            if ns in visited_states:
                                continue
                            stack.append((cur_r, cur_c, nd))
                        break
                    # empty cell
                    if (nr,nc) in painted:
                        # cannot paint on already-painted cell -> stop this walker
                        break
                    # paint cell with origin color and advance
                    out[nr][nc] = color
                    painted.add((nr,nc))
                    cur_r, cur_c = nr, nc
                    # continue with same direction
                # end while inner walker
            # end while stack
        if inp != out:
            return {"input": inp, "output": out}
    raise Exception("Could not generate a nontrivial grid")



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable grid
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])
    # Same modulation rules as the generator
    color_dir_lists = {
        1: [(0,1)],    # right
        2: [(-1,0)],   # up
        3: [(0,-1)],   # left
        4: [(1,0)],    # down
        5: [(0,1),(1,0)],   # right or down (branch)
        6: [(-1,0),(0,1)],  # up or right
        7: [(0,-1),(1,0)],  # left or down
        8: [(1,0),(-1,0)],  # down or up
        9: [(0,1),(0,-1)]   # right or left
    }
    base_dir = {c: dirs[0] for c, dirs in color_dir_lists.items()}

    def find_center(pixels):
        avg_r = sum(p[0] for p in pixels) / len(pixels)
        avg_c = sum(p[1] for p in pixels) / len(pixels)
        best = min(pixels, key=lambda p: (abs(p[0]-avg_r) + abs(p[1]-avg_c), p[0], p[1]))
        return best

    out = [row[:] for row in grid_in]
    # collect colors present
    colors_present = sorted({grid_in[r][c] for r in range(height) for c in range(width) if grid_in[r][c] != 0})
    regions = {c: [] for c in colors_present}
    for r in range(height):
        for c in range(width):
            v = grid_in[r][c]
            if v != 0:
                regions[v].append((r,c))

    painted = set()
    for color in colors_present:
        pixels = regions[color]
        if not pixels:
            continue
        start = find_center(pixels)
        stack = [(start[0], start[1], base_dir[color])]
        visited_states = set()
        max_steps = width * height * 4
        steps = 0
        while stack and steps < max_steps:
            r,c,dir_t = stack.pop()
            dr,dc = dir_t
            state = (r,c,dr,dc)
            if state in visited_states:
                continue
            visited_states.add(state)
            cur_r, cur_c = r, c
            cur_dr, cur_dc = dr, dc
            while True:
                steps += 1
                if steps > max_steps:
                    break
                nr = cur_r + cur_dr
                nc = cur_c + cur_dc
                if nr < 0 or nr >= height or nc < 0 or nc >= width:
                    break
                cell_val = grid_in[nr][nc]
                if cell_val == color:
                    cur_r, cur_c = nr, nc
                    s2 = (cur_r, cur_c, cur_dr, cur_dc)
                    if s2 in visited_states:
                        break
                    visited_states.add(s2)
                    continue
                if cell_val != 0 and cell_val != color:
                    next_dirs = color_dir_lists.get(cell_val, [(cur_dr, cur_dc)])
                    for nd in next_dirs:
                        ns = (cur_r, cur_c, nd[0], nd[1])
                        if ns in visited_states:
                            continue
                        stack.append((cur_r, cur_c, nd))
                    break
                # empty cell
                if (nr,nc) in painted:
                    break
                out[nr][nc] = color
                painted.add((nr,nc))
                cur_r, cur_c = nr, nc
        # end while stack
    return out

