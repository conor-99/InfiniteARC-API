# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 88a61d72
Difficulty: very hard

=== Tags ===
- Cooperative beams

=== Description ===
Cooperative Beam Fusion  Input grids consist of a 15×15 or larger grid with
background color (0) and multiple straight-line beams. Each beam is a contiguous
horizontal or vertical line of a single non-zero color (1-9), originating from
the grid's edges and extending inward without branching. Beams may start from
any edge and travel in straight lines toward the center, potentially
intersecting with beams from perpendicular directions.  Beams of identical color
intersecting at 90-degree angles do not change, while beams of different colors
interacting at intersections trigger a color fusion rule. This fusion replaces
the intersection cell with a specific color determined by a consistent,
predefined mapping between color pairs (e.g., red + blue → green, yellow +
purple → orange). The fusion rule is deterministic but non-obvious, requiring
the solver to infer the relationship between intersecting colors from limited
examples.  In the output grid, all non-intersecting beam cells remain unchanged.
At every valid intersection (horizontal and vertical beams of different colors),
the cell is replaced with its fusion color. Cells where beams of the same color
intersect, or where beams do not cross, retain their original color. Background
cells remain unchanged throughout. The transformation requires recognizing both
the presence of beam intersections and the abstract color relationship governing
their fusion, making it challenging to discern the rule from sparse training
examples.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    # Generate grids until we produce one where at least one fusion occurs
    while True:
        width = random.randint(15, 30)
        height = random.randint(15, 30)
        input_grid = [[0 for _ in range(width)] for _ in range(height)]

        # Place horizontal beams originating from the left edge (rows 1..height-1)
        for r in range(1, height):
            if random.random() < 0.45:
                color = random.randint(1, 9)
                length = random.randint(1, max(1, width - 1))
                for c in range(length):
                    input_grid[r][c] = color

        # Place vertical beams originating from the top edge (cols 1..width-1)
        for c in range(1, width):
            if random.random() < 0.45:
                color = random.randint(1, 9)
                length = random.randint(1, max(1, height - 1))
                for r in range(length):
                    input_grid[r][c] = color

        # Detect beam colors from the visible edge pixels (solver uses same method)
        horiz_colors = [0] * height
        for r in range(height):
            if input_grid[r][0] != 0:
                horiz_colors[r] = input_grid[r][0]

        vert_colors = [0] * width
        for c in range(width):
            if input_grid[0][c] != 0:
                vert_colors[c] = input_grid[0][c]

        # Fusion rule (deterministic, symmetric, non-trivial)
        def fuse(a, b):
            return (a + b) % 9 + 1

        output_grid = [row[:] for row in input_grid]
        for r in range(height):
            for c in range(width):
                h = horiz_colors[r]
                v = vert_colors[c]
                if h != 0 and v != 0 and h != v:
                    output_grid[r][c] = fuse(h, v)

        # Ensure transformation is non-trivial (input != output)
        if input_grid != output_grid:
            return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    horiz_colors = [0] * height
    for r in range(height):
        if grid[r][0] != 0:
            horiz_colors[r] = grid[r][0]

    vert_colors = [0] * width
    for c in range(width):
        if grid[0][c] != 0:
            vert_colors[c] = grid[0][c]

    def fuse(a, b):
        return (a + b) % 9 + 1

    output = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            h = horiz_colors[r]
            v = vert_colors[c]
            if h != 0 and v != 0 and h != v:
                output[r][c] = fuse(h, v)
    return output

