# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 72bfd10d
Difficulty: easy

=== Tags ===
- Take intersection
- Color majority row
- Bounce

=== Description ===
The task involves transforming an input grid to an output grid by first
determining the majority color for each row in the input. The output grid
features a bouncing path that starts at the bottom-left corner (row = height-1,
column = 0), moving right until hitting the right edge, then bouncing left until
hitting the left edge, and repeating this pattern across the grid. Each cell
along this path in the output grid is set to the majority color of the
corresponding row in the input grid, while all other cells are set to 0.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    input_grid = []
    for _ in range(height):
        m = random.randint(1, 9)
        row = [m] * ((width + 1) // 2)
        other_colors = [random.randint(1, 9) for _ in range(width - len(row))]
        row += other_colors
        random.shuffle(row)
        input_grid.append(row)
    
    majority_colors = []
    for row in input_grid:
        counts = {}
        for color in row:
            counts[color] = counts.get(color, 0) + 1
        max_count = max(counts.values())
        for color in row:
            if counts[color] == max_count:
                majority_colors.append(color)
                break
    
    output_grid = [[0] * width for _ in range(height)]
    c = 0
    c_dir = 1
    for r in range(height - 1, -1, -1):
        output_grid[r][c] = majority_colors[r]
        c += c_dir
        if c == 0 or c == width - 1:
            c_dir = -c_dir
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output = [[0] * width for _ in range(height)]
    
    majority_colors = []
    for row in input_grid:
        counts = {}
        for color in row:
            counts[color] = counts.get(color, 0) + 1
        max_count = max(counts.values())
        for color in row:
            if counts[color] == max_count:
                majority_colors.append(color)
                break
    
    c = 0
    c_dir = 1
    for r in range(height - 1, -1, -1):
        output[r][c] = majority_colors[r]
        c += c_dir
        if c == 0 or c == width - 1:
            c_dir = -c_dir
    return output
