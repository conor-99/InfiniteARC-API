# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 6eea748e
Difficulty: medium

=== Tags ===
- Remove intruder
- Wraparound copy

=== Description ===
The input grid is a 2D grid of colors (0-9) containing exactly one "intruder"
cellâ€”a single cell with a color that differs from the dominant background color.
The output grid is generated by first replacing the intruder cell with the most
frequent color in the grid (the background color), then shifting each row to the
right by one position, with the rightmost element of each row wrapping to the
leftmost position. This transformation removes the intruder and applies a
consistent right-shift wraparound to all rows.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(2, 30)
    height = random.randint(2, 30)
    bg = random.randint(0, 9)
    intra = random.randint(0, 9)
    while intra == bg:
        intra = random.randint(0, 9)
    input_grid = [[bg] * width for _ in range(height)]
    r = random.randint(0, height-1)
    c = random.randint(0, width-1)
    input_grid[r][c] = intra
    output_grid = [row[:] for row in input_grid]
    output_grid[r][c] = bg
    for i in range(height):
        output_grid[i] = [output_grid[i][-1]] + output_grid[i][:-1]
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    flat = [cell for row in input_grid for cell in row]
    mode = max(set(flat), key=flat.count)
    output_grid = [row[:] for row in input_grid]
    for r in range(len(output_grid)):
        for c in range(len(output_grid[0])):
            if output_grid[r][c] != mode:
                output_grid[r][c] = mode
                break
        else:
            continue
        break
    for i in range(len(output_grid)):
        output_grid[i] = [output_grid[i][-1]] + output_grid[i][:-1]
    return output_grid
