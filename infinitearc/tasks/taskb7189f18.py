# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: b7189f18
Difficulty: medium

=== Tags ===
- Cylindrical
- Background filling
- Rectangle guessing

=== Description ===
The task involves transforming an input grid into an output grid by identifying
a single rectangular region that may wrap around the left and right edges of the
grid (cylindrical adjacency) and filling all background cells outside this
region with the color 5. The input grid contains a contiguous rectangular block
of non-zero values (using 4-directional adjacency with left and right edges
considered connected), while all other cells are 0 (background). The output grid
preserves the rectangle's original colors and replaces all background cells (0)
with 5. The key challenge is recognizing the rectangle's position, including
cases where it wraps around the grid's horizontal edges, and applying the
background fill consistently. This requires abstract reasoning about geometric
containment and cylindrical grid properties, making it a medium-difficulty task.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common
def generate():
    W = random.randint(1, 30)
    H = random.randint(1, 30)
    input_grid = [[0] * W for _ in range(H)]
    
    top = random.randint(0, H-1)
    bottom = random.randint(top, H-1)
    if top == 0 and bottom == H-1:
        bottom = H-2 if H > 1 else 0
    
    left = random.randint(0, W-1)
    right = random.randint(0, W-1)
    if left <= right:
        if left == 0 and right == W-1:
            right = W-2
    else:
        if left == right + 1:
            right = (right - 1) % W
    
    for r in range(top, bottom + 1):
        if left <= right:
            for c in range(left, right + 1):
                input_grid[r][c] = common.random_color()
        else:
            for c in range(left, W):
                input_grid[r][c] = common.random_color()
            for c in range(0, right + 1):
                input_grid[r][c] = common.random_color()
    
    output_grid = [[5 if cell == 0 else cell for cell in row] for row in input_grid]
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    return [[5 if cell == 0 else cell for cell in row] for row in input_grid]
