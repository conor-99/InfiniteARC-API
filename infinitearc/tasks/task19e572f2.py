# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 19e572f2
Difficulty: mediumâ€“hard

=== Tags ===
- Sequence interpolation
- Color stream
- Mirror pair coordination
- Layered occlusion unfolding
- Color matching
- Associate patterns to patterns

=== Description ===
Mirror Sequence Unfolding  Input grids feature two concentric mirrored layers
(inner and outer) arranged symmetrically around the vertical axis. Each layer
consists of a sequence of color blocks placed along the top edge (for the outer
layer) and bottom edge (for the inner layer), with the color sequence following
a cyclic pattern (e.g., red, yellow, green, blue, red, ...). The outer layer's
sequence is a mirror of the inner layer's sequence, but shifted by one position
(e.g., outer: red, yellow, green; inner: yellow, green, red). The central axis
contains a consistent color anchor that remains unchanged throughout all layers.
Additionally, the grid contains a hidden layer positioned between the visible
outer and inner layers. This hidden layer is partially occluded by a background
color, with the occlusion pattern matching the mirror symmetry of the visible
layers. The occlusion reveals only the central anchor color, while the rest of
the hidden layer appears as background.  The output grid reveals the hidden
layer by replacing the occlusion with an interpolated sequence that maintains
mirror symmetry. The interpolation follows the cyclic color sequence: for each
position in the hidden layer, the color is determined by the midpoint between
the corresponding colors in the outer and inner layer sequences (e.g., if outer
has red at position 0 and inner has yellow at position 0, the hidden layer at
position 0 would be green, the next color in the cycle). The mirror coordination
ensures the left and right halves of the hidden layer sequence are identical,
with colors continuing the cyclic pattern without repetition. All visible
elements (outer layer, inner layer, and central anchor) remain unchanged in the
output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Choose an odd grid size between 7 and 21 for variety
    width = random.choice([7, 9, 11, 13, 15, 17, 19, 21])
    height = width
    grid = [[0] * width for _ in range(height)]

    # center column anchor (non-zero)
    center = width // 2
    anchor = random.randint(1, 9)
    for r in range(height):
        grid[r][center] = anchor

    # number of blocks on each side (outward from center), at least 2
    maxL = min(6, (width - 1) // 2)
    L = random.randint(2, maxL)

    # cyclic color palette (exclude 0)
    cycle = list(range(1, 10))

    # choose a random starting index in the cycle for the outer layer
    start = random.randint(0, len(cycle) - 1)
    outer_out = [cycle[(start + i) % len(cycle)] for i in range(L)]

    # inner layer is the outer rotated by one position (shifted sequence)
    inner_out = outer_out[1:] + outer_out[:1]

    # place outer (top row) and inner (bottom row) symmetrically outward from center
    for i in range(1, L + 1):
        col_left = center - i
        col_right = center + i
        grid[0][col_left] = outer_out[i - 1]
        grid[0][col_right] = outer_out[i - 1]
        grid[-1][col_left] = inner_out[i - 1]
        grid[-1][col_right] = inner_out[i - 1]

    # input grid: hidden layer (center row) is occluded except the central anchor
    # (grid already has zeros elsewhere so nothing else to do)

    # build output by revealing the hidden layer: the hidden color is the next color after the inner
    output = [row[:] for row in grid]
    center_row = height // 2
    hidden_out = []
    for i in range(L):
        inner_color = inner_out[i]
        idx = cycle.index(inner_color)
        hidden_color = cycle[(idx + 1) % len(cycle)]
        hidden_out.append(hidden_color)

    # fill the output center row symmetrically (left and right halves identical outward)
    for i in range(1, L + 1):
        output[center_row][center - i] = hidden_out[i - 1]
        output[center_row][center + i] = hidden_out[i - 1]

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Find the central anchor column: the column where every cell has the same non-zero value
    anchor_col = None
    for c in range(width):
        col_vals = [grid[r][c] for r in range(height)]
        if col_vals[0] != 0 and all(v == col_vals[0] for v in col_vals):
            anchor_col = c
            break
    if anchor_col is None:
        # fallback to true center if not found
        anchor_col = width // 2

    center_row = height // 2

    # Determine how many blocks (L) are placed outward from the center by scanning top row left of center
    L = 0
    c = anchor_col - 1
    while c >= 0 and grid[0][c] != 0:
        L += 1
        c -= 1

    # Reconstruct the inner (bottom) outward sequence and compute hidden colors
    cycle = list(range(1, 10))
    inner_out = [grid[-1][anchor_col - i] for i in range(1, L + 1)]

    hidden_out = []
    for color in inner_out:
        idx = cycle.index(color)
        hidden_out.append(cycle[(idx + 1) % len(cycle)])

    # Fill the center row symmetrically with the hidden sequence
    for i in range(1, L + 1):
        color = hidden_out[i - 1]
        grid[center_row][anchor_col - i] = color
        grid[center_row][anchor_col + i] = color

    return tuple(tuple(row) for row in grid)

