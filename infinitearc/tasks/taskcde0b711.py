# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: cde0b711
Difficulty: hard

=== Tags ===
- Paint by distance to line

=== Description ===
The task involves transforming an input grid into an output grid based on the
Manhattan distance from each cell to the nearest cell forming a continuous line.
The input grid contains a single connected line (a contiguous sequence of cells
with a specific color, connected via edge-sharing) that serves as the reference.
The output grid assigns each cell a color value between 0 and 9, where 0
corresponds to cells on the line itself, and higher values indicate increasing
distance from the line. The scaling is deterministic: for a given input grid,
the maximum Manhattan distance to the line is calculated, and each cell's
distance is scaled proportionally to the range 0–9 using integer division
(distance × 9 ÷ max_distance). This requires identifying the line's connected
component, computing distances, and applying the scaling rule, making the task
challenging due to the need for precise distance calculation and scaling
relative to the input's structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    from common import continuous_creature
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    line_size = random.randint(5, 20)
    pixels = continuous_creature(line_size, width, height)
    input_grid = [[0] * width for _ in range(height)]
    for (r, c) in pixels:
        if r < height and c < width:
            input_grid[r][c] = 1
    distances = [[10**9] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            min_dist = 10**9
            for (r_line, c_line) in pixels:
                dist = abs(r - r_line) + abs(c - c_line)
                if dist < min_dist:
                    min_dist = dist
            distances[r][c] = min_dist
    max_dist = max(max(row) for row in distances)
    if max_dist == 0:
        return generate()
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            output_grid[r][c] = (distances[r][c] * 9) // max_dist
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    line_color = 1
    line_cells = []
    height = len(input_grid)
    width = len(input_grid[0])
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == line_color:
                line_cells.append((r, c))
    if not line_cells:
        return input_grid
    distances = [[10**9] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            min_dist = 10**9
            for (r_line, c_line) in line_cells:
                dist = abs(r - r_line) + abs(c - c_line)
                if dist < min_dist:
                    min_dist = dist
            distances[r][c] = min_dist
    max_dist = max(max(row) for row in distances)
    if max_dist == 0:
        return input_grid
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            output_grid[r][c] = (distances[r][c] * 9) // max_dist
    return output_grid
