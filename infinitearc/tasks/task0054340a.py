# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 0054340a
Difficulty: hard

=== Tags ===
- Pattern concatenation
- Rule gate simulation
- Energy absorption
- Alternating rule composition

=== Description ===
Input grids are 25×25 with a uniform background color (0). Overlaid are three
distinct element types: **emitter clusters**, **gate sequences**, and **absorber
rows**. Emitter clusters consist of 3×1 vertical blocks of color 1 positioned
along the left edge (rows 3–5, column 0; rows 12–14, column 0; rows 20–22,
column 0), each emitting a horizontal pattern of color 1 extending rightward.
Gate sequences are vertical columns (1 cell wide, 5–7 cells tall) of colors 2–5
placed at columns 5, 10, 15, and 20. Each gate color corresponds to a rule:
color 2 (horizontal mirror), color 3 (color inversion), color 4 (pattern shift
right), color 5 (pattern shift left). These rules apply **alternatingly** per
gate encountered (starting with color 2’s rule for the first gate, then color 3,
then color 2, etc.). Absorber rows are horizontal segments (1 cell tall, 3–5
cells wide) of colors 6–9 positioned at rows 7, 17, and 23, spanning columns
22–24.   The transformation process begins with the horizontal pattern emitted
from each cluster. As the pattern passes through each gate column, the
corresponding rule is applied in sequence (e.g., mirror → invert → shift right →
mirror), with the rule type alternating per gate. Patterns are **not**
overwritten by gates but are transformed *in place* (e.g., mirror flips the
pattern horizontally, inversion swaps colors 1↔2, shift moves the pattern within
its row). Upon reaching an absorber row, the pattern’s final color is
**absorbed** (the absorber’s color changes to the pattern’s current color), and
the pattern ceases to exist. The output grid preserves all emitters and gates
unchanged but updates absorber colors to reflect the final absorbed color.
Patterns are removed from the grid (no residual lines), and no two patterns
interact—each emitter’s path is processed independently. The task requires
detecting the alternating rule sequence, tracking pattern transformations
through multiple gates, and applying energy absorption to the correct absorbers.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = 25
    height = 25
    grid = common.grid(width, height, 0)
    
    # Emitters
    for r in range(3,6):
        grid[r][0] = 1
    for r in range(12,15):
        grid[r][0] = 1
    for r in range(20,23):
        grid[r][0] = 1
    
    gate_cols = [5, 10, 15, 20]
    gate_colors = [random.choice([2, 3, 4, 5]) for _ in range(4)]
    
    for idx, col in enumerate(gate_cols):
        color = gate_colors[idx]
        start_row = random.randint(0, height - 5)
        for r in range(start_row, start_row + random.randint(5, 7)):
            if r < height:
                grid[r][col] = color
    
    absorber_rows = [7, 17, 23]
    absorber_colors = random.sample([6,7,8,9], 3)
    for i, row in enumerate(absorber_rows):
        for col in range(22, 25):
            grid[row][col] = absorber_colors[i]
    
    output = [row[:] for row in grid]
    count_3 = gate_colors.count(3)
    final_color = 2 if count_3 % 2 == 1 else 1
    for row in absorber_rows:
        for col in range(22, 25):
            output[row][col] = final_color
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    gate_cols = [5, 10, 15, 20]
    absorber_rows = [7, 17, 23]
    
    gate_colors = []
    for col in gate_cols:
        for r in range(len(grid)):
            if grid[r][col] != 0:
                gate_colors.append(grid[r][col])
                break
        else:
            gate_colors.append(2)  
    
    count_3 = gate_colors.count(3)
    final_color = 2 if count_3 % 2 == 1 else 1
    
    for row in absorber_rows:
        for col in range(22, 25):
            grid[row][col] = final_color
    
    return grid
