# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: b4791832
Difficulty: insane

=== Tags ===
- Color clock
- Truth table visualization
- Shape morphing
- Detect wall

=== Description ===
Input grids contain a central circular clock composed of 12 contiguous colored
cells arranged in a ring, where each color represents a position in a cyclic
sequence. Adjacent to the clock is a 3Ã—3 truth table grid, where each cell's
color visualizes a logical state (e.g., red = true, blue = false), derived from
the spatial relationships between geometric shapes in the main grid. The main
grid features a complex arrangement of squares, triangles, and other shapes on a
background, separated by contiguous wall regions (colored with a consistent
background hue). Walls form non-rectangular barriers that block transformations
and are detectable via their contiguous background color and adjacency to non-
background shapes.  The output grid must apply four interdependent rules in
sequence: (1) rotate the clock ring clockwise by one position (shifting each
color to the next ring position), (2) for each truth table cell colored red,
morph the corresponding geometric shape in the main grid (e.g., squares become
triangles, triangles become circles), (3) detect all wall regions (contiguous
background-colored areas fully enclosed by non-background cells) and ensure no
morphing occurs within or adjacent to walls, and (4) preserve all non-morphed
shapes, walls, and the truth table's color-based logic. Morphing must respect
spatial constraints: a shape can only change if its target cell is non-wall and
not adjacent to a wall, with all transformations applied simultaneously without
overlap. The background color remains unchanged, and all operations are strictly
deterministic based on visual color relationships and spatial configuration.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import hollow_conway

def is_adjacent_to_wall(grid, r, c, wall_color):
    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
        nr, nc = r + dr, c + dc
        if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]):
            if grid[nr][nc] == wall_color:
                return True
    return False

def generate():
    size = 25
    grid = [[0]*size for _ in range(size)]
    
    wall_rows, wall_cols = hollow_conway(10, 10, 5)
    for r, c in zip(wall_rows, wall_cols):
        grid[r+5][c+5] = 5
    
    shape_colors = [random.choice([1,2,3]) for _ in range(9)]
    for i in range(3):
        for j in range(3):
            r = 6 + i*3
            c = 6 + j*3
            grid[r][c] = shape_colors[i*3 + j]
    
    truth_table = [[0]*3 for _ in range(3)]
    for i in range(3):
        for j in range(3):
            if shape_colors[i*3 + j] == 1:
                truth_table[i][j] = 2
            else:
                truth_table[i][j] = 3
    
    for i in range(3):
        for j in range(3):
            grid[i][j] = truth_table[i][j]
    
    ring_positions = [
        (12, 14), (14, 12), (12, 10), (10, 12),
        (13, 14), (14, 13), (14, 11), (13, 10),
        (11, 10), (10, 11), (10, 13), (11, 14)
    ]
    clock_colors = [random.choice(range(1,10)) for _ in range(12)]
    for idx, (r, c) in enumerate(ring_positions):
        grid[r][c] = clock_colors[idx]
    
    output = [row[:] for row in grid]
    rotated_clock = [clock_colors[-1]] + clock_colors[:-1]
    for idx, (r, c) in enumerate(ring_positions):
        output[r][c] = rotated_clock[idx]
    
    for i in range(3):
        for j in range(3):
            if truth_table[i][j] == 2:
                r_shape = 6 + i*3
                c_shape = 6 + j*3
                if not is_adjacent_to_wall(grid, r_shape, c_shape, 5):
                    current_color = grid[r_shape][c_shape]
                    if current_color == 1:
                        new_color = 2
                    elif current_color == 2:
                        new_color = 3
                    else:
                        new_color = 1
                    output[r_shape][c_shape] = new_color
    
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def is_adjacent_to_wall(grid, r, c, wall_color):
    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
        nr, nc = r + dr, c + dc
        if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]):
            if grid[nr][nc] == wall_color:
                return True
    return False

def p(input_grid):
    grid = [list(row) for row in input_grid]
    truth_table = [[grid[i][j] for j in range(3)] for i in range(3)]
    ring_positions = [
        (12, 14), (14, 12), (12, 10), (10, 12),
        (13, 14), (14, 13), (14, 11), (13, 10),
        (11, 10), (10, 11), (10, 13), (11, 14)
    ]
    clock_colors = [grid[r][c] for r, c in ring_positions]
    rotated_clock = [clock_colors[-1]] + clock_colors[:-1]
    for idx, (r, c) in enumerate(ring_positions):
        grid[r][c] = rotated_clock[idx]
    
    for i in range(3):
        for j in range(3):
            if truth_table[i][j] == 2:
                r_shape = 6 + i*3
                c_shape = 6 + j*3
                if not is_adjacent_to_wall(grid, r_shape, c_shape, 5):
                    current_color = grid[r_shape][c_shape]
                    if current_color == 1:
                        new_color = 2
                    elif current_color == 2:
                        new_color = 3
                    else:
                        new_color = 1
                    grid[r_shape][c_shape] = new_color
    
    return tuple(tuple(row) for row in grid)
