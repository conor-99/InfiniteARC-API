# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: e41f4724
Difficulty: hard

=== Tags ===
- Energy field diffusion
- Trail memory
- Multi object alignment
- Connect the dots
- Count different colors

=== Description ===
Input grids feature a background color (0) and multiple colored energy sources
(1-9), each representing a distinct diffusion field. Each source's color
corresponds to a fixed direction: red (1) diffuses right, blue (2) diffuses
down, green (3) diffuses left, yellow (4) diffuses up, purple (5) diffuses
northeast, cyan (6) diffuses southeast, magenta (7) diffuses southwest, orange
(8) diffuses northwest, and maroon (9) diffuses right. Diffusion spreads cell-
by-cell in the source's direction until hitting a non-background cell or grid
boundary. The trail memory (last cell of each diffusion path) is preserved as a
point in the output grid. The output must connect all trail memory points with a
polygon whose side count equals the number of distinct source colors in the
input. The polygon is formed by sorting trail points lexicographically (top-to-
bottom, left-to-right) and connecting them sequentially with straight lines,
using a fixed color (e.g., 9) that does not overlap with existing elements.
Diffusion paths are not visible in the output beyond the trail memory points,
and the polygon must be convex with no self-intersections.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, all_pixels, choices, randint

def generate():
    w = randint(1, 30)
    h = randint(1, 30)
    input_grid = grid(w, h, 0)
    
    # Select 3-5 distinct source colors
    num_sources = randint(3, 5)
    source_colors = random.sample(range(1, 10), num_sources)
    
    # Directions mapping
    directions = {
        1: (0, 1),  # right
        2: (1, 0),  # down
        3: (0, -1), # left
        4: (-1, 0), # up
        5: (-1, 1), # northeast
        6: (1, 1),  # southeast
        7: (1, -1), # southwest
        8: (-1, -1),# northwest
        9: (0, 1)   # right
    }
    
    # Place sources at unique positions
    positions = []
    for color in source_colors:
        while True:
            r = randint(0, h-1)
            c = randint(0, w-1)
            if input_grid[r][c] == 0:
                input_grid[r][c] = color
                positions.append((r, c))
                break
    
    # Compute trail points
    trail_points = []
    for i, color in enumerate(source_colors):
        dr, dc = directions[color]
        r, c = positions[i]
        cur_r, cur_c = r, c
        while True:
            nr, nc = cur_r + dr, cur_c + dc
            if not (0 <= nr < h and 0 <= nc < w) or input_grid[nr][nc] != 0:
                break
            cur_r, cur_c = nr, nc
        trail_points.append((cur_r, cur_c))
    
    # Ensure unique trail points
    if len(trail_points) != len(set(trail_points)):
        # Retry placement (simplified for brevity)
        return generate()
    
    # Sort trail points lex
    trail_points.sort(key=lambda p: (p[0], p[1]))
    
    # Create output grid
    output_grid = [row[:] for row in input_grid]
    
    # Draw polygon lines
    n = len(trail_points)
    for i in range(n):
        r1, c1 = trail_points[i]
        r2, c2 = trail_points[(i+1) % n]
        dx = r2 - r1
        dy = c2 - c1
        steps = max(abs(dx), abs(dy))
        if steps == 0:
            continue
        x_step = dx / steps
        y_step = dy / steps
        for step in range(steps):
            x = r1 + int(x_step * step)
            y = c1 + int(y_step * step)
            if 0 <= x < h and 0 <= y < w:
                output_grid[x][y] = 9
    
    return {
        'input': input_grid,
        'output': output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])
    
    # Directions mapping
    directions = {
        1: (0, 1),
        2: (1, 0),
        3: (0, -1),
        4: (-1, 0),
        5: (-1, 1),
        6: (1, 1),
        7: (1, -1),
        8: (-1, -1),
        9: (0, 1)
    }
    
    # Find all sources (color 1-9)
    sources = []
    for r in range(h):
        for c in range(w):
            if 1 <= grid[r][c] <= 9:
                sources.append((r, c, grid[r][c]))
    
    # Compute trail points
    trail_points = []
    for r, c, color in sources:
        dr, dc = directions[color]
        cur_r, cur_c = r, c
        while True:
            nr, nc = cur_r + dr, cur_c + dc
            if not (0 <= nr < h and 0 <= nc < w) or grid[nr][nc] != 0:
                break
            cur_r, cur_c = nr, nc
        trail_points.append((cur_r, cur_c))
    
    # Sort lex
    trail_points.sort(key=lambda p: (p[0], p[1]))
    
    # Draw polygon lines
    n = len(trail_points)
    for i in range(n):
        r1, c1 = trail_points[i]
        r2, c2 = trail_points[(i+1) % n]
        dx = r2 - r1
        dy = c2 - c1
        steps = max(abs(dx), abs(dy))
        if steps == 0:
            continue
        x_step = dx / steps
        y_step = dy / steps
        for step in range(steps):
            x = r1 + int(x_step * step)
            y = c1 + int(y_step * step)
            if 0 <= x < h and 0 <= y < w:
                grid[x][y] = 9
    
    return tuple(tuple(row) for row in grid)
