# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: c6f53b46
Difficulty: medium

=== Tags ===
- Take maximum
- Color permutation
- Homeomorphism

=== Description ===
The task involves transforming an input grid of integers (0-9) where non-zero
values represent colored cells. First, connected components of non-zero cells
are identified using 4-directional connectivity (up, down, left, right). For
each component, the maximum color value within that component is determined. A
fixed color permutation rule (e.g., incrementing each color by 1 modulo 10) is
applied to this maximum value. The output grid is constructed by replacing every
cell in each component with the permuted maximum color. This process preserves
the topological structure of the components (homeomorphism), as the spatial
arrangement of cells remains unchangedâ€”only the color values are transformed
through the maximum value extraction and permutation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    size = random.randint(3, 15)
    if size > width * height:
        size = width * height
    pixels = common.continuous_creature(size, width, height)
    if not pixels:
        return generate()
    colors = [random.randint(1, 9) for _ in range(len(pixels))]
    input_grid = [[0] * width for _ in range(height)]
    for (r, c), color in zip(pixels, colors):
        input_grid[r][c] = color
    max_color = max(colors)
    permuted = (max_color + 1) % 10
    output_grid = [row[:] for row in input_grid]
    for (r, c) in pixels:
        output_grid[r][c] = permuted
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    rows = len(input_grid)
    cols = len(input_grid[0])
    visited = [[False] * cols for _ in range(rows)]
    output_grid = [list(row) for row in input_grid]
    for r in range(rows):
        for c in range(cols):
            if input_grid[r][c] > 0 and not visited[r][c]:
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and input_grid[nr][nc] > 0:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                colors = [input_grid[cr][cc] for cr, cc in component]
                max_color = max(colors)
                permuted = (max_color + 1) % 10
                for (cr, cc) in component:
                    output_grid[cr][cc] = permuted
    return output_grid
