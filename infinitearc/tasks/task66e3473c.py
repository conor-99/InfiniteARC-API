# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 66e3473c
Difficulty: hard

=== Tags ===
- Dual source paths
- Cascade fountain
- Procedural painting
- Energy absorption

=== Description ===
Input grids feature a grid with two distinct colored sources (e.g., red at top-
left, blue at top-right) and a "cascade fountain" structure composed of gray
absorption nodes arranged in a descending diagonal path that starts near the top
and extends to the bottom. The cascade path is structured such that each node is
positioned one cell down and one cell to the right from the previous, forming a
diagonal staircase. Additionally, the grid contains background cells (e.g.,
white) and scattered obstacles (e.g., black cells) that block energy flow.  The
transformation rule involves two parallel energy flows: 1. From the red source,
energy flows strictly downward until it encounters the first absorption node in
its path. Upon contact, the node changes to red, and the energy continues
flowing downward from that node. 2. Similarly, from the blue source, energy
flows strictly downward, changing the first absorption node it encounters to
blue, and continuing from there. 3. If an absorption node lies on both energy
paths (i.e., the diagonal path intersects both source columns), the node is
colored by the source that reaches it first (determined by the vertical
distance: the source closer to the node's row is considered first). 4. The
output grid visually represents all activated absorption nodes along both paths,
with their colors matching the respective source. All non-absorption nodes and
obstacles remain unchanged.  The task requires correctly identifying the
absorption node paths, determining the order of activation for intersecting
nodes, and applying the color transformation to the output grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    grid = [[0] * width for _ in range(height)]
    
    max_start = min(5, width // 2 - 1)
    start_col = random.randint(2, max_start)
    left_col = random.randint(start_col + 1, width // 2)
    right_col = random.randint(width // 2 + 1, width - 2)
    
    for r in range(height):
        c = r + start_col
        if c < width:
            grid[r][c] = 5
    
    grid[0][left_col] = 2
    grid[0][right_col] = 3
    
    obstacle_count = random.randint(5, 15)
    for _ in range(obstacle_count):
        while True:
            r = random.randint(0, height - 1)
            c = random.randint(0, width - 1)
            if grid[r][c] == 0 and (r, c) != (0, left_col) and (r, c) != (0, right_col):
                if c != r + start_col:
                    grid[r][c] = 1
                    break
    
    output = [row[:] for row in grid]
    for r in range(height):
        c = r + start_col
        if c < width:
            if c == left_col:
                output[r][c] = 2
            elif c == right_col:
                output[r][c] = 3
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    
    left_col = None
    right_col = None
    for c in range(width):
        if grid[0][c] == 2:
            left_col = c
        elif grid[0][c] == 3:
            right_col = c
    
    if left_col is None or right_col is None:
        left_col = 0
        right_col = width - 1
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 5:
                if c == left_col:
                    grid[r][c] = 2
                elif c == right_col:
                    grid[r][c] = 3
    return tuple(tuple(row) for row in grid)
