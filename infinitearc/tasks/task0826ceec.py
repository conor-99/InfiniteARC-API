# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 0826ceec
Difficulty: very hard

=== Tags ===
- Pattern modification
- Momentum transfer
- Permute columns by length
- Image within image

=== Description ===
Input grids are 25×25 with background color 0. Each grid contains multiple
vertical columns of colored blocks (colors 1–9), where each column's height
(number of non-background cells) varies. A 5×5 embedded image (image within
image) is positioned at the center of the grid, composed of colors 1–9 and
background 0. The embedded image's color pattern forms a directional lattice:
each cell's color encodes a movement vector (e.g., color 1 = ↗, color 2 = ↘,
color 3 = ↙, color 4 = ↖), with the center cell of the embedded image
determining the primary momentum transfer direction.  To generate the output
grid: 1. **Permute columns by length**: Columns are sorted in descending order
based on their height (number of blocks). Columns with equal height retain their
original left-to-right order. 2. **Apply momentum transfer**: After permutation,
each column undergoes directional movement based on the embedded image's center
color (C). Blocks move toward the direction corresponding to C (e.g., C=1 →
diagonal up-right). During movement, if two blocks collide (e.g., a block moving
up-right encounters a block moving down-left), they undergo momentum transfer:
their colors swap, and the direction adjusts to the new color's vector. Blocks
wrap around grid edges during movement. 3. **Modify embedded image**: The
embedded image's top row is replaced with the colors of the topmost blocks from
the first three permuted columns (left-to-right order), preserving the embedded
image's 5×5 structure.  The output grid retains all background elements, with
columns permuted, blocks shifted via momentum transfer (with color swaps on
collision), and the embedded image updated to reflect the topmost block colors
of the first three columns.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = 25
    height = 25
    grid = [[0] * width for _ in range(height)]
    
    # Create vertical columns with random heights
    for c in range(width):
        height_col = random.randint(1, height)
        for r in range(height_col):
            grid[r][c] = random.randint(1, 9)

    # Embed 5x5 directional image at center
    embed_start = 10
    for i in range(5):
        for j in range(5):
            r = embed_start + i
            c = embed_start + j
            if i == 2 and j == 2:
                C = random.randint(1, 4)
                grid[r][c] = C
            else:
                grid[r][c] = random.choice([0, 1, 2, 3, 4])

    # Compute column heights
    col_heights = [sum(1 for r in range(height) if grid[r][c] != 0) for c in range(width)]
    sorted_cols = sorted(range(width), key=lambda c: -col_heights[c])
    
    # Create permuted grid
    permuted = [[0] * width for _ in range(height)]
    for new_col, old_col in enumerate(sorted_cols):
        for r in range(height):
            permuted[r][new_col] = grid[r][old_col]

    # Apply momentum transfer
    directions = {
        1: (-1, 1),
        2: (1, 1),
        3: (1, -1),
        4: (-1, -1)
    }
    dr, dc = directions[grid[12][12]]
    new_grid = [[0] * width for _ in range(height)]
    blocks = []
    for r in range(height):
        for c in range(width):
            if permuted[r][c] != 0:
                new_r = (r + dr) % height
                new_c = (c + dc) % width
                blocks.append((new_r, new_c, permuted[r][c]))
    
    # Resolve collisions
    position_blocks = {}
    for (r, c, color) in blocks:
        position_blocks.setdefault((r, c), []).append(color)
    for (r, c), colors in position_blocks.items():
        if len(colors) > 1:
            colors[0], colors[1] = colors[1], colors[0]
        new_grid[r][c] = colors[0] if colors else 0

    # Update embedded image top row
    top_colors = [permuted[0][col] for col in sorted_cols[:3]]
    for i in range(5):
        if i < len(top_colors):
            new_grid[embed_start][embed_start + i] = top_colors[i]
        else:
            new_grid[embed_start][embed_start + i] = 0

    return {
        "input": [row[:] for row in grid],
        "output": [row[:] for row in new_grid]
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    C = grid[12][12]
    
    directions = {
        1: (-1, 1),
        2: (1, 1),
        3: (1, -1),
        4: (-1, -1)
    }
    dr, dc = directions[C]
    
    # Compute column heights
    col_heights = [sum(1 for r in range(height) if grid[r][c] != 0) for c in range(width)]
    sorted_cols = sorted(range(width), key=lambda c: -col_heights[c])
    
    # Create permuted grid
    permuted = [[0] * width for _ in range(height)]
    for new_col, old_col in enumerate(sorted_cols):
        for r in range(height):
            permuted[r][new_col] = grid[r][old_col]
    
    # Apply momentum transfer
    new_grid = [[0] * width for _ in range(height)]
    blocks = []
    for r in range(height):
        for c in range(width):
            if permuted[r][c] != 0:
                new_r = (r + dr) % height
                new_c = (c + dc) % width
                blocks.append((new_r, new_c, permuted[r][c]))
    
    # Resolve collisions
    pos_blocks = {}
    for (r, c, color) in blocks:
        pos_blocks.setdefault((r, c), []).append(color)
    for (r, c), colors in pos_blocks.items():
        if len(colors) > 1:
            colors[0], colors[1] = colors[1], colors[0]
        new_grid[r][c] = colors[0]
    
    # Update embedded image top row
    top_colors = [permuted[0][col] for col in sorted_cols[:3]]
    embed_start = 10
    for i in range(5):
        if i < len(top_colors):
            new_grid[embed_start][embed_start + i] = top_colors[i]
        else:
            new_grid[embed_start][embed_start + i] = 0
    
    return tuple(tuple(row) for row in new_grid)
