# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 09b26d74
Difficulty: hard

=== Tags ===
- Route switching
- Directional routing
- Guided flow
- Local symmetry matching
- Recolor

=== Description ===
Input grids feature a background color (0) and multiple continuous colored paths
(1-8), each forming a connected sequence of cells moving horizontally or
vertically. Certain cells along these paths are marked as "switch points" (color
9), indicating where the path must change direction based on the local symmetry
of their four adjacent cells (up, down, left, right).   For each switch point: -
If the left and right adjacent cells share the same color (horizontal symmetry),
the path direction changes to vertical (e.g., horizontal → vertical movement). -
If the top and bottom adjacent cells share the same color (vertical symmetry),
the path direction changes to horizontal (e.g., vertical → horizontal movement).
- If both symmetries coexist, the path direction changes to vertical.  After
direction switching, the path segment following the switch point is recolored to
a new color (2), while all other elements remain unchanged. The output grid
reflects all direction switches and recoloring at every switch point, requiring
the solver to identify symmetry conditions, infer direction changes, and apply
color transformations sequentially across the grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Grid size
    width = random.randint(6, 20)
    height = random.randint(6, 20)
    # Initialize background
    ingrid = grid(width, height, 0)

    # Colors to use for paths/guides (reserve 2 for recolor and 9 for switches)
    colors = [1, 3, 4, 5, 6, 7, 8]

    # Choose a few full rows and columns (at least one each to create intersections)
    max_rows = min(3, max(1, height - 2))
    max_cols = min(3, max(1, width - 2))
    row_count = random.randint(1, max_rows)
    col_count = random.randint(1, max_cols)

    # Pick distinct row and column indices away from edges so neighbors exist
    row_positions = random.sample(range(1, height - 1), row_count)
    col_positions = random.sample(range(1, width - 1), col_count)

    # Assign unique colors to each row and column (avoid color 2 and 9)
    avail = colors[:]
    random.shuffle(avail)
    row_colors = [avail[i % len(avail)] for i in range(row_count)]
    # Rotate avail for columns to allow reuse but reduce collisions
    random.shuffle(avail)
    col_colors = [avail[i % len(avail)] for i in range(col_count)]

    # Fill rows across the whole width
    for r, col in zip(row_positions, row_colors):
        for c in range(width):
            ingrid[r][c] = col

    # Fill columns but avoid overwriting rows (rows dominate intersections)
    for ci, c in enumerate(col_positions):
        # Split the column into a few segments so top/bottom neighbors can differ
        max_segments = min(3, max(1, height // 2))
        seg_count = random.randint(1, max_segments)
        # Create segment boundaries
        if seg_count == 1:
            segments = [(0, height - 1)]
        else:
            cuts = sorted(random.sample(range(1, height), seg_count - 1))
            starts = [0] + cuts
            ends = [x - 1 for x in cuts] + [height - 1]
            segments = list(zip(starts, ends))
        for seg_idx, (rs, re) in enumerate(segments):
            seg_color = col_colors[seg_idx % len(col_colors)]
            for r in range(rs, re + 1):
                if ingrid[r][c] == 0:
                    ingrid[r][c] = seg_color

    # Collect candidate switch positions (must be on a colored path and have at least one symmetry)
    candidates = []
    for r in range(1, height - 1):
        for c in range(1, width - 1):
            if ingrid[r][c] == 0:
                continue
            left = ingrid[r][c - 1]
            right = ingrid[r][c + 1]
            top = ingrid[r - 1][c]
            bottom = ingrid[r + 1][c]
            horizontal_sym = (left == right) and (left not in (0, 9))
            vertical_sym = (top == bottom) and (top not in (0, 9))
            if not horizontal_sym and not vertical_sym:
                continue
            # Ensure there is a recolorable segment in the symmetry-determined direction
            ok = False
            if horizontal_sym:
                # new direction would be vertical -> need a non-zero neighbor vertically
                if (r + 1 < height and ingrid[r + 1][c] not in (0, 9)) or (r - 1 >= 0 and ingrid[r - 1][c] not in (0, 9)):
                    ok = True
            if vertical_sym:
                # new direction would be horizontal -> need a non-zero neighbor horizontally
                if (c + 1 < width and ingrid[r][c + 1] not in (0, 9)) or (c - 1 >= 0 and ingrid[r][c - 1] not in (0, 9)):
                    ok = True
            if ok:
                candidates.append((r, c))

    # If for some reason no candidates were found (very unlikely), force-create one by ensuring
    # there is at least one row and one column and picking one of their intersections.
    if not candidates:
        # Ensure there is at least one row and column
        r = row_positions[0]
        c = col_positions[0]
        candidates = [(r, c)]

    # Choose a small number of switch points
    switch_count = random.randint(1, min(3, len(candidates)))
    switches = random.sample(candidates, switch_count)

    # Place switch markers (9)
    for r, c in switches:
        ingrid[r][c] = 9

    # Create the output by applying the switching rules in reading order (deterministic)
    outgrid = [row[:] for row in ingrid]
    for r in range(height):
        for c in range(width):
            if ingrid[r][c] != 9:
                continue
            left = ingrid[r][c - 1]
            right = ingrid[r][c + 1]
            top = ingrid[r - 1][c]
            bottom = ingrid[r + 1][c]
            horizontal_sym = (left == right) and (left not in (0, 9))
            vertical_sym = (top == bottom) and (top not in (0, 9))
            # Prefer vertical when both symmetries exist
            if horizontal_sym and vertical_sym:
                newdir = 'vertical'
            elif horizontal_sym:
                newdir = 'vertical'
            elif vertical_sym:
                newdir = 'horizontal'
            else:
                continue

            if newdir == 'vertical':
                # Prefer downward recolor, otherwise upward
                if r + 1 < height and ingrid[r + 1][c] not in (0, 9):
                    start_color = ingrid[r + 1][c]
                    r2 = r + 1
                    while r2 < height and ingrid[r2][c] == start_color:
                        outgrid[r2][c] = 2
                        r2 += 1
                elif r - 1 >= 0 and ingrid[r - 1][c] not in (0, 9):
                    start_color = ingrid[r - 1][c]
                    r2 = r - 1
                    while r2 >= 0 and ingrid[r2][c] == start_color:
                        outgrid[r2][c] = 2
                        r2 -= 1
            else:  # horizontal
                # Prefer rightward recolor, otherwise leftward
                if c + 1 < width and ingrid[r][c + 1] not in (0, 9):
                    start_color = ingrid[r][c + 1]
                    c2 = c + 1
                    while c2 < width and ingrid[r][c2] == start_color:
                        outgrid[r][c2] = 2
                        c2 += 1
                elif c - 1 >= 0 and ingrid[r][c - 1] not in (0, 9):
                    start_color = ingrid[r][c - 1]
                    c2 = c - 1
                    while c2 >= 0 and ingrid[r][c2] == start_color:
                        outgrid[r][c2] = 2
                        c2 -= 1

    return {'input': ingrid, 'output': outgrid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0]) if height > 0 else 0

    # Work on a copy for the output; use the original state (grid_in) to determine segments
    out = [row[:] for row in grid_in]

    for r in range(height):
        for c in range(width):
            if grid_in[r][c] != 9:
                continue
            left = grid_in[r][c - 1] if c - 1 >= 0 else 0
            right = grid_in[r][c + 1] if c + 1 < width else 0
            top = grid_in[r - 1][c] if r - 1 >= 0 else 0
            bottom = grid_in[r + 1][c] if r + 1 < height else 0
            horizontal_sym = (left == right) and (left not in (0, 9))
            vertical_sym = (top == bottom) and (top not in (0, 9))

            # Both symmetries -> choose vertical
            if horizontal_sym and vertical_sym:
                newdir = 'vertical'
            elif horizontal_sym:
                newdir = 'vertical'
            elif vertical_sym:
                newdir = 'horizontal'
            else:
                continue

            if newdir == 'vertical':
                # Prefer downward recolor
                if r + 1 < height and grid_in[r + 1][c] not in (0, 9):
                    start_color = grid_in[r + 1][c]
                    r2 = r + 1
                    while r2 < height and grid_in[r2][c] == start_color:
                        out[r2][c] = 2
                        r2 += 1
                elif r - 1 >= 0 and grid_in[r - 1][c] not in (0, 9):
                    start_color = grid_in[r - 1][c]
                    r2 = r - 1
                    while r2 >= 0 and grid_in[r2][c] == start_color:
                        out[r2][c] = 2
                        r2 -= 1
            else:  # horizontal
                if c + 1 < width and grid_in[r][c + 1] not in (0, 9):
                    start_color = grid_in[r][c + 1]
                    c2 = c + 1
                    while c2 < width and grid_in[r][c2] == start_color:
                        out[r][c2] = 2
                        c2 += 1
                elif c - 1 >= 0 and grid_in[r][c - 1] not in (0, 9):
                    start_color = grid_in[r][c - 1]
                    c2 = c - 1
                    while c2 >= 0 and grid_in[r][c2] == start_color:
                        out[r][c2] = 2
                        c2 -= 1

    return out

