# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: bae29ff9
Difficulty: insane

=== Tags ===
- Laser diffusion
- Field based motion
- Pattern activation
- Image resizing
- Place dot in object center

=== Description ===
Input grids consist of a uniform background color (0) overlaid with multiple
distinct, non-overlapping, and connected objects (each defined by a single color
between 1 and 8) arranged in a complex spatial configuration. Objects vary in
size (from 3x3 to 10x10) and shape, with no two objects sharing adjacent edge
cells. The grid also contains laser sources (cells marked with color 9 that emit
directional lasers), activation patterns (specific arrangements like 2x2 squares
of color 3), and a direction field (background cells containing arrow-like color
codes 4-7 that dictate local movement direction).   The transformation to the
output grid requires applying multiple sequential rules: First, calculate the
geometric center (centroid) of each object and place a dot (color 9) at that
location, overwriting any existing color. Second, simulate laser diffusion from
all sources: lasers travel in their initial direction (determined by source
position) until colliding with an object, where they reflect according to the
object's surface orientation (horizontal collisions reflect vertically, vertical
reflect horizontally), changing the object's color via a cyclic mapping (e.g.,
color 1 → 2 → 3 → 1). Third, when a laser hits an activation pattern, trigger an
image resizing operation on the nearest object: expand the object by one cell
outward in all directions if the pattern is a 2x2 square, or contract inward if
the pattern is a cross shape. Fourth, apply the direction field's influence:
lasers moving through background cells with arrow colors alter their trajectory
(e.g., color 4 directs right, color 5 directs up) before hitting objects. All
transformations must be applied simultaneously without overlapping paths, and no
object resizing may cause overlaps with other objects or the grid boundary. The
output grid retains the input's dimensions while incorporating all dot
placements, laser reflections, pattern activations, and resizing operations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid as create_grid, continuous_creature

# Helper functions

def neighbors4(r, c):
    return [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]


def place_objects(width, height):
    ingrid = create_grid(width, height, 0)
    object_colors = []
    # try to place between 3 and 5 objects
    num_objects = random.randint(3, 5)
    available_colors = list(range(1, 9))
    random.shuffle(available_colors)

    placed = 0
    attempts = 0
    while placed < num_objects and attempts < 800:
        attempts += 1
        color = available_colors[placed]
        # bounding box for sprite
        max_w = min(10, max(3, width - 4))
        max_h = min(10, max(3, height - 4))
        w_obj = random.randint(3, max_w)
        h_obj = random.randint(3, max_h)
        # size of creature between small and the box area
        size = random.randint(max(3, (w_obj * h_obj) // 4), w_obj * h_obj)
        sprite = continuous_creature(size, w_obj, h_obj)

        # choose a placement with a 1-cell margin from boundaries to allow safe expansion
        r0 = random.randint(1, height - h_obj - 1)
        c0 = random.randint(1, width - w_obj - 1)
        pixels = [(r0 + r, c0 + c) for r, c in sprite]

        # validation: no overlaps and no edge-adjacent neighbors with other objects
        bad = False
        for pr, pc in pixels:
            if ingrid[pr][pc] != 0:
                bad = True
                break
            for nr, nc in neighbors4(pr, pc):
                if 0 <= nr < height and 0 <= nc < width and ingrid[nr][nc] != 0:
                    bad = True
                    break
            if bad:
                break
        if bad:
            continue

        # place the object
        for pr, pc in pixels:
            ingrid[pr][pc] = color
        object_colors.append(color)
        placed += 1

    # If nothing placed (rare), create a small central square object
    if len(object_colors) == 0:
        color = 1
        r0 = height // 2 - 1
        c0 = width // 2 - 1
        for dr in range(3):
            for dc in range(3):
                ingrid[r0 + dr][c0 + dc] = color
        object_colors.append(color)

    return ingrid, object_colors


def generate():
    # grid size
    width = random.randint(14, 20)
    height = random.randint(14, 20)

    ingrid, object_colors = place_objects(width, height)

    # Place lasers (color 9) on edges. Keep track of their initial directions.
    lasers = []
    edge_candidates = []
    # left edge
    for r in range(1, height - 1):
        if ingrid[r][0] == 0 and ingrid[r][1] == 0:
            edge_candidates.append((r, 0, (0, 1)))
    # right edge
    for r in range(1, height - 1):
        if ingrid[r][width - 1] == 0 and ingrid[r][width - 2] == 0:
            edge_candidates.append((r, width - 1, (0, -1)))
    # top edge
    for c in range(1, width - 1):
        if ingrid[0][c] == 0 and ingrid[1][c] == 0:
            edge_candidates.append((0, c, (1, 0)))
    # bottom edge
    for c in range(1, width - 1):
        if ingrid[height - 1][c] == 0 and ingrid[height - 2][c] == 0:
            edge_candidates.append((height - 1, c, (-1, 0)))

    random.shuffle(edge_candidates)
    num_lasers = random.randint(1, min(3, max(1, len(edge_candidates))))
    for i in range(num_lasers):
        r, c, d = edge_candidates[i]
        ingrid[r][c] = 9
        lasers.append((r, c, d))

    # Place activation patterns (2x2 squares of color 3). Ensure they can trigger an expansion.
    patterns = []
    pattern_attempts = 0
    num_patterns = random.randint(1, 2)
    while len(patterns) < num_patterns and pattern_attempts < 400:
        pattern_attempts += 1
        r = random.randint(1, height - 3)
        c = random.randint(1, width - 3)
        ok = True
        for dr in (0, 1):
            for dc in (0, 1):
                if ingrid[r + dr][c + dc] != 0:
                    ok = False
                    break
            if not ok:
                break
        if not ok:
            continue

        # find nearest object and test if expansion would be valid (no overlap and within bounds)
        nearest = None
        min_dist = 10 ** 9
        for color in object_colors:
            for rr in range(height):
                for cc in range(width):
                    if ingrid[rr][cc] == color:
                        d = abs(rr - r) + abs(cc - c)
                        if d < min_dist:
                            min_dist = d
                            nearest = color
        if nearest is None:
            continue

        # Check expansion feasibility for nearest object
        obj_pixels = [(rr, cc) for rr in range(height) for cc in range(width) if ingrid[rr][cc] == nearest]
        candidates = set(obj_pixels)
        possible = True
        for rr, cc in obj_pixels:
            for dr, dc in neighbors4(rr, cc):
                if dr < 0 or dr >= height or dc < 0 or dc >= width:
                    possible = False
                    break
                # if neighbor belongs to another object that's not the target, expansion would overlap
                if ingrid[dr][dc] != 0 and ingrid[dr][dc] != nearest:
                    possible = False
                    break
                candidates.add((dr, dc))
            if not possible:
                break
        if not possible:
            continue

        # place the 2x2 pattern
        for dr in (0, 1):
            for dc in (0, 1):
                ingrid[r + dr][c + dc] = 3
        patterns.append((r, c))

    # Place direction-field cells (colors 4-7) in empty background cells
    num_dir_cells = random.randint(8, 20)
    dir_attempts = 0
    while dir_attempts < 800 and sum(1 for _ in range(num_dir_cells)):
        dir_attempts += 1
        if len([1 for _ in range(num_dir_cells)]) == 0:
            break
        if len([1 for _ in range(1)]) >= 1:
            # choose random empty cell
            rr = random.randint(0, height - 1)
            cc = random.randint(0, width - 1)
            if ingrid[rr][cc] == 0:
                ingrid[rr][cc] = random.choice([4, 5, 6, 7])
                # decrement target count
                num_dir_cells -= 1
        if num_dir_cells <= 0:
            break

    # Prepare output as a deep copy
    outgrid = [row[:] for row in ingrid]

    # Step 1: place centroid dots (color 9) for each object (overwrite in output)
    found_colors = sorted({ingrid[r][c] for r in range(height) for c in range(width) if 1 <= ingrid[r][c] <= 8})
    for color in found_colors:
        pixels = [(r, c) for r in range(height) for c in range(width) if ingrid[r][c] == color]
        if not pixels:
            continue
        centroid_r = sum(r for r, c in pixels) // len(pixels)
        centroid_c = sum(c for r, c in pixels) // len(pixels)
        outgrid[centroid_r][centroid_c] = 9

    # Step 2: simulate lasers. Use the original ingrid as the environment and write effects into outgrid.
    dir_map = {4: (0, 1), 5: (-1, 0), 6: (0, -1), 7: (1, 0)}

    def reflect(dr, dc):
        # rotate and flip so horizontal -> vertical and vertical -> horizontal
        return -dc, -dr

    def cycle_color(col):
        return (col % 8) + 1

    # list lasers again (from the ingrid) in case placement changed
    laser_sources = [(r, c) for r in range(height) for c in range(width) if ingrid[r][c] == 9 and (r == 0 or r == height - 1 or c == 0 or c == width - 1)]
    # derive start directions based on edge
    def edge_direction(r, c):
        if c == 0:
            return (0, 1)
        if c == width - 1:
            return (0, -1)
        if r == 0:
            return (1, 0)
        return (-1, 0)

    for sr, sc in laser_sources:
        dr, dc = edge_direction(sr, sc)
        rpos, cpos = sr, sc
        steps = 0
        limit = width * height * 4
        while steps < limit:
            steps += 1
            nr, nc = rpos + dr, cpos + dc
            if not (0 <= nr < height and 0 <= nc < width):
                break
            cell = ingrid[nr][nc]
            if cell in dir_map:
                # field redirects the beam
                dr, dc = dir_map[cell]
                # mark the path cell as laser passed (if it was empty)
                if outgrid[nr][nc] == 0:
                    outgrid[nr][nc] = 9
                rpos, cpos = nr, nc
                continue
            if 1 <= cell <= 8:
                # hit an object: change the whole object's color in output
                new_color = cycle_color(cell)
                for rr in range(height):
                    for cc in range(width):
                        if outgrid[rr][cc] == cell:
                            outgrid[rr][cc] = new_color
                # reflect the beam without entering the object cell
                dr, dc = reflect(dr, dc)
                # continue from the same rpos, cpos
                continue
            if cell == 3:
                # activation pattern: find nearest object (by Manhattan distance) in the original grid
                nearest = None
                min_d = 10 ** 9
                for color in found_colors:
                    for rr in range(height):
                        for cc in range(width):
                            if ingrid[rr][cc] == color:
                                d = abs(rr - nr) + abs(cc - nc)
                                if d < min_d:
                                    min_d = d
                                    nearest = color
                if nearest is not None:
                    # attempt expansion on outgrid: add all 4-neighbors of the object's pixels
                    obj_pixels = [(rr, cc) for rr in range(height) for cc in range(width) if outgrid[rr][cc] == nearest]
                    candidates = set(obj_pixels)
                    possible = True
                    for rr, cc in obj_pixels:
                        for ddr, ddc in neighbors4(rr, cc):
                            if ddr < 0 or ddr >= height or ddc < 0 or ddc >= width:
                                possible = False
                                break
                            if outgrid[ddr][ddc] != 0 and outgrid[ddr][ddc] != nearest:
                                possible = False
                                break
                            candidates.add((ddr, ddc))
                        if not possible:
                            break
                    if possible:
                        for (xr, xc) in candidates:
                            outgrid[xr][xc] = nearest
                # mark the activation cell as visited
                if outgrid[nr][nc] == 0:
                    outgrid[nr][nc] = 9
                rpos, cpos = nr, nc
                continue
            # otherwise background (0 or unknown): mark laser path and step forward
            if outgrid[nr][nc] == 0:
                outgrid[nr][nc] = 9
            rpos, cpos = nr, nc

    # Ensure output is different from input
    identical = True
    for r in range(height):
        if ingrid[r] != outgrid[r]:
            identical = False
            break
    if identical:
        # force a visible change: put a 9 at a safe background location
        for r in range(height):
            for c in range(width):
                if outgrid[r][c] == 0:
                    outgrid[r][c] = 9
                    identical = False
                    break
            if not identical:
                break

    return {"input": ingrid, "output": outgrid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    def neighbors4(r, c):
        return [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]

    # find object colors present
    object_colors = sorted({grid[r][c] for r in range(height) for c in range(width) if 1 <= grid[r][c] <= 8})

    # Prepare output as a copy of the input
    out = [row[:] for row in grid]

    # Step 1: place centroid dots (color 9) for each object
    for color in object_colors:
        pixels = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == color]
        if not pixels:
            continue
        centroid_r = sum(r for r, c in pixels) // len(pixels)
        centroid_c = sum(c for r, c in pixels) // len(pixels)
        out[centroid_r][centroid_c] = 9

    # Step 2: simulate lasers based on the original input grid
    dir_map = {4: (0, 1), 5: (-1, 0), 6: (0, -1), 7: (1, 0)}

    def reflect(dr, dc):
        return -dc, -dr

    def cycle_color(col):
        return (col % 8) + 1

    # find laser sources (cells with 9 on the border)
    laser_sources = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == 9 and (r == 0 or r == height - 1 or c == 0 or c == width - 1)]

    def edge_direction(r, c):
        if c == 0:
            return (0, 1)
        if c == width - 1:
            return (0, -1)
        if r == 0:
            return (1, 0)
        return (-1, 0)

    for sr, sc in laser_sources:
        dr, dc = edge_direction(sr, sc)
        rpos, cpos = sr, sc
        steps = 0
        limit = width * height * 4
        while steps < limit:
            steps += 1
            nr, nc = rpos + dr, cpos + dc
            if not (0 <= nr < height and 0 <= nc < width):
                break
            cell = grid[nr][nc]
            if cell in dir_map:
                dr, dc = dir_map[cell]
                if out[nr][nc] == 0:
                    out[nr][nc] = 9
                rpos, cpos = nr, nc
                continue
            if 1 <= cell <= 8:
                new_color = cycle_color(cell)
                for rr in range(height):
                    for cc in range(width):
                        if out[rr][cc] == cell:
                            out[rr][cc] = new_color
                dr, dc = reflect(dr, dc)
                continue
            if cell == 3:
                # activation: find nearest object in original grid
                nearest = None
                min_d = 10 ** 9
                for color in object_colors:
                    for rr in range(height):
                        for cc in range(width):
                            if grid[rr][cc] == color:
                                d = abs(rr - nr) + abs(cc - nc)
                                if d < min_d:
                                    min_d = d
                                    nearest = color
                if nearest is not None:
                    # attempt expansion on out
                    obj_pixels = [(rr, cc) for rr in range(height) for cc in range(width) if out[rr][cc] == nearest]
                    candidates = set(obj_pixels)
                    possible = True
                    for rr, cc in obj_pixels:
                        for ddr, ddc in neighbors4(rr, cc):
                            if ddr < 0 or ddr >= height or ddc < 0 or ddc >= width:
                                possible = False
                                break
                            if out[ddr][ddc] != 0 and out[ddr][ddc] != nearest:
                                possible = False
                                break
                            candidates.add((ddr, ddc))
                        if not possible:
                            break
                    if possible:
                        for xr, xc in candidates:
                            out[xr][xc] = nearest
                if out[nr][nc] == 0:
                    out[nr][nc] = 9
                rpos, cpos = nr, nc
                continue
            # otherwise mark laser path and step
            if out[nr][nc] == 0:
                out[nr][nc] = 9
            rpos, cpos = nr, nc

    # Return as tuple of tuples
    return tuple(tuple(row) for row in out)

