# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 09845bb1
Difficulty: insane

=== Tags ===
- Maze wave
- Color stream
- Associate colors to images
- Apply rule from a 2x2 hint grid

=== Description ===
The task features a complex maze structure composed of interconnected pathways
where each path segment is colored with a unique color (1-9), forming a
continuous "color stream" that defines the propagation path. The maze is
surrounded by a background color (0), and a 2x2 grid positioned in the top-left
corner serves as a transformation rule: each cell in this grid corresponds to a
directional color replacement rule (e.g., moving right from a cell of color *X*
replaces it with the top-left rule color, while moving down replaces it with the
bottom-left rule color). The output grid applies this rule sequentially along
the color stream path, causing each cell in the stream to update its color based
on the direction of traversal and the 2x2 rule. The wave propagation begins at
the stream's starting point, dynamically transforming colors as it moves through
the maze, while preserving all maze walls and non-stream cells. The final output
reveals a visually distinct "wave" of color changes rippling through the stream
path, with the transformation rules consistently applied across all directional
transitions without overlapping or conflicting changes.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    import common

    # Grid size (keep moderate to allow varied mazes but small enough for fast generation)
    width = common.randint(6, 15)
    height = common.randint(6, 15)
    grid_input = common.grid(width, height, 0)

    # Place the 2x2 rule in the top-left corner. Use four distinct non-zero colors.
    rule_colors = common.random_colors(4)
    # rule is indexed as rule[row][col]
    rule = [[rule_colors[0], rule_colors[1]], [rule_colors[2], rule_colors[3]]]
    grid_input[0][0] = rule[0][0]
    grid_input[0][1] = rule[0][1]
    grid_input[1][0] = rule[1][0]
    grid_input[1][1] = rule[1][1]

    # Block the rule cells so the path doesn't run through them
    blocked = {(0, 0), (0, 1), (1, 0), (1, 1)}

    # Build a non-self-intersecting path (stream) with unique colors for each segment
    # Limit the path length to at most 9 because there are only 9 possible non-zero colors
    max_len = min(9, width * height - len(blocked))
    length = common.randint(3, max_len)

    # Helper: attempt to build a path of the desired length using DFS/backtracking
    def build_path(start):
        visited = set(blocked)  # blocks and used positions (for bounds checks)
        path = [start]
        visited.add(start)
        path_set = {start}  # only the path cells (used to prevent adjacency to non-consecutive cells)

        def extend():
            if len(path) >= length:
                return True
            r, c = path[-1]
            nbrs = [(r, c + 1), (r + 1, c), (r, c - 1), (r - 1, c)]
            random.shuffle(nbrs)
            for nr, nc in nbrs:
                if nr < 0 or nr >= height or nc < 0 or nc >= width:
                    continue
                if (nr, nc) in visited:
                    continue
                # Prevent the candidate from being adjacent to any already-placed path cell
                # other than the immediate predecessor (to avoid non-consecutive orthogonal touches)
                conflict = False
                for (vr, vc) in path_set:
                    if (vr, vc) == path[-1]:
                        continue
                    if abs(nr - vr) + abs(nc - vc) == 1:
                        conflict = True
                        break
                if conflict:
                    continue
                visited.add((nr, nc))
                path.append((nr, nc))
                path_set.add((nr, nc))
                if extend():
                    return True
                path.pop()
                path_set.remove((nr, nc))
                visited.remove((nr, nc))
            return False

        success = extend()
        return path if success else None

    # Try multiple random starts until a valid path is found
    path = None
    attempts = 0
    while path is None and attempts < 400:
        attempts += 1
        start_r = common.randint(2, height - 1)
        start_c = common.randint(2, width - 1)
        if (start_r, start_c) in blocked:
            continue
        path = build_path((start_r, start_c))

    if path is None:
        # Fallback: create a short straight path to the right from (2,2)
        path = []
        r0, c0 = 2, 2
        for i in range(length):
            path.append((r0, c0 + i))

    # Orient path so that its starting endpoint is the lexicographically smaller of the two endpoints.
    # This makes it reconstructable deterministically by a solver that scans row-major for an endpoint.
    if path[-1] < path[0]:
        path = list(reversed(path))

    # Assign a unique color (1-9) to every path cell
    path_colors = common.random_colors(len(path))
    for (r, c), color in zip(path, path_colors):
        grid_input[r][c] = color

    # Build the output by applying the directional mapping from the 2x2 rule
    grid_output = [row[:] for row in grid_input]

    # Mapping (dr,dc) -> rule cell:
    # right  (0,1) -> rule[0][0] (top-left)
    # down   (1,0) -> rule[1][0] (bottom-left)
    # left   (0,-1)-> rule[0][1] (top-right)
    # up     (-1,0)-> rule[1][1] (bottom-right)
    mapping = {
        (0, 1): rule[0][0],
        (1, 0): rule[1][0],
        (0, -1): rule[0][1],
        (-1, 0): rule[1][1]
    }

    for i in range(len(path) - 1):
        r1, c1 = path[i]
        r2, c2 = path[i + 1]
        dr, dc = r2 - r1, c2 - c1
        new_color = mapping.get((dr, dc), grid_input[r1][c1])
        grid_output[r1][c1] = new_color

    # Ensure the input and output are not identical (very unlikely but enforce deterministically)
    identical = True
    for r in range(height):
        if grid_input[r] != grid_output[r]:
            identical = False
            break
    if identical:
        # Change the last path cell in the input to guarantee a difference
        lr, lc = path[-1]
        for c in range(1, 10):
            if c != grid_output[lr][lc]:
                grid_input[lr][lc] = c
                break

    return {"input": grid_input, "output": grid_output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    import common

    # Convert input to a mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Extract the 2x2 rule from the top-left corner (if present)
    if height < 2 or width < 2:
        # Nothing to do for tiny grids
        return tuple(tuple(row) for row in grid)
    rule = [[grid[0][0], grid[0][1]], [grid[1][0], grid[1][1]]]

    # Predicate for rule cells (top-left 2x2)
    def is_rule_cell(r, c):
        return 0 <= r <= 1 and 0 <= c <= 1

    # Find non-rule non-zero cells (these belong to the colored stream)
    stream_cells = [(r, c) for r in range(height) for c in range(width)
                    if grid[r][c] != 0 and not is_rule_cell(r, c)]

    if not stream_cells:
        return tuple(tuple(row) for row in grid)

    # Neighbor function that ignores background and the rule block
    def neighbors(r, c):
        result = []
        for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0 and not is_rule_cell(nr, nc):
                result.append((nr, nc))
        return result

    # Heuristic: start at a stream cell with degree 1 (an endpoint), if possible
    start = None
    for cell in stream_cells:
        if len(neighbors(*cell)) == 1:
            start = cell
            break
    if start is None:
        start = stream_cells[0]

    # Reconstruct the ordered path by walking from the start
    path = [start]
    prev = None
    cur = start
    while True:
        nbrs = neighbors(*cur)
        nxt = None
        for n in nbrs:
            if n != prev:
                nxt = n
                break
        if nxt is None:
            break
        path.append(nxt)
        prev, cur = cur, nxt

    # Apply the same directional mapping as the generator
    mapping = {
        (0, 1): rule[0][0],   # right -> top-left
        (1, 0): rule[1][0],   # down -> bottom-left
        (0, -1): rule[0][1],  # left -> top-right
        (-1, 0): rule[1][1]   # up -> bottom-right
    }

    output = [row[:] for row in grid]
    for i in range(len(path) - 1):
        r1, c1 = path[i]
        r2, c2 = path[i + 1]
        dr, dc = r2 - r1, c2 - c1
        output[r1][c1] = mapping.get((dr, dc), grid[r1][c1])

    return tuple(tuple(row) for row in output)

