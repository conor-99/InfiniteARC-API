# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: b2445f07
Difficulty: insane

=== Tags ===
- Unbounded counting
- Detect enclosure

=== Description ===
The task involves identifying enclosed regions within a grid. An enclosed region
is defined as a connected area of zeros (background) that is completely
surrounded by non-zero values and does not touch the grid's boundary. The output
grid is generated by replacing all cells belonging to any enclosed region with
the value 9, and setting the top-left cell (0,0) to the count of such enclosed
regions. The count is guaranteed to be between 0 and 9, ensuring it fits within
the grid's value constraints. For example, if there are three enclosed regions,
the top-left cell is set to 3, and all enclosed zero cells are replaced with 9,
while other cells retain their original values. The input grids feature complex
arrangements of non-zero structures creating multiple enclosed zero regions,
requiring careful visual analysis to distinguish enclosed areas from boundary-
touching regions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    W = random.randint(5, 30)
    H = random.randint(5, 30)
    input_grid = [[1] * W for _ in range(H)]
    
    # Create enclosed regions
    for _ in range(random.randint(0, 9)):
        r = random.randint(1, H-2)
        c = random.randint(1, W-2)
        if input_grid[r][c] == 0:
            continue
        queue = [(r, c)]
        input_grid[r][c] = 0
        while queue:
            r, c = queue.pop(0)
            if random.random() < 0.7:
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 1 <= nr <= H-2 and 1 <= nc <= W-2 and input_grid[nr][nc] == 1:
                        input_grid[nr][nc] = 0
                        queue.append((nr, nc))
    
    # Compute actual enclosed region count
    visited_border = [[False] * W for _ in range(H)]
    queue = []
    for c in range(W):
        if input_grid[0][c] == 0:
            visited_border[0][c] = True
            queue.append((0, c))
        if input_grid[H-1][c] == 0:
            visited_border[H-1][c] = True
            queue.append((H-1, c))
    for r in range(H):
        if input_grid[r][0] == 0:
            visited_border[r][0] = True
            queue.append((r, 0))
        if input_grid[r][W-1] == 0:
            visited_border[r][W-1] = True
            queue.append((r, W-1))
    
    while queue:
        r, c = queue.pop(0)
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < H and 0 <= nc < W and not visited_border[nr][nc] and input_grid[nr][nc] == 0:
                visited_border[nr][nc] = True
                queue.append((nr, nc))
    
    enclosed = [[False] * W for _ in range(H)]
    actual_count = 0
    for r in range(H):
        for c in range(W):
            if input_grid[r][c] == 0 and not visited_border[r][c]:
                if not enclosed[r][c]:
                    actual_count += 1
                    queue2 = [(r, c)]
                    enclosed[r][c] = True
                    while queue2:
                        r2, c2 = queue2.pop(0)
                        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                            nr, nc = r2 + dr, c2 + dc
                            if 0 <= nr < H and 0 <= nc < W and input_grid[nr][nc] == 0 and not visited_border[nr][nc] and not enclosed[nr][nc]:
                                enclosed[nr][nc] = True
                                queue2.append((nr, nc))
    
    # Create output grid
    output_grid = [row[:] for row in input_grid]
    for r in range(H):
        for c in range(W):
            if input_grid[r][c] == 0:
                output_grid[r][c] = 9
    output_grid[0][0] = actual_count
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    if not input_grid or not input_grid[0]:
        return input_grid
    H = len(input_grid)
    W = len(input_grid[0])
    visited_border = [[False] * W for _ in range(H)]
    queue = []
    for c in range(W):
        if input_grid[0][c] == 0:
            visited_border[0][c] = True
            queue.append((0, c))
        if input_grid[H-1][c] == 0:
            visited_border[H-1][c] = True
            queue.append((H-1, c))
    for r in range(H):
        if input_grid[r][0] == 0:
            visited_border[r][0] = True
            queue.append((r, 0))
        if input_grid[r][W-1] == 0:
            visited_border[r][W-1] = True
            queue.append((r, W-1))
    
    while queue:
        r, c = queue.pop(0)
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < H and 0 <= nc < W and not visited_border[nr][nc] and input_grid[nr][nc] == 0:
                visited_border[nr][nc] = True
                queue.append((nr, nc))
    
    enclosed = [[False] * W for _ in range(H)]
    enclosed_count = 0
    for r in range(H):
        for c in range(W):
            if input_grid[r][c] == 0 and not visited_border[r][c]:
                if not enclosed[r][c]:
                    enclosed_count += 1
                    queue2 = [(r, c)]
                    enclosed[r][c] = True
                    while queue2:
                        r2, c2 = queue2.pop(0)
                        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                            nr, nc = r2 + dr, c2 + dc
                            if 0 <= nr < H and 0 <= nc < W and input_grid[nr][nc] == 0 and not visited_border[nr][nc] and not enclosed[nr][nc]:
                                enclosed[nr][nc] = True
                                queue2.append((nr, nc))
    
    output_grid = [row[:] for row in input_grid]
    for r in range(H):
        for c in range(W):
            if enclosed[r][c]:
                output_grid[r][c] = 9
    output_grid[0][0] = enclosed_count
    return output_grid
