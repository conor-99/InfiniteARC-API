# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 9e621eeb
Difficulty: mediumâ€“hard

=== Tags ===
- Gate chain construction
- Symbolic spatial binding
- Wave reflection
- Source target routing

=== Description ===
The input grid features a single red source cell, a single blue target cell, and
multiple gate structures positioned throughout the grid. The gates consist of
contiguous vertical green lines (representing vertical reflectors) and
contiguous horizontal yellow lines (representing horizontal reflectors), each
spanning at least two cells. The background is uniformly colored. The red source
emits a wave traveling rightward. Upon hitting a vertical green gate, the wave
reflects upward if moving right or downward if moving left. Upon hitting a
horizontal yellow gate, the wave reflects leftward if moving up or rightward if
moving down. The wave continues reflecting according to these deterministic
rules until it reaches the blue target. The output grid must display the wave's
complete trajectory as a continuous purple line connecting the source to the
target, adhering strictly to the reflection sequence. The path must navigate
through the gate structures without overlapping them, maintaining precise
alignment with the reflection rules. The challenge lies in identifying the
correct reflection sequence through multiple gates to form the path from source
to target, requiring both spatial reasoning and sequential rule application.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common


def generate():
    """Generates an input/output pair for the gate-reflection routing task.

    The generator builds a deterministic left-turning wave trajectory starting
    from a red source (2) moving east. At each reflection the wave meets a gate
    cell (vertical=3 for horizontal approach, horizontal=4 for vertical
    approach) and turns left. Gates are placed as short contiguous segments
    (length >= 2). The final segment ends at a blue target (1). The output
    is the input grid with the full trajectory painted as purple (5).
    """
    SRC = 2
    TGT = 1
    VERT = 3
    HORZ = 4
    PATH = 5

    dirs = [(0, 1), (-1, 0), (0, -1), (1, 0)]  # east, north, west, south

    max_outer_tries = 300
    for _attempt in range(max_outer_tries):
        # random size but within ARC limits
        w = random.randint(12, 20)
        h = random.randint(12, 20)
        grid_in = common.grid(w, h, 0)

        # pick a source reasonably away from edges so reflections can happen
        sr = random.randint(2, max(2, h - 3))
        sc = random.randint(1, max(1, w - 4))
        source = (sr, sc)

        reserved = set([source])  # all occupied positions (path or gates)
        path = [source]
        gate_cells = []  # list of (r, c, color)

        dir_idx = 0  # start moving east
        n_reflections = random.randint(3, 6)

        pos = source
        ok = True

        for _ref in range(n_reflections):
            dr, dc = dirs[dir_idx]
            # compute maximum L so that gate position (pos + (L+1)*dir) stays in bounds
            Lmax = 0
            while True:
                test_r = pos[0] + dr * (Lmax + 1)
                test_c = pos[1] + dc * (Lmax + 1)
                if not (0 <= test_r < h and 0 <= test_c < w):
                    break
                Lmax += 1
            if Lmax < 1:
                ok = False
                break

            candidate_Ls = list(range(1, min(6, Lmax) + 1))
            random.shuffle(candidate_Ls)

            found_segment = False
            for L in candidate_Ls:
                end_r = pos[0] + dr * L
                end_c = pos[1] + dc * L
                gate_r = end_r + dr
                gate_c = end_c + dc

                # check intermediate path cells free
                blocked = False
                for k in range(1, L + 1):
                    rr = pos[0] + dr * k
                    cc = pos[1] + dc * k
                    if (rr, cc) in reserved:
                        blocked = True
                        break
                if blocked:
                    continue

                # gate cell must be in bounds and free
                if not (0 <= gate_r < h and 0 <= gate_c < w):
                    continue
                if (gate_r, gate_c) in reserved:
                    continue

                # compute reflect step (rotate left)
                new_dir_idx = (dir_idx + 1) % 4
                rdr, rdc = dirs[new_dir_idx]
                reflect_r = end_r + rdr
                reflect_c = end_c + rdc

                if not (0 <= reflect_r < h and 0 <= reflect_c < w):
                    continue
                if (reflect_r, reflect_c) in reserved:
                    continue

                # Now ensure we can place a contiguous gate of at least 2 cells
                if dir_idx in (0, 2):
                    # approaching horizontally -> need a vertical gate (color VERT)
                    candidate_offsets = [(1, 0), (-1, 0)]
                    random.shuffle(candidate_offsets)
                    gate_segment = [(gate_r, gate_c)]
                    placed = False
                    for adr, adc in candidate_offsets:
                        gr2 = gate_r + adr
                        gc2 = gate_c + adc
                        if 0 <= gr2 < h and 0 <= gc2 < w and (gr2, gc2) not in reserved:
                            gate_segment.append((gr2, gc2))
                            placed = True
                            break
                    if not placed:
                        continue
                    gate_color = VERT
                else:
                    # approaching vertically -> need a horizontal gate (color HORZ)
                    candidate_offsets = [(0, 1), (0, -1)]
                    random.shuffle(candidate_offsets)
                    gate_segment = [(gate_r, gate_c)]
                    placed = False
                    for adr, adc in candidate_offsets:
                        gr2 = gate_r + adr
                        gc2 = gate_c + adc
                        if 0 <= gr2 < h and 0 <= gc2 < w and (gr2, gc2) not in reserved:
                            gate_segment.append((gr2, gc2))
                            placed = True
                            break
                    if not placed:
                        continue
                    gate_color = HORZ

                # Accept this segment: add path cells and gate cells, then perform reflection
                for k in range(1, L + 1):
                    rr = pos[0] + dr * k
                    cc = pos[1] + dc * k
                    path.append((rr, cc))
                    reserved.add((rr, cc))

                for (gr, gc) in gate_segment:
                    gate_cells.append((gr, gc, gate_color))
                    reserved.add((gr, gc))

                # step into the reflected cell and mark it as part of the path
                pos = (reflect_r, reflect_c)
                path.append(pos)
                reserved.add(pos)

                dir_idx = new_dir_idx
                found_segment = True
                break

            if not found_segment:
                ok = False
                break

        if not ok:
            continue

        # Final straight segment to the target (no more reflections)
        dr, dc = dirs[dir_idx]
        Lmax = 0
        while True:
            test_r = pos[0] + dr * (Lmax + 1)
            test_c = pos[1] + dc * (Lmax + 1)
            if not (0 <= test_r < h and 0 <= test_c < w):
                break
            Lmax += 1
        if Lmax < 1:
            continue

        candidate_Ls = list(range(1, min(8, Lmax) + 1))
        random.shuffle(candidate_Ls)
        found_final = False
        for L in candidate_Ls:
            blocked = False
            for k in range(1, L + 1):
                rr = pos[0] + dr * k
                cc = pos[1] + dc * k
                if (rr, cc) in reserved:
                    blocked = True
                    break
            if blocked:
                continue
            # choose this L and place target at end
            target = (pos[0] + dr * L, pos[1] + dc * L)
            for k in range(1, L + 1):
                rr = pos[0] + dr * k
                cc = pos[1] + dc * k
                path.append((rr, cc))
                reserved.add((rr, cc))
            found_final = True
            break

        if not found_final:
            continue

        # ensure at least one gate exists (task requirement)
        if len(gate_cells) == 0:
            continue

        # paint gates and source/target in input grid
        for (gr, gc, color) in gate_cells:
            grid_in[gr][gc] = color

        grid_in[source[0]][source[1]] = SRC
        grid_in[target[0]][target[1]] = TGT

        # construct output by painting the full path as PATH (overwriting endpoints)
        grid_out = [row[:] for row in grid_in]
        for (pr, pc) in path:
            grid_out[pr][pc] = PATH

        # ensure input != output
        if grid_in == grid_out:
            continue

        return {"input": grid_in, "output": grid_out}

    # fallback deterministic simple case if all attempts fail
    w, h = 12, 12
    grid_in = common.grid(w, h, 0)
    source = (h // 2, 1)
    target = (h // 2, w - 2)
    grid_in[source[0]][source[1]] = SRC
    grid_in[target[0]][target[1]] = TGT
    grid_out = [row[:] for row in grid_in]
    for c in range(source[1], target[1] + 1):
        grid_out[source[0]][c] = PATH
    return {"input": grid_in, "output": grid_out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])

    SRC = 2
    TGT = 1
    VERT = 3
    HORZ = 4
    PATH = 5

    # find source and target
    source = None
    target = None
    for r in range(h):
        for c in range(w):
            if grid[r][c] == SRC:
                source = (r, c)
            elif grid[r][c] == TGT:
                target = (r, c)

    if source is None:
        raise ValueError('Source not found')

    dirs = [(0, 1), (-1, 0), (0, -1), (1, 0)]  # east, north, west, south
    dir_idx = 0  # start east

    out = [row[:] for row in grid]

    pos = source
    steps = 0
    max_steps = h * w * 20

    while True:
        # mark current position as path
        out[pos[0]][pos[1]] = PATH
        if pos == target:
            break
        if steps > max_steps:
            break

        dr, dc = dirs[dir_idx]
        nr, nc = pos[0] + dr, pos[1] + dc

        # out of bounds -> stop
        if not (0 <= nr < h and 0 <= nc < w):
            break

        cell = grid[nr][nc]

        if cell == VERT and dir_idx in (0, 2):
            # vertical gate reflects horizontal motion -> turn left
            dir_idx = (dir_idx + 1) % 4
            dr, dc = dirs[dir_idx]
            nr, nc = pos[0] + dr, pos[1] + dc
            if not (0 <= nr < h and 0 <= nc < w):
                break
            if grid[nr][nc] in (VERT, HORZ):
                break
        elif cell == HORZ and dir_idx in (1, 3):
            # horizontal gate reflects vertical motion -> turn left
            dir_idx = (dir_idx + 1) % 4
            dr, dc = dirs[dir_idx]
            nr, nc = pos[0] + dr, pos[1] + dc
            if not (0 <= nr < h and 0 <= nc < w):
                break
            if grid[nr][nc] in (VERT, HORZ):
                break
        elif cell in (VERT, HORZ):
            # unexpected gate orientation - stop to avoid undefined behavior
            break

        pos = (nr, nc)
        steps += 1

    # ensure target is painted as part of path (if it exists)
    if target is not None:
        out[target[0]][target[1]] = PATH

    return out

