# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 44751fbb
Difficulty: mediumâ€“hard

=== Tags ===
- Color transfer on contact
- Create image from info
- Find the odd shape out

=== Description ===
Color Transfer and Rectangular Anomaly  Input grids are composed of a uniform
background color (0) with multiple contiguous shapes formed by solid regions of
non-zero colors. Each shape is primarily rectangular, meaning all cells within
its axis-aligned bounding box share the same color with no gaps. However, one
shape in the grid is the "odd shape out" because it contains at least one
background cell (0) within its bounding box, making it non-rectangular (e.g., a
circle, a cross, or a shape with internal holes).  The output grid is generated
by applying a color transfer rule to all rectangular shapes while ignoring the
odd shape. For each rectangular shape, every background cell (0) directly
adjacent (horizontally or vertically) to any cell of the shape is recolored to
match the shape's color. The odd shape remains unchanged in the output, and its
area does not contribute to color transfer. All other background cells retain
their original color (0), and no shape overlaps or color transfers occur across
non-background cells. The transformation results in a grid where the background
is filled with color only adjacent to rectangular shapes, while the odd shape's
irregular form remains visible as a distinct anomaly.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    """
    Generate a grid with several filled rectangular shapes and one "odd" shape
    that has a background cell inside its bounding box. For every fully-rectangular
    shape, the output recolors every background (0) cell that is orthogonally
    adjacent to the shape to the shape's color. The odd shape does not participate
    in color transfer.
    """
    # Helper to compute minimal Manhattan distance between two axis-aligned rectangles
    def rect_manhattan_distance(a, b):
        # a and b are tuples (r, c, h, w)
        r1, c1, h1, w1 = a
        r2, c2, h2, w2 = b
        r1_max = r1 + h1 - 1
        r2_max = r2 + h2 - 1
        c1_max = c1 + w1 - 1
        c2_max = c2 + w2 - 1
        # row gap
        if r1_max < r2:
            row_gap = r2 - r1_max
        elif r2_max < r1:
            row_gap = r1 - r2_max
        else:
            row_gap = 0
        # col gap
        if c1_max < c2:
            col_gap = c2 - c1_max
        elif c2_max < c1:
            col_gap = c1 - c2_max
        else:
            col_gap = 0
        return row_gap + col_gap

    # We'll retry the whole placement if we fail to place all shapes
    for overall_try in range(200):
        W = random.randint(10, 20)
        H = random.randint(10, 20)
        grid = [[0 for _ in range(W)] for _ in range(H)]

        # number of rectangular shapes (not counting the odd shape)
        n_rect = random.randint(3, 4)
        # pick distinct colors for all shapes
        colors = random.sample(list(range(1, 10)), n_rect + 1)

        rects = []  # list of tuples (r, c, h, w, color)
        placement_ok = True

        # Try to place rectangular shapes with a minimum separation so their
        # neighboring background cells cannot be adjacent to more than one rectangle.
        for i in range(n_rect):
            color = colors[i]
            placed = False
            for _ in range(600):
                # choose size (avoid extremely large shapes)
                max_h = min(6, H - 2)
                max_w = min(6, W - 2)
                if max_h < 2 or max_w < 2:
                    break  # can't place reasonable rectangles here
                h = random.randint(2, max_h)
                w = random.randint(2, max_w)
                r = random.randint(0, H - h)
                c = random.randint(0, W - w)
                # check occupancy
                conflict = False
                for rr in range(r, r + h):
                    for cc in range(c, c + w):
                        if grid[rr][cc] != 0:
                            conflict = True
                            break
                    if conflict:
                        break
                if conflict:
                    continue
                # ensure enough Manhattan separation from existing shapes (>=3)
                candidate = (r, c, h, w)
                too_close = False
                for (r2, c2, h2, w2, _) in rects:
                    if rect_manhattan_distance(candidate, (r2, c2, h2, w2)) < 3:
                        too_close = True
                        break
                if too_close:
                    continue
                # place
                for rr in range(r, r + h):
                    for cc in range(c, c + w):
                        grid[rr][cc] = color
                rects.append((r, c, h, w, color))
                placed = True
                break
            if not placed:
                placement_ok = False
                break

        if not placement_ok:
            continue

        # Place the odd (non-rectangular) shape: a filled rectangle with at least
        # one background cell inside its bounding box (a hole). Ensure it also
        # has separation from the rectangles so it remains visually distinct.
        color_odd = colors[-1]
        placed_odd = False
        for _ in range(600):
            max_h = min(6, H - 2)
            max_w = min(6, W - 2)
            if max_h < 3 or max_w < 3:
                break
            h = random.randint(3, max_h)
            w = random.randint(3, max_w)
            r = random.randint(0, H - h)
            c = random.randint(0, W - w)
            # occupancy
            conflict = False
            for rr in range(r, r + h):
                for cc in range(c, c + w):
                    if grid[rr][cc] != 0:
                        conflict = True
                        break
                if conflict:
                    break
            if conflict:
                continue
            candidate = (r, c, h, w)
            too_close = False
            for (r2, c2, h2, w2, _) in rects:
                if rect_manhattan_distance(candidate, (r2, c2, h2, w2)) < 3:
                    too_close = True
                    break
            if too_close:
                continue
            # place full block
            for rr in range(r, r + h):
                for cc in range(c, c + w):
                    grid[rr][cc] = color_odd
            # create at least one interior background cell (hole)
            inner_r = r + random.randint(1, h - 2)
            inner_c = c + random.randint(1, w - 2)
            grid[inner_r][inner_c] = 0
            placed_odd = True
            break

        if not placed_odd:
            continue

        # Build the output by recoloring background cells orthogonally adjacent
        # to rectangular shapes only (use the original 'grid' to determine adjacency)
        output = [row[:] for row in grid]
        for (r, c, h, w, color) in rects:
            for rr in range(r, r + h):
                for cc in range(c, c + w):
                    for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                        nr, nc = rr + dr, cc + dc
                        if 0 <= nr < H and 0 <= nc < W and grid[nr][nc] == 0:
                            output[nr][nc] = color

        return {"input": grid, "output": output}

    # If we get here, placement failed repeatedly; fall back to a very small valid example
    grid = [[0 for _ in range(12)] for _ in range(12)]
    grid[2][2] = 5
    grid[2][3] = 5
    grid[3][2] = 5
    grid[3][3] = 5
    # odd shape
    grid[7][7] = 6
    grid[7][8] = 6
    grid[8][7] = 6
    grid[8][8] = 6
    grid[8][8] = 0  # hole
    output = [row[:] for row in grid]
    for r, c in [(2,2),(2,3),(3,2),(3,3)]:
        for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:
            nr, nc = r+dr, c+dc
            if 0 <= nr < 12 and 0 <= nc < 12 and grid[nr][nc] == 0:
                output[nr][nc] = 5
    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0]) if H > 0 else 0
    orig = [row[:] for row in grid]

    # find connected components of non-zero cells (4-connectivity)
    visited = [[False] * W for _ in range(H)]
    components = []  # list of (color, list_of_coords)
    for r in range(H):
        for c in range(W):
            if orig[r][c] != 0 and not visited[r][c]:
                color = orig[r][c]
                stack = [(r, c)]
                visited[r][c] = True
                comp = []
                while stack:
                    cr, cc = stack.pop()
                    comp.append((cr, cc))
                    for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc] and orig[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append((color, comp))

    # identify the odd (non-rectangular) shape: its bounding box contains at least
    # one cell that is not equal to the component's color (this includes background 0)
    odd_comp_set = None
    odd_color = None
    for color, comp in components:
        min_r = min(p[0] for p in comp)
        max_r = max(p[0] for p in comp)
        min_c = min(p[1] for p in comp)
        max_c = max(p[1] for p in comp)
        rectangular = True
        for rr in range(min_r, max_r + 1):
            for cc in range(min_c, max_c + 1):
                if orig[rr][cc] != color:
                    rectangular = False
                    break
            if not rectangular:
                break
        if not rectangular:
            odd_comp_set = set(comp)
            odd_color = color
            break

    # build the output: copy original and recolor zeros adjacent to rectangular shapes
    output = [row[:] for row in orig]
    for color, comp in components:
        # skip the odd component (if found)
        if odd_comp_set is not None and set(comp) == odd_comp_set and color == odd_color:
            continue
        for (cr, cc) in comp:
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nr, nc = cr + dr, cc + dc
                if 0 <= nr < H and 0 <= nc < W and orig[nr][nc] == 0:
                    output[nr][nc] = color
    return output

