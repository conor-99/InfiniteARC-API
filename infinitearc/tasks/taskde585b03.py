# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: de585b03
Difficulty: medium–hard

=== Tags ===
- Color implication network
- Periodic offset matching
- Recursive partition
- Cooperative rule network

=== Description ===
Input grids feature a background color (0) overlaid with multiple disjoint,
connected regions of distinct colors (1–9), each region forming a contiguous
shape. The transformation applies a recursive color implication network: at each
recursive partition level, the grid is divided into quadrants based on the
centroid of the largest region. Within each quadrant, regions of color C cause
adjacent regions of color (C + 1) mod 9 to shift by (C mod 3) cells in a
direction determined by the quadrant's row/column parity (even rows/columns:
horizontal shifts; odd rows/columns: vertical shifts). Shifts wrap periodically
around grid boundaries and are applied simultaneously across all regions.
Overlapping shifts prioritize higher color values (e.g., color 9 overrides color
1). This process repeats recursively for each quadrant until the quadrant size
is ≤ 3×3. The output grid shows all shifts as aligned, non-overlapping regions
with background cells filling the shifted paths, preserving all original region
colors while maintaining the recursive partition structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, continuous_creature

def generate():
    while True:
        width = random.randint(5, 30)
        height = random.randint(5, 30)
        input_grid = grid(width, height, 0)
        colors = list(range(1, 10))
        random.shuffle(colors)
        regions = []
        
        for color in colors[:random.randint(3, 5)]:
            size = random.randint(5, 15)
            pixels = continuous_creature(size, width, height)
            for r, c in pixels:
                if 0 <= r < height and 0 <= c < width and input_grid[r][c] == 0:
                    input_grid[r][c] = color
            regions.append((color, pixels))
        
        output_grid = apply_transformation(input_grid)
        if input_grid != output_grid:
            return {
                "input": input_grid,
                "output": output_grid
            }

def apply_transformation(grid):
    if len(grid) <= 3 and len(grid[0]) <= 3:
        return grid

    def find_regions(grid):
        regions = {}
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                color = grid[r][c]
                if color > 0 and (r, c) not in regions:
                    stack = [(r, c)]
                    region = []
                    while stack:
                        (r2, c2) = stack.pop()
                        if (r2, c2) not in region:
                            region.append((r2, c2))
                            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                                r3, c3 = r2 + dr, c2 + dc
                                if 0 <= r3 < len(grid) and 0 <= c3 < len(grid[0]) and grid[r3][c3] == color:
                                    stack.append((r3, c3))
                    regions[color] = region
        return regions

    def compute_centroid(pixels):
        total_r = sum(r for r, c in pixels)
        total_c = sum(c for r, c in pixels)
        return (total_r // len(pixels), total_c // len(pixels))

    regions = find_regions(grid)
    if not regions:
        return grid
    largest_color = max(regions, key=lambda c: len(regions[c]))
    centroid = compute_centroid(regions[largest_color])
    r_c, c_c = centroid

    def apply_shifts_to_quadrant(grid, r_start, r_end, c_start, c_end, direction):
        shifts = {}
        for r in range(r_start, r_end):
            for c in range(c_start, c_end):
                color = grid[r][c]
                if color > 0:
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        r2, c2 = r + dr, c + dc
                        if (r2 >= r_start and r2 < r_end and c2 >= c_start and c2 < c_end):
                            if grid[r2][c2] == (color + 1) % 9:
                                shift_amount = color % 3
                                if direction == 'horizontal':
                                    shifts[(r, c)] = (0, shift_amount)
                                else:
                                    shifts[(r, c)] = (shift_amount, 0)
        output = [row[:] for row in grid]
        for (r, c), (dr, dc) in shifts.items():
            new_r = (r - r_start + dr) % (r_end - r_start) + r_start
            new_c = (c - c_start + dc) % (c_end - c_start) + c_start
            output[new_r][new_c] = grid[r][c]
        return output

    output_grid = [row[:] for row in grid]
    r_start, r_end = 0, len(grid)
    c_start, c_end = 0, len(grid[0])

    if r_c > 0 and c_c > 0:
        top_left = apply_shifts_to_quadrant(
            [row[c_start:c_c] for row in grid[r_start:r_c]],
            0, r_c, 0, c_c, 'horizontal'
        )
        for r in range(r_c):
            for c in range(c_c):
                output_grid[r][c] = top_left[r][c]

    if r_c > 0 and c_c < c_end:
        top_right = apply_shifts_to_quadrant(
            [row[c_c:c_end] for row in grid[r_start:r_c]],
            0, r_c, 0, c_end - c_c, 'horizontal'
        )
        for r in range(r_c):
            for c in range(c_c, c_end):
                output_grid[r][c] = top_right[r][c - c_c]

    if r_c < r_end and c_c > 0:
        bottom_left = apply_shifts_to_quadrant(
            [row[c_start:c_c] for row in grid[r_c:r_end]],
            0, r_end - r_c, 0, c_c, 'vertical'
        )
        for r in range(r_c, r_end):
            for c in range(c_c):
                output_grid[r][c] = bottom_left[r - r_c][c]

    if r_c < r_end and c_c < c_end:
        bottom_right = apply_shifts_to_quadrant(
            [row[c_c:c_end] for row in grid[r_c:r_end]],
            0, r_end - r_c, 0, c_end - c_c, 'vertical'
        )
        for r in range(r_c, r_end):
            for c in range(c_c, c_end):
                output_grid[r][c] = bottom_right[r - r_c][c - c_c]

    return output_grid


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    
    def apply_transformation(grid):
        if len(grid) <= 3 and len(grid[0]) <= 3:
            return grid

        def find_regions(grid):
            regions = {}
            for r in range(len(grid)):
                for c in range(len(grid[0])):
                    color = grid[r][c]
                    if color > 0 and (r, c) not in regions:
                        stack = [(r, c)]
                        region = []
                        while stack:
                            (r2, c2) = stack.pop()
                            if (r2, c2) not in region:
                                region.append((r2, c2))
                                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                                    r3, c3 = r2 + dr, c2 + dc
                                    if 0 <= r3 < len(grid) and 0 <= c3 < len(grid[0]) and grid[r3][c3] == color:
                                        stack.append((r3, c3))
                        regions[color] = region
            return regions

        def compute_centroid(pixels):
            total_r = sum(r for r, c in pixels)
            total_c = sum(c for r, c in pixels)
            return (total_r // len(pixels), total_c // len(pixels))

        regions = find_regions(grid)
        if not regions:
            return grid
        largest_color = max(regions, key=lambda c: len(regions[c]))
        centroid = compute_centroid(regions[largest_color])
        r_c, c_c = centroid

        def apply_shifts_to_quadrant(grid, r_start, r_end, c_start, c_end, direction):
            shifts = {}
            for r in range(r_start, r_end):
                for c in range(c_start, c_end):
                    color = grid[r][c]
                    if color > 0:
                        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                            r2, c2 = r + dr, c + dc
                            if (r2 >= r_start and r2 < r_end and c2 >= c_start and c2 < c_end):
                                if grid[r2][c2] == (color + 1) % 9:
                                    shift_amount = color % 3
                                    if direction == 'horizontal':
                                        shifts[(r, c)] = (0, shift_amount)
                                    else:
                                        shifts[(r, c)] = (shift_amount, 0)
            output = [row[:] for row in grid]
            for (r, c), (dr, dc) in shifts.items():
                new_r = (r - r_start + dr) % (r_end - r_start) + r_start
                new_c = (c - c_start + dc) % (c_end - c_start) + c_start
                output[new_r][new_c] = grid[r][c]
            return output

        output_grid = [row[:] for row in grid]
        r_start, r_end = 0, len(grid)
        c_start, c_end = 0, len(grid[0])

        if r_c > 0 and c_c > 0:
            top_left = apply_shifts_to_quadrant(
                [row[c_start:c_c] for row in grid[r_start:r_c]],
                0, r_c, 0, c_c, 'horizontal'
            )
            for r in range(r_c):
                for c in range(c_c):
                    output_grid[r][c] = top_left[r][c]

        if r_c > 0 and c_c < c_end:
            top_right = apply_shifts_to_quadrant(
                [row[c_c:c_end] for row in grid[r_start:r_c]],
                0, r_c, 0, c_end - c_c, 'horizontal'
            )
            for r in range(r_c):
                for c in range(c_c, c_end):
                    output_grid[r][c] = top_right[r][c - c_c]

        if r_c < r_end and c_c > 0:
            bottom_left = apply_shifts_to_quadrant(
                [row[c_start:c_c] for row in grid[r_c:r_end]],
                0, r_end - r_c, 0, c_c, 'vertical'
            )
            for r in range(r_c, r_end):
                for c in range(c_c):
                    output_grid[r][c] = bottom_left[r - r_c][c]

        if r_c < r_end and c_c < c_end:
            bottom_right = apply_shifts_to_quadrant(
                [row[c_c:c_end] for row in grid[r_c:r_end]],
                0, r_end - r_c, 0, c_end - c_c, 'vertical'
            )
            for r in range(r_c, r_end):
                for c in range(c_c, c_end):
                    output_grid[r][c] = bottom_right[r - r_c][c - c_c]

        return output_grid

    return apply_transformation(grid)
