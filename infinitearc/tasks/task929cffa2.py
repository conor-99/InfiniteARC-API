# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 929cffa2
Difficulty: insane

=== Tags ===
- Symbolic color algebra
- Grid overlay blending
- Chain reaction

=== Description ===
Input grids consist of a background color (0) with multiple contiguous regions
of colors 1 through 9 arranged such that adjacent regions (sharing an edge) have
consecutive color values (e.g., 1 next to 2, 2 next to 3). The output grid is
generated through a deterministic chain reaction process: all adjacent cell
pairs with consecutive colors (X and X+1) are simultaneously replaced with X+2
in each iterative pass. This process repeats from top-left to bottom-right,
reprocessing the grid after each change until no consecutive pairs remain. The
transformation propagates color blends through the grid, with each iteration
amplifying color values in a predictable sequence. Background cells (0) remain
unchanged throughout. The output reflects the final state after all possible
chain reactions, where non-consecutive adjacent pairs persist unchanged. The
complexity arises from the grid's size (up to 30Ã—30), the interwoven sequences
of consecutive colors forming cascading blends across multiple directions, and
the need to apply the blending rules iteratively across multiple layers of
interaction without overlapping or ambiguous transformations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

# Generator for ARC task 435: chain-reaction color blending
# Produces input grids with Manhattan-distance rings (1..9) around a chosen center.
# Ensures uniqueness across multiple generate() calls using a global seed/counter and a VISITED set.

SEED = 0
VISITED = set()


def apply_chain_reaction(grid):
    """Apply the chain reaction rule until stable.

    For any adjacent (edge-sharing) pair of nonzero colors a and b where |a-b| == 1,
    both cells are simultaneously upgraded to min(a,b) + 2 (clamped to 9).
    This is done iteratively (all pairs in a pass are applied simultaneously) until
    no further changes occur.
    """
    h = len(grid)
    w = len(grid[0])
    current = [row[:] for row in grid]
    while True:
        changed = False
        new_grid = [row[:] for row in current]
        for i in range(h):
            for j in range(w):
                a = current[i][j]
                if a == 0:
                    continue
                max_val = a
                # Check 4-neighbors
                for di, dj in ((0, 1), (1, 0), (0, -1), (-1, 0)):
                    ni, nj = i + di, j + dj
                    if 0 <= ni < h and 0 <= nj < w:
                        b = current[ni][nj]
                        if b == 0:
                            continue
                        if abs(a - b) == 1:
                            v = min(a, b) + 2
                            if v > 9:
                                v = 9
                            if v > max_val:
                                max_val = v
                if max_val != a:
                    new_grid[i][j] = max_val
                    changed = True
        current = new_grid
        if not changed:
            break
    return current


def build_gradient(w, h, r, c):
    """Build a Manhattan-distance gradient around (r,c): values d+1 for d<9, else 0."""
    grid = [[0] * w for _ in range(h)]
    for i in range(h):
        for j in range(w):
            d = abs(i - r) + abs(j - c)
            if d < 9:
                grid[i][j] = d + 1
            else:
                grid[i][j] = 0
    return grid


def generate():
    """Generate a unique input/output pair for the ARC task.

    The generator uses a deterministic sequence derived from a global SEED to
    produce a wide variety of sizes and centers. It ensures each returned
    (input,output) pair is unique within this Python process and that the
    output differs from the input (so the task is non-trivial).
    """
    global SEED, VISITED
    attempt_limit = 1000
    attempts = 0
    while True:
        n = SEED
        SEED += 1
        # Choose width/height in range [5, 30] to get nontrivial patterns
        w = 5 + (n % 26)  # 5..30
        h = 5 + ((n * 7) % 26)
        # Choose a center that varies with the seed
        r = (n * 13) % h
        c = (n * 17) % w

        input_grid = build_gradient(w, h, r, c)
        output_grid = apply_chain_reaction(input_grid)

        key = (tuple(tuple(row) for row in input_grid), tuple(tuple(row) for row in output_grid))

        # Skip duplicates
        if key in VISITED:
            attempts += 1
            if attempts > attempt_limit:
                # As a fallback, randomize a center and try again
                r = random.randrange(h)
                c = random.randrange(w)
                input_grid = build_gradient(w, h, r, c)
                output_grid = apply_chain_reaction(input_grid)
                key = (tuple(tuple(row) for row in input_grid), tuple(tuple(row) for row in output_grid))
                if key in VISITED:
                    continue
                if input_grid != output_grid:
                    VISITED.add(key)
                    return {"input": input_grid, "output": output_grid}
                continue
            else:
                continue

        # Ensure the pair is non-trivial (input != output)
        if input_grid == output_grid:
            # Try a few small center shifts to make the pattern nontrivial
            made_variant = False
            for shift in (1, 2, 3, 4):
                r2 = (r + shift) % h
                c2 = (c + shift * 2) % w
                input_grid2 = build_gradient(w, h, r2, c2)
                output_grid2 = apply_chain_reaction(input_grid2)
                key2 = (tuple(tuple(row) for row in input_grid2), tuple(tuple(row) for row in output_grid2))
                if key2 not in VISITED and input_grid2 != output_grid2:
                    VISITED.add(key2)
                    return {"input": input_grid2, "output": output_grid2}
            # If none of the small shifts produced a change, continue with next seed
            continue

        # Accept this unique, nontrivial pair
        VISITED.add(key)
        return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input (tuple of tuples) to mutable list of lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0]) if h > 0 else 0

    # Iteratively apply simultaneous chain-reaction updates until stable
    while True:
        changed = False
        new_grid = [row[:] for row in grid]
        for i in range(h):
            for j in range(w):
                a = grid[i][j]
                if a == 0:
                    continue
                max_val = a
                for di, dj in ((0, 1), (1, 0), (0, -1), (-1, 0)):
                    ni, nj = i + di, j + dj
                    if 0 <= ni < h and 0 <= nj < w:
                        b = grid[ni][nj]
                        if b == 0:
                            continue
                        if abs(a - b) == 1:
                            v = min(a, b) + 2
                            if v > 9:
                                v = 9
                            if v > max_val:
                                max_val = v
                if max_val != a:
                    new_grid[i][j] = max_val
                    changed = True
        grid = new_grid
        if not changed:
            break

    return tuple(tuple(row) for row in grid)
