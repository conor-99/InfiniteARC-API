# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: d66375f4
Difficulty: mediumâ€“hard

=== Tags ===
- Dependency topological sort
- Color space mapping
- Chain reaction
- Transformation stack
- Detect closed curves
- Expand repeating unit

=== Description ===
Input grids consist of nested closed loops (4-connected cycles with no branches)
of distinct colors on a uniform background. Each loop forms a closed shape where
every cell within the loop has exactly two adjacent loop cells, creating a
continuous boundary. Loops are hierarchically nested, with some loops entirely
enclosed within others, forming a clear containment structure.  The task
requires: 1. Detecting all closed loops in the input grid through visual
analysis of continuous boundaries. 2. Performing a topological sort of loops
based on nesting depth (innermost loops processed first). 3. Applying a color
space mapping where each loop's original color is replaced with a new color
determined by its position in the sorted list (e.g., the first loop becomes
color 1, second becomes color 2, etc.). 4. Executing a transformation stack that
sequentially applies the color mapping and then expands the grid by replicating
the entire transformed loop structure into a 2x2 grid pattern across the output.
5. The output grid dimensions are double the input's width and height, with each
quadrant containing a scaled copy of the transformed loop structure, maintaining
all nesting relationships and color mappings while filling gaps with the
background color.  This process ensures the output visually demonstrates a chain
reaction of transformations: detecting boundaries triggers sorting, which drives
color mapping, which then enables the expansion of the repeating loop pattern
across the grid. The solution requires identifying closed curves, understanding
dependency relationships, applying consistent color transformations, and
executing a structured expansion.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

_PREV_INPUTS = set()

def is_closed_loop(component, grid):
    if not component: return False
    H = len(grid)
    W = len(grid[0]) if H>0 else 0
    for (r,c) in component:
        count = 0
        for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):
            nr, nc = r+dr, c+dc
            if 0<=nr<H and 0<=nc<W and grid[nr][nc]==grid[r][c]:
                count += 1
        if count != 2:
            return False
    return True

def generate():
    # Attempt until we produce a valid, previously unseen input
    for attempt in range(1000):
        W = random.randint(6, 15)
        H = random.randint(6, 15)
        min_dim = min(W, H)
        max_possible_loops = min(4, (min_dim - 1) // 2)
        if max_possible_loops < 2:
            continue
        num_loops = random.randint(2, max_possible_loops)
        outer_size_min = 3 + 2*(num_loops - 1)
        outer_size = random.randint(outer_size_min, min_dim)
        top = random.randint(0, H - outer_size)
        left = random.randint(0, W - outer_size)
        colors = common.random_colors(num_loops, exclude=[0])
        grid = common.grid(W, H, 0)
        # Draw nested rectangular loops (frames)
        for i in range(num_loops):
            size = outer_size - 2 * i
            t = top + i
            l = left + i
            col = colors[i]
            # vertical sides
            for r in range(t, t + size):
                grid[r][l] = col
                grid[r][l + size - 1] = col
            # horizontal sides (avoid overdrawing corners twice)
            if size >= 3:
                for c in range(l + 1, l + size - 1):
                    grid[t][c] = col
                    grid[t + size - 1][c] = col
        # Validate loops and collect info
        loop_info = []
        valid = True
        for col in colors:
            component = [(r, c) for r in range(H) for c in range(W) if grid[r][c] == col]
            if not is_closed_loop(component, grid):
                valid = False
                break
            min_r = min(r for r, _ in component)
            max_r = max(r for r, _ in component)
            min_c = min(c for _, c in component)
            max_c = max(c for _, c in component)
            area = (max_r - min_r) * (max_c - min_c)
            loop_info.append((area, col, component))
        if not valid:
            continue
        # Sort by bounding-box area (innermost first). Tie-breaker: color value.
        loop_info.sort(key=lambda x: (x[0], x[1]))
        color_map = {color: idx + 1 for idx, (area, color, _) in enumerate(loop_info)}
        transformed = common.grid(W, H, 0)
        for r in range(H):
            for c in range(W):
                v = grid[r][c]
                if v != 0:
                    transformed[r][c] = color_map[v]
        # Expand to 2x2 tiled output
        out_W = 2 * W
        out_H = 2 * H
        output = common.grid(out_W, out_H, 0)
        for r in range(H):
            for c in range(W):
                val = transformed[r][c]
                output[r][c] = val
                output[r][c + W] = val
                output[r + H][c] = val
                output[r + H][c + W] = val
        inp_t = tuple(tuple(row) for row in grid)
        if inp_t in _PREV_INPUTS:
            continue
        _PREV_INPUTS.add(inp_t)
        return {'input': grid, 'output': output}
    # If we fail to produce a valid grid after many attempts, raise an error
    raise RuntimeError('Failed to generate a valid grid')



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0]) if H > 0 else 0
    # collect colors present (non-zero)
    colors = sorted({grid[r][c] for r in range(H) for c in range(W) if grid[r][c] != 0})
    def is_closed_loop(component):
        if not component:
            return False
        for (r, c) in component:
            count = 0
            for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):
                nr, nc = r + dr, c + dc
                if 0 <= nr < H and 0 <= nc < W and grid[nr][nc] == grid[r][c]:
                    count += 1
            if count != 2:
                return False
        return True
    loop_info = []
    for col in colors:
        component = [(r, c) for r in range(H) for c in range(W) if grid[r][c] == col]
        if not is_closed_loop(component):
            continue
        min_r = min(r for r, _ in component)
        max_r = max(r for r, _ in component)
        min_c = min(c for _, c in component)
        max_c = max(c for _, c in component)
        area = (max_r - min_r) * (max_c - min_c)
        loop_info.append((area, col, component))
    # sort same as generator: by area then by color
    loop_info.sort(key=lambda x: (x[0], x[1]))
    color_map = {color: idx + 1 for idx, (area, color, _) in enumerate(loop_info)}
    transformed = [[0] * W for _ in range(H)]
    for r in range(H):
        for c in range(W):
            v = grid[r][c]
            if v != 0:
                transformed[r][c] = color_map.get(v, 0)
    out_W = 2 * W
    out_H = 2 * H
    output = [[0] * out_W for _ in range(out_H)]
    for r in range(H):
        for c in range(W):
            val = transformed[r][c]
            output[r][c] = val
            output[r][c + W] = val
            output[r + H][c] = val
            output[r + H][c + W] = val
    return output

