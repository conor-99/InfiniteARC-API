# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 34532648
Difficulty: hard

=== Tags ===
- Draw path through ordered checkpoints
- State transfer chain
- Simulate gravity with obstacles
- Pattern modification
- Detect grid

=== Description ===
Input grids are large (20×20 to 30×30) with a single background color (0). The
grid contains:  - **Obstacles**: Vertical or horizontal wall segments (color 1)
of length 1–3 cells, placed such that they do not touch each other, grid edges,
or the hidden grid lines. - **Checkpoints**: A sequence of distinct colors (2,
3, 4, 5) positioned at intersections of a hidden 3×3 grid pattern (i.e., every 3
columns and rows). Checkpoints must be traversed in strict order (color 2 → 3 →
4 → 5), with each checkpoint's color encoding the next movement direction:   -
Color 2: move downward (gravity default)   - Color 3: move right   - Color 4:
move left   - Color 5: move upward - **Hidden Grid**: A structural pattern
defined by invisible grid lines every 3 cells horizontally and vertically;
checkpoint positions align precisely with grid intersections.  In the output
grid:  1. The path is drawn as a continuous line of color 6, starting at the
first checkpoint (color 2) and moving downward along the hidden grid lines. 2.
Upon reaching each checkpoint, the path changes direction per the checkpoint's
color, continuing along the hidden grid lines (e.g., moving right after color 3,
left after color 4). 3. When the path encounters an obstacle (color 1), it
navigates around it by moving along the grid lines (e.g., if moving down and
obstacle blocks the path, the path turns right/left to bypass while staying on
grid lines). 4. The path must traverse all checkpoints in order without
overlapping obstacles, checkpoint cells (except at the checkpoint itself), or
other path segments. 5. The path exits the grid after passing the last
checkpoint (color 5), with all direction changes and obstacle navigations
applied correctly.  The task requires detecting the hidden grid from checkpoint
positions, following a state transfer chain (direction changes at each
checkpoint), simulating gravity (initial downward movement), navigating
obstacles while modifying the background grid, and ensuring the path adheres to
the grid structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid


def generate():
    """
    Generates an ARC-style input/output pair for the task.

    Strategy:
    - Choose a random size between 20 and 30.
    - Hidden grid lines lie at indices 3,6,9,... (i.e. multiples of 3, excluding 0).
    - Choose four intersections that form the corners of an axis-aligned rectangle
      (top-left, bottom-left, bottom-right, top-right). These become checkpoints
      with colors 2,3,4,5 respectively.
    - Place a number of short obstacles (color 1) strictly off the hidden grid
      lines so they do not block the path along the hidden grid lines.
      Obstacles are placed so they don't touch each other or the checkpoints.
    - Build the output by drawing the path (color 6) along the hidden grid lines:
      2 -> move down to 3
      3 -> move right to 4
      4 -> move up to 5
      5 -> move left until exiting the grid

    The output path only writes color 6 on background cells (0) and leaves
    checkpoints and obstacles unchanged.
    """
    # choose size
    size = random.randint(20, 30)
    ingrid = grid(size, size, 0)

    # hidden grid line indices (avoid using 0 so intersections are away from the very edge)
    grid_indices = [3 * i for i in range(1, size // 3)]
    # ensure we have at least two distinct rows and columns
    if len(grid_indices) < 2:
        # fallback to a minimal valid layout (should not happen for sizes >=20)
        r_top, r_bottom = 3, 6
        c_left, c_right = 3, 6
    else:
        r_top, r_bottom = sorted(random.sample(grid_indices, 2))
        c_left, c_right = sorted(random.sample(grid_indices, 2))

    # define checkpoints corners of rectangle (clockwise)
    p2 = (r_top, c_left)    # color 2 (start)
    p3 = (r_bottom, c_left) # color 3
    p4 = (r_bottom, c_right) # color 4
    p5 = (r_top, c_right)   # color 5 (last)
    checkpoints = [p2, p3, p4, p5]

    # place checkpoints
    for idx, (r, c) in enumerate(checkpoints):
        ingrid[r][c] = 2 + idx

    # Place obstacles (color 1) strictly off the hidden grid lines.
    # Obstacles are short segments (length 1-3). They will not touch each other
    # (no cardinal adjacency) and will not be adjacent to checkpoint cells.
    used = set()  # cells occupied by obstacles
    obstacles = []
    num_obstacles = random.randint(6, 18)
    attempts = 0
    max_attempts = 1000
    while len(obstacles) < num_obstacles and attempts < max_attempts:
        attempts += 1
        orient = random.choice([0, 1])  # 0 -> horizontal, 1 -> vertical
        length = random.randint(1, 3)
        r0 = random.randint(1, size - 2)
        c0 = random.randint(1, size - 2)

        cells = []
        ok = True
        for i in range(length):
            r = r0 + (i if orient == 1 else 0)
            c = c0 + (i if orient == 0 else 0)
            # keep away from borders
            if r < 1 or r >= size - 1 or c < 1 or c >= size - 1:
                ok = False
                break
            # ensure obstacle cells are strictly off grid lines
            if r % 3 == 0 or c % 3 == 0:
                ok = False
                break
            # avoid overlapping other obstacles
            if (r, c) in used:
                ok = False
                break
            # avoid touching any existing obstacle cell (cardinal neighbors)
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                if (r + dr, c + dc) in used:
                    ok = False
                    break
            if not ok:
                break
            # do not touch checkpoints (including adjacency)
            for pr, pc in checkpoints:
                if abs(pr - r) + abs(pc - c) <= 1:
                    ok = False
                    break
            if not ok:
                break
            cells.append((r, c))

        if not ok or len(cells) == 0:
            continue
        for (r, c) in cells:
            used.add((r, c))
            ingrid[r][c] = 1
        obstacles.append(cells)

    # Build output by drawing the path along the hidden grid lines.
    output = [row[:] for row in ingrid]
    # Direction mapping chosen so the rectangle path does not overlap itself:
    # 2 -> down, 3 -> right, 4 -> up, 5 -> left
    mapping = {2: (1, 0), 3: (0, 1), 4: (-1, 0), 5: (0, -1)}

    for idx in range(0, 3):
        color = 2 + idx
        dr, dc = mapping[color]
        r, c = checkpoints[idx]
        tr, tc = checkpoints[idx + 1]
        # step from checkpoint to next checkpoint along the mapped direction
        while (r, c) != (tr, tc):
            r += dr
            c += dc
            if not (0 <= r < size and 0 <= c < size):
                break
            # only draw on background cells
            if ingrid[r][c] == 0:
                output[r][c] = 6

    # After last checkpoint (color 5) move left until exiting the grid
    last_color = 5
    dr, dc = mapping[last_color]
    r, c = checkpoints[-1]
    while True:
        r += dr
        c += dc
        if not (0 <= r < size and 0 <= c < size):
            break
        if ingrid[r][c] == 0:
            output[r][c] = 6
        else:
            # if something unexpected is on the line (shouldn't happen with our placement), stop
            break

    return {
        "input": ingrid,
        "output": output
    }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    size = len(grid)

    # find checkpoints (colors 2..5)
    checkpoints = {}
    for r in range(size):
        for c in range(size):
            v = grid[r][c]
            if 2 <= v <= 5:
                checkpoints[v] = (r, c)

    # Expect colors 2,3,4,5 to be present
    # Direction mapping must match the generator:
    # 2 -> down, 3 -> right, 4 -> up, 5 -> left
    mapping = {2: (1, 0), 3: (0, 1), 4: (-1, 0), 5: (0, -1)}

    # Draw path between successive checkpoints
    for color in (2, 3, 4):
        if color not in checkpoints or (color + 1) not in checkpoints:
            continue
        dr, dc = mapping[color]
        r, c = checkpoints[color]
        tr, tc = checkpoints[color + 1]
        # step along direction until we reach the next checkpoint
        while (r, c) != (tr, tc):
            r += dr
            c += dc
            if not (0 <= r < size and 0 <= c < size):
                break
            # only paint background cells
            if grid[r][c] == 0:
                grid[r][c] = 6

    # After the last checkpoint (color 5) continue in its direction until exiting the grid
    if 5 in checkpoints:
        dr, dc = mapping[5]
        r, c = checkpoints[5]
        while True:
            r += dr
            c += dc
            if not (0 <= r < size and 0 <= c < size):
                break
            if grid[r][c] == 0:
                grid[r][c] = 6
            else:
                # unexpected non-background cell encountered; stop
                break

    return tuple(tuple(row) for row in grid)

