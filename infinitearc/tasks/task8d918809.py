# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 8d918809
Difficulty: insane

=== Tags ===
- Mirrored attribute binding
- Rotate to canonical

=== Description ===
Input grids feature a complex arrangement of colored shapes (colors 1-9) on a
uniform background (color 0), with a unique "T" shape composed of color 5 (a 3x3
pattern with a vertical stem and horizontal top bar) appearing exactly once. The
color of the top-left non-background cell (1-9) binds to the mirror axis: red
(color 1) specifies vertical mirroring, blue (color 2) specifies horizontal
mirroring. The entire grid is mirrored across this axis. The mirrored grid is
then rotated in 90Â° increments until the "T" shape's stem points vertically
upward, establishing the canonical orientation. The output grid reflects both
the axis-specific mirror transformation and the final rotational alignment of
the "T" shape.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from copy import deepcopy

def generate():
    # Attempt until valid sample
    for _ in range(100):
        h = random.randint(5, 20)
        w = random.randint(5, 20)
        grid = [[0 for _ in range(w)] for _ in range(h)]
        # Place binding color at top-leftmost non-background cell (we use (0,0))
        binding_color = random.choice([1,2])
        grid[0][0] = binding_color
        # Place exactly one T shape (color 5) in a random position and random orientation,
        # ensuring it does not cover the binding cell at (0,0).
        if h < 3 or w < 3:
            continue
        # generate list of possible top-left corners for the 3x3 T block excluding (0,0)
        positions = [(r,c) for r in range(0, h-2) for c in range(0, w-2) if not (r==0 and c==0)]
        if not positions:
            continue
        r_t, c_t = random.choice(positions)
        # canonical inverted-T coordinates within 3x3 block: stem pointing up (bar at bottom)
        canonical_coords = [(0,1),(1,1),(2,0),(2,1),(2,2)]
        # rotate coords by k*90 degrees clockwise
        k = random.randint(0, 3)
        coords = canonical_coords
        for _ in range(k):
            coords = [(c, 2 - r) for (r,c) in coords]
        # place T
        for (dr,dc) in coords:
            grid[r_t + dr][c_t + dc] = 5
        # Fill other colored shapes randomly, avoiding color 5 so T is unique.
        for r in range(h):
            for c in range(w):
                if grid[r][c] != 0:
                    continue
                # random sparse decoration
                if random.random() < 0.25:
                    # choose a color 1-9 excluding 5
                    choices = [col for col in range(1,10) if col != 5]
                    grid[r][c] = random.choice(choices)
        # Mirror based on binding color: 1 => vertical mirror (flip left-right), 2 => horizontal mirror (flip top-bottom)
        if binding_color == 1:
            mirrored = [row[::-1] for row in grid]
        else:
            mirrored = grid[::-1]
        # rotation helper
        def rotate_90(g):
            return [list(row[::-1]) for row in zip(*g)]
        # canonical checker: inverted-T with bar on bottom row of a 3x3 block and stem upward
        def is_canonical(g):
            H = len(g); W = len(g[0])
            for rr in range(H - 2):
                for cc in range(W - 2):
                    if (g[rr+2][cc] == 5 and g[rr+2][cc+1] == 5 and g[rr+2][cc+2] == 5 and
                        g[rr][cc+1] == 5 and g[rr+1][cc+1] == 5):
                        return True
            return False
        # rotate mirrored grid until canonical orientation found
        current = mirrored
        for _ in range(4):
            if is_canonical(current):
                break
            current = rotate_90(current)
        # Ensure output is different from input (transformation must change the grid)
        if current == grid:
            # if identical, try again
            continue
        # ensure exactly one T of color 5 in input
        # we placed only one T and other positions don't contain 5 so ok
        return { "input": grid, "output": current }
    # fallback (should rarely happen)
    raise Exception('Failed to generate a valid grid')



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    H = len(grid); W = len(grid[0])
    # find top-left non-background cell (first cell in row-major order with value != 0)
    found = False
    for r in range(H):
        for c in range(W):
            if grid[r][c] != 0:
                binding_color = grid[r][c]
                found = True
                break
        if found:
            break
    if not found:
        # nothing to do
        return grid
    # Mirror based on binding color: 1 => vertical mirror (flip left-right), 2 => horizontal mirror (flip top-bottom)
    if binding_color == 1:
        mirrored = [row[::-1] for row in grid]
    elif binding_color == 2:
        mirrored = grid[::-1]
    else:
        mirrored = [row[::-1] for row in grid]
    # rotation helper: 90 degrees clockwise
    def rotate_90(g):
        return [list(row[::-1]) for row in zip(*g)]
    # canonical checker: inverted-T with bar on bottom row of a 3x3 block and stem upward
    def is_canonical(g):
        H = len(g); W = len(g[0])
        for rr in range(H - 2):
            for cc in range(W - 2):
                if (g[rr+2][cc] == 5 and g[rr+2][cc+1] == 5 and g[rr+2][cc+2] == 5 and
                    g[rr][cc+1] == 5 and g[rr+1][cc+1] == 5):
                    return True
        return False
    current = mirrored
    for _ in range(4):
        if is_canonical(current):
            break
        current = rotate_90(current)
    return current

