# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 922eea5a
Difficulty: insane

=== Tags ===
- Multi layer projection

=== Description ===
Task Name: Multi-Layer Projection Cascade  Description: Input grids feature a
series of concentric rectangular layers (typically 3-5), each defined by a
border of a unique color (1-9) surrounding a central region of another color.
Background is color 0. Each layer's border encloses the next inner layer, with
the innermost layer's central region being a solid color. The border thickness
is exactly 1 cell, and layers are perfectly centered relative to each other.
The output grid is generated by applying a "multi-layer projection"
transformation to each layer. For each layer, the border color determines both
the direction of projection and the transformation type: - Color 1 (blue): move
up by N cells - Color 2 (red): move right by N cells - Color 3 (green): move
down by N cells - Color 4 (yellow): move left by N cells - Color 5 (gray):
rotate 90° clockwise - Color 6 (pink): mirror horizontally - Color 7 (orange):
mirror vertically - Color 8 (cyan): rotate 180° - Color 9 (maroon): no movement
(retain position)  Here, N equals the numerical value of the inner layer's
border color (for the outermost layer, N=1). Layers are processed from outermost
to innermost. For movement layers (1-4), the entire border is shifted outward by
N cells in the specified direction while maintaining rectangular shape and
thickness. For rotation/mirror layers (5-8), the border is transformed in-place
before placement. Overlapping regions are resolved by prioritizing the outermost
layer's color (higher layer number overwrites inner layers).  The innermost
layer (with no inner layer) uses N=1 and follows the direction mapping. All
transformations must maintain the rectangular border structure, with shifted
borders possibly extending beyond the original grid boundaries (those portions
are discarded). The output grid displays all transformed borders on the
background, with overlapping cells resolved by the highest layer number.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    k = random.randint(3, 5)
    # Ensure not all borders are 9
    while True:
        borders = random.sample(range(1, 10), k)
        if not all(b == 9 for b in borders):
            break
    possible_colors = list(set(range(1, 10)) - set(borders))
    S = random.choice(possible_colors)
    size = 2 * k + 1
    input_grid = grid(size, size, 0)
    for i in range(k):
        r1, c1 = i, i
        r2, c2 = size - i - 1, size - i - 1
        for c in range(c1, c2 + 1):
            input_grid[r1][c] = borders[i]
            input_grid[r2][c] = borders[i]
        for r in range(r1 + 1, r2):
            input_grid[r][c1] = borders[i]
            input_grid[r][c2] = borders[i]
    center = size // 2
    input_grid[center][center] = S
    output_grid = grid(size, size, 0)
    for i in range(k):
        r1, c1 = i, i
        r2, c2 = size - i - 1, size - i - 1
        N = borders[i + 1] if i < k - 1 else 1
        color = borders[i]
        if color in (1, 2, 3, 4):
            if color == 1:
                r1_new, c1_new = r1 - N, c1
                r2_new, c2_new = r2 - N, c2
            elif color == 2:
                r1_new, c1_new = r1, c1 + N
                r2_new, c2_new = r2, c2 + N
            elif color == 3:
                r1_new, c1_new = r1 + N, c1
                r2_new, c2_new = r2 + N, c2
            else:  # color 4
                r1_new, c1_new = r1, c1 - N
                r2_new, c2_new = r2, c2 - N
        else:
            if color == 5:
                r1_new, c1_new = c1, size - 1 - r2
                r2_new, c2_new = c2, size - 1 - r1
            elif color == 6:
                r1_new, c1_new = r1, size - 1 - c2
                r2_new, c2_new = r2, size - 1 - c1
            elif color == 7:
                r1_new, c1_new = size - 1 - r2, c1
                r2_new, c2_new = size - 1 - r1, c2
            elif color == 8:
                r1_new, c1_new = size - 1 - r2, size - 1 - c2
                r2_new, c2_new = size - 1 - r1, size - 1 - c1
            else:  # color 9
                r1_new, c1_new = r1, c1
                r2_new, c2_new = r2, c2
        r1_new = max(0, min(r1_new, size - 1))
        c1_new = max(0, min(c1_new, size - 1))
        r2_new = max(0, min(r2_new, size - 1))
        c2_new = max(0, min(c2_new, size - 1))
        if r1_new > r2_new or c1_new > c2_new:
            continue
        for c in range(c1_new, c2_new + 1):
            if r1_new < size and r1_new >= 0:
                output_grid[r1_new][c] = color
            if r2_new < size and r2_new >= 0:
                output_grid[r2_new][c] = color
        for r in range(r1_new + 1, r2_new):
            if c1_new < size and c1_new >= 0:
                output_grid[r][c1_new] = color
            if c2_new < size and c2_new >= 0:
                output_grid[r][c2_new] = color
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    size = len(input_grid)
    k = (size - 1) // 2
    borders = [input_grid[i][i] for i in range(k)]
    output_grid = grid(size, size, 0)
    for i in range(k):
        r1, c1 = i, i
        r2, c2 = size - i - 1, size - i - 1
        N = borders[i + 1] if i < k - 1 else 1
        color = borders[i]
        if color in (1, 2, 3, 4):
            if color == 1:
                r1_new, c1_new = r1 - N, c1
                r2_new, c2_new = r2 - N, c2
            elif color == 2:
                r1_new, c1_new = r1, c1 + N
                r2_new, c2_new = r2, c2 + N
            elif color == 3:
                r1_new, c1_new = r1 + N, c1
                r2_new, c2_new = r2 + N, c2
            else:  # color 4
                r1_new, c1_new = r1, c1 - N
                r2_new, c2_new = r2, c2 - N
        else:
            if color == 5:
                r1_new, c1_new = c1, size - 1 - r2
                r2_new, c2_new = c2, size - 1 - r1
            elif color == 6:
                r1_new, c1_new = r1, size - 1 - c2
                r2_new, c2_new = r2, size - 1 - c1
            elif color == 7:
                r1_new, c1_new = size - 1 - r2, c1
                r2_new, c2_new = size - 1 - r1, c2
            elif color == 8:
                r1_new, c1_new = size - 1 - r2, size - 1 - c2
                r2_new, c2_new = size - 1 - r1, size - 1 - c1
            else:  # color 9
                r1_new, c1_new = r1, c1
                r2_new, c2_new = r2, c2
        r1_new = max(0, min(r1_new, size - 1))
        c1_new = max(0, min(c1_new, size - 1))
        r2_new = max(0, min(r2_new, size - 1))
        c2_new = max(0, min(c2_new, size - 1))
        if r1_new > r2_new or c1_new > c2_new:
            continue
        for c in range(c1_new, c2_new + 1):
            if r1_new < size and r1_new >= 0:
                output_grid[r1_new][c] = color
            if r2_new < size and r2_new >= 0:
                output_grid[r2_new][c] = color
        for r in range(r1_new + 1, r2_new):
            if c1_new < size and c1_new >= 0:
                output_grid[r][c1_new] = color
            if c2_new < size and c2_new >= 0:
                output_grid[r][c2_new] = color
    return output_grid
