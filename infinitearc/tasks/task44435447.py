# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 44435447
Difficulty: hard

=== Tags ===
- Divide by n
- Maze

=== Description ===
The task involves transforming a maze grid where the path is a continuous
sequence of connected cells (edge-wise) with a single non-zero color (path
color), while walls consist of other non-zero colors. The output grid is
generated by marking every nth cell along the path, where n equals the number of
distinct wall colors present in the input (excluding the path color). The
marking uses a fixed new color (e.g., 9) at positions 1×n, 2×n, etc., along the
path sequence. For example, if the path color is 1 and walls use colors 2, 3,
and 4 (n=3), every 3rd cell along the path is changed to 9. This requires
identifying the path, counting distinct wall colors, and applying the division
rule consistently. The complexity arises from the need to traverse the path,
count colors, and determine the division points without prior knowledge of n,
making it a challenging abstract reasoning task.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = [[0] * width for _ in range(height)]
    
    path_color = random.randint(1, 8)
    num_wall_colors = random.randint(1, 3)
    wall_colors = []
    while len(wall_colors) < num_wall_colors:
        color = random.randint(1, 9)
        if color != path_color and color not in wall_colors:
            wall_colors.append(color)
    n = len(wall_colors)
    
    # Path spans entire first row
    for c in range(width):
        grid[0][c] = path_color
    
    # Place walls randomly (avoid full rows to prevent solver confusion)
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 and random.random() > 0.5:
                if wall_colors:
                    grid[r][c] = random.choice(wall_colors)
    
    # Ensure all wall colors exist
    for color in wall_colors:
        if not any(grid[r][c] == color for r in range(height) for c in range(width)):
            r, c = random.randint(1, height-1), random.randint(0, width-1)
            grid[r][c] = color
    
    output = [row[:] for row in grid]
    path_cells = [(0, c) for c in range(width)]
    for idx in range(len(path_cells)):
        if (idx + 1) % n == 0:
            r, c = path_cells[idx]
            output[r][c] = 9
    
    return {
        'input': grid,
        'output': output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    
    # Path starts at (0,0), so use its color
    path_color = input_grid[0][0]
    
    # Find the connected component of path_color
    visited = [[False] * len(input_grid[0]) for _ in range(len(input_grid))]
    stack = [(0, 0)]
    visited[0][0] = True
    path_component = []
    
    while stack:
        cr, cc = stack.pop()
        path_component.append((cr, cc))
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = cr + dr, cc + dc
            if 0 <= nr < len(input_grid) and 0 <= nc < len(input_grid[0]) and not visited[nr][nc] and input_grid[nr][nc] == path_color:
                visited[nr][nc] = True
                stack.append((nr, nc))
    
    # Sort path_component to match generator's order
    path_component.sort(key=lambda x: (x[0], x[1]))
    
    # Count wall colors (non-zero, non-path)
    wall_colors = set()
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            color = input_grid[r][c]
            if color != 0 and color != path_color:
                wall_colors.add(color)
    n = len(wall_colors)
    
    output = [row[:] for row in input_grid]
    for idx in range(len(path_component)):
        if (idx + 1) % n == 0:
            r, c = path_component[idx]
            output[r][c] = 9
    
    return output
