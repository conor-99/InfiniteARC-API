# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 24cea2b9
Difficulty: easy

=== Tags ===
- Row parity coloring
- Out of boundary
- Seal gaps inside shape

=== Description ===
The input grid contains a closed shape defined by a boundary of non-zero values,
enclosing an internal area that includes empty cells (value 0). The output grid
fills all internal empty cells within the shape's boundary by coloring them
based on row parity: even-numbered rows (0, 2, 4, ...) are filled with color 1,
and odd-numbered rows (1, 3, 5, ...) are filled with color 2. The boundary of
the shape and all external cells remain unchanged. This transformation strictly
operates within the enclosed area, ignoring any gaps or cells outside the
shape's boundary.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    w = random.randint(3, 30)
    h = random.randint(3, 30)
    b_color = random.randint(1, 9)
    input_grid = [[0] * w for _ in range(h)]
    for i in range(w):
        input_grid[0][i] = b_color
        input_grid[h-1][i] = b_color
    for j in range(h):
        input_grid[j][0] = b_color
        input_grid[j][w-1] = b_color
    output_grid = [row[:] for row in input_grid]
    for r in range(1, h-1):
        for c in range(1, w-1):
            if r % 2 == 0:
                output_grid[r][c] = 1
            else:
                output_grid[r][c] = 2
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    h = len(input_grid)
    w = len(input_grid[0])
    output_grid = [row[:] for row in input_grid]
    for r in range(1, h-1):
        for c in range(1, w-1):
            if input_grid[r][c] == 0:
                if r % 2 == 0:
                    output_grid[r][c] = 1
                else:
                    output_grid[r][c] = 2
    return output_grid
