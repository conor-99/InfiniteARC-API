# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 86b2ed85
Difficulty: very hard

=== Tags ===
- Pattern to sequence mapping
- Heat map draw
- Periodic tiling

=== Description ===
Input grids are large (20×20 to 30×30) with a uniform background color. Overlaid
is a periodic tiling of 4×4 blocks, where each block's main diagonal (top-left
to bottom-right) contains a sequence of four distinct non-background colors.
This diagonal sequence forms the pattern. The output grid is a heat map where
each cell's color is determined by its relative position within the 4×4 block:
for cell (i, j), compute (i mod 4 + j mod 4) modulo 4, then select the
corresponding color from the diagonal sequence in a cyclic manner. The resulting
grid forms a continuous gradient that visually aligns with the underlying
periodic structure, with each 4×4 section repeating the diagonal sequence to
create a seamless, non-overlapping visual pattern. The transformation requires
detecting the diagonal pattern, mapping it to a sequence, and applying the
sequence through modular arithmetic to generate the output's color distribution.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
def generate():
    bg = random.randint(0, 9)
    colors = []
    while len(colors) < 4:
        c = random.randint(0, 9)
        if c != bg and c not in colors:
            colors.append(c)
    size = random.randint(20, 30)
    width = size
    height = size
    input_grid = [[bg] * width for _ in range(height)]
    for i in range(height):
        for j in range(width):
            if i % 4 == j % 4:
                k = i % 4
                input_grid[i][j] = colors[k]
    output_grid = [[0] * width for _ in range(height)]
    for i in range(height):
        for j in range(width):
            k = (i % 4 + j % 4) % 4
            output_grid[i][j] = colors[k]
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    colors = [
        input_grid[0][0],
        input_grid[1][1],
        input_grid[2][2],
        input_grid[3][3]
    ]
    height = len(input_grid)
    width = len(input_grid[0])
    output = [[0] * width for _ in range(height)]
    for i in range(height):
        for j in range(width):
            k = (i % 4 + j % 4) % 4
            output[i][j] = colors[k]
    return output
