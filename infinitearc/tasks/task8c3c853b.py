# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 8c3c853b
Difficulty: easy

=== Tags ===
- Swap rows
- Connect the dots
- Remove singletons
- Image repetition

=== Description ===
The task requires transforming an input grid into an output grid through four
sequential steps: (1) Remove all singleton cells (cells with no adjacent cells
of the same color), setting them to 0; (2) Connect the dots by filling gaps
between same-color cells in rows and columns with that color; (3) Swap the first
and second rows of the grid; (4) Horizontally duplicate the grid to double its
width. The output grid will thus have the same height as the input, but double
the width, with all transformations applied in order.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def remove_singletons(grid):
    rows = len(grid)
    cols = len(grid[0])
    new_grid = [row[:] for row in grid]
    for r in range(rows):
        for c in range(cols):
            color = grid[r][c]
            has_neighbor = False
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < rows and 0 <= nc < cols:
                    if grid[nr][nc] == color:
                        has_neighbor = True
                        break
            if not has_neighbor:
                new_grid[r][c] = 0
    return new_grid

def connect_dots(grid):
    rows = len(grid)
    cols = len(grid[0])
    new_grid = [row[:] for row in grid]
    for r in range(rows):
        for c in range(cols):
            if new_grid[r][c] != 0:
                continue
            left_color = None
            for dc in range(c-1, -1, -1):
                if new_grid[r][dc] != 0:
                    left_color = new_grid[r][dc]
                    break
            right_color = None
            for dc in range(c+1, cols):
                if new_grid[r][dc] != 0:
                    right_color = new_grid[r][dc]
                    break
            if left_color == right_color and left_color is not None:
                new_grid[r][c] = left_color
    for c in range(cols):
        for r in range(rows):
            if new_grid[r][c] != 0:
                continue
            up_color = None
            for dr in range(r-1, -1, -1):
                if new_grid[dr][c] != 0:
                    up_color = new_grid[dr][c]
                    break
            down_color = None
            for dr in range(r+1, rows):
                if new_grid[dr][c] != 0:
                    down_color = new_grid[dr][c]
                    break
            if up_color == down_color and up_color is not None:
                new_grid[r][c] = up_color
    return new_grid

def swap_rows(grid):
    if len(grid) < 2:
        return grid
    new_grid = [row[:] for row in grid]
    new_grid[0], new_grid[1] = new_grid[1], new_grid[0]
    return new_grid

def duplicate_horizontal(grid):
    new_grid = []
    for row in grid:
        new_grid.append(row + row)
    return new_grid

def generate():
    width = random.randint(1, 15)
    height = random.randint(2, 30)
    input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
    
    grid1 = remove_singletons(input_grid)
    grid2 = connect_dots(grid1)
    grid3 = swap_rows(grid2)
    output_grid = duplicate_horizontal(grid3)
    
    if input_grid == output_grid:
        return generate()
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def remove_singletons(grid):
    rows = len(grid)
    cols = len(grid[0])
    new_grid = [row[:] for row in grid]
    for r in range(rows):
        for c in range(cols):
            color = grid[r][c]
            has_neighbor = False
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < rows and 0 <= nc < cols:
                    if grid[nr][nc] == color:
                        has_neighbor = True
                        break
            if not has_neighbor:
                new_grid[r][c] = 0
    return new_grid

def connect_dots(grid):
    rows = len(grid)
    cols = len(grid[0])
    new_grid = [row[:] for row in grid]
    for r in range(rows):
        for c in range(cols):
            if new_grid[r][c] != 0:
                continue
            left_color = None
            for dc in range(c-1, -1, -1):
                if new_grid[r][dc] != 0:
                    left_color = new_grid[r][dc]
                    break
            right_color = None
            for dc in range(c+1, cols):
                if new_grid[r][dc] != 0:
                    right_color = new_grid[r][dc]
                    break
            if left_color == right_color and left_color is not None:
                new_grid[r][c] = left_color
    for c in range(cols):
        for r in range(rows):
            if new_grid[r][c] != 0:
                continue
            up_color = None
            for dr in range(r-1, -1, -1):
                if new_grid[dr][c] != 0:
                    up_color = new_grid[dr][c]
                    break
            down_color = None
            for dr in range(r+1, rows):
                if new_grid[dr][c] != 0:
                    down_color = new_grid[dr][c]
                    break
            if up_color == down_color and up_color is not None:
                new_grid[r][c] = up_color
    return new_grid

def swap_rows(grid):
    if len(grid) < 2:
        return grid
    new_grid = [row[:] for row in grid]
    new_grid[0], new_grid[1] = new_grid[1], new_grid[0]
    return new_grid

def duplicate_horizontal(grid):
    new_grid = []
    for row in grid:
        new_grid.append(row + row)
    return new_grid

def p(input_grid):
    # Ensure input is list of lists (convert if tuple)
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    grid1 = remove_singletons(input_grid)
    grid2 = connect_dots(grid1)
    grid3 = swap_rows(grid2)
    output_grid = duplicate_horizontal(grid3)
    return output_grid
