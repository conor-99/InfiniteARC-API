# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: fa21af49
Difficulty: very hard

=== Tags ===
- Stateful propagation
- Laser diffusion

=== Description ===
Input grids are large (20×20 minimum) with a uniform background color (0).
Within this background, distinct colored elements define a complex propagation
system: laser sources (color 1) exclusively positioned along the left edge,
emitting beams rightward; reflectors (color 2) that alter beam direction by 90°
clockwise upon contact while incrementing the beam's color; diffusers (color 3)
that split a single beam into two perpendicular beams (e.g., right → up/down),
each with color incremented by 1; and absorbers (color 4) that terminate beam
propagation. The output grid renders all beam paths using their current color at
each cell, with background remaining color 0. Propagation proceeds as follows:
beams travel through background cells, changing direction at reflectors,
splitting at diffusers (with each new beam continuing independently), and
terminating at absorbers. Direction changes follow a consistent clockwise
rotation (right → up → left → down → right), and color increments occur
immediately upon encountering a reflector or diffuser. Beams may interact with
multiple elements in sequence, with splits creating concurrent paths that may
themselves split or reflect. The grid is designed such that all paths eventually
terminate or exit the grid, avoiding infinite loops or overlapping paths that
would require resolution rules. The task demands tracking multiple stateful
beams (color and direction) through a network of interactions, where the final
output reveals the cumulative visual trace of all propagation events without
overwriting existing elements.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(20, 30)
    height = random.randint(20, 30)
    grid = [[0] * width for _ in range(height)]
    
    laser_rows = random.sample(range(5, height - 5), random.randint(1, 2))
    for r in laser_rows:
        grid[r][0] = 1
    
    absorber_rows = random.sample(range(5, height - 5), random.randint(1, 2))
    for r in absorber_rows:
        grid[r][width - 1] = 4
    
    for _ in range(random.randint(3, 5)):
        r = random.randint(1, height - 2)
        c = random.randint(1, width - 2)
        if grid[r][c] == 0:
            grid[r][c] = random.choice([2, 3])
    
    output = [row[:] for row in grid]
    directions = [(0, 1), (-1, 0), (0, -1), (1, 0)]
    beams = []
    for r in range(height):
        if grid[r][0] == 1:
            beams.append((r, 0, 0, 1))
    
    while beams:
        r, c, d, color = beams.pop(0)
        dr, dc = directions[d]
        nr, nc = r + dr, c + dc
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            continue
        current_val = grid[nr][nc]
        if current_val == 0:
            output[nr][nc] = color
            beams.append((nr, nc, d, color))
        elif current_val == 2:
            new_d = (d + 1) % 4
            new_color = color + 1
            beams.append((nr, nc, new_d, new_color))
        elif current_val == 3:
            new_d1 = (d + 1) % 4
            new_d2 = (d - 1) % 4
            new_color = color + 1
            beams.append((nr, nc, new_d1, new_color))
            beams.append((nr, nc, new_d2, new_color))
        elif current_val == 4:
            pass
    
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    directions = [(0, 1), (-1, 0), (0, -1), (1, 0)]
    beams = []
    for r in range(height):
        if grid[r][0] == 1:
            beams.append((r, 0, 0, 1))
    
    output = [row[:] for row in grid]
    
    while beams:
        r, c, d, color = beams.pop(0)
        dr, dc = directions[d]
        nr, nc = r + dr, c + dc
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            continue
        current_val = grid[nr][nc]
        if current_val == 0:
            output[nr][nc] = color
            beams.append((nr, nc, d, color))
        elif current_val == 2:
            new_d = (d + 1) % 4
            new_color = color + 1
            beams.append((nr, nc, new_d, new_color))
        elif current_val == 3:
            new_d1 = (d + 1) % 4
            new_d2 = (d - 1) % 4
            new_color = color + 1
            beams.append((nr, nc, new_d1, new_color))
            beams.append((nr, nc, new_d2, new_color))
        elif current_val == 4:
            pass
    
    return tuple(tuple(row) for row in output)
