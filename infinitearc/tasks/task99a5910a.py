# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 99a5910a
Difficulty: insane

=== Tags ===
- Directional routing
- Remove thin noise
- Snap objects to gridlines

=== Description ===
Input grids feature dense, multi-colored arrangements of irregular objects on a
background, each object being a contiguous region of at least four pixels. These
objects are surrounded by thin noise: single-pixel extensions (e.g., a pixel
protruding from a corner), one-pixel-wide connecting lines between objects, and
isolated pixels not part of any object's structure. Objects are also slightly
misaligned from integer grid lines (e.g., a rectangle's top edge spans non-
integer row boundaries), disrupting precise alignment. Additionally, directional
arrows (small, distinct-colored markers) are embedded within the grid,
indicating movement sequences (e.g., ↑, →, ↓, ←) that must guide path routing.
The output grid requires three sequential transformations applied in order:  1.
**Thin Noise Removal**: All single-pixel artifacts are eliminated. This includes
isolated pixels (no adjacent pixels in any direction), one-pixel extensions
beyond natural object boundaries, and thin lines connecting objects (not part of
either object's structure). Noise is identified by its minimal size and lack of
connection to larger contiguous regions.  2. **Gridline Snapping**: Each main
object is adjusted to align its bounding box precisely with integer grid lines.
For example, if an object's top edge is offset by 0.3 pixels, it is shifted to
align with the nearest row boundary. This ensures all edges (top, bottom, left,
right) rest exactly on grid lines, eliminating fractional positioning.  3.
**Directional Routing**: A path is drawn following the sequence of directional
arrows present in the input. The path starts at a designated anchor (e.g., the
top-left corner of the grid), moves one cell per step in the direction specified
by each arrow, and connects to a target object's center. The path is rendered as
a continuous line of the target object's color on background cells only,
avoiding all snapped objects. The path must strictly adhere to the arrow
sequence, stopping if it hits an object or grid boundary. Directional arrows
remain visible in the output, but the path is added over background pixels.  All
transformations interact: noise removal affects object boundaries, which
influences snapping accuracy, and snapped objects must not obstruct the
directional path. The task demands precise visual reasoning across multiple
layers of abstraction, with no reliance on numerical values or pixel-level
matching.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_el, random_you, random_aitch, rand_sprite, random_color

def generate():
    width = random.randint(15, 30)
    height = random.randint(15, 30)
    bg = 0
    grid_input = [[bg] * width for _ in range(height)]
    
    # Create main objects (contiguous regions >=4 pixels)
    colors = []
    objects = []
    for _ in range(random.randint(3, 5)):
        color = random_color(exclude=colors + [bg])
        colors.append(color)
        shape_name = random.choice(['el', 'you', 'aitch'])
        shape = rand_sprite(shape_name, width, height)
        while len(shape) < 4:
            shape = rand_sprite(shape_name, width, height)
        objects.append((color, shape))
    
    # Place objects on grid
    for color, shape in objects:
        for r, c in shape:
            if 0 <= r < height and 0 <= c < width:
                grid_input[r][c] = color

    # Add noise: isolated pixels not adjacent to objects
    noise_pixels = []
    for r in range(height):
        for c in range(width):
            if grid_input[r][c] != bg:
                continue
            has_neighbor = False
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid_input[nr][nc] != bg:
                    has_neighbor = True
                    break
            if not has_neighbor:
                noise_pixels.append((r, c))
    
    # Add isolated noise pixels
    for _ in range(random.randint(5, 15)):
        if noise_pixels:
            r, c = random.choice(noise_pixels)
            grid_input[r][c] = random_color(exclude=[bg] + colors)

    # Place directional arrows (two-cell glyphs) along path
    # Path from (0,0) to target object center
    target_obj = random.choice(objects)
    target_center = (random.randint(5, height-6), random.randint(5, width-6))
    path = []
    current = (0, 0)
    while current != target_center:
        if current[1] < target_center[1]:
            current = (current[0], current[1] + 1)
        elif current[1] > target_center[1]:
            current = (current[0], current[1] - 1)
        elif current[0] < target_center[0]:
            current = (current[0] + 1, current[1])
        elif current[0] > target_center[0]:
            current = (current[0] - 1, current[1])
        path.append(current)
    
    arrow_color = random_color(exclude=colors + [bg])
    for i in range(len(path) - 1):
        r1, c1 = path[i]
        r2, c2 = path[i+1]
        if r1 == r2 and c1 + 1 == c2:
            grid_input[r1][c1] = arrow_color
            grid_input[r1][c1+1] = arrow_color
        elif c1 == c2 and r1 + 1 == r2:
            grid_input[r1][c1] = arrow_color
            grid_input[r1+1][c1] = arrow_color

    # Generate output grid
    grid_output = [[bg] * width for _ in range(height)]
    
    # Step 1: Remove noise (keep components >=4 pixels)
    visited = [[False] * width for _ in range(height)]
    components = []
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and grid_input[r][c] != bg:
                comp = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    comp.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr+dr, cc+dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid_input[nr][nc] != bg:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append(comp)
    
    main_components = [comp for comp in components if len(comp) >= 4]
    
    # Step 2: Snap objects to bounding boxes
    for comp in main_components:
        min_r = min(r for r, c in comp)
        max_r = max(r for r, c in comp)
        min_c = min(c for r, c in comp)
        max_c = max(c for r, c in comp)
        color = grid_input[comp[0][0]][comp[0][1]]
        for r in range(min_r, max_r+1):
            for c in range(min_c, max_c+1):
                grid_output[r][c] = color

    # Step 3: Draw path
    if arrow_color in [grid_input[r][c] for r in range(height) for c in range(width)]:
        # Find arrow positions
        arrow_positions = []
        for r in range(height):
            for c in range(width):
                if grid_input[r][c] == arrow_color:
                    if c+1 < width and grid_input[r][c+1] == arrow_color:
                        arrow_positions.append((r, c, 'right'))
                    elif r+1 < height and grid_input[r+1][c] == arrow_color:
                        arrow_positions.append((r, c, 'down'))
        
        # Sort by path order
        arrow_positions.sort(key=lambda x: (x[0], x[1]))
        directions = [d for _, _, d in arrow_positions]
        
        # Compute path
        path = [(0, 0)]
        r, c = 0, 0
        for d in directions:
            if d == 'right':
                c += 1
            elif d == 'down':
                r += 1
            path.append((r, c))
        
        # Find target object color
        target_color = None
        for comp in main_components:
            min_r = min(r for r, c in comp)
            max_r = max(r for r, c in comp)
            min_c = min(c for r, c in comp)
            max_c = max(c for r, c in comp)
            if min_r <= path[-1][0] <= max_r and min_c <= path[-1][1] <= max_c:
                target_color = grid_input[comp[0][0]][comp[0][1]]
                break
        if target_color is None:
            target_color = random.choice(colors)
        
        # Draw path
        for r, c in path:
            if 0 <= r < height and 0 <= c < width and grid_output[r][c] == bg:
                grid_output[r][c] = target_color
    
    return {'input': grid_input, 'output': grid_output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    bg = 0
    
    # Step 1: Remove noise (keep components >=4 pixels)
    visited = [[False] * width for _ in range(height)]
    components = []
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and grid[r][c] != bg:
                comp = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    comp.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] != bg:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append(comp)
    
    main_components = [comp for comp in components if len(comp) >= 4]
    noise_removed = [[bg] * width for _ in range(height)]
    for comp in main_components:
        color = grid[comp[0][0]][comp[0][1]]
        for r, c in comp:
            noise_removed[r][c] = color

    # Step 2: Snap objects
    snapped = [[bg] * width for _ in range(height)]
    for comp in main_components:
        min_r = min(r for r, c in comp)
        max_r = max(r for r, c in comp)
        min_c = min(c for r, c in comp)
        max_c = max(c for r, c in comp)
        color = grid[comp[0][0]][comp[0][1]]
        for r in range(min_r, max_r + 1):
            for c in range(min_c, max_c + 1):
                snapped[r][c] = color

    # Step 3: Detect arrows
    arrow_color = None
    for r in range(height):
        for c in range(width):
            if grid[r][c] != bg:
                # Check horizontal
                if c + 1 < width and grid[r][c] == grid[r][c+1]:
                    arrow_color = grid[r][c]
                    break
                # Check vertical
                if r + 1 < height and grid[r][c] == grid[r+1][c]:
                    arrow_color = grid[r][c]
                    break
        if arrow_color is not None:
            break

    if arrow_color is None:
        return snapped

    # Find all arrow positions
    arrows = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] == arrow_color:
                if c + 1 < width and grid[r][c] == grid[r][c+1]:
                    arrows.append((r, c, 'right'))
                elif r + 1 < height and grid[r][c] == grid[r+1][c]:
                    arrows.append((r, c, 'down'))

    # Sort arrows along path
    arrows.sort(key=lambda x: (x[0], x[1]))
    directions = [d for _, _, d in arrows]

    # Compute path
    path = [(0, 0)]
    r, c = 0, 0
    for d in directions:
        if d == 'right':
            c += 1
        elif d == 'down':
            r += 1
        path.append((r, c))

    # Find target object color
    target_color = None
    for comp in main_components:
        min_r = min(r for r, c in comp)
        max_r = max(r for r, c in comp)
        min_c = min(c for r, c in comp)
        max_c = max(c for r, c in comp)
        if min_r <= path[-1][0] <= max_r and min_c <= path[-1][1] <= max_c:
            target_color = grid[comp[0][0]][comp[0][1]]
            break
    if target_color is None:
        target_color = grid[path[-1][0]][path[-1][1]] if 0 <= path[-1][0] < height and 0 <= path[-1][1] < width else 1

    # Draw path with bounds checking
    for r, c in path:
        if 0 <= r < height and 0 <= c < width and snapped[r][c] == bg:
            snapped[r][c] = target_color

    return snapped
