# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 963ebbbb
Difficulty: hard

=== Tags ===
- Take negative

=== Description ===
The input grids feature multiple distinct, connected shapes (each shape is a
contiguous region of uniform color, using numbers 1-9), with background color 0.
The output grid is generated by identifying the boundary (perimeter) of each
shape—defined as pixels within a shape that are adjacent to at least one
background cell (0)—and replacing these boundary pixels with color 5, while all
other cells remain 0. This transformation requires the solver to detect
connected components, determine their perimeters, and apply a consistent color
replacement rule, making it challenging to deduce from minimal examples due to
the need for multi-step spatial reasoning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = [[0] * width for _ in range(height)]
    num_shapes = random.randint(2, 4)
    used_colors = []
    max_retries = 10
    for _ in range(num_shapes):
        retries = 0
        while retries < max_retries:
            shape_name = random.choice(["el", "you", "aitch"])
            pixels = common.rand_sprite(shape_name, width, height)
            all_free = True
            for r, c in pixels:
                if r < 0 or r >= height or c < 0 or c >= width:
                    all_free = False
                    break
                if input_grid[r][c] != 0:
                    all_free = False
                    break
            if all_free:
                break
            retries += 1
        if retries == max_retries:
            pixels = [(0, 0), (0, 1), (1, 0)]
        color = common.random_color(exclude=used_colors)
        used_colors.append(color)
        for r, c in pixels:
            if 0 <= r < height and 0 <= c < width:
                input_grid[r][c] = color
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 0:
                        output_grid[r][c] = 5
                        break
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 0:
                        output[r][c] = 5
                        break
    return output
