# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 796eca49
Difficulty: insane

=== Tags ===
- Relational projection
- Cylindrical
- Carve negative space

=== Description ===
Input grids feature a background color (0) with multiple connected foreground
regions, each uniquely colored (1-9) and positioned to form a relational
structure. The regions must contain at least three distinct colors, with one
designated "anchor" region (typically the largest or most centrally located).
The output grid is generated through three sequential steps: (1) For each
foreground region, compute the centroid vector pointing toward the anchor
region's centroid; (2) Project every cell of the region along this vector,
wrapping around the grid edges (cylindrical boundary conditions); (3) Carve
negative space by removing all projected cells that overlap with original
foreground regions (setting them to background 0), while retaining non-
overlapping projections. The final output displays the original background,
unmodified foreground regions, and projected regions only in positions where
they do not intersect with the input's foreground structure. This requires
precise relational geometry (centroid calculations), cylindrical coordinate
wrapping, and spatial carving logic, with no two projections overlapping the
same cell in the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    # Try multiple times to produce a valid instance that meets constraints
    for global_try in range(500):
        width = random.randint(6, 20)
        height = random.randint(6, 20)

        # Number of distinct colored regions (at least 3)
        num_regions = random.randint(3, 5)
        colors = random.sample(list(range(1, 10)), num_regions)

        # Prepare to place connected sprites without overlap
        regions = []  # list of (color, set_of_pixels)
        occupied = set()
        placement_failed = False

        for color in colors:
            placed = False
            for attempt in range(200):
                # sprite bounding box (small to keep things varied)
                box_w = random.randint(2, min(6, width))
                box_h = random.randint(2, min(6, height))
                size = random.randint(3, min(box_w * box_h, 12))

                sprite = common.continuous_creature(size, box_w, box_h)
                # sprite is a list of (r,c) within box_h x box_w

                # choose offset so sprite fits inside the full grid
                if height - box_h < 0 or width - box_w < 0:
                    continue
                r0 = random.randint(0, height - box_h)
                c0 = random.randint(0, width - box_w)

                placed_pixels = set((r0 + r, c0 + c) for (r, c) in sprite)

                # ensure no overlap with previously placed regions
                if placed_pixels & occupied:
                    continue

                # accept placement
                regions.append((color, placed_pixels))
                occupied |= placed_pixels
                placed = True
                break

            if not placed:
                placement_failed = True
                break

        if placement_failed:
            continue

        # Choose anchor deterministically: largest area, tie-break by closeness to grid center, then by color
        center_r = (height - 1) / 2.0
        center_c = (width - 1) / 2.0
        def anchor_key(item):
            color, pixels = item
            area = len(pixels)
            pixels_list = list(pixels)
            cr = sum(r for r, c in pixels_list) / area
            cc = sum(c for r, c in pixels_list) / area
            dist2 = (cr - center_r) ** 2 + (cc - center_c) ** 2
            return (-area, dist2, color)

        anchor_color, anchor_pixels = sorted(regions, key=anchor_key)[0]
        anchor_pixels = list(anchor_pixels)
        a_r = sum(r for r, c in anchor_pixels) / len(anchor_pixels)
        a_c = sum(c for r, c in anchor_pixels) / len(anchor_pixels)

        original_foreground = set().union(*(pixels for _, pixels in regions))

        # For each region compute projected cells by translating the entire region
        # by the rounded centroid vector (anchor_centroid - region_centroid) with wrap.
        proj_map = {}  # color -> set of projected positions (after carving)
        for color, pixels in regions:
            pixels_list = list(pixels)
            cr = sum(r for r, c in pixels_list) / len(pixels_list)
            cc = sum(c for r, c in pixels_list) / len(pixels_list)
            v_r = a_r - cr
            v_c = a_c - cc
            shift_r = int(round(v_r))
            shift_c = int(round(v_c))

            projected = set()
            for (r, c) in pixels_list:
                new_r = (r + shift_r) % height
                new_c = (c + shift_c) % width
                projected.add((new_r, new_c))

            # Carve negative space: remove any projected cell that overlaps original foreground
            projected -= original_foreground

            proj_map[color] = projected

        # Ensure no two projections overlap the same cell
        used = {}
        conflict = False
        for color, pset in proj_map.items():
            for pos in pset:
                if pos in used:
                    conflict = True
                    break
                used[pos] = color
            if conflict:
                break
        if conflict:
            continue

        # Must have at least one projected cell retained (so output != input)
        if not used:
            continue

        # Build input and output grids
        input_grid = [[0 for _ in range(width)] for _ in range(height)]
        for color, pixels in regions:
            for (r, c) in pixels:
                input_grid[r][c] = color

        output_grid = [row[:] for row in input_grid]
        for pos, color in used.items():
            r, c = pos
            if input_grid[r][c] == 0:
                output_grid[r][c] = color

        # ensure they differ
        if input_grid == output_grid:
            continue

        return {"input": input_grid, "output": output_grid}

    raise RuntimeError("Failed to generate a valid task instance")



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Collect pixels by color (foreground regions are uniquely colored)
    regions = {}
    for r in range(height):
        for c in range(width):
            col = grid[r][c]
            if col == 0:
                continue
            regions.setdefault(col, []).append((r, c))

    if not regions:
        return grid

    # Choose anchor deterministically in the same way as the generator:
    # largest area, tie-break by closeness to grid center, then by color id
    center_r = (height - 1) / 2.0
    center_c = (width - 1) / 2.0
    def anchor_key_from_dict(color):
        pixels = regions[color]
        area = len(pixels)
        cr = sum(r for r, c in pixels) / area
        cc = sum(c for r, c in pixels) / area
        dist2 = (cr - center_r) ** 2 + (cc - center_c) ** 2
        return (-area, dist2, color)

    anchor_color = sorted(list(regions.keys()), key=anchor_key_from_dict)[0]
    anchor_pixels = regions[anchor_color]
    a_r = sum(r for r, c in anchor_pixels) / len(anchor_pixels)
    a_c = sum(c for r, c in anchor_pixels) / len(anchor_pixels)

    original_foreground = set()
    for pixels in regions.values():
        original_foreground.update(pixels)

    # For each region compute the integer rounded centroid vector and project
    proj_map = {}  # color -> set of projected positions
    for color, pixels in regions.items():
        pixels_list = pixels
        cr = sum(r for r, c in pixels_list) / len(pixels_list)
        cc = sum(c for r, c in pixels_list) / len(pixels_list)
        v_r = a_r - cr
        v_c = a_c - cc
        shift_r = int(round(v_r))
        shift_c = int(round(v_c))

        projected = set()
        for (r, c) in pixels_list:
            new_r = (r + shift_r) % height
            new_c = (c + shift_c) % width
            projected.add((new_r, new_c))

        # Carve negative space by removing projections that overlap original foreground
        projected -= original_foreground
        proj_map[color] = projected

    # If different regions project to the same cell, remove those conflicting projections
    # to guarantee no two projections overlap the same cell in the output.
    cell_counts = {}
    for color, pset in proj_map.items():
        for pos in pset:
            cell_counts[pos] = cell_counts.get(pos, 0) + 1

    for color in list(proj_map.keys()):
        proj_map[color] = {pos for pos in proj_map[color] if cell_counts.get(pos, 0) == 1}

    # Build output grid: start from input and add non-overlapping projections
    output = [row[:] for row in grid]
    for color, pset in proj_map.items():
        for (r, c) in pset:
            if output[r][c] == 0:
                output[r][c] = color

    return output

