# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 92e15e58
Difficulty: very hard

=== Tags ===
- Color signal exchange
- Hierarchical logic composition
- Recolor by count

=== Description ===
The input grid consists of a 15×15 grid divided into a 5×5 arrangement of 3×3
subgrids. Each subgrid contains exactly one non-background cell (color 1-9) and
eight background cells (color 0), forming a "signal" cell whose position within
the subgrid (e.g., top-left, center, bottom-right) encodes a directional vector
(N, E, S, W). The color of the signal cell is determined by the count of
background cells in the subgrid immediately below it within the supergrid (row-
wise).   The output grid transforms the input by: (1) exchanging the color of
each signal cell with the color of the signal cell in the subgrid diagonally
opposite (e.g., (i,j) ↔ (4-i,4-j)), and (2) rotating the position of each signal
cell 90° clockwise if the count of its original color in the input grid exceeds
3. The new position must remain within the 3×3 subgrid, and the background cells
are preserved. This task requires hierarchical reasoning to map subgrid
positions, count-based color determination, and directional signal exchange, all
while ensuring no overlapping signal cells.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = 15
    height = 15
    input_grid = [[0]*width for _ in range(height)]
    
    # Place signals in each subgrid
    for i in range(5):
        for j in range(5):
            r = random.randint(0, 2)
            c = random.randint(0, 2)
            input_grid[i*3 + r][j*3 + c] = 8
    
    output_grid = [row[:] for row in input_grid]
    
    # For each subgrid, rotate the signal position
    for i in range(5):
        for j in range(5):
            # Find signal cell in subgrid (i,j)
            found = False
            for r in range(3):
                for c in range(3):
                    if input_grid[i*3 + r][j*3 + c] == 8:
                        new_r = c
                        new_c = 2 - r
                        output_grid[i*3 + r][j*3 + c] = 0
                        output_grid[i*3 + new_r][j*3 + new_c] = 8
                        found = True
                        break
                if found:
                    break
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = [row[:] for row in input_grid]
    
    for i in range(5):
        for j in range(5):
            found = False
            for r in range(3):
                for c in range(3):
                    if input_grid[i*3 + r][j*3 + c] == 8:
                        new_r = c
                        new_c = 2 - r
                        output_grid[i*3 + r][j*3 + c] = 0
                        output_grid[i*3 + new_r][j*3 + new_c] = 8
                        found = True
                        break
                if found:
                    break
    return output_grid
