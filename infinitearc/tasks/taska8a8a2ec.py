# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: a8a8a2ec
Difficulty: very hard

=== Tags ===
- Procedural painting
- Threshold by area
- Detect repetition

=== Description ===
Input grids feature a single background color (typically 0) with multiple
contiguous regions of distinct colors (1-9), each region forming a unique shape.
Some regions exhibit identical spatial patterns relative to their positions,
forming repeated pairs or groups (same color and shape). In the output grid, all
regions that are part of such a repeated pattern and contain more than 4 cells
are repainted with color 9, while all other regions and the background remain
unchanged. The solution requires detecting exact shape repetitions across the
grid and applying the area threshold to determine which regions are transformed.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from typing import Dict, List, Tuple
import collections
import common


def make_contiguous_shape(size: int) -> List[Tuple[int, int]]:
    """
    Generate a contiguous shape of exactly `size` cells. The shape is returned as a
    sorted list of (r, c) coordinates normalized so the minimum row and column are 0.
    """
    if size <= 0:
        return []
    pixels = {(0, 0)}
    # Grow the shape by randomly adding neighbors of already-present pixels.
    attempts = 0
    while len(pixels) < size and attempts < size * 200:
        attempts += 1
        base = random.choice(tuple(pixels))
        dr, dc = random.choice([(1, 0), (-1, 0), (0, 1), (0, -1)])
        new = (base[0] + dr, base[1] + dc)
        if new in pixels:
            continue
        pixels.add(new)
    # Normalize to top-left = (0,0)
    min_r = min(r for r, c in pixels)
    min_c = min(c for r, c in pixels)
    normalized = sorted(((r - min_r, c - min_c) for r, c in pixels))
    return normalized


def shape_dimensions(shape: List[Tuple[int, int]]) -> Tuple[int, int]:
    if not shape:
        return 0, 0
    max_r = max(r for r, c in shape)
    max_c = max(c for r, c in shape)
    return max_r + 1, max_c + 1


def can_place(grid: List[List[int]], shape: List[Tuple[int, int]], r0: int, c0: int, color: int) -> bool:
    h = len(grid)
    w = len(grid[0])
    for r, c in shape:
        rr, cc = r0 + r, c0 + c
        # bounds
        if rr < 0 or rr >= h or cc < 0 or cc >= w:
            return False
        # cannot overlap existing cell
        if grid[rr][cc] != 0:
            return False
        # do not allow orthogonal adjacency to the same color (would merge regions)
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = rr + dr, cc + dc
            if 0 <= nr < h and 0 <= nc < w and grid[nr][nc] == color:
                return False
    return True


def place_shape(grid: List[List[int]], shape: List[Tuple[int, int]], r0: int, c0: int, color: int) -> None:
    for r, c in shape:
        grid[r0 + r][c0 + c] = color


def place_group(grid: List[List[int]], shape: List[Tuple[int, int]], color: int, repeats: int, max_attempts: int = 300) -> bool:
    """Try to place `repeats` copies of `shape` (same color) into the grid.
    If placement of any copy fails the function rolls back all partial placements
    and returns False. Otherwise returns True after placing all copies.
    """
    h = len(grid)
    w = len(grid[0])
    sh, sw = shape_dimensions(shape)
    placed = []
    for _ in range(repeats):
        success = False
        for _attempt in range(max_attempts):
            if h - sh < 0 or w - sw < 0:
                break
            r0 = random.randint(0, h - sh)
            c0 = random.randint(0, w - sw)
            if can_place(grid, shape, r0, c0, color):
                place_shape(grid, shape, r0, c0, color)
                placed.append((r0, c0))
                success = True
                break
        if not success:
            # rollback
            for pr, pc in placed:
                for r, c in shape:
                    grid[pr + r][pc + c] = 0
            return False
    return True


def generate() -> Dict[str, List[List[int]]]:
    # grid size
    w = random.randint(10, 20)
    h = random.randint(10, 20)
    grid: List[List[int]] = [[0] * w for _ in range(h)]

    # Avoid using 9 in the input (9 is the repaint color in the task)
    palette = list(range(1, 9))

    # Guarantee at least one repeated group with area > 4 so the output differs from the input.
    ensured = False
    for _try in range(60):
        size_big = random.randint(5, 10)  # area > 4
        shape_big = make_contiguous_shape(size_big)
        repeats = random.choice([2, 2, 3])
        color_big = random.choice(palette)
        if place_group(grid, shape_big, color_big, repeats):
            ensured = True
            break
    if not ensured:
        # last resort: place two adjacent single pixels of same color (forced)
        # but that would not meet area>4 so try again with smaller shape
        size_big = 5
        shape_big = make_contiguous_shape(size_big)
        color_big = random.choice(palette)
        place_group(grid, shape_big, color_big, 2)

    # Add a few additional repeated groups (optional) and some unique regions
    extra_repeats = random.randint(0, 3)
    for _ in range(extra_repeats):
        size = random.randint(3, 9)
        shape = make_contiguous_shape(size)
        repeats = random.choice([2, 3])
        color = random.choice(palette)
        # We don't insist success here; if it fails it's fine.
        place_group(grid, shape, color, repeats)

    # Add several singleton (unique) regions of varying sizes
    singleton_count = random.randint(4, 10)
    for _ in range(singleton_count):
        size = random.randint(1, 6)
        shape = make_contiguous_shape(size)
        color = random.choice(palette)
        # place a single copy
        place_group(grid, shape, color, 1)

    # Build the output by detecting repeated exact shapes (same color + same relative shape)
    output = [row[:] for row in grid]
    H = len(grid)
    W = len(grid[0])
    visited = [[False] * W for _ in range(H)]
    regions = []  # list of tuples (color, rel_shape_tuple, absolute_cells_list)

    for r in range(H):
        for c in range(W):
            if grid[r][c] != 0 and not visited[r][c]:
                color_val = grid[r][c]
                stack = [(r, c)]
                visited[r][c] = True
                cells = []
                while stack:
                    rr, cc = stack.pop()
                    cells.append((rr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = rr + dr, cc + dc
                        if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc] and grid[nr][nc] == color_val:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                min_r = min(a for a, b in cells)
                min_c = min(b for a, b in cells)
                rel = tuple(sorted(((a - min_r, b - min_c) for a, b in cells)))
                regions.append((color_val, rel, cells))

    grouped = collections.defaultdict(list)
    for color_val, rel, cells in regions:
        grouped[(color_val, rel)].append(cells)

    # Repaint every region that belongs to a repeated group (group size >= 2) and whose area > 4
    for (color_val, rel), group_cells in list(grouped.items()):
        if len(group_cells) >= 2:
            area = len(group_cells[0])
            if area > 4:
                for cells in group_cells:
                    for rr, cc in cells:
                        output[rr][cc] = 9

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from typing import List, Tuple

def p(input_grid: Tuple[Tuple[int, ...], ...]) -> List[List[int]]:
    # Convert to mutable grid
    grid: List[List[int]] = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0]) if h > 0 else 0

    visited = [[False] * w for _ in range(h)]
    regions = []  # (color, rel_shape_tuple, absolute_cells)

    for i in range(h):
        for j in range(w):
            if grid[i][j] != 0 and not visited[i][j]:
                color_val = grid[i][j]
                stack = [(i, j)]
                visited[i][j] = True
                cells = []
                while stack:
                    r, c = stack.pop()
                    cells.append((r, c))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] == color_val:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                min_r = min(r for r, c in cells)
                min_c = min(c for r, c in cells)
                rel = tuple(sorted(((r - min_r, c - min_c) for r, c in cells)))
                regions.append((color_val, rel, cells))

    # Group by (color, relative-shape)
    groups = {}
    for color_val, rel, cells in regions:
        key = (color_val, rel)
        groups.setdefault(key, []).append(cells)

    # Repaint regions that are part of a repeated group (group length >= 2) and whose area > 4
    for key, group_cells in groups.items():
        if len(group_cells) >= 2:
            area = len(group_cells[0])
            if area > 4:
                for cells in group_cells:
                    for r, c in cells:
                        grid[r][c] = 9

    return grid

