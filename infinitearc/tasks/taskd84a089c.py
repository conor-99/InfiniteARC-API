# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: d84a089c
Difficulty: very hard

=== Tags ===
- Gravity with barriers
- Concentric

=== Description ===
The input grid features a uniform background color (0), with barrier elements
(color 1) distributed irregularly and movable elements (color 2) positioned in
vertical columns. Barrier elements block downward movement of movable elements,
while movable elements remain stationary until gravity is applied.  The
transformation to the output grid involves two sequential steps:   1. **Gravity
Application**: Each movable element (color 2) moves downward in its column until
it either hits a barrier (color 1) below it or reaches the grid’s bottom edge.
All movements occur simultaneously without overlapping.   2. **Concentric
Pattern Generation**: After gravity is applied, the grid is overlaid with
concentric circular rings centered at the grid’s geometric center. Each ring has
a width of 1 cell, uses color 3, and is spaced such that the number of rings
equals the number of distinct rows occupied by movable elements after gravity.
The rings are drawn exclusively on background cells (color 0), avoiding barriers
(color 1) and movable elements (color 2). The innermost ring corresponds to the
highest concentration of movable elements in the gravity-applied grid, with each
subsequent ring expanding outward.    The output grid preserves all barriers and
gravity-applied movable elements while adding the concentric ring pattern on the
background. The task requires recognizing both the gravity-based movement
dynamics and the geometric construction of concentric patterns based on the
spatial distribution of elements.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random
from typing import List, Dict, Tuple

def apply_gravity_column(col: List[int]) -> List[int]:
    non_2 = [cell for cell in col if cell != 2]
    two_count = col.count(2)
    return non_2 + [2] * two_count

def generate() -> Dict[str, List[List[int]]]:
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    grid = common.grid(width, height, 0)
    # Place barriers (1s)
    num_barriers = random.randint(1, width * height // 3)
    barrier_positions = random.sample(common.all_pixels(width, height), num_barriers)
    for r, c in barrier_positions:
        grid[r][c] = 1
    # Place movable elements (2s)
    available = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == 0]
    num_movables = random.randint(1, len(available) // 2)
    if num_movables > len(available):
        num_movables = len(available)
    movable_positions = random.sample(available, num_movables)
    for r, c in movable_positions:
        grid[r][c] = 2
    # Apply gravity
    gravity_grid = [apply_gravity_column(col) for col in zip(*grid)]
    gravity_grid = list(zip(*gravity_grid))
    # Count distinct rows with 2s
    rows_with_2 = set()
    for r in range(height):
        for c in range(width):
            if gravity_grid[r][c] == 2:
                rows_with_2.add(r)
    num_rings = len(rows_with_2)
    # Create output grid
    output = [[cell for cell in row] for row in gravity_grid]
    # Add concentric rings
    cx = (width - 1) / 2.0
    cy = (height - 1) / 2.0
    for r in range(height):
        for c in range(width):
            if output[r][c] == 0:
                dist = ((r - cx) ** 2 + (c - cy) ** 2) ** 0.5
                ring_idx = int(dist)
                if ring_idx < num_rings and ring_idx <= dist < ring_idx + 1:
                    output[r][c] = 3
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
from typing import Tuple
from typing import List, Dict

def apply_gravity_column(col: List[int]) -> List[int]:
    non_2 = [cell for cell in col if cell != 2]
    two_count = col.count(2)
    return non_2 + [2] * two_count

def p(input_grid: Tuple[Tuple[int, ...], ...]) -> Tuple[Tuple[int, ...], ...]:
    # Convert input to list of lists
    grid = [list(row) for row in input_grid]
    if not grid or not grid[0]:
        return input_grid
    height = len(grid)
    width = len(grid[0])
    # Apply gravity column by column
    gravity_grid = [apply_gravity_column(col) for col in zip(*grid)]
    gravity_grid = list(zip(*gravity_grid))
    # Count distinct rows with 2s
    rows_with_2 = set()
    for r in range(height):
        for c in range(width):
            if gravity_grid[r][c] == 2:
                rows_with_2.add(r)
    num_rings = len(rows_with_2)
    # Convert to list of lists for mutation
    output = [list(row) for row in gravity_grid]
    # Add concentric rings
    cx = (width - 1) / 2.0
    cy = (height - 1) / 2.0
    for r in range(height):
        for c in range(width):
            if output[r][c] == 0:
                dist = ((r - cx) ** 2 + (c - cy) ** 2) ** 0.5
                ring_idx = int(dist)
                if ring_idx < num_rings and ring_idx <= dist < ring_idx + 1:
                    output[r][c] = 3
    return tuple(tuple(row) for row in output)
