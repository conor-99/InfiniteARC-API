# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: ec587691
Difficulty: insane

=== Tags ===
- Paint on collision
- Folded grid reasoning
- Wavefront timing
- Detect symmetry
- Divide by n

=== Description ===
Symmetric Wavefront Collisions on Folded Grids  Input grids feature a central
fold line (marked by a continuous red line) dividing the grid into two mirrored
halves. On either side of the fold, colored wavefronts (diagonal lines of colors
2-9) move toward the fold at 45-degree angles, advancing one cell diagonally per
time step (wavefront timing). When wavefronts collide (either directly or via
mirroring across the fold), they trigger a "paint" operation where the collision
cell is colored with the sum of the two wavefront colors modulo 10 (paint on
collision). The grid's folding creates symmetric collision patterns, requiring
the output to maintain perfect symmetry across the fold line (detect symmetry).
The grid is visually divided into n equal sections along the fold line (divide
by n), where n is determined by the number of distinct wavefront colors present
in the input. Each section's wavefronts move independently until collisions
occur, with the final output grid showing all collision points painted, full
symmetry across the fold, and the grid's division into n symmetric sections. The
complexity arises from simultaneously tracking mirrored wavefronts, collision
painting, symmetry enforcement, and visual section division without relying on
numerical calculations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(3, 30)
    mid = width // 2
    grid = [[0] * width for _ in range(height)]
    for r in range(height):
        grid[r][mid] = 2
    n = random.randint(2, 5)
    colors = random.sample(range(3, 10), n)
    for color in colors:
        r_start = random.randint(0, height - 3)
        if mid - 2 >= 0:
            grid[r_start][mid-2] = color
            grid[r_start+1][mid-1] = color
        if mid + 2 < width:
            grid[r_start][mid+2] = color
            grid[r_start+1][mid+1] = color
    output = [row[:] for row in grid]
    for color in colors:
        for r in range(height - 2):
            if grid[r][mid-2] == color and grid[r+1][mid-1] == color:
                if grid[r][mid+2] == color and grid[r+1][mid+1] == color:
                    output[r][mid-2] = 0
                    output[r+1][mid-1] = 0
                    output[r][mid+2] = 0
                    output[r+1][mid+1] = 0
                    if r+2 < height:
                        output[r+2][mid] = (2 * color) % 10
                    break
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input):
    if isinstance(input, tuple):
        input = [list(row) for row in input]
    height = len(input)
    width = len(input[0])
    mid = width // 2
    while mid < width and not all(input[r][mid] == 2 for r in range(height)):
        mid += 1
    output = [row[:] for row in input]
    colors = set()
    for r in range(height):
        for c in range(width):
            if input[r][c] not in [0, 2]:
                colors.add(input[r][c])
    for color in colors:
        for r in range(height - 2):
            if input[r][mid-2] == color and input[r+1][mid-1] == color:
                if input[r][mid+2] == color and input[r+1][mid+1] == color:
                    output[r][mid-2] = 0
                    output[r+1][mid-1] = 0
                    output[r][mid+2] = 0
                    output[r+1][mid+1] = 0
                    if r+2 < height:
                        output[r+2][mid] = (2 * color) % 10
                    break
    return output
