# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: d99f7bc1
Difficulty: medium

=== Tags ===
- Only one
- Count touches
- Take complement
- Take minimum

=== Description ===
The input grid contains a single contiguous region (a connected shape formed by
cells of the same color, with no other regions present). For each cell within
this region, count how many of its four orthogonal neighbors (up, down, left,
right) share the same color (count touches). Identify the smallest count value
found across all cells in the region. In the output grid, every cell in the
region that has a touch count matching this minimum value is replaced with its
complement color (e.g., color 0 becomes 9, 1 becomes 8, 2 becomes 7, etc.),
while all other cells retain their original color. The shape and structure of
the region remain unchanged, only the colors of cells meeting the minimum touch
count condition are transformed.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    width = common.randint(5, 30)
    height = common.randint(5, 30)
    color = common.randint(1, 9)
    region_size = common.randint(3, 20)
    pixels = common.continuous_creature(region_size, width, height)
    input_grid = common.grid(width, height, 0)
    for (r, c) in pixels:
        input_grid[r][c] = color
    touch_counts = {}
    for (r, c) in pixels:
        count = 0
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == color:
                count += 1
        touch_counts[(r, c)] = count
    min_touch = min(touch_counts.values())
    output_grid = [row[:] for row in input_grid]
    for (r, c) in pixels:
        if touch_counts[(r, c)] == min_touch:
            output_grid[r][c] = 9 - color
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    color = 0
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                color = input_grid[r][c]
                break
        if color != 0:
            break
    if color == 0:
        return input_grid
    region = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == color:
                region.append((r, c))
    touch_counts = {}
    for (r, c) in region:
        count = 0
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == color:
                count += 1
        touch_counts[(r, c)] = count
    min_touch = min(touch_counts.values())
    output_grid = [row[:] for row in input_grid]
    for (r, c) in region:
        if touch_counts[(r, c)] == min_touch:
            output_grid[r][c] = 9 - color
    return output_grid
