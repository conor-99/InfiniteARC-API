# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: f6975595
Difficulty: insane

=== Tags ===
- Substitution rule discovery
- Cyclic coloring
- Connect the dots

=== Description ===
Cyclic Path Mapping  Input grids are 15×15 with a background color of 0.
Scattered across the grid are colored dots (values 1–9) at distinct positions,
each dot having a unique color in the input. The grid also contains a hidden
substitution rule that maps each color to another color in a cyclic sequence
(e.g., 1→2→3→1), though the cycle length and direction (increasing/decreasing)
are unknown. The substitution rule is consistent across all input-output pairs.
The output grid must connect all dots with straight horizontal or vertical lines
(no diagonals), forming a single continuous path that visits every dot exactly
once. The connection order follows the substitution sequence: dots are traversed
in the order of their substituted colors, cycling through the sequence (e.g.,
substituted color 1 → 2 → 3 → 1 → 2...). Line segments between consecutive dots
are drawn using the substituted color of the starting dot (e.g., a connection
from a dot with input color 1, substituted to 2, uses line color 2). Lines must
occupy only background cells (0), avoiding existing dots and other lines.  The
challenge lies in discovering the substitution cycle's length and direction from
minimal input-output examples. The solution requires analyzing line colors in
the output to infer the mapping (e.g., output line color 2 following input color
1 suggests substitution 1→2), then applying the cycle to determine the
connection order. The task demands recognizing non-obvious cyclic patterns and
applying multi-step reasoning to reconstruct the path, with no visual cues
indicating the cycle's properties.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    """
    Generate a 15x15 grid with k uniquely colored dots placed in a single column (distinct rows,
    spaced so that every consecutive pair has at least one background cell between them).
    The colors are arranged top-to-bottom according to a random cyclic permutation `cycle`.
    The substitution map sends each color to the next color in `cycle` (wraparound).

    The output grid connects each consecutive pair of dots (top-to-bottom) with a vertical
    segment drawn in the substituted color of the starting dot (i.e., M[color_i] = color_{i+1}).
    Segments are drawn only through background cells.
    """
    size = 15
    # number of dots (choose between 3 and 6 for complexity)
    k = random.randint(3, 6)
    # pick k distinct colors from 1..9
    colors = random.sample(list(range(1, 10)), k)
    # random cyclic order for the substitution map
    cycle = colors[:]
    random.shuffle(cycle)
    # build substitution map: cycle[i] -> cycle[(i+1) % k]
    sub_map = {cycle[i]: cycle[(i+1) % k] for i in range(k)}

    # choose a column to place all dots
    col = random.randint(0, size - 1)

    # choose k distinct row indices with minimum gap >= 2 to ensure there's space to draw lines
    # use rejection sampling (small k so this is cheap)
    tries = 0
    while True:
        tries += 1
        rows = sorted(random.sample(range(size), k))
        if all(rows[i+1] - rows[i] >= 2 for i in range(k-1)):
            break
        if tries > 200:
            # fallback: spread them evenly if random sampling fails (very unlikely)
            rows = list(range(1, size, max(1, size // (k + 1))))[:k]
            rows = sorted(rows)
            # enforce min gap >= 2 by nudging later rows
            for i in range(1, k):
                if rows[i] - rows[i-1] < 2:
                    rows[i] = min(size-1, rows[i-1] + 2)
            break

    # place colors in top-to-bottom order according to `cycle`
    input_grid = grid(size, size, 0)
    positions = []
    for i, r in enumerate(rows):
        input_grid[r][col] = cycle[i]
        positions.append((r, col))

    # create output by drawing vertical segments between consecutive positions
    output_grid = [row[:] for row in input_grid]
    for i in range(k - 1):
        r1, c1 = positions[i]
        r2, c2 = positions[i + 1]
        line_color = sub_map[cycle[i]]
        start = min(r1, r2) + 1
        end = max(r1, r2)
        for r in range(start, end):
            output_grid[r][c1] = line_color

    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # convert to mutable list of lists
    grid_in = [list(row) for row in input_grid]
    h = len(grid_in)
    w = len(grid_in[0]) if h > 0 else 0

    # collect dot positions (non-zero cells)
    dots = []
    for r in range(h):
        for c in range(w):
            val = grid_in[r][c]
            if val != 0:
                dots.append((r, c, val))

    if not dots:
        return [row[:] for row in grid_in]

    # We assume generator places dots in a single column and orders them top-to-bottom
    # according to the hidden cycle. Reconstruct the cycle by sorting top-to-bottom.
    dots_sorted = sorted(dots, key=lambda t: (t[0], t[1]))
    colors_in_order = [t[2] for t in dots_sorted]
    k = len(colors_in_order)

    # build substitution map: color_i -> color_{i+1}
    sub_map = {colors_in_order[i]: colors_in_order[(i + 1) % k] for i in range(k)}

    # construct output by drawing straight segments between consecutive sorted dots
    output = [row[:] for row in grid_in]
    for i in range(k - 1):
        r1, c1, col1 = dots_sorted[i]
        r2, c2, col2 = dots_sorted[i + 1]
        line_color = sub_map[col1]
        if r1 == r2:
            # horizontal segment
            start_c = min(c1, c2) + 1
            end_c = max(c1, c2)
            for cc in range(start_c, end_c):
                output[r1][cc] = line_color
        elif c1 == c2:
            # vertical segment
            start_r = min(r1, r2) + 1
            end_r = max(r1, r2)
            for rr in range(start_r, end_r):
                output[rr][c1] = line_color
        else:
            # fallback (should not occur with this generator): attempt an L-shaped path
            # prefer corner (r1, c2) if free, otherwise (r2, c1)
            if output[r1][c2] == 0 and grid_in[r1][c2] == 0:
                # horizontal then vertical
                start_c = min(c1, c2) + 1
                end_c = max(c1, c2)
                for cc in range(start_c, end_c):
                    output[r1][cc] = line_color
                start_r = min(r1, r2) + 1
                end_r = max(r1, r2)
                for rr in range(start_r, end_r):
                    output[rr][c2] = line_color
            elif output[r2][c1] == 0 and grid_in[r2][c1] == 0:
                start_r = min(r1, r2) + 1
                end_r = max(r1, r2)
                for rr in range(start_r, end_r):
                    output[rr][c1] = line_color
                start_c = min(c1, c2) + 1
                end_c = max(c1, c2)
                for cc in range(start_c, end_c):
                    output[r2][cc] = line_color
            else:
                # If neither corner is free, skip drawing for safety.
                pass

    return output
