# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 5e96b5ac
Difficulty: insane

=== Tags ===
- Cylindrical
- Diagonals

=== Description ===
The task involves transforming a grid by treating it as cylindrical in the
horizontal direction (left and right edges are connected). For each diagonal
defined by the equation (row - column) mod width = constant, the elements along
that diagonal are rotated left by one position. The output grid is formed by
placing the rotated elements back into their original diagonal positions. This
requires recognizing the cylindrical nature of the grid, identifying diagonals
that wrap around the width, and applying a consistent rotation to each
diagonal's elements. The transformation is deterministic and abstract, relying
on relational reasoning about grid topology and diagonal patterns rather than
simple pixel matching or memorization.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
def generate():
    while True:
        width = random.randint(2, 30)
        height = random.randint(2, 30)
        input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
        output_grid = [[0] * width for _ in range(height)]
        diagonals = {}
        for r in range(height):
            for c in range(width):
                d = (r - c) % width
                if d not in diagonals:
                    diagonals[d] = []
                diagonals[d].append((r, c))
        for d, positions in diagonals.items():
            values = [input_grid[r][c] for r, c in positions]
            if len(values) > 1:
                values = values[1:] + [values[0]]
            for idx, (r, c) in enumerate(positions):
                output_grid[r][c] = values[idx]
        if input_grid != output_grid:
            return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    diagonals = {}
    for r in range(height):
        for c in range(width):
            d = (r - c) % width
            if d not in diagonals:
                diagonals[d] = []
            diagonals[d].append((r, c))
    output = [[0] * width for _ in range(height)]
    for d, positions in diagonals.items():
        values = [input_grid[r][c] for r, c in positions]
        if len(values) > 1:
            values = values[1:] + [values[0]]
        for idx, (r, c) in enumerate(positions):
            output[r][c] = values[idx]
    return output
