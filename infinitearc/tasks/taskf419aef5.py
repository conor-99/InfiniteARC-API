# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: f419aef5
Difficulty: easy

=== Tags ===
- Permute rows by length
- Recolor by count
- Nearest color fill
- Size guessing

=== Description ===
The task involves transforming an input grid into an output grid through a
sequence of consistent, deterministic operations. The input grid is a 2D array
of integers between 0 and 9, representing colors or symbols, with dimensions
ranging from 1×1 to 30×30. The output grid must maintain the same dimensions as
the input.  The transformation process follows four key steps:  1. **Permute
rows by length**: Each row is evaluated based on the count of non-zero elements
(ignoring zeros). Rows are sorted in descending order of this count, with rows
having the same count retaining their original relative order.  2. **Recolor by
count**: For every non-zero color value `c` present in the grid, replace all
occurrences of `c` with the total count of `c` in the entire grid. For example,
if color `5` appears 4 times, all `5`s are replaced with `4`.  3. **Nearest
color fill**: All cells with a value of `0` (background) are replaced by the
value of the nearest non-zero cell. Nearest is determined by Manhattan distance
(sum of horizontal and vertical differences). In cases of multiple equally close
non-zero cells, the first encountered during a top-left to bottom-right scan is
chosen.  4. **Size guessing**: The output grid retains the exact dimensions of
the input grid. The solver must recognize that the size does not change during
transformation, as the rules inherently operate on the existing grid structure
without resizing.  These operations are applied sequentially to generate the
output grid from the input grid, ensuring clarity and consistency for an easy-
level task.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    while True:
        width = random.randint(1, 30)
        height = random.randint(1, 30)
        input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
        if all(cell == 0 for row in input_grid for cell in row):
            continue
        def count_nonzero(row):
            return sum(1 for x in row if x != 0)
        sorted_indices = sorted(range(len(input_grid)), key=lambda i: (-count_nonzero(input_grid[i]), i))
        grid1 = [input_grid[i] for i in sorted_indices]
        color_count = {}
        for row in grid1:
            for cell in row:
                if cell != 0:
                    color_count[cell] = color_count.get(cell, 0) + 1
        grid2 = []
        for row in grid1:
            new_row = []
            for cell in row:
                if cell != 0:
                    new_row.append(min(color_count[cell], 9))
                else:
                    new_row.append(0)
            grid2.append(new_row)
        non_zero_positions = []
        for r in range(len(grid2)):
            for c in range(len(grid2[0])):
                if grid2[r][c] != 0:
                    non_zero_positions.append((r, c))
        grid3 = [row[:] for row in grid2]
        for r in range(len(grid3)):
            for c in range(len(grid3[0])):
                if grid3[r][c] == 0:
                    min_dist = float('inf')
                    nearest_color = 0
                    for (nr, nc) in non_zero_positions:
                        dist = abs(r - nr) + abs(c - nc)
                        if dist < min_dist:
                            min_dist = dist
                            nearest_color = grid2[nr][nc]
                    grid3[r][c] = nearest_color
        output_grid = grid3
        if input_grid != output_grid:
            return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    def count_nonzero(row):
        return sum(1 for x in row if x != 0)
    sorted_indices = sorted(range(len(input_grid)), key=lambda i: (-count_nonzero(input_grid[i]), i))
    grid1 = [input_grid[i] for i in sorted_indices]
    color_count = {}
    for row in grid1:
        for cell in row:
            if cell != 0:
                color_count[cell] = color_count.get(cell, 0) + 1
    grid2 = []
    for row in grid1:
        new_row = []
        for cell in row:
            if cell != 0:
                new_row.append(min(color_count[cell], 9))
            else:
                new_row.append(0)
        grid2.append(new_row)
    non_zero_positions = []
    for r in range(len(grid2)):
        for c in range(len(grid2[0])):
            if grid2[r][c] != 0:
                non_zero_positions.append((r, c))
    grid3 = [row[:] for row in grid2]
    for r in range(len(grid3)):
        for c in range(len(grid3[0])):
            if grid3[r][c] == 0:
                min_dist = float('inf')
                nearest_color = 0
                for (nr, nc) in non_zero_positions:
                    dist = abs(r - nr) + abs(c - nc)
                    if dist < min_dist:
                        min_dist = dist
                        nearest_color = grid2[nr][nc]
                grid3[r][c] = nearest_color
    return grid3
