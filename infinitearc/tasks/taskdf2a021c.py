# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: df2a021c
Difficulty: hard

=== Tags ===
- Cave escape
- Swap columns
- Obstacles

=== Description ===
Input grids are large cave systems (minimum 15x15) with a single background
color and obstacles represented by a distinct obstacle color. The cave features
a continuous left-to-right path that is obstructed by one or more vertical
columns of obstacles (columns where every cell matches the obstacle color), each
immediately followed by a background column. The output grid is produced by
swapping each obstructing obstacle column with the column directly to its right.
After this transformation, the escape path is visualized by drawing the path
from the left edge to the right edge using a new color, following the now
unobstructed route. All other elements, including obstacles and background,
remain unchanged except for the swapped columns and the drawn path. The
transformation requires identifying vertical obstacle columns through visual
pattern recognition, performing multiple column swaps in sequence, and then
rendering the resulting escape path, making it challenging due to the multi-step
reasoning and precise visual pattern matching required.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Size: large cave systems
    width = random.randint(15, 30)
    height = random.randint(15, 30)

    background = 0
    path_color = 5
    # choose an obstacle color different from path_color and background
    possible_obs = [c for c in range(1, 10) if c != path_color]
    obstacle = random.choice(possible_obs)

    # Start with an empty cave (all background)
    ingrid = grid(width, height, background)

    # Choose a random set of vertical obstacle columns. Each obstacle column
    # must have a right neighbor (so column index < width-1) and we avoid
    # adjacent obstacle columns to keep swaps unambiguous.
    max_possible = max(1, (width - 1) // 2)
    num_obstacles = random.randint(1, max_possible)

    obstacle_cols = []
    attempts = 0
    while len(obstacle_cols) < num_obstacles and attempts < 1000:
        attempts += 1
        c = random.randint(0, width - 2)  # must have a right neighbor
        if c in obstacle_cols:
            continue
        # avoid adjacency so that swaps do not conflict
        if any(abs(c - oc) <= 1 for oc in obstacle_cols):
            continue
        obstacle_cols.append(c)
    obstacle_cols.sort()

    # Paint the obstacle columns (full-height) into the input grid
    for col in obstacle_cols:
        for r in range(height):
            ingrid[r][col] = obstacle

    # Build the output grid by swapping each obstacle column with its right neighbor
    # using the original input as the source (i.e., swaps occur simultaneously).
    output = [row[:] for row in ingrid]
    for col in obstacle_cols:
        for r in range(height):
            output[r][col] = ingrid[r][col + 1]
            output[r][col + 1] = ingrid[r][col]

    # Draw the escape path across the middle row (now unobstructed) by marking
    # background cells with the path color. We only draw on background pixels so
    # obstacles and other features remain unchanged.
    mid_row = height // 2
    for c in range(width):
        if output[mid_row][c] == background:
            output[mid_row][c] = path_color

    return {"input": ingrid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to a mutable grid
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Determine background color as the most frequent color
    counts = {}
    for r in range(height):
        for c in range(width):
            counts[grid[r][c]] = counts.get(grid[r][c], 0) + 1
    background = max(counts, key=lambda k: counts[k])

    # Identify obstacle columns: columns that are the same non-background color in
    # every row and whose immediate right neighbor is a full background column.
    obstacle_cols = []
    for col in range(width - 1):
        col_val = grid[0][col]
        if col_val == background:
            continue
        all_same = True
        for r in range(1, height):
            if grid[r][col] != col_val:
                all_same = False
                break
        if not all_same:
            continue
        # Require the right neighbor to be entirely background (per spec)
        if all(grid[r][col + 1] == background for r in range(height)):
            obstacle_cols.append(col)

    # Perform simultaneous swaps based on the original input snapshot
    snapshot = [row[:] for row in grid]
    out = [row[:] for row in grid]
    for col in obstacle_cols:
        for r in range(height):
            out[r][col] = snapshot[r][col + 1]
            out[r][col + 1] = snapshot[r][col]

    # Draw the escape path across the middle row. The generator uses path color 5,
    # and draws only on background pixels, so we reproduce that.
    path_color = 5
    mid_row = height // 2
    for c in range(width):
        if out[mid_row][c] == background:
            out[mid_row][c] = path_color

    return tuple(tuple(row) for row in out)

