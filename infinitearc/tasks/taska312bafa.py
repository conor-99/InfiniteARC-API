# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: a312bafa
Difficulty: hard

=== Tags ===
- Split and merge
- Pathfinding with state
- Phase shift
- Embedded rule repetition

=== Description ===
The input grids display a dynamic network of interconnected paths, each segment
colored to represent its current state. At every junction, a path splits into
two branches based on the segment's color (e.g., red segments split into paths
moving diagonally inward, green segments split into paths moving outward). Each
branch transitions to a new state color according to a consistent rule, and
paths merge when they converge, with the merged segment adopting a state color
determined by a predefined combinatorial rule (e.g., red + blue = purple). A
"phase shift" advances all active path segments one step in their current
direction, triggering new splits and merges at junctions. The output grid
reflects the network's configuration after one phase shift, showing all paths
updated to their new positions, states, and connections. The "embedded rule
repetition" requires that the split/merge rules are recursively applied at every
junction, creating a self-similar fractal-like pattern where splits generate
smaller-scale repetitions of the original rules. The task demands tracking
multiple state transitions simultaneously across the grid, with the output
revealing emergent structures formed by the interplay of recursive splitting and
merging.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import common
    from common import grid, continuous_creature
    import random
    
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = grid(width, height, 0)
    
    size = min(50, width * height)
    size = random.randint(5, size)
    pixels = continuous_creature(size, width, height)
    
    for r, c in pixels:
        if random.random() < 0.2:
            input_grid[r][c] = 9
        else:
            input_grid[r][c] = 1
    
    output_grid = grid(width, height, 0)
    next_positions = {}
    
    directions = {
        1: (0, 1),
        2: (1, 0),
        3: (0, -1),
        4: (-1, 0),
        5: (-1, 1),
        6: (1, 1),
        7: (1, -1),
        8: (-1, -1),
        9: [(-1, 1), (1, 1)]
    }
    
    for r in range(height):
        for c in range(width):
            color = input_grid[r][c]
            if color == 0:
                continue
            if color == 9:
                for idx, (dr, dc) in enumerate(directions[9]):
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        key = (nr, nc)
                        if key not in next_positions:
                            next_positions[key] = []
                        next_positions[key].append(5 + idx)
            else:
                dr, dc = directions[color]
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    key = (nr, nc)
                    if key not in next_positions:
                        next_positions[key] = []
                    next_positions[key].append(color)
    
    for (r, c), colors in next_positions.items():
        total = sum(colors)
        merged_color = total % 9
        if merged_color == 0:
            merged_color = 9
        output_grid[r][c] = merged_color
    
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = [[0] * width for _ in range(height)]
    next_positions = {}
    
    directions = {
        1: (0, 1),
        2: (1, 0),
        3: (0, -1),
        4: (-1, 0),
        5: (-1, 1),
        6: (1, 1),
        7: (1, -1),
        8: (-1, -1),
        9: [(-1, 1), (1, 1)]
    }
    
    for r in range(height):
        for c in range(width):
            color = input_grid[r][c]
            if color == 0:
                continue
            if color == 9:
                for idx, (dr, dc) in enumerate(directions[9]):
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        key = (nr, nc)
                        if key not in next_positions:
                            next_positions[key] = []
                        next_positions[key].append(5 + idx)
            else:
                dr, dc = directions[color]
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    key = (nr, nc)
                    if key not in next_positions:
                        next_positions[key] = []
                    next_positions[key].append(color)
    
    for (r, c), colors in next_positions.items():
        total = sum(colors)
        merged_color = total % 9
        if merged_color == 0:
            merged_color = 9
        output_grid[r][c] = merged_color
    
    return output_grid
