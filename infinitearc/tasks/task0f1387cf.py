# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 0f1387cf
Difficulty: medium–hard

=== Tags ===
- Maze wave
- Blockwise rule application
- Detect enclosure
- Dual grid translation
- Associate images to bools
- Color the row with most dots

=== Description ===
# Wave Enclosure Mapping  Input grids depict a maze-like structure with
background (color 0), walls (colors 1-3), and paths (colors 4-6). The maze
contains multiple enclosed regions (rooms), each filled with a unique internal
color (7-9) and bounded by walls. A wave pattern (color 7) traverses the maze in
a continuous path, moving through paths and rooms.  The output grid is generated
by: 1. **Detecting Enclosure**: Identifying all rooms (contiguous non-wall, non-
background areas surrounded by walls or grid edges). 2. **Associating Images to
Booleans**: For each room, determining if it is a rectangular block (width ≈
height within 1 cell), setting a boolean flag (True for blocks, False
otherwise). 3. **Blockwise Rule Application**: If any room is a block (True),
the row containing the most non-background cells (dots) in the input grid is
entirely colored with color 8 in the output. 4. **Maze Wave Processing**: The
wave path (color 7) is preserved only within rooms; wave segments outside rooms
are removed. 5. **Dual Grid Translation**: The output grid combines the wave
path (within rooms) and the colored row (from step 3), while all other cells
retain their input values.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Dimensions
    width = random.randint(10, 18)
    height = random.randint(10, 18)
    grid = [[0 for _ in range(width)] for _ in range(height)]

    # Scatter some walls (1-3) lightly to create a maze-like background
    for r in range(height):
        for c in range(width):
            if random.random() < 0.06:  # sparse walls
                grid[r][c] = random.randint(1, 3)

    # Place a few rectangular rooms. Rooms will have a 1-cell wall border and an interior color (9)
    rooms = []  # list of (r0, c0, rh, rw)
    num_rooms = random.randint(2, 3)
    attempts = 0
    while len(rooms) < num_rooms and attempts < 200:
        attempts += 1
        rh = random.randint(2, 4)
        rw = random.randint(2, 4)
        r0 = random.randint(1, height - rh - 2)
        c0 = random.randint(1, width - rw - 2)
        # Check that the rectangle including a 1-cell border is free
        ok = True
        for rr in range(r0 - 1, r0 + rh + 1):
            for cc in range(c0 - 1, c0 + rw + 1):
                if grid[rr][cc] != 0:
                    ok = False
                    break
            if not ok:
                break
        if not ok:
            continue
        wall_color = random.randint(1, 3)
        # Place border walls and interior color 9
        for rr in range(r0 - 1, r0 + rh + 1):
            for cc in range(c0 - 1, c0 + rw + 1):
                if rr == r0 - 1 or rr == r0 + rh or cc == c0 - 1 or cc == c0 + rw:
                    grid[rr][cc] = wall_color
                else:
                    grid[rr][cc] = 9
        rooms.append((r0, c0, rh, rw))

    # Sprinkle some path tiles (4-6) in empty areas to create corridors (but keep many zeros)
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 and random.random() < 0.10:
                grid[r][c] = random.randint(4, 6)

    # Create a single continuous wave (color 7). The wave may travel through zeros and room interiors (9).
    # Start from a random empty border or interior cell that is not a wall.
    zero_positions = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == 0]
    if not zero_positions:
        # fallback: make at least one zero cell
        rr, cc = height // 2, width // 2
        grid[rr][cc] = 0
        zero_positions = [(rr, cc)]
    # Prefer border zeros so wave has outside segments
    border_zeros = [(r, c) for (r, c) in zero_positions if r == 0 or r == height - 1 or c == 0 or c == width - 1]
    if border_zeros:
        start = random.choice(border_zeros)
    else:
        start = random.choice(zero_positions)

    sr, sc = start
    grid[sr][sc] = 7
    wave_positions = [(sr, sc)]

    # Random walk length
    max_steps = random.randint(6, max(8, (width * height) // 6))
    prev = None
    r, c = sr, sc
    for _ in range(max_steps - 1):
        neighs = []
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width:
                # allow step into zeros or room interiors (9), but do not step onto explicit path tiles (4-6) or walls (1-3)
                if grid[nr][nc] in (0, 9):
                    neighs.append((nr, nc))
        if not neighs:
            break
        # try to avoid immediate backtracking unless stuck
        if prev and len(neighs) > 1 and prev in neighs:
            neighs = [p for p in neighs if p != prev]
            if not neighs:
                neighs = [prev]
        nr, nc = random.choice(neighs)
        prev = (r, c)
        r, c = nr, nc
        # Paint the wave (overwrite zeros or room interior cells)
        grid[r][c] = 7
        wave_positions.append((r, c))

    # Ensure there is at least one wave cell outside rooms (so output will differ)
    def inside_any_room(pos):
        pr, pc = pos
        for (r0, c0, rh, rw) in rooms:
            if r0 <= pr < r0 + rh and c0 <= pc < c0 + rw:
                return True
        return False

    # If all wave cells ended up inside rooms (rare), force one outside cell to be a 7
    if all(inside_any_room(p) for p in wave_positions):
        # find a nearby zero and mark it as wave
        outside_candidates = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == 0]
        if outside_candidates:
            orr, occ = random.choice(outside_candidates)
            grid[orr][occ] = 7
            wave_positions.append((orr, occ))

    # Compute output following the specification
    # 1) Detect enclosed rooms: connected components of colors in {7,8,9} that are surrounded by walls (1-3) or edges
    H, W = height, width
    visited = [[False] * W for _ in range(H)]
    enclosed_components = []
    for rr in range(H):
        for cc in range(W):
            if grid[rr][cc] in (7, 8, 9) and not visited[rr][cc]:
                # BFS
                comp = []
                queue = [(rr, cc)]
                visited[rr][cc] = True
                qi = 0
                while qi < len(queue):
                    cr, cc2 = queue[qi]
                    qi += 1
                    comp.append((cr, cc2))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc2 + dc
                        if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc] and grid[nr][nc] in (7, 8, 9):
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                # Check enclosure: every orthogonal neighbor of every cell must be wall (1-3) or outside or part of comp
                comp_set = set(comp)
                enclosed = True
                for (cr, cc2) in comp:
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc2 + dc
                        if 0 <= nr < H and 0 <= nc < W:
                            if (nr, nc) in comp_set:
                                continue
                            if grid[nr][nc] in (1, 2, 3):
                                continue
                            # neighbor is not a wall and not part of comp -> not enclosed
                            enclosed = False
                            break
                        else:
                            # neighbor out of bounds counts as edge, which is acceptable
                            continue
                    if not enclosed:
                        break
                if enclosed:
                    enclosed_components.append(comp)

    # 2) Associate images to booleans: check if any enclosed component is a (filled) block whose bounding box has width≈height within 1
    is_block = False
    for comp in enclosed_components:
        rows = [p[0] for p in comp]
        cols = [p[1] for p in comp]
        min_r, max_r = min(rows), max(rows)
        min_c, max_c = min(cols), max(cols)
        rh = max_r - min_r + 1
        rw = max_c - min_c + 1
        if len(comp) == rh * rw and abs(rh - rw) <= 1:
            is_block = True
            break

    # 3) Find row with most non-background cells
    row_counts = [sum(1 for c in range(W) if grid[r][c] != 0) for r in range(H)]
    max_row = row_counts.index(max(row_counts)) if row_counts else 0

    # 4) Maze wave processing: preserve 7s only if they belong to an enclosed component; otherwise remove them (set to 0)
    # Build a set of all positions that are inside enclosed components
    enclosed_positions = set()
    for comp in enclosed_components:
        for p in comp:
            enclosed_positions.add(p)

    output = [row[:] for row in grid]
    for rr in range(H):
        for cc in range(W):
            if grid[rr][cc] == 7 and (rr, cc) not in enclosed_positions:
                output[rr][cc] = 0

    # 5) If any block room exists, color the row with the most non-background cells entirely with color 8
    if is_block:
        for cc in range(W):
            output[max_row][cc] = 8

    return {
        "input": grid,
        "output": output
    }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0]) if H > 0 else 0

    # 1) Detect connected components formed by colors 7-9
    visited = [[False] * W for _ in range(H)]
    components = []  # list of lists of (r,c)
    for r in range(H):
        for c in range(W):
            if grid[r][c] in (7, 8, 9) and not visited[r][c]:
                comp = []
                queue = [(r, c)]
                visited[r][c] = True
                qi = 0
                while qi < len(queue):
                    cr, cc = queue[qi]
                    qi += 1
                    comp.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc] and grid[nr][nc] in (7, 8, 9):
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                components.append(comp)

    # Check enclosure for each component: neighbors must be walls (1-3) or part of component or out-of-bounds
    enclosed_components = []
    for comp in components:
        comp_set = set(comp)
        enclosed = True
        for (cr, cc) in comp:
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = cr + dr, cc + dc
                if 0 <= nr < H and 0 <= nc < W:
                    if (nr, nc) in comp_set:
                        continue
                    if grid[nr][nc] in (1, 2, 3):
                        continue
                    enclosed = False
                    break
                else:
                    # edges are acceptable
                    continue
            if not enclosed:
                break
        if enclosed:
            enclosed_components.append(comp)

    # 2) Check if any enclosed component is a full block with width≈height
    is_block = False
    for comp in enclosed_components:
        rows = [p[0] for p in comp]
        cols = [p[1] for p in comp]
        min_r, max_r = min(rows), max(rows)
        min_c, max_c = min(cols), max(cols)
        rh = max_r - min_r + 1
        rw = max_c - min_c + 1
        if len(comp) == rh * rw and abs(rh - rw) <= 1:
            is_block = True
            break

    # 3) Find row with most non-background cells
    row_counts = [sum(1 for c in range(W) if grid[r][c] != 0) for r in range(H)]
    max_row = row_counts.index(max(row_counts)) if row_counts else 0

    # 4) Maze wave processing: remove 7s that are not inside enclosed components
    enclosed_pos = set()
    for comp in enclosed_components:
        for p in comp:
            enclosed_pos.add(p)

    output = [row[:] for row in grid]
    for r in range(H):
        for c in range(W):
            if grid[r][c] == 7 and (r, c) not in enclosed_pos:
                output[r][c] = 0

    # 5) If a block exists, color the row with the most non-background cells with color 8
    if is_block:
        for c in range(W):
            output[max_row][c] = 8

    return tuple(tuple(row) for row in output)

