# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 62aa43a7
Difficulty: very hard

=== Tags ===
- Field based motion
- Nearest color fill

=== Description ===
Input grids contain a background color (0) and multiple non-background connected
regions (1-9), each forming a contiguous block. The output grid replaces each
background cell with the color of the nearest non-background region, where
"nearest" is measured along the region's primary axis. A region's primary axis
is determined by its visual orientation: horizontal regions span significantly
more columns than rows (e.g., horizontal bars), while vertical regions span
significantly more rows than columns (e.g., vertical bars). For each background
cell, the horizontal distance to the nearest horizontal region and the vertical
distance to the nearest vertical region are calculated. The cell adopts the
color of the region type (horizontal or vertical) with the smaller distance. If
distances are equal, the cell takes the color of the topmost region (smallest
row index), and if tied, the leftmost region (smallest column index). This
requires visual analysis of region shapes, axis determination, and multi-step
distance comparisons to resolve ties.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random
import collections

def generate():
    # Create a random grid size
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = common.grid(width, height, 0)

    used_colors = []

    # Place a few horizontal and vertical bar-like regions
    num_h = random.randint(1, min(4, height))
    num_v = random.randint(1, min(4, width))

    for _ in range(num_h):
        color = common.random_color(used_colors)
        used_colors.append(color)
        r = random.randint(0, height - 1)
        c_start = random.randint(0, width - 3)
        c_end = random.randint(c_start + 2, width - 1)
        for c in range(c_start, c_end + 1):
            grid[r][c] = color

    for _ in range(num_v):
        color = common.random_color(used_colors)
        used_colors.append(color)
        c = random.randint(0, width - 1)
        r_start = random.randint(0, height - 3)
        r_end = random.randint(r_start + 2, height - 1)
        for r in range(r_start, r_end + 1):
            grid[r][c] = color

    # Ensure there is at least one background cell so output differs
    has_zero = any(grid[r][c] == 0 for r in range(height) for c in range(width))
    if not has_zero:
        # pick a random cell and clear it
        rr = random.randint(0, height - 1)
        cc = random.randint(0, width - 1)
        grid[rr][cc] = 0

    # Helper: find connected components and their bounding boxes
    def find_components(g):
        visited = [[False] * width for _ in range(height)]
        comps = []  # list of (color, min_r, max_r, min_c, max_c)
        for r in range(height):
            for c in range(width):
                if g[r][c] == 0 or visited[r][c]:
                    continue
                color = g[r][c]
                dq = collections.deque()
                dq.append((r, c))
                visited[r][c] = True
                min_r = max_r = r
                min_c = max_c = c
                while dq:
                    cr, cc = dq.popleft()
                    min_r = min(min_r, cr)
                    max_r = max(max_r, cr)
                    min_c = min(min_c, cc)
                    max_c = max(max_c, cc)
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and g[nr][nc] == color:
                            visited[nr][nc] = True
                            dq.append((nr, nc))
                comps.append((color, min_r, max_r, min_c, max_c))
        return comps

    comps = find_components(grid)

    # Classify components into horizontal or vertical primary axis
    h_regions = []  # (row, start_col, end_col, color)
    v_regions = []  # (col, start_row, end_row, color)
    for color, min_r, max_r, min_c, max_c in comps:
        width_region = max_c - min_c + 1
        height_region = max_r - min_r + 1
        if width_region > 2 * height_region:
            # horizontal
            h_regions.append((min_r, min_c, max_c, color))
        elif height_region > 2 * width_region:
            # vertical
            v_regions.append((min_c, min_r, max_r, color))
        else:
            # ambiguous: choose by larger span (consistent with solver)
            if width_region >= height_region:
                h_regions.append((min_r, min_c, max_c, color))
            else:
                v_regions.append((min_c, min_r, max_r, color))

    # Fill background cells according to nearest region along the region's primary axis
    output = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                continue

            # Find closest horizontal region (by horizontal distance, then topmost, then leftmost)
            closest_h = None
            min_h_key = None  # tuple (dist, row, start_col, color)
            for (hr, h_start, h_end, color) in h_regions:
                if c < h_start:
                    dist = h_start - c
                elif c > h_end:
                    dist = c - h_end
                else:
                    dist = 0
                key = (dist, hr, h_start, color)
                if min_h_key is None or key < min_h_key:
                    min_h_key = key
                    closest_h = (hr, h_start, h_end, color)

            # Find closest vertical region (by vertical distance, then topmost, then leftmost)
            closest_v = None
            min_v_key = None  # tuple (dist, top_row, col, color)
            for (vc, v_start, v_end, color) in v_regions:
                if r < v_start:
                    dist = v_start - r
                elif r > v_end:
                    dist = r - v_end
                else:
                    dist = 0
                key = (dist, v_start, vc, color)
                if min_v_key is None or key < min_v_key:
                    min_v_key = key
                    closest_v = (vc, v_start, v_end, color)

            # Decide which region type wins
            if min_h_key is None and min_v_key is None:
                # No regions found (shouldn't happen), leave as background
                continue
            if min_h_key is None:
                output[r][c] = closest_v[3]
                continue
            if min_v_key is None:
                output[r][c] = closest_h[3]
                continue

            min_h_dist = min_h_key[0]
            min_v_dist = min_v_key[0]

            if min_h_dist < min_v_dist:
                output[r][c] = closest_h[3]
            elif min_v_dist < min_h_dist:
                output[r][c] = closest_v[3]
            else:
                # tie: choose topmost region (smallest row index), then leftmost
                h_row = closest_h[0]
                v_top = closest_v[1]
                if h_row < v_top:
                    output[r][c] = closest_h[3]
                elif v_top < h_row:
                    output[r][c] = closest_v[3]
                else:
                    h_left = closest_h[1]
                    v_col = closest_v[0]
                    if h_left < v_col:
                        output[r][c] = closest_h[3]
                    else:
                        output[r][c] = closest_v[3]

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
import collections

def p(input_grid):
    # Convert input to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # Helper: find connected components and their bounding boxes
    def find_components(g):
        visited = [[False] * width for _ in range(height)]
        comps = []  # list of (color, min_r, max_r, min_c, max_c)
        for r in range(height):
            for c in range(width):
                if g[r][c] == 0 or visited[r][c]:
                    continue
                color = g[r][c]
                dq = collections.deque()
                dq.append((r, c))
                visited[r][c] = True
                min_r = max_r = r
                min_c = max_c = c
                while dq:
                    cr, cc = dq.popleft()
                    min_r = min(min_r, cr)
                    max_r = max(max_r, cr)
                    min_c = min(min_c, cc)
                    max_c = max(max_c, cc)
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and g[nr][nc] == color:
                            visited[nr][nc] = True
                            dq.append((nr, nc))
                comps.append((color, min_r, max_r, min_c, max_c))
        return comps

    comps = find_components(grid)

    # Classify components into horizontal or vertical primary axis
    h_regions = []  # (row, start_col, end_col, color)
    v_regions = []  # (col, start_row, end_row, color)
    for color, min_r, max_r, min_c, max_c in comps:
        width_region = max_c - min_c + 1
        height_region = max_r - min_r + 1
        if width_region > 2 * height_region:
            h_regions.append((min_r, min_c, max_c, color))
        elif height_region > 2 * width_region:
            v_regions.append((min_c, min_r, max_r, color))
        else:
            if width_region >= height_region:
                h_regions.append((min_r, min_c, max_c, color))
            else:
                v_regions.append((min_c, min_r, max_r, color))

    # Fill background cells
    output = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                continue

            # Closest horizontal region
            closest_h = None
            min_h_key = None
            for (hr, h_start, h_end, color) in h_regions:
                if c < h_start:
                    dist = h_start - c
                elif c > h_end:
                    dist = c - h_end
                else:
                    dist = 0
                key = (dist, hr, h_start, color)
                if min_h_key is None or key < min_h_key:
                    min_h_key = key
                    closest_h = (hr, h_start, h_end, color)

            # Closest vertical region
            closest_v = None
            min_v_key = None
            for (vc, v_start, v_end, color) in v_regions:
                if r < v_start:
                    dist = v_start - r
                elif r > v_end:
                    dist = r - v_end
                else:
                    dist = 0
                key = (dist, v_start, vc, color)
                if min_v_key is None or key < min_v_key:
                    min_v_key = key
                    closest_v = (vc, v_start, v_end, color)

            if min_h_key is None and min_v_key is None:
                continue
            if min_h_key is None:
                output[r][c] = closest_v[3]
                continue
            if min_v_key is None:
                output[r][c] = closest_h[3]
                continue

            min_h_dist = min_h_key[0]
            min_v_dist = min_v_key[0]

            if min_h_dist < min_v_dist:
                output[r][c] = closest_h[3]
            elif min_v_dist < min_h_dist:
                output[r][c] = closest_v[3]
            else:
                # tie
                h_row = closest_h[0]
                v_top = closest_v[1]
                if h_row < v_top:
                    output[r][c] = closest_h[3]
                elif v_top < h_row:
                    output[r][c] = closest_v[3]
                else:
                    h_left = closest_h[1]
                    v_col = closest_v[0]
                    if h_left < v_col:
                        output[r][c] = closest_h[3]
                    else:
                        output[r][c] = closest_v[3]

    return output

