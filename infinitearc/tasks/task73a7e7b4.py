# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 73a7e7b4
Difficulty: insane

=== Tags ===
- Hierarchical reasoning
- Draw line of sight
- Field interference pattern

=== Description ===
Input grids feature a background color (0) with scattered elements: primary
field emitters (colors 1-3), obstacle structures (color 4 forming interconnected
walls), and a horizontal pattern strip (top-left corner, width 3-5, height 1)
containing a repeating sequence of colors 5-7. The output grid is generated
through hierarchical line-of-sight propagation with interference patterns:  1.
**Primary Line of Sight**: From each primary emitter (colors 1-3), draw lines in
all four cardinal directions until blocked by obstacles (color 4) or grid
boundaries. Lines overwrite background cells (0) using the emitter's color. The
line's color sequence cycles through the pattern strip (e.g., first cell =
pattern[0], next = pattern[1], etc.).  2. **Primary Interference**: Cells where
lines from ≥2 primary emitters intersect are marked with color 8 (overriding
emitter colors). The interference color is determined by the pattern strip's
next sequence position after the last used color.  3. **Hierarchical Field
Emission**: Treat all color 8 cells as new emitters. Draw secondary lines from
these cells in four directions, using the pattern strip sequence (starting from
the next color after the primary line's last position). Secondary lines only
propagate through background cells (0) or primary line cells (not over obstacles
or primary emitters).  4. **Secondary Interference**: Cells where lines from ≥2
secondary emitters intersect are marked with color 9, determined by the pattern
strip's next sequence position.  All obstacles (color 4), primary emitters
(1-3), and the pattern strip remain unchanged. Interference patterns (colors
8-9) form hierarchical field interference patterns where lines cross, with
colors cycling through the pattern strip sequence. No lines pass through
obstacles, and all paths terminate at grid boundaries without self-intersection.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    # Size selected to provide nontrivial scenes but keep generation fast
    size = random.randint(12, 24)
    grid = common.grid(size, size, 0)

    # Create a top-left horizontal pattern strip (colors 5-7)
    pattern_len = random.randint(3, 5)
    pattern = [random.choice([5, 6, 7]) for _ in range(pattern_len)]
    for c in range(pattern_len):
        grid[0][c] = pattern[c]

    # Build an interconnected obstacle structure (cross + extra blocks)
    # Choose a horizontal and a vertical wall (avoid row 0 to keep pattern intact)
    if size >= 6:
        hr = random.randint(2, size - 3)
    else:
        hr = 1
    vc = random.randint(1, size - 2)

    for c in range(size):
        grid[hr][c] = 4
    for r in range(size):
        grid[r][vc] = 4

    # Add a few extra obstacle blocks to make the walls irregular / interconnected
    extra_blocks = random.randint(max(1, size // 6), max(1, size // 3))
    for _ in range(extra_blocks):
        r = random.randint(1, size - 1)
        c = random.randint(0, size - 1)
        # Do not overwrite the top-left pattern
        if r == 0 and c < pattern_len:
            continue
        grid[r][c] = 4

    # Re-assert the pattern (in case obstacle placement disturbed it)
    for c in range(pattern_len):
        grid[0][c] = pattern[c]

    # Place 2-4 primary emitters (colors 1-3) on background cells only
    free_cells = [(r, c) for r in range(1, size) for c in range(size) if grid[r][c] == 0]
    n_emit = random.randint(2, 4)
    n_emit = min(n_emit, len(free_cells))
    emit_positions = random.sample(free_cells, n_emit)
    emitters = []
    for (r, c) in emit_positions:
        color = random.choice([1, 2, 3])
        grid[r][c] = color
        emitters.append((r, c, color))

    # Primary propagation: collect contributions (emitter id, step) for each reachable cell
    L = len(pattern)
    contribs = {}  # (r,c) -> list of (emitter_idx, step)
    for eid, (er, ec, _) in enumerate(emitters):
        for dr, dc in ((0, 1), (1, 0), (0, -1), (-1, 0)):
            step = 1
            cr, cc = er + dr, ec + dc
            while 0 <= cr < size and 0 <= cc < size:
                # Stop at obstacles, primary emitters, or the pattern strip
                if grid[cr][cc] == 4 or grid[cr][cc] in (1, 2, 3):
                    break
                if cr == 0 and cc < pattern_len:
                    break
                # Record a contribution from this emitter at this step distance
                contribs.setdefault((cr, cc), []).append((eid, step))
                step += 1
                cr += dr
                cc += dc

    # Build the intermediate output after primary propagation
    output = [row[:] for row in grid]
    # For cells with a single contribution, paint with the appropriate pattern color
    # For cells with >=2 contributions, mark them as interference (color 8) and
    # record the next pattern index (used to seed secondary emission)
    primary_start_for_8 = {}  # (r,c) -> start_index for secondary propagation
    for (r, c), lst in contribs.items():
        if len(lst) == 1:
            _, step = lst[0]
            output[r][c] = pattern[(step - 1) % L]
        else:
            # Determine the "last used" color by choosing the contribution with the
            # largest step (furthest emitter) and then take the next pattern index.
            max_step = max(s for (_id, s) in lst)
            last_idx = (max_step - 1) % L
            primary_start_for_8[(r, c)] = (last_idx + 1) % L
            output[r][c] = 8

    # Secondary propagation from all 8-cells: allow passing through background (0)
    # and primary line cells (5-7), but stop at obstacles, primary emitters, the
    # pattern strip, or other 8-cells.
    sec_contribs = {}  # (r,c) -> list of (sr,sc, step, start_idx)
    for (sr, sc), start_idx in primary_start_for_8.items():
        for dr, dc in ((0, 1), (1, 0), (0, -1), (-1, 0)):
            step = 1
            cr, cc = sr + dr, sc + dc
            while 0 <= cr < size and 0 <= cc < size:
                # Blockers that stop secondary propagation
                if grid[cr][cc] in (4, 1, 2, 3):
                    break
                if cr == 0 and cc < pattern_len:
                    break
                if output[cr][cc] == 8:
                    break
                # Secondary may propagate through background or primary-line cells
                if output[cr][cc] in (0, 5, 6, 7):
                    sec_contribs.setdefault((cr, cc), []).append((sr, sc, step, start_idx))
                    step += 1
                    cr += dr
                    cc += dc
                    continue
                # Any other cell stops propagation
                break

    # Apply secondary contributions: single -> pattern color (continuing sequence),
    # multiple -> interference (color 9)
    for (r, c), lst in sec_contribs.items():
        if len(lst) == 1:
            _sr, _sc, step, start_idx = lst[0]
            output[r][c] = pattern[(start_idx + step - 1) % L]
        else:
            output[r][c] = 9

    # Ensure obstacles, primary emitters and the pattern strip remain unchanged
    for c in range(pattern_len):
        output[0][c] = pattern[c]
    for r in range(size):
        for c in range(size):
            if grid[r][c] in (1, 2, 3):
                output[r][c] = grid[r][c]
            if grid[r][c] == 4:
                output[r][c] = 4

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    size = len(grid)

    # Extract the pattern strip from top-left row
    pattern = []
    if size > 0:
        for c in range(len(grid[0])):
            if grid[0][c] in (5, 6, 7):
                pattern.append(grid[0][c])
            else:
                break
    if not pattern:
        pattern = [5, 6, 7]
    L = len(pattern)

    # Find primary emitters (colors 1-3)
    emitters = []
    for r in range(size):
        for c in range(size):
            if grid[r][c] in (1, 2, 3):
                emitters.append((r, c, grid[r][c]))

    # Primary contributions: record (emitter_id, step) for each reachable cell
    contribs = {}
    for eid, (er, ec, _) in enumerate(emitters):
        for dr, dc in ((0, 1), (1, 0), (0, -1), (-1, 0)):
            step = 1
            cr, cc = er + dr, ec + dc
            while 0 <= cr < size and 0 <= cc < size:
                # Stop at obstacles, primary emitters, or the pattern strip
                if grid[cr][cc] == 4 or grid[cr][cc] in (1, 2, 3):
                    break
                if cr == 0 and cc < len(pattern):
                    break
                contribs.setdefault((cr, cc), []).append((eid, step))
                step += 1
                cr += dr
                cc += dc

    # Build intermediate output after primary propagation
    output = [row[:] for row in grid]
    primary_start_for_8 = {}
    for (r, c), lst in contribs.items():
        if len(lst) == 1:
            _, step = lst[0]
            output[r][c] = pattern[(step - 1) % L]
        else:
            max_step = max(s for (_id, s) in lst)
            last_idx = (max_step - 1) % L
            primary_start_for_8[(r, c)] = (last_idx + 1) % L
            output[r][c] = 8

    # Secondary contributions from 8-cells
    sec_contribs = {}
    for (sr, sc), start_idx in primary_start_for_8.items():
        for dr, dc in ((0, 1), (1, 0), (0, -1), (-1, 0)):
            step = 1
            cr, cc = sr + dr, sc + dc
            while 0 <= cr < size and 0 <= cc < size:
                # Blockers
                if grid[cr][cc] in (4, 1, 2, 3):
                    break
                if cr == 0 and cc < len(pattern):
                    break
                if output[cr][cc] == 8:
                    break
                if output[cr][cc] in (0, 5, 6, 7):
                    sec_contribs.setdefault((cr, cc), []).append((sr, sc, step, start_idx))
                    step += 1
                    cr += dr
                    cc += dc
                    continue
                break

    # Finalize secondary: single -> pattern continuation, multiple -> 9
    for (r, c), lst in sec_contribs.items():
        if len(lst) == 1:
            _sr, _sc, step, start_idx = lst[0]
            output[r][c] = pattern[(start_idx + step - 1) % L]
        else:
            output[r][c] = 9

    # Ensure obstacles, primary emitters and the pattern strip remain unchanged
    for c in range(len(pattern)):
        output[0][c] = pattern[c]
    for r in range(size):
        for c in range(size):
            if grid[r][c] in (1, 2, 3):
                output[r][c] = grid[r][c]
            if grid[r][c] == 4:
                output[r][c] = 4

    return output

