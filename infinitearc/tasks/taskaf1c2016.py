# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: af1c2016
Difficulty: medium

=== Tags ===
- Detect wall
- X marks the spot
- Shape guessing

=== Description ===
The input grid features a single, connected shape (non-zero color) surrounded by
background (color 0), forming a closed region such as a rectangle, polygon, or
irregular blob. The task requires detecting the outer boundary (wall) of this
shape by identifying all pixels belonging to the shape that are adjacent to
background pixels (color 0). These boundary pixels are then replaced with a new
color (e.g., color 2) in the output grid. Simultaneously, the geometric center
of the shape's bounding box (the smallest rectangle encompassing all shape
pixels) is calculated by averaging the minimum and maximum row and column
indices of the shape's pixels. An "X" marker (color 9) is placed at this center
position. The output grid thus highlights the shape's perimeter as a distinct
outline and marks its central point with an "X," requiring the solver to
recognize the shape's structure, identify its boundary, and compute its centroid
for the marker placement.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    shape_color = random.randint(1, 9)
    shape_size = random.randint(5, width * height - 5)
    pixels = common.continuous_creature(shape_size, width, height)
    input_grid = common.grid(width, height, 0)
    for r, c in pixels:
        input_grid[r][c] = shape_color
    output_grid = [row[:] for row in input_grid]
    boundary = []
    for r, c in pixels:
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 0:
                boundary.append((r, c))
                break
    for r, c in boundary:
        output_grid[r][c] = 2
    rows = [p[0] for p in pixels]
    cols = [p[1] for p in pixels]
    min_row, max_row = min(rows), max(rows)
    min_col, max_col = min(cols), max(cols)
    center_row = (min_row + max_row) // 2
    center_col = (min_col + max_col) // 2
    output_grid[center_row][center_col] = 9
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    shape_pixels = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                shape_pixels.append((r, c))
    if not shape_pixels:
        return input_grid
    boundary = []
    for r, c in shape_pixels:
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 0:
                boundary.append((r, c))
                break
    output_grid = [row[:] for row in input_grid]
    for r, c in boundary:
        output_grid[r][c] = 2
    rows = [p[0] for p in shape_pixels]
    cols = [p[1] for p in shape_pixels]
    min_row, max_row = min(rows), max(rows)
    min_col, max_col = min(cols), max(cols)
    center_row = (min_row + max_row) // 2
    center_col = (min_col + max_col) // 2
    output_grid[center_row][center_col] = 9
    return output_grid
