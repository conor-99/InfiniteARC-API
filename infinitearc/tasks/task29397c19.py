# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 29397c19
Difficulty: insane

=== Tags ===
- Competitive agents
- Draw x on largest object

=== Description ===
Input grids consist of a background (color 0) and multiple non-background
colored objects, each forming a contiguous 4-connected region of a single color.
These objects represent competitive agents; the largest agent (by cell count) is
determined. In case of a tie in size, the agent with the highest color value is
selected. The output grid is identical to the input except that an 'X' pattern
(two crossing diagonal lines) is drawn at the geometric center of the largest
agent's region using a fixed color (e.g., maroon). The 'X' replaces the original
color of the cells it covers within the largest region, while all other elements
remain unchanged. The geometric center is calculated as the average of all
coordinates within the region, and the 'X' is drawn using the closest cells to
this center point to form the pattern.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    """
    Generate a grid with several non-background contiguous objects (4-connected),
    choose the largest object (tie-break by larger color), compute its geometric
    center, and draw an 'X' (center + four diagonals at distance 1) using a color
    different from the object's color.
    """
    # Try a few times to produce a valid configuration (at least 2 objects)
    for _attempt in range(200):
        width = common.randint(6, 25)
        height = common.randint(6, 25)
        grid = [[0 for _ in range(width)] for _ in range(height)]

        # Number of objects and their colors (unique colors to avoid accidental merges)
        num_objects = common.randint(2, min(6, 8))
        colors = list(range(1, 10))
        random.shuffle(colors)
        colors = colors[:num_objects]

        placed_objects = []  # list of (color, cells_list)
        occupied = set()

        for color in colors:
            # Create a contiguous sprite within a small bounding box
            shape_w = common.randint(3, min(8, width))
            shape_h = common.randint(3, min(8, height))
            max_cells = shape_w * shape_h
            size = common.randint(4, min(12, max_cells))
            region = common.continuous_creature(size, shape_w, shape_h)

            # Compute bounding box of the region
            min_r = min(r for r, c in region)
            max_r = max(r for r, c in region)
            min_c = min(c for r, c in region)
            max_c = max(c for r, c in region)
            bbox_h = max_r - min_r + 1
            bbox_w = max_c - min_c + 1

            if bbox_h > height or bbox_w > width:
                continue

            # Attempt to place this region without overlapping existing objects
            placed = False
            for _ in range(60):
                offset_r = common.randint(0, height - bbox_h)
                offset_c = common.randint(0, width - bbox_w)
                new_cells = []
                conflict = False
                for (r, c) in region:
                    nr = offset_r + r - min_r
                    nc = offset_c + c - min_c
                    if (nr, nc) in occupied:
                        conflict = True
                        break
                    new_cells.append((nr, nc))
                if conflict:
                    continue
                # Place the region
                for (nr, nc) in new_cells:
                    grid[nr][nc] = color
                    occupied.add((nr, nc))
                placed_objects.append((color, new_cells))
                placed = True
                break
            # If cannot place this object, skip it and try the next color

        # Need at least 2 placed objects for a valid puzzle
        if len(placed_objects) < 2:
            continue

        # Determine largest object (by size, tie-break by larger color)
        largest = max(placed_objects, key=lambda x: (len(x[1]), x[0]))
        lcolor, lcells = largest

        # Geometric center (centroid)
        centroid_r = sum(r for r, c in lcells) / len(lcells)
        centroid_c = sum(c for r, c in lcells) / len(lcells)

        # Choose the closest cell to the centroid using Euclidean distance,
        # tie-break with row then column to make selection deterministic
        def dist_key(cell):
            r, c = cell
            d = (r - centroid_r) ** 2 + (c - centroid_c) ** 2
            return (d, r, c)

        center = min(lcells, key=dist_key)

        # Choose X color that is different from the largest object's color
        x_color = 9 if lcolor != 9 else 8

        # Draw the X (center and four diagonals) but only inside the object's cells
        output = [row[:] for row in grid]
        cr, cc = center
        for dr, dc in [(-1, -1), (0, 0), (1, 1), (-1, 1), (1, -1)]:
            rr = cr + dr
            cc2 = cc + dc
            if 0 <= rr < height and 0 <= cc2 < width and (rr, cc2) in lcells:
                output[rr][cc2] = x_color

        # Ensure output differs from input (X color is chosen to ensure this)
        if output != grid:
            return {"input": grid, "output": output}

    # Fallback: return last generated (shouldn't normally reach here)
    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # Find all 4-connected components of non-zero color
    visited = [[False] * width for _ in range(height)]
    components = []  # list of (color, cells)

    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and not visited[r][c]:
                color = grid[r][c]
                queue = [(r, c)]
                visited[r][c] = True
                cells = []
                while queue:
                    cr, cc = queue.pop(0)
                    cells.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                components.append((color, cells))

    if not components:
        return grid

    # Select largest object, tie-break on larger color value
    largest = max(components, key=lambda x: (len(x[1]), x[0]))
    lcolor, lcells = largest

    # Geometric center
    centroid_r = sum(r for r, c in lcells) / len(lcells)
    centroid_c = sum(c for r, c in lcells) / len(lcells)

    # Closest cell to centroid (Euclidean), tie-break on row then column
    def dist_key(cell):
        r, c = cell
        d = (r - centroid_r) ** 2 + (c - centroid_c) ** 2
        return (d, r, c)

    center = min(lcells, key=dist_key)

    # Choose X color (must match generator logic): use 9 unless the object's color is 9
    x_color = 9 if lcolor != 9 else 8

    out = [row[:] for row in grid]
    cr, cc = center
    cellset = set(lcells)
    for dr, dc in [(-1, -1), (0, 0), (1, 1), (-1, 1), (1, -1)]:
        rr = cr + dr
        cc2 = cc + dc
        if 0 <= rr < height and 0 <= cc2 < width and (rr, cc2) in cellset:
            out[rr][cc2] = x_color

    return out

