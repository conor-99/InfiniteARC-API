# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 7ac7beeb
Difficulty: hard

=== Tags ===
- One yes one no
- Bridges
- Shape morphing
- X marks the spot

=== Description ===
The task involves transforming input grids containing a bridge—a linear
connection (horizontal or vertical) between two distinct shapes—and an 'X'
pattern (two intersecting lines forming a cross) precisely positioned at the
bridge's midpoint. The output grid must remove the bridge, merging the two
connected shapes into a single contiguous region, while replacing the 'X' with a
new geometric pattern (e.g., a solid square or diamond). Additionally, the
surrounding shapes must undergo morphing to smoothly fill the vacated space,
ensuring no gaps or disconnected regions remain. The "one yes one no" aspect
refers to the bridge's presence in the input (yes) and its absence in the output
(no), while the 'X' mark (yes) is transformed into a new pattern (no longer an
'X'). For hard difficulty, inputs feature bridges of variable thickness (1–3
cells), diagonal bridges, and 'X' patterns slightly offset from the exact
midpoint, requiring precise spatial reasoning to identify the bridge, verify the
'X' location, and apply morphing rules that adjust shape boundaries and
connectivity.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
from common import grid, draw
import random

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    input_grid = grid(width, height, 0)
    output_grid = grid(width, height, 0)
    
    # Generate shape A (color 1)
    shape_A_rows, shape_A_cols = common.conway_sprite(width=5, height=5, tries=3)
    shape_A = [(r, c) for r, c in zip(shape_A_rows, shape_A_cols)]
    for r, c in shape_A:
        if r < height and c < width:
            input_grid[r][c] = 1
    
    # Generate shape B (color 2)
    shape_B_rows, shape_B_cols = common.conway_sprite(width=5, height=5, tries=3)
    shape_B = [(r, c) for r, c in zip(shape_B_rows, shape_B_cols)]
    for r, c in shape_B:
        r_offset = height - 6
        c_offset = width - 6
        if r < height and c < width:
            input_grid[r + r_offset][c + c_offset] = 2
    
    # Determine bridge direction (horizontal, vertical, diagonal)
    bridge_direction = random.choice(['horizontal', 'vertical', 'diagonal'])
    bridge_length = random.choice([1, 3])
    
    if bridge_direction == 'horizontal':
        row = random.randint(3, height - 4)
        start_col = random.randint(3, width - 4 - bridge_length)
        for i in range(bridge_length):
            col = start_col + i
            if i == bridge_length // 2:
                input_grid[row][col] = 9  # X
            else:
                input_grid[row][col] = 5
    
    elif bridge_direction == 'vertical':
        col = random.randint(3, width - 4)
        start_row = random.randint(3, height - 4 - bridge_length)
        for i in range(bridge_length):
            row = start_row + i
            if i == bridge_length // 2:
                input_grid[row][col] = 9
            else:
                input_grid[row][col] = 5
    
    else:  # diagonal
        start_row = random.randint(3, height - 4 - bridge_length)
        start_col = random.randint(3, width - 4 - bridge_length)
        for i in range(bridge_length):
            row = start_row + i
            col = start_col + i
            if i == bridge_length // 2:
                input_grid[row][col] = 9
            else:
                input_grid[row][col] = 5

    # Copy input to output
    output_grid = [row[:] for row in input_grid]
    
    # Remove bridge (5 and 9) and replace X with 2x2 square
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] in [5, 9]:
                output_grid[r][c] = 0
    
    # Find X position
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 9:
                for dr in [-1, 0]:
                    for dc in [-1, 0]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < height and 0 <= nc < width:
                            output_grid[nr][nc] = 7
    
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = [list(row) for row in input_grid]
    
    # Find bridge cells (5s and 9)
    bridge_cells = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] in [5, 9]:
                bridge_cells.append((r, c))
    
    if not bridge_cells:
        return output_grid
    
    # Find midpoint in bridge sequence
    bridge_cells.sort(key=lambda x: (x[0], x[1]))
    midpoint = bridge_cells[len(bridge_cells)//2]
    
    # Remove bridge cells
    for r, c in bridge_cells:
        output_grid[r][c] = 0
    
    # Replace X with 2x2 square
    for dr in [-1, 0]:
        for dc in [-1, 0]:
            r, c = midpoint[0] + dr, midpoint[1] + dc
            if 0 <= r < height and 0 <= c < width:
                output_grid[r][c] = 7
    
    return output_grid
