# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: bd6ed855
Difficulty: hard

=== Tags ===
- Analogical mapping between pairs
- Pattern rotation
- Gas expansion
- Local physics rule
- Connect the dots
- Measure area

=== Description ===
Input grids feature a path of non-background colored dots (each dot is a single
cell) connected sequentially (connect the dots), forming a loop where
consecutive dots are adjacent horizontally or vertically. Each dot color
represents a gas source, and the output grid applies a gas expansion rule: each
dot expands outward by one cell in all four cardinal directions (up, down, left,
right), filling only background cells (color 0) without overlapping existing
dots. After expansion, the entire grid undergoes a 90-degree clockwise pattern
rotation (pattern rotation). The area covered by each expanded region (measured
as the number of cells in the expansion) is visually represented by the
thickness of the connecting line between consecutive dots in the output, with
thicker lines indicating larger areas. The analogical mapping between input and
output ensures that each pair of consecutive dots in the path corresponds to a
rotated, expanded segment in the output, with all background cells remaining
unchanged except for the expanded regions. The local physics rule enforces that
expansions only occur into background cells and do not propagate through or
overwrite existing dots or their expanded regions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    size = random.randint(5, 30)
    grid = [[0] * size for _ in range(size)]
    r1 = random.randint(1, size - 4)
    r2 = random.randint(r1 + 2, size - 2)
    c1 = random.randint(1, size - 4)
    c2 = random.randint(c1 + 2, size - 2)
    path = []
    for c in range(c1, c2 + 1):
        path.append((r1, c))
    for r in range(r1 + 1, r2 + 1):
        path.append((r, c2))
    for c in range(c2 - 1, c1 - 1, -1):
        path.append((r2, c))
    for r in range(r2 - 1, r1, -1):
        path.append((r, c1))
    colors = [random.randint(1, 9) for _ in range(len(path))]
    for (r, c), color in zip(path, colors):
        grid[r][c] = color
    input_grid = [row[:] for row in grid]
    expanded = [row[:] for row in grid]
    for (r, c) in path:
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < size and 0 <= nc < size and expanded[nr][nc] == 0:
                expanded[nr][nc] = grid[r][c]
    rotated = [list(x) for x in zip(*expanded[::-1])]
    return {
        "input": input_grid,
        "output": rotated
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    size = len(grid)
    path = []
    for r in range(size):
        for c in range(size):
            if grid[r][c] != 0:
                path.append((r, c))
    if not path:
        return grid
    min_r = min(r for r, c in path)
    max_r = max(r for r, c in path)
    min_c = min(c for r, c in path)
    max_c = max(c for r, c in path)
    new_path = []
    for c in range(min_c, max_c + 1):
        new_path.append((min_r, c))
    for r in range(min_r + 1, max_r + 1):
        new_path.append((r, max_c))
    for c in range(max_c - 1, min_c - 1, -1):
        new_path.append((max_r, c))
    for r in range(max_r - 1, min_r, -1):
        new_path.append((r, min_c))
    for (r, c) in new_path:
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < size and 0 <= nc < size and grid[nr][nc] == 0:
                grid[nr][nc] = grid[r][c]
    rotated = [list(x) for x in zip(*grid[::-1])]
    return rotated
