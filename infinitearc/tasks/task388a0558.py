# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 388a0558
Difficulty: hard

=== Tags ===
- Friction path
- Mask based logic
- Heat map draw
- State transfer chain

=== Description ===
Input grids feature a contiguous mask region defined by color 9 on a
0-background. Within this mask, friction zones (color 5 for clockwise turns,
color 6 for counterclockwise turns) and multiple straight-line paths (color 1)
originate from the mask's boundary. Each path moves in its initial direction
(determined by its orientation at the boundary) until encountering a friction
zone, where it instantaneously changes direction by 90Â° clockwise (color 5) or
counterclockwise (color 6) while continuing through the grid. Paths terminate
when exiting the mask region. The output grid displays a heat map exclusively
within the mask, where each cell's color corresponds to the number of paths that
traversed it (1-9, with higher counts represented by higher colors), while all
non-mask regions retain background color 0. Friction zones do not block paths
but alter their direction, and paths never overlap or intersect friction zones
at corners. The transformation requires tracking path trajectories through
sequential state changes (direction) at each friction interaction, followed by
aggregating traversal counts to generate the heat map.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    grid = common.grid(width, height, 0)
    
    mask_size = random.randint(20, 30)
    mask_pixels = common.continuous_creature(mask_size, width, height)
    
    # Apply random horizontal flip to increase diversity
    if random.choice([True, False]):
        mask_pixels = [(r, width - 1 - c) for (r, c) in mask_pixels]
    
    for r, c in mask_pixels:
        if 0 <= r < height and 0 <= c < width:
            grid[r][c] = 9
    
    mask_boundary = []
    for r, c in mask_pixels:
        if not (0 <= r < height and 0 <= c < width):
            continue
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0:
                mask_boundary.append((r, c))
                break
    
    friction_count = random.randint(4, 7)
    friction_positions = []
    friction_colors = []
    for _ in range(friction_count):
        while True:
            r = random.randint(0, height-1)
            c = random.randint(0, width-1)
            if (r, c) in mask_pixels and (r, c) not in mask_boundary:
                friction_positions.append((r, c))
                friction_colors.append(random.choice([5, 6]))
                break
    
    for (r, c), color in zip(friction_positions, friction_colors):
        if 0 <= r < height and 0 <= c < width:
            grid[r][c] = color
    
    path_count = random.randint(4, 7)
    for _ in range(path_count):
        if not mask_boundary:
            break
        start = random.choice(mask_boundary)
        r, c = start
        directions = []
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 9:
                directions.append((dr, dc))
        if not directions:
            continue
        dr, dc = random.choice(directions)
        direction = (dr, dc)
        
        if 0 <= r < height and 0 <= c < width:
            grid[r][c] = 1
        current = (r, c)
        while True:
            nr, nc = current[0] + direction[0], current[1] + direction[1]
            if not (0 <= nr < height and 0 <= nc < width):
                break
            if grid[nr][nc] == 9:
                if grid[nr][nc] in [5, 6]:
                    break
                else:
                    current = (nr, nc)
                    if 0 <= nr < height and 0 <= nc < width:
                        grid[nr][nc] = 1
            else:
                break
        
        if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] in [5, 6]:
            if grid[nr][nc] == 5:
                dr, dc = direction
                direction = (dc, -dr)
            elif grid[nr][nc] == 6:
                dr, dc = direction
                direction = (-dc, dr)
        
        while True:
            nr, nc = current[0] + direction[0], current[1] + direction[1]
            if not (0 <= nr < height and 0 <= nc < width) or grid[nr][nc] != 9:
                break
            if grid[nr][nc] in [5, 6]:
                break
            current = (nr, nc)
            if 0 <= nr < height and 0 <= nc < width:
                grid[nr][nc] = 1
    
    output = common.grid(width, height, 0)
    count_grid = common.grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            if 0 <= r < height and 0 <= c < width and grid[r][c] == 9:
                count_grid[r][c] = 0
    
    for r in range(height):
        for c in range(width):
            if 0 <= r < height and 0 <= c < width and grid[r][c] == 1:
                count_grid[r][c] += 1
    
    for r in range(height):
        for c in range(width):
            if 0 <= r < height and 0 <= c < width and grid[r][c] == 9:
                count = count_grid[r][c]
                output[r][c] = min(count, 9)
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    
    mask = set()
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 9:
                mask.add((r, c))
    
    mask_boundary = set()
    for (r, c) in mask:
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 9:
                mask_boundary.add((r, c))
                break
    
    count_grid = [[0] * width for _ in range(height)]
    
    for (r, c) in mask_boundary:
        if grid[r][c] == 1:
            current = (r, c)
            direction = None
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 1:
                    direction = (dr, dc)
                    break
            if direction is None:
                continue
            
            while True:
                if 0 <= current[0] < height and 0 <= current[1] < width:
                    count_grid[current[0]][current[1]] += 1
                nr, nc = current[0] + direction[0], current[1] + direction[1]
                if not (0 <= nr < height and 0 <= nc < width):
                    break
                if (nr, nc) not in mask:
                    break
                if grid[nr][nc] in [5, 6]:
                    if grid[nr][nc] == 5:
                        dr, dc = direction
                        direction = (dc, -dr)
                    elif grid[nr][nc] == 6:
                        dr, dc = direction
                        direction = (-dc, dr)
                    current = (nr, nc)
                    continue
                elif grid[nr][nc] == 1:
                    current = (nr, nc)
                else:
                    break
    
    output = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if (r, c) in mask:
                count = count_grid[r][c]
                output[r][c] = min(count, 9)
    
    return output
