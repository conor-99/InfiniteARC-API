# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 281e3e7c
Difficulty: hard

=== Tags ===
- Image within image

=== Description ===
The input grid contains a rectangular inner image surrounded by a uniform border
of a single color. The border color is consistent across all four edges (top,
bottom, left, right), and the border thickness (number of cells surrounding the
inner image) varies between examples but is uniform across all edges. The output
grid is the inner image, obtained by removing the border from all sides. To
determine the border thickness, the solver identifies the border color from the
edge pixels and calculates how many consecutive border color cells appear from
the start of each edge before the inner image begins. The output grid is then
cropped to the region enclosed by the border.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    while True:
        inner_height = random.randint(1, 20)
        inner_width = random.randint(1, 20)
        inner_grid = [[random.randint(0, 9) for _ in range(inner_width)] for _ in range(inner_height)]
        inner_colors = set()
        for row in inner_grid:
            for color in row:
                inner_colors.add(color)
        if inner_colors != set(range(10)):
            break
    border_color = random.choice([c for c in range(10) if c not in inner_colors])
    t = random.randint(1, 5)
    input_height = inner_height + 2 * t
    input_width = inner_width + 2 * t
    input_grid = [[border_color] * input_width for _ in range(input_height)]
    for i in range(inner_height):
        for j in range(inner_width):
            input_grid[t + i][t + j] = inner_grid[i][j]
    return {"input": input_grid, "output": inner_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid or not input_grid[0]:
        return []
    border_color = input_grid[0][0]
    t = 0
    while t < len(input_grid) and all(cell == border_color for cell in input_grid[t]):
        t += 1
    output_grid = []
    for i in range(t, len(input_grid) - t):
        output_grid.append(input_grid[i][t:len(input_grid[0]) - t])
    return output_grid
