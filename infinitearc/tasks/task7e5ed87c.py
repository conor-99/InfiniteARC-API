# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 7e5ed87c
Difficulty: hard

=== Tags ===
- Example condition induction
- Rule gate simulation

=== Description ===
Input grids are 15×15 to 30×30 in size, featuring a single background color (0).
A continuous path of a distinct color (e.g., 5) originates at the left edge of
the grid, moving strictly rightward. Scattered throughout the grid are isolated
gate cells (colors 1–4), each representing a unique rule. Gates are positioned
such that the path intersects them sequentially. Each gate cell is surrounded by
background color and not part of the path.  The output grid transforms the
path's trajectory and color based on the gates encountered. For each gate cell
the path intersects: - The direction of the path changes by 90 degrees, with the
rotation direction (clockwise or counterclockwise) determined by the gate's
color. - The path's color updates to a new color specific to the gate's color.
The path continues moving in the new direction until it exits the grid. The
output grid renders the entire path with updated directions and colors, while
all gate cells remain unchanged. The transformation rules are consistent across
all gate colors: each color corresponds to a fixed rotation direction and color
transition, which must be inferred from the input–output examples.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import *

def generate():
    """
    Generate a grid with a single segmented path that starts on the left edge and moves
    initially to the right. The path intersects a sequence of single-cell gates (colors 1..4).
    Each gate causes a 90-degree rotation (clockwise or counterclockwise) and changes the
    path color for subsequent segments. The path continues until it leaves the grid.

    Returns:
      A dict with keys 'input' and 'output' containing the two grids (lists of lists).
    """
    # Fixed rule mapping
    rotation_direction = {1: 'clockwise', 2: 'counterclockwise', 3: 'clockwise', 4: 'counterclockwise'}
    color_map = {1: 6, 2: 7, 3: 8, 4: 9}
    initial_path_color = 5

    # Try generating until a valid non-self-intersecting path with the requested gates.
    for attempt in range(300):
        width = random.randint(15, 30)
        height = random.randint(15, 30)

        # Start on left edge, avoid top/bottom border so turns have room
        start_row = random.randint(1, height - 2)
        r, c = start_row, 0
        dr, dc = 0, 1  # start moving right

        # Choose number of gates
        num_gates = random.randint(2, 4)

        path = [(r, c)]
        used = set(path)
        gates = []

        ok = True

        # Place each gate sequentially along the current direction
        for gi in range(num_gates):
            placed = False
            # Try several candidate step lengths to place the next gate
            for _ in range(80):
                steps = random.randint(2, 6)
                nr, nc = r, c
                valid = True
                for _s in range(steps):
                    nr += dr
                    nc += dc
                    # Never allow visiting column 0 again (only the starting cell is allowed at col 0)
                    if not (0 <= nr < height and 0 <= nc < width) or ((nr, nc) in used) or (nc == 0 and (nr, nc) != path[0]):
                        valid = False
                        break
                if not valid:
                    continue
                # Append intervening cells into path
                nr2, nc2 = r, c
                for _s in range(steps):
                    nr2 += dr
                    nc2 += dc
                    path.append((nr2, nc2))
                    used.add((nr2, nc2))
                gate_color = random.randint(1, 4)
                gates.append((nr2, nc2, gate_color))

                # Update direction according to gate
                if rotation_direction[gate_color] == 'clockwise':
                    dr, dc = dc, -dr
                else:
                    dr, dc = -dc, dr

                # Move current position to gate cell
                r, c = nr2, nc2
                placed = True
                break

            if not placed:
                ok = False
                break

        if not ok:
            continue

        # After final gate, extend the path until it exits the grid
        while True:
            nr = r + dr
            nc = c + dc
            if not (0 <= nr < height and 0 <= nc < width):
                break
            if (nr, nc) in used or (nc == 0 and (nr, nc) != path[0]):
                ok = False
                break
            path.append((nr, nc))
            used.add((nr, nc))
            r, c = nr, nc

        if not ok:
            continue

        # Build the input grid: path pixels are initial_path_color except gate cells
        input_grid = [[0 for _ in range(width)] for __ in range(height)]
        gate_positions = {(gr, gc): gcol for (gr, gc, gcol) in gates}
        for (pr, pc) in path:
            if (pr, pc) in gate_positions:
                input_grid[pr][pc] = gate_positions[(pr, pc)]
            else:
                input_grid[pr][pc] = initial_path_color

        # Build the output grid by simulating the path and applying the gates' rules
        output_grid = [[0 for _ in range(width)] for __ in range(height)]
        current_color = initial_path_color
        for (pr, pc) in path:
            if (pr, pc) in gate_positions:
                gcol = gate_positions[(pr, pc)]
                output_grid[pr][pc] = gcol  # gates remain unchanged
                current_color = color_map[gcol]
            else:
                output_grid[pr][pc] = current_color

        # Ensure input != output (should be true given the color changes) and return
        if input_grid != output_grid:
            return {'input': input_grid, 'output': output_grid}

    # If we reach here, generation failed (very unlikely)
    raise RuntimeError('Failed to generate a valid puzzle after many attempts')



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import *

def p(input_grid):
    # Convert immutable input (tuple of tuples) to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # The generator uses these fixed rules; the solver uses the same mapping
    rotation_direction = {1: 'clockwise', 2: 'counterclockwise', 3: 'clockwise', 4: 'counterclockwise'}
    color_map = {1: 6, 2: 7, 3: 8, 4: 9}
    initial_path_color = 5

    # Find the start on the left edge (the path begins at column 0)
    start_row = None
    for r in range(height):
        if grid[r][0] == initial_path_color:
            start_row = r
            break
    # Fallback: if the exact color isn't at col 0 (shouldn't happen), look for any non-background
    if start_row is None:
        for r in range(height):
            if grid[r][0] != 0:
                start_row = r
                break
    if start_row is None:
        return grid  # nothing to do

    # Simulate the path following the same rules as the generator
    output = [[0 for _ in range(width)] for __ in range(height)]

    r, c = start_row, 0
    dr, dc = 0, 1
    current_color = initial_path_color

    # Walk until we exit the grid
    while 0 <= r < height and 0 <= c < width:
        val = grid[r][c]
        if val in (1, 2, 3, 4):
            # Gate: remain the gate color and update state
            output[r][c] = val
            current_color = color_map[val]
            if rotation_direction[val] == 'clockwise':
                dr, dc = dc, -dr
            else:
                dr, dc = -dc, dr
        else:
            # Regular path cell: draw with the current path color
            output[r][c] = current_color

        # Step forward
        r += dr
        c += dc

    return output

