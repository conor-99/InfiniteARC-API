# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 76339a15
Difficulty: insane

=== Tags ===
- Example condition induction
- Rule composition

=== Description ===
**Task Title**: Recursive Symmetry Cascade with Conditional Merging
**Description**: Input grids feature a central motif (a contiguous block of non-
background color) surrounded by two concentric rings of markers. The inner ring
(immediately adjacent to the motif) is divided into four quadrants (top, right,
bottom, left), each containing a sequence of markers of a single color (B, C, D,
E). The outer ring (encircling the inner ring) also has four quadrants, each
containing a single marker of a distinct color (F, G, H, I). All marker colors
differ from the background (0) and the central motif color.  Each inner ring
quadrant color encodes a transformation rule: - **Top (B)**: Rotate the motif
90° clockwise. - **Right (C)**: Reflect the motif vertically. - **Bottom (D)**:
Rotate the motif 90° counterclockwise. - **Left (E)**: Reflect the motif
horizontally.  Each outer ring quadrant color defines a condition for applying
the corresponding transformation: - **Top (F)**: Apply rotation only if the
motif’s height exceeds its width. - **Right (G)**: Apply reflection only if the
motif’s width exceeds its height. - **Bottom (H)**: Apply rotation only if the
motif has vertical symmetry. - **Left (I)**: Apply reflection only if the motif
has horizontal symmetry.  Transformations are applied sequentially in the order
top → right → bottom → left, but only if their condition is satisfied. After all
transformations, the motif is redrawn at the center. If the transformed motif’s
bounding box overlaps with another region of the same color (after
transformation), merge the overlapping regions into a single contiguous region.
The merged region adopts the color of the top-leftmost cell of the combined area
(prioritizing the original motif’s position).  The output grid is identical to
the input except for the transformed central motif and any merged regions. All
markers remain unchanged and are not overwritten. The background (0) remains
fully visible between all regions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    size = random.randint(15, 25)
    if size % 2 == 0:
        size += 1
    inp = grid(size, size, 0)
    
    h = random.randint(3, 5)
    w = random.randint(2, h-1)
    
    # Create non-symmetric motif with random missing cell
    motif = [[9] * w for _ in range(h)]
    # Randomly remove one cell (not critical for connectivity)
    r_remove = random.randint(0, h-1)
    c_remove = random.randint(0, w-1)
    if r_remove == 0 and c_remove == 0:
        r_remove = 1
        c_remove = random.choice([0, 1])
    motif[r_remove][c_remove] = 0

    # Calculate center position
    center = size // 2
    start_r = center - h // 2
    start_c = center - w // 2

    # Place motif
    for r in range(h):
        for c in range(w):
            if motif[r][c] == 9:
                inp[start_r + r][start_c + c] = 9

    # Inner ring (B,C,D,E)
    for c in range(start_c, start_c + w):
        inp[start_r - 1][c] = 1
    for r in range(start_r, start_r + h):
        inp[r][start_c + w] = 2
    for c in range(start_c, start_c + w):
        inp[start_r + h][c] = 3
    for r in range(start_r, start_r + h):
        inp[r][start_c - 1] = 4

    # Outer ring (F,G,H,I)
    inp[start_r - 2][center] = 5
    inp[center][start_c + w + 1] = 6
    inp[start_r + h + 1][center] = 7
    inp[center][start_c - 2] = 8

    # Compute output (apply rotation if h > w)
    out = [row[:] for row in inp]
    if h > w:
        new_motif = [[0] * h for _ in range(w)]
        for r in range(h):
            for c in range(w):
                new_motif[c][h-1-r] = motif[r][c]
        
        # Clear original motif
        for r in range(h):
            for c in range(w):
                if motif[r][c] == 9:
                    out[start_r + r][start_c + c] = 0
        
        # Place transformed motif
        for r in range(w):
            for c in range(h):
                if new_motif[r][c] == 9:
                    out[start_r + r][start_c + c] = 9

    return {'input': inp, 'output': out}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    size = len(grid)
    
    # Find contiguous region of color 9 (motif)
    positions = []
    for r in range(size):
        for c in range(size):
            if grid[r][c] == 9:
                positions.append((r, c))
    
    if not positions:
        return grid
    
    # Calculate bounding box
    min_r = min(r for r, c in positions)
    max_r = max(r for r, c in positions)
    min_c = min(c for r, c in positions)
    max_c = max(c for r, c in positions)
    h = max_r - min_r + 1
    w = max_c - min_c + 1
    
    # Extract motif from grid
    motif = []
    for r in range(min_r, max_r + 1):
        row = []
        for c in range(min_c, max_c + 1):
            row.append(grid[r][c])
        motif.append(row)

    # Apply transformations
    if h > w:
        new_motif = [[0] * h for _ in range(w)]
        for r in range(h):
            for c in range(w):
                new_motif[c][h-1-r] = motif[r][c]
        
        # Clear original motif
        for r in range(h):
            for c in range(w):
                if motif[r][c] == 9:
                    grid[min_r + r][min_c + c] = 0
        
        # Place transformed motif
        for r in range(w):
            for c in range(h):
                if new_motif[r][c] == 9:
                    grid[min_r + r][min_c + c] = 9

    return grid
