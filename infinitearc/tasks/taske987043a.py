# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: e987043a
Difficulty: hard

=== Tags ===
- Color by distance to edge
- Inverse rule reconstruction

=== Description ===
Input grids are square or rectangular (dimensions between 5×5 and 30×30) with a
single background color. Each cell's color is determined by its minimum
Euclidean distance to the nearest grid edge (top, bottom, left, or right), where
distance is the minimum number of steps to reach any edge. For example, border
cells have distance 0, the next layer inward has distance 1, and so on. The
color assigned to each distance value follows a fixed but non-obvious mapping
across all grids (e.g., distance 0 might map to color 7, distance 1 to color 3,
distance 2 to color 9). This mapping is consistent but not sequential, requiring
the solver to infer the rule from input-output pairs.  The output grid inverts
this rule: for each cell, compute its distance d, then determine the new
distance d' = max_distance - d (where max_distance is the largest distance value
in the grid, corresponding to the center region). The output color for each cell
is the color assigned to d' in the same mapping used for the input. This
reverses the spatial pattern—cells that were closest to the edge in the input
become farthest from the edge in the output, and vice versa—while preserving the
same color-distance relationship. The transformation requires recognizing the
distance-based color rule in the input, inferring the exact color mapping, and
applying the inverse distance transformation to generate the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
def generate(mapping=[random.randint(0,9) for _ in range(15)]):
    H = random.randint(3, 30)
    W = random.randint(3, 30)
    max_d = (min(H, W) - 1) // 2
    input_grid = [[0] * W for _ in range(H)]
    output_grid = [[0] * W for _ in range(H)]
    for r in range(H):
        for c in range(W):
            d = min(r, H-1-r, c, W-1-c)
            input_grid[r][c] = mapping[d]
            d_prime = max_d - d
            output_grid[r][c] = mapping[d_prime]
    if input_grid == output_grid:
        return generate(mapping)
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    H = len(input_grid)
    W = len(input_grid[0])
    max_d = (min(H, W) - 1) // 2
    mapping = {}
    for d in range(max_d + 1):
        for r in range(H):
            for c in range(W):
                if min(r, H-1-r, c, W-1-c) == d:
                    mapping[d] = input_grid[r][c]
                    break
            else:
                continue
            break
    output_grid = [[0] * W for _ in range(H)]
    for r in range(H):
        for c in range(W):
            d = min(r, H-1-r, c, W-1-c)
            d_prime = max_d - d
            output_grid[r][c] = mapping[d_prime]
    return output_grid
