# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 91178a36
Difficulty: medium–hard

=== Tags ===
- Emergent behavior
- Role dependent behavior
- Zigzag path

=== Description ===
Input grids feature a background of a single color (e.g., 0) with a sequence of
colored markers (values 1-9) arranged in a straight line. Each marker's color
corresponds to a fixed movement direction (e.g., color 1 → right, color 2 →
down, color 3 → left, color 4 → up), with directions alternating between
horizontal and vertical across consecutive markers. The output grid displays a
continuous zigzag path formed by connecting the markers' positions, where each
segment follows the direction of its originating marker. The path turns at each
marker interaction point, creating a consistent zigzag pattern that alternates
between horizontal and vertical segments. The background and markers remain
unchanged, while the path is drawn using the color of the originating marker.
Non-role cells and the background are preserved, with the path extending between
markers without overlapping. The transformation requires identifying the role-
dependent direction mapping, tracing the path through interactions, and
generating the emergent zigzag structure through sequential directional
application.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Grid size: keep some minimum room so zigzag fits
    width = random.randint(6, 30)
    height = random.randint(6, 30)

    # Number of markers (at least 3 to make a zigzag)
    max_markers = min(width, height, 8)
    n = random.randint(3, max_markers)

    # We'll place markers on a straight diagonal line with dr = 1 and dc = ±1
    dr = 1
    dc = random.choice([1, -1])

    # Choose a start row so all markers fit vertically
    r0_min, r0_max = 0, height - (n * dr)
    r0 = random.randint(r0_min, r0_max)

    # Choose start col depending on dc so markers fit horizontally
    if dc == 1:
        c0_min, c0_max = 0, width - n
    else:
        c0_min, c0_max = n - 1, width - 1
    c0 = random.randint(c0_min, c0_max)

    # Build marker positions along the straight line
    markers_pos = [(r0 + i * dr, c0 + i * dc) for i in range(n)]

    # Alternate orientations between horizontal and vertical
    start_horizontal = random.choice([True, False])
    orientations = []
    for i in range(n):
        is_h = (i % 2 == 0) == start_horizontal
        orientations.append('h' if is_h else 'v')

    # Assign colors: horizontal markers use {1,3}, vertical use {2,4}
    colors = []
    for orient in orientations:
        if orient == 'h':
            colors.append(random.choice([1, 3]))
        else:
            colors.append(random.choice([2, 4]))

    # Create input grid and place markers
    input_grid = [[0 for _ in range(width)] for _ in range(height)]
    for (r, c), col in zip(markers_pos, colors):
        input_grid[r][c] = col

    # Helper for inclusive ranges
    def inclusive_range(a, b):
        if a <= b:
            return range(a, b + 1)
        else:
            return range(a, b - 1, -1)

    # Create output grid starting as a copy of input
    output_grid = [row[:] for row in input_grid]

    # Draw zigzag segments for each adjacent marker pair
    for i in range(n - 1):
        rA, cA = markers_pos[i]
        rB, cB = markers_pos[i + 1]
        colA = colors[i]
        colB = colors[i + 1]
        orientA = orientations[i]
        orientB = orientations[i + 1]

        if orientA == 'h' and orientB == 'v':
            # Horizontal from A to column of B, then vertical from B to row of A
            step_c = 1 if cB > cA else -1
            for c in inclusive_range(cA + step_c, cB):
                # don't overwrite markers
                if output_grid[rA][c] == 0:
                    output_grid[rA][c] = colA
            step_r = 1 if rA > rB else -1
            for r in inclusive_range(rB + step_r, rA):
                if output_grid[r][cB] == 0:
                    output_grid[r][cB] = colB
            # also color the intersection cell (rA, cB) with the vertical segment color
            if output_grid[rA][cB] == 0:
                output_grid[rA][cB] = colB
        elif orientA == 'v' and orientB == 'h':
            # Vertical from A to row of B, then horizontal from B to column of A
            step_r = 1 if rB > rA else -1
            for r in inclusive_range(rA + step_r, rB):
                if output_grid[r][cA] == 0:
                    output_grid[r][cA] = colA
            step_c = 1 if cA > cB else -1
            for c in inclusive_range(cB + step_c, cA):
                if output_grid[rB][c] == 0:
                    output_grid[rB][c] = colB
            # color the intersection (rB, cA) if empty
            if output_grid[rB][cA] == 0:
                output_grid[rB][cA] = colB
        else:
            # This should not happen because orientations alternate, but handle gracefully
            # Connect directly in manhattan path if both same orientation
            # Draw a simple L-shaped connection: horizontal then vertical
            step_c = 1 if cB > cA else -1
            for c in inclusive_range(cA + step_c, cB):
                if output_grid[rA][c] == 0:
                    output_grid[rA][c] = colA
            step_r = 1 if rB > rA else -1
            for r in inclusive_range(rA + step_r, rB):
                if output_grid[r][cB] == 0:
                    output_grid[r][cB] = colA

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert tuple-of-tuples to mutable list of lists if needed
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # Find markers (non-zero cells)
    markers = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                markers.append((r, c, grid[r][c]))

    if not markers:
        return grid

    # Sort markers along the line: rows increase monotonically in generator
    markers.sort(key=lambda x: (x[0], x[1]))

    # Determine orientations from colors: 1/3 -> horizontal, 2/4 -> vertical
    orientations = []
    colors = []
    positions = []
    for r, c, col in markers:
        positions.append((r, c))
        colors.append(col)
        if col in (1, 3):
            orientations.append('h')
        else:
            orientations.append('v')

    # Helper for inclusive ranges
    def inclusive_range(a, b):
        if a <= b:
            return range(a, b + 1)
        else:
            return range(a, b - 1, -1)

    # Start output grid as a copy of input
    output = [row[:] for row in grid]

    n = len(positions)
    for i in range(n - 1):
        rA, cA = positions[i]
        rB, cB = positions[i + 1]
        colA = colors[i]
        colB = colors[i + 1]
        orientA = orientations[i]
        orientB = orientations[i + 1]

        if orientA == 'h' and orientB == 'v':
            step_c = 1 if cB > cA else -1
            for c in inclusive_range(cA + step_c, cB):
                if output[rA][c] == 0:
                    output[rA][c] = colA
            step_r = 1 if rA > rB else -1
            for r in inclusive_range(rB + step_r, rA):
                if output[r][cB] == 0:
                    output[r][cB] = colB
            if output[rA][cB] == 0:
                output[rA][cB] = colB
        elif orientA == 'v' and orientB == 'h':
            step_r = 1 if rB > rA else -1
            for r in inclusive_range(rA + step_r, rB):
                if output[r][cA] == 0:
                    output[r][cA] = colA
            step_c = 1 if cA > cB else -1
            for c in inclusive_range(cB + step_c, cA):
                if output[rB][c] == 0:
                    output[rB][c] = colB
            if output[rB][cA] == 0:
                output[rB][cA] = colB
        else:
            # Fallback: simple L-shaped connection
            step_c = 1 if cB > cA else -1
            for c in inclusive_range(cA + step_c, cB):
                if output[rA][c] == 0:
                    output[rA][c] = colA
            step_r = 1 if rB > rA else -1
            for r in inclusive_range(rA + step_r, rB):
                if output[r][cB] == 0:
                    output[r][cB] = colA

    return output

