# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 3fb0d1e1
Difficulty: medium

=== Tags ===
- Cylindrical
- Normalize orientation

=== Description ===
The task involves grids that represent patterns on a cylindrical surface, where
the leftmost and rightmost columns are connected. The input grid contains visual
patterns (e.g., lines, shapes) that wrap around this cylindrical boundary,
causing features to appear discontinuous when viewed on a standard rectangular
grid. The transformation to the output grid "unrolls" the cylindrical pattern
into a continuous, non-wrapped arrangement. This is achieved by horizontally
shifting the entire grid such that the wrapped pattern aligns seamlessly from
left to right without edge connection. The shift amount is determined by the
position where the pattern crosses the right edge: the grid is shifted left by
the number of columns from the right edge to the start of the pattern, ensuring
the pattern appears as a single contiguous segment. The output grid maintains
the same dimensions as the input, with all elements shifted consistently to
eliminate the cylindrical wrap while preserving the visual structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(3, 30)
    height = random.randint(1, 30)
    c = random.randint(1, 9)
    r = random.randint(0, height - 1)
    L = random.randint(1, width - 2)
    k = random.randint(1, L)  # Corrected: k <= L
    
    output = grid(width, height, 0)
    for col in range(L + 1):
        output[r][col] = c
    
    input_grid = grid(width, height, 0)
    for i in range(height):
        for j in range(width):
            input_grid[i][j] = output[i][(j + k) % width]
    
    return {
        'input': input_grid,
        'output': output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid
def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    for r in range(height):
        if input_grid[r][0] == input_grid[r][width - 1]:
            c = input_grid[r][0]
            if c == 0:
                continue
            i = width - 1
            while i >= 0 and input_grid[r][i] == c:
                i -= 1
            shift = (i + 1) % width
            output = grid(width, height, 0)
            for i in range(height):
                for j in range(width):
                    output[i][j] = input_grid[i][(j + shift) % width]
            return output
    return input_grid
