# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: d3d2b6cd
Difficulty: mediumâ€“hard

=== Tags ===
- Signal to structure
- Feature binding
- Beam reflection
- State machine grid

=== Description ===
Input grids consist of a 2D grid with a background color (0) and multiple
colored cells (1-8) representing reflectors. Each reflector color encodes a
unique reflection behavior (e.g., color 1 might reflect beams 90 degrees
clockwise, color 2 counterclockwise). A single beam source is present as a
contiguous line of color 9 along one grid boundary, initiating a beam that
travels inward. The output grid reproduces all input elements but adds the
beam's full path (using color 9) as it traverses the grid, reflecting off each
reflector according to its color-specific rule. The path is drawn over the
background without altering reflectors or the source, continuing until the beam
exits the grid. Reflection rules must be inferred from input-output examples,
requiring the solver to bind each color to its corresponding reflection behavior
through pattern recognition.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid
def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = grid(width, height, 0)
    
    start_row = random.randint(1, height - 2)
    end_row = random.randint(start_row + 1, height - 1)
    for r in range(start_row, end_row + 1):
        input_grid[r][0] = 9
    
    for _ in range(random.randint(1, 5)):
        r = random.randint(0, height - 1)
        c = random.randint(1, width - 1)
        input_grid[r][c] = random.randint(1, 8)
    
    direction = 0
    current = (start_row, 0)
    path_cells = set()
    path_cells.add(current)
    
    while True:
        dr, dc = [(0, 1), (1, 0), (0, -1), (-1, 0)][direction]
        nr, nc = current[0] + dr, current[1] + dc
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        val = input_grid[nr][nc]
        if val == 0:
            path_cells.add((nr, nc))
            current = (nr, nc)
        else:
            color = val
            mod = color % 4
            if mod == 1:
                direction = (direction + 1) % 4
            elif mod == 2:
                direction = (direction + 3) % 4
            else:
                direction = (direction + 2) % 4
            current = (nr, nc)
    
    output_grid = [row[:] for row in input_grid]
    for r, c in path_cells:
        if input_grid[r][c] == 0:
            output_grid[r][c] = 9
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    
    source_edges = []
    for r in range(height):
        if input_grid[r][0] == 9:
            source_edges.append((r, 0))
        if input_grid[r][width-1] == 9:
            source_edges.append((r, width-1))
    for c in range(width):
        if input_grid[0][c] == 9:
            source_edges.append((0, c))
        if input_grid[height-1][c] == 9:
            source_edges.append((height-1, c))
    
    if not source_edges:
        return input_grid
    
    r, c = source_edges[0]
    if c == 0:
        direction = 0
    elif c == width - 1:
        direction = 2
    elif r == 0:
        direction = 1
    else:
        direction = 3
    
    current = (r, c)
    path_cells = set()
    path_cells.add(current)
    
    while True:
        dr, dc = [(0, 1), (1, 0), (0, -1), (-1, 0)][direction]
        nr, nc = current[0] + dr, current[1] + dc
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        val = input_grid[nr][nc]
        if val == 0:
            path_cells.add((nr, nc))
            current = (nr, nc)
        else:
            color = val
            mod = color % 4
            if mod == 1:
                direction = (direction + 1) % 4
            elif mod == 2:
                direction = (direction + 3) % 4
            else:
                direction = (direction + 2) % 4
            current = (nr, nc)
    
    output_grid = [list(row) for row in input_grid]
    for r, c in path_cells:
        if input_grid[r][c] == 0:
            output_grid[r][c] = 9
    return output_grid
