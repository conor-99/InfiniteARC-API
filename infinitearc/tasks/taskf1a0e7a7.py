# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: f1a0e7a7
Difficulty: insane

=== Tags ===
- Rectangle guessing
- Direction guessing

=== Description ===
The task involves transforming an input grid into an output grid by moving a
single axis-aligned rectangle based on the relative position of a direction
marker. The input grid contains exactly one rectangleâ€”a solid, contiguous block
of a single color (not touching the grid edges) and one direction marker (a
single pixel of a different color). The rectangle is identified as the largest
contiguous block of its color that forms a rectangle (i.e., aligned with the
grid axes and without holes). The direction marker's position relative to the
rectangle's bounding box determines the movement direction: if the marker is
above the rectangle, the rectangle is moved up; below, it is moved down; to the
left, it is moved left; to the right, it is moved right. The movement shifts the
rectangle by one cell in the determined direction, ensuring the new position
remains within grid bounds and does not overlap with other elements. The
transformation requires recognizing the rectangle and marker amidst potential
distractions, making the task "insane" due to the need for precise spatial
reasoning and abstraction over grid structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid
def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    A = random.randint(1, 9)
    w = random.randint(2, min(width, height) // 2)
    h = random.randint(2, min(width, height) // 2)
    r = random.randint(1, height - h - 1)
    c = random.randint(1, width - w - 1)
    direction = random.choice(['up', 'down', 'left', 'right'])
    if direction == 'up':
        mr = r - 1
        mc = random.randint(c, c + w - 1)
    elif direction == 'down':
        mr = r + h
        mc = random.randint(c, c + w - 1)
    elif direction == 'left':
        mr = random.randint(r, r + h - 1)
        mc = c - 1
    else:  # 'right'
        mr = random.randint(r, r + h - 1)
        mc = c + w
    B = A
    while B == A or B == 0:
        B = random.randint(1, 9)
    input_grid = grid(width, height, 0)
    for i in range(r, r + h):
        for j in range(c, c + w):
            input_grid[i][j] = A
    input_grid[mr][mc] = B
    output_grid = [row[:] for row in input_grid]
    for i in range(r, r + h):
        for j in range(c, c + w):
            output_grid[i][j] = 0
    if direction == 'up':
        new_r, new_c = r - 1, c
    elif direction == 'down':
        new_r, new_c = r + 1, c
    elif direction == 'left':
        new_r, new_c = r, c - 1
    else:
        new_r, new_c = r, c + 1
    for i in range(new_r, new_r + h):
        for j in range(new_c, new_c + w):
            output_grid[i][j] = A
    output_grid[mr][mc] = 0
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    def is_rectangular(component, grid):
        if not component:
            return False
        min_r = min(r for r, c in component)
        max_r = max(r for r, c in component)
        min_c = min(c for r, c in component)
        max_c = max(c for r, c in component)
        for r in range(min_r, max_r + 1):
            for c in range(min_c, max_c + 1):
                if (r, c) not in component:
                    return False
        return True
    
    colors = set()
    for row in input_grid:
        for cell in row:
            if cell != 0:
                colors.add(cell)
    rect_color = None
    largest_area = 0
    rect_bounding_box = None
    for color in colors:
        if color == 0:
            continue
        visited = [[False] * len(input_grid[0]) for _ in range(len(input_grid))]
        for i in range(len(input_grid)):
            for j in range(len(input_grid[0])):
                if not visited[i][j] and input_grid[i][j] == color:
                    component = []
                    queue = [(i, j)]
                    visited[i][j] = True
                    while queue:
                        r, c = queue.pop(0)
                        component.append((r, c))
                        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                            nr, nc = r + dr, c + dc
                            if 0 <= nr < len(input_grid) and 0 <= nc < len(input_grid[0]) and not visited[nr][nc] and input_grid[nr][nc] == color:
                                visited[nr][nc] = True
                                queue.append((nr, nc))
                    if is_rectangular(component, input_grid):
                        area = len(component)
                        if area > largest_area:
                            largest_area = area
                            rect_color = color
                            min_r = min(r for r, c in component)
                            max_r = max(r for r, c in component)
                            min_c = min(c for r, c in component)
                            max_c = max(c for r, c in component)
                            rect_bounding_box = (min_r, max_r, min_c, max_c)
    if rect_color is None:
        rect_color = 1
        rect_bounding_box = (0, 0, 0, 0)
    min_r, max_r, min_c, max_c = rect_bounding_box
    marker_pos = None
    for i in range(len(input_grid)):
        for j in range(len(input_grid[0])):
            if input_grid[i][j] != 0 and input_grid[i][j] != rect_color:
                if marker_pos is None:
                    marker_pos = (i, j)
                else:
                    pass
    if marker_pos is None:
        marker_pos = (0, 0)
    mr, mc = marker_pos
    if mr < min_r:
        direction = 'up'
    elif mr > max_r:
        direction = 'down'
    elif mc < min_c:
        direction = 'left'
    else:
        direction = 'right'
    if direction == 'up':
        new_r, new_c = min_r - 1, min_c
    elif direction == 'down':
        new_r, new_c = min_r + 1, min_c
    elif direction == 'left':
        new_r, new_c = min_r, min_c - 1
    else:
        new_r, new_c = min_r, min_c + 1
    output_grid = [list(row) for row in input_grid]
    for i in range(min_r, max_r + 1):
        for j in range(min_c, max_c + 1):
            output_grid[i][j] = 0
    for i in range(new_r, new_r + (max_r - min_r + 1)):
        for j in range(new_c, new_c + (max_c - min_c + 1)):
            output_grid[i][j] = rect_color
    output_grid[mr][mc] = 0
    return output_grid
