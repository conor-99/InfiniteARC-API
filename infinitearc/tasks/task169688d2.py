# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 169688d2
Difficulty: mediumâ€“hard

=== Tags ===
- Stateful propagation
- Shape to color encoding
- Swap positions of two objects

=== Description ===
Input grids feature a background color (0) with exactly two distinct, non-
overlapping shapes: a square (defined as a contiguous region with four straight
edges forming a right-angled polygon) and a circle (defined as a contiguous
region approximating a circular form with rounded edges). Each shape is encoded
to a specific color: squares always use color 2 (red), circles always use color
3 (blue). The shapes are placed at separate positions within the grid, fully
surrounded by background.  The output grid swaps the positions of the square and
circle shapes while maintaining their respective colors. The square (color 2)
moves to the circle's original position, and the circle (color 3) moves to the
square's original position. All other grid cells, including background and any
other features, remain unchanged. The transformation is deterministic and
requires recognizing the shape-based color encoding to identify which objects to
swap.  This task is medium-hard as it demands visual differentiation of shape
types (square vs. circle) based on their geometric properties, understanding the
fixed color encoding per shape, and executing the positional swap without
altering the color values.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = [[0]*width for _ in range(height)]
    
    # Place square
    r_s = random.randint(0, height - 3)
    c_s = random.randint(0, width - 3)
    for r in range(r_s, r_s + 3):
        for c in range(c_s, c_s + 3):
            input_grid[r][c] = 2
    
    # Place circle
    r_c = max(0, r_s + 3)
    c_c = max(0, c_s + 3)
    if r_c + 2 >= height:
        r_c = height - 3
    if c_c + 2 >= width:
        c_c = width - 3
    
    for r in range(r_c, r_c + 3):
        for c in range(c_c, c_c + 3):
            dr = r - r_c
            dc = c - c_c
            if dr == 1 or (dc == 1 and dr != 1):
                input_grid[r][c] = 3
    
    # Create output by swapping 2 and 3
    output_grid = [[3 if cell == 2 else 2 if cell == 3 else 0 for cell in row] for row in input_grid]
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    
    output_grid = []
    for row in input_grid:
        new_row = []
        for cell in row:
            if cell == 2:
                new_row.append(3)
            elif cell == 3:
                new_row.append(2)
            else:
                new_row.append(cell)
        output_grid.append(new_row)
    return output_grid
