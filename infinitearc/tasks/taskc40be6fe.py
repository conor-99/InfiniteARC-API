# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: c40be6fe
Difficulty: very hard

=== Tags ===
- Mask based logic

=== Description ===
Masked Pattern Synthesis  Input grids feature a uniform background color (0)
overlaid with multiple distinct foreground color regions (1–9) and a closed-loop
mask formed exclusively by a single consistent color (e.g., 5). The mask appears
as a contiguous, non-rectangular boundary with no self-intersections, enclosing
a region that varies in shape but maintains a minimum width of 2 cells. The mask
boundary itself is always visible and unaltered in the output, but its interior
represents the active transformation zone.  The output grid is generated through
two interdependent transformations applied simultaneously: 1. **Interior
Transformation**: For every cell within the mask's enclosed interior, calculate
its orthogonal distance from the nearest mask boundary cell (distance 1 =
adjacent to boundary, distance 2 = next inward layer, etc.). Assign colors to
these cells using a cyclic pattern: distance 1 → color 1, distance 2 → color 2,
..., distance 9 → color 9, distance 10 → color 1 (repeating). This creates
concentric color rings radiating inward from the mask boundary. 2. **Exterior
Transformation**: All cells outside the mask boundary undergo a cyclic color
shift: each foreground color `c` (1–9) is replaced with `(c % 9) + 1` (e.g.,
1→2, 2→3, ..., 9→1), while background color (0) remains unchanged. Foreground
regions outside the mask retain their relative positions and shapes but have
colors shifted according to this rule.  The mask boundary (color 5) persists
unchanged in the output, visually separating the transformed interior from the
shifted exterior. The transformation requires precise boundary detection (using
flood-fill techniques to distinguish interior from exterior), accurate distance
mapping within irregularly shaped interiors, and simultaneous application of two
distinct color rules across the grid. No input grid contains identical
foreground patterns or mask configurations, demanding that solvers generalize
the distance-based coloring and cyclic shift rules rather than relying on
memorized patterns. The complexity arises from the need to handle variable mask
geometries while maintaining deterministic application of both transformation
rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
from collections import deque
def generate():
    width = common.randint(3, 30)
    height = common.randint(3, 30)
    mask_rows, mask_cols = common.hollow_conway(width, height)
    input_grid = common.grid(width, height, 0)
    for r, c in zip(mask_rows, mask_cols):
        input_grid[r][c] = 5
    
    visited_ext = [[False] * width for _ in range(height)]
    queue = deque()
    for r in [0, height-1]:
        for c in range(width):
            if input_grid[r][c] != 5 and not visited_ext[r][c]:
                visited_ext[r][c] = True
                queue.append((r, c))
    for c in [0, width-1]:
        for r in range(1, height-1):
            if input_grid[r][c] != 5 and not visited_ext[r][c]:
                visited_ext[r][c] = True
                queue.append((r, c))
    while queue:
        r, c = queue.popleft()
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited_ext[nr][nc] and input_grid[nr][nc] != 5:
                visited_ext[nr][nc] = True
                queue.append((nr, nc))
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 5:
                continue
            if visited_ext[r][c]:
                input_grid[r][c] = common.random_color(exclude=[5])
            else:
                input_grid[r][c] = common.random_color(exclude=[5])
    
    output_grid = [[0]*width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 5:
                output_grid[r][c] = 5
    
    dist = [[-1]*width for _ in range(height)]
    queue_dist = deque()
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 5:
                dist[r][c] = 0
                queue_dist.append((r, c))
    while queue_dist:
        r, c = queue_dist.popleft()
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and dist[nr][nc] == -1:
                dist[nr][nc] = dist[r][c] + 1
                queue_dist.append((nr, nc))
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 5:
                continue
            if visited_ext[r][c]:
                c_val = input_grid[r][c]
                output_grid[r][c] = (c_val % 9) + 1 if c_val != 0 else 0
            else:
                d = dist[r][c]
                output_grid[r][c] = (d - 1) % 9 + 1
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
from collections import deque
def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    
    mask_cells = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 5:
                mask_cells.append((r, c))
    
    dist = [[-1] * width for _ in range(height)]
    queue_dist = deque()
    for r, c in mask_cells:
        dist[r][c] = 0
        queue_dist.append((r, c))
    while queue_dist:
        r, c = queue_dist.popleft()
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and dist[nr][nc] == -1:
                dist[nr][nc] = dist[r][c] + 1
                queue_dist.append((nr, nc))
    
    visited_ext = [[False] * width for _ in range(height)]
    queue_ext = deque()
    for r in [0, height-1]:
        for c in range(width):
            if grid[r][c] != 5 and not visited_ext[r][c]:
                visited_ext[r][c] = True
                queue_ext.append((r, c))
    for c in [0, width-1]:
        for r in range(1, height-1):
            if grid[r][c] != 5 and not visited_ext[r][c]:
                visited_ext[r][c] = True
                queue_ext.append((r, c))
    while queue_ext:
        r, c = queue_ext.popleft()
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited_ext[nr][nc] and grid[nr][nc] != 5:
                visited_ext[nr][nc] = True
                queue_ext.append((nr, nc))
    
    output = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 5:
                output[r][c] = 5
            elif visited_ext[r][c]:
                c_val = grid[r][c]
                output[r][c] = (c_val % 9) + 1 if c_val != 0 else 0
            else:
                d = dist[r][c]
                output[r][c] = (d - 1) % 9 + 1
    return tuple(tuple(row) for row in output)
