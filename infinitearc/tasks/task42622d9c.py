# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 42622d9c
Difficulty: insane

=== Tags ===
- Take complement
- Detect background color

=== Description ===
The task involves transforming a grid by first identifying the background color,
which is the most common color found along the grid's edges (top, bottom, left,
and right borders). For all non-background cells, their color is replaced with 9
minus the original value. Background cells remain unchanged. The transformation
ensures the output grid differs from the input, as non-background cells are
systematically inverted in value. Input grids feature complex arrangements of
multiple distinct colors, with the background color subtly embedded in the
perimeter edges. Solvers must detect the background through edge analysis, then
apply the complement transformation to non-background elements, requiring both
pattern recognition in edge composition and precise numerical inversion. The
difficulty arises from the need to correctly identify the background amid
potential edge color variability, followed by consistent application of the
complement rule across diverse foreground structures.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    w = random.randint(3, 30)
    h = random.randint(3, 30)
    b = random.randint(0, 9)
    input_grid = [[b] * w for _ in range(h)]
    for r in range(1, h - 1):
        for c in range(1, w - 1):
            input_grid[r][c] = random.randint(0, 9)
    if all(input_grid[r][c] == b for r in range(1, h - 1) for c in range(1, w - 1)):
        input_grid[1][1] = (input_grid[1][1] + 1) % 10
    output_grid = [[b if cell == b else 9 - cell for cell in row] for row in input_grid]
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid or not input_grid[0]:
        return input_grid
    h = len(input_grid)
    w = len(input_grid[0])
    edges = []
    for r in range(h):
        for c in range(w):
            if r == 0 or r == h - 1 or c == 0 or c == w - 1:
                edges.append(input_grid[r][c])
    from collections import Counter
    bg_color = Counter(edges).most_common(1)[0][0]
    output_grid = []
    for r in range(h):
        new_row = []
        for c in range(w):
            if input_grid[r][c] == bg_color:
                new_row.append(bg_color)
            else:
                new_row.append(9 - input_grid[r][c])
        output_grid.append(new_row)
    return output_grid
