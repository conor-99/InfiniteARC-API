# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 1d9330c8
Difficulty: mediumâ€“hard

=== Tags ===
- Procedural painting
- Feature binding
- Impact highlight
- Implicit topology

=== Description ===
The input grid features a background color with scattered red "source" cells and
blue "target" cells, separated by walls of various non-background colors. The
walls form a maze-like structure where background corridors connect distinct
regions. The output grid retains all walls, sources, and targets but draws a
green "impact highlight" line from each red source to its nearest blue target
within the same connected background corridor. The line follows the shortest
path through background corridors (avoiding walls), drawn using a consistent
green color. Each source must have at least one target in its connected region;
sources without reachable targets remain unconnected. The highlight lines are
strictly minimal paths with no overlaps, and all connections respect the
implicit topology of the background corridor network formed by the maze walls.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import collections

def generate():
    # Grid size
    width = random.randint(11, 25)
    height = random.randint(11, 25)

    # Start filled with walls (temporary value 1)
    grid_input = [[1 for _ in range(width)] for _ in range(height)]

    # Neighbor order (consistent): up, left, right, down
    NEI = [(-1, 0), (0, -1), (0, 1), (1, 0)]

    # Decide how many chunks (we want multiple disconnected corridor components)
    chunk_rows = random.randint(2, 4)
    while chunk_rows > 1 and height // chunk_rows < 3:
        chunk_rows -= 1
    chunk_cols = random.randint(2, 4)
    while chunk_cols > 1 and width // chunk_cols < 3:
        chunk_cols -= 1

    chunk_h = max(3, height // chunk_rows)
    chunk_w = max(3, width // chunk_cols)

    chunks = []

    def carve_snake(r0, r1, c0, c1):
        # Carve a randomized meandering path inside the rectangle [r0..r1] x [c0..c1]
        cells = [(r, c) for r in range(r0, r1 + 1) for c in range(c0, c1 + 1)]
        if not cells:
            return
        start = random.choice(cells)
        end = random.choice(cells)
        while end == start:
            end = random.choice(cells)
        cur = start
        grid_input[cur[0]][cur[1]] = 0
        steps = 0
        limit = max( (r1 - r0 + 1) * (c1 - c0 + 1) * 2, 8 )
        while cur != end and steps < limit:
            nbrs = []
            weights = []
            for dr, dc in NEI:
                nr, nc = cur[0] + dr, cur[1] + dc
                if nr < r0 or nr > r1 or nc < c0 or nc > c1:
                    continue
                nbrs.append((nr, nc))
                # Prefer moves that get closer to the end
                d_cur = abs(cur[0] - end[0]) + abs(cur[1] - end[1])
                d_new = abs(nr - end[0]) + abs(nc - end[1])
                weights.append(3 if d_new < d_cur else 1)
            if not nbrs:
                break
            choice = random.choices(nbrs, weights=weights, k=1)[0]
            cur = choice
            grid_input[cur[0]][cur[1]] = 0
            steps += 1
        # If not reached, connect by straight segments
        while cur[0] != end[0]:
            nr = cur[0] + (1 if end[0] > cur[0] else -1)
            cur = (nr, cur[1])
            grid_input[cur[0]][cur[1]] = 0
        while cur[1] != end[1]:
            nc = cur[1] + (1 if end[1] > cur[1] else -1)
            cur = (cur[0], nc)
            grid_input[cur[0]][cur[1]] = 0
        # Add a couple of short random branches
        path_cells = [(r, c) for r in range(r0, r1 + 1) for c in range(c0, c1 + 1) if grid_input[r][c] == 0]
        for _ in range(random.randint(0, 2)):
            if not path_cells:
                break
            seed = random.choice(path_cells)
            bcur = seed
            for _ in range(random.randint(1, 4)):
                nbrs = []
                for dr, dc in NEI:
                    nr, nc = bcur[0] + dr, bcur[1] + dc
                    if nr < r0 or nr > r1 or nc < c0 or nc > c1:
                        continue
                    nbrs.append((nr, nc))
                if not nbrs:
                    break
                bcur = random.choice(nbrs)
                grid_input[bcur[0]][bcur[1]] = 0

    # Carve each chunk separately so corridors are disconnected between chunks
    for i in range(chunk_rows):
        for j in range(chunk_cols):
            r0 = i * chunk_h
            r1 = (i + 1) * chunk_h - 1 if i < chunk_rows - 1 else height - 1
            c0 = j * chunk_w
            c1 = (j + 1) * chunk_w - 1 if j < chunk_cols - 1 else width - 1
            carve_snake(r0, r1, c0, c1)
            chunks.append((r0, r1, c0, c1))

    # Color walls with a variety of non-background colors (avoid 0,2,3,4)
    wall_colors = [1, 5, 6, 7, 8, 9]
    for r in range(height):
        for c in range(width):
            if grid_input[r][c] == 1:
                grid_input[r][c] = random.choice(wall_colors)

    # Place sources (2) and targets (3) in background corridors (cells equal to 0)
    sources = []
    targets = []
    pair_count = 0
    for idx, (r0, r1, c0, c1) in enumerate(chunks):
        bg = [(r, c) for r in range(r0, r1 + 1) for c in range(c0, c1 + 1) if grid_input[r][c] == 0]
        if not bg:
            continue
        mode = random.choices(['pair', 'source_only', 'target_only', 'none'], weights=[0.6, 0.1, 0.1, 0.2], k=1)[0]
        if mode == 'pair' and len(bg) >= 2:
            # pick two positions that are not adjacent (so there is at least one background cell to mark)
            tries = 0
            a = b = None
            while tries < 40:
                a, b = random.sample(bg, 2)
                if abs(a[0] - b[0]) + abs(a[1] - b[1]) >= 2:
                    break
                tries += 1
            if a is None or b is None:
                continue
            grid_input[a[0]][a[1]] = 2
            grid_input[b[0]][b[1]] = 3
            sources.append(a)
            targets.append(b)
            pair_count += 1
        elif mode == 'source_only':
            a = random.choice(bg)
            grid_input[a[0]][a[1]] = 2
            sources.append(a)
        elif mode == 'target_only':
            b = random.choice(bg)
            grid_input[b[0]][b[1]] = 3
            targets.append(b)

    # Ensure at least one source-target pair exists (so output differs from input)
    if pair_count == 0:
        # find a chunk with at least two background cells
        candidate = None
        for (r0, r1, c0, c1) in chunks:
            bg = [(r, c) for r in range(r0, r1 + 1) for c in range(c0, c1 + 1) if grid_input[r][c] == 0]
            if len(bg) >= 2:
                candidate = (r0, r1, c0, c1)
                break
        if candidate is None:
            # force carve into a random chunk to create space
            r0, r1, c0, c1 = random.choice(chunks)
            # carve a small straight corridor
            rr = (r0 + r1) // 2
            cc0 = c0 + 1
            cc1 = min(c1 - 1, cc0 + 2)
            for cc in range(cc0, cc1 + 1):
                grid_input[rr][cc] = 0
            bg = [(r, c) for r in range(r0, r1 + 1) for c in range(c0, c1 + 1) if grid_input[r][c] == 0]
            a, b = bg[0], bg[min(1, len(bg) - 1)]
            grid_input[a[0]][a[1]] = 2
            grid_input[b[0]][b[1]] = 3
            sources.append(a)
            targets.append(b)
        else:
            r0, r1, c0, c1 = candidate
            bg = [(r, c) for r in range(r0, r1 + 1) for c in range(c0, c1 + 1) if grid_input[r][c] == 0]
            a, b = random.sample(bg, 2)
            # ensure not adjacent
            if abs(a[0] - b[0]) + abs(a[1] - b[1]) < 2:
                # carve an intermediate cell
                midr = (a[0] + b[0]) // 2
                midc = (a[1] + b[1]) // 2
                grid_input[midr][midc] = 0
            grid_input[a[0]][a[1]] = 2
            grid_input[b[0]][b[1]] = 3
            sources.append(a)
            targets.append(b)

    # Produce output by drawing green (4) highlights along shortest paths inside passable background
    grid_output = [row[:] for row in grid_input]

    H, W = height, width
    passable = set([0, 2, 3])
    comp_id = [[-1] * W for _ in range(H)]
    visited = [[False] * W for _ in range(H)]
    comp_list = []
    for r in range(H):
        for c in range(W):
            if (r, c) not in comp_list and grid_input[r][c] in passable and not visited[r][c]:
                # flood-fill this component
                comp_idx = len(comp_list)
                comp_cells = []
                dq = collections.deque()
                dq.append((r, c))
                visited[r][c] = True
                while dq:
                    cr, cc = dq.popleft()
                    comp_cells.append((cr, cc))
                    comp_id[cr][cc] = comp_idx
                    for dr, dc in NEI:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc] and grid_input[nr][nc] in passable:
                            visited[nr][nc] = True
                            dq.append((nr, nc))
                comp_list.append(comp_cells)

    # Forbids overlapping highlights from different sources: mark cells that have been used by a highlight
    used = [[False] * W for _ in range(H)]

    # scan for source cells and draw path to nearest target in same component
    for r in range(H):
        for c in range(W):
            if grid_input[r][c] != 2:
                continue
            cid = comp_id[r][c]
            if cid == -1:
                continue
            # collect targets in same component
            tlist = [(tr, tc) for (tr, tc) in comp_list[cid] if grid_input[tr][tc] == 3]
            if not tlist:
                continue
            # BFS from source to nearest target (avoid cells already used by earlier highlights)
            parent = [[None] * W for _ in range(H)]
            dist = [[-1] * W for _ in range(H)]
            dq = collections.deque()
            dq.append((r, c))
            dist[r][c] = 0
            found = None
            while dq and found is None:
                cr, cc = dq.popleft()
                if grid_input[cr][cc] == 3:
                    found = (cr, cc)
                    break
                for dr, dc in NEI:
                    nr, nc = cr + dr, cc + dc
                    if not (0 <= nr < H and 0 <= nc < W):
                        continue
                    if dist[nr][nc] != -1:
                        continue
                    # passable if it is background or a source/target and not a colored wall
                    if grid_input[nr][nc] not in passable:
                        continue
                    # avoid stepping on cells already used by a previous highlight
                    if used[nr][nc]:
                        continue
                    dist[nr][nc] = dist[cr][cc] + 1
                    parent[nr][nc] = (cr, cc)
                    dq.append((nr, nc))
            if found is None:
                continue
            # reconstruct path
            path = []
            cur = found
            while cur is not None:
                path.append(cur)
                if cur == (r, c):
                    break
                cur = parent[cur[0]][cur[1]]
            # paint the path (only background cells become green 4; keep sources/targets and walls)
            for (pr, pc) in path:
                if grid_output[pr][pc] == 0:
                    grid_output[pr][pc] = 4
                    used[pr][pc] = True

    return {"input": grid_input, "output": grid_output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import collections

def p(input_grid):
    # convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0]) if H > 0 else 0

    NEI = [(-1, 0), (0, -1), (0, 1), (1, 0)]
    passable = set([0, 2, 3])

    # find connected components of passable cells
    comp_id = [[-1] * W for _ in range(H)]
    comp_list = []
    visited = [[False] * W for _ in range(H)]
    for r in range(H):
        for c in range(W):
            if grid[r][c] in passable and not visited[r][c]:
                dq = collections.deque()
                dq.append((r, c))
                visited[r][c] = True
                comp_idx = len(comp_list)
                comp_cells = []
                while dq:
                    cr, cc = dq.popleft()
                    comp_cells.append((cr, cc))
                    comp_id[cr][cc] = comp_idx
                    for dr, dc in NEI:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc] and grid[nr][nc] in passable:
                            visited[nr][nc] = True
                            dq.append((nr, nc))
                comp_list.append(comp_cells)

    # used cells to avoid overlapping highlights
    used = [[False] * W for _ in range(H)]

    # For each source, BFS to nearest target within same component and draw green (4) on background cells along path
    for r in range(H):
        for c in range(W):
            if grid[r][c] != 2:
                continue
            cid = comp_id[r][c]
            if cid == -1:
                continue
            targets = [(tr, tc) for (tr, tc) in comp_list[cid] if grid[tr][tc] == 3]
            if not targets:
                continue
            parent = [[None] * W for _ in range(H)]
            dist = [[-1] * W for _ in range(H)]
            dq = collections.deque()
            dq.append((r, c))
            dist[r][c] = 0
            found = None
            while dq and found is None:
                cr, cc = dq.popleft()
                if grid[cr][cc] == 3:
                    found = (cr, cc)
                    break
                for dr, dc in NEI:
                    nr, nc = cr + dr, cc + dc
                    if not (0 <= nr < H and 0 <= nc < W):
                        continue
                    if dist[nr][nc] != -1:
                        continue
                    if grid[nr][nc] not in passable:
                        continue
                    if used[nr][nc]:
                        continue
                    dist[nr][nc] = dist[cr][cc] + 1
                    parent[nr][nc] = (cr, cc)
                    dq.append((nr, nc))
            if found is None:
                continue
            # reconstruct path and paint
            path = []
            cur = found
            while cur is not None:
                path.append(cur)
                if cur == (r, c):
                    break
                cur = parent[cur[0]][cur[1]]
            for (pr, pc) in path:
                if grid[pr][pc] == 0:
                    grid[pr][pc] = 4
                    used[pr][pc] = True

    return tuple(tuple(row) for row in grid)
