# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 709051c4
Difficulty: very hard

=== Tags ===
- Rotational pattern mapping
- Diagonal weaving
- Guided flow
- Periodic reflection
- Fit to bounding box

=== Description ===
**Task Description: Diagonal Weave Reflection**    **Input Grids:**   Input
grids are 2D grids (1×1 to 30×30) with a background color (0). Walls are 1-cell-
thick horizontal or vertical segments of a single wall color (1), arranged to
form enclosed pathways without overlapping. Diagonal "flow" lines (colors 2–5)
originate from the top edge (row 0), traveling at 45° angles (e.g., color 2:
top-left to bottom-right, color 3: top-right to bottom-left). Each flow line is
continuous, moving through background cells until it collides with a wall.
**Transformation Rules:**   1. **Periodic Reflection:** Upon hitting a wall, a
flow line reflects with a *deterministic periodic pattern*:      - **First
reflection:** Reflects *perpendicular* to the wall (horizontal wall → vertical
movement; vertical wall → horizontal movement).      - **Second reflection:**
Reflects *parallel* to the wall.      - **Subsequent reflections:** Alternates
between perpendicular and parallel directions (e.g., 3rd = perpendicular, 4th =
parallel).      This creates a weaving path where lines alternate between
"tight" (perpendicular) and "loose" (parallel) reflections.    2. **Color
Progression:** Each reflection cycles the line’s color through a fixed sequence
(e.g., 2 → 3 → 4 → 5 → 2...), repeating every 4 reflections. The color change
persists for all subsequent steps until the line exits the grid.    3. **Guided
Flow:** Flow lines follow the walls’ structure without overlapping, walls, or
grid boundaries. Lines exit the grid after finite reflections, leaving a traced
path.    4. **Bounding Box Fit:** The output grid is the *minimal bounding box*
enclosing all reflected paths. Background cells outside this box are set to 0;
the bounding box size adjusts dynamically to fit the entire pattern. Walls
remain unchanged in the output.    **Output Grid:**   The output displays the
traced paths of all flow lines (colors cycling through 2–5), with walls
preserved. Paths weave through the grid via periodic reflections, exiting the
bounding box cleanly. No line overlaps with walls, other paths, or the grid
edges. The bounding box is tightly fitted to the paths, eliminating extraneous
background cells.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def sgn(x):
    return -1 if x < 0 else (1 if x > 0 else 0)


def place_wall_segments(base, width, height, min_seg=2, max_seg=6, count=None):
    if count is None:
        count = random.randint(6, 12)
    attempts = 0
    placed = 0
    while placed < count and attempts < count * 10:
        attempts += 1
        orientation = random.choice(["h", "v"])
        if orientation == "h":
            if height < 3:
                continue
            row = random.randint(1, height - 2)
            length = random.randint(min_seg, min(max_seg, width - 2))
            if width - length - 1 >= 1:
                start = random.randint(1, width - length - 1)
            else:
                start = random.randint(0, max(0, width - length))
            ok = True
            for c in range(start, start + length):
                if base[row][c] == 1:
                    ok = False
                    break
            if not ok:
                continue
            for c in range(start, start + length):
                base[row][c] = 1
            placed += 1
        else:
            if width < 3:
                continue
            col = random.randint(1, width - 2)
            length = random.randint(min_seg, min(max_seg, height - 2))
            if height - length - 1 >= 1:
                start = random.randint(1, height - length - 1)
            else:
                start = random.randint(0, max(0, height - length))
            ok = True
            for r in range(start, start + length):
                if base[r][col] == 1:
                    ok = False
                    break
            if not ok:
                continue
            for r in range(start, start + length):
                base[r][col] = 1
            placed += 1
    return base


def find_collision_candidates(base, width, height):
    candidates = []
    # examine every possible starting column on the top row
    for c in range(width):
        if base[0][c] != 0:
            continue
        for dc in (1, -1):
            r, cc = 0, c
            dr = 1
            while True:
                nr, nc = r + dr, cc + dc
                if nr < 0 or nr >= height or nc < 0 or nc >= width:
                    break
                if base[nr][nc] == 1:
                    candidates.append((c, (dr, dc)))
                    break
                r, cc = nr, nc
    return candidates


def simulate_full_path(base, start_r, start_c, direction, start_color):
    # base: grid with walls (1) and background (0)
    height = len(base)
    width = len(base[0])
    r, c = start_r, start_c
    dr, dc = direction
    current_color = start_color
    reflections = 0
    visited = set()
    visited.add((r, c))
    output = [row[:] for row in base]
    output[r][c] = current_color

    while True:
        nr, nc = r + dr, c + dc
        # exit if leaving the grid
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        # if next is a wall, reflect
        if base[nr][nc] == 1:
            reflections += 1
            # determine wall orientation by checking neighbors of the wall cell
            # if the wall cell has a horizontal neighbor, treat as horizontal segment
            if (nc - 1 >= 0 and base[nr][nc - 1] == 1) or (nc + 1 < width and base[nr][nc + 1] == 1):
                wall = 'h'
            else:
                wall = 'v'

            # vector from wall cell to current cell
            vx = r - nr
            vy = c - nc

            if wall == 'h':
                perp = (sgn(vx), 0)
                par = (0, sgn(vy))
            else:
                perp = (0, sgn(vy))
                par = (sgn(vx), 0)

            primary = perp if reflections % 2 == 1 else par
            alternative = par if reflections % 2 == 1 else perp

            accepted = False
            for cand in (primary, alternative):
                newdr, newdc = cand
                if newdr == 0 and newdc == 0:
                    continue
                nr2, nc2 = r + newdr, c + newdc
                if 0 <= nr2 < height and 0 <= nc2 < width and base[nr2][nc2] != 1 and (nr2, nc2) not in visited:
                    dr, dc = newdr, newdc
                    current_color = (current_color - 2 + 1) % 4 + 2
                    accepted = True
                    break
                # try inverted direction (swap sign)
                newdr2, newdc2 = -newdr, -newdc
                if newdr2 == 0 and newdc2 == 0:
                    continue
                nr2, nc2 = r + newdr2, c + newdc2
                if 0 <= nr2 < height and 0 <= nc2 < width and base[nr2][nc2] != 1 and (nr2, nc2) not in visited:
                    dr, dc = newdr2, newdc2
                    current_color = (current_color - 2 + 1) % 4 + 2
                    accepted = True
                    break

            if not accepted:
                # can't reflect into a free cell -> terminate
                break

            # perform the move into the newly chosen direction
            r, c = r + dr, c + dc
            if (r, c) in visited:
                break
            visited.add((r, c))
            output[r][c] = current_color

        else:
            # move normally
            r, c = nr, nc
            if (r, c) in visited:
                break
            visited.add((r, c))
            output[r][c] = current_color

    return output


def generate():
    # Try to build a scene where at least one top-origin diagonal will hit a wall.
    tries = 0
    while True:
        tries += 1
        width = random.randint(12, 25)
        height = random.randint(12, 25)
        base = grid(width, height, 0)
        base = place_wall_segments(base, width, height)

        candidates = find_collision_candidates(base, width, height)
        if not candidates and tries < 30:
            # try again to build a different wall arrangement
            continue
        if not candidates:
            # Force a simple wall to guarantee a collision: place a small wall near top center
            col = width // 2
            row = min(3, height - 2)
            base[row][col] = 1
            candidates = find_collision_candidates(base, width, height)
        # pick a random candidate start
        start_col, direction = random.choice(candidates)
        # choose a starting color consistent with diagonal direction
        if direction[1] == 1:
            start_color = random.choice([2, 4])
        else:
            start_color = random.choice([3, 5])

        # build input grid: base walls + the initial diagonal up to (but not including) the wall
        input_grid = [row[:] for row in base]
        r, c = 0, start_col
        dr, dc = direction
        input_grid[r][c] = start_color
        while True:
            nr, nc = r + dr, c + dc
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                break
            if base[nr][nc] == 1:
                break
            input_grid[nr][nc] = start_color
            r, c = nr, nc

        # simulate the full reflected path to create the output
        output_full = simulate_full_path(base, 0, start_col, direction, start_color)

        # compute bounding box of path cells (colors 2-5)
        min_r, max_r = height, -1
        min_c, max_c = width, -1
        for rr in range(height):
            for cc in range(width):
                if 2 <= output_full[rr][cc] <= 5:
                    min_r = min(min_r, rr)
                    max_r = max(max_r, rr)
                    min_c = min(min_c, cc)
                    max_c = max(max_c, cc)

        if max_r == -1:
            # nothing traced (shouldn't normally happen) try again
            if tries < 30:
                continue
            # fallback: return the full grid
            cropped = output_full
        else:
            cropped = [row[min_c:max_c + 1] for row in output_full[min_r:max_r + 1]]

        return {"input": input_grid, "output": cropped}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    def sgn(x):
        return -1 if x < 0 else (1 if x > 0 else 0)

    # reconstruct base (walls only)
    base = [[1 if grid[r][c] == 1 else 0 for c in range(width)] for r in range(height)]

    # find all starting flow pixels on the top row
    starts = []
    for c in range(width):
        v = grid[0][c]
        if 2 <= v <= 5:
            # infer initial diagonal direction from color (consistent with generator)
            if v in (2, 4):
                direction = (1, 1)
            else:
                direction = (1, -1)
            starts.append((0, c, direction, v))

    # helper to simulate a single path on base grid
    def simulate(base, start_r, start_c, direction, start_color):
        r, c = start_r, start_c
        dr, dc = direction
        current_color = start_color
        reflections = 0
        visited = set()
        visited.add((r, c))
        output = [row[:] for row in base]
        output[r][c] = current_color

        while True:
            nr, nc = r + dr, c + dc
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                break
            if base[nr][nc] == 1:
                reflections += 1
                if (nc - 1 >= 0 and base[nr][nc - 1] == 1) or (nc + 1 < width and base[nr][nc + 1] == 1):
                    wall = 'h'
                else:
                    wall = 'v'
                vx = r - nr
                vy = c - nc
                if wall == 'h':
                    perp = (sgn(vx), 0)
                    par = (0, sgn(vy))
                else:
                    perp = (0, sgn(vy))
                    par = (sgn(vx), 0)
                primary = perp if reflections % 2 == 1 else par
                alternative = par if reflections % 2 == 1 else perp
                accepted = False
                for cand in (primary, alternative):
                    newdr, newdc = cand
                    if newdr == 0 and newdc == 0:
                        continue
                    nr2, nc2 = r + newdr, c + newdc
                    if 0 <= nr2 < height and 0 <= nc2 < width and base[nr2][nc2] != 1 and (nr2, nc2) not in visited:
                        dr, dc = newdr, newdc
                        current_color = (current_color - 2 + 1) % 4 + 2
                        accepted = True
                        break
                    newdr2, newdc2 = -newdr, -newdc
                    if newdr2 == 0 and newdc2 == 0:
                        continue
                    nr2, nc2 = r + newdr2, c + newdc2
                    if 0 <= nr2 < height and 0 <= nc2 < width and base[nr2][nc2] != 1 and (nr2, nc2) not in visited:
                        dr, dc = newdr2, newdc2
                        current_color = (current_color - 2 + 1) % 4 + 2
                        accepted = True
                        break
                if not accepted:
                    break
                r, c = r + dr, c + dc
                if (r, c) in visited:
                    break
                visited.add((r, c))
                output[r][c] = current_color
            else:
                r, c = nr, nc
                if (r, c) in visited:
                    break
                visited.add((r, c))
                output[r][c] = current_color
        return output

    # if no explicit starts found, try to infer by scanning top row for background with a diagonal path that later stops at a wall
    if not starts:
        for c in range(width):
            if base[0][c] != 0:
                continue
            # check both diagonal directions
            for dc in (1, -1):
                r, cc = 0, c
                dr = 1
                while True:
                    nr, nc = r + dr, cc + dc
                    if nr < 0 or nr >= height or nc < 0 or nc >= width:
                        break
                    if base[nr][nc] == 1:
                        # guess a color based on direction
                        start_color = 2 if dc == 1 else 3
                        starts.append((0, c, (1, dc), start_color))
                        break
                    r, cc = nr, nc
            if starts:
                break

    # simulate all starts and merge results (but generator uses only one start typically)
    final_output = [row[:] for row in base]
    any_paths = False
    for (sr, sc, direction, color) in starts:
        simulated = simulate(base, sr, sc, direction, color)
        # overlay colors onto final_output (walls remain 1)
        for r in range(height):
            for c in range(width):
                if 2 <= simulated[r][c] <= 5:
                    final_output[r][c] = simulated[r][c]
                    any_paths = True

    # find bounding box of path cells
    min_r, max_r = height, -1
    min_c, max_c = width, -1
    for r in range(height):
        for c in range(width):
            if 2 <= final_output[r][c] <= 5:
                min_r = min(min_r, r)
                max_r = max(max_r, r)
                min_c = min(min_c, c)
                max_c = max(max_c, c)

    if max_r == -1:
        # nothing traced: return the grid unchanged
        return tuple(tuple(row) for row in final_output)

    cropped = [row[min_c:max_c + 1] for row in final_output[min_r:max_r + 1]]
    return tuple(tuple(row) for row in cropped)

