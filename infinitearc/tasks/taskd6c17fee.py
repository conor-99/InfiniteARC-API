# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: d6c17fee
Difficulty: medium–hard

=== Tags ===
- Synchronized bounce
- Symbolic color algebra
- Example condition induction
- Find and double the smallest object

=== Description ===
Input grids contain multiple connected regions of distinct colors, each
representing a separate object. The smallest object is identified by its area
(number of cells), with ties broken by position (top-left preference). The
output grid is formed by duplicating this smallest object such that the two
copies are symmetrically placed with respect to the grid's geometric center. The
symmetry axis (vertical, horizontal, main diagonal, or anti-diagonal) is
determined by the numerical value of the smallest object's color: color 1 →
vertical symmetry, color 2 → horizontal symmetry, color 3 → main diagonal
symmetry, color 4 → anti-diagonal symmetry, and colors 5–9 wrap around to colors
1–4. All other regions in the grid remain unchanged. The duplication creates a
"synchronized bounce" effect where the mirrored copy appears to reflect off the
grid's center axis. The symbolic color algebra rule maps color values to
symmetry types, enabling pattern recognition through example induction.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
from common import grid, random

def generate():
    W = random.randint(3, 30)
    H = random.randint(3, 30)
    input_grid = grid(W, H)
    
    # Place smallest region (single cell)
    r_small = random.randint(0, H-1)
    c_small = random.randint(0, W-1)
    c_small_color = random.randint(1, 9)
    input_grid[r_small][c_small] = c_small_color
    
    # Determine symmetry type
    sym_type = ((c_small_color - 1) % 4) + 1
    
    # Compute mirror position
    if sym_type == 1:  # vertical
        sym_r, sym_c = r_small, W - 1 - c_small
    elif sym_type == 2:  # horizontal
        sym_r, sym_c = H - 1 - r_small, c_small
    elif sym_type == 3:  # main diagonal
        sym_r, sym_c = c_small, r_small
    else:  # sym_type == 4
        sym_r, sym_c = H - 1 - c_small, W - 1 - r_small
    
    # Clamp mirror position to grid bounds
    sym_r = max(0, min(sym_r, H-1))
    sym_c = max(0, min(sym_c, W-1))
    
    # Place another region (2x2) with correct variable names
    color_other = random.randint(1, 9)
    while color_other == c_small_color:
        color_other = random.randint(1, 9)
    
    r_other = random.randint(0, H-2)
    c_other_col = random.randint(0, W-2)
    # Avoid overlapping with smallest and mirror
    while (r_other <= r_small <= r_other+1 and c_other_col <= c_small <= c_other_col+1) or \
          (r_other <= sym_r <= r_other+1 and c_other_col <= sym_c <= c_other_col+1):
        r_other = random.randint(0, H-2)
        c_other_col = random.randint(0, W-2)
    
    for dr in range(2):
        for dc in range(2):
            input_grid[r_other + dr][c_other_col + dc] = color_other
    
    # Create output grid
    output_grid = [row[:] for row in input_grid]
    if input_grid[sym_r][sym_c] == 0:
        output_grid[sym_r][sym_c] = c_small_color
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    H = len(input_list)
    W = len(input_list[0])
    
    components = {}
    for r in range(H):
        for c in range(W):
            color = input_list[r][c]
            if color > 0:
                if color not in components:
                    components[color] = []
                components[color].append((r, c))
    
    min_area = float('inf')
    smallest_color = None
    smallest_region = []
    smallest_min_r = float('inf')
    smallest_min_c = float('inf')
    
    for color, pixels in components.items():
        area = len(pixels)
        min_r = min(r for r, c in pixels)
        min_c = min(c for r, c in pixels)
        if area < min_area or (area == min_area and (min_r < smallest_min_r or (min_r == smallest_min_r and min_c < smallest_min_c))):
            min_area = area
            smallest_color = color
            smallest_region = pixels
            smallest_min_r = min_r
            smallest_min_c = min_c
    
    sym_type = ((smallest_color - 1) % 4) + 1
    
    output_list = [row[:] for row in input_list]
    
    for (r, c) in smallest_region:
        if sym_type == 1:
            sym_r, sym_c = r, W - 1 - c
        elif sym_type == 2:
            sym_r, sym_c = H - 1 - r, c
        elif sym_type == 3:
            sym_r, sym_c = c, r
        else:  # sym_type == 4
            sym_r, sym_c = H - 1 - c, W - 1 - r
        
        # Clamp mirror position to grid bounds
        sym_r = max(0, min(sym_r, H-1))
        sym_c = max(0, min(sym_c, W-1))
        
        if input_list[sym_r][sym_c] == 0:
            output_list[sym_r][sym_c] = smallest_color
    
    return tuple(tuple(row) for row in output_list)
