# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: f2f4edf4
Difficulty: hard

=== Tags ===
- Minimal edit completion
- Color arithmetic mod n

=== Description ===
The input grid contains exactly one cell with value 0 (representing a missing
value), and all other cells contain colors from 1 to 9. The output grid replaces
this 0 with a value computed by summing the four adjacent non-zero cells (up,
down, left, right), then taking the result modulo n, where n is the number of
distinct colors present in the input grid (excluding the 0 cell). The input grid
is guaranteed to contain at least two distinct non-zero colors, ensuring n â‰¥ 2.
The transformation requires identifying the single missing cell, determining n
through distinct color counting, summing adjacent values, and applying modular
arithmetic to compute the correct replacement value. This task demands multi-
step reasoning, precise pattern recognition, and correct application of color
arithmetic under a dynamically determined modulus.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
def generate():
    while True:
        width = random.randint(3, 30)
        height = random.randint(3, 30)
        grid_in = [[random.randint(1, 9) for _ in range(width)] for _ in range(height)]
        valid_positions = [(r, c) for r in range(1, height-1) for c in range(1, width-1)]
        if not valid_positions:
            continue
        while valid_positions:
            r, c = random.choice(valid_positions)
            valid_positions.remove((r, c))
            grid_in[r][c] = 0
            neighbors = [
                grid_in[r-1][c],
                grid_in[r+1][c],
                grid_in[r][c-1],
                grid_in[r][c+1]
            ]
            total = sum(neighbors)
            colors = set()
            for row in grid_in:
                for cell in row:
                    if cell != 0:
                        colors.add(cell)
            n = len(colors)
            s = total % n
            if s == 0:
                grid_in[r][c] = random.randint(1, 9)
                continue
            else:
                grid_out = [row[:] for row in grid_in]
                grid_out[r][c] = s
                return {
                    "input": grid_in,
                    "output": grid_out
                }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] == 0:
                zero_r, zero_c = r, c
                break
        else:
            continue
        break
    neighbors = [
        input_grid[zero_r-1][zero_c],
        input_grid[zero_r+1][zero_c],
        input_grid[zero_r][zero_c-1],
        input_grid[zero_r][zero_c+1]
    ]
    total = sum(neighbors)
    colors = set()
    for row in input_grid:
        for cell in row:
            if cell != 0:
                colors.add(cell)
    n = len(colors)
    s = total % n
    output_grid = [row[:] for row in input_grid]
    output_grid[zero_r][zero_c] = s
    return output_grid
