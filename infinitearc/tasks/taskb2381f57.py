# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: b2381f57
Difficulty: very hard

=== Tags ===
- Indexed painting
- Detect vertical symmetry
- Concentric

=== Description ===
Input grids are large (20Ã—20 or larger) with a single background color (0).
Overlaid on this background are multiple concentric, symmetric shapes centered
on the vertical midline, each forming a closed loop of a distinct color. These
shapes are perfectly mirrored across the vertical axis and arranged in a
sequence from innermost (smallest) to outermost (largest), with no gaps between
layers. The colors of the shapes follow no discernible pattern related to their
position in the sequence, and the shapes may vary in form (e.g., squares,
rectangles, or pixelated circles) but maintain consistent symmetry. Non-
concentric elements (e.g., isolated shapes or noise) are present but do not
interfere with the concentric sequence.  The output grid requires three key
transformations: 1. **Detect the vertical symmetry axis**: Identify the grid's
vertical midline (center column) as the axis of symmetry for all concentric
shapes. 2. **Identify concentric layers**: Determine the order of layers from
innermost (index 0) to outermost (index *n*), based solely on geometric size and
position relative to the symmetry axis. 3. **Apply indexed painting**: Replace
each layer's color with *index + 1*, where index starts at 0 for the innermost
layer. For example, the innermost layer (index 0) becomes color 1, the next
(index 1) becomes color 2, and so on. The background (color 0) and non-
concentric elements remain unchanged.  The task demands precise spatial
reasoning to distinguish concentric layers from irregular elements, verify
vertical symmetry to avoid misidentifying layers, and apply the index-based
color mapping without relying on the input's color values. The complexity arises
from the need to process multiple nested structures, handle irregular shape
forms, and ensure no layer is misordered due to visual distractions like non-
concentric elements or partial symmetry disruptions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # choose odd width and height between 21 and 29 inclusive
    width_choices = [w for w in range(21, 30) if w % 2 == 1]
    height_choices = [h for h in range(21, 30) if h % 2 == 1]
    width = random.choice(width_choices)
    height = random.choice(height_choices)

    grid = [[0 for _ in range(width)] for _ in range(height)]
    center_r = height // 2
    center_c = width // 2

    # compute maximum possible radius so that rings fit
    max_rad = min(center_r, center_c)
    # maximum number of layers we can place (limit for complexity)
    max_num_layers = min(4, max_rad)
    num_layers = random.randint(2, max_num_layers)

    # choose layer colors from high palette to avoid accidental collisions with small mapping indices
    palette = [6, 7, 8, 9]
    layer_colors = random.sample(palette, num_layers)

    # start radius chosen so all layers fit
    start_max = max(1, max_rad - (num_layers - 1))
    start_rad = random.randint(1, start_max)

    radii = [start_rad + i for i in range(num_layers)]

    # draw rings using Chebyshev distance (square-like concentric rings)
    for color, radius in zip(layer_colors, radii):
        for r in range(height):
            for c in range(width):
                if max(abs(r - center_r), abs(c - center_c)) == radius:
                    grid[r][c] = color

    # add non-concentric noise (colors not in layer_colors)
    # to avoid accidental symmetric centered objects, only place noise on the left side (c < center_c)
    noise_colors = [c for c in range(1, 10) if c not in layer_colors]
    # number of noise pixels to add
    n_noise = random.randint(15, 45)
    attempts = 0
    placed = 0
    while placed < n_noise and attempts < n_noise * 20:
        attempts += 1
        r = random.randint(0, height - 1)
        # pick column on left half only (avoid center column)
        if center_c - 1 >= 0:
            c = random.randint(0, center_c - 1)
        else:
            c = 0
        # avoid overwriting ring pixels
        if grid[r][c] != 0:
            continue
        d = max(abs(r - center_r), abs(c - center_c))
        if d in radii:
            # do not place noise on ring positions
            continue
        # choose a noise color (not in layer colors)
        color = random.choice(noise_colors)
        grid[r][c] = color
        placed += 1

    # prepare the output by mapping each ring's color to index+1 (innermost -> 1)
    output = [row[:] for row in grid]
    for i, radius in enumerate(radii):
        color = layer_colors[i]
        for r in range(height):
            for c in range(width):
                if max(abs(r - center_r), abs(c - center_c)) == radius and grid[r][c] == color:
                    output[r][c] = i + 1

    return { "input": grid, "output": output }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # convert input to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    center_r = height // 2
    center_c = width // 2

    # collect positions by color
    color_positions = {}
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if v == 0: continue
            color_positions.setdefault(v, []).append((r, c))

    candidates = []  # (color, rad_min, rad_max, positions)
    for color, positions in color_positions.items():
        # check perfect vertical symmetry for this color
        symmetric = True
        for (r, c) in positions:
            mc = width - 1 - c
            if grid[r][mc] != color:
                symmetric = False
                break
        if not symmetric:
            continue
        cols = [c for (_, c) in positions]
        min_c, max_c = min(cols), max(cols)
        # ensure bounding box is centered on the vertical midline
        if min_c + max_c != width - 1:
            continue
        # compute chebyshev radii extents
        dists = [max(abs(r - center_r), abs(c - center_c)) for (r, c) in positions]
        rad_min = min(dists)
        rad_max = max(dists)
        candidates.append((color, rad_min, rad_max, positions))

    if not candidates:
        # nothing to do
        return grid

    # sort candidates by inner radius (innermost first)
    candidates.sort(key=lambda x: x[1])

    # find the longest contiguous chain where each next layer begins at prev.rad_max + 1
    best_chain = []
    n = len(candidates)
    for i in range(n):
        chain = [candidates[i]]
        prev_max = candidates[i][2]
        for j in range(i + 1, n):
            colj, minj, maxj, posj = candidates[j]
            if minj == prev_max + 1:
                chain.append(candidates[j])
                prev_max = maxj
            else:
                break
        if len(chain) > len(best_chain):
            best_chain = chain

    # if no contiguous chain found, fall back to all candidates sorted
    if not best_chain:
        best_chain = candidates

    # build mapping color -> index+1 based on chain order
    color_to_new = {}
    for idx, (color, _, _, _) in enumerate(best_chain):
        color_to_new[color] = idx + 1

    # create output by replacing only the pixels that belong to the selected components
    output = [row[:] for row in grid]
    for idx, (color, _, _, positions) in enumerate(best_chain):
        newc = idx + 1
        for (r, c) in positions:
            output[r][c] = newc

    return output

