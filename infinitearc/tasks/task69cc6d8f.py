# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 69cc6d8f
Difficulty: very hard

=== Tags ===
- Gate chain construction
- Draw pattern from point
- Connect the dots
- Multi stage color switch

=== Description ===
Task: Gate Chain Pathway  Tags: Gate chain construction, Draw pattern from
point, Connect the dots, Multi stage color switch  Description: Input grids
feature a single starting point (a distinct color, e.g., yellow) and multiple
gate cells, each colored with a unique color from a predefined palette (e.g.,
blue, red, green, cyan, etc.). The background is uniformly colored (e.g.,
black). Gate cells are positioned such that they can be connected via straight
horizontal or vertical paths without overlapping other elements. The gates must
be connected in the order determined by the alphabetical sequence of their color
names (blue, cyan, green, gray, maroon, orange, pink, red, yellow), not by
numerical color values.  The output grid must draw a continuous path starting
from the initial point and sequentially connecting all gate cells in this
alphabetical order. Each segment of the path between consecutive gates is drawn
using the color of the destination gate. For example, the segment from the
starting point to the first gate (blue) is drawn in blue; the segment from the
first gate to the second gate (cyan) is drawn in cyan; and so on. The path must
be drawn only on background cells, avoiding all existing gate cells and the
starting point. The original starting point and all gate cells remain unchanged
in the output, with the path segments added between them. This requires the
solver to correctly map each color to its name, sort gates alphabetically by
name, and execute precise path drawing with multi-stage color transitions
between consecutive gates.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Mapping from color index to its English name (consistent with common.py color ordering)
    color_to_name = {1: 'blue', 8: 'cyan', 3: 'green', 5: 'gray', 9: 'maroon', 7: 'orange', 6: 'pink', 2: 'red'}
    colors = list(color_to_name.keys())

    min_dim = 7
    max_dim = 20
    min_gates = 3
    max_gates = min(6, len(colors))
    min_step = 2  # minimum spacing so there's at least one background cell to paint between points

    # Try multiple random attempts to build a non-self-intersecting monotonic chain
    for attempt in range(500):
        width = random.randint(min_dim, max_dim)
        height = random.randint(min_dim, max_dim)
        n_gates = random.randint(min_gates, max_gates)

        chosen = random.sample(colors, n_gates)
        # Sort colors alphabetically by name to determine the required connection order
        ordered_colors = sorted(chosen, key=lambda c: color_to_name[c])

        # We'll try two orientation choices (start horizontal or start vertical)
        start_dir = random.choice(['H', 'V'])
        for dir_try in range(2):
            dir_choice = start_dir if dir_try == 0 else ('V' if start_dir == 'H' else 'H')

            if dir_choice == 'H':
                h_steps = (n_gates + 1) // 2
                v_steps = n_gates - h_steps
            else:
                v_steps = (n_gates + 1) // 2
                h_steps = n_gates - v_steps

            # choose a start position that leaves room to the right and down for the planned steps
            min_sr = 1
            max_sr = height - 1 - min_step * v_steps
            min_sc = 1
            max_sc = width - 1 - min_step * h_steps
            if max_sr < min_sr or max_sc < min_sc:
                continue

            sr = random.randint(min_sr, max_sr)
            sc = random.randint(min_sc, max_sc)

            available_right = width - 1 - sc
            available_down = height - 1 - sr
            if available_right < min_step * h_steps or available_down < min_step * v_steps:
                continue

            # distribute leftover space among the horizontal and vertical moves
            extras_right = available_right - min_step * h_steps
            extras_down = available_down - min_step * v_steps

            def distribute(k, extra):
                if k <= 0:
                    return []
                parts = [0] * k
                for _ in range(extra):
                    parts[random.randrange(k)] += 1
                return parts

            h_extras = distribute(h_steps, extras_right)
            v_extras = distribute(v_steps, extras_down)
            h_offsets = [min_step + (h_extras[i] if i < len(h_extras) else 0) for i in range(h_steps)]
            v_offsets = [min_step + (v_extras[i] if i < len(v_extras) else 0) for i in range(v_steps)]

            # Build the monotonic chain of gate positions by walking from the start
            positions = []
            used = set()  # internal painted cells reserved to avoid self-crossing
            cur_r, cur_c = sr, sc
            h_idx = 0
            v_idx = 0
            ok = True
            for i in range(n_gates):
                if (dir_choice == 'H' and i % 2 == 0) or (dir_choice == 'V' and i % 2 == 1):
                    # horizontal move
                    offset = h_offsets[h_idx]
                    next_r, next_c = cur_r, cur_c + offset
                    h_idx += 1
                    # check and reserve internal horizontal cells
                    for cc in range(min(cur_c, next_c) + 1, max(cur_c, next_c)):
                        if (cur_r, cc) in used:
                            ok = False
                            break
                    if not ok:
                        break
                    for cc in range(min(cur_c, next_c) + 1, max(cur_c, next_c)):
                        used.add((cur_r, cc))
                else:
                    # vertical move
                    offset = v_offsets[v_idx]
                    next_r, next_c = cur_r + offset, cur_c
                    v_idx += 1
                    for rr in range(min(cur_r, next_r) + 1, max(cur_r, next_r)):
                        if (rr, cur_c) in used:
                            ok = False
                            break
                    if not ok:
                        break
                    for rr in range(min(cur_r, next_r) + 1, max(cur_r, next_r)):
                        used.add((rr, cur_c))

                # validate endpoint
                if not (0 <= next_r < height and 0 <= next_c < width):
                    ok = False
                    break
                if (next_r, next_c) == (sr, sc) or (next_r, next_c) in positions:
                    ok = False
                    break

                positions.append((next_r, next_c))
                cur_r, cur_c = next_r, next_c

            if not ok or len(positions) != n_gates:
                continue

            # create input grid and place start and gates
            input_grid = grid(width, height, 0)
            input_grid[sr][sc] = 4  # start (yellow)
            for pos, col in zip(positions, ordered_colors):
                r, c = pos
                input_grid[r][c] = col

            # create output and draw straight segments using the destination gate color
            output_grid = [row[:] for row in input_grid]
            cur = (sr, sc)
            for pos, col in zip(positions, ordered_colors):
                r, c = pos
                if cur[0] == r:
                    for cc in range(min(cur[1], c) + 1, max(cur[1], c)):
                        if output_grid[r][cc] == 0:
                            output_grid[r][cc] = col
                elif cur[1] == c:
                    for rr in range(min(cur[0], r) + 1, max(cur[0], r)):
                        if output_grid[rr][cur[1]] == 0:
                            output_grid[rr][cur[1]] = col
                else:
                    ok = False
                    break
                cur = (r, c)

            if not ok:
                continue

            # ensure we changed something
            if input_grid == output_grid:
                continue

            return {'input': input_grid, 'output': output_grid}

    # fallback simple example (very unlikely to be used)
    width, height = 7, 7
    input_grid = grid(width, height, 0)
    input_grid[1][1] = 4
    input_grid[1][4] = 1
    input_grid[4][4] = 8
    output_grid = [row[:] for row in input_grid]
    for c in range(2, 4):
        output_grid[1][c] = 1
    for r in range(2, 4):
        output_grid[r][4] = 8
    return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Normalize input to a list of lists
    if not isinstance(input_grid, list) or not isinstance(input_grid[0], list):
        input_grid = [list(row) for row in input_grid]

    # Color name mapping (must match the generator mapping)
    color_to_name = {1: 'blue', 8: 'cyan', 3: 'green', 5: 'gray', 9: 'maroon', 7: 'orange', 6: 'pink', 2: 'red'}

    height = len(input_grid)
    width = len(input_grid[0]) if height > 0 else 0

    # find the starting point (yellow == 4)
    start = None
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 4:
                start = (r, c)
                break
        if start is not None:
            break

    if start is None:
        # nothing to do
        return [row[:] for row in input_grid]

    # find gate cells and sort them by their color's English name
    gates = []
    for r in range(height):
        for c in range(width):
            val = input_grid[r][c]
            if val in color_to_name:
                gates.append((r, c, val, color_to_name[val]))

    gates_sorted = sorted(gates, key=lambda x: x[3])

    output_grid = [row[:] for row in input_grid]
    cur_r, cur_c = start

    for r, c, col, _ in gates_sorted:
        # draw straight segment (generator guarantees straight alignment)
        if cur_r == r:
            for cc in range(min(cur_c, c) + 1, max(cur_c, c)):
                if output_grid[r][cc] == 0:
                    output_grid[r][cc] = col
        elif cur_c == c:
            for rr in range(min(cur_r, r) + 1, max(cur_r, r)):
                if output_grid[rr][cur_c] == 0:
                    output_grid[rr][cur_c] = col
        else:
            # fallback L-shaped connection (shouldn't be necessary for valid generator outputs)
            # try bend at (cur_r, c)
            can_bend1 = True
            for cc in range(min(cur_c, c) + 1, max(cur_c, c)):
                if output_grid[cur_r][cc] != 0:
                    can_bend1 = False
                    break
            if can_bend1:
                for cc in range(min(cur_c, c) + 1, max(cur_c, c)):
                    output_grid[cur_r][cc] = col
                for rr in range(min(cur_r, r) + 1, max(cur_r, r)):
                    if output_grid[rr][c] == 0:
                        output_grid[rr][c] = col
            else:
                # try bend at (r, cur_c)
                can_bend2 = True
                for rr in range(min(cur_r, r) + 1, max(cur_r, r)):
                    if output_grid[rr][cur_c] != 0:
                        can_bend2 = False
                        break
                if can_bend2:
                    for rr in range(min(cur_r, r) + 1, max(cur_r, r)):
                        output_grid[rr][cur_c] = col
                    for cc in range(min(cur_c, c) + 1, max(cur_c, c)):
                        if output_grid[r][cc] == 0:
                            output_grid[r][cc] = col
                else:
                    # if neither bend is free, we do not override gates/start; leave as-is
                    pass
        cur_r, cur_c = r, c

    return output_grid

