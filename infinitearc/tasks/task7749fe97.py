# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 7749fe97
Difficulty: very hard

=== Tags ===
- Pattern activation
- Goal conditioned path
- Shape to color encoding
- Recolor

=== Description ===
Input grids consist of a background color (0), multiple distinct contiguous
shapes (each a single non-zero color), a start cell (background), and a goal
cell (background). Each shape is defined by its unique geometric form (e.g.,
square, horizontal line, diagonal line, triangle, cross), with forms visually
distinguishable by their arrangement. The output grid applies two primary
transformations:    1. **Shape to Color Encoding**: Each shape is recolored to a
fixed output color based on its geometric form. For example, a perfect square
(equal width/height) maps to color 5, a horizontal line (width > height) maps to
color 3, a diagonal line (slope = Â±1) maps to color 7, a right triangle (three
cells forming a corner) maps to color 9, and a cross (center cell with four
adjacent cells) maps to color 2. This mapping is consistent across all instances
of the same shape form.    2. **Goal Conditioned Path**: A shortest-path route
is drawn from the start cell to the goal cell through background cells (0),
avoiding recolored shapes. The path's color dynamically cycles through the
output colors of the nearest shapes encountered along the path's direction. For
instance, if the path moves past a square (color 5) followed by a triangle
(color 9), the path alternates between colors 5 and 9 at each step. The path
must navigate around all recolored shapes, and its color sequence is determined
solely by the visual form of adjacent shapes, not numerical values.    This task
requires identifying subtle geometric forms, applying fixed color mappings, and
dynamically generating a path whose color sequence depends on the spatial
relationship between the path and surrounding shapes. The difficulty arises from
the need to simultaneously recognize multiple shape types, apply their mappings,
and compute a path whose color changes based on the visual context of the input
grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque

def generate():
    """
    Generator for ARC task 473.
    Produces a grid with five distinct shapes (square, horizontal line, diagonal line,
    right triangle, cross). Each shape in the input uses a unique non-zero color.
    The output recolors each shape according to a fixed mapping and draws a shortest
    path from the top-left corner (start) to the bottom-right corner (goal) through
    background cells. Each step along the path (except the start cell) is colored by
    scanning forward in the movement direction for the first non-zero cell (a shape);
    if none is found the step gets a default color.
    """
    mapping = {
        'square': 5,
        'horizontal_line': 3,
        'diagonal_line': 7,
        'triangle': 9,
        'cross': 2
    }
    default_color = 1

    # helper shape creators
    def create_square(r, c, s):
        return [(r + dr, c + dc) for dr in range(s) for dc in range(s)]

    def create_horizontal_line(r, c, length):
        return [(r, c + dc) for dc in range(length)]

    def create_diagonal_line(r, c, length, slope=1):
        if slope == 1:
            return [(r + d, c + d) for d in range(length)]
        else:
            return [(r + d, c - d) for d in range(length)]

    def create_triangle_at_orientation(r, c, orientation):
        # orientation: 0=top-left,1=top-right,2=bottom-left,3=bottom-right
        if orientation == 0:
            return [(r, c), (r, c + 1), (r + 1, c)]
        if orientation == 1:
            return [(r, c), (r, c - 1), (r + 1, c)]
        if orientation == 2:
            return [(r, c), (r, c + 1), (r - 1, c)]
        return [(r, c), (r, c - 1), (r - 1, c)]

    def create_cross(r, c):
        return [(r, c), (r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]

    # Try multiple times if placement fails, to keep generator robust
    for attempt_total in range(1000):
        size = random.randint(10, 20)
        grid = [[0 for _ in range(size)] for _ in range(size)]
        occupied = set()
        shapes = []  # list of (shape_name, pixels)
        used_input_colors = set()
        start = (0, 0)
        goal = (size - 1, size - 1)

        shape_sequence = ['square', 'horizontal_line', 'diagonal_line', 'triangle', 'cross']
        failed = False

        for shape in shape_sequence:
            placed = False
            # try many candidate placements for a shape
            for _ in range(300):
                if shape == 'square':
                    s = random.randint(2, min(4, size - 2))
                    r = random.randint(0, size - s)
                    c = random.randint(0, size - s)
                    pixels = create_square(r, c, s)
                elif shape == 'horizontal_line':
                    max_len = max(2, min(6, size - 2))
                    length = random.randint(2, max_len)
                    r = random.randint(0, size - 1)
                    c = random.randint(0, size - length)
                    pixels = create_horizontal_line(r, c, length)
                elif shape == 'diagonal_line':
                    length = random.randint(2, min(6, size - 2))
                    slope = random.choice([1, -1])
                    if slope == 1:
                        r = random.randint(0, size - length)
                        c = random.randint(0, size - length)
                        pixels = create_diagonal_line(r, c, length, slope=1)
                    else:
                        r = random.randint(0, size - length)
                        c = random.randint(length - 1, size - 1)
                        pixels = create_diagonal_line(r, c, length, slope=-1)
                elif shape == 'triangle':
                    orientation = random.randint(0, 3)
                    if orientation == 0:
                        r = random.randint(0, size - 2)
                        c = random.randint(0, size - 2)
                    elif orientation == 1:
                        r = random.randint(0, size - 2)
                        c = random.randint(1, size - 1)
                    elif orientation == 2:
                        r = random.randint(1, size - 1)
                        c = random.randint(0, size - 2)
                    else:
                        r = random.randint(1, size - 1)
                        c = random.randint(1, size - 1)
                    pixels = create_triangle_at_orientation(r, c, orientation)
                else:  # cross
                    r = random.randint(1, size - 2)
                    c = random.randint(1, size - 2)
                    pixels = create_cross(r, c)

                # bounds and overlap checks
                ok = True
                for (rr, cc) in pixels:
                    if rr < 0 or rr >= size or cc < 0 or cc >= size:
                        ok = False
                        break
                    if (rr, cc) in occupied:
                        ok = False
                        break
                    if (rr, cc) == start or (rr, cc) == goal:
                        ok = False
                        break
                if not ok:
                    continue

                # simulate placement and check if there's still a path from start to goal
                occ_temp = occupied.union(set(pixels))
                if start in occ_temp or goal in occ_temp:
                    continue

                # BFS to test connectivity of background from start to goal
                q = deque()
                visited = [[False] * size for _ in range(size)]
                visited[start[0]][start[1]] = True
                q.append(start)
                reachable = False
                while q:
                    cr, cc = q.popleft()
                    if (cr, cc) == goal:
                        reachable = True
                        break
                    for dr, dc in ((0, 1), (1, 0), (0, -1), (-1, 0)):
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < size and 0 <= nc < size and not visited[nr][nc] and (nr, nc) not in occ_temp:
                            visited[nr][nc] = True
                            q.append((nr, nc))
                if not reachable:
                    continue

                # choose an input color for this shape (preferably not equal to its mapped output color)
                choices = [c for c in range(1, 10) if c not in used_input_colors and c != mapping[shape]]
                if not choices:
                    choices = [c for c in range(1, 10) if c not in used_input_colors]
                if not choices:
                    # all colors used somehow; pick any color (should be very rare)
                    choices = list(range(1, 10))
                input_color = random.choice(choices)

                # commit placement
                for (rr, cc) in pixels:
                    grid[rr][cc] = input_color
                occupied.update(pixels)
                used_input_colors.add(input_color)
                shapes.append((shape, pixels))
                placed = True
                break

            if not placed:
                failed = True
                break

        if failed:
            continue

        # ensure start and goal are free
        if grid[start[0]][start[1]] != 0 or grid[goal[0]][goal[1]] != 0:
            continue

        # create output by recoloring shapes according to mapping
        output = [row[:] for row in grid]
        for (shape, pixels) in shapes:
            new_color = mapping[shape]
            for (rr, cc) in pixels:
                output[rr][cc] = new_color

        # BFS to find shortest path (on background cells only) and parent pointers
        parent = [[None] * size for _ in range(size)]
        visited = [[False] * size for _ in range(size)]
        q = deque()
        q.append(start)
        visited[start[0]][start[1]] = True
        found_goal = False
        while q:
            cr, cc = q.popleft()
            if (cr, cc) == goal:
                found_goal = True
                break
            for dr, dc in ((0, 1), (1, 0), (0, -1), (-1, 0)):
                nr, nc = cr + dr, cc + dc
                if 0 <= nr < size and 0 <= nc < size and not visited[nr][nc] and output[nr][nc] == 0:
                    visited[nr][nc] = True
                    parent[nr][nc] = (cr, cc)
                    q.append((nr, nc))
        if not found_goal:
            # Should not happen because we tested connectivity while placing shapes, but retry if it does
            continue

        # reconstruct path
        path = []
        cur = goal
        while cur != start:
            path.append(cur)
            cur = parent[cur[0]][cur[1]]
            if cur is None:
                break
        if cur is None:
            continue
        path.append(start)
        path.reverse()

        # color the path (every step except the start) using the scanning rule in the movement direction
        for i in range(len(path) - 1):
            r1, c1 = path[i]
            r2, c2 = path[i + 1]
            dr = r2 - r1
            dc = c2 - c1
            nr, nc = r1 + dr, c1 + dc
            found_color = None
            while 0 <= nr < size and 0 <= nc < size:
                if output[nr][nc] != 0:
                    found_color = output[nr][nc]
                    break
                nr += dr
                nc += dc
            output[r2][c2] = found_color if found_color is not None else default_color

        return {"input": grid, "output": output}

    raise RuntimeError('Failed to generate a valid grid')



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    # Convert to a mutable list of lists
    grid = [list(row) for row in input_grid]
    size = len(grid)

    mapping = {
        'square': 5,
        'horizontal_line': 3,
        'diagonal_line': 7,
        'triangle': 9,
        'cross': 2
    }
    default_color = 1

    visited = [[False] * size for _ in range(size)]
    components = []  # list of (pixels list)

    # find connected components of non-zero cells (4-connected)
    for r in range(size):
        for c in range(size):
            if grid[r][c] != 0 and not visited[r][c]:
                color_val = grid[r][c]
                stack = [(r, c)]
                visited[r][c] = True
                pixels = []
                while stack:
                    cr, cc = stack.pop()
                    pixels.append((cr, cc))
                    for dr, dc in ((0, 1), (1, 0), (0, -1), (-1, 0)):
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < size and 0 <= nc < size and not visited[nr][nc] and grid[nr][nc] == color_val:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append(pixels)

    # helper methods for classification
    def classify(pixels):
        min_r = min(p[0] for p in pixels)
        max_r = max(p[0] for p in pixels)
        min_c = min(p[1] for p in pixels)
        max_c = max(p[1] for p in pixels)
        width = max_c - min_c + 1
        height = max_r - min_r + 1
        n = len(pixels)
        pixel_set = set(pixels)

        # cross: five pixels, center with four orthogonal neighbors
        if n == 5 and width == 3 and height == 3:
            center = (min_r + 1, min_c + 1)
            if center in pixel_set and (center[0] - 1, center[1]) in pixel_set and (center[0] + 1, center[1]) in pixel_set and (center[0], center[1] - 1) in pixel_set and (center[0], center[1] + 1) in pixel_set:
                return 'cross'

        # full square
        if width == height and n == width * height and width >= 2:
            return 'square'

        # horizontal line
        if height == 1 and width >= 2:
            return 'horizontal_line'

        # diagonal line (slope +1 or -1)
        diffs = [p[0] - p[1] for p in pixels]
        sums = [p[0] + p[1] for p in pixels]
        if all(d == diffs[0] for d in diffs) or all(s == sums[0] for s in sums):
            return 'diagonal_line'

        # right triangle (3 pixels in 2x2)
        if n == 3 and width == 2 and height == 2:
            return 'triangle'

        # fallback
        return 'diagonal_line'

    # create output grid by recoloring detected shapes according to mapping
    out = [row[:] for row in grid]
    shape_pixels_list = []  # store (shape_name, pixels)
    for pixels in components:
        shape_name = classify(pixels)
        new_color = mapping[shape_name]
        for (r, c) in pixels:
            out[r][c] = new_color
        shape_pixels_list.append((shape_name, pixels))

    # find path from top-left to bottom-right (start and goal are corners)
    start = (0, 0)
    goal = (size - 1, size - 1)

    parent = [[None] * size for _ in range(size)]
    visited = [[False] * size for _ in range(size)]
    q = deque()
    q.append(start)
    visited[start[0]][start[1]] = True
    found = False
    while q:
        cr, cc = q.popleft()
        if (cr, cc) == goal:
            found = True
            break
        for dr, dc in ((0, 1), (1, 0), (0, -1), (-1, 0)):
            nr, nc = cr + dr, cc + dc
            if 0 <= nr < size and 0 <= nc < size and not visited[nr][nc] and out[nr][nc] == 0:
                visited[nr][nc] = True
                parent[nr][nc] = (cr, cc)
                q.append((nr, nc))
    if not found:
        # no path (should not happen given the generator), but return recolored shapes anyway
        return out

    # reconstruct path
    path = []
    cur = goal
    while cur != start:
        path.append(cur)
        cur = parent[cur[0]][cur[1]]
        if cur is None:
            break
    if cur is None:
        return out
    path.append(start)
    path.reverse()

    # color the path (every step except the start) using the same scanning rule
    for i in range(len(path) - 1):
        r1, c1 = path[i]
        r2, c2 = path[i + 1]
        dr = r2 - r1
        dc = c2 - c1
        nr, nc = r1 + dr, c1 + dc
        found_color = None
        while 0 <= nr < size and 0 <= nc < size:
            if out[nr][nc] != 0:
                found_color = out[nr][nc]
                break
            nr += dr
            nc += dc
        out[r2][c2] = found_color if found_color is not None else default_color

    return out

