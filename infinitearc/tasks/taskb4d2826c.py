# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: b4d2826c
Difficulty: mediumâ€“hard

=== Tags ===
- Trail memory
- Pairwise rule matching
- Move object based on arrow
- Count touches

=== Description ===
Input grids feature a background color (0) with distinct colored objects (1-4)
and directional arrows (5-8, each representing right/up/left/down). Each object
is associated with the nearest arrow (pairwise matching) to determine movement
direction. The number of adjacent non-background cells (touch count) around the
object determines how many steps it moves. Upon movement, the object leaves a
trail (color 9) at its original position. Output grids display all moved
objects, their trails, and unchanged arrows. The transformation requires
identifying object-arrow associations, counting adjacent elements (touch count),
applying directional movement, and preserving trail memory through the output
grid. The task demands spatial reasoning, adjacency analysis, and sequential
rule application to correctly map input to output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common


def generate():
    """Generates a random ARC-style input/output pair for the described task.

    Rules implemented:
    - Background color is 0.
    - Objects use colors 1..4.
    - Directional arrows use colors 5..8 mapped to (right, up, left, down) respectively.
    - Each object is associated with the nearest arrow (Manhattan distance). Tie-breaker: smaller (distance, arrow_row, arrow_col, arrow_color).
    - Touch count = number of orthogonally adjacent non-background cells around the object (objects and arrows count).
    - The object moves that many steps in the arrow's direction (clamped to grid bounds).
    - If an object moves (new position != original) it leaves a trail (9) at its original cell.
    - Arrows remain unchanged in the output.

    The generator ensures at least one object actually moves and that no moved object lands on an arrow
    or collides with other moved objects. If those conditions fail it retries (limited attempts).
    """
    # Direction mapping: 5:right, 6:up, 7:left, 8:down
    DIRS = {5: (0, 1), 6: (-1, 0), 7: (0, -1), 8: (1, 0)}

    attempts = 0
    while attempts < 200:
        attempts += 1
        # Keep grids moderate sized for speed and variety
        width = random.randint(5, 12)
        height = random.randint(5, 12)

        # Start with background
        ingrid = common.grid(width, height, 0)

        # All possible cells
        cells = [(r, c) for r in range(height) for c in range(width)]
        random.shuffle(cells)

        # Place objects (2-4)
        max_objects = min(4, len(cells) - 1)
        if max_objects < 2:
            continue
        num_objects = random.randint(2, max_objects)
        object_cells = cells[:num_objects]
        # Give objects colors from 1..4 (allow distinct colors)
        object_colors = random.sample([1, 2, 3, 4], num_objects)
        objects = []
        for (r, c), col in zip(object_cells, object_colors):
            ingrid[r][c] = col
            objects.append((r, c, col))

        # Place arrows (1-4), disjoint from objects
        remaining = [cell for cell in cells if cell not in object_cells]
        if not remaining:
            continue
        max_arrows = min(4, len(remaining))
        num_arrows = random.randint(1, max_arrows)
        arrow_cells = remaining[:num_arrows]
        arrow_colors = random.sample([5, 6, 7, 8], num_arrows)
        arrows = []
        for (r, c), acol in zip(arrow_cells, arrow_colors):
            ingrid[r][c] = acol
            arrows.append((r, c, acol))

        # Helper to compute touch counts given current ingrid
        def compute_touches():
            touches = []
            for r, c, _ in objects:
                count = 0
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and ingrid[nr][nc] != 0:
                        count += 1
                touches.append(count)
            return touches

        touches = compute_touches()

        # Ensure at least one object has a non-zero touch count by placing an extra arrow
        # adjacent to a random object if necessary.
        if all(t == 0 for t in touches):
            idx = random.randrange(len(objects))
            r, c, _ = objects[idx]
            neighbors = []
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and ingrid[nr][nc] == 0:
                    neighbors.append((nr, nc))
            if not neighbors:
                # give up this attempt
                continue
            ar, ac = random.choice(neighbors)
            acol = random.choice([5, 6, 7, 8])
            ingrid[ar][ac] = acol
            arrows.append((ar, ac, acol))
            touches = compute_touches()

        # For each object, find the nearest arrow (tie-break deterministically)
        nearest_arrows = []
        for r, c, _ in objects:
            best = None
            for ar, ac, acol in arrows:
                dist = abs(r - ar) + abs(c - ac)
                key = (dist, ar, ac, acol)
                if best is None or key < best[0]:
                    best = (key, (ar, ac, acol))
            # If there are no arrows (shouldn't happen) we bail out
            if best is None:
                best = ((9999, 0, 0, 5), (0, 0, 5))
            nearest_arrows.append(best[1])

        # Compute new positions
        new_positions = []
        arrow_pos_set = {(ar, ac) for ar, ac, _ in arrows}
        conflict = False
        for (r, c, _), (ar, ac, acol), steps in zip(objects, nearest_arrows, touches):
            dr, dc = DIRS[acol]
            new_r = r + dr * steps
            new_c = c + dc * steps
            # clamp
            new_r = max(0, min(new_r, height - 1))
            new_c = max(0, min(new_c, width - 1))
            if (new_r, new_c) in arrow_pos_set:
                conflict = True
                break
            new_positions.append((new_r, new_c))

        if conflict:
            continue

        # No two objects may end up in the same final cell
        if len(set(new_positions)) != len(new_positions):
            continue

        # At least one object must actually move to a different cell
        moved = any(new != (r, c) for new, (r, c, _) in zip(new_positions, objects))
        if not moved:
            continue

        # Build output grid: start from a copy of input, then apply trails and moved objects
        output = [row[:] for row in ingrid]

        # Trails only for objects that moved
        for (r, c, _), (new_r, new_c) in zip(objects, new_positions):
            if (new_r, new_c) != (r, c):
                output[r][c] = 9

        # Place moved objects (they will overwrite trails if they land on them)
        for (r, c, col), (new_r, new_c) in zip(objects, new_positions):
            output[new_r][new_c] = col

        # Sanity checks before returning
        if output == ingrid:
            # Shouldn't happen because we required moved==True, but be safe
            continue

        return {"input": ingrid, "output": output}

    # As a fallback (extremely unlikely) raise an error so the validator knows generation failed
    raise RuntimeError("Failed to generate a valid example after many attempts")



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input tuple-of-tuples to a mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # Direction mapping must match generator: 5:right, 6:up, 7:left, 8:down
    DIRS = {5: (0, 1), 6: (-1, 0), 7: (0, -1), 8: (1, 0)}

    objects = []
    arrows = []
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if 1 <= v <= 4:
                objects.append((r, c, v))
            elif 5 <= v <= 8:
                arrows.append((r, c, v))

    # If there are no objects or no arrows, return the grid unchanged
    if not objects:
        return [row[:] for row in grid]

    # Compute touch counts: number of orthogonally adjacent non-background cells
    touches = {}
    for r, c, _ in objects:
        count = 0
        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                count += 1
        touches[(r, c)] = count

    # For each object, pick the nearest arrow (tie-break deterministically)
    nearest = {}
    for r, c, _ in objects:
        best = None
        for ar, ac, acol in arrows:
            dist = abs(r - ar) + abs(c - ac)
            key = (dist, ar, ac, acol)
            if best is None or key < best[0]:
                best = (key, (ar, ac, acol))
        if best is None:
            # No arrows: object cannot move
            nearest[(r, c)] = (r, c, None)
        else:
            nearest[(r, c)] = best[1]

    # Compute new positions first (so we can mirror generator's two-phase update)
    new_positions = {}
    arrow_positions = {(ar, ac) for ar, ac, _ in arrows}
    for r, c, _ in objects:
        ar, ac, acol = nearest[(r, c)]
        steps = touches[(r, c)]
        if acol is None or steps == 0:
            new_positions[(r, c)] = (r, c)
            continue
        dr, dc = DIRS[acol]
        new_r = r + dr * steps
        new_c = c + dc * steps
        # clamp to grid
        new_r = max(0, min(new_r, height - 1))
        new_c = max(0, min(new_c, width - 1))
        # If final cell is an arrow, per generator design this should not happen for valid inputs,
        # so treat it as non-movement (safeguard)
        if (new_r, new_c) in arrow_positions:
            new_positions[(r, c)] = (r, c)
        else:
            new_positions[(r, c)] = (new_r, new_c)

    # Now apply trails for all objects that moved, then place moved objects (two-phase update)
    output = [row[:] for row in grid]

    # Phase 1: trails for objects that actually moved
    for r, c, _ in objects:
        new_r, new_c = new_positions[(r, c)]
        if (new_r, new_c) != (r, c):
            output[r][c] = 9

    # Phase 2: place moved objects
    for r, c, col in objects:
        new_r, new_c = new_positions[(r, c)]
        if (new_r, new_c) != (r, c):
            output[new_r][new_c] = col

    return output

