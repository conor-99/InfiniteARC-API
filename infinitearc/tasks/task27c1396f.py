# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 27c1396f
Difficulty: insane

=== Tags ===
- Cut and unfold
- Only one

=== Description ===
Input grids are large (25Ã—25) with a single background color. Over this
background, a single contiguous shape is drawn, but it is folded along a single
axis (either vertical or horizontal), such that one half of the shape is a
mirror image of the other half. The fold axis is marked by a thin, continuous
line of a distinct color (e.g., color 5) running parallel to the axis,
separating the mirrored halves. The shape is designed to be symmetric *only*
along this axis, with no other possible symmetry axes. The background is
uniform, and the shape occupies most of the grid, leaving minimal empty space.
The fold line is the *only* visual cue indicating the axis of symmetry.  In the
output grid, the shape is fully unfolded: the mirrored half is replaced with an
exact copy of the non-mirrored half, and the fold line color is removed. The
background remains unchanged. The unfolded shape becomes fully contiguous and
non-symmetric, revealing the complete structure without the fold. The
transformation requires identifying the unique symmetry axis (vertical or
horizontal) and correcting the mirrored half to its original form. The "Only
One" tag ensures the fold axis is uniquely identifiable, as no other axis would
satisfy the mirror condition for the shape. The task demands precise visual
analysis of the grid's symmetry and spatial relationships, with no numerical or
pixel-based shortcuts.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    """Generate a folded-contiguous-shape example on a 25x25 grid.

    The fold axis is always placed at the central row/column (index 12) so
    halves have equal width/height. The left/top half is treated as the
    original (non-mirrored) half; the right/bottom half in the input is the
    mirrored copy. The output unfolds by copying the original half (preserving
    its orientation) onto the opposite side and removing the fold marker.
    """
    size = 25
    background = 0
    fold_line = 5
    # Choose a shape color different from background and fold line
    shape_color = random.choice([c for c in range(1, 10) if c != fold_line])

    input_grid = grid(size, size, background)
    output_grid = grid(size, size, background)

    # Place axis at the central column/row to ensure equal halves (size is odd)
    axis_pos = size // 2  # 12 for size=25
    orientation = random.choice(["vertical", "horizontal"])

    def build_contiguous_blob(max_rows, max_cols, allowed_rows, allowed_cols, target_size, touch_axis_coord):
        """Build a contiguous set of pixels inside allowed rows/cols.

        We start the seed on the border adjacent to the fold axis (touch_axis_coord)
        so the final blob will always touch the fold and unfolding can connect the halves.
        """
        pixels = set()
        # seed at the axis-adjacent border: choose a random position along the border
        seed_r = random.randrange(0, max_rows)
        seed_c = touch_axis_coord
        if seed_r not in allowed_rows or seed_c not in allowed_cols:
            # clamp seed inside allowed region
            seed_r = min(max(seed_r, min(allowed_rows)), max(allowed_rows))
            seed_c = min(max(seed_c, min(allowed_cols)), max(allowed_cols))
        pixels.add((seed_r, seed_c))
        frontier = set()
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = seed_r + dr, seed_c + dc
            if nr in allowed_rows and nc in allowed_cols:
                frontier.add((nr, nc))
        while len(pixels) < target_size and frontier:
            p = random.choice(tuple(frontier))
            frontier.remove(p)
            pixels.add(p)
            r, c = p
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if nr in allowed_rows and nc in allowed_cols and (nr, nc) not in pixels and (nr, nc) not in frontier:
                    frontier.add((nr, nc))
        return pixels

    if orientation == "vertical":
        # left half columns: 0..axis_pos-1
        allowed_cols = range(0, axis_pos)
        allowed_rows = range(0, size)
        half_area = len(allowed_cols) * len(allowed_rows)
        # target between ~35% and ~85% of the half area to make the shape large
        min_sz = max(1, int(0.35 * half_area))
        max_sz = max(1, int(0.85 * half_area))
        target_size = random.randint(min_sz, max_sz)
        # ensure the blob touches the border at column axis_pos-1
        left_pixels = build_contiguous_blob(size, size, allowed_rows, allowed_cols, target_size, axis_pos - 1)

        # Fill input: left original + mirrored right
        for (r, c) in left_pixels:
            input_grid[r][c] = shape_color
            mirror_c = 2 * axis_pos - c
            # mirror_c will be in axis_pos+1..size-1
            input_grid[r][mirror_c] = shape_color
        # Draw the fold line (full column)
        for r in range(size):
            input_grid[r][axis_pos] = fold_line

        # Build output: copy the original (left) onto both sides preserving orientation
        for (r, c) in left_pixels:
            output_grid[r][c] = shape_color
            c_target = axis_pos + 1 + c
            if 0 <= c_target < size:
                output_grid[r][c_target] = shape_color
        # Fill the axis column to connect halves where appropriate
        for r in range(size):
            left_neighbor = output_grid[r][axis_pos - 1] if axis_pos - 1 >= 0 else background
            right_neighbor = output_grid[r][axis_pos + 1] if axis_pos + 1 < size else background
            if left_neighbor == shape_color or right_neighbor == shape_color:
                output_grid[r][axis_pos] = shape_color
            else:
                output_grid[r][axis_pos] = background

    else:
        # horizontal fold: top rows 0..axis_pos-1 are the original
        allowed_rows = range(0, axis_pos)
        allowed_cols = range(0, size)
        half_area = len(allowed_rows) * len(allowed_cols)
        min_sz = max(1, int(0.35 * half_area))
        max_sz = max(1, int(0.85 * half_area))
        target_size = random.randint(min_sz, max_sz)
        # ensure the blob touches the border at row axis_pos-1
        top_pixels = build_contiguous_blob(size, size, allowed_rows, allowed_cols, target_size, axis_pos - 1)

        # Fill input: top original + mirrored bottom
        for (r, c) in top_pixels:
            input_grid[r][c] = shape_color
            mirror_r = 2 * axis_pos - r
            input_grid[mirror_r][c] = shape_color
        # Draw the fold line (full row)
        for c in range(size):
            input_grid[axis_pos][c] = fold_line

        # Build output: copy the original (top) onto both sides preserving orientation
        for (r, c) in top_pixels:
            output_grid[r][c] = shape_color
            r_target = axis_pos + 1 + r
            if 0 <= r_target < size:
                output_grid[r_target][c] = shape_color
        # Fill the axis row to connect halves where appropriate
        for c in range(size):
            top_neighbor = output_grid[axis_pos - 1][c] if axis_pos - 1 >= 0 else background
            bottom_neighbor = output_grid[axis_pos + 1][c] if axis_pos + 1 < size else background
            if top_neighbor == shape_color or bottom_neighbor == shape_color:
                output_grid[axis_pos][c] = shape_color
            else:
                output_grid[axis_pos][c] = background

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid_in = [list(row) for row in input_grid]
    size = len(grid_in)
    fold = 5
    background = 0

    axis_col = None
    axis_row = None
    # Detect fold column (vertical) first
    for c in range(size):
        if all(grid_in[r][c] == fold for r in range(size)):
            axis_col = c
            break
    if axis_col is None:
        for r in range(size):
            if all(grid_in[r][c] == fold for c in range(size)):
                axis_row = r
                break

    # Determine the shape color (most common non-background, non-fold color)
    counts = {}
    for r in range(size):
        for c in range(size):
            v = grid_in[r][c]
            if v == background or v == fold:
                continue
            counts[v] = counts.get(v, 0) + 1
    if counts:
        shape_color = max(counts.items(), key=lambda x: x[1])[0]
    else:
        # fallback (should not happen for valid inputs)
        shape_color = 1

    out = [[background for _ in range(size)] for _ in range(size)]

    if axis_col is not None:
        left_width = axis_col  # columns 0..axis_col-1
        # Copy original (left) side as source
        for r in range(size):
            for c in range(left_width):
                if grid_in[r][c] == shape_color:
                    out[r][c] = shape_color
        # Copy left side onto right preserving orientation
        for r in range(size):
            for c in range(left_width):
                if out[r][c] == shape_color:
                    c_target = axis_col + 1 + c
                    if 0 <= c_target < size:
                        out[r][c_target] = shape_color
        # Fill the axis column to connect halves where appropriate
        for r in range(size):
            left_neighbor = out[r][axis_col - 1] if axis_col - 1 >= 0 else background
            right_neighbor = out[r][axis_col + 1] if axis_col + 1 < size else background
            if left_neighbor == shape_color or right_neighbor == shape_color:
                out[r][axis_col] = shape_color
            else:
                out[r][axis_col] = background

    else:
        # horizontal
        top_height = axis_row  # rows 0..axis_row-1
        for r in range(top_height):
            for c in range(size):
                if grid_in[r][c] == shape_color:
                    out[r][c] = shape_color
        # Copy top onto bottom preserving orientation
        for r in range(top_height):
            for c in range(size):
                if out[r][c] == shape_color:
                    r_target = axis_row + 1 + r
                    if 0 <= r_target < size:
                        out[r_target][c] = shape_color
        # Fill the axis row
        for c in range(size):
            top_neighbor = out[axis_row - 1][c] if axis_row - 1 >= 0 else background
            bottom_neighbor = out[axis_row + 1][c] if axis_row + 1 < size else background
            if top_neighbor == shape_color or bottom_neighbor == shape_color:
                out[axis_row][c] = shape_color
            else:
                out[axis_row][c] = background

    return tuple(tuple(row) for row in out)

