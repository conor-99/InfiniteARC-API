# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 386e5fc7
Difficulty: insane

=== Tags ===
- Infer hidden grid
- Route switching
- Staircase construction
- Reflect by color
- Loop filling
- Bridges

=== Description ===
Input grids feature a complex maze of colored paths (each path is a continuous
sequence of cells sharing the same non-zero color) embedded on a background of
color 0. Key elements include switch cells (color 5), reflector cells (color 7),
and bridge anchor points (color 9). The hidden staircase structure is inferred
by: (1) tracing all paths while applying directional rules at switches (color 5
rotates direction in a fixed cycle: right → up → left → down → right) and
reflectors (color 7 reverses direction); (2) filling any closed loops formed
during path tracing with color 3; (3) drawing bridges (color 8) as straight
lines between all bridge anchors (color 9) without crossing existing paths; (4)
constructing a diagonal staircase pattern from bottom-left to top-right where
each 2×2 step block cycles through a sequence of colors (1→2→3→1→2→3...) based
on the path's direction progression. The output grid preserves all input
elements but transforms path directions, fills loops, adds bridges, and aligns
the entire structure into the staircase pattern, with bridge connections and
color sequence adherence forming the hidden grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque
from common import grid

# Generator for ARC task 459 - creates random path networks with switches (5), reflectors (7),
# bridge anchors (9) and returns both input and transformed output (according to the same rules
# implemented in the solver below).

def generate():
    # random size but reasonably constrained for speed and clarity
    width = random.randint(12, 18)
    height = random.randint(12, 18)
    input_grid = grid(width, height, 0)

    occupied = set()  # cells already used by placed paths or anchors
    path_colors = [1, 2, 4, 6]  # allowed path colors (avoid special reserved colors)
    components = []  # keep lists of component coordinates for ensuring specials

    def in_bounds(r, c):
        return 0 <= r < height and 0 <= c < width

    def orth_neighbors(r, c):
        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
            yield r + dr, c + dc

    # Place 1-2 rectangular loops (simple rings) to guarantee loop-filling behavior.
    for _ in range(random.randint(1, 2)):
        for attempt in range(200):
            w_rect = random.randint(3, min(8, width - 2))
            h_rect = random.randint(3, min(8, height - 2))
            r0 = random.randint(1, height - h_rect - 1)
            c0 = random.randint(1, width - w_rect - 1)
            coords = set()
            for r in range(r0, r0 + h_rect):
                coords.add((r, c0))
                coords.add((r, c0 + w_rect - 1))
            for c in range(c0, c0 + w_rect):
                coords.add((r0, c))
                coords.add((r0 + h_rect - 1, c))
            if coords & occupied:
                continue
            color = random.choice(path_colors)
            for (r, c) in coords:
                input_grid[r][c] = color
                occupied.add((r, c))
            # Add 1 or 2 special cells (switch or reflector) on the loop border sometimes
            if random.random() < 0.9:
                coords_list = list(coords)
                for _ in range(random.randint(1, min(2, len(coords_list)))):
                    rr, cc = random.choice(coords_list)
                    input_grid[rr][cc] = random.choice([5, 7])
            components.append(list(coords))
            break

    # Helper to carve an open non-branching path using backtracking (avoids overlapping existing occupied cells).
    def carve_path(length):
        for attempt in range(400):
            sr = random.randint(1, height - 2)
            sc = random.randint(1, width - 2)
            if (sr, sc) in occupied:
                continue
            path = [(sr, sc)]
            visited = { (sr, sc) }

            def backtrack():
                if len(path) >= length:
                    return list(path)
                r, c = path[-1]
                nbs = list(orth_neighbors(r, c))
                random.shuffle(nbs)
                for nr, nc in nbs:
                    if not in_bounds(nr, nc):
                        continue
                    if (nr, nc) in visited or (nr, nc) in occupied:
                        continue
                    # ensure the new cell is not adjacent to other occupied cells (except the previous cell)
                    ok = True
                    for ar, ac in orth_neighbors(nr, nc):
                        if (ar, ac) in occupied and (ar, ac) != path[-1]:
                            ok = False
                            break
                    if not ok:
                        continue
                    visited.add((nr, nc))
                    path.append((nr, nc))
                    res = backtrack()
                    if res:
                        return res
                    path.pop()
                    visited.remove((nr, nc))
                return None

            res = backtrack()
            if res:
                return res
        return None

    # Place 1-3 open paths
    for _ in range(random.randint(1, 3)):
        length = random.randint(4, min(12, width * height // 10))
        p = carve_path(length)
        if not p:
            continue
        color = random.choice(path_colors)
        for (r, c) in p:
            input_grid[r][c] = color
            occupied.add((r, c))
        # Possibly convert some internal path cells into special cells (5 or 7)
        if len(p) >= 3 and random.random() < 0.85:
            idx = random.randint(1, len(p) - 2)
            rr, cc = p[idx]
            input_grid[rr][cc] = random.choice([5, 7])
        components.append(p)

    # Place 1-3 anchor pairs (anchors are color 9). Anchors are placed so that a straight bridge between them is free.
    anchors = []
    pair_attempts = random.randint(1, 3)
    for _ in range(pair_attempts):
        placed = False
        for attempt in range(300):
            if random.random() < 0.5:
                # horizontal pair on same row
                r = random.randint(1, height - 2)
                candidates = [c for c in range(1, width - 1) if (r, c) not in occupied]
                if len(candidates) < 2:
                    continue
                c1, c2 = sorted(random.sample(candidates, 2))
                if c2 - c1 < 2:
                    continue
                corridor_ok = all(((r, cc) not in occupied) for cc in range(c1, c2 + 1))
                if not corridor_ok:
                    continue
                input_grid[r][c1] = 9
                input_grid[r][c2] = 9
                occupied.add((r, c1))
                occupied.add((r, c2))
                anchors.append((r, c1))
                anchors.append((r, c2))
                placed = True
                break
            else:
                # vertical pair on same column
                c = random.randint(1, width - 2)
                candidates = [r for r in range(1, height - 1) if (r, c) not in occupied]
                if len(candidates) < 2:
                    continue
                r1, r2 = sorted(random.sample(candidates, 2))
                if r2 - r1 < 2:
                    continue
                corridor_ok = all(((rr, c) not in occupied) for rr in range(r1, r2 + 1))
                if not corridor_ok:
                    continue
                input_grid[r1][c] = 9
                input_grid[r2][c] = 9
                occupied.add((r1, c))
                occupied.add((r2, c))
                anchors.append((r1, c))
                anchors.append((r2, c))
                placed = True
                break
        if not placed:
            # skip if failed to place this pair after many tries
            break

    # Ensure at least a single special (5 or 7) exists to influence staircase offset
    cur_specials = sum(1 for r in range(height) for c in range(width) if input_grid[r][c] in (5, 7))
    if cur_specials == 0 and components:
        comp = random.choice(components)
        if comp:
            rr, cc = random.choice(comp)
            input_grid[rr][cc] = random.choice([5, 7])

    # Now compute the output grid by applying the same transformation as the solver.
    def transform(inp):
        orig = [row[:] for row in inp]
        out = [row[:] for row in inp]

        # find path components (non-zero and not anchors 9)
        h = len(orig)
        w = len(orig[0])
        seen = set()
        comps = []
        for r in range(h):
            for c in range(w):
                if (r, c) in seen:
                    continue
                if orig[r][c] == 0 or orig[r][c] == 9:
                    continue
                # BFS to collect component
                stack = [(r, c)]
                seen.add((r, c))
                comp = []
                while stack:
                    rr, cc = stack.pop()
                    comp.append((rr, cc))
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = rr + dr, cc + dc
                        if 0 <= nr < h and 0 <= nc < w and (nr, nc) not in seen and orig[nr][nc] != 0 and orig[nr][nc] != 9:
                            seen.add((nr, nc))
                            stack.append((nr, nc))
                comps.append(comp)

        # helper maps
        dir_map = {(0, 1): 0, (-1, 0): 1, (0, -1): 2, (1, 0): 3}
        dir_to_color = [1, 2, 3, 1]

        # trace and recolor components according to directional rules
        for comp in comps:
            comp_set = set(comp)
            # build adjacency
            adj = {}
            for (r, c) in comp:
                nbs = []
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = r + dr, c + dc
                    if (nr, nc) in comp_set:
                        nbs.append((nr, nc))
                adj[(r, c)] = nbs
            endpoints = [p for p, nbs in adj.items() if len(nbs) == 1]

            # produce an ordered walk through the component
            order = []
            if endpoints:
                start = sorted(endpoints)[0]
                order = [start]
                prev = None
                while True:
                    cur = order[-1]
                    # neighbors excluding previous to move forward
                    nexts = [n for n in adj[cur] if n != prev]
                    if not nexts:
                        break
                    # pick deterministic neighbor (sorted) so solver == generator
                    nxt = sorted(nexts)[0]
                    order.append(nxt)
                    prev = cur
                    if len(order) > len(comp):
                        break
            else:
                # closed loop: pick smallest coordinate to start and follow neighbors
                start = sorted(comp)[0]
                order = [start]
                # choose a deterministic next
                if adj[start]:
                    nxt = sorted(adj[start])[0]
                    order.append(nxt)
                    prev = start
                    cur = nxt
                    while True:
                        nexts = [n for n in adj[cur] if n != prev]
                        if not nexts:
                            break
                        nxt = sorted(nexts)[0]
                        if nxt == start:
                            break
                        order.append(nxt)
                        prev, cur = cur, nxt

            # assign colors along the walk, applying switches/reflectors to the traveled direction
            for i, (r, c) in enumerate(order):
                # determine movement direction for this position
                if i < len(order) - 1:
                    nr, nc = order[i + 1]
                    dr, dc = nr - r, nc - c
                elif i > 0:
                    pr, pc = order[i - 1]
                    dr, dc = r - pr, c - pc
                else:
                    dr, dc = 0, 1
                dir_idx = dir_map.get((dr, dc), 0)
                val = orig[r][c]
                if val == 5:
                    dir_idx = (dir_idx + 1) % 4
                elif val == 7:
                    dir_idx = (dir_idx + 2) % 4
                # preserve special and anchors; recolor only ordinary path pixels
                if val not in (5, 7, 9):
                    out[r][c] = dir_to_color[dir_idx]

        # fill enclosed zero regions (loop interiors) with color 3
        blocked = set((r, c) for r in range(h) for c in range(w) if orig[r][c] != 0)
        reachable = set()
        dq = deque()
        # start BFS from all border zero cells
        for r in range(h):
            for c in range(w):
                if (r in (0, h - 1) or c in (0, w - 1)) and orig[r][c] == 0:
                    reachable.add((r, c))
                    dq.append((r, c))
        while dq:
            rr, cc = dq.popleft()
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = rr + dr, cc + dc
                if 0 <= nr < h and 0 <= nc < w and (nr, nc) not in reachable and (nr, nc) not in blocked:
                    reachable.add((nr, nc))
                    dq.append((nr, nc))
        for r in range(h):
            for c in range(w):
                if orig[r][c] == 0 and (r, c) not in reachable:
                    out[r][c] = 3

        # draw straight bridges (8) between anchors (9) along rows and columns when the straight corridor is free
        anchors = [(r, c) for r in range(h) for c in range(w) if orig[r][c] == 9]
        from collections import defaultdict
        by_row = defaultdict(list)
        by_col = defaultdict(list)
        for r, c in anchors:
            by_row[r].append(c)
            by_col[c].append(r)
        for r, cols in by_row.items():
            cols_sorted = sorted(cols)
            for i in range(len(cols_sorted) - 1):
                c1, c2 = cols_sorted[i], cols_sorted[i + 1]
                corridor_ok = True
                for cc in range(min(c1, c2), max(c1, c2) + 1):
                    if orig[r][cc] not in (0, 9):
                        corridor_ok = False
                        break
                if corridor_ok:
                    for cc in range(min(c1, c2), max(c1, c2) + 1):
                        if out[r][cc] == 0:
                            out[r][cc] = 8
        for c, rows in by_col.items():
            rows_sorted = sorted(rows)
            for i in range(len(rows_sorted) - 1):
                r1, r2 = rows_sorted[i], rows_sorted[i + 1]
                corridor_ok = True
                for rr in range(min(r1, r2), max(r1, r2) + 1):
                    if orig[rr][c] not in (0, 9):
                        corridor_ok = False
                        break
                if corridor_ok:
                    for rr in range(min(r1, r2), max(r1, r2) + 1):
                        if out[rr][c] == 0:
                            out[rr][c] = 8

        # build diagonal staircase of 2x2 blocks from bottom-left to top-right; blocks only fill empty (0) cells
        special_count = sum(1 for r in range(h) for c in range(w) if orig[r][c] in (5, 7))
        offset = special_count % 3
        color_cycle = [1, 2, 3]
        i = 0
        while True:
            bottom = h - 1 - 2 * i
            top = bottom - 1
            left = 2 * i
            right = left + 1
            if top < 0 or right >= w:
                break
            color = color_cycle[(offset + i) % 3]
            for rr in (top, bottom):
                for cc in (left, right):
                    if out[rr][cc] == 0:
                        out[rr][cc] = color
            i += 1

        return out

    output_grid = transform(input_grid)

    return { 'input': input_grid, 'output': output_grid }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])
    orig = [row[:] for row in grid]
    out = [row[:] for row in grid]

    def in_bounds(r, c):
        return 0 <= r < h and 0 <= c < w

    # find path components (non-zero and not anchors 9)
    seen = set()
    comps = []
    for r in range(h):
        for c in range(w):
            if (r, c) in seen:
                continue
            if orig[r][c] == 0 or orig[r][c] == 9:
                continue
            stack = [(r, c)]
            seen.add((r, c))
            comp = []
            while stack:
                rr, cc = stack.pop()
                comp.append((rr, cc))
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < h and 0 <= nc < w and (nr, nc) not in seen and orig[nr][nc] != 0 and orig[nr][nc] != 9:
                        seen.add((nr, nc))
                        stack.append((nr, nc))
            comps.append(comp)

    # mapping
    dir_map = {(0, 1): 0, (-1, 0): 1, (0, -1): 2, (1, 0): 3}
    dir_to_color = [1, 2, 3, 1]

    # trace components and recolor path pixels
    for comp in comps:
        comp_set = set(comp)
        adj = {}
        for (r, c) in comp:
            nbs = []
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = r + dr, c + dc
                if (nr, nc) in comp_set:
                    nbs.append((nr, nc))
            adj[(r, c)] = nbs
        endpoints = [p for p, nbs in adj.items() if len(nbs) == 1]

        order = []
        if endpoints:
            start = sorted(endpoints)[0]
            order = [start]
            prev = None
            while True:
                cur = order[-1]
                nexts = [n for n in adj[cur] if n != prev]
                if not nexts:
                    break
                nxt = sorted(nexts)[0]
                order.append(nxt)
                prev = cur
                if len(order) > len(comp):
                    break
        else:
            start = sorted(comp)[0]
            order = [start]
            if adj[start]:
                nxt = sorted(adj[start])[0]
                order.append(nxt)
                prev = start
                cur = nxt
                while True:
                    nexts = [n for n in adj[cur] if n != prev]
                    if not nexts:
                        break
                    nxt = sorted(nexts)[0]
                    if nxt == start:
                        break
                    order.append(nxt)
                    prev, cur = cur, nxt

        for i, (r, c) in enumerate(order):
            if i < len(order) - 1:
                nr, nc = order[i + 1]
                dr, dc = nr - r, nc - c
            elif i > 0:
                pr, pc = order[i - 1]
                dr, dc = r - pr, c - pc
            else:
                dr, dc = 0, 1
            dir_idx = dir_map.get((dr, dc), 0)
            val = orig[r][c]
            if val == 5:
                dir_idx = (dir_idx + 1) % 4
            elif val == 7:
                dir_idx = (dir_idx + 2) % 4
            if val not in (5, 7, 9):
                out[r][c] = dir_to_color[dir_idx]

    # fill enclosed zero regions (loop interiors) with color 3
    blocked = set((r, c) for r in range(h) for c in range(w) if orig[r][c] != 0)
    reachable = set()
    dq = deque()
    for r in range(h):
        for c in range(w):
            if (r in (0, h - 1) or c in (0, w - 1)) and orig[r][c] == 0:
                reachable.add((r, c))
                dq.append((r, c))
    while dq:
        rr, cc = dq.popleft()
        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
            nr, nc = rr + dr, cc + dc
            if 0 <= nr < h and 0 <= nc < w and (nr, nc) not in reachable and (nr, nc) not in blocked:
                reachable.add((nr, nc))
                dq.append((nr, nc))
    for r in range(h):
        for c in range(w):
            if orig[r][c] == 0 and (r, c) not in reachable:
                out[r][c] = 3

    # draw bridges between anchors
    anchors = [(r, c) for r in range(h) for c in range(w) if orig[r][c] == 9]
    from collections import defaultdict
    by_row = defaultdict(list)
    by_col = defaultdict(list)
    for r, c in anchors:
        by_row[r].append(c)
        by_col[c].append(r)
    for r, cols in by_row.items():
        cols_sorted = sorted(cols)
        for i in range(len(cols_sorted) - 1):
            c1, c2 = cols_sorted[i], cols_sorted[i + 1]
            corridor_ok = True
            for cc in range(min(c1, c2), max(c1, c2) + 1):
                if orig[r][cc] not in (0, 9):
                    corridor_ok = False
                    break
            if corridor_ok:
                for cc in range(min(c1, c2), max(c1, c2) + 1):
                    if out[r][cc] == 0:
                        out[r][cc] = 8
    for c, rows in by_col.items():
        rows_sorted = sorted(rows)
        for i in range(len(rows_sorted) - 1):
            r1, r2 = rows_sorted[i], rows_sorted[i + 1]
            corridor_ok = True
            for rr in range(min(r1, r2), max(r1, r2) + 1):
                if orig[rr][c] not in (0, 9):
                    corridor_ok = False
                    break
            if corridor_ok:
                for rr in range(min(r1, r2), max(r1, r2) + 1):
                    if out[rr][c] == 0:
                        out[rr][c] = 8

    # diagonal staircase of 2x2 blocks from bottom-left; fill only empty cells
    special_count = sum(1 for r in range(h) for c in range(w) if orig[r][c] in (5, 7))
    offset = special_count % 3
    color_cycle = [1, 2, 3]
    i = 0
    while True:
        bottom = h - 1 - 2 * i
        top = bottom - 1
        left = 2 * i
        right = left + 1
        if top < 0 or right >= w:
            break
        color = color_cycle[(offset + i) % 3]
        for rr in (top, bottom):
            for cc in (left, right):
                if out[rr][cc] == 0:
                    out[rr][cc] = color
        i += 1

    return out

