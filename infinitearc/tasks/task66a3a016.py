# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 66a3a016
Difficulty: medium

=== Tags ===
- Divide by n
- Measure area

=== Description ===
The task involves transforming an input grid into an output grid by analyzing
connected regions and applying a division operation based on their area. The
input grid consists of a 2D arrangement of colors (0–9), where non-zero values
form connected regions (adjacent horizontally or vertically, ignoring 0). Each
region's area (number of cells) must be divisible by a fixed integer *n* (e.g.,
*n* = 2 for this task). The output grid replaces every cell within a region with
the value (region area ÷ *n*), resulting in a grid where each cell’s value
reflects the scaled-down size of its original region. For example, a region of 6
cells with *n* = 2 becomes 3 in the output. The transformation is visual,
relying solely on region shape and size—*not* the original color values—and
ensures the output grid differs from the input by modifying at least one cell.
The difficulty arises from correctly identifying all regions, measuring their
areas, and performing consistent division, requiring careful abstraction over
the grid structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    n = 2
    while True:
        width = common.randint(1, 30)
        height = common.randint(1, 30)
        if width * height >= 2:
            break
    max_size = width * height
    max_possible = min(max_size, 18)
    possible_sizes = [s for s in range(2, max_possible + 1, 2)]
    if not possible_sizes:
        possible_sizes = [2]
    size = common.choice(possible_sizes)
    pixels = common.continuous_creature(size, width, height)
    input_grid = common.grid(width, height, 0)
    exclude = [size // n]
    color = common.random_color(exclude=exclude)
    for r, c in pixels:
        input_grid[r][c] = color
    output_grid = common.grid(width, height, 0)
    for r, c in pixels:
        output_grid[r][c] = size // n
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    n = 2
    height = len(input_grid)
    width = len(input_grid[0])
    visited = [[False] * width for _ in range(height)]
    output_grid = common.grid(width, height, 0)
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and input_grid[r][c] != 0:
                region = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    region.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] != 0:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                area = len(region)
                val = area // n
                for (rr, rc) in region:
                    output_grid[rr][rc] = val
    return output_grid
