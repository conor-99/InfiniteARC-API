# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 8b6046f8
Difficulty: hard

=== Tags ===
- Bridges
- Grid overlay blending
- Pattern rotation

=== Description ===
Input grids feature a single continuous bridge structure (horizontal or
vertical) of a uniform color connecting two opposite edges, surrounded by a
background of a different color. Scattered in the top-left quadrant is a
distinct 2x2 pattern block containing four unique colors arranged in a fixed
grid. The output grid transforms the input by rotating the 2x2 pattern block 90
degrees clockwise, then applying the rotated pattern's colors in sequence to the
bridge structure. Specifically, each cell along the bridge (starting from the
edge it connects) is replaced with the corresponding color from the rotated
pattern, cycling through the four colors repeatedly as the bridge extends. Non-
bridge areas, including the original pattern location, remain visually
unchanged. The rotation direction is fixed (clockwise), and the pattern
application follows the bridge's path without overlap or modification to other
grid elements.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Dimensions
    width = random.randint(3, 30)
    height = random.randint(3, 30)

    # Background and bridge colors (distinct)
    bg = random.randint(0, 9)
    bridge = random.randint(0, 9)
    while bridge == bg:
        bridge = random.randint(0, 9)

    # Orientation of the bridge
    is_horizontal = random.choice([True, False])

    # Choose 4 unique pattern colors that are different from bg and bridge
    available = [c for c in range(10) if c not in (bg, bridge)]
    pattern_colors = random.sample(available, 4)
    tl, tr, bl, br = pattern_colors

    # Create input grid with background
    ingrid = grid(width, height, bg)

    # Place the 2x2 pattern in the top-left corner
    ingrid[0][0] = tl
    ingrid[0][1] = tr
    ingrid[1][0] = bl
    ingrid[1][1] = br

    # Place the continuous bridge (guarantee it does not overlap the pattern)
    if is_horizontal:
        # choose a row >= 2 so the 2x2 top-left pattern isn't touched
        y = random.randint(2, height - 1)
        for c in range(width):
            ingrid[y][c] = bridge
    else:
        # choose a column >= 2 so the 2x2 top-left pattern isn't touched
        x = random.randint(2, width - 1)
        for r in range(height):
            ingrid[r][x] = bridge

    # Build output by rotating the 2x2 pattern clockwise and applying its colors
    # rotated 2x2 clockwise = [[bl, tl], [br, tr]]
    seq = [bl, tl, br, tr]  # flattened row-major order after rotation

    outgrid = [row[:] for row in ingrid]
    if is_horizontal:
        for c in range(width):
            outgrid[y][c] = seq[c % 4]
    else:
        for r in range(height):
            outgrid[r][x] = seq[r % 4]

    return {"input": ingrid, "output": outgrid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import Counter

def p(input_grid):
    # Convert input (tuple of tuples) to a mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Find the background color (most common color)
    counts = Counter()
    for r in range(height):
        for c in range(width):
            counts[grid[r][c]] += 1
    bg_color = counts.most_common(1)[0][0]

    # Identify the bridge color by frequency: it should appear exactly width (horizontal)
    # or height (vertical) times (the rest of non-background colors are the 2x2 pattern)
    bridge_color = None
    orientation = None
    for color, cnt in counts.items():
        if color == bg_color:
            continue
        if cnt == width:
            bridge_color = color
            orientation = 'h'
            break
        if cnt == height:
            bridge_color = color
            orientation = 'v'
            break

    # Fallback: detect a uniform row or column with a color different from background
    if bridge_color is None:
        for r in range(height):
            rowvals = set(grid[r])
            if len(rowvals) == 1 and next(iter(rowvals)) != bg_color:
                bridge_color = next(iter(rowvals))
                orientation = 'h'
                break
        if bridge_color is None:
            for c in range(width):
                colvals = set(grid[r][c] for r in range(height))
                if len(colvals) == 1 and next(iter(colvals)) != bg_color:
                    bridge_color = next(iter(colvals))
                    orientation = 'v'
                    break

    # Read the top-left 2x2 pattern
    tl = grid[0][0]
    tr = grid[0][1]
    bl = grid[1][0]
    br = grid[1][1]

    # Rotated clockwise flattened row-major
    seq = [bl, tl, br, tr]

    output = [row[:] for row in grid]
    if orientation == 'h':
        # find the row index of the bridge
        y = None
        for r in range(height):
            if all(output[r][c] == bridge_color for c in range(width)):
                y = r
                break
        if y is None:
            # fallback: pick the row with the most bridge_color occurrences
            y = max(range(height), key=lambda r: sum(1 for c in range(width) if output[r][c] == bridge_color))
        for c in range(width):
            output[y][c] = seq[c % 4]
    else:
        # find the column index of the bridge
        x = None
        for c in range(width):
            if all(output[r][c] == bridge_color for r in range(height)):
                x = c
                break
        if x is None:
            x = max(range(width), key=lambda c: sum(1 for r in range(height) if output[r][c] == bridge_color))
        for r in range(height):
            output[r][x] = seq[r % 4]

    return output

