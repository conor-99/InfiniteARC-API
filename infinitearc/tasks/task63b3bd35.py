# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 63b3bd35
Difficulty: insane

=== Tags ===
- Transformation stack
- Pattern intersection
- Recolor smallest component

=== Description ===
Input grids contain multiple overlapping connected patterns of distinct colors,
each pattern being a 4-connected region of a single color. The smallest pattern
(by cell count; ties resolved by row-major order of first cell) is recolored to
a new color not present in the input. Then, a transformation stack is applied:
for each pattern larger than the smallest, the pattern is rotated 90 degrees
clockwise if it is the nth largest pattern where n is even, otherwise rotated
counterclockwise. The output grid displays all patterns with the smallest
recolored and all larger patterns rotated according to this stack rule,
preserving all intersections and connectivity.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 20)
    height = random.randint(5, 20)
    grid = [[0] * width for _ in range(height)]
    
    # Place single cell at top-left
    grid[0][0] = 1
    
    # Place 2x2 block in center
    start_r2 = max(0, height // 2 - 1)
    start_c2 = max(0, width // 2 - 1)
    for r in range(start_r2, start_r2 + 2):
        for c in range(start_c2, start_c2 + 2):
            if r < height and c < width:
                grid[r][c] = 2
    
    # Place 3x3 block in bottom-right
    start_r3 = max(0, height - 4)
    start_c3 = max(0, width - 4)
    for r in range(start_r3, start_r3 + 3):
        for c in range(start_c3, start_c3 + 3):
            if r < height and c < width:
                grid[r][c] = 3
    
    visited = [[False] * width for _ in range(height)]
    components = []
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and grid[r][c] != 0:
                color = grid[r][c]
                stack = [(r, c)]
                comp = []
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    comp.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append((color, comp))
    
    components.sort(key=lambda x: (len(x[1]), x[1][0][0], x[1][0][1]))
    smallest_color, smallest_comp = components[0]
    
    existing_colors = set()
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                existing_colors.add(grid[r][c])
    new_color = 4
    while new_color in existing_colors:
        new_color += 1
    if new_color > 9:
        new_color = 4
    
    output = [row[:] for row in grid]
    for (r, c) in smallest_comp:
        output[r][c] = new_color
    
    larger_components = components[1:]
    larger_components.sort(key=lambda x: len(x[1]), reverse=True)
    
    for idx, (color, comp) in enumerate(larger_components, start=1):
        if idx % 2 == 0:
            rotated_comp = [(c, height - 1 - r) for (r, c) in comp]
        else:
            rotated_comp = [(height - 1 - c, r) for (r, c) in comp]
        
        for (r, c) in rotated_comp:
            if 0 <= r < height and 0 <= c < width:
                output[r][c] = color
        for (r, c) in comp:
            output[r][c] = 0
    
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    visited = [[False] * width for _ in range(height)]
    components = []
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and grid[r][c] != 0:
                color = grid[r][c]
                stack = [(r, c)]
                comp = []
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    comp.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append((color, comp))
    
    components.sort(key=lambda x: (len(x[1]), x[1][0][0], x[1][0][1]))
    smallest_color, smallest_comp = components[0]
    
    existing_colors = set()
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                existing_colors.add(grid[r][c])
    new_color = 4
    while new_color in existing_colors:
        new_color += 1
    if new_color > 9:
        new_color = 4
    
    output = [row[:] for row in grid]
    for (r, c) in smallest_comp:
        output[r][c] = new_color
    
    larger_components = components[1:]
    larger_components.sort(key=lambda x: len(x[1]), reverse=True)
    
    for idx, (color, comp) in enumerate(larger_components, start=1):
        if idx % 2 == 0:
            rotated_comp = [(c, height - 1 - r) for (r, c) in comp]
        else:
            rotated_comp = [(height - 1 - c, r) for (r, c) in comp]
        
        for (r, c) in rotated_comp:
            if 0 <= r < height and 0 <= c < width:
                output[r][c] = color
        for (r, c) in comp:
            output[r][c] = 0
    
    return output
