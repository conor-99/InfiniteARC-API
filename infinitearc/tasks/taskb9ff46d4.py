# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: b9ff46d4
Difficulty: hard

=== Tags ===
- Layered occlusion unfolding
- Substitution rule discovery
- Associate images to bools

=== Description ===
The task involves input grids composed of a dominant background color (the most
frequent color in the grid) and one or more foreground colors that occlude parts
of the background. The output grid is a binary transformation where cells
matching the background color are set to 1 (indicating the underlying background
layer is revealed), and all other cells (foreground occlusions) are set to 0.
The substitution rule requires identifying the background color as the mode of
the input grid, then replacing all non-mode values with 0 while converting the
mode to 1. This rule is not immediately obvious from the input grids and
requires discovering that the background layer corresponds to the most frequent
color, followed by applying a binary substitution to associate the background
regions with true (1) and occlusions with false (0). The transformation
demonstrates layered occlusion unfolding by revealing the underlying structure
through statistical analysis of pixel frequencies.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    while True:
        width = random.randint(1, 30)
        height = random.randint(1, 30)
        if width * height >= 3:
            break
    b = random.randint(0, 9)
    input_grid = common.grid(width, height, b)
    total_cells = width * height
    max_k = (total_cells - 1) // 2
    k = random.randint(1, max_k)
    
    all_pixels = [(r, c) for r in range(height) for c in range(width)]
    selected = random.sample(all_pixels, k)
    
    available_colors = [c for c in range(10) if c != b]
    for r, c in selected:
        input_grid[r][c] = random.choice(available_colors)
    
    output_grid = [[1 if cell == b else 0 for cell in row] for row in input_grid]
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    flat = [cell for row in input_grid for cell in row]
    mode = max(set(flat), key=flat.count)
    return [[1 if cell == mode else 0 for cell in row] for row in input_grid]
