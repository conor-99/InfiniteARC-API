# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: e1ee2d9b
Difficulty: medium–hard

=== Tags ===
- Intersecting currents
- Diagonal weaving
- Mask based logic
- Cooperative rule network
- Associate colors to colors

=== Description ===
Input grids consist of 15×15 to 30×30 matrices with a background color (0) and
two distinct diagonal line patterns moving in perpendicular directions—top-left
to bottom-right (currents A) and top-right to bottom-left (currents B)—each
using unique non-background colors (1–8). These lines intersect at grid points
marked by a dedicated mask color (9), which serves as the sole indicator of
intersections where the two diagonal currents cross. The mask color (9) appears
only at intersection points, never overlapping with the current colors.   The
output grid transforms the input by replacing each mask cell (color 9) with a
new color derived from a consistent color association rule. This rule maps the
two intersecting current colors (A and B) to a single target color (C) based on
a predefined, invisible mapping (e.g., color 1 + color 2 → color 3). The
transformation is applied only to mask cells, leaving all other grid
elements—including the diagonal line patterns and background—unchanged. The
association rule must be inferred through pattern recognition across input-
output pairs, requiring the solver to identify consistent color mappings at
intersections while ignoring non-masking grid elements. The task demands
simultaneous tracking of two diagonal patterns, precise identification of
intersection points via mask color, and application of a relational color
mapping, making it medium-hard due to the need for multi-step visual inference
without explicit rule hints.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    size = random.randint(15, 30)
    bg = 0
    a = random.randint(1, 8)
    b = random.randint(1, 8)
    while b == a:
        b = random.randint(1, 8)
    
    grid_in = [[bg] * size for _ in range(size)]
    
    # Choose k_offsets (for A lines: row - col = k)
    k_offsets = [0, 2]
    
    # Choose m_offsets (for B lines: row + col = m) based on size parity
    if size % 2 == 1:
        m_offsets = [size - 1, size - 3]
    else:
        m_offsets = [size - 2, size - 4]
    
    # Fill grid_in
    for r in range(size):
        for c in range(size):
            if (r - c) in k_offsets and (r + c) in m_offsets:
                grid_in[r][c] = 9
            elif (r - c) in k_offsets:
                grid_in[r][c] = a
            elif (r + c) in m_offsets:
                grid_in[r][c] = b
    
    # Compute c = ((a + b - 1) % 8) + 1
    c = ((a + b - 1) % 8) + 1
    
    # Create output grid by replacing 9 with c
    grid_out = [[c if cell == 9 else cell for cell in row] for row in grid_in]
    
    return {"input": grid_in, "output": grid_out}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    colors = set()
    for row in grid:
        for cell in row:
            if cell != 0 and cell != 9:
                colors.add(cell)
    a, b = list(colors)
    c = ((a + b - 1) % 8) + 1
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 9:
                grid[i][j] = c
    return tuple(tuple(row) for row in grid)
