# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 6c784f4f
Difficulty: hard

=== Tags ===
- Pattern translation
- Motif extraction
- Connect all dots of same color
- Mark extrema corners

=== Description ===
**Task Description: Extrema Corner Mapping**    **Grid Type:** Input grids are
5×5 to 30×30 matrices containing values 0–9, where 0 represents background. Non-
background colors (1–9) form distinct, connected clusters (each cluster is a
single color with adjacent cells sharing the same value). Clusters may be
irregular in shape but are always fully enclosed by background or grid edges.
**Transformation Rules:**   1. **Motif Extraction:** For each non-background
color cluster, identify all cells belonging to that cluster.   2. **Pattern
Translation:** Compute the minimal axis-aligned bounding box for each cluster,
defined by the topmost, bottommost, leftmost, and rightmost cells of the
cluster. The bounding box’s four corners are:      - Top-left: (min_row,
min_col)      - Top-right: (min_row, max_col)      - Bottom-left: (max_row,
min_col)      - Bottom-right: (max_row, max_col)   3. **Corner Marking:** In the
output grid, retain all input cells unchanged except for the four bounding box
corners of every cluster. Replace each corner cell with a fixed marker color
(e.g., color 9). If multiple clusters share a corner, the marker is applied once
(order of processing does not affect the result).    **Output Grid:** The output
grid matches the input grid, with all cluster bounding box corners marked as the
fixed marker color. Background (0) and non-corner cells remain unchanged.
**Complexity:** The task demands precise boundary detection across multiple
overlapping clusters, handling edge cases (e.g., clusters spanning the grid
edge), and avoiding overwriting non-corner cells. Difficulty arises from the
need to process all clusters sequentially, resolve corner overlaps, and
distinguish between background and marker color without visual cues (e.g.,
relying solely on spatial relationships).
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = [[0 for _ in range(width)] for _ in range(height)]

    # Choose number of clusters (colors) to place
    max_clusters = min(6, 8, width * height // 4)
    if max_clusters < 1:
        max_clusters = 1
    num_clusters = random.randint(1, max_clusters)

    # Choose distinct cluster colors excluding the marker color 9
    colors = common.random_colors(num_clusters, exclude=[9])

    clusters = []  # list of (color, list_of_pixels)

    for color in colors:
        placed = False
        # Try a few times to place a non-overlapping connected sprite
        for _ in range(60):
            # Make a small bounding box for the sprite so shapes are reasonably sized
            mini_w = random.randint(1, min(6, width))
            mini_h = random.randint(1, min(6, height))
            area = mini_w * mini_h
            if area <= 0:
                continue
            size = random.randint(1, area)
            sprite = common.continuous_creature(size, width=mini_w, height=mini_h)
            # choose an offset so sprite fits in the full grid
            max_row_off = height - mini_h
            max_col_off = width - mini_w
            row_off = random.randint(0, max_row_off) if max_row_off > 0 else 0
            col_off = random.randint(0, max_col_off) if max_col_off > 0 else 0
            placed_pixels = [(r + row_off, c + col_off) for (r, c) in sprite]
            # check overlap
            overlap = False
            for r, c in placed_pixels:
                if grid[r][c] != 0:
                    overlap = True
                    break
            if overlap:
                continue
            # place sprite
            for r, c in placed_pixels:
                grid[r][c] = color
            clusters.append((color, placed_pixels))
            placed = True
            break
        # If placement failed for this color, skip it
        if not placed:
            continue

    # Ensure we have at least one cluster
    if len(clusters) == 0:
        # Force a single pixel cluster in the center
        rr = height // 2
        cc = width // 2
        color = common.random_color(exclude=[9])
        grid[rr][cc] = color
        clusters.append((color, [(rr, cc)]))

    # Build output by copying input and marking corners with color 9
    output = [row[:] for row in grid]
    for _, pixels in clusters:
        rows = [p[0] for p in pixels]
        cols = [p[1] for p in pixels]
        min_r, max_r = min(rows), max(rows)
        min_c, max_c = min(cols), max(cols)
        corners = [(min_r, min_c), (min_r, max_c), (max_r, min_c), (max_r, max_c)]
        for r, c in corners:
            output[r][c] = 9

    # Make sure input != output (should be the case because we never used color 9 in input)
    if grid == output:
        # Very unlikely; regenerate
        return generate()

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0
    output = [row[:] for row in grid]
    # collect distinct non-background, non-marker colors present in input
    colors = set()
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if v != 0 and v != 9:
                colors.add(v)
    for color in colors:
        rows = []
        cols = []
        for r in range(height):
            for c in range(width):
                if grid[r][c] == color:
                    rows.append(r)
                    cols.append(c)
        if not rows:
            continue
        min_r, max_r = min(rows), max(rows)
        min_c, max_c = min(cols), max(cols)
        corners = [(min_r, min_c), (min_r, max_c), (max_r, min_c), (max_r, max_c)]
        for r, c in corners:
            output[r][c] = 9
    return output

