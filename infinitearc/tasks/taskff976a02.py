# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: ff976a02
Difficulty: medium

=== Tags ===
- Color by rank in row
- Detect connectedness
- Count hor lines

=== Description ===
The task involves transforming an input grid into an output grid by analyzing
horizontal runs of identical colors within each row. For each row, consecutive
cells of the same color form a horizontal run, and these runs are ranked left-
to-right (rank 1 for the leftmost run, rank 2 for the next, etc.). The output
grid is constructed by replacing every cell in a run with its corresponding rank
(e.g., rank 1 becomes color 1, rank 2 becomes color 2, etc.). Additionally, the
task requires detecting connected regions (4-connected components) across the
entire grid, where connected regions of the same color are identified as
distinct objects. The count of horizontal runs (referred to as "hor lines")
across all rows is used to validate the solution's consistency but does not
directly influence the color transformation. The output grid thus encodes the
rank of each horizontal run within its row while ensuring that connected regions
of the same color in the input correspond to consistent rank patterns in the
output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    input_grid = []
    for _ in range(height):
        R = random.randint(1, 9)
        R = min(R, width)
        if R == 1:
            run_lengths = [width]
        else:
            splits = sorted(random.sample(range(1, width), R-1))
            run_lengths = [splits[0]] + [splits[i] - splits[i-1] for i in range(1, len(splits))] + [width - splits[-1]]
        colors = []
        prev = None
        for _ in range(R):
            color = random.randint(0, 9)
            while color == prev:
                color = random.randint(0, 9)
            colors.append(color)
            prev = color
        row = []
        for i in range(R):
            row.extend([colors[i]] * run_lengths[i])
        input_grid.append(row)
    
    output_grid = []
    for row in input_grid:
        new_row = []
        current = None
        rank = 0
        for c in row:
            if c != current:
                rank += 1
                current = c
            new_row.append(rank)
        output_grid.append(new_row)
    
    if input_grid == output_grid:
        return generate()
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    output = []
    for row in input_grid:
        current = None
        rank = 0
        new_row = []
        for c in row:
            if c != current:
                rank += 1
                current = c
            new_row.append(rank)
        output.append(new_row)
    return output
