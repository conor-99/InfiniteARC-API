# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: a59ce91d
Difficulty: hard

=== Tags ===
- Signal tracing
- Draw pattern from point
- Color stream

=== Description ===
Input grids are rectangular (1×1 to 30×30) with a background color (0). The grid
contains a sequence of distinct non-background cells with colors 1 through N
(each color appearing exactly once), where N ≥ 1. This sequence starts at color
1 and increments by 1 for each subsequent color. The sequence cells are not
necessarily adjacent in the input grid and may be separated by background or
other non-sequence non-background cells. The input may contain additional non-
background cells with colors outside the sequence (e.g., color 5 when sequence
is 1-3).  The output grid is generated by drawing the shortest possible path
(using horizontal and vertical moves only) between each consecutive pair of
sequence cells (from color k to color k+1 for k = 1 to N-1). These paths are
drawn using color 1, overwriting only background cells (0), and must avoid all
non-background cells (including sequence cells themselves). The original
sequence cells, all other non-background cells, and the background remain
unchanged except for the newly drawn paths. The sequence must be sorted by color
value (1, 2, 3, ..., N), and the output must draw continuous paths connecting
these sorted cells in order.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

from collections import deque
import random

# Generator for ARC task: draw shortest background paths connecting sequence colored cells 1..N
# This generator builds an input grid (with sequence and random obstacles) and then
# uses the same deterministic solver logic to produce the corresponding output grid.


def _find_shortest_background_path(grid, start, end):
    """BFS that finds the shortest path composed only of background cells (value 0)
    that connects a neighbor of start to a neighbor of end. Returns list of coords
    (row,col) or None. The neighbor exploration order is fixed for determinism.
    """
    h = len(grid)
    w = len(grid[0])
    sr, sc = start
    er, ec = end
    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # consistent order

    visited = [[False] * w for _ in range(h)]
    prev = {}
    q = deque()

    # Start from background neighbors of the start cell
    for dr, dc in dirs:
        nr, nc = sr + dr, sc + dc
        if 0 <= nr < h and 0 <= nc < w and grid[nr][nc] == 0:
            visited[nr][nc] = True
            prev[(nr, nc)] = None
            q.append((nr, nc))

    target = None
    while q:
        r, c = q.popleft()
        # If this background cell is adjacent to the end, we've connected the two
        if abs(r - er) + abs(c - ec) == 1:
            target = (r, c)
            break
        for dr, dc in dirs:
            nr, nc = r + dr, c + dc
            if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] == 0:
                visited[nr][nc] = True
                prev[(nr, nc)] = (r, c)
                q.append((nr, nc))

    if target is None:
        return None

    # Reconstruct path from target back to the first neighbor
    path = []
    cur = target
    while cur is not None:
        path.append(cur)
        cur = prev[cur]
    path.reverse()
    return path


def _solve_grid(grid):
    """Deterministic solver logic used by both generator and final solver.
    Takes a list-of-lists grid (input) and returns a list-of-lists output grid.
    """
    h = len(grid)
    w = len(grid[0])

    # Count occurrences of colors 1..9 to determine the sequence length N (1..N each appear exactly once)
    counts = [0] * 10
    positions = {}
    for r in range(h):
        for c in range(w):
            v = grid[r][c]
            if 1 <= v <= 9:
                counts[v] += 1
                if counts[v] == 1:
                    positions[v] = (r, c)

    # Determine N as the largest k such that colors 1..k each appear exactly once
    N = 0
    for k in range(1, 10):
        if counts[k] == 1:
            N = k
        else:
            break

    # If sequence length is 0 or 1, nothing to draw
    if N <= 1:
        return [row[:] for row in grid]

    seq_positions = [positions[k] for k in range(1, N + 1)]

    output = [row[:] for row in grid]

    # For each consecutive pair, find shortest background-only path and draw it with color 1
    for i in range(len(seq_positions) - 1):
        start = seq_positions[i]
        end = seq_positions[i + 1]
        path = _find_shortest_background_path(grid, start, end)
        if path:
            for (r, c) in path:
                if grid[r][c] == 0:
                    output[r][c] = 1

    return output


def generate():
    # Random grid size (varied but reasonable)
    width = random.randint(6, 20)
    height = random.randint(6, 20)

    # Sequence length N (colors 1..N)
    N = random.randint(2, 5)

    # Choose sequence positions ensuring consecutive sequence cells are not adjacent
    positions = []
    attempts_pos = 0
    while len(positions) < N and attempts_pos < 2000:
        attempts_pos += 1
        r = random.randrange(height)
        c = random.randrange(width)
        if (r, c) in positions:
            continue
        if positions and (abs(r - positions[-1][0]) + abs(c - positions[-1][1])) < 2:
            # ensure at least one background cell between consecutive sequence cells
            continue
        positions.append((r, c))

    # If we failed to find a full set of spaced positions, fall back to scanning
    if len(positions) < N:
        positions = []
        all_cells = [(r, c) for r in range(height) for c in range(width)]
        random.shuffle(all_cells)
        for (r, c) in all_cells:
            if len(positions) == 0:
                positions.append((r, c))
            else:
                pr, pc = positions[-1]
                if abs(r - pr) + abs(c - pc) >= 2:
                    positions.append((r, c))
            if len(positions) >= N:
                break

    # Place the sequence colors on a fresh grid
    base_grid = [[0 for _ in range(width)] for _ in range(height)]
    for i, (r, c) in enumerate(positions):
        base_grid[r][c] = i + 1

    # Colors available for obstacles (must be outside the sequence 1..N)
    obstacle_colors = [c for c in range(1, 10) if c not in range(1, N + 1)]

    # Try placing random obstacles and ensure shortest-paths exist on that resulting grid
    max_obstacle_attempts = 200
    obstacle_attempts = 0
    final_grid = None

    while obstacle_attempts < max_obstacle_attempts:
        obstacle_attempts += 1
        grid = [row[:] for row in base_grid]

        # Choose obstacle positions randomly from the free cells (not sequence cells)
        free_cells = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == 0]
        if not free_cells:
            break

        max_obs = max(0, int(len(free_cells) * 0.20))
        obs_count = random.randint(0, max_obs) if max_obs > 0 else 0
        obs_positions = random.sample(free_cells, obs_count) if obs_count > 0 else []

        for (r, c) in obs_positions:
            grid[r][c] = random.choice(obstacle_colors)

        # Verify that all consecutive pairs have a valid background path
        failed = False
        for i in range(len(positions) - 1):
            start = positions[i]
            end = positions[i + 1]
            path = _find_shortest_background_path(grid, start, end)
            if path is None:
                failed = True
                break

        if not failed:
            final_grid = grid
            break

    if final_grid is None:
        # Fallback to obstacle-free base grid
        final_grid = [row[:] for row in base_grid]

    inp = [row[:] for row in final_grid]
    out = _solve_grid(inp)

    # Ensure outputs are lists of lists (not tuples)
    return {"input": inp, "output": [row[:] for row in out]}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def _find_shortest_background_path(grid, start, end):
    """BFS that finds the shortest path composed only of background cells (value 0)
    that connects a neighbor of start to a neighbor of end. Returns list of coords
    (row,col) or None. The neighbor exploration order matches the generator.
    """
    h = len(grid)
    w = len(grid[0])
    sr, sc = start
    er, ec = end
    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]

    visited = [[False] * w for _ in range(h)]
    prev = {}
    q = deque()

    # Seed queue with background neighbors of the start
    for dr, dc in dirs:
        nr, nc = sr + dr, sc + dc
        if 0 <= nr < h and 0 <= nc < w and grid[nr][nc] == 0:
            visited[nr][nc] = True
            prev[(nr, nc)] = None
            q.append((nr, nc))

    target = None
    while q:
        r, c = q.popleft()
        if abs(r - er) + abs(c - ec) == 1:
            target = (r, c)
            break
        for dr, dc in dirs:
            nr, nc = r + dr, c + dc
            if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] == 0:
                visited[nr][nc] = True
                prev[(nr, nc)] = (r, c)
                q.append((nr, nc))

    if target is None:
        return None

    # Reconstruct path from target back to start-neighbor
    path = []
    cur = target
    while cur is not None:
        path.append(cur)
        cur = prev[cur]
    path.reverse()
    return path


def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])

    # Count occurrences of colors 1..9 to determine the sequence length N (1..N each appear exactly once)
    counts = [0] * 10
    positions = {}
    for r in range(h):
        for c in range(w):
            v = grid[r][c]
            if 1 <= v <= 9:
                counts[v] += 1
                # store last seen position (only valid if count==1 for sequence colors)
                if counts[v] == 1:
                    positions[v] = (r, c)

    # Determine N as the largest k such that colors 1..k each appear exactly once
    N = 0
    for k in range(1, 10):
        if counts[k] == 1:
            N = k
        else:
            break

    # If no sequence or only single cell, nothing to draw
    if N <= 1:
        return tuple(tuple(row) for row in grid)

    # Collect sequence positions in order
    seq_positions = [positions[k] for k in range(1, N + 1)]

    # Prepare output copy
    output = [row[:] for row in grid]

    # For each consecutive pair, find shortest background-only path and draw it with color 1
    for i in range(len(seq_positions) - 1):
        start = seq_positions[i]
        end = seq_positions[i + 1]
        path = _find_shortest_background_path(grid, start, end)
        if path:
            for (r, c) in path:
                # overwrite only background cells
                if grid[r][c] == 0:
                    output[r][c] = 1

    return tuple(tuple(row) for row in output)

