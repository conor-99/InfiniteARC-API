# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: a58c9326
Difficulty: hard

=== Tags ===
- Directional routing
- Color carving
- Recursive agent following

=== Description ===
Input grids consist of a 15×15 grid with a uniform background color (e.g.,
black) and multiple "wall" structures formed by contiguous regions of solid
color (non-background), each wall segment being 1-3 cells thick and oriented
horizontally or vertically. Scattered throughout the grid are "agent" cells
(single cells of distinct colors) positioned such that their initial movement
direction is determined by their color: color 1 moves right, color 2 moves up,
color 3 moves left, color 4 moves down, color 5 moves up-right, color 6 moves
down-right, color 7 moves down-left, and color 8 moves up-left.   The
transformation process begins by simulating each agent's movement path. Agents
move one cell at a time in their current direction. If the next cell is
background (black), it is carved (changed to the agent's current color) and the
agent continues moving. If the next cell is a wall (non-background), the agent
reflects by turning 90 degrees left (e.g., right → up, up → left, up-right →
right, etc.), adopts the wall's color, and continues without moving into the
wall cell. This reflection and color change occur at every wall collision. The
agent continues this process until it exits the grid boundary.  The output grid
preserves all original walls and background, but replaces every background cell
traversed by any agent with the color the agent held at the moment of traversal.
Agents' starting positions remain unchanged as they originate on non-background
cells. The carving paths are continuous and never overlap with walls or other
paths, with each agent's color evolving dynamically through reflections. The
final grid reveals a complex, recursive pattern where the visual "carving"
follows the agents' reflection history, creating layered color transitions that
depend on the sequence of wall interactions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = 15
    height = 15
    bg = 0

    # Predefined direction and reflection maps (used only for simulation)
    directions = {
        1: (0, 1), 2: (-1, 0), 3: (0, -1), 4: (1, 0),
        5: (-1, 1), 6: (1, 1), 7: (1, -1), 8: (-1, -1)
    }
    # Reflection = rotate 90 degrees left of the given color's direction
    reflect_map = {1: 2, 2: 3, 3: 4, 4: 1, 5: 8, 8: 7, 7: 6, 6: 5}

    # Try generating until a valid configuration is produced.
    # We guard against infinite loops by limiting attempts.
    attempts = 0
    while True:
        attempts += 1
        if attempts > 200:
            # As a last resort, produce a very simple, valid example deterministically
            grid = [[bg for _ in range(width)] for _ in range(height)]
            # one horizontal wall and one agent
            for c in range(4, 10):
                grid[7][c] = 1
            grid[3][3] = 5
            # simulate
            output = [row[:] for row in grid]
            agents = [(3, 3, 5)]
            for r0, c0, color0 in sorted(agents):
                cur_r, cur_c = r0, c0
                cur_color = color0
                steps = 0
                while True:
                    steps += 1
                    if steps > 1000: break
                    dr, dc = directions[cur_color]
                    nr, nc = cur_r + dr, cur_c + dc
                    if not (0 <= nr < height and 0 <= nc < width):
                        break
                    if output[nr][nc] == bg:
                        output[nr][nc] = cur_color
                        cur_r, cur_c = nr, nc
                    else:
                        wall_color = output[nr][nc]
                        cur_color = reflect_map[wall_color]
            return {"input": grid, "output": output}

        # start with empty background
        grid = [[bg for _ in range(width)] for _ in range(height)]

        # Place 4-7 straight wall segments (horizontal or vertical).
        seg_count = random.randint(4, 7)
        ok = True
        for _s in range(seg_count):
            placed = False
            # try a few times to place this segment without overlap
            for _try in range(60):
                orient = random.choice(["h", "v"])
                length = random.randint(3, 8)
                thickness = random.randint(1, 3)
                color = random.randint(1, 8)
                if orient == "h":
                    r0 = random.randint(0, height - thickness)
                    c0 = random.randint(0, width - length)
                    # check overlap
                    overlap = False
                    for rr in range(r0, r0 + thickness):
                        for cc in range(c0, c0 + length):
                            if grid[rr][cc] != bg:
                                overlap = True
                                break
                        if overlap:
                            break
                    if overlap:
                        continue
                    for rr in range(r0, r0 + thickness):
                        for cc in range(c0, c0 + length):
                            grid[rr][cc] = color
                    placed = True
                    break
                else:
                    c0 = random.randint(0, width - thickness)
                    r0 = random.randint(0, height - length)
                    overlap = False
                    for rr in range(r0, r0 + length):
                        for cc in range(c0, c0 + thickness):
                            if grid[rr][cc] != bg:
                                overlap = True
                                break
                        if overlap:
                            break
                    if overlap:
                        continue
                    for rr in range(r0, r0 + length):
                        for cc in range(c0, c0 + thickness):
                            grid[rr][cc] = color
                    placed = True
                    break
            if not placed:
                ok = False
                break
        if not ok:
            continue

        # Place 2-4 agents as isolated single cells (no 4-neighbor non-bg cells).
        agent_count = random.randint(2, 4)
        agents = []
        tries = 0
        while len(agents) < agent_count and tries < 1000:
            tries += 1
            r = random.randint(0, height - 1)
            c = random.randint(0, width - 1)
            if grid[r][c] != bg:
                continue
            isolated = True
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                rr, cc = r + dr, c + dc
                if 0 <= rr < height and 0 <= cc < width:
                    if grid[rr][cc] != bg:
                        isolated = False
                        break
            if not isolated:
                continue
            color = random.randint(1, 8)
            grid[r][c] = color
            agents.append((r, c, color))
        if len(agents) != agent_count:
            continue

        # Simulation: process agents in reading order so solver can reproduce the same order.
        agents_sorted = sorted(agents, key=lambda x: (x[0], x[1]))
        output = [row[:] for row in grid]
        all_good = True

        for r0, c0, color0 in agents_sorted:
            cur_r, cur_c = r0, c0
            cur_color = color0
            steps = 0
            max_steps = 1000
            while True:
                steps += 1
                if steps > max_steps:
                    all_good = False
                    break
                dr, dc = directions[cur_color]
                nr, nc = cur_r + dr, cur_c + dc
                # agent exits the grid
                if not (0 <= nr < height and 0 <= nc < width):
                    break
                if output[nr][nc] == bg:
                    output[nr][nc] = cur_color
                    cur_r, cur_c = nr, nc
                else:
                    # hit a wall or previously carved path
                    wall_color = output[nr][nc]
                    # adopt wall's color then reflect left relative to that color
                    if wall_color not in reflect_map:
                        all_good = False
                        break
                    cur_color = reflect_map[wall_color]
                    # do not move into the obstacle
            if not all_good:
                break

        if not all_good:
            continue

        # ensure we carved at least one background cell
        carved = False
        for rr in range(height):
            for cc in range(width):
                if grid[rr][cc] == bg and output[rr][cc] != bg:
                    carved = True
                    break
            if carved:
                break
        if not carved:
            continue

        return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input (tuple of tuples) to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    bg = 0

    # Direction mapping for colors 1..8
    directions = {
        1: (0, 1), 2: (-1, 0), 3: (0, -1), 4: (1, 0),
        5: (-1, 1), 6: (1, 1), 7: (1, -1), 8: (-1, -1)
    }
    # Reflection mapping: rotate 90 degrees left of the given color's direction
    reflect_map = {1: 2, 2: 3, 3: 4, 4: 1, 5: 8, 8: 7, 7: 6, 6: 5}

    # Find connected components (4-connected) of non-background cells.
    visited = [[False] * width for _ in range(height)]
    agents = []  # will store (r, c, color) for isolated single-cell components
    for r in range(height):
        for c in range(width):
            if grid[r][c] == bg or visited[r][c]:
                continue
            color = grid[r][c]
            stack = [(r, c)]
            comp = []
            visited[r][c] = True
            while stack:
                x, y = stack.pop()
                comp.append((x, y))
                for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                    nx, ny = x + dr, y + dc
                    if 0 <= nx < height and 0 <= ny < width and not visited[nx][ny] and grid[nx][ny] == color:
                        visited[nx][ny] = True
                        stack.append((nx, ny))
            if len(comp) == 1:
                agents.append((comp[0][0], comp[0][1], color))

    # Sort agents in reading order so the simulation order is deterministic and matches the generator.
    agents_sorted = sorted(agents, key=lambda x: (x[0], x[1]))

    output = [row[:] for row in grid]

    # Simulate each agent sequentially. Carvings from earlier agents become obstacles for later agents.
    for r0, c0, color0 in agents_sorted:
        cur_r, cur_c = r0, c0
        cur_color = color0
        steps = 0
        while True:
            steps += 1
            if steps > 1000:
                # safety break in case of pathological inputs
                break
            dr, dc = directions[cur_color]
            nr, nc = cur_r + dr, cur_c + dc
            if not (0 <= nr < height and 0 <= nc < width):
                # agent left the grid
                break
            if output[nr][nc] == bg:
                output[nr][nc] = cur_color
                cur_r, cur_c = nr, nc
            else:
                wall_color = output[nr][nc]
                # adopt wall color then reflect left relative to that color
                if wall_color not in reflect_map:
                    break
                cur_color = reflect_map[wall_color]
                # do not move into obstacle
    return output

