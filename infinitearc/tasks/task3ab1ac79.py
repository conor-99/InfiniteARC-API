# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 3ab1ac79
Difficulty: very hard

=== Tags ===
- Mask based logic
- Multi condition recolor

=== Description ===
# Masked Recolor Network  The input grid features a complex arrangement of
multiple distinct colored regions (each a connected component of a single non-
background color) on a uniform background. Each region is surrounded by a thin
border of a different color (not the region's color or the background), forming
a layered structure. The border color varies per region and is consistent across
all borders of that region.  The transformation requires identifying a "mask"
region: all background cells that are orthogonally adjacent to at least two
different border colors. These mask cells form a non-contiguous pattern that may
wrap around regions or connect through background gaps.   For each mask cell,
the output applies a multi-condition recolor rule based on the specific pair of
border colors it borders: - The border colors must be considered in clockwise
order (e.g., top-left border first) - A fixed color mapping is used where each
unique border pair corresponds to a specific output color (e.g., border colors 3
and 7 → output color 9, border colors 1 and 4 → output color 5) - If a mask cell
borders more than two border colors, the rule uses the two border colors that
appear most frequently in its neighborhood - Border colors are treated as
distinct identifiers (not numerical values), with the mapping determined solely
by their visual relationship  The output grid preserves all original regions,
borders, and background cells, with only the identified mask cells being
recolored according to the fixed pair mapping. The transformation requires
simultaneous detection of border regions, mask identification, and application
of the multi-condition color mapping, making it computationally intensive for
the solver to infer the correct mapping from minimal examples.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import continuous_creature

def _place_sprite_nonoverlapping(sprite, h, w, occupied, margin=2, tries=200):
    # sprite: list of (r,c) within sprite bounding box starting at (0,0)
    # Determine sprite bounding box
    minr = min(p[0] for p in sprite)
    minc = min(p[1] for p in sprite)
    maxr = max(p[0] for p in sprite)
    maxc = max(p[1] for p in sprite)
    sprite_h = maxr - minr + 1
    sprite_w = maxc - minc + 1
    # normalize sprite pixels to start at (0,0)
    norm = [(p[0]-minr, p[1]-minc) for p in sprite]
    r0_min = margin
    r0_max = h - margin - sprite_h
    c0_min = margin
    c0_max = w - margin - sprite_w
    if r0_max < r0_min or c0_max < c0_min:
        return None
    for _ in range(tries):
        r0 = random.randint(r0_min, r0_max)
        c0 = random.randint(c0_min, c0_max)
        coords = [(r0 + pr, c0 + pc) for (pr, pc) in norm]
        conflict = False
        for (r,c) in coords:
            if (r,c) in occupied:
                conflict = True
                break
        if conflict:
            continue
        return coords
    return None


def generate():
    # Try to build a grid with multiple colored regions and surrounding borders
    # that create background mask cells adjacent to at least two different border colors.
    width = random.randint(10, 20)
    height = random.randint(10, 20)

    # number of regions: 3 or 4 to keep color usage manageable
    num_regions = random.randint(3, 4)

    grid = [[0 for _ in range(width)] for _ in range(height)]

    # choose distinct colors for regions and borders (2*num_regions distinct colors)
    colors = random.sample(list(range(1, 10)), num_regions * 2)
    region_colors = colors[:num_regions]
    border_colors = colors[num_regions: num_regions*2]

    occupied = set()  # cells occupied by region pixels
    all_region_pixels = []  # list of (r,c,color,b_color)

    # place each region as a separated connected sprite
    for i in range(num_regions):
        r_color = region_colors[i]
        b_color = border_colors[i]
        # create a small connected sprite
        # sprite generation parameters
        tries_sprite = 0
        placed = False
        while not placed and tries_sprite < 300:
            tries_sprite += 1
            # pick a small bounding box for the sprite, ensure it can fit with margins
            margin = 2
            max_w = min(8, width - 2 * margin)
            max_h = min(8, height - 2 * margin)
            if max_w < 2 or max_h < 2:
                return generate()
            sprite_w = random.randint(2, max_w)
            sprite_h = random.randint(2, max_h)
            max_size = sprite_w * sprite_h
            if max_size < 1:
                continue
            size = random.randint(3, max(3, min(10, max_size)))
            sprite = continuous_creature(size, sprite_w, sprite_h)
            coords = _place_sprite_nonoverlapping(sprite, height, width, occupied, margin=margin, tries=200)
            if coords is None:
                continue
            # place region pixels
            for (r, c) in coords:
                grid[r][c] = r_color
                occupied.add((r, c))
                all_region_pixels.append((r, c, r_color, b_color))
            placed = True
        if not placed:
            # fallback: if we failed to place this region (rare), restart generation
            return generate()

    # create borders: a border cell is any background cell orthogonally adjacent to a region pixel
    # assign the border color of the region to that cell. If multiple regions try to paint the same
    # border cell, keep the first assignment (deterministic in this run order).
    border_assigned = {}
    for (r, c, r_color, b_color) in all_region_pixels:
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if not (0 <= nr < height and 0 <= nc < width):
                continue
            if grid[nr][nc] == 0:
                if (nr, nc) not in border_assigned:
                    border_assigned[(nr, nc)] = b_color
                    grid[nr][nc] = b_color

    # identify mask cells: background cells (value 0) orthogonally adjacent to >=2 different border colors
    mask_cells = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                continue
            neigh = []
            for dr, dc in [(-1, 0), (0, 1), (1, 0), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    color = grid[nr][nc]
                    # treat only colors that belong to borders
                    if color in border_colors:
                        neigh.append(color)
            if len(set(neigh)) >= 2:
                mask_cells.append((r, c))

    # If no mask cells found, try again
    if not mask_cells:
        return generate()

    # mapping function: deterministic function of ordered pair (a,b)
    def mapping_func(a, b):
        # produce a color in [1..9]
        return ((a * 7 + b * 13) % 9) + 1

    output = [row[:] for row in grid]

    # recolor each mask cell according to rules
    for (r, c) in mask_cells:
        # collect orthogonal border neighbors in clockwise order: up, right, down, left
        neigh_order = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        colors_seen = []
        counts = {}
        for idx, (dr, dc) in enumerate(neigh_order):
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width:
                col = grid[nr][nc]
                if col in border_colors:
                    colors_seen.append(col)
                    counts[col] = counts.get(col, 0) + 1
        unique_colors = list(counts.keys())
        if len(unique_colors) <= 1:
            continue
        # if more than two, pick two with highest frequency; tie-break by earliest appearance in clockwise order
        def key_sort(col):
            # return (-count, first_index_in_clockwise)
            first_idx = len(neigh_order)
            for idx, (dr, dc) in enumerate(neigh_order):
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    if grid[nr][nc] == col:
                        first_idx = idx
                        break
            return (-counts[col], first_idx)
        unique_colors.sort(key=key_sort)
        col1, col2 = unique_colors[0], unique_colors[1]
        # ensure clockwise order between the two: whichever appears first around the cell should be first
        # find first occurrence indices
        idx1 = None
        idx2 = None
        for idx, (dr, dc) in enumerate(neigh_order):
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width:
                if grid[nr][nc] == col1 and idx1 is None:
                    idx1 = idx
                if grid[nr][nc] == col2 and idx2 is None:
                    idx2 = idx
        # if they are reversed, order by index
        if idx2 is not None and idx1 is not None and idx2 < idx1:
            col1, col2 = col2, col1
        output[r][c] = mapping_func(col1, col2)

    # ensure output differs from input
    if output == grid:
        return generate()

    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # identify border colors: a color is a border color if any of its cells is orthogonally adjacent to background 0
    colors = set()
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if v != 0:
                colors.add(v)
    border_colors = set()
    # scan for any color cell adjacent to background
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if v == 0:
                continue
            for dr, dc in [(-1, 0), (0, 1), (1, 0), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    if grid[nr][nc] == 0:
                        border_colors.add(v)
                        break

    # mapping function (must match generator)
    def mapping_func(a, b):
        return ((a * 7 + b * 13) % 9) + 1

    # find mask cells and recolor
    out = [row[:] for row in grid]
    neigh_order = [(-1, 0), (0, 1), (1, 0), (0, -1)]
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                continue
            # collect orthogonal border neighbors in clockwise order
            neighbor_colors = []
            counts = {}
            for idx, (dr, dc) in enumerate(neigh_order):
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    col = grid[nr][nc]
                    if col in border_colors:
                        neighbor_colors.append(col)
                        counts[col] = counts.get(col, 0) + 1
            if len(set(neighbor_colors)) < 2:
                continue
            unique_colors = list(counts.keys())
            # sort by (-count, first_index)
            def key_sort(col):
                first_idx = len(neigh_order)
                for idx, (dr, dc) in enumerate(neigh_order):
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == col:
                        first_idx = idx
                        break
                return (-counts[col], first_idx)
            unique_colors.sort(key=key_sort)
            col1, col2 = unique_colors[0], unique_colors[1]
            # ensure clockwise order between the two
            idx1 = None
            idx2 = None
            for idx, (dr, dc) in enumerate(neigh_order):
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    if grid[nr][nc] == col1 and idx1 is None:
                        idx1 = idx
                    if grid[nr][nc] == col2 and idx2 is None:
                        idx2 = idx
            if idx2 is not None and idx1 is not None and idx2 < idx1:
                col1, col2 = col2, col1
            out[r][c] = mapping_func(col1, col2)

    return tuple(tuple(row) for row in out)

