# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 6202ceb2
Difficulty: insane

=== Tags ===
- Repulsion and bounce

=== Description ===
**Repulsion and Bounce**  Input grids feature a background color (0) and
multiple contiguous clusters of distinct colors (1-9), each representing a
dynamic "particle." A fixed set of color pairs (e.g., {1, 4}, {3, 7}, {5, 9})
are defined as repelling: in the output, no cell of one color in a repelling
pair may be adjacent (including diagonally) to any cell of the other color. To
resolve adjacency:  1. **Repulsion Resolution:** For each repelling pair, shift
one cluster away from the other along the shortest axis (prioritizing horizontal
shifts over vertical). The direction is determined by the relative position of
the clusters (e.g., if Cluster A is to the left of Cluster B, shift Cluster A
left).  2. **Boundary Bounce:** If a shift would move a cluster outside the grid
boundary, the shift direction reverses ("bounces"), moving the cluster along the
boundary (e.g., a cluster at the left edge shifting left instead shifts right).
3. **Iterative Separation:** Shifts are applied iteratively until all repelling
pairs are separated, with no overlaps between clusters or with the background.
The output preserves the exact cell count per color as the input.  4.
**Stability Constraint:** All shifts must maintain the clusters' connectivity
(no disintegration into disconnected components) and avoid creating new
repelling adjacencies.  The output grid demonstrates a stable configuration
where repelling clusters are maximally separated while respecting grid
boundaries and connectivity constraints. The transformation requires resolving
multiple overlapping repulsion interactions simultaneously, with boundary
bounces introducing non-linear path dependencies.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import copy
from collections import defaultdict
import common

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    grid = common.grid(width, height, 0)
    
    repelling_pairs = [(1,4), (2,5), (3,6)]
    a, b = random.choice(repelling_pairs)
    
    cluster_a = common.continuous_creature(3, width, height)
    cluster_b = common.continuous_creature(3, width, height)
    
    start_a_row = random.randint(5, height - 5)
    start_a_col = random.randint(5, width - 5)
    start_a = (start_a_row, start_a_col)
    
    cluster_a = [(r + start_a[0], c + start_a[1]) for r, c in cluster_a]
    
    max_col_a = max(c for r, c in cluster_a)
    start_b_col = max_col_a + 1
    start_b = (start_a[0], start_b_col)
    cluster_b = [(r + start_b[0], c + start_b[1]) for r, c in cluster_b]
    
    for (r, c) in cluster_a:
        if 0 <= r < height and 0 <= c < width:
            grid[r][c] = a
    for (r, c) in cluster_b:
        if 0 <= r < height and 0 <= c < width:
            grid[r][c] = b
    
    output_grid = copy.deepcopy(grid)
    shift = (0, -1)  # Correct horizontal shift
    for (r, c) in cluster_a:
        new_c = c + shift[1]
        if new_c < 0:
            shift = (0, 1)  # Bounce right
            new_c = c + shift[1]
        output_grid[r][c] = 0
        output_grid[r][new_c] = a
    
    return {
        "input": grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    
    repelling_pairs = [(1,4), (2,5), (3,6)]
    
    def get_cells(color):
        return [(r, c) for r in range(height) for c in range(width) if input_grid[r][c] == color]
    
    for a, b in repelling_pairs:
        cells_a = get_cells(a)
        cells_b = get_cells(b)
        if not cells_a or not cells_b:
            continue
        
        for (ra, ca) in cells_a:
            for (rb, cb) in cells_b:
                if abs(ra - rb) <= 1 and abs(ca - cb) <= 1:
                    # Correct horizontal shift
                    shift = (0, -1) if ca < cb else (0, 1)
                    
                    output = [row[:] for row in input_grid]
                    for (r, c) in cells_a:
                        new_c = c + shift[1]
                        if new_c < 0 or new_c >= width:
                            shift = (0, 1) if shift[1] == -1 else (0, -1)
                            new_c = c + shift[1]
                        output[r][c] = 0
                        output[r][new_c] = a
                    return output
    return input_grid
