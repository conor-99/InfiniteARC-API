# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: b5a1910e
Difficulty: hard

=== Tags ===
- Image expansion
- Motif extraction

=== Description ===
The task involves input grids containing a specific motif defined by cells of
color 2 that are orthogonally surrounded by color 3 (i.e., cells where all four
direct neighborsâ€”up, down, left, rightâ€”have color 3). The output grid is
generated by expanding each such motif cell into a 2Ã—2 block of color 2, while
all other cells in the output grid are set to color 0. The output grid
dimensions are exactly double the input grid's width and height. This requires
the solver to first identify the motif through relational neighbor analysis (not
just color matching), then apply a deterministic expansion rule that scales the
motif's presence without overlapping or altering the background. The difficulty
arises from the need to recognize the motif's contextual condition (surrounding
colors) before performing the expansion, making the transformation non-obvious
and requiring multi-step reasoning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(3, 15)
    height = random.randint(3, 15)
    input_grid = grid(width, height, 0)
    
    num_motifs = random.randint(1, 5)
    for _ in range(num_motifs):
        i = random.randint(1, height - 2)
        j = random.randint(1, width - 2)
        input_grid[i-1][j] = 3
        input_grid[i+1][j] = 3
        input_grid[i][j-1] = 3
        input_grid[i][j+1] = 3
        input_grid[i][j] = 2
    
    for i in range(height):
        for j in range(width):
            if input_grid[i][j] == 0:
                input_grid[i][j] = random.randint(1, 9)
    
    output_grid = grid(2 * width, 2 * height, 0)
    for i in range(height):
        for j in range(width):
            if input_grid[i][j] == 2:
                if i > 0 and i < height - 1 and j > 0 and j < width - 1:
                    if (input_grid[i-1][j] == 3 and 
                        input_grid[i+1][j] == 3 and 
                        input_grid[i][j-1] == 3 and 
                        input_grid[i][j+1] == 3):
                        output_grid[2*i][2*j] = 2
                        output_grid[2*i][2*j+1] = 2
                        output_grid[2*i+1][2*j] = 2
                        output_grid[2*i+1][2*j+1] = 2
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid
def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output = grid(2 * width, 2 * height, 0)
    for i in range(height):
        for j in range(width):
            if input_grid[i][j] == 2:
                if i > 0 and i < height - 1 and j > 0 and j < width - 1:
                    if (input_grid[i-1][j] == 3 and 
                        input_grid[i+1][j] == 3 and 
                        input_grid[i][j-1] == 3 and 
                        input_grid[i][j+1] == 3):
                        output[2*i][2*j] = 2
                        output[2*i][2*j+1] = 2
                        output[2*i+1][2*j] = 2
                        output[2*i+1][2*j+1] = 2
    return output
