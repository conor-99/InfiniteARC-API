# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 7ba63dd3
Difficulty: medium

=== Tags ===
- Sort objects in row by size
- Only one
- Dominant color

=== Description ===
The task involves input grids containing rows with multiple connected regions
(objects) of distinct colors, where one color is dominant (appearing most
frequently across the entire grid). For each row, the connected regions of the
dominant color are identified, then sorted by their size (number of cells in the
region) from smallest to largest. The output grid rearranges these dominant
color regions within each row to reflect this sorted order, while all non-
dominant color regions and their positions remain unchanged. The "Only one" tag
indicates that the task focuses exclusively on the single dominant color for
sorting, and the "Dominant color" tag specifies that the sorting is based on the
most prevalent color in the input grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(3, 10)
    height = random.randint(3, 10)
    dominant = random.randint(1, 9)
    non_dominant = random.choice([i for i in range(1, 10) if i != dominant])
    
    input_grid = grid(width, height, dominant)
    
    for r in range(height):
        c = min((width + 1) // 2, width - 2)
        input_grid[r][c] = non_dominant
    
    output_grid = [row[:] for row in input_grid]
    for r in range(height):
        row = input_grid[r]
        c = min((width + 1) // 2, width - 2)
        left_segment = row[:c]
        right_segment = row[c+1:]
        output_grid[r] = right_segment + [row[c]] + left_segment
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    # Ensure input_grid is a list of lists
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    all_cells = [cell for row in input_grid for cell in row]
    dominant = max(set(all_cells), key=all_cells.count)
    
    output = [row[:] for row in input_grid]
    
    for r in range(len(input_grid)):
        row = input_grid[r]
        c = min((len(row) + 1) // 2, len(row) - 2)
        left_segment = row[:c]
        right_segment = row[c+1:]
        output[r] = right_segment + [row[c]] + left_segment
    
    return output
