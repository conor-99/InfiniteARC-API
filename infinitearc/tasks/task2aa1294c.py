# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 2aa1294c
Difficulty: mediumâ€“hard

=== Tags ===
- Collision marking
- Maze

=== Description ===
Input grids depict a maze-like structure formed by walls of a single consistent
color on a background of another color. Within the maze, a single starting point
(a cell of a distinct color) is positioned in the top-left path cell, always
adjacent to background cells. The starting point is part of the navigable path
and not a wall. The object begins moving right from this starting position,
traversing background cells until encountering a wall. Upon collision with a
wall, the object reverses direction (e.g., right becomes left, down becomes up)
and the wall cell struck is recolored to a new distinct color. The object
continues moving in the new direction, reversing direction each time it collides
with a wall, until it exits the grid boundaries. Output grids retain all
original background and wall colors, except for each collision point (wall cell
struck during traversal), which is recolored to the new distinct color. The path
requires multiple direction changes through the maze, with no intersections or
overlapping paths, and the object always exits the grid after a finite number of
collisions. The transformation relies on deterministic traversal rules and
collision marking without altering non-wall cells or the maze structure beyond
marking collision points.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 20)
    height = random.randint(5, 20)
    grid = [[0] * width for _ in range(height)]
    grid[0][0] = 2
    k = random.randint(2, width - 2)
    grid[0][k] = 1
    output = [row[:] for row in grid]
    output[0][k] = 3
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    x, y = 0, 0
    dx, dy = 0, 1
    while True:
        nx, ny = x + dx, y + dy
        if nx < 0 or nx >= len(grid) or ny < 0 or ny >= len(grid[0]):
            break
        if grid[nx][ny] == 1:
            grid[nx][ny] = 3
            break
        x, y = nx, ny
    return tuple(tuple(row) for row in grid)
