# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: c8232661
Difficulty: mediumâ€“hard

=== Tags ===
- Pattern modification
- Connect all dots of same color
- Follow color path to destination
- Pattern to sequence mapping
- Pattern resizing
- Associate images to numbers

=== Description ===
Task Name: Color Path Integration  Description: Input grids feature a uniform
background color (0) with multiple clusters of colored dots (each cluster a
single color from 1-9), where each cluster contains 2-4 dots arranged in a
distinct, non-overlapping pattern. Clusters of different colors may be adjacent
or separated by background cells, and no two clusters of the same color overlap.
The transformation to the output grid requires: 1. **Connecting all dots of the
same color** into a single continuous path using the same color. Dots are sorted
in row-major order (top-left to bottom-right), and consecutive dots are
connected via straight horizontal or vertical segments. 2. **Pattern resizing**
by expanding each segment of the path to fill the minimal bounding rectangle
that encloses all dots of the color, maintaining the original color and
occupying only background cells. 3. **Following the color path to destination**,
where the destination for each color is the cell directly below the lowest dot
in the cluster, adjusted to remain within grid bounds.  The output grid
preserves all original dots and background, adding connecting paths (in the same
color) without overwriting existing elements. Paths for different colors may
overlap but are visually distinct due to color differentiation. The
transformation ensures no input grid matches its output, as paths are added to
form continuous connections and resized patterns.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(10, 25)
    height = random.randint(10, 25)
    grid = [[0] * width for _ in range(height)]
    used = set()
    clusters = []
    
    num_clusters = random.randint(3, 5)
    for _ in range(num_clusters):
        color = random.randint(1, 9)
        while color in {c for c, _ in clusters}:
            color = random.randint(1, 9)
        num_dots = random.randint(2, 4)
        positions = []
        used_positions = used.copy()
        for i in range(num_dots):
            while True:
                r = random.randint(0, height-1)
                c = random.randint(0, width-1)
                if (r, c) not in used_positions:
                    positions.append((r, c))
                    used_positions.add((r, c))
                    break
        rows = [p[0] for p in positions]
        cols = [p[1] for p in positions]
        min_r, max_r = min(rows), max(rows)
        min_c, max_c = min(cols), max(cols)
        bounding_area = (max_r - min_r + 1) * (max_c - min_c + 1)
        if bounding_area <= num_dots:
            continue
        for r, c in positions:
            grid[r][c] = color
            used.add((r, c))
        clusters.append((color, positions))
    
    output = [row[:] for row in grid]
    for color in range(1, 10):
        positions = []
        for r in range(height):
            for c in range(width):
                if grid[r][c] == color:
                    positions.append((r, c))
        if not positions:
            continue
        rows = [p[0] for p in positions]
        cols = [p[1] for p in positions]
        min_r, max_r = min(rows), max(rows)
        min_c, max_c = min(cols), max(cols)
        for r in range(min_r, max_r + 1):
            for c in range(min_c, max_c + 1):
                if grid[r][c] == 0:
                    output[r][c] = color
    
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    output = [row[:] for row in input_grid]
    for color in range(1, 10):
        positions = []
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == color:
                    positions.append((r, c))
        if not positions:
            continue
        rows = [p[0] for p in positions]
        cols = [p[1] for p in positions]
        min_r, max_r = min(rows), max(rows)
        min_c, max_c = min(cols), max(cols)
        for r in range(min_r, max_r + 1):
            for c in range(min_c, max_c + 1):
                if input_grid[r][c] == 0:
                    output[r][c] = color
    return output
