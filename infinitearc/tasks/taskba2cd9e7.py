# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: ba2cd9e7
Difficulty: mediumâ€“hard

=== Tags ===
- Stateful propagation
- Shape attribute projection
- Follow color path to destination
- Summarize

=== Description ===
The input grid features a complex arrangement of contiguous colored paths (each
path is a connected sequence of cells sharing the same color value 1-9), where
each color corresponds to a fixed initial direction (e.g., color 1 = right, 2 =
down, 3 = left, 4 = up). Obstacles are represented by cells of any color not
belonging to the current path. Each path originates at its starting cell and
propagates in its color's initial direction. Upon encountering an obstacle (a
cell with a different color), the path reflects (reversing its direction) and
continues propagating. This stateful propagation continues iteratively until the
path exits the grid. The output grid must render the complete trajectory of each
path as a continuous line using its original color, with reflection points
accurately marked at obstacle encounters. All obstacles remain visually
unchanged in the output. Background cells (color 0) are preserved without
modification. The task requires simultaneously tracking multiple path
trajectories, applying directional state changes upon reflection, and
synthesizing the complete visual path from start to exit in a single output
grid. The output must summarize the full propagation history of all paths
without omitting any reflection points or directional transitions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid


def generate():
    # Grid size: moderate but variable so generator produces many unique examples
    w = random.randint(6, 20)
    h = random.randint(6, 20)
    input_grid = grid(w, h, 0)

    # Direction mapping for colors 1-4
    directions = {
        1: (0, 1),   # right
        2: (1, 0),   # down
        3: (0, -1),  # left
        4: (-1, 0)   # up
    }

    obstacle_colors = [5, 6, 7, 8, 9]

    # Choose how many distinct path colors (directions) to include
    num_paths = random.randint(2, 4)
    path_colors = random.sample([1, 2, 3, 4], num_paths)

    # To avoid color conflicts where two different paths would try to paint the same cell
    # we keep horizontal paths on distinct rows and vertical paths on distinct columns.
    used_rows = set()
    used_cols = set()

    starts = []  # list of (r, c, color)

    for color in path_colors:
        dr, dc = directions[color]
        placed = False
        tries = 0
        # Try to place a start cell satisfying constraints (interior, not blocked on exit side)
        while not placed and tries < 200:
            tries += 1
            # Choose a start coordinate that is not on the edge in the direction of travel
            if dr == 0:
                # horizontal path: pick a row that hasn't been used
                rows = [r for r in range(1, h - 1) if r not in used_rows]
                if not rows:
                    break
                r = random.choice(rows)
                c = random.randint(1, w - 2)
            else:
                # vertical path: pick a column that hasn't been used
                cols = [c for c in range(1, w - 1) if c not in used_cols]
                if not cols:
                    break
                c = random.choice(cols)
                r = random.randint(1, h - 2)

            # don't place on an occupied cell
            if input_grid[r][c] != 0:
                continue

            next_r, next_c = r + dr, c + dc
            prev_r, prev_c = r - dr, c - dc

            # ensure both neighboring positions exist (we avoid starts on the very edge)
            if not (0 <= next_r < h and 0 <= next_c < w):
                continue
            if not (0 <= prev_r < h and 0 <= prev_c < w):
                continue

            # Randomly decide whether to force a reflection by placing an obstacle in front
            place_obstacle_ahead = random.random() < 0.6
            if place_obstacle_ahead:
                if input_grid[next_r][next_c] != 0:
                    # can't place an obstacle here; try another start
                    continue
                input_grid[next_r][next_c] = random.choice(obstacle_colors)

            # Ensure the backwards direction (where the path would travel after reflecting)
            # is clear all the way to the border so the path can exit. If it's blocked, undo
            # the placed obstacle (if any) and try a different start.
            rr, cc = prev_r, prev_c
            blocked_prev = False
            while 0 <= rr < h and 0 <= cc < w:
                if input_grid[rr][cc] != 0:
                    blocked_prev = True
                    break
                rr -= dr
                cc -= dc

            if blocked_prev:
                # undo the obstacle we placed and retry
                if place_obstacle_ahead and input_grid[next_r][next_c] in obstacle_colors:
                    input_grid[next_r][next_c] = 0
                continue

            # Place the start
            input_grid[r][c] = color
            starts.append((r, c, color))
            placed = True
            if dr == 0:
                used_rows.add(r)
            else:
                used_cols.add(c)

        # end placement attempts for this color

    # Sort starts deterministically by color so output painting order is stable
    starts.sort(key=lambda x: x[2])

    # Create the output by simulating the stateful propagation for each start
    output_grid = [row[:] for row in input_grid]

    for (sr, sc, color) in starts:
        dr, dc = directions[color]
        cur_r, cur_c = sr, sc
        steps = 0
        max_steps = w * h * 4  # safety cap to avoid infinite loops
        while True:
            steps += 1
            if steps > max_steps:
                break

            # Paint the current cell with the path color if it is not an obstacle of another color
            if output_grid[cur_r][cur_c] == 0 or output_grid[cur_r][cur_c] == color:
                output_grid[cur_r][cur_c] = color

            next_r, next_c = cur_r + dr, cur_c + dc

            # If the next step leaves the grid, the path exits
            if not (0 <= next_r < h and 0 <= next_c < w):
                break

            # If the next cell is an obstacle (non-zero and not the path color), reflect
            if input_grid[next_r][next_c] != 0 and input_grid[next_r][next_c] != color:
                # reflect in place (do not overwrite the obstacle cell)
                dr, dc = -dr, -dc
                alt_r, alt_c = cur_r + dr, cur_c + dc
                if not (0 <= alt_r < h and 0 <= alt_c < w):
                    # reflection leads immediately out of bounds -> exit
                    break
                # if the alternate side is also blocked, give up (shouldn't happen with our generator)
                if input_grid[alt_r][alt_c] != 0 and input_grid[alt_r][alt_c] != color:
                    break
                cur_r, cur_c = alt_r, alt_c
                continue
            else:
                # Move into an empty cell or a same-colored cell
                cur_r, cur_c = next_r, next_c
                continue

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert tuple-of-tuples input to a mutable list-of-lists
    ingrid = [list(row) for row in input_grid]
    h = len(ingrid)
    w = len(ingrid[0]) if h else 0

    # Start with a copy of the input so obstacles stay unchanged
    output = [row[:] for row in ingrid]

    directions = {
        1: (0, 1),   # right
        2: (1, 0),   # down
        3: (0, -1),  # left
        4: (-1, 0)   # up
    }

    # Find starting cells (colors 1-4). The generator uses colors 1-4 only for starts.
    starts = []
    for r in range(h):
        for c in range(w):
            if ingrid[r][c] in (1, 2, 3, 4):
                starts.append((r, c, ingrid[r][c]))

    # Sort starts deterministically by color to match the generator's painting order
    starts.sort(key=lambda x: x[2])

    # Simulate each path's stateful propagation and paint its trajectory into output
    for (sr, sc, color) in starts:
        dr, dc = directions[color]
        cur_r, cur_c = sr, sc
        steps = 0
        max_steps = max(1, w * h * 4)
        while True:
            steps += 1
            if steps > max_steps:
                break

            # Paint the current cell if it's not an obstacle of a different color
            if output[cur_r][cur_c] == 0 or output[cur_r][cur_c] == color:
                output[cur_r][cur_c] = color

            next_r, next_c = cur_r + dr, cur_c + dc

            # If next step leaves the grid, path exits
            if not (0 <= next_r < h and 0 <= next_c < w):
                break

            # If the next cell is an obstacle (non-zero and not the path color), reflect
            if ingrid[next_r][next_c] != 0 and ingrid[next_r][next_c] != color:
                dr, dc = -dr, -dc
                alt_r, alt_c = cur_r + dr, cur_c + dc
                if not (0 <= alt_r < h and 0 <= alt_c < w):
                    break
                # If the alternate side is also blocked, stop to avoid infinite toggling
                if ingrid[alt_r][alt_c] != 0 and ingrid[alt_r][alt_c] != color:
                    break
                cur_r, cur_c = alt_r, alt_c
                continue
            else:
                # Move forward into the next cell
                cur_r, cur_c = next_r, next_c
                continue

    return output

