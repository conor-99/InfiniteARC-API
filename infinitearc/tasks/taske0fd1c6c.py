# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: e0fd1c6c
Difficulty: insane

=== Tags ===
- Cut and unfold
- Draw path through ordered checkpoints
- Phase shift
- Count hor lines

=== Description ===
Task Name: Cut and Unfold Path  Input grids feature a 2D arrangement of colored
cells (values 0-9) containing four key visual elements: horizontal lines (full
rows of identical non-background color), ordered checkpoints (distinct positions
marked by a unique color sequence), cut lines (vertical or horizontal lines of a
specific marker color), and background patterns. Horizontal lines are defined as
entire rows where all cells share the same non-zero color. Checkpoints appear in
a fixed traversal order, visible as discrete points within the grid. Cut lines
form continuous segments of a designated color (e.g., color 8) that indicate
where the grid was folded.  The output grid is generated through four sequential
visual transformations: 1. **Count Horizontal Lines**: Tally all full rows
(entire row of identical non-background color), excluding background (value 0),
to determine a shift count N. 2. **Phase Shift**: Apply a cyclic right rotation
to each row by N positions (mod row width), shifting all elements within rows
while preserving row order. 3. **Path Drawing**: Connect the ordered checkpoints
(in their sequence) with a continuous path using a dedicated color (e.g., color
3), moving only horizontally or vertically between adjacent cells without
crossing itself. 4. **Unfold Cut Lines**: For each cut line segment, reverse any
mirroring applied to the grid section relative to the cut line, restoring the
original configuration as if the grid were never folded.  The transformation
requires simultaneous recognition of spatial patterns (horizontal lines,
checkpoint order, cut line placement), numerical interpretation (counting lines
for phase shift), and multi-step visual reconstruction (path drawing followed by
unfolding). The output merges all transformations into a single coherent grid
where the phase shift alters checkpoint positions, the path traverses the new
arrangement, and cut lines are restored to their unmirrored state. This task
demands combinatorial visual reasoning across multiple interdependent
operations, making it exceptionally complex for human pattern recognition.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque
from common import grid

# Generator for ARC task: Cut and Unfold Path
# Produces an 'input' folded grid and the 'output' grid after applying the
# four-step transformation described in the task.

PATH_COLOR = 3
CUT_COLOR = 8


def _right_rotate_row(row, k):
    if k == 0:
        return list(row)
    k = k % len(row)
    return list(row[-k:] + row[:-k])


def _left_rotate_row(row, k):
    if k == 0:
        return list(row)
    k = k % len(row)
    return list(row[k:] + row[:k])


def _find_uniform_rows(mat):
    H = len(mat)
    W = len(mat[0])
    uniform_rows = []
    colors = set()
    for r in range(H):
        v = mat[r][0]
        if v != 0 and all(mat[r][c] == v for c in range(W)):
            uniform_rows.append(r)
            colors.add(v)
    return uniform_rows, colors


def _bfs_path(grid_mat, start, goal, path_color=PATH_COLOR, forbid_values=None):
    H = len(grid_mat)
    W = len(grid_mat[0])
    if start == goal:
        return [start]
    q = deque([start])
    parents = {start: None}
    forbid_values = forbid_values or set()
    while q:
        r, c = q.popleft()
        for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):
            nr, nc = r + dr, c + dc
            if nr < 0 or nr >= H or nc < 0 or nc >= W:
                continue
            if (nr, nc) in parents:
                continue
            # don't step onto existing path segments (to avoid crossing)
            if grid_mat[nr][nc] == path_color:
                continue
            if grid_mat[nr][nc] in forbid_values:
                continue
            parents[(nr, nc)] = (r, c)
            if (nr, nc) == goal:
                # reconstruct path
                path = []
                cur = goal
                while cur is not None:
                    path.append(cur)
                    cur = parents[cur]
                path.reverse()
                return path
            q.append((nr, nc))
    return None


def generate():
    # Repeat attempts until we build a valid example (should be quick)
    for _attempt in range(200):
        W = random.randint(6, 12)
        H = random.randint(6, 12)

        # Choose fold orientation and a fold index that leaves both sides non-empty
        fold_type = random.choice(['vertical', 'horizontal'])
        if fold_type == 'vertical':
            min_f = max(1, (W + 1) // 2)  # prefer fold that keeps mirror indices valid
            max_f = W - 2
            if min_f > max_f:
                min_f = 1
            f = random.randint(min_f, max_f)
        else:
            min_f = max(1, (H + 1) // 2)
            max_f = H - 2
            if min_f > max_f:
                min_f = 1
            f = random.randint(min_f, max_f)

        # Number of full horizontal rows (at least one)
        max_full = min(3, H - 1)
        if max_full < 1:
            continue
        n_full = random.randint(1, max_full)

        # pick full-row indices (avoid putting a horizontal cut exactly on a full row)
        available_rows = list(range(H))
        if fold_type == 'horizontal':
            available_rows = [r for r in available_rows if r != f]
        if len(available_rows) < n_full:
            continue
        full_rows = random.sample(available_rows, n_full)

        # Choose checkpoint colors (avoid PATH_COLOR and CUT_COLOR)
        cp_color_pool = [1, 2, 4, 5]
        k = random.randint(2, min(4, len(cp_color_pool)))
        cp_colors = random.sample(cp_color_pool, k)
        cp_colors.sort()

        # Full row colors (avoid checkpoint colors and reserved colors)
        full_color_choices = [6, 7, 9]
        full_row_colors = [random.choice(full_color_choices) for _ in full_rows]

        # Build original (unfolded) grid: mostly zeros, with full rows and checkpoints
        original = grid(W, H, 0)
        # place full rows
        for r_idx, r in enumerate(full_rows):
            color = full_row_colors[r_idx]
            for c in range(W):
                original[r][c] = color
        # Place checkpoints on the "source" side (the side that will be mirrored onto the other)
        # For vertical fold the source side will be columns > f; for horizontal the source is rows > f.
        # Choose rows/columns for checkpoints avoiding full rows and cutline.
        free_rows = [r for r in range(H) if r not in full_rows]
        if len(free_rows) < k:
            continue
        chosen_rows = random.sample(free_rows, k)

        cp_positions_original = []
        for i, color in enumerate(cp_colors):
            r = chosen_rows[i]
            if fold_type == 'vertical':
                # pick a column on the source side (right side, > f)
                c = random.randint(f + 1, W - 1)
            else:
                # pick a column anywhere but row must be on bottom side (> f)
                c = random.randint(0, W - 1)
                r = random.randint(f + 1, H - 1)
                # ensure not on a full row (re-sample if necessary)
                attempts = 0
                while r in full_rows and attempts < 20:
                    r = random.randint(f + 1, H - 1)
                    attempts += 1
                if r in full_rows:
                    # fallback to a free row
                    r = chosen_rows[i]
            original[r][c] = color
            cp_positions_original.append((r, c))

        # Create input grid by folding (mirror source side onto the other side)
        input_grid = grid(W, H, 0)
        if fold_type == 'vertical':
            for r in range(H):
                for c in range(W):
                    if c == f:
                        input_grid[r][c] = CUT_COLOR
                    elif c > f:
                        input_grid[r][c] = original[r][c]
                    else:  # c < f: mirror from right side
                        src_c = 2 * f - c
                        # src_c should be within [f+1, W-1]
                        if 0 <= src_c < W:
                            input_grid[r][c] = original[r][src_c]
                        else:
                            input_grid[r][c] = 0
        else:
            for r in range(H):
                for c in range(W):
                    if r == f:
                        input_grid[r][c] = CUT_COLOR
                    elif r > f:
                        input_grid[r][c] = original[r][c]
                    else:  # r < f: mirror from bottom side
                        src_r = 2 * f - r
                        if 0 <= src_r < H:
                            input_grid[r][c] = original[src_r][c]
                        else:
                            input_grid[r][c] = 0

        # Ensure at least one horizontal full row exists in the input (should hold because original had full rows)
        uniform_rows, uniform_colors = _find_uniform_rows(input_grid)
        if len(uniform_rows) < 1:
            # try another attempt
            continue

        # Step 1: Count horizontal lines N
        N = len(uniform_rows)
        shift = N % W

        # Step 2: Phase shift (right rotate each row by N)
        shifted = [ _right_rotate_row(input_grid[r], shift) for r in range(H) ]

        # Step 3: Path drawing: locate checkpoints in shifted grid and connect in order (by color)
        # Determine the set of columns/rows that correspond to the source side after the shift.
        if fold_type == 'vertical':
            source_cols_orig = list(range(f + 1, W))
            source_cols_after_shift = set(((c + shift) % W) for c in source_cols_orig)
        else:
            source_rows_orig = list(range(f + 1, H))
            source_rows_after_shift = set(((r + shift) % H) for r in source_rows_orig)

        # find candidate checkpoint colors (exclude background, path and cut colors and full-row colors)
        pre_uniform_rows, pre_uniform_colors = _find_uniform_rows(input_grid)
        candidates = set()
        for r in range(H):
            for c in range(W):
                v = shifted[r][c]
                if v == 0 or v == PATH_COLOR or v == CUT_COLOR:
                    continue
                if v in pre_uniform_colors:
                    continue
                candidates.add(v)
        # keep only those we placed (sanity)
        # but preserve ordering by color value
        cp_detected = sorted([v for v in candidates if v in cp_colors])
        if not cp_detected:
            # fallback: use cp_colors that we placed
            cp_detected = cp_colors[:]

        # For each checkpoint color pick the occurrence that lies on the source side after shift (if available)
        checkpoints_shifted = []
        for color in cp_detected:
            occ = [(r, c) for r in range(H) for c in range(W) if shifted[r][c] == color]
            chosen = None
            if fold_type == 'vertical':
                for (r, c) in occ:
                    if c in source_cols_after_shift:
                        chosen = (r, c)
                        break
            else:
                for (r, c) in occ:
                    if r in source_rows_after_shift:
                        chosen = (r, c)
                        break
            if chosen is None and occ:
                chosen = occ[0]
            if chosen:
                checkpoints_shifted.append((color, chosen))

        # sort by checkpoint color (ordered checkpoints)
        checkpoints_shifted.sort(key=lambda x: x[0])
        cp_positions_shifted = [pos for _, pos in checkpoints_shifted]

        # Draw non-self-crossing paths between successive checkpoints using BFS (avoid stepping on existing path)
        S = [list(row) for row in shifted]
        valid_path = True
        for i in range(len(cp_positions_shifted) - 1):
            a = cp_positions_shifted[i]
            b = cp_positions_shifted[i+1]
            path = _bfs_path(S, a, b, path_color=PATH_COLOR, forbid_values={})
            if path is None:
                valid_path = False
                break
            for (pr, pc) in path:
                S[pr][pc] = PATH_COLOR

        if not valid_path:
            # try another attempt
            continue

        # Step 4: Unfold cut lines: undo the shift first, then un-mirror relative to original fold index f
        unshifted = [ _left_rotate_row(S[r], shift) for r in range(H) ]

        # find the original cutline position (should be at index f in the unshifted grid)
        # (we used f earlier when creating the input, but recompute to be robust)
        if fold_type == 'vertical':
            # find column index where CUT_COLOR appears (should be consistent)
            cut_cols = set()
            for r in range(H):
                for c in range(W):
                    if unshifted[r][c] == CUT_COLOR:
                        cut_cols.add(c)
            if cut_cols:
                f_found = min(cut_cols)
            else:
                f_found = f
            # reconstruct original by mirroring back
            output = grid(W, H, 0)
            for r in range(H):
                for c in range(W):
                    if c > f_found:
                        output[r][c] = unshifted[r][c]
                    elif c < f_found:
                        srcc = 2 * f_found - c
                        if 0 <= srcc < W:
                            output[r][c] = unshifted[r][srcc]
                        else:
                            output[r][c] = 0
                    else:  # c == f_found -> fill from right neighbor if possible
                        if f_found + 1 < W:
                            output[r][c] = unshifted[r][f_found + 1]
                        else:
                            output[r][c] = unshifted[r][f_found - 1]
        else:
            cut_rows = set()
            for r in range(H):
                for c in range(W):
                    if unshifted[r][c] == CUT_COLOR:
                        cut_rows.add(r)
            if cut_rows:
                f_found = min(cut_rows)
            else:
                f_found = f
            output = grid(W, H, 0)
            for r in range(H):
                for c in range(W):
                    if r > f_found:
                        output[r][c] = unshifted[r][c]
                    elif r < f_found:
                        sr = 2 * f_found - r
                        if 0 <= sr < H:
                            output[r][c] = unshifted[sr][c]
                        else:
                            output[r][c] = 0
                    else:  # r == f_found
                        if f_found + 1 < H:
                            output[r][c] = unshifted[f_found + 1][c]
                        else:
                            output[r][c] = unshifted[f_found - 1][c]

        # Final sanity checks
        if input_grid == output:
            # avoid trivial examples
            continue

        return {'input': input_grid, 'output': output}

    # fallback (should not happen often)
    W = 6
    H = 6
    inp = grid(W, H, 0)
    out = grid(W, H, 0)
    return {'input': inp, 'output': out}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

PATH_COLOR = 3
CUT_COLOR = 8


def _right_rotate_row(row, k):
    if k == 0:
        return list(row)
    k = k % len(row)
    return list(row[-k:] + row[:-k])


def _left_rotate_row(row, k):
    if k == 0:
        return list(row)
    k = k % len(row)
    return list(row[k:] + row[:k])


def _find_uniform_rows(mat):
    H = len(mat)
    W = len(mat[0])
    uniform_rows = []
    colors = set()
    for r in range(H):
        v = mat[r][0]
        if v != 0 and all(mat[r][c] == v for c in range(W)):
            uniform_rows.append(r)
            colors.add(v)
    return uniform_rows, colors


def _bfs_path(grid_mat, start, goal, path_color=PATH_COLOR, forbid_values=None):
    H = len(grid_mat)
    W = len(grid_mat[0])
    if start == goal:
        return [start]
    q = deque([start])
    parents = {start: None}
    forbid_values = forbid_values or set()
    while q:
        r, c = q.popleft()
        for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):
            nr, nc = r + dr, c + dc
            if nr < 0 or nr >= H or nc < 0 or nc >= W:
                continue
            if (nr, nc) in parents:
                continue
            # don't step onto existing path segments (to avoid crossing)
            if grid_mat[nr][nc] == path_color:
                continue
            if grid_mat[nr][nc] in forbid_values:
                continue
            parents[(nr, nc)] = (r, c)
            if (nr, nc) == goal:
                # reconstruct path
                path = []
                cur = goal
                while cur is not None:
                    path.append(cur)
                    cur = parents[cur]
                path.reverse()
                return path
            q.append((nr, nc))
    return None


def p(input_grid):
    # Convert to list of lists
    grid_in = [list(row) for row in input_grid]
    H = len(grid_in)
    W = len(grid_in[0])

    # Step 1: Count horizontal full rows (non-background, uniform rows)
    uniform_rows, uniform_colors = _find_uniform_rows(grid_in)
    N = len(uniform_rows)

    # Step 2: Phase shift (right rotate each row by N)
    shift = N % W
    shifted = [_right_rotate_row(grid_in[r], shift) for r in range(H)]

    # Detect fold orientation and original fold index f (in the unshifted input)
    # We can detect it directly from grid_in (input before shift)
    cut_positions = [(r, c) for r in range(H) for c in range(W) if grid_in[r][c] == CUT_COLOR]
    fold_type = None
    f_orig = None
    if cut_positions:
        rows_with_cut = set(r for r, c in cut_positions)
        cols_with_cut = set(c for r, c in cut_positions)
        if len(cols_with_cut) == 1:
            fold_type = 'vertical'
            f_orig = next(iter(cols_with_cut))
        elif len(rows_with_cut) == 1:
            fold_type = 'horizontal'
            f_orig = next(iter(rows_with_cut))

    # Step 3: Find checkpoint colors (exclude background, path color, cut color, and uniform-row colors)
    pre_uniform_rows, pre_uniform_colors = uniform_rows, uniform_colors
    candidates = set()
    for r in range(H):
        for c in range(W):
            v = shifted[r][c]
            if v == 0 or v == PATH_COLOR or v == CUT_COLOR:
                continue
            if v in pre_uniform_colors:
                continue
            candidates.add(v)
    # sort candidate colors to form an order
    cp_colors = sorted(candidates)

    # Compute which columns/rows correspond to the source side after shift
    if fold_type == 'vertical':
        source_cols_after_shift = set(((c + shift) % W) for c in range(f_orig + 1, W))
    else:
        source_rows_after_shift = set(((r + shift) % H) for r in range(f_orig + 1, H))

    # For each checkpoint color choose the canonical occurrence (the one on the source side after shift, if any)
    checkpoints_shifted = []
    for color in cp_colors:
        occ = [(r, c) for r in range(H) for c in range(W) if shifted[r][c] == color]
        chosen = None
        if fold_type == 'vertical':
            for (r, c) in occ:
                if c in source_cols_after_shift:
                    chosen = (r, c)
                    break
        else:
            for (r, c) in occ:
                if r in source_rows_after_shift:
                    chosen = (r, c)
                    break
        if chosen is None and occ:
            chosen = occ[0]
        if chosen:
            checkpoints_shifted.append((color, chosen))

    checkpoints_shifted.sort(key=lambda x: x[0])
    cp_positions_shifted = [pos for _, pos in checkpoints_shifted]

    # Step 3 (continued): Draw the path (color PATH_COLOR) connecting checkpoints sequentially
    S = [list(row) for row in shifted]
    for i in range(len(cp_positions_shifted) - 1):
        a = cp_positions_shifted[i]
        b = cp_positions_shifted[i + 1]
        path = _bfs_path(S, a, b, path_color=PATH_COLOR, forbid_values=set())
        if path is None:
            # If no path, just continue (shouldn't happen for generator's outputs)
            continue
        for (pr, pc) in path:
            S[pr][pc] = PATH_COLOR

    # Step 4: Unfold cut lines: first undo the shift (rotate left by shift) to recover the folded input
    unshifted = [_left_rotate_row(S[r], shift) for r in range(H)]

    # Find cut index in unshifted grid (should match f_orig)
    if fold_type == 'vertical':
        cut_cols = set()
        for r in range(H):
            for c in range(W):
                if unshifted[r][c] == CUT_COLOR:
                    cut_cols.add(c)
        if cut_cols:
            f_found = min(cut_cols)
        else:
            f_found = f_orig if f_orig is not None else 0
        # reconstruct original by unmirroring
        output = [[0 for _ in range(W)] for __ in range(H)]
        for r in range(H):
            for c in range(W):
                if c > f_found:
                    output[r][c] = unshifted[r][c]
                elif c < f_found:
                    srcc = 2 * f_found - c
                    if 0 <= srcc < W:
                        output[r][c] = unshifted[r][srcc]
                    else:
                        output[r][c] = 0
                else:
                    if f_found + 1 < W:
                        output[r][c] = unshifted[r][f_found + 1]
                    else:
                        output[r][c] = unshifted[r][f_found - 1]
    else:
        cut_rows = set()
        for r in range(H):
            for c in range(W):
                if unshifted[r][c] == CUT_COLOR:
                    cut_rows.add(r)
        if cut_rows:
            f_found = min(cut_rows)
        else:
            f_found = f_orig if f_orig is not None else 0
        output = [[0 for _ in range(W)] for __ in range(H)]
        for r in range(H):
            for c in range(W):
                if r > f_found:
                    output[r][c] = unshifted[r][c]
                elif r < f_found:
                    sr = 2 * f_found - r
                    if 0 <= sr < H:
                        output[r][c] = unshifted[sr][c]
                    else:
                        output[r][c] = 0
                else:
                    if f_found + 1 < H:
                        output[r][c] = unshifted[f_found + 1][c]
                    else:
                        output[r][c] = unshifted[f_found - 1][c]

    return output
