# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 4eea9025
Difficulty: insane

=== Tags ===
- Mapping by size relation
- Rotating signal
- Recursive pattern copy
- Image juxtaposition

=== Description ===
Input grids consist of multiple non-overlapping, contiguous colored shapes (each
shape is a single color, background is 0) arranged in a central pattern. Each
shape's size is determined by the maximum dimension of its bounding box (width
or height). For each shape, the output grid must generate a sequence of rotated
copies where each copy is rotated by 90° increments relative to the previous,
with the number of copies equal to the shape's size. The first copy (original)
remains at its input position. Subsequent copies are placed adjacent to the
previous copy in a clockwise spiral pattern (right, up, left, down, repeating),
with placement direction determined by copy index modulo 4. The rotation angle
for the nth copy (0-based) is 90° × n. All copies maintain the original color
and must be positioned without overlapping background or other shapes. This
process is applied recursively to each new copy, up to a depth equal to the
maximum size of any shape in the input, creating a complex hierarchical pattern
where each level of recursion adds a rotated copy in the spiral arrangement. The
output grid preserves all original shapes while visually juxtaposing the
recursively generated rotated copies in a structured spiral formation, with no
two copies overlapping and all transformations strictly based on shape size and
rotational sequence.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

# Rotate a grid 90 degrees clockwise using common utilities
def rotate90(grid):
    return common.flip_horiz(common.transpose(grid))


def rotate_n(grid, n):
    g = [row[:] for row in grid]
    for _ in range(n % 4):
        g = rotate90(g)
    return g


def place_chain(output_grid, shape_grid, anchor_r, anchor_c, color, size, width, height):
    placed_any = False
    prev_anchor_r, prev_anchor_c = anchor_r, anchor_c
    prev_h = len(shape_grid)
    prev_w = len(shape_grid[0])
    # n == 0 is the original (already present). Create copies for n=1..size-1
    for n in range(1, size):
        rot = rotate_n(shape_grid, n)
        h_n = len(rot)
        w_n = len(rot[0])
        d = (n - 1) % 4  # 0:right, 1:up, 2:left, 3:down
        if d == 0:
            new_r = prev_anchor_r
            new_c = prev_anchor_c + prev_w
        elif d == 1:
            new_r = prev_anchor_r - h_n
            new_c = prev_anchor_c
        elif d == 2:
            new_r = prev_anchor_r
            new_c = prev_anchor_c - w_n
        else:
            new_r = prev_anchor_r + prev_h
            new_c = prev_anchor_c

        cells = []
        ok = True
        for rr in range(h_n):
            for cc in range(w_n):
                if rot[rr][cc] != 0:
                    R = new_r + rr
                    C = new_c + cc
                    if R < 0 or R >= height or C < 0 or C >= width or output_grid[R][C] != 0:
                        ok = False
                        break
                    cells.append((R, C))
            if not ok:
                break
        if ok:
            for R, C in cells:
                output_grid[R][C] = color
            placed_any = True
            prev_anchor_r, prev_anchor_c = new_r, new_c
            prev_h, prev_w = h_n, w_n
    return placed_any


def generate():
    # Create reasonably sized grids and simple contiguous shapes (rectangles or near-rectangles)
    for attempt in range(200):
        width = random.randint(8, 20)
        height = random.randint(8, 20)
        input_grid = common.grid(width, height, 0)

        n_shapes = random.randint(2, 3)
        colors = common.random_colors(n_shapes, exclude=[0])
        shapes = []
        failed = False

        for color in colors:
            # choose a small bounding box for the shape
            bbox_h = random.randint(2, 4)
            bbox_w = random.randint(2, 4)

            # try to place the bounding box away from the edges so spiral copies have space
            placed = False
            for _ in range(30):
                r_min = 2 if (height - bbox_h - 4) >= 2 else 0
                r_max = height - bbox_h - 3 if (height - bbox_h - 3) >= 0 else height - bbox_h
                c_min = 2 if (width - bbox_w - 4) >= 2 else 0
                c_max = width - bbox_w - 3 if (width - bbox_w - 3) >= 0 else width - bbox_w
                if r_max < r_min:
                    r_min, r_max = 0, max(0, height - bbox_h)
                if c_max < c_min:
                    c_min, c_max = 0, max(0, width - bbox_w)

                anchor_r = random.randint(r_min, r_max)
                anchor_c = random.randint(c_min, c_max)

                # build pixels for a simple contiguous block with a small random hole probability
                pixels = []
                overlap = False
                for dr in range(bbox_h):
                    for dc in range(bbox_w):
                        rr = anchor_r + dr
                        cc = anchor_c + dc
                        if input_grid[rr][cc] != 0:
                            overlap = True
                            break
                        pixels.append((rr, cc))
                    if overlap:
                        break
                if overlap:
                    continue

                # optionally carve one or two cells to make slightly irregular shapes while preserving connectivity
                if bbox_h * bbox_w > 2 and random.random() < 0.5:
                    # remove up to one interior cell
                    if bbox_h > 1 and bbox_w > 1:
                        dr = random.randint(0, bbox_h - 1)
                        dc = random.randint(0, bbox_w - 1)
                        # remove (anchor_r+dr, anchor_c+dc) from pixels
                        pixels.remove((anchor_r + dr, anchor_c + dc))

                # final check for connectivity (simple BFS)
                if pixels:
                    pixel_set = set(pixels)
                    stack = [next(iter(pixel_set))]
                    seen = {stack[0]}
                    while stack:
                        cr, cc = stack.pop()
                        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                            nbr = (cr + dr, cc + dc)
                            if nbr in pixel_set and nbr not in seen:
                                seen.add(nbr)
                                stack.append(nbr)
                    if len(seen) != len(pixel_set):
                        continue

                # place
                for rr, cc in pixels:
                    input_grid[rr][cc] = color
                shapes.append((color, pixels))
                placed = True
                break

            if not placed:
                failed = True
                break

        if failed:
            continue

        # sort shapes by their top-left corner so placement order is deterministic and matches solver scan order
        shapes.sort(key=lambda item: (min(r for r, c in item[1]), min(c for r, c in item[1])))

        # compute maximum size
        M = 0
        for color, pixels in shapes:
            min_r = min(r for r, c in pixels)
            max_r = max(r for r, c in pixels)
            min_c = min(c for r, c in pixels)
            max_c = max(c for r, c in pixels)
            size = max(max_r - min_r + 1, max_c - min_c + 1)
            M = max(M, size)

        if M < 2:
            continue

        output_grid = [row[:] for row in input_grid]
        any_new = False
        for color, pixels in shapes:
            min_r = min(r for r, c in pixels)
            max_r = max(r for r, c in pixels)
            min_c = min(c for r, c in pixels)
            max_c = max(c for r, c in pixels)
            bbox_h = max_r - min_r + 1
            bbox_w = max_c - min_c + 1
            size = max(bbox_h, bbox_w)

            shape_grid = [[0] * bbox_w for _ in range(bbox_h)]
            for r, c in pixels:
                shape_grid[r - min_r][c - min_c] = color

            placed = place_chain(output_grid, shape_grid, min_r, min_c, color, size, width, height)
            any_new = any_new or placed

        if not any_new:
            continue

        return {'input': input_grid, 'output': output_grid}

    # fallback small guaranteed example
    width, height = 8, 8
    input_grid = common.grid(width, height, 0)
    color = 1
    input_grid[3][3] = color
    input_grid[3][4] = color
    input_grid[4][3] = color
    input_grid[4][4] = color
    output_grid = [row[:] for row in input_grid]
    output_grid[3][5] = color
    return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import transpose, flip_horiz

# rotation utilities must match generator
def rotate90(grid):
    return flip_horiz(transpose(grid))


def rotate_n(grid, n):
    g = [row[:] for row in grid]
    for _ in range(n % 4):
        g = rotate90(g)
    return g


def p(input_grid):
    # convert to mutable list-of-lists
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])

    # find connected components (contiguous shapes) by color
    visited = [[False] * width for _ in range(height)]
    shapes = []  # list of (color, pixels)

    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                color = input_grid[r][c]
                pixels = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    pixels.append((cr, cc))
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                shapes.append((color, pixels))

    if not shapes:
        return input_grid

    # compute maximum shape size (used as recursion depth in description)
    M = 0
    for color, pixels in shapes:
        min_r = min(r for r, c in pixels)
        max_r = max(r for r, c in pixels)
        min_c = min(c for r, c in pixels)
        max_c = max(c for r, c in pixels)
        size = max(max_r - min_r + 1, max_c - min_c + 1)
        M = max(M, size)

    # start from the input and add rotated copies
    output_grid = [row[:] for row in input_grid]

    for color, pixels in shapes:
        min_r = min(r for r, c in pixels)
        max_r = max(r for r, c in pixels)
        min_c = min(c for r, c in pixels)
        max_c = max(c for r, c in pixels)
        bbox_h = max_r - min_r + 1
        bbox_w = max_c - min_c + 1
        size = max(bbox_h, bbox_w)

        # build the local shape bitmap
        shape_grid = [[0] * bbox_w for _ in range(bbox_h)]
        for r, c in pixels:
            shape_grid[r - min_r][c - min_c] = color

        prev_anchor_r, prev_anchor_c = min_r, min_c
        prev_h, prev_w = bbox_h, bbox_w

        # place copies in a chain: n=0 original (already present), n=1..size-1 placed around previous
        for n in range(1, size):
            rot = rotate_n(shape_grid, n)
            h_n = len(rot)
            w_n = len(rot[0])
            d = (n - 1) % 4
            if d == 0:
                new_r = prev_anchor_r
                new_c = prev_anchor_c + prev_w
            elif d == 1:
                new_r = prev_anchor_r - h_n
                new_c = prev_anchor_c
            elif d == 2:
                new_r = prev_anchor_r
                new_c = prev_anchor_c - w_n
            else:
                new_r = prev_anchor_r + prev_h
                new_c = prev_anchor_c

            ok = True
            cells = []
            for rr in range(h_n):
                for cc in range(w_n):
                    if rot[rr][cc] != 0:
                        R = new_r + rr
                        C = new_c + cc
                        if R < 0 or R >= height or C < 0 or C >= width or output_grid[R][C] != 0:
                            ok = False
                            break
                        cells.append((R, C))
                if not ok:
                    break

            if ok:
                for R, C in cells:
                    output_grid[R][C] = color
                prev_anchor_r, prev_anchor_c = new_r, new_c
                prev_h, prev_w = h_n, w_n

    return output_grid

