# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 2e489edc
Difficulty: very hard

=== Tags ===
- Dynamic environment
- Shape attribute projection
- Grid topology inference
- Area based reconstruction

=== Description ===
Input grids consist of multiple non-overlapping, contiguous colored regions
(each region is a single non-zero color, background is 0) arranged in complex
topological configurations. Regions may be adjacent, nested, or connected
through narrow passages, forming a dynamic spatial network. The output grid
requires reconstructing each region based on "shape attribute projection"
derived from its topological relationships. Specifically, each region's output
shape and color are determined by the colors and relative positions of its
neighboring regions. For example, a region adjacent to red above and blue below
becomes a vertical stripe pattern with red on top and blue on bottom, while a
region nested within a green region adopts a gradient toward green. Nested
regions project attributes inward, modifying inner regions based on outer region
colors. The reconstruction must preserve grid dimensions, with background
remaining 0, and requires inferring the complete topological structure
(including adjacency chains and nesting hierarchies) before applying the
projection rules. This task demands multi-step reasoning: first identifying all
topological relationships through connectivity analysis, then applying cascading
attribute projections that depend on the spatial arrangement of neighbors in all
directions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque, Counter


def generate():
    # Grid size
    width = random.randint(8, 20)
    height = random.randint(8, 20)
    grid = [[0 for _ in range(width)] for _ in range(height)]
    occ = [[False for _ in range(width)] for _ in range(height)]

    regions = {}  # color -> list of (r,c)

    # Prepare a pool of distinct colors
    colors_pool = random.sample(list(range(1, 10)), 9)

    # Helper functions
    def can_place_rect(top, left, h, w):
        if top < 0 or left < 0 or top + h > height or left + w > width:
            return False
        for rr in range(top, top + h):
            for cc in range(left, left + w):
                if occ[rr][cc]:
                    return False
        return True

    def place_rect(top, left, h, w, color):
        coords = []
        for rr in range(top, top + h):
            for cc in range(left, left + w):
                grid[rr][cc] = color
                occ[rr][cc] = True
                coords.append((rr, cc))
        regions[color] = coords

    def place_hollow_rect(top, left, h, w, color):
        coords = []
        for rr in range(top, top + h):
            for cc in range(left, left + w):
                if rr == top or rr == top + h - 1 or cc == left or cc == left + w - 1:
                    grid[rr][cc] = color
                    occ[rr][cc] = True
                    coords.append((rr, cc))
        regions[color] = coords

    # 1) Try to place an outer hollow ring to create a nested hole
    outer_ring = None
    if len(colors_pool) >= 2:
        for _ in range(120):
            rh = random.randint(5, min(12, height))
            rw = random.randint(5, min(12, width))
            rt = random.randint(0, height - rh)
            cl = random.randint(0, width - rw)
            if rh < 5 or rw < 5:
                continue
            # ensure border cells free
            ok = True
            for rr in range(rt, rt + rh):
                for cc in range(cl, cl + rw):
                    if rr == rt or rr == rt + rh - 1 or cc == cl or cc == cl + rw - 1:
                        if occ[rr][cc]:
                            ok = False
                            break
                if not ok:
                    break
            if not ok:
                continue
            outer_color = colors_pool.pop(0)
            place_hollow_rect(rt, cl, rh, rw, outer_color)
            outer_ring = (rt, cl, rh, rw, outer_color)
            break

    # 2) If we created a ring, place an inner region inside its hole
    if outer_ring:
        rt, cl, rh, rw, outer_color = outer_ring
        hole_t = rt + 1
        hole_l = cl + 1
        hole_h = rh - 2
        hole_w = rw - 2
        # Choose an inner rect that does not completely fill the hole
        max_inner_h = max(1, hole_h - 1)
        max_inner_w = max(1, hole_w - 1)
        inner_h = random.randint(1, max_inner_h)
        inner_w = random.randint(1, max_inner_w)
        inner_top = random.randint(hole_t, hole_t + hole_h - inner_h)
        inner_left = random.randint(hole_l, hole_l + hole_w - inner_w)
        if len(colors_pool) == 0:
            inner_color = outer_color
        else:
            inner_color = colors_pool.pop(0)
        place_rect(inner_top, inner_left, inner_h, inner_w, inner_color)

        # Try to place a top neighbor and bottom neighbor inside the hole (so they are adjacent to inner region)
        # top neighbor
        if hole_h >= 3 and len(colors_pool) >= 1:
            # space above inner?
            if inner_top - hole_t >= 1:
                top_h = random.randint(1, min(2, inner_top - hole_t))
                top_w = random.randint(1, inner_w)
                top_left = inner_left + random.randint(0, max(0, inner_w - top_w))
                top_top = inner_top - top_h
                if can_place_rect(top_top, top_left, top_h, top_w):
                    top_color = colors_pool.pop(0)
                    place_rect(top_top, top_left, top_h, top_w, top_color)
        # bottom neighbor
        if hole_h >= 3 and len(colors_pool) >= 1:
            space_below = hole_t + hole_h - (inner_top + inner_h)
            if space_below >= 1:
                bot_h = random.randint(1, min(2, space_below))
                bot_w = random.randint(1, inner_w)
                bot_left = inner_left + random.randint(0, max(0, inner_w - bot_w))
                bot_top = inner_top + inner_h
                if can_place_rect(bot_top, bot_left, bot_h, bot_w):
                    bot_color = colors_pool.pop(0)
                    place_rect(bot_top, bot_left, bot_h, bot_w, bot_color)

    # 3) Create a vertical triple (top, middle, bottom) somewhere else for vertical-stripe cases
    def try_place_vertical_triple():
        if len(colors_pool) < 3:
            return False
        for _ in range(200):
            triple_w = random.randint(2, min(6, width))
            left = random.randint(0, width - triple_w)
            if height < 3:
                return False
            top = random.randint(0, height - 3)
            max_total_h = height - top
            total_h = random.randint(3, min(10, max_total_h))
            # split total_h into three positive integers
            cut1 = random.randint(1, total_h - 2)
            cut2 = random.randint(cut1 + 1, total_h - 1)
            h1 = cut1
            h2 = cut2 - cut1
            h3 = total_h - cut2
            if not can_place_rect(top, left, h1, triple_w):
                continue
            if not can_place_rect(top + h1, left, h2, triple_w):
                continue
            if not can_place_rect(top + h1 + h2, left, h3, triple_w):
                continue
            c1 = colors_pool.pop(0)
            place_rect(top, left, h1, triple_w, c1)
            c2 = colors_pool.pop(0)
            place_rect(top + h1, left, h2, triple_w, c2)
            c3 = colors_pool.pop(0)
            place_rect(top + h1 + h2, left, h3, triple_w, c3)
            return True
        return False

    try_place_vertical_triple()

    # 4) Create a horizontal triple (left, middle, right) somewhere else for horizontal-stripe cases
    def try_place_horizontal_triple():
        if len(colors_pool) < 3:
            return False
        for _ in range(200):
            triple_h = random.randint(2, min(6, height))
            top = random.randint(0, height - triple_h)
            if width < 3:
                return False
            left = random.randint(0, width - 3)
            max_total_w = width - left
            total_w = random.randint(3, min(10, max_total_w))
            cut1 = random.randint(1, total_w - 2)
            cut2 = random.randint(cut1 + 1, total_w - 1)
            w1 = cut1
            w2 = cut2 - cut1
            w3 = total_w - cut2
            if not can_place_rect(top, left, triple_h, w1):
                continue
            if not can_place_rect(top, left + w1, triple_h, w2):
                continue
            if not can_place_rect(top, left + w1 + w2, triple_h, w3):
                continue
            c1 = colors_pool.pop(0)
            place_rect(top, left, triple_h, w1, c1)
            c2 = colors_pool.pop(0)
            place_rect(top, left + w1, triple_h, w2, c2)
            c3 = colors_pool.pop(0)
            place_rect(top, left + w1 + w2, triple_h, w3, c3)
            return True
        return False

    try_place_horizontal_triple()

    # 5) Place a couple of random small rectangles to increase complexity
    tries = 0
    while len(regions) < 6 and tries < 200 and colors_pool:
        rw = random.randint(1, min(5, width))
        rh = random.randint(1, min(5, height))
        top = random.randint(0, height - rh)
        left = random.randint(0, width - rw)
        if can_place_rect(top, left, rh, rw):
            c = colors_pool.pop(0)
            place_rect(top, left, rh, rw, c)
        tries += 1

    # 6) Now compute the output grid by analyzing topological relationships and applying projections
    def build_regions_map(g):
        mp = {}
        for rr in range(height):
            for cc in range(width):
                val = g[rr][cc]
                if val == 0:
                    continue
                mp.setdefault(val, []).append((rr, cc))
        return mp

    regions_map = build_regions_map(grid)

    # Background components (connected components of zeros)
    visited_bg = [[False for _ in range(width)] for _ in range(height)]
    bg_components = []  # list of dicts: {coords:set(), touches_border:bool, neighbor_colors:Counter}
    for rr in range(height):
        for cc in range(width):
            if grid[rr][cc] != 0 or visited_bg[rr][cc]:
                continue
            # BFS a background component
            q = deque()
            q.append((rr, cc))
            visited_bg[rr][cc] = True
            coords = []
            touches_border = False
            neighbor_colors = Counter()
            while q:
                br, bc = q.popleft()
                coords.append((br, bc))
                if br == 0 or bc == 0 or br == height - 1 or bc == width - 1:
                    touches_border = True
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = br + dr, bc + dc
                    if nr < 0 or nr >= height or nc < 0 or nc >= width:
                        continue
                    if grid[nr][nc] == 0 and not visited_bg[nr][nc]:
                        visited_bg[nr][nc] = True
                        q.append((nr, nc))
                    elif grid[nr][nc] != 0:
                        neighbor_colors[grid[nr][nc]] += 1
            bg_components.append({
                'coords': coords,
                'touches_border': touches_border,
                'neighbor_colors': neighbor_colors
            })

    # For each background hole (not touching border) determine outer ring color and which inner regions are inside it
    nested_map = {}  # inner_color -> outer_color
    for comp in bg_components:
        if comp['touches_border']:
            continue
        if not comp['neighbor_colors']:
            continue
        # outer color is the most common neighbor of the hole
        outer_color = comp['neighbor_colors'].most_common(1)[0][0]
        # inner region colors are other neighbor colors around the hole (if any)
        inner_candidates = set(comp['neighbor_colors'].keys()) - {outer_color}
        for inner in inner_candidates:
            nested_map[inner] = outer_color

    # Helper to find adjacency directions and their most frequent neighbor color
    def adjacency_for_region(color, coords):
        top_cnt = Counter()
        bot_cnt = Counter()
        left_cnt = Counter()
        right_cnt = Counter()
        for (rr, cc) in coords:
            if rr > 0 and grid[rr - 1][cc] != 0 and grid[rr - 1][cc] != color:
                top_cnt[grid[rr - 1][cc]] += 1
            if rr < height - 1 and grid[rr + 1][cc] != 0 and grid[rr + 1][cc] != color:
                bot_cnt[grid[rr + 1][cc]] += 1
            if cc > 0 and grid[rr][cc - 1] != 0 and grid[rr][cc - 1] != color:
                left_cnt[grid[rr][cc - 1]] += 1
            if cc < width - 1 and grid[rr][cc + 1] != 0 and grid[rr][cc + 1] != color:
                right_cnt[grid[rr][cc + 1]] += 1
        def most_common_or_none(cnt):
            if not cnt:
                return None
            return cnt.most_common(1)[0][0]
        return {
            'top': most_common_or_none(top_cnt),
            'bottom': most_common_or_none(bot_cnt),
            'left': most_common_or_none(left_cnt),
            'right': most_common_or_none(right_cnt),
            'counts': {'top': top_cnt, 'bottom': bot_cnt, 'left': left_cnt, 'right': right_cnt}
        }

    # Build output grid
    output = [[0 for _ in range(width)] for _ in range(height)]

    for color, coords in regions_map.items():
        # nested rule
        if color in nested_map:
            outer = nested_map[color]
            # gradient toward outer color from center
            rs = [p[0] for p in coords]
            cs = [p[1] for p in coords]
            if coords:
                rc = sum(rs) / len(rs)
                cc = sum(cs) / len(cs)
                maxd = 0.0
                dists = []
                for (r0, c0) in coords:
                    d = ((r0 - rc) ** 2 + (c0 - cc) ** 2) ** 0.5
                    dists.append(d)
                    if d > maxd:
                        maxd = d
                for (idx, (r0, c0)) in enumerate(coords):
                    if maxd == 0:
                        val = outer
                    else:
                        ratio = dists[idx] / maxd
                        valf = color + (outer - color) * ratio
                        val = int(round(valf))
                        if val < 1:
                            val = 1
                        if val > 9:
                            val = 9
                    output[r0][c0] = val
            continue

        # adjacency rules
        adj = adjacency_for_region(color, coords)
        topc = adj['top']
        botc = adj['bottom']
        leftc = adj['left']
        rightc = adj['right']

        if topc is not None and botc is not None:
            # vertical stripe: split by row midpoint of bounding box
            rows = [p[0] for p in coords]
            minr, maxr = min(rows), max(rows)
            threshold = (minr + maxr) // 2
            for (r0, c0) in coords:
                output[r0][c0] = topc if r0 <= threshold else botc
            continue

        if leftc is not None and rightc is not None:
            cols = [p[1] for p in coords]
            minc, maxc = min(cols), max(cols)
            threshold = (minc + maxc) // 2
            for (r0, c0) in coords:
                output[r0][c0] = leftc if c0 <= threshold else rightc
            continue

        # if any neighbor exists, pick the most frequent neighbor across directions
        total_neighbor_counts = Counter()
        for d in ['top', 'bottom', 'left', 'right']:
            total_neighbor_counts.update(adj['counts'][d])
        if total_neighbor_counts:
            fill_color = total_neighbor_counts.most_common(1)[0][0]
            for (r0, c0) in coords:
                output[r0][c0] = fill_color
            continue

        # otherwise preserve color
        for (r0, c0) in coords:
            output[r0][c0] = color

    # Safety: ensure output != input
    same = True
    for rr in range(height):
        for cc in range(width):
            if grid[rr][cc] != output[rr][cc]:
                same = False
                break
        if not same:
            break
    if same:
        # Force at least one pixel change: change first non-zero pixel to a different color (bounded 1..9)
        for rr in range(height):
            for cc in range(width):
                if grid[rr][cc] != 0:
                    newcol = grid[rr][cc] % 9 + 1
                    output[rr][cc] = newcol
                    same = False
                    break
            if not same:
                break

    return {'input': grid, 'output': output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque, Counter

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height else 0

    # Build regions map (color -> list of coords)
    regions_map = {}
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if v == 0:
                continue
            regions_map.setdefault(v, []).append((r, c))

    # Background components
    visited_bg = [[False for _ in range(width)] for _ in range(height)]
    bg_components = []
    for rr in range(height):
        for cc in range(width):
            if grid[rr][cc] != 0 or visited_bg[rr][cc]:
                continue
            q = deque()
            q.append((rr, cc))
            visited_bg[rr][cc] = True
            coords = []
            touches_border = False
            neighbor_colors = Counter()
            while q:
                br, bc = q.popleft()
                coords.append((br, bc))
                if br == 0 or bc == 0 or br == height - 1 or bc == width - 1:
                    touches_border = True
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = br + dr, bc + dc
                    if nr < 0 or nr >= height or nc < 0 or nc >= width:
                        continue
                    if grid[nr][nc] == 0 and not visited_bg[nr][nc]:
                        visited_bg[nr][nc] = True
                        q.append((nr, nc))
                    elif grid[nr][nc] != 0:
                        neighbor_colors[grid[nr][nc]] += 1
            bg_components.append({'coords': coords, 'touches_border': touches_border, 'neighbor_colors': neighbor_colors})

    nested_map = {}
    for comp in bg_components:
        if comp['touches_border']:
            continue
        if not comp['neighbor_colors']:
            continue
        outer_color = comp['neighbor_colors'].most_common(1)[0][0]
        inner_candidates = set(comp['neighbor_colors'].keys()) - {outer_color}
        for inner in inner_candidates:
            nested_map[inner] = outer_color

    # adjacency helper
    def adjacency_for_region(color, coords):
        top_cnt = Counter()
        bot_cnt = Counter()
        left_cnt = Counter()
        right_cnt = Counter()
        for (rr, cc) in coords:
            if rr > 0 and grid[rr - 1][cc] != 0 and grid[rr - 1][cc] != color:
                top_cnt[grid[rr - 1][cc]] += 1
            if rr < height - 1 and grid[rr + 1][cc] != 0 and grid[rr + 1][cc] != color:
                bot_cnt[grid[rr + 1][cc]] += 1
            if cc > 0 and grid[rr][cc - 1] != 0 and grid[rr][cc - 1] != color:
                left_cnt[grid[rr][cc - 1]] += 1
            if cc < width - 1 and grid[rr][cc + 1] != 0 and grid[rr][cc + 1] != color:
                right_cnt[grid[rr][cc + 1]] += 1
        def most_common_or_none(cnt):
            if not cnt:
                return None
            return cnt.most_common(1)[0][0]
        return {'top': most_common_or_none(top_cnt), 'bottom': most_common_or_none(bot_cnt), 'left': most_common_or_none(left_cnt), 'right': most_common_or_none(right_cnt), 'counts': {'top': top_cnt, 'bottom': bot_cnt, 'left': left_cnt, 'right': right_cnt}}

    # Build output
    output = [[0 for _ in range(width)] for _ in range(height)]

    for color, coords in regions_map.items():
        if color in nested_map:
            outer = nested_map[color]
            rs = [p[0] for p in coords]
            cs = [p[1] for p in coords]
            if coords:
                rc = sum(rs) / len(rs)
                cc = sum(cs) / len(cs)
                maxd = 0.0
                dists = []
                for (r0, c0) in coords:
                    d = ((r0 - rc) ** 2 + (c0 - cc) ** 2) ** 0.5
                    dists.append(d)
                    if d > maxd:
                        maxd = d
                for (idx, (r0, c0)) in enumerate(coords):
                    if maxd == 0:
                        val = outer
                    else:
                        ratio = dists[idx] / maxd
                        valf = color + (outer - color) * ratio
                        val = int(round(valf))
                        if val < 1:
                            val = 1
                        if val > 9:
                            val = 9
                    output[r0][c0] = val
            continue

        adj = adjacency_for_region(color, coords)
        topc = adj['top']
        botc = adj['bottom']
        leftc = adj['left']
        rightc = adj['right']

        if topc is not None and botc is not None:
            rows = [p[0] for p in coords]
            minr, maxr = min(rows), max(rows)
            threshold = (minr + maxr) // 2
            for (r0, c0) in coords:
                output[r0][c0] = topc if r0 <= threshold else botc
            continue

        if leftc is not None and rightc is not None:
            cols = [p[1] for p in coords]
            minc, maxc = min(cols), max(cols)
            threshold = (minc + maxc) // 2
            for (r0, c0) in coords:
                output[r0][c0] = leftc if c0 <= threshold else rightc
            continue

        total_neighbor_counts = Counter()
        for d in ['top', 'bottom', 'left', 'right']:
            total_neighbor_counts.update(adj['counts'][d])
        if total_neighbor_counts:
            fill_color = total_neighbor_counts.most_common(1)[0][0]
            for (r0, c0) in coords:
                output[r0][c0] = fill_color
            continue

        for (r0, c0) in coords:
            output[r0][c0] = color

    # Return as tuple of tuples
    return tuple(tuple(row) for row in output)

