# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 5d92ea9b
Difficulty: very hard

=== Tags ===
- Color signal exchange
- Magnetic path alignment
- Alternating rule composition
- Image filling

=== Description ===
The input grid features a uniform background (color 0) overlaid with red (color
1) and blue (color 2) magnetic nodes. Each red node represents a North pole,
while each blue node represents a South pole. The output grid requires a multi-
step transformation based on the following rules:  1. **Magnetic Path
Alignment**: For every pair of aligned North-South poles (red and blue nodes
sharing the same row or column with no intervening nodes), draw a straight-line
path between them. Paths are ordered by the row index of the North pole (red
node), then by column index, to determine the sequence for alternating color
assignment.  2. **Color Signal Exchange**: When paths intersect, their colors
are exchanged for all segments beyond the intersection point. For example, a red
path crossing a blue path becomes blue for the remaining segment, and the blue
path becomes red for its remaining segment.  3. **Alternating Rule
Composition**: The initial path color alternates starting with red for the first
ordered path, blue for the second, red for the third, and so on. This
alternation persists through all path segments after color exchange.  4. **Image
Filling**: After all path color exchanges are resolved, fill all enclosed
regions bounded exclusively by paths with the color of the path forming their
boundary. Regions not enclosed remain background (color 0).  The transformation
demands sequential application of these rules with dependencies: path ordering
determines initial colors, intersections dynamically alter path colors, and the
final filling depends on the updated path configuration. The complexity arises
from the interplay between path alignment, dynamic color exchange at
intersections, and region identification in a grid with multiple overlapping
paths, requiring the solver to track spatial relationships and color states
across multiple iterations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    size = random.randint(10, 30)
    input_grid = [[0] * size for _ in range(size)]
    
    # Randomize vertical pairs (red top, blue bottom)
    vertical_cols = random.sample(range(1, size-1, 2), k=random.randint(2, min(3, size//3)))
    for col in vertical_cols:
        input_grid[0][col] = 1  # North pole (red)
        input_grid[size-1][col] = 2  # South pole (blue)
    
    # Randomize horizontal pairs (red left, blue right)
    horizontal_rows = random.sample(range(1, size-1, 2), k=random.randint(2, min(3, size//3)))
    for row in horizontal_rows:
        input_grid[row][0] = 1  # North pole
        input_grid[row][size-1] = 2  # South pole
    
    # Create output grid by simulating rules
    output_grid = [[0] * size for _ in range(size)]
    
    # Find all pairs (vertical and horizontal)
    pairs = []
    for col in vertical_cols:
        pairs.append(((0, col), (size-1, col)))  # Vertical pair
    for row in horizontal_rows:
        pairs.append(((row, 0), (row, size-1)))  # Horizontal pair
    
    # Sort pairs by red node's row then column
    pairs.sort(key=lambda x: (x[0][0], x[0][1]))
    
    # Assign alternating colors
    colors = [1 if i % 2 == 0 else 2 for i in range(len(pairs))]
    
    # Draw paths with assigned colors
    for (red, blue), color in zip(pairs, colors):
        if red[0] == blue[0]:  # Horizontal
            for c in range(min(red[1], blue[1]), max(red[1], blue[1]) + 1):
                output_grid[red[0]][c] = color
        else:  # Vertical
            for r in range(min(red[0], blue[0]), max(red[0], blue[0]) + 1):
                output_grid[r][red[1]] = color
    
    # Apply color exchange at intersections
    for r in range(size):
        for c in range(size):
            if output_grid[r][c] > 0:
                # Check if intersection (multiple paths cross)
                if (r > 0 and output_grid[r-1][c] > 0 and output_grid[r][c] != output_grid[r-1][c]) or \
                   (c > 0 and output_grid[r][c-1] > 0 and output_grid[r][c] != output_grid[r][c-1]):
                    output_grid[r][c] = 3 - output_grid[r][c]
    
    # Fill enclosed regions
    for r in range(1, size-1):
        for c in range(1, size-1):
            if output_grid[r][c] == 0:
                if (output_grid[r-1][c] > 0 and output_grid[r+1][c] > 0 and
                    output_grid[r][c-1] > 0 and output_grid[r][c+1] > 0):
                    output_grid[r][c] = output_grid[r][c+1]
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable list of lists
    grid = [list(row) for row in input_grid]
    size = len(grid)
    
    # Identify red (1) and blue (2) nodes
    red_nodes = []
    blue_nodes = []
    for r in range(size):
        for c in range(size):
            if grid[r][c] == 1:
                red_nodes.append((r, c))
            elif grid[r][c] == 2:
                blue_nodes.append((r, c))
    
    # Find valid pairs (aligned with no nodes in between)
    pairs = []
    for r, c in red_nodes:
        # Check horizontal alignment (right)
        for dc in range(1, size - c):
            if (r, c + dc) in blue_nodes and all(grid[r][c + dc2] == 0 for dc2 in range(1, dc)):
                pairs.append(((r, c), (r, c + dc)))
                break
        # Check vertical alignment (down)
        for dr in range(1, size - r):
            if (r + dr, c) in blue_nodes and all(grid[r + dr2][c] == 0 for dr2 in range(1, dr)):
                pairs.append(((r, c), (r + dr, c)))
                break
    
    # Sort pairs by red node's row then column
    pairs.sort(key=lambda x: (x[0][0], x[0][1]))
    
    # Initialize output grid
    output = [[0] * size for _ in range(size)]
    
    # Assign alternating colors
    for idx, ((r, c), (br, bc)) in enumerate(pairs):
        color = 1 if idx % 2 == 0 else 2
        if r == br:  # Horizontal
            for col in range(min(c, bc), max(c, bc) + 1):
                output[r][col] = color
        else:  # Vertical
            for row in range(min(r, br), max(r, br) + 1):
                output[row][c] = color
    
    # Apply color exchange at intersections
    for r in range(size):
        for c in range(size):
            if output[r][c] > 0:
                if (r > 0 and output[r-1][c] > 0 and output[r][c] != output[r-1][c]) or \
                   (c > 0 and output[r][c-1] > 0 and output[r][c] != output[r][c-1]):
                    output[r][c] = 3 - output[r][c]
    
    # Fill enclosed regions
    for r in range(1, size-1):
        for c in range(1, size-1):
            if output[r][c] == 0:
                if (output[r-1][c] > 0 and output[r+1][c] > 0 and
                    output[r][c-1] > 0 and output[r][c+1] > 0):
                    output[r][c] = output[r][c+1]
    
    return output
