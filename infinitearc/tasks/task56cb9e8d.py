# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 56cb9e8d
Difficulty: easy

=== Tags ===
- Detect enclosure

=== Description ===
Each input grid contains a single closed rectangular boundary formed by a
distinct non-zero color (e.g., color 1). The boundary is complete, with all four
sides present and no gaps, enclosing a contiguous region. The output grid is
identical to the input except that all cells strictly inside this enclosed
rectangle are replaced with a fixed color (e.g., color 2), while the boundary
itself and all exterior cells remain unchanged. The task requires recognizing
the enclosed area defined by the closed loop and applying a consistent color
replacement to its interior.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    input_grid = [[0] * width for _ in range(height)]
    
    r1 = random.randint(0, height - 3)
    r2 = random.randint(r1 + 2, height - 1)
    c1 = random.randint(0, width - 3)
    c2 = random.randint(c1 + 2, width - 1)
    
    for c in range(c1, c2 + 1):
        input_grid[r1][c] = 1
        input_grid[r2][c] = 1
    for r in range(r1, r2 + 1):
        input_grid[r][c1] = 1
        input_grid[r][c2] = 1
    
    output_grid = [row[:] for row in input_grid]
    for r in range(r1 + 1, r2):
        for c in range(c1 + 1, c2):
            output_grid[r][c] = 2
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    non_zero = []
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] != 0:
                non_zero.append((r, c))
    
    if not non_zero:
        return input_grid
    
    rows = [p[0] for p in non_zero]
    cols = [p[1] for p in non_zero]
    r1, r2 = min(rows), max(rows)
    c1, c2 = min(cols), max(cols)
    
    for c in range(c1, c2 + 1):
        if input_grid[r1][c] == 0:
            return input_grid
    for c in range(c1, c2 + 1):
        if input_grid[r2][c] == 0:
            return input_grid
    for r in range(r1, r2 + 1):
        if input_grid[r][c1] == 0:
            return input_grid
    for r in range(r1, r2 + 1):
        if input_grid[r][c2] == 0:
            return input_grid
    
    output_grid = [list(row) for row in input_grid]
    for r in range(r1 + 1, r2):
        for c in range(c1 + 1, c2):
            output_grid[r][c] = 2
    return output_grid
