# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 495b5b59
Difficulty: very hard

=== Tags ===
- Color stream
- Mark centroid
- Pattern expansion

=== Description ===
Input grids consist of a single background color (0) and multiple distinct,
connected regions of non-zero colors. Each region is a contiguous group of cells
sharing the same color, with regions of different colors remaining separate and
non-overlapping. For each region, compute its centroid as the rounded average of
all row and column coordinates of its cells. In the output grid, the centroid of
each region is marked by changing that cell to a fixed marker color (9), while
preserving all other original region cells. Additionally, a diamond-shaped
pattern is expanded from each centroid using the region's original color. The
diamond's radius is determined by the floor of the square root of the region's
area (number of cells). The diamond includes all cells where the Manhattan
distance from the centroid is less than or equal to the radius. This pattern is
drawn only on background cells (0) in the input, meaning existing regions and
the marked centroid cell are preserved without overwriting. If the diamond would
extend beyond the grid boundary or overlap with non-background cells, expansion
stops at the first such cell. The output grid thus features marked centroids and
expanded diamond patterns for each region, while maintaining the original
regions and background structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import math
from collections import deque
from common import grid, random_color


def generate():
    """
    Generate an input/output pair.

    - Create a grid with a zero background.
    - Place 2-5 distinct contiguous regions (unique colors, excluding 9).
    - For each region compute centroid = rounded average of coordinates (row, col).
    - Mark centroid in the output with color 9 (do not overwrite other original region cells).
    - Expand a diamond-shaped pattern from the centroid using BFS up to radius=floor(sqrt(area)),
      only moving through background cells (input grid == 0). Do not overwrite the centroid.
    """
    # Try several times if placement fails
    for _attempt in range(100):
        width = random.randint(6, 25)
        height = random.randint(6, 25)
        input_grid = grid(width, height, 0)

        occupied = set()
        regions = []  # list of (color, list_of_pixels)
        colors_used = []

        # Choose number of regions; limited so colors remain available
        max_regions = min(5, 8)  # can't use more than 8 distinct non-9 colors
        num_regions = random.randint(2, max_regions)

        ok = True
        for i in range(num_regions):
            # pick a color excluding already used colors and the marker color 9
            color = random_color(exclude=colors_used + [9])
            colors_used.append(color)

            # maximum remaining free cells to ensure we can still place the remaining regions
            remaining_cells = width * height - len(occupied)
            if remaining_cells <= 0:
                ok = False
                break

            # pick a region size (at least 1, capped reasonably)
            max_size = min(12, remaining_cells - (num_regions - i - 1))
            if max_size <= 0:
                ok = False
                break
            size = random.randint(1, max_size)

            placed = False
            # Try multiple random placements/grows
            for attempt_place in range(300):
                r0 = random.randint(0, height - 1)
                c0 = random.randint(0, width - 1)
                if (r0, c0) in occupied:
                    continue
                pixels = [(r0, c0)]
                # Grow the region to the desired size by adding adjacent cells
                grow_failed = False
                for _ in range(size - 1):
                    # try to expand from a random existing pixel
                    idx = random.randrange(len(pixels))
                    pr, pc = pixels[idx]
                    neighbors = [(pr + 1, pc), (pr - 1, pc), (pr, pc + 1), (pr, pc - 1)]
                    random.shuffle(neighbors)
                    added = False
                    for nr, nc in neighbors:
                        if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in occupied and (nr, nc) not in pixels:
                            pixels.append((nr, nc))
                            added = True
                            break
                    if not added:
                        # Try any neighbor of any current pixel
                        pool = pixels[:]
                        random.shuffle(pool)
                        found = False
                        for pr2, pc2 in pool:
                            neighbors = [(pr2 + 1, pc2), (pr2 - 1, pc2), (pr2, pc2 + 1), (pr2, pc2 - 1)]
                            random.shuffle(neighbors)
                            for nr, nc in neighbors:
                                if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in occupied and (nr, nc) not in pixels:
                                    pixels.append((nr, nc))
                                    found = True
                                    break
                            if found:
                                break
                        if not found:
                            grow_failed = True
                            break
                if grow_failed or len(pixels) != size:
                    continue
                # ensure no overlap with existing regions
                conflict = False
                for p in pixels:
                    if p in occupied:
                        conflict = True
                        break
                if conflict:
                    continue
                # place pixels
                for pr, pc in pixels:
                    input_grid[pr][pc] = color
                    occupied.add((pr, pc))
                regions.append((color, pixels))
                placed = True
                break

            if not placed:
                ok = False
                break

        if not ok:
            # try a fresh layout
            continue

        # Sort regions by their top-leftmost pixel so order matches solver's scan order
        regions.sort(key=lambda rc: min(rc[1]))

        # Create output and apply centroid marking + diamond expansion using original input as mask
        output_grid = [row[:] for row in input_grid]
        for color, pixels in regions:
            area = len(pixels)
            sum_r = sum(r for (r, c) in pixels)
            sum_c = sum(c for (r, c) in pixels)
            centroid_r = int(round(sum_r / area))
            centroid_c = int(round(sum_c / area))
            centroid_r = max(0, min(centroid_r, height - 1))
            centroid_c = max(0, min(centroid_c, width - 1))

            # mark centroid with 9 (overwrites whatever was there in the output)
            output_grid[centroid_r][centroid_c] = 9

            # BFS diamond expansion limited by radius and blocked by non-background cells in the original input
            radius = int(math.floor(math.sqrt(area)))
            q = deque()
            q.append((centroid_r, centroid_c, 0))
            visited = set()
            visited.add((centroid_r, centroid_c))
            while q:
                r, c, d = q.popleft()
                # paint only background cells from the original input and do not overwrite the centroid marker
                if d > 0 and input_grid[r][c] == 0 and not (r == centroid_r and c == centroid_c):
                    output_grid[r][c] = color
                if d >= radius:
                    continue
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = r + dr, c + dc
                    if not (0 <= nr < height and 0 <= nc < width):
                        continue
                    if (nr, nc) in visited:
                        continue
                    # only traverse through original-background cells
                    if input_grid[nr][nc] != 0:
                        continue
                    visited.add((nr, nc))
                    q.append((nr, nc, d + 1))

        return {"input": input_grid, "output": output_grid}

    # Fallback (shouldn't normally happen)
    w, h = 6, 6
    g = grid(w, h, 0)
    return {"input": g, "output": g}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import math
from collections import deque

def p(input_grid):
    # convert to mutable list of lists
    grid_list = [list(row) for row in input_grid]
    height = len(grid_list)
    width = len(grid_list[0])

    visited = [[False] * width for _ in range(height)]
    regions = []  # will collect (color, pixels) in scan order

    for r in range(height):
        for c in range(width):
            if grid_list[r][c] != 0 and not visited[r][c]:
                color = grid_list[r][c]
                # flood-fill to get the connected region of this color
                stack = [(r, c)]
                visited[r][c] = True
                pixels = []
                while stack:
                    x, y = stack.pop()
                    pixels.append((x, y))
                    for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nx, ny = x + dx, y + dy
                        if 0 <= nx < height and 0 <= ny < width and not visited[nx][ny] and grid_list[nx][ny] == color:
                            visited[nx][ny] = True
                            stack.append((nx, ny))
                regions.append((color, pixels))

    # Build output copying the input
    output_grid = [row[:] for row in grid_list]

    # Process regions in the same scan order we discovered them
    for color, pixels in regions:
        area = len(pixels)
        sum_r = sum(r for (r, c) in pixels)
        sum_c = sum(c for (r, c) in pixels)
        centroid_r = int(round(sum_r / area))
        centroid_c = int(round(sum_c / area))
        centroid_r = max(0, min(centroid_r, height - 1))
        centroid_c = max(0, min(centroid_c, width - 1))

        # mark centroid with 9
        output_grid[centroid_r][centroid_c] = 9

        # BFS diamond expansion limited by radius and blocked by non-background cells in original input
        radius = int(math.floor(math.sqrt(area)))
        q = deque()
        q.append((centroid_r, centroid_c, 0))
        visited_bfs = set()
        visited_bfs.add((centroid_r, centroid_c))
        while q:
            r, c, d = q.popleft()
            if d > 0 and grid_list[r][c] == 0 and not (r == centroid_r and c == centroid_c):
                output_grid[r][c] = color
            if d >= radius:
                continue
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = r + dr, c + dc
                if not (0 <= nr < height and 0 <= nc < width):
                    continue
                if (nr, nc) in visited_bfs:
                    continue
                # only traverse through original-background cells
                if grid_list[nr][nc] != 0:
                    continue
                visited_bfs.add((nr, nc))
                q.append((nr, nc, d + 1))

    return tuple(tuple(row) for row in output_grid)

