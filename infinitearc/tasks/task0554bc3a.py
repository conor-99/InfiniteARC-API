# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 0554bc3a
Difficulty: hard

=== Tags ===
- Paint on collision

=== Description ===
Input grids are large (20×20 or larger) with a uniform background color (0).
Obstacles appear as connected regions of color 1 arranged in intricate, maze-
like configurations that block movement. Positioned on all four edges of the
grid are multiple agents (distinct colors 2–9), each oriented inward along their
edge (e.g., left-edge agents move right, top-edge agents move down). Agents move
one cell per step orthogonally toward the grid's center until they collide with
an obstacle (color 1), at which point they permanently repaint the obstacle cell
with their color. Agents that exit the grid without colliding leave no mark in
the output. Obstacles not hit by any agent retain their original color.  Output
grids display the background, unchanged obstacles, and repainted obstacle cells
(formerly color 1) now matching the color of the agent that collided with them.
The transformation requires simulating each agent's path independently,
identifying collision points, and applying color changes. The complexity arises
from non-straight paths through obstacles, multiple agents moving in different
directions, overlapping potential collision zones, and the need to resolve all
collisions without interference (agents do not interact with each other, only
with obstacles). The task demands precise path tracing and color mapping across
a visually complex grid with no redundant or overlapping transformations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Size between 20 and 30
    size = random.randint(20, 30)
    # Start with empty background
    grid = [[0 for _ in range(size)] for _ in range(size)]

    # Recursive division maze-like walls inside the inner region (keep 1-cell border free)
    def divide(top, left, bottom, right):
        w = right - left + 1
        h = bottom - top + 1
        # stop if region too small to divide
        if w < 3 or h < 3:
            return
        # choose orientation based on region shape
        if w < h:
            horizontal = True
        elif h < w:
            horizontal = False
        else:
            horizontal = random.choice([True, False])

        if horizontal:
            # choose a horizontal wall row (must leave at least one cell above and below)
            row = random.randint(top + 1, bottom - 1)
            hole = random.randint(left, right)
            for c in range(left, right + 1):
                grid[row][c] = 1
            # leave one hole
            grid[row][hole] = 0
            # recurse into subregions
            divide(top, left, row - 1, right)
            divide(row + 1, left, bottom, right)
        else:
            # vertical wall
            col = random.randint(left + 1, right - 1)
            hole = random.randint(top, bottom)
            for r in range(top, bottom + 1):
                grid[r][col] = 1
            grid[hole][col] = 0
            divide(top, left, bottom, col - 1)
            divide(top, col + 1, bottom, right)

    # Draw walls only in the interior so edges remain free for agents
    if size >= 5:
        divide(1, 1, size - 2, size - 2)

    # Helper to pick positions on a side ensuring adjacency cell (one step inward) is free.
    def choose_edge_positions(side, min_count, max_count):
        desired = random.randint(min_count, max_count)
        candidates = list(range(1, size - 1))
        random.shuffle(candidates)
        chosen = []
        for i in candidates:
            if side == 'left':
                if grid[i][1] == 0 and grid[i][0] == 0:
                    chosen.append(i)
            elif side == 'right':
                if grid[i][size - 2] == 0 and grid[i][size - 1] == 0:
                    chosen.append(i)
            elif side == 'top':
                if grid[1][i] == 0 and grid[0][i] == 0:
                    chosen.append(i)
            elif side == 'bottom':
                if grid[size - 2][i] == 0 and grid[size - 1][i] == 0:
                    chosen.append(i)
            if len(chosen) >= desired:
                break
        # Guarantee at least two agents per side by creating holes if necessary
        if len(chosen) < 2:
            for i in candidates:
                if i in chosen:
                    continue
                if side == 'left':
                    grid[i][1] = 0
                elif side == 'right':
                    grid[i][size - 2] = 0
                elif side == 'top':
                    grid[1][i] = 0
                elif side == 'bottom':
                    grid[size - 2][i] = 0
                chosen.append(i)
                if len(chosen) >= 2:
                    break
        return chosen

    # Decide how many agents per side (at least 2)
    max_per_side = max(2, size // 6)
    left_pos = choose_edge_positions('left', 2, max_per_side)
    top_pos = choose_edge_positions('top', 2, max_per_side)
    right_pos = choose_edge_positions('right', 2, max_per_side)
    bottom_pos = choose_edge_positions('bottom', 2, max_per_side)

    colors = list(range(2, 10))
    agents = []

    # Place agents in a deterministic scanning order: left (top->bottom), top (left->right), right (top->bottom), bottom (left->right)
    for r in sorted(left_pos):
        color = random.choice(colors)
        grid[r][0] = color
        agents.append((r, 0, color, 'R'))

    for c in sorted(top_pos):
        color = random.choice(colors)
        grid[0][c] = color
        agents.append((0, c, color, 'D'))

    for r in sorted(right_pos):
        color = random.choice(colors)
        grid[r][size - 1] = color
        agents.append((r, size - 1, color, 'L'))

    for c in sorted(bottom_pos):
        color = random.choice(colors)
        grid[size - 1][c] = color
        agents.append((size - 1, c, color, 'U'))

    # Prepare simulation grid and output
    sim = [row[:] for row in grid]
    output = [row[:] for row in grid]

    # Process each agent in the same scanning order used above.
    for ar, ac, color, dirc in agents:
        if dirc == 'R':
            dr, dc = 0, 1
        elif dirc == 'L':
            dr, dc = 0, -1
        elif dirc == 'D':
            dr, dc = 1, 0
        else:
            dr, dc = -1, 0

        r, c = ar + dr, ac + dc
        while 0 <= r < size and 0 <= c < size:
            if sim[r][c] == 1:
                # repaint obstacle in both the simulation grid and the output so later agents don't hit it
                sim[r][c] = color
                output[r][c] = color
                break
            r += dr
            c += dc
        # agents leave no mark in the output (they disappear)
        output[ar][ac] = 0

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # sim mirrors the evolving world (repaints remove obstacles for later agents)
    sim = [row[:] for row in grid]
    output = [row[:] for row in grid]

    # Left edge (agents move right)
    for r in range(height):
        val = sim[r][0]
        if 2 <= val <= 9:
            color = val
            for c in range(1, width):
                if sim[r][c] == 1:
                    sim[r][c] = color
                    output[r][c] = color
                    break
            output[r][0] = 0

    # Top edge (agents move down)
    for c in range(width):
        val = sim[0][c]
        if 2 <= val <= 9:
            color = val
            for r in range(1, height):
                if sim[r][c] == 1:
                    sim[r][c] = color
                    output[r][c] = color
                    break
            output[0][c] = 0

    # Right edge (agents move left)
    for r in range(height):
        val = sim[r][width - 1]
        if 2 <= val <= 9:
            color = val
            for c in range(width - 2, -1, -1):
                if sim[r][c] == 1:
                    sim[r][c] = color
                    output[r][c] = color
                    break
            output[r][width - 1] = 0

    # Bottom edge (agents move up)
    for c in range(width):
        val = sim[height - 1][c]
        if 2 <= val <= 9:
            color = val
            for r in range(height - 2, -1, -1):
                if sim[r][c] == 1:
                    sim[r][c] = color
                    output[r][c] = color
                    break
            output[height - 1][c] = 0

    # Return as immutable tuple of tuples (consistent with many ARC solvers)
    return tuple(tuple(row) for row in output)

