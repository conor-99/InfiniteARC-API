# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: ae69bdcc
Difficulty: easy

=== Tags ===
- Seal gaps inside shape
- Take half
- Remove singletons

=== Description ===
The task involves transforming a grid by first sealing any gaps within the main
shape (filling enclosed holes), then removing isolated single pixels
(singletons) not connected to the main shape, and finally taking the top half of
the resulting grid. The main shape is defined as the largest connected region of
non-zero pixels (using 4-directional connectivity). Gaps inside this shape are
filled by converting 0s enclosed by the shape's color into the shape's color.
Singletons are any non-zero pixels not part of the main shape; these are set to
0. The output grid consists of the top half of the processed grid (rows 0 to
floor(height/2) - 1), ensuring the transformation is visually intuitive and
requires only basic pattern recognition.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 15)
    height = random.randint(5, 15)
    main_color = random.randint(1, 9)
    grid = [[0]*width for _ in range(height)]
    
    for r in range(height):
        grid[r][0] = main_color
        grid[r][width-1] = main_color
    for c in range(width):
        grid[0][c] = main_color
        grid[height-1][c] = main_color
    
    inner_rows = range(1, height-1)
    inner_cols = range(1, width-1)
    inner_positions = [(r, c) for r in inner_rows for c in inner_cols]
    random.shuffle(inner_positions)
    
    num_holes = random.randint(1, len(inner_positions)//2)
    num_singletons = random.randint(1, len(inner_positions)//4)
    
    for i in range(num_holes):
        r, c = inner_positions[i]
        grid[r][c] = 0
    for i in range(num_holes, num_holes + num_singletons):
        r, c = inner_positions[i]
        singleton_color = random.randint(1, 9)
        while singleton_color == main_color:
            singleton_color = random.randint(1, 9)
        grid[r][c] = singleton_color
    
    output_grid = [row[:] for row in grid]
    
    for r in inner_rows:
        for c in inner_cols:
            if output_grid[r][c] == 0:
                output_grid[r][c] = main_color
    
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] != main_color and output_grid[r][c] != 0:
                output_grid[r][c] = 0
    
    top_rows = height // 2
    output_grid = output_grid[:top_rows]
    
    return {
        "input": grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    h = len(input_grid)
    w = len(input_grid[0])
    
    colors = set()
    for row in input_grid:
        for cell in row:
            if cell != 0:
                colors.add(cell)
    
    main_color = None
    max_size = 0
    for color in colors:
        visited = [[False]*w for _ in range(h)]
        for r in range(h):
            for c in range(w):
                if not visited[r][c] and input_grid[r][c] == color:
                    size = 0
                    queue = [(r, c)]
                    visited[r][c] = True
                    while queue:
                        cr, cc = queue.pop(0)
                        size += 1
                        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and input_grid[nr][nc] == color:
                                visited[nr][nc] = True
                                queue.append((nr, nc))
                    if size > max_size:
                        max_size = size
                        main_color = color
    
    visited_border = [[False]*w for _ in range(h)]
    queue = []
    for r in [0, h-1]:
        for c in range(w):
            if input_grid[r][c] == 0 and not visited_border[r][c]:
                visited_border[r][c] = True
                queue.append((r, c))
    for c in [0, w-1]:
        for r in range(1, h-1):
            if input_grid[r][c] == 0 and not visited_border[r][c]:
                visited_border[r][c] = True
                queue.append((r, c))
    
    while queue:
        r, c = queue.pop(0)
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < h and 0 <= nc < w and not visited_border[nr][nc] and input_grid[nr][nc] == 0:
                visited_border[nr][nc] = True
                queue.append((nr, nc))
    
    output_grid = [row[:] for row in input_grid]
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] == 0 and not visited_border[r][c]:
                output_grid[r][c] = main_color
    
    for r in range(h):
        for c in range(w):
            if output_grid[r][c] != main_color and output_grid[r][c] != 0:
                output_grid[r][c] = 0
    
    top_rows = h // 2
    return output_grid[:top_rows]
