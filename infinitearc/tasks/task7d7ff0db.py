# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 7d7ff0db
Difficulty: insane

=== Tags ===
- Cascade fountain

=== Description ===
Input grids feature a background color (0), a vertical column of source cells
(color 1) positioned at the top center, and a horizontal sequence of distinct
non-background colors (2-9) at the top-left corner forming a "color sequence
strip." Below the source column, the grid contains a complex arrangement of
obstacles (non-background colors) that form a navigable path without complete
blockage. Obstacles are positioned such that they intersect the vertical source
path at varying intervals, creating opportunities for cascade splitting.  The
output grid simulates a "cascade fountain" where the source color (1) flows
downward along the vertical column. Upon encountering an obstacle, the cascade
splits into two diagonal paths (upper-left and upper-right relative to the
obstacle's position), continuing until it exits the grid boundaries. The
cascade's color cycles sequentially through the color sequence strip from left
to right, repeating the sequence as needed (e.g., if the strip is [2, 4, 5], the
sequence becomes 2→4→5→2→4→5...). Only background cells are overwritten;
existing obstacles, the color sequence strip, and the original source column
remain visually unchanged. The cascade path alternates direction at each split
point based on the obstacle's position relative to the flow, creating a visually
complex, non-overlapping trajectory that terminates at grid edges. The
transformation requires simultaneous recognition of the color sequence,
obstacle-based splitting logic, and sequential color cycling to reconstruct the
output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque
from common import grid

def generate():
    # Choose grid size
    width = random.randint(10, 30)
    height = random.randint(10, 30)

    center_col = width // 2

    # Choose strip length so it sits in the top-left and does not overlap the source column
    strip_length_max = min(6, center_col)
    if strip_length_max < 2:
        strip_length_max = 2
    strip_length = random.randint(2, strip_length_max)

    # Create empty grid
    ingrid = grid(width, height, 0)

    # Create color strip at top-left (row 0, columns 0..strip_length-1)
    strip_colors = random.sample(list(range(2, 10)), strip_length)
    for c, color in enumerate(strip_colors):
        ingrid[0][c] = color

    # Place vertical source column (color 1) at the top center
    # Ensure there is space below the source for obstacles and cascade
    max_source_len = min(10, max(3, height - 4))
    source_length = random.randint(3, max_source_len)
    for r in range(source_length):
        ingrid[r][center_col] = 1

    # Place obstacles only on the center column at varying rows below the source
    possible_rows = list(range(source_length + 1, height - 1))
    if not possible_rows:
        # fallback: ensure at least one row for an obstacle
        possible_rows = [height - 2]
    num_blocks = random.randint(1, min(6, len(possible_rows)))
    block_rows = sorted(random.sample(possible_rows, num_blocks))
    for r in block_rows:
        # obstacles are non-background colors (2-9)
        ingrid[r][center_col] = random.choice(list(range(2, 10)))

    # Build the output by simulating the cascade fountain
    output = [row[:] for row in ingrid]

    # BFS queue entries: (r, c, dir, idx)
    # dir: 0 = straight down, -1 = down-left diagonal, 1 = down-right diagonal
    queue = deque()
    start_r = source_length
    start_c = center_col
    # Only start if the cell immediately below the source is background
    if start_r < height and ingrid[start_r][start_c] == 0:
        queue.append((start_r, start_c, 0, 0))

    while queue:
        r, c, dir, idx = queue.popleft()
        # Paint only background cells (do not overwrite source, strip, or obstacles)
        if output[r][c] == 0:
            output[r][c] = strip_colors[idx % len(strip_colors)]

        next_r = r + 1
        next_c = c + (dir if dir != 0 else 0)

        # If the next cell in the current direction is free, continue that direction
        if 0 <= next_r < height and 0 <= next_c < width and ingrid[next_r][next_c] == 0:
            if output[next_r][next_c] == 0:
                queue.append((next_r, next_c, dir, idx + 1))
        else:
            # Encountered an obstacle or edge. If we were going straight down, split into two diagonals.
            if dir == 0:
                for dc in (-1, 1):
                    nr = r + 1
                    nc = c + dc
                    if 0 <= nr < height and 0 <= nc < width and ingrid[nr][nc] == 0 and output[nr][nc] == 0:
                        queue.append((nr, nc, dc, idx + 1))
            # If we were already diagonal and are blocked or at edge, that branch terminates.

    return {"input": ingrid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    # Convert input to mutable list-of-lists
    ingrid = [list(row) for row in input_grid]
    height = len(ingrid)
    width = len(ingrid[0])

    # Find the source column: the vertical column of 1's that starts at the top
    center_col = None
    for c in range(width):
        if ingrid[0][c] == 1:
            center_col = c
            break
    if center_col is None:
        # No obvious top-center source, return the input unchanged
        return [list(row) for row in input_grid]

    # Compute source length (number of contiguous 1's starting from row 0)
    source_length = 0
    while source_length < height and ingrid[source_length][center_col] == 1:
        source_length += 1

    # Read the color strip from the top-left row
    strip_colors = []
    for c in range(width):
        v = ingrid[0][c]
        if v != 0:
            # Stop if we hit the source column (color 1) or any 0
            if v == 1:
                break
            strip_colors.append(v)
        else:
            break

    if not strip_colors:
        return [list(row) for row in input_grid]

    # Prepare output as a copy of the input
    output = [row[:] for row in ingrid]

    # Simulate the cascade with the same rules as the generator
    queue = deque()
    start_r = source_length
    start_c = center_col
    if start_r < height and ingrid[start_r][start_c] == 0:
        queue.append((start_r, start_c, 0, 0))

    while queue:
        r, c, dir, idx = queue.popleft()
        if output[r][c] == 0:
            output[r][c] = strip_colors[idx % len(strip_colors)]

        next_r = r + 1
        next_c = c + (dir if dir != 0 else 0)

        if 0 <= next_r < height and 0 <= next_c < width and ingrid[next_r][next_c] == 0:
            if output[next_r][next_c] == 0:
                queue.append((next_r, next_c, dir, idx + 1))
        else:
            if dir == 0:
                for dc in (-1, 1):
                    nr = r + 1
                    nc = c + dc
                    if 0 <= nr < height and 0 <= nc < width and ingrid[nr][nc] == 0 and output[nr][nc] == 0:
                        queue.append((nr, nc, dc, idx + 1))

    return output

