# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: ef24e610
Difficulty: very hard

=== Tags ===
- Pattern guided construction
- State transfer chain

=== Description ===
Input grids are 30×30 with background color 0. The grid contains a primary
structure composed of multiple disjoint, contiguous regions (each a single color
from 1–9, regions do not touch diagonally), and a secondary "state path" — a
sequence of adjacent cells (forming a continuous path from top to bottom edge)
where each cell has a color from 1–9 (path colors, distinct from region labels).
The state path forms a sequence that dictates a chain of transformations applied
to the primary structure in order.  The output grid is generated by sequentially
applying the following transformations based on the state path colors:  -
**Color 1 (Red):** Shift all non-background cells in the primary structure one
cell down (bottom row cells wrap to top row). - **Color 2 (Blue):** Shift all
non-background cells one cell left (leftmost column cells wrap to rightmost
column). - **Color 3 (Green):** Rotate the entire primary structure 180° (each
cell (r,c) moves to (height-1-r, width-1-c)). - **Color 4 (Yellow):** Apply a
horizontal flip (mirror left-right) to the primary structure. - **Color 5
(Gray):** Apply a vertical flip (mirror top-bottom) to the primary structure. -
**Color 6 (Pink):** Replace all cells of the primary structure with color 7,
preserving connectivity. - **Color 7 (Orange):** Replace all cells with color 8.
- **Color 8 (Cyan):** Replace all cells with color 9. - **Color 9 (Maroon):**
Replace all cells with color 1.  **State Tracking Rules:** - The primary
structure is the entire set of non-background cells initially. - Transformations
1–5 are applied to the entire current structure (not per region). - After any
transformation 1–5, the current structure remains the entire transformed
structure. - Transformations 6–9 replace the *color* of the entire current
structure (not the regions), changing all non-background cells to the new color.
- Transformations 6–9 do not alter the spatial arrangement of the structure,
only its color. - The structure remains contiguous after all transformations
(wrapping for shifts preserves connectivity).  **Key Complexity Factors:** 1.
Transformations 1–5 require spatial reasoning (shifts, rotations, flips) applied
to the evolving grid state. 2. Transformations 6–9 require color state tracking
across multiple steps (e.g., color 6 → 7, then color 7 → 8). 3. The path
sequence may contain repeated states (e.g., [3, 6, 6]), requiring sequential
application. 4. The output grid must maintain the same background and path
position (path is not visible in output).  This task demands precise sequential
reasoning about spatial transformations, color propagation, and state tracking
across multiple steps, with no visual cues for numerical values. The solution
requires recognizing the path, applying each transformation in order to the
current grid state, and understanding that color-based transformations (6–9)
only affect the color of the entire structure, not its spatial arrangement.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    """
    Generates a 30x30 input grid and corresponding output grid according to the task
    description. The input contains a monotonic top-to-bottom path (one cell per row)
    colored with instruction colors (a subset of 1..9) and several disjoint contiguous
    regions (each a single color chosen from the remaining colors). The output is the
    result of applying the instruction sequence (top-to-bottom along the path) to the
    primary structure (all non-background cells excluding the path), following the
    specified spatial and color-transform rules.
    """
    width = height = 30

    # Keep a simple persistent counter to increase variation between successive calls
    if not hasattr(generate, "_counter"):
        generate._counter = 0
    generate._counter += 1

    # A bounded number of overall attempts to produce a non-trivial pair
    for overall_attempt in range(60):
        # Start with empty grid
        grid = [[0 for _ in range(width)] for _ in range(height)]

        # Decide how many disjoint regions we'll create
        num_regions = random.randint(2, 4)

        # Choose path colors such that there remain enough colors for regions and
        # include at least one spatial instruction (1-5) to reduce chance of identity
        max_path_colors = 9 - num_regions
        max_path_colors = max(1, min(5, max_path_colors))
        path_color_count = random.randint(1, max_path_colors)

        # Ensure at least one color in 1..5 is present in the path palette
        all_colors = list(range(1, 10))
        for _ in range(100):
            path_colors = random.sample(all_colors, path_color_count)
            if any(c <= 5 for c in path_colors):
                break
        else:
            # fallback: ensure at least one spatial instruction exists
            path_colors = random.sample(all_colors, path_color_count - 1) + [random.randint(1, 5)]
            path_colors = list(dict.fromkeys(path_colors))

        # Region colors must be disjoint from path colors
        remaining_colors = [c for c in all_colors if c not in path_colors]
        if len(remaining_colors) < num_regions:
            # improbable, try again
            continue
        region_colors = random.sample(remaining_colors, num_regions)

        # Build a monotonic top->bottom path: exactly one cell in each row.
        # Start column influenced by counter to improve uniqueness across calls.
        start_col = (random.randint(0, width - 1) + generate._counter) % width
        cols = [start_col]
        for r in range(1, height):
            step = random.choice((-1, 0, 1))
            nc = cols[-1] + step
            nc = max(0, min(width - 1, nc))
            cols.append(nc)
        path_positions = [(r, cols[r]) for r in range(height)]

        # Paint the path into the grid using the path palette (path is visible in input)
        for (r, c) in path_positions:
            grid[r][c] = random.choice(path_colors)

        # Reserve occupied set to avoid putting regions on the path
        occupied = set(path_positions)

        # Generate regions: contiguous 4-connected blobs that do not touch other regions
        # even diagonally and do not reach the top or bottom rows (so the path is the only
        # top-to-bottom chain of non-background cells).
        regions = []
        success = True
        for color in region_colors:
            placed = False
            for attempt in range(300):
                # pick a seed not on top/bottom and not on the path and not adjacent to occupied
                sr = random.randint(2, height - 3)
                sc = random.randint(0, width - 1)
                if (sr, sc) in occupied:
                    continue
                # ensure 8-neighborhood has no occupied cell (this enforces separation)
                conflict = False
                for dr in (-1, 0, 1):
                    for dc in (-1, 0, 1):
                        nr, nc = sr + dr, sc + dc
                        if 0 <= nr < height and 0 <= nc < width and (nr, nc) in occupied:
                            conflict = True
                            break
                    if conflict:
                        break
                if conflict:
                    continue

                # Grow a region using random frontier expansion (keeps 4-connectivity)
                target = random.randint(18, 80)
                region_pixels = set()
                region_pixels.add((sr, sc))
                frontier = [(sr, sc)]
                grow_tries = 0
                while len(region_pixels) < target and frontier and grow_tries < 2000:
                    grow_tries += 1
                    base = random.choice(frontier)
                    br, bc = base
                    candidates = []
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = br + dr, bc + dc
                        # avoid path, avoid top/bottom rows, avoid already occupied
                        if not (0 <= nr < height and 0 <= nc < width):
                            continue
                        if nr in (0, height - 1):
                            continue
                        if (nr, nc) in occupied or (nr, nc) in region_pixels:
                            continue
                        # ensure adding this cell won't touch other regions diagonally
                        conflict2 = False
                        for dr2 in (-1, 0, 1):
                            for dc2 in (-1, 0, 1):
                                ar, ac = nr + dr2, nc + dc2
                                if 0 <= ar < height and 0 <= ac < width and (ar, ac) in occupied and (ar, ac) not in region_pixels:
                                    conflict2 = True
                                    break
                            if conflict2:
                                break
                        if not conflict2:
                            candidates.append((nr, nc))
                    if not candidates:
                        # couldn't grow from this base for now
                        try:
                            frontier.remove(base)
                        except ValueError:
                            pass
                        continue
                    newcell = random.choice(candidates)
                    region_pixels.add(newcell)
                    frontier.append(newcell)
                # Accept the region only if it has a reasonable size
                if len(region_pixels) >= 6:
                    for (rr, cc) in region_pixels:
                        grid[rr][cc] = color
                        occupied.add((rr, cc))
                    regions.append(region_pixels)
                    placed = True
                    break
                else:
                    # try a new seed
                    continue
            if not placed:
                success = False
                break

        if not success:
            # try generating all over again
            continue

        # Primary structure: all non-background cells excluding the path
        primary = {}
        path_set = set(path_positions)
        for r in range(height):
            for c in range(width):
                if grid[r][c] != 0 and (r, c) not in path_set:
                    primary[(r, c)] = grid[r][c]

        # Instruction sequence is the colors along the path (top-to-bottom)
        instructions = [grid[r][c] for (r, c) in path_positions]

        # Transformation helpers
        def spatial_transform(pos, instr):
            r, c = pos
            if instr == 1:
                return ((r + 1) % height, c)
            if instr == 2:
                return (r, (c - 1) % width)
            if instr == 3:
                return (height - 1 - r, width - 1 - c)
            if instr == 4:
                return (r, width - 1 - c)
            if instr == 5:
                return (height - 1 - r, c)
            return (r, c)

        def color_map(instr):
            if instr == 6:
                return 7
            if instr == 7:
                return 8
            if instr == 8:
                return 9
            if instr == 9:
                return 1
            return None

        # Apply instructions sequentially
        current = dict(primary)
        for instr in instructions:
            if instr in (1, 2, 3, 4, 5):
                newmap = {}
                for pos, col in current.items():
                    newpos = spatial_transform(pos, instr)
                    newmap[newpos] = col
                current = newmap
            else:
                # color replacement for entire structure
                newcol = color_map(instr)
                current = {pos: newcol for pos in current}

        # Build the output grid (path is not visible in output)
        output = [[0 for _ in range(width)] for _ in range(height)]
        for (r, c), col in current.items():
            output[r][c] = col

        # Ensure input and output are not identical (very unlikely but check to be safe)
        identical = True
        for r in range(height):
            for c in range(width):
                if grid[r][c] != output[r][c]:
                    identical = False
                    break
            if not identical:
                break
        if identical:
            # try again to avoid trivial identical cases
            continue

        return {"input": grid, "output": output}

    # If we failed to produce a pair after many tries, fall back to a simple deterministic case
    # (still respects the rules but is unlikely to be used in validation)
    grid = [[0 for _ in range(width)] for _ in range(height)]
    path_cols = [width // 2] * height
    path_positions = [(r, path_cols[r]) for r in range(height)]
    for (r, c) in path_positions:
        grid[r][c] = 1
    # Put two small regions
    grid[10][5] = 2
    grid[10][6] = 2
    grid[11][5] = 2
    primary = {(10, 5): 2, (10, 6): 2, (11, 5): 2}
    # Apply one down-shift instruction
    current = {((r + 1) % height, c): col for (r, c), col in primary.items()}
    output = [[0 for _ in range(width)] for _ in range(height)]
    for (r, c), col in current.items():
        output[r][c] = col
    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Build a boolean map of non-background cells
    nonzero = [[grid[r][c] != 0 for c in range(width)] for r in range(height)]

    # Dynamic programming to find a monotonic top-to-bottom path that uses one cell per row.
    # dp[r][c] == True means there exists a path from row 0 to (r,c) following the rule that
    # each step goes to the next row and column may change by at most 1.
    dp = [[False] * width for _ in range(height)]
    parent = {}

    # Initialize top row
    for c in range(width):
        if nonzero[0][c]:
            dp[0][c] = True
            parent[(0, c)] = None

    # Fill DP table
    for r in range(1, height):
        for c in range(width):
            if not nonzero[r][c]:
                continue
            found = False
            for pc in (c - 1, c, c + 1):
                if 0 <= pc < width and dp[r - 1][pc]:
                    dp[r][c] = True
                    parent[(r, c)] = (r - 1, pc)
                    found = True
                    break
            if found:
                continue

    # Find endpoint in bottom row
    end_col = None
    for c in range(width):
        if dp[height - 1][c]:
            end_col = c
            break

    if end_col is None:
        # Fallback: try to find any connected nonzero component that touches top and bottom
        # (should not be necessary for the generator used here but keeps solver robust).
        from collections import deque
        visited = [[False] * width for _ in range(height)]
        dirs = [(1,0),(-1,0),(0,1),(0,-1)]
        endpoint = None
        for c in range(width):
            if not nonzero[0][c]:
                continue
            q = deque()
            q.append((0,c))
            visited[0][c] = True
            parent = {(0,c): None}
            reached_bottom = None
            while q:
                r,c0 = q.popleft()
                if r == height - 1:
                    reached_bottom = (r, c0)
                    break
                for dr, dc in dirs:
                    nr, nc = r + dr, c0 + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and nonzero[nr][nc]:
                        visited[nr][nc] = True
                        parent[(nr,nc)] = (r,c0)
                        q.append((nr,nc))
            if reached_bottom:
                endpoint = reached_bottom
                break
        if endpoint is None:
            # No path found; return the input unchanged (defensive)
            return grid
        # Reconstruct path from endpoint to top
        path = []
        cur = endpoint
        while cur is not None:
            path.append(cur)
            cur = parent[cur]
        path.reverse()
        # If this path includes multiple cells in same row, compress to one per row by choosing
        # the first occurrence per row (this keeps solver consistent with generator's monotonic path)
        final_path = []
        seen_rows = set()
        for (r,c) in path:
            if r in seen_rows:
                continue
            final_path.append((r,c))
            seen_rows.add(r)
        path_positions = final_path
    else:
        # Reconstruct monotonic path from DP parent pointers
        path_positions = [None] * height
        cur = (height - 1, end_col)
        for r in range(height - 1, -1, -1):
            path_positions[r] = cur
            cur = parent[cur]

    # Extract instruction colors along the path (top-to-bottom)
    instructions = [grid[r][c] for (r, c) in path_positions]

    # Build the primary structure (non-background cells excluding the path)
    path_set = set(path_positions)
    structure = {(r, c): grid[r][c] for r in range(height) for c in range(width) if grid[r][c] != 0 and (r, c) not in path_set}

    # Transformation helpers
    def spatial_transform(pos, instr):
        r, c = pos
        if instr == 1:
            return ((r + 1) % height, c)
        if instr == 2:
            return (r, (c - 1) % width)
        if instr == 3:
            return (height - 1 - r, width - 1 - c)
        if instr == 4:
            return (r, width - 1 - c)
        if instr == 5:
            return (height - 1 - r, c)
        return (r, c)

    def color_map(instr):
        if instr == 6:
            return 7
        if instr == 7:
            return 8
        if instr == 8:
            return 9
        if instr == 9:
            return 1
        return None

    # Apply instructions sequentially
    current = dict(structure)
    for instr in instructions:
        if instr in (1, 2, 3, 4, 5):
            newmap = {}
            for pos, col in current.items():
                newpos = spatial_transform(pos, instr)
                newmap[newpos] = col
            current = newmap
        else:
            newcol = color_map(instr)
            current = {pos: newcol for pos in current}

    # Build output grid; path is not drawn in the output
    output = [[0 for _ in range(width)] for _ in range(height)]
    for (r, c), col in current.items():
        output[r][c] = col

    return output

