# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 260f51b8
Difficulty: hard

=== Tags ===
- Palette compression
- Multi object alignment

=== Description ===
The task involves transforming input grids containing multiple distinct colored
objects (connected regions of non-zero values) into output grids through two
sequential steps. First, palette compression reduces the number of colors by
retaining only the three largest connected components (by area) from the input,
mapping all other non-background colors to the color of the largest component.
Second, multi-object alignment positions each retained object such that their
top-left corners are aligned along the top row of the grid, arranged
sequentially from left to right without vertical overlap. The background (0)
remains unchanged, and objects are shifted within the grid's fixed dimensions to
maintain their structural integrity while adhering to the alignment rule. This
requires identifying connected components, determining size-based color
retention, and resolving positional constraints for multiple objects in a
visually consistent manner.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def get_components(grid):
    # 4-connectivity
    components = []
    visited = set()
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and (r, c) not in visited:
                stack = [(r, c)]
                visited.add((r, c))
                component = []
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == grid[r][c] and (nr, nc) not in visited:
                            visited.add((nr, nc))
                            stack.append((nr, nc))
                components.append(component)
    return components

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    grid = [[0] * width for _ in range(height)]
    
    # Create top three components with random placement
    colors = [1, 2, 3]
    for i, color in enumerate(colors):
        shape = random.choice(['el', 'you', 'aitch'])
        pixels = common.rand_sprite(shape, width, height)
        dx = random.randint(0, width - 5)
        dy = random.randint(0, height - 5)
        shifted_pixels = [(r + dy, c + dx) for (r, c) in pixels]
        for (r, c) in shifted_pixels:
            if 0 <= r < height and 0 <= c < width:
                grid[r][c] = color
    
    # Add small components with random placement
    for _ in range(random.randint(1, 5)):
        color = random.randint(4, 9)
        size = random.randint(1, 5)
        pixels = common.random_pixels(width, height, prob=0.2)
        dx = random.randint(0, width - 1)
        dy = random.randint(0, height - 1)
        shifted_pixels = [(r + dy, c + dx) for (r, c) in pixels]
        for (r, c) in shifted_pixels[:size]:
            if 0 <= r < height and 0 <= c < width and grid[r][c] == 0:
                grid[r][c] = color
    
    # Compute components
    components = get_components(grid)
    comp_sizes = [(len(comp), comp, grid[comp[0][0]][comp[0][1]]) for comp in components]
    comp_sizes.sort(key=lambda x: x[0], reverse=True)
    top_three = comp_sizes[:3]
    
    # Create output grid initialized to largest_color
    largest_color = top_three[0][2] if top_three else 0
    output = [[largest_color] * width for _ in range(height)]
    
    # Align top three components
    cumulative_width = 0
    for i in range(len(top_three)):
        size, comp, color = top_three[i]
        rows = [p[0] for p in comp]
        cols = [p[1] for p in comp]
        min_r, max_r = min(rows), max(rows)
        min_c, max_c = min(cols), max(cols)
        width_comp = max_c - min_c + 1
        for (r, c) in comp:
            new_r = r - min_r
            new_c = c - min_c + cumulative_width
            if 0 <= new_r < height and 0 <= new_c < width:
                output[new_r][new_c] = color
        cumulative_width += width_comp
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def get_components(grid):
    # 4-connectivity
    components = []
    visited = set()
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and (r, c) not in visited:
                stack = [(r, c)]
                visited.add((r, c))
                component = []
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == grid[r][c] and (nr, nc) not in visited:
                            visited.add((nr, nc))
                            stack.append((nr, nc))
                components.append(component)
    return components

def p(input_grid):
    components = get_components(input_grid)
    comp_sizes = [(len(comp), comp, input_grid[comp[0][0]][comp[0][1]]) for comp in components]
    comp_sizes.sort(key=lambda x: x[0], reverse=True)
    top_three = comp_sizes[:3]
    
    largest_color = top_three[0][2] if top_three else 0
    height = len(input_grid)
    width = len(input_grid[0])
    output = [[largest_color] * width for _ in range(height)]
    
    # Align top three components
    cumulative_width = 0
    for i in range(len(top_three)):
        size, comp, color = top_three[i]
        rows = [p[0] for p in comp]
        cols = [p[1] for p in comp]
        min_r, max_r = min(rows), max(rows)
        min_c, max_c = min(cols), max(cols)
        width_comp = max_c - min_c + 1
        for (r, c) in comp:
            new_r = r - min_r
            new_c = c - min_c + cumulative_width
            if 0 <= new_r < height and 0 <= new_c < width:
                output[new_r][new_c] = color
        cumulative_width += width_comp
    
    return output
