# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: d28eb4e7
Difficulty: insane

=== Tags ===
- Contextual image parsing
- Find analogous pattern property
- Even or odd
- Program synthesis from examples

=== Description ===
The task requires analyzing the input grid to identify the number of distinct
non-background shapes (connected components of the same color, excluding
background 0). The parity (even or odd) of this count determines a color
replacement rule applied to all shapes: if the count is even, all shapes become
blue (color 1); if odd, all shapes become red (color 2). Subsequently, the grid
undergoes a mirroring transformation based on the grid's width parity: if the
width is even, the grid is mirrored horizontally; if odd, it is mirrored
vertically. The output grid integrates both the color replacement and mirroring
transformations, requiring the solver to deduce the dual-step rule from visual
patterns in the examples. The complexity arises from the need to simultaneously
track shape count parity, color substitution, and grid dimension-based
mirroring, all derived purely from visual structure without numerical
computation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_color
def generate():
    width = random.randint(5, 20)
    height = random.randint(5, 20)
    input_grid = grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            if random.random() < 0.4:
                input_grid[r][c] = random_color(exclude=[0])
    visited = [[False] * width for _ in range(height)]
    count = 0
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                count += 1
                queue = [(r, c)]
                visited[r][c] = True
                color = input_grid[r][c]
                while queue:
                    cr, cc = queue.pop(0)
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
    parity = count % 2
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                output_grid[r][c] = 1 if parity == 0 else 2
    if width % 2 == 0:
        output_grid = [row[::-1] for row in output_grid]
    else:
        output_grid = output_grid[::-1]
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random
from common import grid, random_color
def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    visited = [[False] * width for _ in range(height)]
    count = 0
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                count += 1
                queue = [(r, c)]
                visited[r][c] = True
                color = input_grid[r][c]
                while queue:
                    cr, cc = queue.pop(0)
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
    parity = count % 2
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                output_grid[r][c] = 1 if parity == 0 else 2
    if width % 2 == 0:
        output_grid = [row[::-1] for row in output_grid]
    else:
        output_grid = output_grid[::-1]
    return output_grid
