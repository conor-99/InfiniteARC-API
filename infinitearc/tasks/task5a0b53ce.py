# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 5a0b53ce
Difficulty: insane

=== Tags ===
- Out of boundary
- Attention switching
- Separate image
- Maze

=== Description ===
The task involves a maze-like input grid where a continuous path of non-zero
values forms a single connected structure (e.g., a loop or open path). The
transformation requires moving each cell along the path one step in a direction
that alternates cyclically (right → down → left → up → right → ...), wrapping
around grid boundaries when movement would exit the grid. For example, moving
right from the rightmost column wraps to the leftmost column. The output grid is
a new configuration of the path after applying this alternating directional
shift to every cell in the original path. "Attention switching" refers to the
cyclic alternation of movement directions, "out of boundary" describes the wrap-
around behavior at grid edges, "separate image" indicates the output path is
structurally distinct from the input, and "maze" defines the input structure as
a connected path. The difficulty arises from needing to identify the path's
traversal order, apply the cyclic direction shift, and handle boundary
wrapping—all while ensuring no overlaps or conflicts in the transformed grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(5, 15)
    height = random.randint(5, 15)
    path_size = random.randint(5, 20)
    # Create deterministic horizontal path in row 0
    path = [(0, c) for c in range(min(path_size, width))]
    input_grid = grid(width, height, 0)
    for r, c in path:
        input_grid[r][c] = 1
    output_grid = grid(width, height, 0)
    for idx, (r, c) in enumerate(path):
        dr, dc = [0, 1, 0, -1][idx % 4], [1, 0, -1, 0][idx % 4]
        new_r = (r + dr) % height
        new_c = (c + dc) % width
        output_grid[new_r][new_c] = 1
    if input_grid == output_grid:
        return generate()
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random
from common import grid

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    path = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                path.append((r, c))
    # Sort path by row then column for deterministic order
    path.sort(key=lambda x: (x[0], x[1]))
    output_grid = grid(width, height, 0)
    for idx, (r, c) in enumerate(path):
        dr, dc = [0, 1, 0, -1][idx % 4], [1, 0, -1, 0][idx % 4]
        new_r = (r + dr) % height
        new_c = (c + dc) % width
        output_grid[new_r][new_c] = 1
    return output_grid
