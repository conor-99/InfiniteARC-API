# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 3c9097d4
Difficulty: insane

=== Tags ===
- Progressive rule shift
- Color space mapping
- Path following

=== Description ===
Input grids feature a single, non-intersecting path of colored cells (1-9)
beginning at the left edge and traversing the grid in a continuous, winding
sequence. Background cells are uniformly colored (0). The path's direction
changes through orthogonal turns but never crosses itself, forming a complex,
visually distinct route through the grid.  The output grid transforms the path
by applying a progressive cyclic color shift: each cell's color advances through
a cycle of all 10 colors (0-9) by a number of positions equal to its distance
from the start of the path. The first cell (immediately after the starting edge)
shifts forward once (0→1, 1→2, ..., 9→0), the second cell shifts forward twice
(0→2, 1→3, ..., 9→1), the third cell shifts forward three times, and so on. This
creates a visible progression where colors move sequentially through the cycle
as the path extends deeper into the grid. Background cells and all non-path
elements remain unchanged. The transformation requires recognizing both the
path's sequence and the cumulative shift pattern applied to each cell's color.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(2, 30)
    height = random.randint(2, 30)
    start_row = random.randint(0, height - 2)
    
    path = []
    for r in range(start_row, height):
        path.append((r, 0))
    for c in range(1, width):
        path.append((height - 1, c))
    
    input_grid = grid(width, height, 0)
    for idx, (r, c) in enumerate(path):
        input_grid[r][c] = random.randint(1, 9)
    
    output_grid = grid(width, height, 0)
    for idx, (r, c) in enumerate(path):
        old_color = input_grid[r][c]
        new_color = (old_color + idx + 1) % 10
        output_grid[r][c] = new_color
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    path_cells = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] > 0:
                path_cells.append((r, c))
    path_cells.sort(key=lambda x: (x[0], x[1]))
    
    output_grid = grid(width, height, 0)
    for idx, (r, c) in enumerate(path_cells):
        old_color = input_grid[r][c]
        new_color = (old_color + idx + 1) % 10
        output_grid[r][c] = new_color
    
    return output_grid
