# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: a156657e
Difficulty: medium

=== Tags ===
- Recoloring

=== Description ===
The task involves identifying boundary cells within connected regions of the
input grid and recoloring them to a fixed color (8), while preserving all inner
cells. A boundary cell is defined as any cell that either lies on the grid's
edge or is adjacent (horizontally or vertically) to a cell with a different
color. In the output grid, all such boundary cells are replaced with color 8,
while all non-boundary cells retain their original color. This transformation
requires understanding of connected regions and edge detection, which can be
discovered through examination of input-output pairs showing how regions'
perimeters are highlighted. The rule is purely visual and does not rely on
numerical properties of the colors.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    color_A = random.randint(1, 9)
    color_B = random.randint(1, 9)
    while color_B == color_A:
        color_B = random.randint(1, 9)
    input_grid = common.grid(width, height, color_B)
    x = random.randint(1, width - 4)
    y = random.randint(1, height - 4)
    for r in range(y, y + 3):
        for c in range(x, x + 3):
            input_grid[r][c] = color_A
    output_grid = [[input_grid[r][c] for c in range(width)] for r in range(height)]
    for r in range(height):
        for c in range(width):
            if r == 0 or r == height - 1 or c == 0 or c == width - 1:
                output_grid[r][c] = 8
            else:
                for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        if input_grid[nr][nc] != input_grid[r][c]:
                            output_grid[r][c] = 8
                            break
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = [[input_grid[r][c] for c in range(width)] for r in range(height)]
    for r in range(height):
        for c in range(width):
            if r == 0 or r == height - 1 or c == 0 or c == width - 1:
                output_grid[r][c] = 8
            else:
                for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        if input_grid[nr][nc] != input_grid[r][c]:
                            output_grid[r][c] = 8
                            break
    return output_grid
