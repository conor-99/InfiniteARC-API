# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 8110c935
Difficulty: hard

=== Tags ===
- Periodic reflection
- Take intersection

=== Description ===
# Task: Periodic Reflection Intersection  Input grids feature a background color
(0) and a foreground pattern composed of one or more disconnected shapes filled
with distinct non-background colors (1-9). The foreground pattern is
intentionally asymmetric to ensure the transformation produces a meaningful
output. Grid dimensions range from 5×5 to 30×30.  The transformation process
consists of two distinct reflection operations applied to the input grid: 1.
Generate a horizontally reflected grid (left-right flip) where each cell (i,j)
in the output corresponds to the input's cell (i, width-1-j). 2. Generate a
vertically reflected grid (top-bottom flip) where each cell (i,j) in the output
corresponds to the input's cell (height-1-i, j).  The output grid is formed by
taking the intersection of these two reflected grids. A cell in the output is
non-background (color > 0) if and only if the same cell is non-background in
both the horizontally reflected grid and the vertically reflected grid. The
color of the cell in the output is preserved from the horizontally reflected
grid (not the original input).  This transformation creates a new pattern that
exists only in the overlapping region of the two reflections. For asymmetric
input patterns, this results in a smaller, centrally located pattern that
maintains symmetry with respect to both horizontal and vertical axes. The output
grid will always differ from the input due to the intersection operation
reducing the pattern size.  The challenge lies in recognizing the need to
perform two independent reflection operations before applying the intersection,
and understanding that the output's pattern is derived from the positional
overlap of the reflections rather than the input's original configuration. The
task requires multi-step reasoning about spatial transformations and their
compositional effects.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import random_pixels, random_color

def is_symmetric_horizontal(grid):
    width = len(grid[0])
    for r in range(len(grid)):
        for c in range(width // 2):
            if grid[r][c] != grid[r][width - 1 - c]:
                return False
    return True

def is_symmetric_vertical(grid):
    height = len(grid)
    for r in range(height // 2):
        for c in range(len(grid[0])):
            if grid[r][c] != grid[height - 1 - r][c]:
                return False
    return True

def generate():
    while True:
        width = random.randint(5, 30)
        height = random.randint(5, 30)
        grid_input = [[0] * width for _ in range(height)]
        
        pixels = random_pixels(width, height, 0.3)
        for r, c in pixels:
            grid_input[r][c] = random_color(exclude=[0])
        
        if not is_symmetric_horizontal(grid_input) and not is_symmetric_vertical(grid_input):
            h_reflected = [row[::-1] for row in grid_input]
            v_reflected = grid_input[::-1]
            
            output = [[0] * width for _ in range(height)]
            for r in range(height):
                for c in range(width):
                    if h_reflected[r][c] > 0 and v_reflected[r][c] > 0:
                        output[r][c] = h_reflected[r][c]
            
            if grid_input != output:
                return {
                    "input": grid_input,
                    "output": output
                }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    width = len(input_list[0])
    height = len(input_list)
    
    h_reflected = [row[::-1] for row in input_list]
    v_reflected = input_list[::-1]
    
    output = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if h_reflected[r][c] > 0 and v_reflected[r][c] > 0:
                output[r][c] = h_reflected[r][c]
    
    return tuple(tuple(row) for row in output)
