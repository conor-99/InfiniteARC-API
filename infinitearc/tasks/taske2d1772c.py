# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: e2d1772c
Difficulty: insane

=== Tags ===
- Detect symmetry

=== Description ===
Input grids are large (up to 30×30) 2D arrangements of colored cells (values
1–9) on a background (value 0), designed to exhibit near-perfect 180-degree
rotational symmetry around the grid's central point. However, the input grids
contain deliberate asymmetries: certain colored cells are missing from their
symmetric counterparts, or background cells (0) occupy positions where colored
cells should exist. The output grid must correct all such asymmetries to achieve
full rotational symmetry. For every cell (r, c), the cell at (height-1-r,
width-1-c) must match its color. If one cell is colored (1–9) and the other is
background (0), the background cell is replaced with the colored cell's value.
If both cells are background, they remain background. The correction process
must be applied uniformly across all cell pairs, with no exceptions or conflicts
(the input is constructed to avoid cases where both cells are colored but
differ). This task demands precise identification of asymmetric pairs across the
entire grid, requiring the model to navigate complex spatial relationships in
large grids while applying a single, consistent symmetry rule. The "insane"
difficulty arises from the combinatorial complexity of verifying and correcting
all 450+ cell pairs in a 30×30 grid, where even minor errors in symmetry
detection propagate across the entire output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_color

def generate():
    h = random.randint(1, 30)
    w = random.randint(1, 30)
    while h == 1 and w == 1:
        h = random.randint(1, 30)
        w = random.randint(1, 30)
    base = grid(w, h, 0)
    for r in range(h):
        for c in range(w):
            mirror_r = h - 1 - r
            mirror_c = w - 1 - c
            if (r, c) < (mirror_r, mirror_c):
                color = random_color()
                base[r][c] = color
                base[mirror_r][mirror_c] = color
            elif (r, c) == (mirror_r, mirror_c):
                color = random_color()
                base[r][c] = color
    input_grid = [row[:] for row in base]
    pairs = []
    for r in range(h):
        for c in range(w):
            mirror_r = h - 1 - r
            mirror_c = w - 1 - c
            if (r, c) < (mirror_r, mirror_c):
                pairs.append((r, c, mirror_r, mirror_c))
    if not pairs:
        input_grid[0][0] = 0
    else:
        num_to_flip = max(1, int(len(pairs) * 0.25))
        flipped_pairs = random.sample(pairs, num_to_flip)
        for (r, c, mr, mc) in flipped_pairs:
            if random.choice([True, False]):
                input_grid[r][c] = 0
            else:
                input_grid[mr][mc] = 0
    return {"input": input_grid, "output": base}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    h = len(input_grid)
    w = len(input_grid[0])
    output = [list(row) for row in input_grid]
    for r in range(h):
        for c in range(w):
            mirror_r = h - 1 - r
            mirror_c = w - 1 - c
            if output[r][c] != 0 and output[mirror_r][mirror_c] == 0:
                output[mirror_r][mirror_c] = output[r][c]
            elif output[r][c] == 0 and output[mirror_r][mirror_c] != 0:
                output[r][c] = output[mirror_r][mirror_c]
    return output
