# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: c1254812
Difficulty: very hard

=== Tags ===
- Goal conditioned path
- Rotational pattern mapping
- Pattern analogy
- Local physics rule

=== Description ===
Input grids feature a start cell (marked with a distinct color), a goal cell
(marked with another distinct color), and scattered rotational markers
distributed across the grid. Each marker cell contains a unique color that
encodes a specific rotational direction change: for example, red markers rotate
the path 90° clockwise, blue markers rotate 90° counterclockwise, green markers
rotate 180°, and yellow markers preserve direction. The path begins moving in a
fixed initial direction (e.g., right) from the start cell. As the path traverses
each cell, it follows the direction encoded by the cell's color if it contains a
marker. Obstacle cells (non-marker, non-path colors) block movement, forcing the
path to stop at the obstacle. The path must navigate through the grid, applying
rotational changes at each marker cell, until it reaches the goal cell. The
output grid must depict the complete path as a continuous line (using a
designated color) from start to goal, with all traversed cells highlighted,
while preserving all input elements (start, goal, markers, obstacles) unchanged.
The challenge lies in recognizing the rotational pattern mapping across multiple
markers, correctly applying sequential direction changes, and ensuring the path
avoids obstacles while adhering to the local physics rule of direction
modification at marker cells. The grid dimensions are large enough (≥20×20) to
require careful path tracing through complex marker arrangements, with the path
length and rotation sequence determined by the input's marker configuration.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    """
    Generates a 20x20 grid with:
    - start cell color 1 at the left edge (col 0)
    - goal cell color 2 at the right edge (col width-1)
    - a long serpentine path connecting them (no obstacles on the path)
    - markers placed at turning points encoding rotations:
        color 3 -> +90° (clockwise)
        color 4 -> -90° (counterclockwise)
        color 5 -> 180°
        color 6 -> preserve (0°)  (rarely used)
    - obstacles (colors 7 or 9) placed off the path
    The output grid is the same as the input but with the traversed path cells
    (those that were background 0 in the input) painted with color 8.
    """
    width = height = 20
    inp = grid(width, height, 0)

    # Colors
    START = 1
    GOAL = 2
    ROT_TO_COLOR = {0: 6, 1: 3, 2: 5, 3: 4}  # rotation -> color
    PATH_COLOR = 8

    # Choose an odd number of rows K to produce a serpentine path that ends on the right side
    min_rows = 5
    K = random.randint(min_rows, height)
    # make K odd so final column is the rightmost (since first row goes left->right)
    if K % 2 == 0:
        if K - 1 >= min_rows:
            K -= 1
        else:
            K += 1
            if K > height:
                K = height if height % 2 == 1 else height - 1

    # Choose a contiguous block of K rows and a random vertical direction
    top = random.randint(0, height - K)
    block = list(range(top, top + K))
    if random.choice([True, False]):
        row_order = block
    else:
        row_order = block[::-1]

    # Build a continuous serpentine path starting at (row_order[0], 0) moving to the right first
    path = []
    for i, r in enumerate(row_order):
        if i == 0:
            for c in range(0, width):
                path.append((r, c))
        else:
            prev_c = path[-1][1]
            # step vertically into the same column on the new row
            path.append((r, prev_c))
            if prev_c == width - 1:
                for c in range(width - 2, -1, -1):
                    path.append((r, c))
            else:
                for c in range(1, width):
                    path.append((r, c))

    # Ensure final cell is on the rightmost column (should be true when K is odd)
    start = (row_order[0], 0)
    goal = path[-1]

    # Place start and goal
    inp[start[0]][start[1]] = START
    inp[goal[0]][goal[1]] = GOAL

    # Helper to compute direction index from a->b: 0:right,1:down,2:left,3:up
    def dir_index(a, b):
        dr = b[0] - a[0]
        dc = b[1] - a[1]
        if (dr, dc) == (0, 1):
            return 0
        if (dr, dc) == (1, 0):
            return 1
        if (dr, dc) == (0, -1):
            return 2
        if (dr, dc) == (-1, 0):
            return 3
        raise ValueError("Non-adjacent cells in path")

    # Place markers at turning points so that when the solver follows the rotation
    # rules it will reproduce the exact serpentine path.
    for i in range(1, len(path) - 1):
        a = path[i - 1]
        b = path[i]
        c = path[i + 1]
        # skip start/goal (they're already placed explicitly)
        if b == start or b == goal:
            continue
        d_prev = dir_index(a, b)
        d_next = dir_index(b, c)
        rot = (d_next - d_prev) % 4
        if rot != 0:
            inp[b[0]][b[1]] = ROT_TO_COLOR[rot]
        # if rot == 0, leave as background 0 so there's no marker here

    # Scatter a few decoy markers off the path (do not overwrite start/goal)
    num_decoys = random.randint(0, 12)
    offpath = [(r, c) for r in range(height) for c in range(width) if (r, c) not in path and (r, c) != start and (r, c) != goal]
    random.shuffle(offpath)
    for (r, c) in offpath[:num_decoys]:
        inp[r][c] = random.choice([3, 4, 5, 6])

    # Add obstacles (colors 7 or 9) off the path (do not overwrite start/goal or decoy markers)
    for r in range(height):
        for c in range(width):
            if (r, c) in path or (r, c) == start or (r, c) == goal:
                continue
            if inp[r][c] in (3, 4, 5, 6):
                # keep decoy markers
                continue
            if random.random() < 0.28:
                inp[r][c] = random.choice([7, 9])

    # Build output by painting traversed path cells that were background 0 with PATH_COLOR
    out = [row[:] for row in inp]
    for (r, c) in path:
        # preserve start, goal, markers and obstacles; only paint background path cells
        if inp[r][c] == 0:
            out[r][c] = PATH_COLOR

    return {"input": inp, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0]) if h > 0 else 0

    # Colors & mapping must match generator
    START = 1
    GOAL = 2
    ROT_COLOR_TO_ROT = {3: 1, 4: 3, 5: 2, 6: 0}  # color -> rotation amount (in 90deg steps)
    PATH_COLOR = 8

    # Find start and goal
    start = None
    goal = None
    for r in range(h):
        for c in range(w):
            if grid[r][c] == START:
                start = (r, c)
            elif grid[r][c] == GOAL:
                goal = (r, c)
    if start is None or goal is None:
        raise ValueError("Start or goal not found")

    # Directions: 0:right,1:down,2:left,3:up
    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    current_dir = 0  # start moving to the right

    # Copy input to output and then mark traversed cells that were background 0
    out = [row[:] for row in grid]

    r, c = start
    # Do not overwrite start cell; paint other traversed background cells
    steps = 0
    while (r, c) != goal:
        dr, dc = dirs[current_dir]
        nr, nc = r + dr, c + dc
        # Check bounds
        if nr < 0 or nr >= h or nc < 0 or nc >= w:
            break  # out of bounds (should not happen for valid inputs)
        val = grid[nr][nc]
        # Obstacle detection: generator uses obstacle colors 7 and 9 (anything >=7)
        if val >= 7 and val <= 9:
            break
        # Move into the cell
        r, c = nr, nc
        # If it's the goal, stop after stepping into it (do not overwrite the goal color)
        if grid[r][c] == GOAL:
            break
        # If the cell is a marker, apply its rotation
        if grid[r][c] in ROT_COLOR_TO_ROT:
            rot = ROT_COLOR_TO_ROT[grid[r][c]]
            current_dir = (current_dir + rot) % 4
        # Paint the cell if it was background
        if grid[r][c] == 0:
            out[r][c] = PATH_COLOR
        steps += 1
        # Safety: prevent infinite loops on malformed inputs
        if steps > h * w * 4:
            break

    # Return as immutable tuple-of-tuples (the validator expects a grid in that format)
    return tuple(tuple(row) for row in out)

