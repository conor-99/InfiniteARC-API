# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 40e5076c
Difficulty: very hard

=== Tags ===
- Propagate label
- Move object to first unoccupied space

=== Description ===
Input grids feature a background color (0), multiple propagation sources
(distinct color X), and a single object (distinct color Y). Propagation sources
spread color X in the direction directly toward the object along the grid's row
or column (whichever aligns with the object's relative position), filling all
background cells (0) in that path until blocked by non-background cells. After
propagation, the object (color Y) is moved to the first background cell (0)
encountered in row-major order (top-left to bottom-right), scanning each row
left-to-right, top-to-bottom. The output grid retains all non-background
elements except for the object's new position and the propagated color X filling
background cells along the path toward the object. This requires sequential
reasoning: determining the object's location, calculating propagation directions
for each source, executing directional spreading, and identifying the first
available background cell for the object's relocation. The complexity arises
from the interplay between dynamic propagation (dependent on object position)
and the need for precise spatial ordering in the movement step, with no reliance
on numerical properties of colors.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(5, 20)
    height = random.randint(5, 20)
    grid_input = [[0] * width for _ in range(height)]
    
    colors = list(range(1, 10))
    X = random.choice(colors)
    Y = random.choice([c for c in colors if c != X])
    
    y_r = random.randint(0, height-1)
    y_c = random.randint(0, width-1)
    grid_input[y_r][y_c] = Y
    
    sources = []
    if y_c > 1:
        c = random.randint(0, y_c - 2)
        grid_input[y_r][c] = X
        sources.append((y_r, c))
    if y_c < width - 2:
        c = random.randint(y_c + 2, width-1)
        grid_input[y_r][c] = X
        sources.append((y_r, c))
    if y_r > 1:
        r = random.randint(0, y_r - 2)
        grid_input[r][y_c] = X
        sources.append((r, y_c))
    if y_r < height - 2:
        r = random.randint(y_r + 2, height-1)
        grid_input[r][y_c] = X
        sources.append((r, y_c))
    
    if not sources:
        grid_input[0][0] = X
        sources.append((0, 0))
    
    grid_output = [row[:] for row in grid_input]
    
    for r, c in sources:
        if r == y_r:
            step = 1 if c < y_c else -1
            for col in range(c + step, y_c, step):
                grid_output[r][col] = X
        elif c == y_c:
            step = 1 if r < y_r else -1
            for row in range(r + step, y_r, step):
                grid_output[row][c] = X
    
    first_zero = None
    for r in range(height):
        for c in range(width):
            if grid_output[r][c] == 0:
                first_zero = (r, c)
                break
        if first_zero:
            break
    if first_zero is None:
        first_zero = (0, 0)
    
    grid_output[y_r][y_c] = 0
    grid_output[first_zero[0]][first_zero[1]] = Y
    
    return {"input": grid_input, "output": grid_output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    non_zero = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                non_zero.append(grid[r][c])
    
    colors = set(non_zero)
    if len(colors) != 2:
        colors = list(colors)
        X = colors[0]
        Y = colors[1] if len(colors) > 1 else 1
    else:
        color_count = {c: non_zero.count(c) for c in colors}
        Y = next(c for c in colors if color_count[c] == 1)
        X = next(c for c in colors if color_count[c] > 1)
    
    y_r, y_c = -1, -1
    for r in range(height):
        for c in range(width):
            if grid[r][c] == Y:
                y_r, y_c = r, c
                break
        if y_r != -1:
            break
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] == X:
                if r == y_r:
                    step = 1 if c < y_c else -1
                    for col in range(c + step, y_c, step):
                        grid[r][col] = X
                elif c == y_c:
                    step = 1 if r < y_r else -1
                    for row in range(r + step, y_r, step):
                        grid[row][c] = X
    
    first_zero = None
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0:
                first_zero = (r, c)
                break
        if first_zero:
            break
    if first_zero is None:
        first_zero = (0, 0)
    
    grid[y_r][y_c] = 0
    grid[first_zero[0]][first_zero[1]] = Y
    
    return tuple(tuple(row) for row in grid)
