# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 9e81650f
Difficulty: hard

=== Tags ===
- Local physics rule

=== Description ===
# Wave Propagation Resonance  Input grids are 20Ã—20 with background color 0.
Non-background cells are color 1 (wave sources) or color 2 (wave absorbers).
Each color 1 cell emits a wave that propagates in all four cardinal directions
(up, down, left, right) at a rate of one cell per step. The wave path is marked
with color 1 in the output grid. When a wave encounters a color 2 cell, that
cell is transformed to color 3, and the wave is absorbed (no further propagation
from that cell). If a wave encounters another color 1 cell, the wave continues
propagating from that cell (effectively turning the color 1 cell into a new
source for the wave). Propagation occurs simultaneously in all directions from
all active sources until no more propagation is possible. The output grid
retains all color 1 cells as wave sources (color 1), transforms color 2
absorbers to color 3, and marks the wave propagation paths with color 1.
Background cells (0) remain unchanged except where wave paths or absorbers are
located. The grid contains multiple sources and absorbers arranged such that
wave paths intersect, overlap, and continue from new sources, requiring the
solver to track simultaneous propagation across the grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque

def generate():
    width = 20
    height = 20
    grid = [[0] * width for _ in range(height)]
    
    num_sources = random.randint(1, 5)
    source_positions = []
    for _ in range(num_sources):
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        while (r, c) in source_positions:
            r = random.randint(0, height-1)
            c = random.randint(0, width-1)
        source_positions.append((r, c))
        grid[r][c] = 1
    
    num_absorbers = random.randint(1, 5)
    absorber_positions = []
    for _ in range(num_absorbers):
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        while (r, c) in source_positions or (r, c) in absorber_positions:
            r = random.randint(0, height-1)
            c = random.randint(0, width-1)
        absorber_positions.append((r, c))
        grid[r][c] = 2
    
    output_grid = [row[:] for row in grid]
    visited = [[False] * width for _ in range(height)]
    queue = deque()
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 1:
                visited[r][c] = True
                queue.append((r, c))
    
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    
    while queue:
        r, c = queue.popleft()
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc]:
                visited[nr][nc] = True
                if grid[nr][nc] == 1:
                    queue.append((nr, nc))
                elif grid[nr][nc] == 2:
                    output_grid[nr][nc] = 3
                elif grid[nr][nc] == 0:
                    output_grid[nr][nc] = 1
                    queue.append((nr, nc))
    
    return {"input": grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque
def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = [list(row) for row in input_grid]
    visited = [[False] * width for _ in range(height)]
    queue = deque()
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 1:
                visited[r][c] = True
                queue.append((r, c))
    
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    
    while queue:
        r, c = queue.popleft()
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc]:
                visited[nr][nc] = True
                if input_grid[nr][nc] == 1:
                    queue.append((nr, nc))
                elif input_grid[nr][nc] == 2:
                    output_grid[nr][nc] = 3
                elif input_grid[nr][nc] == 0:
                    output_grid[nr][nc] = 1
                    queue.append((nr, nc))
    
    return output_grid
