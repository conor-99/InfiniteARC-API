# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 238bcd1d
Difficulty: easy

=== Tags ===
- Detect connectedness
- Repaint border
- Draw pattern from point
- Swap columns

=== Description ===
The task involves transforming an input grid into an output grid through a
sequence of four consistent, deterministic steps. First, the input grid is
analyzed to identify the top-left cell of the single connected region (a
contiguous group of non-zero color cells connected by edges). Next, all
perimeter cells (first row, last row, first column, last column) are repainted
to color 2. Then, starting from the identified top-left cell of the connected
region, a horizontal line of up to three cells to the right is drawn using color
3 (stopping at the grid boundary if necessary). Finally, the first and second
columns (columns 0 and 1) of the grid are swapped. These steps apply uniformly
to all valid input grids, creating a clear and discoverable pattern for the
output grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
def generate():
    width = common.randint(3, 30)
    height = common.randint(3, 30)
    shape = common.choice(['el', 'you', 'aitch'])
    pixels = common.rand_sprite(shape, width, height)
    while not pixels:
        shape = common.choice(['el', 'you', 'aitch'])
        pixels = common.rand_sprite(shape, width, height)
    input_grid = common.grid(width, height, 0)
    for r, c in pixels:
        input_grid[r][c] = common.random_color(exclude=[0])
    non_zero = [(r, c) for r in range(height) for c in range(width) if input_grid[r][c] > 0]
    if not non_zero:
        return {'input': input_grid, 'output': input_grid}
    top_left_r = min(r for r, c in non_zero)
    top_left_c = min(c for r, c in non_zero)
    output_grid = [row[:] for row in input_grid]
    for c in range(width):
        output_grid[0][c] = 2
        output_grid[height-1][c] = 2
    for r in range(height):
        output_grid[r][0] = 2
        output_grid[r][width-1] = 2
    for i in range(3):
        c = top_left_c + i
        if c >= width:
            break
        output_grid[top_left_r][c] = 3
    for r in range(height):
        output_grid[r][0], output_grid[r][1] = output_grid[r][1], output_grid[r][0]
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    non_zero = [(r, c) for r in range(height) for c in range(width) if input_grid[r][c] > 0]
    if not non_zero:
        return input_grid
    top_left_r = min(r for r, c in non_zero)
    top_left_c = min(c for r, c in non_zero)
    output_grid = [row[:] for row in input_grid]
    for c in range(width):
        output_grid[0][c] = 2
        output_grid[height-1][c] = 2
    for r in range(height):
        output_grid[r][0] = 2
        output_grid[r][width-1] = 2
    for i in range(3):
        c = top_left_c + i
        if c >= width:
            break
        output_grid[top_left_r][c] = 3
    for r in range(height):
        output_grid[r][0], output_grid[r][1] = output_grid[r][1], output_grid[r][0]
    return output_grid
