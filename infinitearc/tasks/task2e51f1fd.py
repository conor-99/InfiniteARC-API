# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 2e51f1fd
Difficulty: hard

=== Tags ===
- Mirror bounce
- Motif extraction
- Stacked layer alignment
- Pattern translation
- Pattern rotation
- Local convolution rule

=== Description ===
The task involves a grid where multiple contiguous colored motifs (each
representing a distinct layer) move in fixed initial directions until they
encounter mirror lines (a specific color). Upon contact with a mirror line, each
motif reflects (reversing horizontal or vertical movement based on mirror
orientation) and rotates 90 degrees clockwise. The output grid is generated by
overlaying all motif paths, prioritizing lower color numbers for overlapping
cells. Stacked layer alignment is achieved as motifs align into a symmetrical
pattern relative to the mirror lines after bouncing, with pattern translation
and rotation occurring through the bounce mechanics. Motif extraction identifies
each contiguous color region as a separate layer, and local convolution rules
determine reflection direction and rotation at each mirror interaction. The
transformation requires tracking multi-layer movement, directional changes,
rotations, and alignment without relying on numerical properties, demanding
sequential spatial reasoning across all grid elements.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, rand_sprite

def generate():
    width = random.randint(15, 25)
    height = random.randint(15, 25)
    grid_input = grid(width, height, 0)
    mirror_color = 6
    mirror_vertical = random.choice([True, False])
    mirror_pos = random.randint(5, width-6) if mirror_vertical else random.randint(5, height-6)
    
    if mirror_vertical:
        for r in range(height):
            grid_input[r][mirror_pos] = mirror_color
    else:
        for c in range(width):
            grid_input[mirror_pos][c] = mirror_color
    
    # Place motifs
    for color in range(1, 6):
        shape = random.choice(['el', 'aitch', 'you'])
        pixels = rand_sprite(shape, width, height)
        
        if mirror_vertical:
            if random.choice([True, False]):
                valid_pixels = [(r, c) for r, c in pixels if c < mirror_pos]
            else:
                valid_pixels = [(r, c) for r, c in pixels if c > mirror_pos]
        else:
            if random.choice([True, False]):
                valid_pixels = [(r, c) for r, c in pixels if r < mirror_pos]
            else:
                valid_pixels = [(r, c) for r, c in pixels if r > mirror_pos]
        
        if not valid_pixels:
            continue
        
        for r, c in valid_pixels:
            if 0 <= r < height and 0 <= c < width:
                grid_input[r][c] = color

    # Collect actual motif colors present in grid
    motif_colors = []
    for color in range(1, 6):
        if any(grid_input[r][c] == color for r in range(height) for c in range(width)):
            motif_colors.append(color)
    
    # Ensure at least 3 motifs
    if len(motif_colors) < 3:
        motif_colors = motif_colors[:3]  # At least 3
    
    path_cells = {}
    for color in motif_colors:
        initial_positions = []
        for r in range(height):
            for c in range(width):
                if grid_input[r][c] == color:
                    initial_positions.append((r, c))
        
        if mirror_vertical:
            if max(c for r, c in initial_positions) < mirror_pos:
                direction = (0, 1)
            else:
                direction = (0, -1)
        else:
            if max(r for r, c in initial_positions) < mirror_pos:
                direction = (1, 0)
            else:
                direction = (-1, 0)
        
        current_positions = initial_positions
        current_dir = direction
        path_set = set()
        while True:
            next_positions = [(r + current_dir[0], c + current_dir[1]) for (r, c) in current_positions]
            hit_mirror = any(0 <= r < height and 0 <= c < width and grid_input[r][c] == mirror_color for (r, c) in next_positions)
            if hit_mirror:
                if mirror_vertical:
                    current_dir = (current_dir[0], -current_dir[1])
                else:
                    current_dir = (-current_dir[0], current_dir[1])
                current_dir = (current_dir[1], -current_dir[0])
            
            for (r, c) in next_positions:
                if 0 <= r < height and 0 <= c < width:
                    path_set.add((r, c))
            
            if not any(0 <= r < height and 0 <= c < width for (r, c) in next_positions):
                break
            current_positions = next_positions
        
        path_cells[color] = path_set
    
    grid_output = grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            min_color = 0
            for color in motif_colors:
                if (r, c) in path_cells.get(color, set()):
                    if min_color == 0 or color < min_color:
                        min_color = color
            grid_output[r][c] = min_color
    
    return {'input': grid_input, 'output': grid_output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid:
        return []
    grid_input = [list(row) for row in input_grid]
    width = len(grid_input[0])
    height = len(grid_input)
    mirror_color = 6
    mirror_vertical = None
    mirror_pos = None
    
    for c in range(width):
        if all(grid_input[r][c] == mirror_color for r in range(height)):
            mirror_vertical = True
            mirror_pos = c
            break
    if mirror_vertical is None:
        for r in range(height):
            if all(grid_input[r][c] == mirror_color for c in range(width)):
                mirror_vertical = False
                mirror_pos = r
                break
    if mirror_vertical is None:
        return grid_input
    
    motif_colors = [color for color in range(1, 6) if any(grid_input[r][c] == color for r in range(height) for c in range(width))]
    path_cells = {}
    
    for color in motif_colors:
        initial_positions = []
        for r in range(height):
            for c in range(width):
                if grid_input[r][c] == color:
                    initial_positions.append((r, c))
        
        if mirror_vertical:
            if max(c for r, c in initial_positions) < mirror_pos:
                direction = (0, 1)
            else:
                direction = (0, -1)
        else:
            if max(r for r, c in initial_positions) < mirror_pos:
                direction = (1, 0)
            else:
                direction = (-1, 0)
        
        current_positions = initial_positions
        current_dir = direction
        path_set = set()
        while True:
            next_positions = [(r + current_dir[0], c + current_dir[1]) for (r, c) in current_positions]
            hit_mirror = any(0 <= r < height and 0 <= c < width and grid_input[r][c] == mirror_color for (r, c) in next_positions)
            if hit_mirror:
                if mirror_vertical:
                    current_dir = (current_dir[0], -current_dir[1])
                else:
                    current_dir = (-current_dir[0], current_dir[1])
                current_dir = (current_dir[1], -current_dir[0])
            
            for (r, c) in next_positions:
                if 0 <= r < height and 0 <= c < width:
                    path_set.add((r, c))
            
            if not any(0 <= r < height and 0 <= c < width for (r, c) in next_positions):
                break
            current_positions = next_positions
        
        path_cells[color] = path_set
    
    grid_output = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            min_color = 0
            for color in motif_colors:
                if (r, c) in path_cells.get(color, set()):
                    if min_color == 0 or color < min_color:
                        min_color = color
            grid_output[r][c] = min_color
    
    return grid_output
