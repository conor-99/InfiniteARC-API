# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 6e776750
Difficulty: medium–hard

=== Tags ===
- Detect enclosure
- Non rectangular tiling
- Multi stage color switch

=== Description ===
Input grids feature a complex arrangement of non-rectangular tiles (e.g.,
hexagons, triangles, irregular polygons) drawn in distinct colors (2-9), forming
a seamless tiling without overlapping. The background color is 0. Some tiles
enclose regions of background color (holes), defined as connected background
areas completely surrounded by a single tile color (all adjacent cells to the
hole belong to the enclosing tile). These enclosed holes are visually distinct
from the tile shapes.  The output grid transforms each hole through a two-stage
visual color switch. In the first stage, each hole is filled with the color that
immediately follows the enclosing tile's color in the natural sequence
(2→3→4→...→9→0→2). In the second stage, the color is adjusted based on the
enclosing tile's position in the grid: if the tile is located in an even-
numbered row (0-indexed), the hole color shifts one position forward in the
sequence; if in an odd-numbered row, it shifts one position backward. This
creates a multi-stage transformation where the final hole color depends on both
the tile's color and its vertical position. All non-hole regions and tile
boundaries remain unchanged, and the transformation applies uniformly to all
enclosed holes.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import hollow_conway
def generate():
    while True:
        width = random.randint(10, 30)
        height = random.randint(10, 30)
        grid = [[0] * width for _ in range(height)]
        
        colors = random.sample(range(2, 10), random.randint(2, 4))
        
        for color in colors:
            size = random.randint(3, 5)
            rows, cols = hollow_conway(size, size, tries=5)
            r = random.randint(0, height - size)
            c = random.randint(0, width - size)
            for i, j in zip(rows, cols):
                grid[r + i][c + j] = color
        
        visited = [[False] * width for _ in range(height)]
        has_hole = False
        for r in range(height):
            for c in range(width):
                if grid[r][c] == 0 and not visited[r][c]:
                    component = []
                    stack = [(r, c)]
                    visited[r][c] = True
                    while stack:
                        cr, cc = stack.pop()
                        component.append((cr, cc))
                        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == 0:
                                visited[nr][nc] = True
                                stack.append((nr, nc))
                    
                    surrounding = set()
                    for cr, cc in component:
                        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                                surrounding.add(grid[nr][nc])
                    if len(surrounding) == 1:
                        has_hole = True
                        break
            if has_hole:
                break
        
        if has_hole:
            break
    
    output_grid = [row[:] for row in grid]
    visited = [[False] * width for _ in range(height)]
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 and not visited[r][c]:
                component = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == 0:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                
                surrounding = set()
                for cr, cc in component:
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                            surrounding.add(grid[nr][nc])
                if len(surrounding) == 1:
                    enc_color = next(iter(surrounding))
                    min_row = min(cr for cr, cc in component)
                    parity = min_row % 2
                    next_color = (enc_color + 1) % 10
                    if parity == 0:
                        new_color = (next_color + 1) % 10
                    else:
                        new_color = (next_color - 1) % 10
                    for cr, cc in component:
                        output_grid[cr][cc] = new_color
    
    return {"input": grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import *
def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    visited = [[False] * width for _ in range(height)]
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 and not visited[r][c]:
                component = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == 0:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                
                surrounding = set()
                for cr, cc in component:
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                            surrounding.add(grid[nr][nc])
                if len(surrounding) == 1:
                    enc_color = next(iter(surrounding))
                    min_row = min(cr for cr, cc in component)
                    parity = min_row % 2
                    next_color = (enc_color + 1) % 10
                    if parity == 0:
                        new_color = (next_color + 1) % 10
                    else:
                        new_color = (next_color - 1) % 10
                    for cr, cc in component:
                        grid[cr][cc] = new_color
    
    return tuple(tuple(row) for row in grid)
