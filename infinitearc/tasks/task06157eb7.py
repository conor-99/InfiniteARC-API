# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 06157eb7
Difficulty: very hard

=== Tags ===
- Kinetic collision
- Bounce marking
- Color modulated motion
- Token following
- Spacing

=== Description ===
Input grids are large (20×20 or larger) with background color 0. Walls consist
of horizontal or vertical line segments (1-3 cells long) of distinct colors
(1-9), placed such that no walls touch or overlap. Tokens are single-cell
markers of unique colors (not used by walls), positioned at the leftmost column
(column 0) in distinct rows, moving east (right) initially. The output grid
displays the complete path of each token, with segments colored according to the
token's current color during traversal. Upon collision with a wall, the token's
color updates to the wall's color, and its direction changes based on the wall's
color: red (2) → 90° clockwise, blue (1) → 90° counter-clockwise, green (3) →
90° clockwise, yellow (4) → 90° counter-clockwise, and so on (color-specific
direction rules are consistent across all examples). Paths are drawn over
background cells only, never over walls or other paths. Tokens exit the grid at
boundaries after finite bounces, with no path intersections. The spacing between
walls creates complex multi-bounce trajectories requiring sequential color-
modulated motion tracking.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    """Generate an ARC-style input/output pair for the kinetic-bounce task.

    Walls are short horizontal/vertical segments (1-3) placed so they don't touch
    (no 8-neighbor adjacency). Tokens are placed in the leftmost column (col 0),
    have colors that are not used by walls, and move east initially. When a
    token's next cell contains a non-zero color (a wall or occupied cell), the
    token adopts that color and rotates 90 degrees according to a color rule
    (consistent mapping implemented below). Paths are drawn only over
    background cells (0) and never over walls or previously drawn paths.

    The function will retry random placements until it finds a configuration in
    which all tokens exit the grid without path intersections.
    """

    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # E, S, W, N

    def rotate_dir_by_color(color):
        # Mapping consistent with description: color % 4 == 2 or 3 -> clockwise,
        # otherwise counter-clockwise. This yields: 1->CCW, 2->CW, 3->CW, 4->CCW, ...
        return 1 if (color % 4) in (2, 3) else -1

    def neighbors8(r, c, height, width):
        for dr in (-1, 0, 1):
            for dc in (-1, 0, 1):
                if dr == 0 and dc == 0:
                    continue
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    yield (nr, nc)

    # Try multiple times to build a valid configuration
    for overall_attempt in range(400):
        width = random.randint(20, 30)
        height = random.randint(20, 30)

        # Choose a small set of distinct wall colors (1..9)
        wall_count = random.randint(4, 7)
        wall_colors = random.sample(list(range(1, 10)), wall_count)

        walls_map = {}  # (r,c) -> color
        walls_cells = set()
        placed_all_walls = True

        # Place each wall as a short segment (length 1..3) while keeping 8-neighbor
        # separation so walls do not touch or overlap.
        for wcolor in wall_colors:
            placed = False
            for attempt_w in range(200):
                orient = random.choice([0, 1])  # 0 horizontal, 1 vertical
                length = random.randint(1, 3)
                if orient == 0:
                    row = random.randint(0, height - 1)
                    col = random.randint(2, max(2, width - length))
                    cells = [(row, c) for c in range(col, col + length)]
                else:
                    col = random.randint(2, width - 1)
                    row = random.randint(0, max(0, height - length))
                    cells = [(r, col) for r in range(row, row + length)]

                # Reject any placement that would touch existing walls (8-neighbor)
                bad = False
                for (r, c) in cells:
                    if c < 2 or r < 0 or r >= height or c < 0 or c >= width:
                        bad = True
                        break
                    for nr, nc in neighbors8(r, c, height, width):
                        if (nr, nc) in walls_cells:
                            bad = True
                            break
                    if bad:
                        break
                    if (r, c) in walls_cells:
                        bad = True
                        break
                if bad:
                    continue

                # Accept placement
                for (r, c) in cells:
                    walls_map[(r, c)] = wcolor
                    walls_cells.add((r, c))
                placed = True
                break
            if not placed:
                placed_all_walls = False
                break

        if not placed_all_walls:
            continue

        # Choose token colors (must be distinct and not used by walls)
        possible_token_colors = [c for c in range(1, 10) if c not in wall_colors]
        token_count = random.randint(2, 3)
        if len(possible_token_colors) < token_count:
            continue
        token_colors = random.sample(possible_token_colors, token_count)

        # Choose token rows in leftmost column ensuring the immediate east cell is free
        candidates = [r for r in range(height) if (r, 1) not in walls_cells and (r, 0) not in walls_cells]
        if len(candidates) < token_count:
            continue

        rows_choice = None
        for attempt_r in range(200):
            rows = random.sample(candidates, token_count)
            rows.sort()
            if token_count > 1:
                minsep = min(rows[i] - rows[i - 1] for i in range(1, len(rows)))
                if minsep < 3:
                    continue
            rows_choice = rows
            break
        if rows_choice is None:
            continue

        # Build the input grid
        input_grid = grid(width, height, 0)
        for (r, c), col in walls_map.items():
            input_grid[r][c] = col
        tokens = [(r, col) for r, col in zip(rows_choice, token_colors)]
        for r, col in tokens:
            input_grid[r][0] = col

        # Simulate each token sequentially and draw its path on output_grid. If any
        # token would cross an already drawn path or would be trapped, abandon the
        # configuration and retry.
        output_grid = [row[:] for row in input_grid]
        path_cells = set()
        max_steps = width * height * 4
        valid = True

        for (sr, scol) in tokens:
            cur_pos = (sr, 0)
            cur_color = scol
            direction = 0  # start east
            steps = 0
            while True:
                dr, dc = directions[direction]
                nr, nc = cur_pos[0] + dr, cur_pos[1] + dc
                steps += 1
                if steps > max_steps:
                    valid = False
                    break
                if nr < 0 or nr >= height or nc < 0 or nc >= width:
                    # token exits
                    break
                # Collision detection uses the input grid: any non-zero cell is an
                # obstacle/wall (walls are never in column 0 or 1 by construction).
                if input_grid[nr][nc] != 0:
                    wall_color = input_grid[nr][nc]
                    cur_color = wall_color
                    rot = rotate_dir_by_color(wall_color)
                    direction = (direction + rot) % 4
                    # do not step into the wall
                    continue
                # Only draw paths on background cells (0). If the cell is already
                # non-zero in output_grid it means it is occupied by a token start or
                # a previously drawn path — reject this configuration.
                if output_grid[nr][nc] != 0:
                    valid = False
                    break
                # Mark the path cell with the token's current color
                output_grid[nr][nc] = cur_color
                path_cells.add((nr, nc))
                cur_pos = (nr, nc)
            if not valid:
                break

        if not valid:
            continue

        # Ensure input != output (at least one path cell was drawn)
        if input_grid == output_grid:
            continue

        return {"input": input_grid, "output": output_grid}

    # Should rarely reach here; return the last attempted grid if nothing valid
    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert immutable input to a mutable list-of-lists
    input_list = [list(row) for row in input_grid]
    height = len(input_list)
    width = len(input_list[0])
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # E, S, W, N

    def rotate_dir_by_color(color):
        return 1 if (color % 4) in (2, 3) else -1

    # Collect tokens from the leftmost column (column 0)
    tokens = []
    for r in range(height):
        if input_list[r][0] != 0:
            tokens.append((r, input_list[r][0]))

    output_grid = [row[:] for row in input_list]
    max_steps = width * height * 6

    for (sr, scol) in tokens:
        cur_pos = (sr, 0)
        cur_color = scol
        direction = 0  # start east
        steps = 0
        while True:
            dr, dc = directions[direction]
            nr, nc = cur_pos[0] + dr, cur_pos[1] + dc
            steps += 1
            if steps > max_steps:
                # Safety break for malformed inputs (generator guarantees exit)
                break
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                # token exited the grid
                break
            # Any non-zero in the input is treated as a wall/obstacle
            if input_list[nr][nc] != 0:
                wall_color = input_list[nr][nc]
                cur_color = wall_color
                rot = rotate_dir_by_color(wall_color)
                direction = (direction + rot) % 4
                continue
            # Only draw on background cells; never overwrite walls or previously
            # drawn paths (those show up as non-zero in output_grid). For valid
            # inputs (generated by the generator) this will always be a 0 cell.
            if output_grid[nr][nc] != 0:
                break
            output_grid[nr][nc] = cur_color
            cur_pos = (nr, nc)
    return output_grid

