# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: f6085703
Difficulty: very hard

=== Tags ===
- Infer hidden grid
- Shape attribute projection
- Rule switch on context
- Elastic wave
- Recolor smallest component
- Find the intruder

=== Description ===
# Elastic Intruder Wave  Input grids are composed of multiple disconnected,
4-connected regions (components) in distinct colors (1-9), set against a uniform
background of color 0. Each component represents a geometric shape with clear
boundaries and no overlapping regions. The grid dimensions range from 15×15 to
25×25, containing 5–12 distinct components.  The output transformation follows a
sequence of context-dependent rules:  1. **Infer the hidden grid**: Identify the
smallest component by area (number of cells) — this is the "intruder" that must
be transformed. All other components remain as structural elements.  2. **Rule
switch on context**: The color to which the intruder is recolored depends on the
color of the largest component in the grid. Using a predefined cyclic sequence
(1→2→3→...→9→1), the intruder is recolored to the next color in the sequence
after the largest component's color. If the largest component is color 1, the
intruder becomes color 2; if the largest is color 9, it becomes color 1.  3.
**Elastic wave propagation**: Starting from the intruder's position, a wave-like
effect spreads radially outward. Components within a Manhattan distance of 3
from the intruder's centroid are affected. The wave alternates between two
colors (A and B) based on distance: distance 1 components change to color A,
distance 2 to color B, distance 3 to color A, and so on. The wave respects
component boundaries and only affects non-background regions.  4. **Shape
attribute projection**: The bounding box dimensions (width and height) of the
largest component are projected onto the intruder. The intruder's shape is not
physically altered, but its color transformation (from step 2) is reinforced
through the elastic wave propagation, creating a visual echo that aligns with
the largest component's geometric properties.  5. **Find the intruder**: The
final transformation visually distinguishes the intruder by its recolored state
and the concentric wave pattern emanating from its position, while all other
components maintain their original shapes and colors except where modified by
the wave.  The task requires recognizing the smallest component, determining the
context-dependent recoloring rule, and applying the wave propagation with
alternating colors based on distance, all while maintaining the structural
integrity of the largest component's geometric attributes. The output grid must
visibly demonstrate the wave's concentric pattern and the intruder's transformed
state, with no component overlapping or altering the background.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import math
import common

# Improved generator ensuring unique component sizes and valid bounding boxes.

def generate():
    width = random.randint(15, 25)
    height = random.randint(15, 25)

    num_components = random.randint(5, min(9, 9))

    grid = [[0 for _ in range(width)] for _ in range(height)]
    components = []  # list of lists of (r,c)

    def can_place(sprite, off_r, off_c):
        for pr, pc in sprite:
            r = pr + off_r
            c = pc + off_c
            if r < 0 or r >= height or c < 0 or c >= width:
                return False
            if grid[r][c] != 0:
                return False
            # ensure no 4-neighbor adjacency with existing components
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                    return False
        return True

    # Choose distinct sizes for components (to avoid ties)
    used_sizes = set()
    max_size_possible = max(1, min(20, (width * height) // max(1, num_components)))
    for i in range(num_components):
        # pick a unique size
        for attempt_size in range(200):
            size = random.randint(1, max_size_possible)
            if size not in used_sizes:
                used_sizes.add(size)
                break
        else:
            # fallback
            size = max(1, (i + 2))
            used_sizes.add(size)

        # Try to place a connected sprite of this size somewhere in the grid
        placed = False
        for attempt in range(400):
            # pick a bounding box that can contain this size
            w_comp = random.randint(2, min(8, width - 2))
            # ensure h_comp is large enough: ceil(size / w_comp)
            min_h = max(2, math.ceil(size / w_comp))
            max_h_allowed = min(8, height - 2)
            if min_h > max_h_allowed:
                continue
            h_comp = random.randint(min_h, max_h_allowed)

            # Build a contiguous creature of exact size inside this small bbox
            s = min(size, w_comp * h_comp)
            sprite = common.continuous_creature(s, w_comp, h_comp)
            if not sprite:
                continue

            max_off_r = height - h_comp
            max_off_c = width - w_comp
            if max_off_r < 0 or max_off_c < 0:
                continue

            for trial in range(50):
                off_r = random.randint(0, max_off_r)
                off_c = random.randint(0, max_off_c)
                if can_place(sprite, off_r, off_c):
                    coords = [(pr + off_r, pc + off_c) for pr, pc in sprite]
                    for r, c in coords:
                        grid[r][c] = -1  # temporary mark to reserve
                    components.append(coords)
                    placed = True
                    break
            if placed:
                break

        if not placed:
            # fallback: attempt to place a single isolated pixel
            found = False
            for r in range(height):
                for c in range(width):
                    if grid[r][c] != 0:
                        continue
                    ok = True
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                            ok = False
                            break
                    if ok:
                        grid[r][c] = -1
                        components.append([(r, c)])
                        found = True
                        break
                if found:
                    break
            if not found:
                # last resort: fill any free spot (may touch)
                for r in range(height):
                    for c in range(width):
                        if grid[r][c] == 0:
                            grid[r][c] = -1
                            components.append([(r, c)])
                            found = True
                            break
                    if found:
                        break

    # Now assign unique colors to components. Ensure the condition that
    # the smallest component's original color != (next color after largest_color)
    sizes = [len(comp) for comp in components]
    smallest_idx = sizes.index(min(sizes))
    largest_idx = sizes.index(max(sizes))

    for try_colors in range(400):
        colors = random.sample(list(range(1, 10)), len(components))
        largest_color = colors[largest_idx]
        new_color_intruder = (largest_color % 9) + 1
        if colors[smallest_idx] != new_color_intruder:
            break
    else:
        colors = random.sample(list(range(1, 10)), len(components))
        largest_color = colors[largest_idx]
        new_color_intruder = (largest_color % 9) + 1
        if colors[smallest_idx] == new_color_intruder:
            for j in range(len(colors)):
                if j == largest_idx:
                    continue
                candidate_new = (colors[j] % 9) + 1
                if colors[smallest_idx] != candidate_new:
                    colors[largest_idx], colors[j] = colors[j], colors[largest_idx]
                    break
            largest_color = colors[largest_idx]
            new_color_intruder = (largest_color % 9) + 1

    # Create the final input grid assigning the colors
    input_grid = [[0 for _ in range(width)] for _ in range(height)]
    for idx, comp in enumerate(components):
        col = colors[idx]
        for r, c in comp:
            input_grid[r][c] = col

    # Build the output grid following the same deterministic rules
    output_grid = [row[:] for row in input_grid]

    smallest_comp = components[smallest_idx]
    largest_comp = components[largest_idx]
    largest_color = colors[largest_idx]
    new_color_intruder = (largest_color % 9) + 1

    # Recolor intruder
    for r, c in smallest_comp:
        output_grid[r][c] = new_color_intruder

    centroid_r = sum(r for r, c in smallest_comp) / len(smallest_comp)
    centroid_c = sum(c for r, c in smallest_comp) / len(smallest_comp)

    # Wave colors
    A = (new_color_intruder % 9) + 1
    B = (A % 9) + 1

    # Bounding box of largest
    min_r = min(r for r, c in largest_comp)
    max_r = max(r for r, c in largest_comp)
    min_c = min(c for r, c in largest_comp)
    max_c = max(c for r, c in largest_comp)
    bbox_h = max_r - min_r + 1
    bbox_w = max_c - min_c + 1

    top_left_r = int(round(centroid_r - (bbox_h - 1) / 2.0))
    top_left_c = int(round(centroid_c - (bbox_w - 1) / 2.0))

    for r, c in smallest_comp:
        if top_left_r <= r < top_left_r + bbox_h and top_left_c <= c < top_left_c + bbox_w:
            output_grid[r][c] = new_color_intruder

    # Apply elastic wave to other components
    for idx, comp in enumerate(components):
        if idx == smallest_idx:
            continue
        min_dist = min(abs(r - centroid_r) + abs(c - centroid_c) for r, c in comp)
        d = int(round(min_dist))
        if 1 <= d <= 3:
            new_col = A if (d % 2 == 1) else B
            for r, c in comp:
                output_grid[r][c] = new_col

    # Sanity clamp
    for r in range(height):
        for c in range(width):
            v = output_grid[r][c]
            output_grid[r][c] = int(v) if 0 <= int(v) <= 9 else 0

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import math
import common

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    visited = [[False] * width for _ in range(height)]
    components = []
    comp_colors = []

    for r in range(height):
        for c in range(width):
            if visited[r][c] or grid[r][c] == 0:
                continue
            color = grid[r][c]
            stack = [(r, c)]
            visited[r][c] = True
            comp = []
            while stack:
                cr, cc = stack.pop()
                comp.append((cr, cc))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            components.append(comp)
            comp_colors.append(color)

    if not components:
        return tuple(tuple(row) for row in grid)

    sizes = [len(comp) for comp in components]
    smallest_idx = sizes.index(min(sizes))
    largest_idx = sizes.index(max(sizes))

    smallest_comp = components[smallest_idx]
    largest_comp = components[largest_idx]
    largest_color = comp_colors[largest_idx]

    new_color_intruder = (largest_color % 9) + 1

    output_grid = [row[:] for row in grid]

    for r, c in smallest_comp:
        output_grid[r][c] = new_color_intruder

    centroid_r = sum(r for r, c in smallest_comp) / len(smallest_comp)
    centroid_c = sum(c for r, c in smallest_comp) / len(smallest_comp)

    A = (new_color_intruder % 9) + 1
    B = (A % 9) + 1

    min_r = min(r for r, c in largest_comp)
    max_r = max(r for r, c in largest_comp)
    min_c = min(c for r, c in largest_comp)
    max_c = max(c for r, c in largest_comp)
    bbox_h = max_r - min_r + 1
    bbox_w = max_c - min_c + 1

    top_left_r = int(round(centroid_r - (bbox_h - 1) / 2.0))
    top_left_c = int(round(centroid_c - (bbox_w - 1) / 2.0))
    for r, c in smallest_comp:
        if top_left_r <= r < top_left_r + bbox_h and top_left_c <= c < top_left_c + bbox_w:
            output_grid[r][c] = new_color_intruder

    for idx, comp in enumerate(components):
        if idx == smallest_idx:
            continue
        min_dist = min(abs(r - centroid_r) + abs(c - centroid_c) for r, c in comp)
        d = int(round(min_dist))
        if 1 <= d <= 3:
            new_col = A if (d % 2 == 1) else B
            for r, c in comp:
                output_grid[r][c] = new_col

    return tuple(tuple(row) for row in output_grid)

