# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: e8b16421
Difficulty: insane

=== Tags ===
- Pattern alignment

=== Description ===
The input grid consists of multiple disconnected patterns (connected components
of the same color) scattered across the grid. The output grid is formed by
rotating each pattern 90 degrees clockwise around its centroid (center of mass),
then shifting each pattern so that its centroid aligns with the main diagonal
(where row index equals column index). Patterns are processed in order of
increasing centroid row, and shifts are applied without overlapping. The
transformation requires precise geometric reasoning to align the patterns'
centroids to the diagonal while maintaining the patterns' rotational orientation
relative to their original positions. This task demands multi-step spatial
reasoning, including centroid calculation, rotation, and coordinate-based
alignment.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    while True:
        width = common.randint(5, 30)
        height = common.randint(5, 30)
        input_grid = common.grid(width, height, 0)
        colors = common.random_colors(2, exclude=[0])
        
        # Create two disconnected patterns
        for color in colors:
            pattern = common.random_el(width, height)
            for r, c in pattern:
                if input_grid[r][c] == 0:
                    input_grid[r][c] = color
        
        # Create output grid
        output_grid = common.grid(width, height, 0)
        visited = [[False] * width for _ in range(height)]
        patterns = []
        
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] > 0 and not visited[r][c]:
                    color = input_grid[r][c]
                    pixels = []
                    stack = [(r, c)]
                    visited[r][c] = True
                    while stack:
                        sr, sc = stack.pop()
                        pixels.append((sr, sc))
                        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                            nr, nc = sr + dr, sc + dc
                            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                                visited[nr][nc] = True
                                stack.append((nr, nc))
                    cx = sum(p[0] for p in pixels) // len(pixels)
                    cy = sum(p[1] for p in pixels) // len(pixels)
                    patterns.append((color, pixels, cx, cy))
        
        patterns.sort(key=lambda x: x[2])
        for color, pixels, cx, cy in patterns:
            rotated = []
            for r, c in pixels:
                new_r = cx + (c - cy)
                new_c = cy + (cx - r)
                rotated.append((new_r, new_c))
            d = max(cx, cy)
            shift_r = d - cx
            shift_c = d - cy
            shifted = [(r + shift_r, c + shift_c) for r, c in rotated]
            for r, c in shifted:
                if 0 <= r < height and 0 <= c < width:
                    output_grid[r][c] = color
        
        # Ensure input != output
        if input_grid != output_grid:
            return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = common.grid(width, height, 0)
    
    visited = [[False] * width for _ in range(height)]
    patterns = []
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] > 0 and not visited[r][c]:
                color = input_grid[r][c]
                pixels = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    sr, sc = stack.pop()
                    pixels.append((sr, sc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = sr + dr, sc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                cx = sum(p[0] for p in pixels) // len(pixels)
                cy = sum(p[1] for p in pixels) // len(pixels)
                patterns.append((color, pixels, cx, cy))
    
    patterns.sort(key=lambda x: x[2])
    
    for color, pixels, cx, cy in patterns:
        rotated = []
        for r, c in pixels:
            new_r = cx + (c - cy)
            new_c = cy + (cx - r)
            rotated.append((new_r, new_c))
        d = max(cx, cy)
        shift_r = d - cx
        shift_c = d - cy
        shifted = [(r + shift_r, c + shift_c) for r, c in rotated]
        for r, c in shifted:
            if 0 <= r < height and 0 <= c < width:
                output_grid[r][c] = color
    
    return output_grid
