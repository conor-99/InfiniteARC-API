# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: ae384aae
Difficulty: medium–hard

=== Tags ===
- Synchronized bounce
- Parallel lasers
- Agent memory trace

=== Description ===
# Task Description  **Input Grid:** A grid containing multiple colored "laser"
agents (each represented by a distinct color from 1-9) positioned along the
grid's edges. Lasers on the top edge move downward, bottom edge lasers move
upward, left edge lasers move rightward, and right edge lasers move leftward.
The grid also contains background color (0) and may include static obstacles
(other colors that lasers cannot pass through). Lasers move in straight lines
until hitting a boundary or obstacle.  **Transformation Rule:** The output grid
is generated by simulating each laser's movement for a number of steps equal to
the grid's height. During each step, lasers move one cell in their current
direction. Upon hitting a grid boundary (top, bottom, left, or right edge),
lasers reverse direction (e.g., downward → upward, right → left). Upon hitting
an obstacle, lasers stop moving. The "memory trace" is created by drawing every
cell visited by each laser during the simulation in its original color. The
background (0) is overwritten by these traces, while existing agents and
obstacles remain visible. All lasers move and bounce simultaneously
("synchronized bounce"), and lasers moving in parallel directions maintain their
parallel paths ("parallel lasers"). The transformation requires identifying
edge-based movement direction, bounce logic, and trace accumulation across
multiple steps.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    w = random.randint(5, 30)
    h = random.randint(5, 30)
    grid = [[0] * w for _ in range(h)]
    
    laser_colors = random.sample(range(1, 10), random.randint(2, 5))
    
    top_lasers = []
    for col in random.sample(range(1, w-1), random.randint(1, 3)):
        grid[0][col] = random.choice(laser_colors)
        top_lasers.append((0, col))
    
    bottom_lasers = []
    for col in random.sample(range(1, w-1), random.randint(1, 3)):
        grid[h-1][col] = random.choice(laser_colors)
        bottom_lasers.append((h-1, col))
    
    left_lasers = []
    for row in random.sample(range(1, h-1), random.randint(1, 3)):
        grid[row][0] = random.choice(laser_colors)
        left_lasers.append((row, 0))
    
    right_lasers = []
    for row in random.sample(range(1, h-1), random.randint(1, 3)):
        grid[row][w-1] = random.choice(laser_colors)
        right_lasers.append((row, w-1))
    
    next_cells = set()
    for r, c in top_lasers:
        next_cells.add((r + 1, c))
    for r, c in bottom_lasers:
        next_cells.add((r - 1, c))
    for r, c in left_lasers:
        next_cells.add((r, c + 1))
    for r, c in right_lasers:
        next_cells.add((r, c - 1))
    
    obstacle_colors = [c for c in range(1, 10) if c not in laser_colors]
    for _ in range(random.randint(5, 15)):
        r = random.randint(1, h-2)
        c = random.randint(1, w-2)
        if (r, c) in next_cells:
            continue
        if grid[r][c] != 0:
            continue
        grid[r][c] = random.choice(obstacle_colors)
    
    output = [row[:] for row in grid]
    lasers = []
    for r in range(h):
        for c in range(w):
            if grid[r][c] != 0:
                if r == 0:
                    dir = (1, 0)
                elif r == h-1:
                    dir = (-1, 0)
                elif c == 0:
                    dir = (0, 1)
                elif c == w-1:
                    dir = (0, -1)
                else:
                    continue
                lasers.append((r, c, grid[r][c], dir))
    
    for r, c, color, (dr, dc) in lasers:
        cr, cc = r, c
        for step in range(h):
            nr = cr + dr
            nc = cc + dc
            if nr < 0 or nr >= h or nc < 0 or nc >= w:
                dr, dc = -dr, -dc
                nr = cr + dr
                nc = cc + dc
            if grid[nr][nc] != 0:
                break
            if output[nr][nc] == 0:
                output[nr][nc] = color
            cr, cc = nr, nc
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    original_grid = [list(row) for row in input_grid]
    output_grid = [row[:] for row in original_grid]
    h = len(original_grid)
    w = len(original_grid[0])
    
    lasers = []
    for r in range(h):
        for c in range(w):
            if original_grid[r][c] != 0:
                if r == 0:
                    dir = (1, 0)
                elif r == h-1:
                    dir = (-1, 0)
                elif c == 0:
                    dir = (0, 1)
                elif c == w-1:
                    dir = (0, -1)
                else:
                    continue
                lasers.append((r, c, original_grid[r][c], dir))
    
    for r, c, color, (dr, dc) in lasers:
        cr, cc = r, c
        for step in range(h):
            nr = cr + dr
            nc = cc + dc
            if nr < 0 or nr >= h or nc < 0 or nc >= w:
                dr, dc = -dr, -dc
                nr = cr + dr
                nc = cc + dc
            if original_grid[nr][nc] != 0:
                break
            if output_grid[nr][nc] == 0:
                output_grid[nr][nc] = color
            cr, cc = nr, nc
    
    return tuple(tuple(row) for row in output_grid)
