# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: da3027ef
Difficulty: hard

=== Tags ===
- Compositional reflection
- Color clock
- Take half

=== Description ===
The input grid is a square (15×15 to 30×30) with a central circular arrangement
of colored cells forming a clock face, where colors 1–9 represent hours 1–9
clockwise (starting at 12 o'clock, top center). The clock face is surrounded by
background color 0. A distinct "time hand" — a single line of cells extending
from the grid center to the clock face — is colored with a unique value (not
part of the clock sequence), indicating the current time (e.g., color 3 = 3
o'clock). The grid also contains non-clock elements (e.g., shapes or patterns)
that must be reflected and transformed.  The output grid is generated through
three sequential steps: 1. **Compositional reflection**: Reflect the entire grid
over the axis aligned with the time hand's direction. For example, a time hand
color 3 (3 o'clock, right) requires a vertical reflection (left-right flip);
color 6 (6 o'clock, bottom) requires a horizontal reflection (top-bottom flip).
Reflection applies to all non-background elements while preserving the clock
face symmetry. 2. **Color clock**: Replace each color in the grid with the color
6 positions ahead in the 9-color cycle (half the clock cycle). For example,
color 1 → color 7, color 2 → color 8, color 3 → color 9, color 4 → color 1,
color 5 → color 2, etc. (mod 9, with 0 as background). 3. **Take half**: The
reflection and color transformation are applied, and the output retains all grid
elements, with "take half" referring to the 6-position color shift (half the
cycle length), not spatial reduction. The transformation is deterministic: each
color maps uniquely to its half-cycle counterpart via modular arithmetic.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import math

# Generator for ARC task 422: constructs a square grid with a 9-color "clock" around the center
# and a single radial time hand (a straight contiguous line of the hour's color from center
# to the corresponding clock marker). Then the grid is reflected across the axis perpendicular
# to the hand direction and all non-zero colors are shifted by +6 (mod 9) to produce output.


def _reflect_grid(ingrid, center, axis_x, axis_y):
    """Reflect all non-zero pixels across the line through the center with direction (axis_x, axis_y).
    axis_x and axis_y are given in the (x=col, y=row) coordinate system.

    For axis directions aligned with grid symmetries (vertical, horizontal, main diagonals)
    we perform exact integer transforms; otherwise we use the floating-point reflection and
    round to nearest integer.
    """
    size = len(ingrid)
    out = [[0] * size for _ in range(size)]

    # Exact integer cases first to avoid floating rounding differences
    if axis_x == 0 and axis_y == 0:
        # degenerate
        for r in range(size):
            for c in range(size):
                out[r][c] = ingrid[r][c]
        return out

    # vertical axis (x=constant direction)
    if axis_x == 0:
        for r in range(size):
            for c in range(size):
                v = ingrid[r][c]
                if v == 0:
                    continue
                nc = 2 * center - c
                nr = r
                if 0 <= nr < size and 0 <= nc < size:
                    out[nr][nc] = v
        return out

    # horizontal axis (y=constant direction)
    if axis_y == 0:
        for r in range(size):
            for c in range(size):
                v = ingrid[r][c]
                if v == 0:
                    continue
                nc = c
                nr = 2 * center - r
                if 0 <= nr < size and 0 <= nc < size:
                    out[nr][nc] = v
        return out

    # diagonal axes when |axis_x| == |axis_y|
    if abs(axis_x) == abs(axis_y):
        # if product positive -> axis slope +1 (y = x type through center)
        if axis_x * axis_y > 0:
            # reflect across line y = x through center: swap x and y offsets
            for r in range(size):
                for c in range(size):
                    v = ingrid[r][c]
                    if v == 0:
                        continue
                    # swap row and col around center
                    nc = r
                    nr = c
                    if 0 <= nr < size and 0 <= nc < size:
                        out[nr][nc] = v
            return out
        else:
            # axis slope -1 (y = -x through center): map (x,y)->(-y,-x)
            for r in range(size):
                for c in range(size):
                    v = ingrid[r][c]
                    if v == 0:
                        continue
                    nc = 2 * center - r
                    nr = 2 * center - c
                    if 0 <= nr < size and 0 <= nc < size:
                        out[nr][nc] = v
            return out

    # General case: floating point reflection
    norm = math.hypot(axis_x, axis_y)
    ux = axis_x / norm
    uy = axis_y / norm
    for r in range(size):
        for c in range(size):
            v = ingrid[r][c]
            if v == 0:
                continue
            vx = c - center
            vy = r - center
            dot = vx * ux + vy * uy
            rx = 2 * dot * ux - vx
            ry = 2 * dot * uy - vy
            nc = center + int(round(rx))
            nr = center + int(round(ry))
            if 0 <= nr < size and 0 <= nc < size:
                out[nr][nc] = v
    return out


def generate():
    # size between 15 and 30 (inclusive)
    size = random.randint(15, 30)
    center = size // 2
    grid_in = [[0 for _ in range(size)] for _ in range(size)]

    # Try a few radii to place nine distinct clock markers around the center.
    chosen_positions = None
    chosen_r = None
    for r_try in range(3, max(4, center - 1)):
        positions = []
        for i in range(9):
            angle = -math.pi / 2 + i * (2 * math.pi / 9)  # start at top, go clockwise
            rr = center + int(round(r_try * math.sin(angle)))
            cc = center + int(round(r_try * math.cos(angle)))
            positions.append((rr, cc))
        if len(set(positions)) != 9:
            continue
        # ensure we have at least one marker that lies on an integer-symmetric axis
        axes_ok = []
        for idx, (rr, cc) in enumerate(positions):
            dr = rr - center
            dc = cc - center
            if dr == 0 or dc == 0 or abs(dr) == abs(dc):
                axes_ok.append(idx)
        if axes_ok:
            chosen_positions = positions
            chosen_r = r_try
            break
    # fallback: if not found (very unlikely), force a simple ring using r=3 and small tweaks
    if chosen_positions is None:
        r_try = 3
        pos_set = set()
        positions = []
        for i in range(9):
            angle = -math.pi / 2 + i * (2 * math.pi / 9)
            rr = center + int(round(r_try * math.sin(angle)))
            cc = center + int(round(r_try * math.cos(angle)))
            # tweak if collision
            if (rr, cc) in pos_set:
                rr = min(max(0, rr + (i % 3) - 1), size - 1)
                cc = min(max(0, cc + ((i + 1) % 3) - 1), size - 1)
            positions.append((rr, cc))
            pos_set.add((rr, cc))
        chosen_positions = positions
        chosen_r = r_try

    # place the clock colors 1..9 clockwise starting at top
    for idx, (rr, cc) in enumerate(chosen_positions):
        color = idx + 1
        grid_in[rr][cc] = color

    # choose the hour index for the time hand such that the direction is axis-friendly
    candidate_indices = []
    for idx, (rr, cc) in enumerate(chosen_positions):
        dr = rr - center
        dc = cc - center
        if dr == 0 or dc == 0 or abs(dr) == abs(dc):
            candidate_indices.append(idx)
    if not candidate_indices:
        # extremely unlikely; just use index 0
        H_idx = 0
    else:
        H_idx = random.choice(candidate_indices)

    hand_color = H_idx + 1  # color of the hour marker indicates the time (1..9)
    end_r, end_c = chosen_positions[H_idx]
    dr = end_r - center
    dc = end_c - center
    g = math.gcd(abs(dr), abs(dc))
    if g == 0:
        step_r, step_c = 0, 0
    else:
        step_r, step_c = dr // g, dc // g

    # draw time hand (a contiguous straight line from center to marker) and overwrite center
    for t in range(g + 1):
        rr = center + t * step_r
        cc = center + t * step_c
        grid_in[rr][cc] = hand_color

    # forbidden cells: do not place random shapes on the clock markers or the hand
    forbidden = set(chosen_positions)
    for t in range(g + 1):
        forbidden.add((center + t * step_r, center + t * step_c))

    # Add some random non-clock elements (dots, short lines, small rectangles)
    shapes = random.randint(6, 12)
    for _ in range(shapes):
        kind = random.choice(['dot', 'hline', 'vline', 'rect', 'diag'])
        color = random.randint(1, 9)
        # random attempt limited to avoid infinite loops
        for attempt in range(40):
            if kind == 'dot':
                rr = random.randint(0, size - 1)
                cc = random.randint(0, size - 1)
                if (rr, cc) in forbidden or grid_in[rr][cc] != 0:
                    continue
                grid_in[rr][cc] = color
                break
            elif kind == 'hline':
                length = random.randint(2, min(6, size - 2))
                rr = random.randint(1, size - 2)
                cc0 = random.randint(0, size - length)
                cells = [(rr, cc0 + i) for i in range(length)]
                if any((c in forbidden or grid_in[c[0]][c[1]] != 0) for c in cells):
                    continue
                for (r2, c2) in cells:
                    grid_in[r2][c2] = color
                break
            elif kind == 'vline':
                length = random.randint(2, min(6, size - 2))
                cc = random.randint(1, size - 2)
                rr0 = random.randint(0, size - length)
                cells = [(rr0 + i, cc) for i in range(length)]
                if any((c in forbidden or grid_in[c[0]][c[1]] != 0) for c in cells):
                    continue
                for (r2, c2) in cells:
                    grid_in[r2][c2] = color
                break
            elif kind == 'rect':
                h = random.randint(2, 4)
                w = random.randint(2, 4)
                rr0 = random.randint(0, size - h)
                cc0 = random.randint(0, size - w)
                cells = [(rr0 + dr2, cc0 + dc2) for dr2 in range(h) for dc2 in range(w)]
                if any((c in forbidden or grid_in[c[0]][c[1]] != 0) for c in cells):
                    continue
                for (r2, c2) in cells:
                    grid_in[r2][c2] = color
                break
            elif kind == 'diag':
                length = random.randint(2, min(6, size - 2))
                rr0 = random.randint(0, size - length)
                cc0 = random.randint(0, size - length)
                direction = random.choice([(1, 1), (1, -1)])
                cells = [(rr0 + i * direction[0], cc0 + i * direction[1]) for i in range(length)]
                if any((c in forbidden or grid_in[c[0]][c[1]] != 0) for c in cells):
                    continue
                for (r2, c2) in cells:
                    grid_in[r2][c2] = color
                break

    # Reflection axis is perpendicular to the hand direction. For the reflection we use the axis
    # vector in (x=col, y=row) coordinates: axis = (-dr, dc) (perpendicular to (dc, dr)).
    axis_x = -dr
    axis_y = dc

    reflected = _reflect_grid(grid_in, center, axis_x, axis_y)

    # color shift: advance each non-zero color by 6 positions mod 9 (1..9 cycle)
    grid_out = [[0 for _ in range(size)] for _ in range(size)]
    for r in range(size):
        for c in range(size):
            v = reflected[r][c]
            if v == 0:
                grid_out[r][c] = 0
            else:
                grid_out[r][c] = ((v - 1 + 6) % 9) + 1

    return {'input': grid_in, 'output': grid_out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import math


def _reflect_grid(ingrid, center, axis_x, axis_y):
    size = len(ingrid)
    out = [[0] * size for _ in range(size)]

    if axis_x == 0 and axis_y == 0:
        for r in range(size):
            for c in range(size):
                out[r][c] = ingrid[r][c]
        return out

    if axis_x == 0:
        for r in range(size):
            for c in range(size):
                v = ingrid[r][c]
                if v == 0:
                    continue
                nc = 2 * center - c
                nr = r
                if 0 <= nr < size and 0 <= nc < size:
                    out[nr][nc] = v
        return out

    if axis_y == 0:
        for r in range(size):
            for c in range(size):
                v = ingrid[r][c]
                if v == 0:
                    continue
                nc = c
                nr = 2 * center - r
                if 0 <= nr < size and 0 <= nc < size:
                    out[nr][nc] = v
        return out

    if abs(axis_x) == abs(axis_y):
        if axis_x * axis_y > 0:
            for r in range(size):
                for c in range(size):
                    v = ingrid[r][c]
                    if v == 0:
                        continue
                    nc = r
                    nr = c
                    if 0 <= nr < size and 0 <= nc < size:
                        out[nr][nc] = v
            return out
        else:
            for r in range(size):
                for c in range(size):
                    v = ingrid[r][c]
                    if v == 0:
                        continue
                    nc = 2 * center - r
                    nr = 2 * center - c
                    if 0 <= nr < size and 0 <= nc < size:
                        out[nr][nc] = v
            return out

    # General floating-point reflection
    norm = math.hypot(axis_x, axis_y)
    ux = axis_x / norm
    uy = axis_y / norm
    for r in range(size):
        for c in range(size):
            v = ingrid[r][c]
            if v == 0:
                continue
            vx = c - center
            vy = r - center
            dot = vx * ux + vy * uy
            rx = 2 * dot * ux - vx
            ry = 2 * dot * uy - vy
            nc = center + int(round(rx))
            nr = center + int(round(ry))
            if 0 <= nr < size and 0 <= nc < size:
                out[nr][nc] = v
    return out


def p(input_grid):
    grid_in = [list(row) for row in input_grid]
    size = len(grid_in)
    center = size // 2

    # Find the hand color by inspecting the center cell (generator draws the hand through the center)
    hand_color = grid_in[center][center]

    end_r = None
    end_c = None

    if hand_color != 0:
        # Look among the 8 immediate neighbors for the contiguous hand direction
        found = False
        for dr0 in (-1, 0, 1):
            for dc0 in (-1, 0, 1):
                if dr0 == 0 and dc0 == 0:
                    continue
                r1 = center + dr0
                c1 = center + dc0
                if not (0 <= r1 < size and 0 <= c1 < size):
                    continue
                if grid_in[r1][c1] != hand_color:
                    continue
                # extend along this direction
                step_r, step_c = dr0, dc0
                rr, cc = r1, c1
                last_r, last_c = center, center
                while 0 <= rr < size and 0 <= cc < size and grid_in[rr][cc] == hand_color:
                    last_r, last_c = rr, cc
                    rr += step_r
                    cc += step_c
                end_r, end_c = last_r, last_c
                found = True
                break
            if found:
                break
        if not found:
            # fallback to the more general search if immediate neighbor test fails
            coords = [(r, c) for r in range(size) for c in range(size) if grid_in[r][c] == hand_color]
            coords.sort(key=lambda rc: (rc[0] - center) ** 2 + (rc[1] - center) ** 2, reverse=True)
            for (r, c) in coords:
                dr = r - center
                dc = c - center
                if dr == 0 and dc == 0:
                    continue
                g = math.gcd(abs(dr), abs(dc))
                if g == 0:
                    continue
                step_r = dr // g
                step_c = dc // g
                ok = True
                for t in range(g + 1):
                    rr = center + t * step_r
                    cc = center + t * step_c
                    if not (0 <= rr < size and 0 <= cc < size and grid_in[rr][cc] == hand_color):
                        ok = False
                        break
                if ok:
                    end_r, end_c = r, c
                    break

    else:
        # no color at center: try to find any straight contiguous line starting from center
        candidates = []
        for r in range(size):
            for c in range(size):
                v = grid_in[r][c]
                if v == 0:
                    continue
                dr = r - center
                dc = c - center
                if dr == 0 and dc == 0:
                    continue
                g = math.gcd(abs(dr), abs(dc))
                if g == 0:
                    continue
                step_r = dr // g
                step_c = dc // g
                ok = True
                for t in range(g + 1):
                    rr = center + t * step_r
                    cc = center + t * step_c
                    if not (0 <= rr < size and 0 <= cc < size and grid_in[rr][cc] == v):
                        ok = False
                        break
                if ok:
                    candidates.append((g, r, c, v))
        if not candidates:
            return grid_in
        candidates.sort(reverse=True)
        _, end_r, end_c, hand_color = candidates[0]

    if end_r is None:
        # should not happen with the generator, but return original grid to avoid crash
        return grid_in

    dr = end_r - center
    dc = end_c - center
    # axis perpendicular to the hand (in x=col, y=row coordinates) is (-dr, dc)
    axis_x = -dr
    axis_y = dc

    reflected = _reflect_grid(grid_in, center, axis_x, axis_y)

    out = [[0] * size for _ in range(size)]
    for r in range(size):
        for c in range(size):
            v = reflected[r][c]
            if v == 0:
                out[r][c] = 0
            else:
                out[r][c] = ((v - 1 + 6) % 9) + 1
    return out

