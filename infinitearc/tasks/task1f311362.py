# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 1f311362
Difficulty: very hard

=== Tags ===
- Mirror twins
- Binary rule overlay

=== Description ===
Task: Mirror Twins with Binary Overlay  Description: Input grids are rectangular
with even width, divided vertically into left and right mirror halves. The left
half contains a pattern of colors, while the right half is initially a mirror of
the left. A distinct "mask color" appears exclusively in the left half,
indicating that the corresponding right half cell should have its color swapped
with a specific paired color (e.g., if a cell has color X in the left, the
mirrored right cell should have color Y, and vice versa). The mask color itself
is not subject to swapping. The output grid corrects the right half by applying
this color swap where the mask color is present in the left half.  The task
requires identifying the mirror line, detecting the mask color, inferring the
color pair for swapping (based on input-output examples), and applying the
transformation to generate the output. Background cells (color 0) do not
participate in the swap. This complex transformation demands sequential
reasoning across multiple visual features, making it very challenging to deduce
the rule from limited examples.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_color

def generate():
    w = random.choice([i for i in range(2, 31) if i % 2 == 0])
    h = random.randint(1, 30)
    mask_color = random_color(exclude=[0])
    pair_color = random_color(exclude=[0, mask_color])
    
    left = [[0] * (w//2) for _ in range(h)]
    left[0][0] = mask_color
    num_mask = random.randint(1, (w//2)*h)
    for _ in range(num_mask - 1):
        r = random.randint(0, h-1)
        c = random.randint(0, w//2-1)
        left[r][c] = mask_color
    
    if w//2 > 1:
        left[0][1] = pair_color
    else:
        if h > 1:
            left[1][0] = pair_color
    
    input_grid = []
    for row in left:
        input_grid.append(row + row[::-1])
    
    output_grid = []
    for row in left:
        right = row[::-1]
        new_right = []
        for i in range(len(right)):
            if row[w//2 - 1 - i] == mask_color:
                new_right.append(pair_color)
            else:
                new_right.append(right[i])
        output_grid.append(row + new_right)
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    w = len(input_grid[0])
    h = len(input_grid)
    mirror_col = w // 2
    
    # Find mask_color (first non-zero in left half, which is guaranteed to be mask_color)
    mask_color = 0
    for r in range(h):
        for c in range(mirror_col):
            if input_grid[r][c] != 0:
                mask_color = input_grid[r][c]
                break
        if mask_color != 0:
            break
    
    # Find pair_color (first non-zero different from mask_color)
    pair_color = 0
    for r in range(h):
        for c in range(mirror_col):
            if input_grid[r][c] != 0 and input_grid[r][c] != mask_color:
                pair_color = input_grid[r][c]
                break
        if pair_color != 0:
            break
    
    # If pair_color wasn't found, default to 1
    if pair_color == 0:
        pair_color = 1
    
    output_grid = []
    for r in range(h):
        new_row = []
        for c in range(w):
            if c < mirror_col:
                new_row.append(input_grid[r][c])
            else:
                left_c = w - 1 - c
                if input_grid[r][left_c] == mask_color:
                    new_row.append(pair_color)
                else:
                    new_row.append(input_grid[r][c])
        output_grid.append(new_row)
    return output_grid
