# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 8fed5555
Difficulty: insane

=== Tags ===
- Loopless path

=== Description ===
Input grids consist of a single connected path formed by a distinct color (e.g.,
color 1) on a background of another color (e.g., color 0). The path may contain
one or more loops where the sequence of connected cells intersects itself,
creating closed cycles. The output grid must transform the input path into a
loopless path by removing the topmost-leftmost cell from each loop. A loop is
defined as a sequence of cells where a cell is revisited during traversal (e.g.,
forming a closed shape). For each loop detected, the cell with the smallest row
index (topmost) is selected; if multiple cells share this row, the one with the
smallest column index (leftmost) is removed. This process is repeated for all
loops until no cycles remain, resulting in a single continuous path with no
self-intersections. The background and all non-loop cells remain unchanged, and
the transformation must maintain connectivity of the path after loop removal.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    start_r = random.randint(1, height - 2)
    start_c = random.randint(1, width - 2)
    loop_size = random.randint(2, 5)
    path = []
    for i in range(loop_size):
        path.append((start_r, start_c + i))
    for i in range(1, loop_size):
        path.append((start_r + i, start_c + loop_size - 1))
    for i in range(loop_size - 1):
        path.append((start_r + loop_size - 1, start_c + loop_size - 2 - i))
    for i in range(1, loop_size - 1):
        path.append((start_r + loop_size - 1 - i, start_c))
    input_grid = [[0] * width for _ in range(height)]
    for r, c in path:
        if 0 <= r < height and 0 <= c < width:
            input_grid[r][c] = 1
    output_grid = [row[:] for row in input_grid]
    output_grid[start_r][start_c] = 0
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 1:
                output_grid = [list(row)[:] for row in input_grid]
                output_grid[r][c] = 0
                return output_grid
    return input_grid
