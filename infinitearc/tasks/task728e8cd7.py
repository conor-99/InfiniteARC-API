# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 728e8cd7
Difficulty: hard

=== Tags ===
- Color palette
- Measure distance from side
- Color matching
- Sort rows by criteria

=== Description ===
The input grid is a 2D array of colors (values 0-9). For each cell, compute its
minimum distance to any grid edge (top, bottom, left, or right). If the cell's
original color matches this distance value, retain the color; otherwise, replace
it with color 9. After this transformation, sort the rows of the grid in
descending order based on the number of cells in each row that retained their
original color (i.e., cells where color equaled the distance value). Rows with
more matching cells appear first in the output. This task requires synthesizing
distance calculation, color-based conditional replacement, and row sorting based
on a derived metricâ€”all while avoiding direct numerical operations like
summation or parity checks.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    h = random.randint(1, 30)
    w = random.randint(1, 30)
    input_grid = [[0] * w for _ in range(h)]
    for r in range(h):
        for c in range(w):
            d = min(r, h - 1 - r, c, w - 1 - c)
            if d > 9:
                input_grid[r][c] = random.randint(0, 9)
            else:
                if random.random() > 0.5:
                    input_grid[r][c] = d
                else:
                    colors = [x for x in range(10) if x != d]
                    input_grid[r][c] = random.choice(colors)
    output_grid = [[0] * w for _ in range(h)]
    row_counts = [0] * h
    for r in range(h):
        for c in range(w):
            d = min(r, h - 1 - r, c, w - 1 - c)
            if input_grid[r][c] == d:
                output_grid[r][c] = input_grid[r][c]
                row_counts[r] += 1
            else:
                output_grid[r][c] = 9
    sorted_indices = sorted(range(h), key=lambda i: row_counts[i], reverse=True)
    output_grid = [output_grid[i] for i in sorted_indices]
    if input_grid == output_grid:
        return generate()
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    h = len(input_grid)
    w = len(input_grid[0])
    distances = [[0] * w for _ in range(h)]
    for r in range(h):
        for c in range(w):
            distances[r][c] = min(r, h - 1 - r, c, w - 1 - c)
    transformed = [[0] * w for _ in range(h)]
    row_counts = [0] * h
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] == distances[r][c]:
                transformed[r][c] = input_grid[r][c]
                row_counts[r] += 1
            else:
                transformed[r][c] = 9
    sorted_indices = sorted(range(h), key=lambda i: row_counts[i], reverse=True)
    return [transformed[i] for i in sorted_indices]
