# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: a4bc6733
Difficulty: insane

=== Tags ===
- Flow with decay
- Multi agent path weaving
- Diagonal weaving
- Color by distance to center

=== Description ===
Diagonal Path Weave with Center-Dependent Coloring  Input grids feature a 20×20
grid with multiple distinct colored agents positioned along the perimeter edges
(top, bottom, left, right). Each agent moves diagonally toward the center at a
45° angle, with starting directions determined by their edge position (e.g.,
top-edge agents move down-right, left-edge agents move down-right). Agents leave
continuous path traces as they move, but must weave around other paths to avoid
collisions—adjusting direction by one orthogonal step when paths would
intersect. The grid contains no obstacles; weaving occurs solely through path
adjustments.  Output grids display all agent paths as continuous diagonal lines
with precise weaving to maintain non-overlapping trajectories. Each cell along a
path is colored based on its Manhattan distance to the grid's center (distance =
|row - center_row| + |column - center_column|), using a predefined color
gradient. Cells closest to the center use a distinct color (e.g., bright blue),
with colors gradually shifting outward toward the grid edges (e.g., fading to
gray). This creates a visible "decay" effect where paths appear to transition
toward the central color as they move inward. The coloring is position-based,
not path-based, meaning all paths at the same distance from the center share
identical colors regardless of their origin.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    grid_size = 20
    center = grid_size // 2
    input_grid = [[0] * grid_size for _ in range(grid_size)]
    output_grid = [[0] * grid_size for _ in range(grid_size)]
    
    num_agents = random.randint(3, 9)
    colors = random.sample(range(1, 10), num_agents)
    
    top_positions = random.sample(range(1, grid_size-1), num_agents // 2)
    for c, color in zip(top_positions, colors[:num_agents//2]):
        input_grid[0][c] = color
    
    left_positions = random.sample(range(1, grid_size-1), num_agents - num_agents//2)
    for r, color in zip(left_positions, colors[num_agents//2:]):
        input_grid[r][0] = color
    
    all_paths = set()
    for r in range(grid_size):
        for c in range(grid_size):
            if input_grid[r][c] > 0:
                if r == 0:
                    dr, dc = 1, 1
                elif r == grid_size-1:
                    dr, dc = -1, 1
                elif c == 0:
                    dr, dc = 1, 1
                else:
                    dr, dc = 1, -1
                cur_r, cur_c = r, c
                while 0 <= cur_r < grid_size and 0 <= cur_c < grid_size:
                    all_paths.add((cur_r, cur_c))
                    cur_r += dr
                    cur_c += dc
    
    for (r, c) in all_paths:
        dist = abs(r - center) + abs(c - center)
        color_val = (dist * 9) // grid_size
        output_grid[r][c] = color_val
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid_size = len(input_grid)
    center = grid_size // 2
    output = [[0] * grid_size for _ in range(grid_size)]
    
    for r in range(grid_size):
        for c in range(grid_size):
            if input_grid[r][c] > 0:
                if r == 0:
                    dr, dc = 1, 1
                elif r == grid_size-1:
                    dr, dc = -1, 1
                elif c == 0:
                    dr, dc = 1, 1
                else:
                    dr, dc = 1, -1
                cur_r, cur_c = r, c
                while 0 <= cur_r < grid_size and 0 <= cur_c < grid_size:
                    dist = abs(cur_r - center) + abs(cur_c - center)
                    color_val = (dist * 9) // grid_size
                    output[cur_r][cur_c] = color_val
                    cur_r += dr
                    cur_c += dc
    return output
