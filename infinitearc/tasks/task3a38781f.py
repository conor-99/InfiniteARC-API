# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 3a38781f
Difficulty: easy

=== Tags ===
- Border detection
- Remove singletons

=== Description ===
The task involves transforming an input grid into an output grid by identifying
and removing isolated cells (singletons) that lack adjacent cells of the same
color. For each cell in the input grid, if it is not connected (via horizontal
or vertical adjacency) to at least one other cell of the same color, it is
considered a singleton and is replaced with the background color (0) in the
output. All other cells—those belonging to connected regions of two or more
cells of the same color—remain unchanged. The output grid thus retains all
contiguous shapes while eliminating single, disconnected cells, making the task
visually intuitive for an "easy" difficulty.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    w = random.randint(5, 15)
    h = random.randint(5, 15)
    grid = common.grid(w, h, 0)
    colors = list(range(1, 10))
    
    regions = random.randint(2, 3)
    for _ in range(regions):
        color = random.choice(colors)
        r = random.randint(0, h-2)
        c = random.randint(0, w-2)
        grid[r][c] = color
        grid[r][c+1] = color
        grid[r+1][c] = color
        grid[r+1][c+1] = color
    
    singleton_color = 4
    num_singletons = random.randint(3, 5)
    for _ in range(num_singletons):
        placed = False
        for _ in range(100):
            r = random.randint(0, h-1)
            c = random.randint(0, w-1)
            if grid[r][c] != 0:
                continue
            if (r > 0 and grid[r-1][c] == singleton_color) or \
               (r < h-1 and grid[r+1][c] == singleton_color) or \
               (c > 0 and grid[r][c-1] == singleton_color) or \
               (c < w-1 and grid[r][c+1] == singleton_color):
                continue
            grid[r][c] = singleton_color
            placed = True
            break
        if not placed:
            grid[0][0] = singleton_color
    
    output = [row[:] for row in grid]
    for r in range(h):
        for c in range(w):
            if output[r][c] == 0:
                continue
            color = output[r][c]
            has_neighbor = False
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < h and 0 <= nc < w and output[nr][nc] == color:
                    has_neighbor = True
                    break
            if not has_neighbor:
                output[r][c] = 0
    
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    h = len(input_grid)
    w = len(input_grid[0])
    output = [row[:] for row in input_grid]
    for r in range(h):
        for c in range(w):
            if output[r][c] == 0:
                continue
            color = output[r][c]
            has_neighbor = False
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < h and 0 <= nc < w and output[nr][nc] == color:
                    has_neighbor = True
                    break
            if not has_neighbor:
                output[r][c] = 0
    return output
