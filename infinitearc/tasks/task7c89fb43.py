# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 7c89fb43
Difficulty: easy

=== Tags ===
- Proximity guessing
- Mark centroid
- Associate images to colors
- Crop

=== Description ===
The input grids contain a single connected region of non-zero colors on a zero
background. The task requires identifying this region, computing its centroid
(average position of all pixels in the region), cropping the grid to the minimal
bounding box containing the region, and marking the centroid pixel with a fixed
color (e.g., color 5), while preserving the original region color elsewhere in
the cropped grid. The output grid is the cropped region with the centroid
marked.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    S = common.randint(3, 15)
    width = common.randint(1, 30)
    height = common.randint(1, 30)
    while width * height < S:
        width = common.randint(1, 30)
        height = common.randint(1, 30)
    region_pixels = common.continuous_creature(S, width, height)
    colors = [1, 2, 3, 4, 6, 7, 8, 9]
    region_color = common.choice(colors)
    input_grid = common.grid(width, height, 0)
    for r, c in region_pixels:
        input_grid[r][c] = region_color
    sum_r = sum(r for r, c in region_pixels)
    sum_c = sum(c for r, c in region_pixels)
    centroid_r = round(sum_r / S)
    centroid_c = round(sum_c / S)
    min_r = min(r for r, c in region_pixels)
    max_r = max(r for r, c in region_pixels)
    min_c = min(c for r, c in region_pixels)
    max_c = max(c for r, c in region_pixels)
    out_height = max_r - min_r + 1
    out_width = max_c - min_c + 1
    output_grid = common.grid(out_width, out_height, region_color)
    cx = centroid_r - min_r
    cy = centroid_c - min_c
    if 0 <= cx < out_height and 0 <= cy < out_width:
        output_grid[cx][cy] = 5
    else:
        output_grid[0][0] = 5
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    pixels = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                pixels.append((r, c))
    if not pixels:
        return common.grid(1, 1, 0)
    S = len(pixels)
    sum_r = sum(r for r, c in pixels)
    sum_c = sum(c for r, c in pixels)
    centroid_r = round(sum_r / S)
    centroid_c = round(sum_c / S)
    min_r = min(r for r, c in pixels)
    max_r = max(r for r, c in pixels)
    min_c = min(c for r, c in pixels)
    max_c = max(c for r, c in pixels)
    out_height = max_r - min_r + 1
    out_width = max_c - min_c + 1
    region_color = input_grid[pixels[0][0]][pixels[0][1]]
    output_grid = common.grid(out_width, out_height, region_color)
    cx = centroid_r - min_r
    cy = centroid_c - min_c
    if 0 <= cx < out_height and 0 <= cy < out_width:
        output_grid[cx][cy] = 5
    else:
        output_grid[0][0] = 5
    return output_grid
