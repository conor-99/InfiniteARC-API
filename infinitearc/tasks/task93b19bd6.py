# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 93b19bd6
Difficulty: very hard

=== Tags ===
- Color clock
- Alternating rule composition
- Color space mapping
- Multi stage rule chain
- Fill between lines
- Draw pattern from point

=== Description ===
**Task Description: Color Clock Interlacing**    **Input Grids:**   Each input
grid features a background of color 0 (empty), overlaid with horizontal and
vertical lines of distinct colors (e.g., horizontal lines in color 1, vertical
lines in color 2) that form a grid of rectangular regions. Within these regions,
some cells contain seed colors (3–9), and exactly one cell contains a starting
point marker (color 7). The lines are continuous, non-overlapping, and intersect
only at grid points, partitioning the grid into distinct, non-adjacent regions.
**Transformation Rules:**   1. **Color Space Mapping:**      All seed colors
(3–9) in the input undergo a cyclic color space mapping:      `3 → 4 → 5 → 6 → 7
→ 8 → 9 → 3 → ...`      (Each color increments by 1, wrapping at 9).    2.
**Color Clock Initialization:**      The starting point (color 7) defines the
initial color of the *color clock*, which cycles through `[7, 8, 9]`
sequentially for the filling process.    3. **Alternating Rule Composition:**
Starting from the seed cell (now mapped to a new color), fill the region in a
spiral pattern that alternates direction based on step parity:      - **Even
steps:** Move horizontally (left/right) along the current row.      - **Odd
steps:** Move vertically (up/down) along the current column.      The spiral
direction rotates 90° clockwise after each full loop (e.g., right → up → left →
down → right).    4. **Multi-Stage Rule Chain:**      After filling the initial
region, the process cascades to adjacent regions (connected via line
intersections). The *color clock* continues from the last color used in the
previous region, and the alternating direction rule resets per region. The
entire grid is filled in a chain reaction, with no gaps or overlaps.    5.
**Fill Between Lines:**      The filling occurs *between* the line boundaries
(colors 1 and 2), leaving the lines visible. Cells occupied by lines are skipped
and retain their original colors.    **Output Grids:**   The output grid
preserves all input lines (colors 1 and 2), background (color 0), and seed color
mappings. The regions are filled with the color clock sequence, alternating
directions, and cascading across connected regions. The pattern begins at the
starting point and propagates outward, creating a visually cohesive, non-
repeating spiral of colors that adheres strictly to the multi-stage rule chain.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Grid size
    width = random.randint(7, 20)
    height = random.randint(7, 20)
    input_grid = [[0 for _ in range(width)] for _ in range(height)]

    def pick_positions(limit, count):
        # choose 'count' positions in [1, limit-2] with at least one empty row/col between lines
        if count <= 0:
            return []
        candidates = list(range(1, limit - 1))
        if not candidates:
            return []
        # try random sampling with spacing constraint
        for _ in range(200):
            if len(candidates) < count:
                break
            pos = sorted(random.sample(candidates, count))
            ok = True
            for i in range(len(pos) - 1):
                if pos[i + 1] - pos[i] < 2:
                    ok = False
                    break
            if ok:
                return pos
        # fallback: greedy evenly spaced placement
        pos = []
        step = max(2, (limit - 1) // (count + 1))
        cur = 1 + step
        while len(pos) < count and cur < limit - 1:
            pos.append(cur)
            cur += step
        if len(pos) < count:
            # last resort: place with stride 2
            pos = []
            cur = 1
            while len(pos) < count and cur < limit - 1:
                pos.append(cur)
                cur += 2
        return pos[:count]

    # choose numbers of horizontal and vertical lines (at least one of each)
    hr_max = min(3, max(1, (height - 1) // 3))
    vc_max = min(3, max(1, (width - 1) // 3))
    hr_count = random.randint(1, hr_max)
    vc_count = random.randint(1, vc_max)

    hor_lines = pick_positions(height, hr_count)
    ver_lines = pick_positions(width, vc_count)

    # draw horizontal (1) then vertical (2) lines (vertical overwrites intersections)
    for r in hor_lines:
        for c in range(width):
            input_grid[r][c] = 1
    for c in ver_lines:
        for r in range(height):
            input_grid[r][c] = 2

    # build row and column segments (regions between lines)
    hor_lines_sorted = sorted(hor_lines)
    ver_lines_sorted = sorted(ver_lines)

    row_segments = []
    prev = -1
    for r in hor_lines_sorted:
        top = prev + 1
        bottom = r - 1
        if bottom >= top:
            row_segments.append((top, bottom))
        prev = r
    top = prev + 1
    bottom = height - 1
    if bottom >= top:
        row_segments.append((top, bottom))

    col_segments = []
    prev = -1
    for c in ver_lines_sorted:
        left = prev + 1
        right = c - 1
        if right >= left:
            col_segments.append((left, right))
        prev = c
    left = prev + 1
    right = width - 1
    if right >= left:
        col_segments.append((left, right))

    # collect regions and map coordinates to region id
    region_cells = {}
    coord_to_region = {}
    region_id = 0
    for ri, (rtop, rbot) in enumerate(row_segments):
        for ci, (cleft, cright) in enumerate(col_segments):
            cells = []
            for r in range(rtop, rbot + 1):
                for c in range(cleft, cright + 1):
                    # should be interior cell (not a line)
                    if r in hor_lines_sorted or c in ver_lines_sorted:
                        continue
                    cells.append((r, c))
            if not cells:
                # skip empty region
                continue
            region_cells[region_id] = {'rows': (rtop, rbot), 'cols': (cleft, cright), 'cells': cells}
            for (r, c) in cells:
                coord_to_region[(r, c)] = region_id
            region_id += 1

    if not region_cells:
        # degenerate, retry
        return generate()

    # choose a start region that has at least two interior cells so we can place both start and a seed
    multi_cell_regions = [rid for rid, info in region_cells.items() if len(info['cells']) >= 2]
    if multi_cell_regions:
        start_region = random.choice(multi_cell_regions)
    else:
        start_region = random.choice(list(region_cells.keys()))

    # place the single start marker (color 7)
    start_cells = region_cells[start_region]['cells']
    start_cell = random.choice(start_cells)
    input_grid[start_cell[0]][start_cell[1]] = 7

    # place exactly one seed (color in 3..9 except 7) per region if possible
    seed_colors = [3, 4, 5, 6, 8, 9]
    region_seed = {}
    for rid, info in region_cells.items():
        choices = [p for p in info['cells'] if p != start_cell]
        if not choices:
            # if only cell in this region is the start, we will not place a seed here
            continue
        sc = random.choice(choices)
        color = random.choice(seed_colors)
        input_grid[sc[0]][sc[1]] = color
        region_seed[rid] = sc

    # create output grid as a copy and map seed colors (3..9 -> next, 9 -> 3)
    output_grid = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width):
            val = input_grid[r][c]
            if 3 <= val <= 9 and val != 7:
                output_grid[r][c] = 3 + ((val - 3 + 1) % 7)

    # build adjacency graph between regions via line intersections
    adjacency = {rid: set() for rid in region_cells.keys()}
    for hr in hor_lines_sorted:
        for vc in ver_lines_sorted:
            neighbors = set()
            for dr in (-1, 1):
                for dc in (-1, 1):
                    rr = hr + dr
                    cc = vc + dc
                    if rr < 0 or rr >= height or cc < 0 or cc >= width:
                        continue
                    if rr in hor_lines_sorted or cc in ver_lines_sorted:
                        continue
                    rid = coord_to_region.get((rr, cc))
                    if rid is not None:
                        neighbors.add(rid)
            for u in neighbors:
                for v in neighbors:
                    if u != v:
                        adjacency[u].add(v)
                        adjacency[v].add(u)

    # BFS over regions starting from start_region, if disconnected continue with remaining regions
    from collections import deque
    visited = set()
    order = []
    queue = deque([start_region])
    visited.add(start_region)
    while queue:
        cur = queue.popleft()
        order.append(cur)
        for nb in sorted(adjacency[cur]):
            if nb not in visited:
                visited.add(nb)
                queue.append(nb)
    # if some regions are disconnected, append them in arbitrary order
    for rid in sorted(region_cells.keys()):
        if rid not in visited:
            # start a BFS from this disconnected component
            q = deque([rid])
            visited.add(rid)
            while q:
                cur = q.popleft()
                order.append(cur)
                for nb in sorted(adjacency[cur]):
                    if nb not in visited:
                        visited.add(nb)
                        q.append(nb)

    # spiral generator anchored at seed for each region
    def spiral_from_anchor(top, bottom, left, right, anchor, excluded):
        ar, ac = anchor
        path = []
        seen = set()
        max_radius = max(ar - top, bottom - ar, ac - left, right - ac)
        for radius in range(1, max_radius + 1):
            # top edge
            r = ar - radius
            for c in range(ac - radius, ac + radius + 1):
                if r < top or r > bottom or c < left or c > right:
                    continue
                if (r, c) in seen:
                    continue
                seen.add((r, c))
                if (r, c) in excluded:
                    continue
                path.append((r, c))
            # right edge
            c = ac + radius
            for r in range(ar - radius + 1, ar + radius + 1):
                if r < top or r > bottom or c < left or c > right:
                    continue
                if (r, c) in seen:
                    continue
                seen.add((r, c))
                if (r, c) in excluded:
                    continue
                path.append((r, c))
            # bottom edge
            r = ar + radius
            for c in range(ac + radius - 1, ac - radius - 1, -1):
                if r < top or r > bottom or c < left or c > right:
                    continue
                if (r, c) in seen:
                    continue
                seen.add((r, c))
                if (r, c) in excluded:
                    continue
                path.append((r, c))
            # left edge
            c = ac - radius
            for r in range(ar + radius - 1, ar - radius, -1):
                if r < top or r > bottom or c < left or c > right:
                    continue
                if (r, c) in seen:
                    continue
                seen.add((r, c))
                if (r, c) in excluded:
                    continue
                path.append((r, c))
        return path

    # color clock
    color_cycle = [7, 8, 9]
    color_idx = 0  # starts at 7 (the starting marker is 7)

    # ensure color_idx starts at the starting marker value (7)
    # place seeds set for exclusion during fill
    seeds_set = set(region_seed.values())

    # fill regions in order
    for rid in order:
        info = region_cells[rid]
        top, bottom = info['rows']
        left, right = info['cols']
        # anchor: use the seed if present, otherwise pick the top-left interior cell
        anchor = region_seed.get(rid)
        if anchor is None:
            # pick first available interior cell that is not a line
            anchor = info['cells'][0]
        excluded = set([anchor]) | seeds_set
        path = spiral_from_anchor(top, bottom, left, right, anchor, excluded)
        for (r, c) in path:
            # skip lines and seeds
            if r in hor_lines_sorted or c in ver_lines_sorted:
                continue
            if (r, c) in seeds_set:
                continue
            output_grid[r][c] = color_cycle[color_idx % len(color_cycle)]
            color_idx = (color_idx + 1) % len(color_cycle)

    return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height else 0

    # detect horizontal and vertical lines: rows/cols where every cell is either 1 or 2
    hor_lines = [r for r in range(height) if all(grid[r][c] in (1, 2) for c in range(width))]
    ver_lines = [c for c in range(width) if all(grid[r][c] in (1, 2) for r in range(height))]
    hor_lines_sorted = sorted(hor_lines)
    ver_lines_sorted = sorted(ver_lines)

    # build row and column segments between lines
    row_segments = []
    prev = -1
    for r in hor_lines_sorted:
        top = prev + 1
        bottom = r - 1
        if bottom >= top:
            row_segments.append((top, bottom))
        prev = r
    top = prev + 1
    bottom = height - 1
    if bottom >= top:
        row_segments.append((top, bottom))

    col_segments = []
    prev = -1
    for c in ver_lines_sorted:
        left = prev + 1
        right = c - 1
        if right >= left:
            col_segments.append((left, right))
        prev = c
    left = prev + 1
    right = width - 1
    if right >= left:
        col_segments.append((left, right))

    # map interior coordinates to region ids and collect region cells
    region_cells = {}
    coord_to_region = {}
    region_id = 0
    for rtop, rbot in row_segments:
        for cleft, cright in col_segments:
            cells = []
            for r in range(rtop, rbot + 1):
                for c in range(cleft, cright + 1):
                    if r in hor_lines_sorted or c in ver_lines_sorted:
                        continue
                    cells.append((r, c))
            if not cells:
                continue
            region_cells[region_id] = {'rows': (rtop, rbot), 'cols': (cleft, cright), 'cells': cells}
            for (r, c) in cells:
                coord_to_region[(r, c)] = region_id
            region_id += 1

    # find start cell (color 7)
    start_cell = None
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 7:
                start_cell = (r, c)
                break
        if start_cell:
            break
    if start_cell is None:
        # fallback: choose first interior cell
        for rid, info in region_cells.items():
            if info['cells']:
                start_cell = info['cells'][0]
                break

    # find starting region
    start_region = coord_to_region.get(start_cell)
    if start_region is None:
        # fallback to first region
        start_region = next(iter(region_cells.keys())) if region_cells else None

    # find a seed cell in each region (value in 3..9 except 7)
    region_seed = {}
    for rid, info in region_cells.items():
        seed = None
        for (r, c) in info['cells']:
            val = grid[r][c]
            if 3 <= val <= 9 and val != 7:
                seed = (r, c)
                break
        if seed is None:
            # no explicit seed found; pick top-left interior as anchor
            seed = info['cells'][0]
        region_seed[rid] = seed

    # create output grid and apply seed color mapping (3..9 -> next, 9 -> 3)
    output = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            val = grid[r][c]
            if 3 <= val <= 9 and val != 7:
                output[r][c] = 3 + ((val - 3 + 1) % 7)

    # build adjacency via intersections
    adjacency = {rid: set() for rid in region_cells.keys()}
    for hr in hor_lines_sorted:
        for vc in ver_lines_sorted:
            neighbors = set()
            for dr in (-1, 1):
                for dc in (-1, 1):
                    rr = hr + dr
                    cc = vc + dc
                    if rr < 0 or rr >= height or cc < 0 or cc >= width:
                        continue
                    if rr in hor_lines_sorted or cc in ver_lines_sorted:
                        continue
                    rid = coord_to_region.get((rr, cc))
                    if rid is not None:
                        neighbors.add(rid)
            for u in neighbors:
                for v in neighbors:
                    if u != v:
                        adjacency[u].add(v)
                        adjacency[v].add(u)

    # BFS order of regions starting from start_region, if disconnected continue with remaining
    from collections import deque
    order = []
    if start_region is not None:
        visited = set([start_region])
        q = deque([start_region])
        while q:
            cur = q.popleft()
            order.append(cur)
            for nb in sorted(adjacency[cur]):
                if nb not in visited:
                    visited.add(nb)
                    q.append(nb)
        for rid in sorted(region_cells.keys()):
            if rid not in visited:
                # traverse this component as well
                visited.add(rid)
                q = deque([rid])
                while q:
                    cur = q.popleft()
                    order.append(cur)
                    for nb in sorted(adjacency[cur]):
                        if nb not in visited:
                            visited.add(nb)
                            q.append(nb)
    else:
        order = sorted(region_cells.keys())

    # spiral generator
    def spiral_from_anchor(top, bottom, left, right, anchor, excluded):
        ar, ac = anchor
        path = []
        seen = set()
        max_radius = max(ar - top, bottom - ar, ac - left, right - ac)
        for radius in range(1, max_radius + 1):
            r = ar - radius
            for c in range(ac - radius, ac + radius + 1):
                if r < top or r > bottom or c < left or c > right:
                    continue
                if (r, c) in seen:
                    continue
                seen.add((r, c))
                if (r, c) in excluded:
                    continue
                path.append((r, c))
            c = ac + radius
            for r in range(ar - radius + 1, ar + radius + 1):
                if r < top or r > bottom or c < left or c > right:
                    continue
                if (r, c) in seen:
                    continue
                seen.add((r, c))
                if (r, c) in excluded:
                    continue
                path.append((r, c))
            r = ar + radius
            for c in range(ac + radius - 1, ac - radius - 1, -1):
                if r < top or r > bottom or c < left or c > right:
                    continue
                if (r, c) in seen:
                    continue
                seen.add((r, c))
                if (r, c) in excluded:
                    continue
                path.append((r, c))
            c = ac - radius
            for r in range(ar + radius - 1, ar - radius, -1):
                if r < top or r > bottom or c < left or c > right:
                    continue
                if (r, c) in seen:
                    continue
                seen.add((r, c))
                if (r, c) in excluded:
                    continue
                path.append((r, c))
        return path

    # color clock and fill
    color_cycle = [7, 8, 9]
    color_idx = 0

    seeds_set = set(region_seed.values()) if region_seed else set()

    for rid in order:
        info = region_cells[rid]
        top, bottom = info['rows']
        left, right = info['cols']
        anchor = region_seed.get(rid, info['cells'][0])
        excluded = set([anchor]) | seeds_set
        path = spiral_from_anchor(top, bottom, left, right, anchor, excluded)
        for (r, c) in path:
            if r in hor_lines_sorted or c in ver_lines_sorted:
                continue
            if (r, c) in seeds_set:
                continue
            output[r][c] = color_cycle[color_idx % len(color_cycle)]
            color_idx = (color_idx + 1) % len(color_cycle)

    return output

