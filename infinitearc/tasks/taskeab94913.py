# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: eab94913
Difficulty: medium–hard

=== Tags ===
- Hierarchical agent routing
- Rule priority resolution
- Friction path
- Connect nearest components
- Center object in canvas

=== Description ===
**Task Name: Friction Path Network**    **Tags:**   Hierarchical agent routing,
Rule priority resolution, Friction path, Connect nearest components, Center
object in canvas    **Description:**   Input grids contain multiple colored
agents (distinct non-background colors) and their corresponding targets (same
color, positioned at distinct locations). Agents are hierarchically prioritized:
higher-priority agents (e.g., red, color 2) must connect to targets before
lower-priority agents (e.g., blue, color 5). Each agent connects to the nearest
target of identical color using a friction path, which alternates horizontal and
vertical movement (e.g., right, up, right, up) to form a zigzag route, avoiding
overlaps with other agents or targets. After all paths are drawn, the entire
path network is centered within the grid by shifting all path cells so their
bounding box aligns with the grid’s geometric center. All background elements,
agents, and targets remain unchanged except for the newly drawn friction paths,
which occupy only background cells. The output grid visually represents
hierarchical routing with centered paths, emphasizing the friction path pattern
and spatial organization.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate_friction_path(agent, target):
    path = []
    dr = target[0] - agent[0]
    dc = target[1] - agent[1]
    current = agent
    horizontal = True
    while current != target:
        if horizontal:
            step = 1 if dc > 0 else -1
            new_col = current[1] + step
            new_pos = (current[0], new_col)
            if new_pos == target:
                break
            path.append(new_pos)
            current = new_pos
            dc -= step
        else:
            step = 1 if dr > 0 else -1
            new_row = current[0] + step
            new_pos = (new_row, current[1])
            if new_pos == target:
                break
            path.append(new_pos)
            current = new_pos
            dr -= step
        horizontal = not horizontal
    return path

def generate():
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    input_grid = grid(width, height, 0)
    colors = sorted(random.sample(range(2, 10), random.randint(2, 5)))
    for color in colors:
        while True:
            r_a = random.randint(0, height-1)
            c_a = random.randint(0, width-1)
            if input_grid[r_a][c_a] == 0:
                input_grid[r_a][c_a] = color
                break
        while True:
            r_t = random.randint(0, height-1)
            c_t = random.randint(0, width-1)
            if input_grid[r_t][c_t] == 0 and (r_t, c_t) != (r_a, c_a):
                input_grid[r_t][c_t] = color
                break
    output_grid = [row[:] for row in input_grid]
    path_cells = []
    for color in colors:
        agent_pos = None
        target_pos = None
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == color:
                    if agent_pos is None:
                        agent_pos = (r, c)
                    else:
                        target_pos = (r, c)
        if agent_pos and target_pos:
            path = generate_friction_path(agent_pos, target_pos)
            path_cells.extend(path)
            for (r, c) in path:
                output_grid[r][c] = 1
    if path_cells:
        min_r = min(r for r, c in path_cells)
        max_r = max(r for r, c in path_cells)
        min_c = min(c for r, c in path_cells)
        max_c = max(c for r, c in path_cells)
        current_center_r = (min_r + max_r) / 2.0
        current_center_c = (min_c + max_c) / 2.0
        grid_center_r = (height - 1) / 2.0
        grid_center_c = (width - 1) / 2.0
        shift_r = int(round(grid_center_r - current_center_r))
        shift_c = int(round(grid_center_c - current_center_c))
        for (r, c) in path_cells:
            output_grid[r][c] = 0
            new_r = r + shift_r
            new_c = c + shift_c
            if 0 <= new_r < height and 0 <= new_c < width:
                output_grid[new_r][new_c] = 1
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random
from common import grid

def generate_friction_path(agent, target):
    path = []
    dr = target[0] - agent[0]
    dc = target[1] - agent[1]
    current = agent
    horizontal = True
    while current != target:
        if horizontal:
            step = 1 if dc > 0 else -1
            new_col = current[1] + step
            new_pos = (current[0], new_col)
            if new_pos == target:
                break
            path.append(new_pos)
            current = new_pos
            dc -= step
        else:
            step = 1 if dr > 0 else -1
            new_row = current[0] + step
            new_pos = (new_row, current[1])
            if new_pos == target:
                break
            path.append(new_pos)
            current = new_pos
            dr -= step
        horizontal = not horizontal
    return path

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    non_bg = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                non_bg.append((r, c, grid[r][c]))
    color_groups = {}
    for r, c, color in non_bg:
        if color not in color_groups:
            color_groups[color] = []
        color_groups[color].append((r, c))
    path_cells = []
    for color in sorted(color_groups.keys()):
        positions = color_groups[color]
        if len(positions) < 2:
            continue
        agent, target = positions[0], positions[1]
        path = generate_friction_path(agent, target)
        path_cells.extend(path)
        for (r, c) in path:
            grid[r][c] = 1
    if path_cells:
        min_r = min(r for r, c in path_cells)
        max_r = max(r for r, c in path_cells)
        min_c = min(c for r, c in path_cells)
        max_c = max(c for r, c in path_cells)
        current_center_r = (min_r + max_r) / 2.0
        current_center_c = (min_c + max_c) / 2.0
        grid_center_r = (height - 1) / 2.0
        grid_center_c = (width - 1) / 2.0
        shift_r = int(round(grid_center_r - current_center_r))
        shift_c = int(round(grid_center_c - current_center_c))
        for (r, c) in path_cells:
            grid[r][c] = 0
            new_r = r + shift_r
            new_c = c + shift_c
            if 0 <= new_r < height and 0 <= new_c < width:
                grid[new_r][new_c] = 1
    return tuple(tuple(row) for row in grid)
