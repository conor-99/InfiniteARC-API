# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 46a9ec1b
Difficulty: mediumâ€“hard

=== Tags ===
- Non overwriting draw
- If then color switch
- Field based motion
- Analogical mapping between pairs
- Associate patterns to colors

=== Description ===
Task Name: Directional Path Mapping  Input grids consist of a uniform background
color (0) and multiple distinct colored regions (1-9), each representing a
specific directional field. Colors 1-4 are strictly associated with cardinal
directions: color 1 = right, color 2 = down, color 3 = left, color 4 = up.
Colors 5-9 serve as source markers (color 5), pattern indicators (color 6-9), or
fixed obstacles. Source cells (color 5) are always positioned along the grid
edges. The grid contains at least two non-background directional fields (colors
1-4) arranged to create path intersections and direction switches.  In the
output grid, paths originate from every edge-aligned source cell (color 5). Each
path moves through background cells (0) following the directional fields it
encounters. The path's current color begins as 5 and changes to match any non-
background cell it enters (if-then color switch). Upon entering a directional
cell (colors 1-4), the path immediately adopts the cell's color and shifts
direction to the cell's associated cardinal direction. Paths never overwrite
non-background cells or other paths, and all paths terminate upon exiting the
grid.  The transformation requires sequential application of three rules: (1)
path initiation from edge sources, (2) directional field following, and (3)
conditional color switching. The output grid visually maps the analogical
relationship between input directional fields and their corresponding path
trajectories, with color associations fixed across all examples. The complexity
arises from paths switching colors multiple times and navigating through
overlapping directional fields, requiring users to recognize the color-direction
mapping and track path evolution.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    w = random.randint(5, 20)
    h = random.randint(5, 20)
    grid = [[0] * w for _ in range(h)]
    
    edges = [
        [(0, c) for c in range(w)],
        [(h-1, c) for c in range(w)],
        [(r, 0) for r in range(h)],
        [(r, w-1) for r in range(h)]
    ]
    sources = []
    for edge in edges:
        if random.choice([True, False]):
            pos = random.choice(edge)
            grid[pos[0]][pos[1]] = 5
            sources.append(pos)
    
    if len(sources) < 2:
        for edge in edges:
            if len(sources) >= 2:
                break
            for pos in edge:
                if grid[pos[0]][pos[1]] == 0:
                    grid[pos[0]][pos[1]] = 5
                    sources.append(pos)
                    if len(sources) >= 2:
                        break
    
    directions = {1: (0, 1), 2: (1, 0), 3: (0, -1), 4: (-1, 0)}
    output_grid = [row[:] for row in grid]
    
    for src in sources:
        r, c = src
        if r == 0:
            dr, dc = 1, 0
        elif r == h-1:
            dr, dc = -1, 0
        elif c == 0:
            dr, dc = 0, 1
        else:
            dr, dc = 0, -1
        
        current_r, current_c = r, c
        current_color = 5
        path_steps = []
        
        while True:
            next_r = current_r + dr
            next_c = current_c + dc
            if next_r < 0 or next_r >= h or next_c < 0 or next_c >= w:
                break
            if grid[next_r][next_c] in [1, 2, 3, 4]:
                current_color = grid[next_r][next_c]
                dr, dc = directions[current_color]
                current_r, current_c = next_r, next_c
            else:
                path_steps.append((next_r, next_c, current_color))
                current_r, current_c = next_r, next_c
        
        for (r, c, color) in path_steps:
            output_grid[r][c] = color
    
    if grid == output_grid:
        return generate()
    
    return {
        "input": grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])
    directions = {1: (0, 1), 2: (1, 0), 3: (0, -1), 4: (-1, 0)}
    
    sources = []
    for r in range(h):
        for c in range(w):
            if grid[r][c] == 5 and (r == 0 or r == h-1 or c == 0 or c == w-1):
                sources.append((r, c))
    
    for src in sources:
        r, c = src
        if r == 0:
            dr, dc = 1, 0
        elif r == h-1:
            dr, dc = -1, 0
        elif c == 0:
            dr, dc = 0, 1
        else:
            dr, dc = 0, -1
        
        current_r, current_c = r, c
        current_color = 5
        while True:
            next_r = current_r + dr
            next_c = current_c + dc
            if next_r < 0 or next_r >= h or next_c < 0 or next_c >= w:
                break
            if grid[next_r][next_c] in [1, 2, 3, 4]:
                current_color = grid[next_r][next_c]
                dr, dc = directions[current_color]
                current_r, current_c = next_r, next_c
            else:
                grid[next_r][next_c] = current_color
                current_r, current_c = next_r, next_c
    
    return tuple(tuple(row) for row in grid)
