# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 0f6379c1
Difficulty: medium

=== Tags ===
- Concentric

=== Description ===
This task features input grids with odd dimensions (e.g., 3×3, 5×5) where each
concentric layer of cells, defined by their Chebyshev distance from the grid's
center, is uniformly colored. The output grid reverses the color order of these
concentric layers, positioning the outermost layer's color at the center and the
innermost layer's color at the outermost perimeter. For example, a 5×5 grid with
three layers (inner: red, middle: green, outer: blue) transforms to (inner:
blue, middle: green, outer: red). The transformation is strictly based on layer
position relative to the center, with no color-value dependencies, ensuring
consistent application across all valid grids.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    sizes = [3,5,7,9,11,13,15,17,19]
    s = random.choice(sizes)
    L = (s + 1) // 2
    colors = random.sample(range(0, 10), L)
    center = (s - 1) // 2
    input_grid = [[0] * s for _ in range(s)]
    for i in range(s):
        for j in range(s):
            d = max(abs(i - center), abs(j - center))
            input_grid[i][j] = colors[d]
    output_grid = [[0] * s for _ in range(s)]
    for i in range(s):
        for j in range(s):
            d = max(abs(i - center), abs(j - center))
            output_grid[i][j] = colors[L - 1 - d]
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    s = len(input_grid)
    center = (s - 1) // 2
    L = (s + 1) // 2
    layer_colors = []
    for d in range(L):
        c = center + d
        if c >= s:
            c = s - 1
        layer_colors.append(input_grid[center][c])
    reversed_colors = layer_colors[::-1]
    output = [[0] * s for _ in range(s)]
    for i in range(s):
        for j in range(s):
            d = max(abs(i - center), abs(j - center))
            output[i][j] = reversed_colors[d]
    return output
