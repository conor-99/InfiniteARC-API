# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: d8c95aa5
Difficulty: hard

=== Tags ===
- Mirror pair coordination
- Loopless path
- Relational projection
- Nearest color fill
- Separate images

=== Description ===
Input grids consist of a 2D grid with dimensions between 1×1 and 30×30, where
each cell contains a value from 0 to 9 (0 representing background). Non-zero
values denote distinct colors, and the grid contains multiple disconnected
connected components (each a group of 4-connected cells sharing the same color),
referred to as "images." These images are positioned such that each has a
natural mirror counterpart across the vertical centerline of the grid, but the
input may lack complete mirror pairs or contain misaligned images.   The
transformation requires: 1. **Mirror Pair Coordination**: For each image,
compute its mirror position across the vertical axis. If the mirror would
overlap with an existing image (original or mirrored), shift the mirrored image
horizontally by the minimal distance (left or right) to eliminate overlap while
preserving symmetry. Shifts must avoid creating new overlaps with other images.
2. **Loopless Path**: Adjusted mirror positions must not form cyclic connections
between original and mirrored images. This is ensured by horizontal shifting to
prevent overlapping, which inherently avoids loop formation in connectivity. 3.
**Relational Projection**: Mirror images are projected with identical shape,
color, and orientation relative to their original positions, maintaining the
spatial relationship between paired images. 4. **Nearest Color Fill**: All
background cells (0) are replaced with the color of the nearest non-background
cell (using Manhattan distance). In case of equal distance to multiple colors,
the smallest color value is chosen. 5. **Separate Images**: Each image and its
mirror are processed independently, with no interaction between different color
groups. Mirroring adjustments for one image do not affect processing of other
images.  The output grid must contain all adjusted mirror images without
overlaps, all background cells filled with the nearest color, and all mirror
pairs symmetrically coordinated. The task requires simultaneous coordination of
multiple image pairs, resolution of spatial conflicts, and precise nearest-color
filling, making it challenging due to the combinatorial complexity of
overlapping adjustments and tie-breaking in color fill.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_colors

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    center = width // 2
    
    input_grid = grid(width, height, 0)
    colors = random_colors(random.randint(2, 5), exclude=[0])
    
    for color in colors:
        x = random.randint(0, center - 2)
        y = random.randint(0, height - 2)
        w = random.randint(1, 3)
        h = random.randint(1, 3)
        for r in range(y, min(y + h, height)):
            for c in range(x, min(x + w, center)):
                input_grid[r][c] = color

    output_grid = [row[:] for row in input_grid]
    
    non_zero_cells = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                non_zero_cells.append((r, c, input_grid[r][c]))

    mirror_positions = {}
    colors_set = set(c for _, _, c in non_zero_cells)
    for color in colors_set:
        mirror_pixels = []
        for r, c, _ in non_zero_cells:
            if input_grid[r][c] == color:
                mirror_c = width - 1 - c
                mirror_pixels.append((r, mirror_c))
        mirror_positions[color] = mirror_pixels

    for color, pixels in list(mirror_positions.items()):
        for other_color, other_pixels in mirror_positions.items():
            if color == other_color:
                continue
            if any(p in other_pixels for p in pixels):
                shift = 1
                while True:
                    shifted_pixels = [(r, c + shift) for (r, c) in pixels]
                    if not any(p in other_pixels for p in shifted_pixels):
                        mirror_positions[color] = shifted_pixels
                        break
                    shift += 1
                    if shift > 10:
                        break

    for color, pixels in mirror_positions.items():
        for (r, c) in pixels:
            if 0 <= c < width:
                output_grid[r][c] = color

    non_zero_cells = []
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] != 0:
                non_zero_cells.append((r, c, output_grid[r][c]))

    for r in range(height):
        for c in range(width):
            if output_grid[r][c] == 0:
                min_dist = float('inf')
                nearest_color = None
                for (r2, c2, color) in non_zero_cells:
                    dist = abs(r - r2) + abs(c - c2)
                    if dist < min_dist or (dist == min_dist and color < nearest_color):
                        min_dist = dist
                        nearest_color = color
                output_grid[r][c] = nearest_color

    if input_grid == output_grid:
        return generate()
    
    return {
        'input': input_grid,
        'output': output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    
    # Convert to list of lists to ensure mutability
    output_grid = [list(row) for row in input_grid]
    
    non_zero_cells = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                non_zero_cells.append((r, c, input_grid[r][c]))

    mirror_positions = {}
    colors_set = set(c for _, _, c in non_zero_cells)
    for color in colors_set:
        mirror_pixels = []
        for r, c, _ in non_zero_cells:
            if input_grid[r][c] == color:
                mirror_c = width - 1 - c
                mirror_pixels.append((r, mirror_c))
        mirror_positions[color] = mirror_pixels

    for color, pixels in list(mirror_positions.items()):
        for other_color, other_pixels in mirror_positions.items():
            if color == other_color:
                continue
            if any(p in other_pixels for p in pixels):
                shift = 1
                while True:
                    shifted_pixels = [(r, c + shift) for (r, c) in pixels]
                    if not any(p in other_pixels for p in shifted_pixels):
                        mirror_positions[color] = shifted_pixels
                        break
                    shift += 1
                    if shift > 10:
                        break

    for color, pixels in mirror_positions.items():
        for (r, c) in pixels:
            if 0 <= c < width:
                output_grid[r][c] = color

    non_zero_cells = []
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] != 0:
                non_zero_cells.append((r, c, output_grid[r][c]))

    for r in range(height):
        for c in range(width):
            if output_grid[r][c] == 0:
                min_dist = float('inf')
                nearest_color = None
                for (r2, c2, color) in non_zero_cells:
                    dist = abs(r - r2) + abs(c - c2)
                    if dist < min_dist or (dist == min_dist and color < nearest_color):
                        min_dist = dist
                        nearest_color = color
                output_grid[r][c] = nearest_color
    
    return output_grid
