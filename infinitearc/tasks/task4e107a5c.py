# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 4e107a5c
Difficulty: insane

=== Tags ===
- Cooperative rule network
- Associate images to patterns
- Contouring

=== Description ===
Input grids consist of multiple non-overlapping, contiguous colored regions
(each region is a single color, background is 0) arranged such that some regions
are adjacent to exactly one other region (forming distinct pairs). The output
grid requires drawing a single-cell thick contour around each such pair, where
the contour color is determined by a fixed, consistent association between the
two region colors in the pair. For example, a pair of regions colored 2 and 5
might map to contour color 8. Contours are drawn on the minimal bounding box
perimeter encompassing both regions in the pair, with the contour layer being
the outermost edge of this bounding box. Regions not part of any adjacent pair
remain unchanged. The association between color pairs and contour colors must be
inferred from the input-output examples, requiring the solver to recognize both
the spatial relationships between regions and the abstract color mapping rules.
This task demands simultaneous analysis of adjacency patterns, spatial bounding,
and cross-referenced color associations across the grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
from typing import List, Tuple

def generate():
    size = common.randint(10, 20)
    grid_size = (size, size)
    input_grid = common.grid(*grid_size, 0)
    output_grid = common.grid(*grid_size, 0)
    
    for i in range(size):
        for j in range(size):
            output_grid[i][j] = input_grid[i][j]
    
    num_pairs = common.randint(2, 4)
    region_colors = list(range(1, 9))
    common.random.shuffle(region_colors)
    
    for _ in range(num_pairs):
        color1 = region_colors.pop()
        color2 = region_colors.pop()
        
        shape1 = common.rand_sprite('el', 3, 3)
        shape2 = common.rand_sprite('you', 3, 3)
        
        x = common.randint(0, size - 3)
        y = common.randint(0, size - 3)
        
        for r, c in shape1:
            if 0 <= x + r < size and 0 <= y + c < size:
                input_grid[x + r][y + c] = color1
                output_grid[x + r][y + c] = color1
        
        for r, c in shape2:
            if 0 <= x + r < size and 0 <= y + 1 + c < size:
                input_grid[x + r][y + 1 + c] = color2
                output_grid[x + r][y + 1 + c] = color2
    
    regions = {}
    for r in range(size):
        for c in range(size):
            if input_grid[r][c] > 0:
                color = input_grid[r][c]
                if color not in regions:
                    regions[color] = []
                regions[color].append((r, c))
    
    neighbors = {color: set() for color in regions}
    for color, cells in regions.items():
        for (r, c) in cells:
            for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < size and 0 <= nc < size and input_grid[nr][nc] > 0:
                    ncolor = input_grid[nr][nc]
                    if ncolor != color:
                        neighbors[color].add(ncolor)
    
    pairs = []
    for color in neighbors:
        if len(neighbors[color]) == 1:
            neighbor_color = next(iter(neighbors[color]))
            if (color, neighbor_color) not in pairs and (neighbor_color, color) not in pairs:
                pairs.append((color, neighbor_color))
    
    for (color1, color2) in pairs:
        cells = regions.get(color1, []) + regions.get(color2, [])
        if not cells:
            continue
        min_r = min(r for r, c in cells)
        max_r = max(r for r, c in cells)
        min_c = min(c for r, c in cells)
        max_c = max(c for r, c in cells)
        
        for c in range(min_c - 1, max_c + 2):
            if min_r - 1 >= 0 and min_r - 1 < size and 0 <= c < size:
                output_grid[min_r - 1][c] = 9
        for c in range(min_c - 1, max_c + 2):
            if max_r + 1 < size and 0 <= c < size:
                output_grid[max_r + 1][c] = 9
        for r in range(min_r - 1, max_r + 2):
            if 0 <= r < size and min_c - 1 >= 0 and min_c - 1 < size:
                output_grid[r][min_c - 1] = 9
        for r in range(min_r - 1, max_r + 2):
            if 0 <= r < size and max_c + 1 < size:
                output_grid[r][max_c + 1] = 9
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    size = len(input_list)
    if size == 0:
        return input_list
    width = len(input_list[0])
    
    visited = [[False] * width for _ in range(size)]
    regions = {}
    
    def dfs(r, c, color):
        stack = [(r, c)]
        visited[r][c] = True
        cells = []
        while stack:
            r, c = stack.pop()
            cells.append((r, c))
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < size and 0 <= nc < width and not visited[nr][nc] and input_list[nr][nc] == color:
                    visited[nr][nc] = True
                    stack.append((nr, nc))
        return cells
    
    for r in range(size):
        for c in range(width):
            if not visited[r][c] and input_list[r][c] > 0:
                color = input_list[r][c]
                cells = dfs(r, c, color)
                if color not in regions:
                    regions[color] = []
                regions[color].extend(cells)
    
    neighbors = {}
    for color, cells in regions.items():
        neighbors[color] = set()
        for (r, c) in cells:
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < size and 0 <= nc < width and input_list[nr][nc] > 0:
                    ncolor = input_list[nr][nc]
                    if ncolor != color:
                        neighbors[color].add(ncolor)
    
    pairs = []
    for color in neighbors:
        if len(neighbors[color]) == 1:
            neighbor_color = next(iter(neighbors[color]))
            if (color, neighbor_color) not in pairs and (neighbor_color, color) not in pairs:
                pairs.append((color, neighbor_color))
    
    for (color1, color2) in pairs:
        cells = regions.get(color1, []) + regions.get(color2, [])
        if not cells:
            continue
        min_r = min(r for r, c in cells)
        max_r = max(r for r, c in cells)
        min_c = min(c for r, c in cells)
        max_c = max(c for r, c in cells)
        
        for c in range(min_c - 1, max_c + 2):
            if min_r - 1 >= 0 and min_r - 1 < size and 0 <= c < width:
                input_list[min_r - 1][c] = 9
        for c in range(min_c - 1, max_c + 2):
            if max_r + 1 < size and 0 <= c < width:
                input_list[max_r + 1][c] = 9
        for r in range(min_r - 1, max_r + 2):
            if 0 <= r < size and min_c - 1 >= 0 and min_c - 1 < width:
                input_list[r][min_c - 1] = 9
        for r in range(min_r - 1, max_r + 2):
            if 0 <= r < size and max_c + 1 < width:
                input_list[r][max_c + 1] = 9
    
    return input_list
