# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: f6b4e45b
Difficulty: hard

=== Tags ===
- Signal tracing

=== Description ===
Input grids represent complex circuit diagrams with interconnected wires and
logic gates. Background cells are color 0 (black), wires are color 1 (red), and
gate nodes are uniquely colored from 2-9 (each color representing a specific
logic gate operation: e.g., color 2 = AND, color 3 = OR, color 4 = XOR). Input
terminals appear as colored cells along grid edges (e.g., color 5 = active high
signal, color 6 = inactive low signal). Output terminals are similarly marked
for signal observation.    The transformation requires tracing signal
propagation from input terminals through the wire network. Signals travel along
wires, applying gate logic at each node (e.g., an AND gate (color 2) outputs
active only when both inputs are active). Active wires are recolored to match
the signal's state (e.g., active high signals appear in color 5), while inactive
wires remain background (color 0). The output grid preserves all original gate
positions and wire structures, but only active signal paths are highlighted.
Multiple signal paths may converge at gates, requiring sequential logic
application (e.g., OR gate output depends on any active input), and propagation
halts when no further signal changes occur.    This task demands sequential
logical inference across nested gate dependencies, branching signal paths, and
precise color-state mappingâ€”challenging due to the need to track multi-step
propagation through overlapping logic operations in dense, non-linear circuit
layouts.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque
import common

# Gate mapping: colors -> logical function names (for clarity only)
GATE_TYPES = {2: 'AND', 3: 'OR', 4: 'XOR', 7: 'NAND', 8: 'NOR', 9: 'BUF'}


def manhattan_path(a, b, size):
    """Return a simple Manhattan path from a to b with optional small detour."""
    (r1, c1), (r2, c2) = a, b
    path = []
    if random.random() < 0.5:
        # horizontal then vertical
        c_step = 1 if c2 >= c1 else -1
        for c in range(c1, c2 + c_step, c_step):
            path.append((r1, c))
        r_step = 1 if r2 >= r1 else -1
        for r in range(r1 + r_step, r2 + r_step, r_step):
            path.append((r, c2))
    else:
        # vertical then horizontal
        r_step = 1 if r2 >= r1 else -1
        for r in range(r1, r2 + r_step, r_step):
            path.append((r, c1))
        c_step = 1 if c2 >= c1 else -1
        for c in range(c1 + c_step, c2 + c_step, c_step):
            path.append((r2, c))

    # small random detour
    if random.random() < 0.18 and len(path) > 3:
        idx = len(path) // 2
        r, c = path[idx]
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < size and 0 <= nc < size:
                path.insert(idx + 1, (nr, nc))
                break

    # compact and clip
    seen = set()
    out = []
    for p in path:
        if p in seen: continue
        r, c = p
        if 0 <= r < size and 0 <= c < size:
            out.append(p)
            seen.add(p)
    return out


def compute_propagation(input_grid):
    """Given an input grid, compute which wire cells become active (True).

    Rules (monotonic activation):
    - Terminals on edges carry fixed signals: color 5 -> True, 6 -> False.
    - Wires (color 1) become active if they are adjacent (4-neighborhood) to a terminal
      that is True, to an active gate output, or to another already-active wire.
    - Gates (colors in GATE_TYPES) compute an output boolean based on the current
      boolean values of their adjacent neighbors (wires, terminals, other gates).
      If a gate's computed output becomes True (it was previously False), it will
      activate all adjacent wires (and can trigger downstream gates). Activation
      is monotonic (cells only flip from inactive to active), and the system is
      iterated until a fixed point.
    """
    size = len(input_grid)
    terminals = {}
    gates = {}
    wires = set()
    for r in range(size):
        for c in range(size):
            v = input_grid[r][c]
            if v in (5, 6) and (r == 0 or r == size - 1 or c == 0 or c == size - 1):
                terminals[(r, c)] = (v == 5)
            elif v in GATE_TYPES:
                gates[(r, c)] = v
            elif v == 1:
                wires.add((r, c))

    active_wires = set()
    gate_outputs = {pos: False for pos in gates}
    queue = deque()
    # seed with active terminals
    for pos, val in terminals.items():
        if val:
            queue.append((pos, True))

    while queue:
        pos, val = queue.popleft()
        r, c = pos
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if not (0 <= nr < size and 0 <= nc < size):
                continue
            npos = (nr, nc)
            cell = input_grid[nr][nc]
            # wires pick up signal
            if cell == 1:
                if val and npos not in active_wires:
                    active_wires.add(npos)
                    queue.append((npos, True))
            # gates evaluate based on current neighbors
            if npos in gates:
                # gather boolean inputs from all 4 neighbors of the gate
                inputs = []
                for dr2, dc2 in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    ar, ac = nr + dr2, nc + dc2
                    if not (0 <= ar < size and 0 <= ac < size):
                        continue
                    av = input_grid[ar][ac]
                    ap = (ar, ac)
                    if av == 1:
                        inputs.append(ap in active_wires)
                    elif ap in terminals:
                        inputs.append(terminals[ap])
                    elif ap in gates:
                        inputs.append(gate_outputs.get(ap, False))
                gate_type = gates[npos]
                out = False
                if inputs:
                    if gate_type == 2:  # AND
                        out = all(inputs)
                    elif gate_type == 3:  # OR
                        out = any(inputs)
                    elif gate_type == 4:  # XOR
                        out = (sum(1 for x in inputs if x) % 2 == 1)
                    elif gate_type == 7:  # NAND
                        out = not all(inputs)
                    elif gate_type == 8:  # NOR
                        out = not any(inputs)
                    elif gate_type == 9:  # BUFFER (acts like OR)
                        out = any(inputs)
                else:
                    out = False

                if out and not gate_outputs[npos]:
                    gate_outputs[npos] = True
                    # activate adjacent wires
                    for dr2, dc2 in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        wr, wc = nr + dr2, nc + dc2
                        if not (0 <= wr < size and 0 <= wc < size):
                            continue
                        if input_grid[wr][wc] == 1 and (wr, wc) not in active_wires:
                            active_wires.add((wr, wc))
                            queue.append(((wr, wc), True))
                    # also re-evaluate neighboring gates (direct gate-to-gate adjacency)
                    for dr2, dc2 in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        gr, gc = nr + dr2, nc + dc2
                        if not (0 <= gr < size and 0 <= gc < size):
                            continue
                        if (gr, gc) in gates and not gate_outputs.get((gr, gc), False):
                            queue.append(((gr, gc), True))

    return active_wires, gate_outputs, terminals


def generate():
    size = random.randint(10, 20)
    grid_in = common.grid(size, size, 0)

    # Place random terminals on edges (2..5 terminals)
    term_count = random.randint(2, 5)
    terminal_positions = set()
    attempts = 0
    while len(terminal_positions) < term_count and attempts < 200:
        attempts += 1
        side = random.choice([0, 1, 2, 3])  # top,right,bottom,left
        if side == 0:
            r, c = 0, random.randint(1, size - 2)
        elif side == 1:
            r, c = random.randint(1, size - 2), size - 1
        elif side == 2:
            r, c = size - 1, random.randint(1, size - 2)
        else:
            r, c = random.randint(1, size - 2), 0
        if (r, c) in terminal_positions:
            continue
        color = 5 if random.random() < 0.55 else 6
        grid_in[r][c] = color
        terminal_positions.add((r, c))

    # Place gates in the interior (2..6 gates)
    gate_count = random.randint(2, 6)
    gates = {}
    tries = 0
    while len(gates) < gate_count and tries < 800:
        tries += 1
        r = random.randint(2, size - 3)
        c = random.randint(2, size - 3)
        if (r, c) in gates or (r, c) in terminal_positions:
            continue
        # avoid adjacency to other gates to keep distinguishable gate nodes
        too_close = False
        for (gr, gc) in gates:
            if abs(gr - r) + abs(gc - c) <= 2:
                too_close = True
                break
        if too_close:
            continue
        color = random.choice(list(GATE_TYPES.keys()))
        gates[(r, c)] = color

    # Draw wires connecting terminals to gates and gates to gates
    # We'll draw Manhattan paths that create branching and intersections
    # Keep a list of connection endpoints that should be wired
    endpoints = []
    for tpos in terminal_positions:
        # choose a gate to connect to
        if gates and random.random() < 0.9:
            gpos = random.choice(list(gates.keys()))
            # connect to a neighbor of the gate so the gate has an adjacent wire
            nbrs = [(gpos[0] + dr, gpos[1] + dc) for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]]
            nbrs = [n for n in nbrs if 0 <= n[0] < size and 0 <= n[1] < size]
            if nbrs:
                target = random.choice(nbrs)
            else:
                target = gpos
            endpoints.append((tpos, target))
        else:
            # terminal to random interior point
            target = (random.randint(2, size - 3), random.randint(2, size - 3))
            endpoints.append((tpos, target))

    # connect some gates pairwise to create cascades
    gate_positions = list(gates.keys())
    random.shuffle(gate_positions)
    for i in range(len(gate_positions) - 1):
        a = gate_positions[i]
        b = gate_positions[i + 1]
        # connect neighbor-of-a to neighbor-of-b
        anbrs = [(a[0] + dr, a[1] + dc) for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]]
        bnbrs = [(b[0] + dr, b[1] + dc) for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]]
        anbrs = [n for n in anbrs if 0 <= n[0] < size and 0 <= n[1] < size]
        bnbrs = [n for n in bnbrs if 0 <= n[0] < size and 0 <= n[1] < size]
        if anbrs and bnbrs and random.random() < 0.9:
            endpoints.append((random.choice(anbrs), random.choice(bnbrs)))

    # add a few random extra branches
    for _ in range(random.randint(1, 4)):
        a = (random.randint(1, size - 2), random.randint(1, size - 2))
        b = (random.randint(1, size - 2), random.randint(1, size - 2))
        endpoints.append((a, b))

    # draw all endpoint connections as wire paths
    for a, b in endpoints:
        path = manhattan_path(a, b, size)
        for (r, c) in path:
            # don't overwrite terminals (keep 5/6), gates will be placed later
            if grid_in[r][c] == 0:
                grid_in[r][c] = 1

    # finally place gate colors (override any wires that passed through)
    for (r, c), color in gates.items():
        grid_in[r][c] = color

    # Compute propagation to build output grid
    active_wires, gate_outputs, terminals = compute_propagation(grid_in)

    # Build output grid: gates and terminals preserved, active wires colored 5
    grid_out = common.grid(size, size, 0)
    for (r, c), color in gates.items():
        grid_out[r][c] = color
    for (r, c), val in terminals.items():
        grid_out[r][c] = 5 if val else 6
    for (r, c) in active_wires:
        grid_out[r][c] = 5

    return {"input": grid_in, "output": grid_out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

# The solver duplicates the gate interpretation and propagation used in the generator
GATE_TYPES = {2: 'AND', 3: 'OR', 4: 'XOR', 7: 'NAND', 8: 'NOR', 9: 'BUF'}


def compute_propagation(input_grid):
    size = len(input_grid)
    terminals = {}
    gates = {}
    wires = set()
    for r in range(size):
        for c in range(size):
            v = input_grid[r][c]
            if v in (5, 6) and (r == 0 or r == size - 1 or c == 0 or c == size - 1):
                terminals[(r, c)] = (v == 5)
            elif v in GATE_TYPES:
                gates[(r, c)] = v
            elif v == 1:
                wires.add((r, c))

    active_wires = set()
    gate_outputs = {pos: False for pos in gates}
    queue = deque()

    for pos, val in terminals.items():
        if val:
            queue.append((pos, True))

    while queue:
        pos, val = queue.popleft()
        r, c = pos
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if not (0 <= nr < size and 0 <= nc < size):
                continue
            npos = (nr, nc)
            cell = input_grid[nr][nc]
            if cell == 1:
                if val and npos not in active_wires:
                    active_wires.add(npos)
                    queue.append((npos, True))
            if npos in gates:
                inputs = []
                for dr2, dc2 in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    ar, ac = nr + dr2, nc + dc2
                    if not (0 <= ar < size and 0 <= ac < size):
                        continue
                    av = input_grid[ar][ac]
                    ap = (ar, ac)
                    if av == 1:
                        inputs.append(ap in active_wires)
                    elif ap in terminals:
                        inputs.append(terminals[ap])
                    elif ap in gates:
                        inputs.append(gate_outputs.get(ap, False))
                gate_type = gates[npos]
                out = False
                if inputs:
                    if gate_type == 2:  # AND
                        out = all(inputs)
                    elif gate_type == 3:  # OR
                        out = any(inputs)
                    elif gate_type == 4:  # XOR
                        out = (sum(1 for x in inputs if x) % 2 == 1)
                    elif gate_type == 7:  # NAND
                        out = not all(inputs)
                    elif gate_type == 8:  # NOR
                        out = not any(inputs)
                    elif gate_type == 9:  # BUFFER
                        out = any(inputs)
                else:
                    out = False

                if out and not gate_outputs[npos]:
                    gate_outputs[npos] = True
                    for dr2, dc2 in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        wr, wc = nr + dr2, nc + dc2
                        if not (0 <= wr < size and 0 <= wc < size):
                            continue
                        if input_grid[wr][wc] == 1 and (wr, wc) not in active_wires:
                            active_wires.add((wr, wc))
                            queue.append(((wr, wc), True))
                    for dr2, dc2 in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        gr, gc = nr + dr2, nc + dc2
                        if not (0 <= gr < size and 0 <= gc < size):
                            continue
                        if (gr, gc) in gates and not gate_outputs.get((gr, gc), False):
                            queue.append(((gr, gc), True))

    return active_wires, gate_outputs, terminals


def p(input_grid):
    # convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    size = len(grid)

    active_wires, gate_outputs, terminals = compute_propagation(grid)

    # Build output grid: gates and terminals preserved, active wires colored 5
    out = [[0] * size for _ in range(size)]
    for (r, c), v in {( (r, c), grid[r][c]) for r in range(size) for c in range(size) if grid[r][c] in GATE_TYPES}:
        pass
    # copy gates
    for r in range(size):
        for c in range(size):
            if grid[r][c] in GATE_TYPES:
                out[r][c] = grid[r][c]
    # copy terminals
    for (r, c), val in terminals.items():
        out[r][c] = 5 if val else 6
    # set active wires
    for (r, c) in active_wires:
        out[r][c] = 5

    return tuple(tuple(row) for row in out)

