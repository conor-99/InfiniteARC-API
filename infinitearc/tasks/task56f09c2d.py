# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 56f09c2d
Difficulty: hard

=== Tags ===
- Take minimum

=== Description ===
The task requires transforming an input grid into an output grid by processing
each connected region (defined by 4-directional adjacency, regardless of color)
and replacing every cell in the region with the minimum color value found within
that region. For instance, if a region contains colors 3, 5, and 1, all cells in
that region become 1. Input grids feature complex arrangements of multiple
interwoven regions with varying color distributions, where regions may contain
mixtures of high and low values. The output grid must reflect the minimum color
for each region, requiring careful identification of connected components and
precise computation of minimum values. The difficulty arises from the need to
distinguish overlapping or closely spaced regions, especially in grids with
numerous small regions and intricate patterns, where misidentifying a region's
boundaries leads to incorrect transformations. The input grid is guaranteed to
differ from the output grid, as at least one region must contain a color value
higher than the minimum within its component.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    def find_components(grid):
        height = len(grid)
        width = len(grid[0])
        visited = [[False] * width for _ in range(height)]
        components = []
        for r in range(height):
            for c in range(width):
                if grid[r][c] != 0 and not visited[r][c]:
                    stack = [(r, c)]
                    visited[r][c] = True
                    comp = []
                    while stack:
                        cr, cc = stack.pop()
                        comp.append((cr, cc))
                        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] != 0:
                                visited[nr][nc] = True
                                stack.append((nr, nc))
                    components.append(comp)
        return components
    
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    while True:
        grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
        components = find_components(grid)
        if not components:
            continue
        has_var = False
        for comp in components:
            colors = set(grid[r][c] for r, c in comp)
            if len(colors) > 1:
                has_var = True
                break
        if has_var:
            break
    output = [[0] * width for _ in range(height)]
    for comp in components:
        min_val = min([grid[x][y] for x, y in comp])
        for x, y in comp:
            output[x][y] = min_val
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    visited = [[False] * width for _ in range(height)]
    output = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                stack = [(r, c)]
                visited[r][c] = True
                comp = []
                while stack:
                    cr, cc = stack.pop()
                    comp.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] != 0:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                min_color = min([input_grid[x][y] for x, y in comp])
                for x, y in comp:
                    output[x][y] = min_color
    return output
