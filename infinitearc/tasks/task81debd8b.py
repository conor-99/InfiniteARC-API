# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 81debd8b
Difficulty: insane

=== Tags ===
- Non overwriting draw
- Contouring
- Projection unto rectangle

=== Description ===
# Rectangular Contour Projection  Input grids feature multiple distinct, non-
overlapping shapes (each a connected region of uniform non-zero color) on a
background of color 0. Shapes are separated by at least one background cell in
all directions, with no two shapes sharing edges or corners. Each shape has a
unique color and varies in size and orientation, with no restrictions on aspect
ratio or complexity.  The transformation requires generating a contour around
the minimal axis-aligned bounding rectangle (MBR) of each shape. The contour is
drawn exclusively on background cells (0) immediately outside the MBR's
perimeter, forming a continuous rectangular outline using color 9. The contour
must precisely follow the MBR's edges: top edge (one row above MBR top), bottom
edge (one row below MBR bottom), left edge (one column to the left of MBR left),
and right edge (one column to the right of MBR right).   For example, if a
shape's MBR spans rows 2-5 and columns 3-7, the contour will appear on: - Top:
row 1, columns 3-7 - Bottom: row 6, columns 3-7 - Left: rows 2-5, column 2 -
Right: rows 2-5, column 8  All other grid cells remain unchanged from the input.
Background cells not adjacent to any MBR perimeter retain their original color
(0). The contour must be drawn without gaps, and no contour may intersect with
any shape's interior or other contours. The output must preserve all input
shapes exactly while adding only the specified rectangular contours on
background cells. This requires simultaneous identification of all shapes,
precise MBR calculation, and non-overwriting contour placementâ€”all while
maintaining strict geometric consistency across all shapes.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common


def generate():
    """Generate an input/output pair for the Rectangular Contour Projection task.

    - Places 2-4 contiguous shapes (using common.continuous_creature) of unique non-zero
      colors (excluding 9) into a background of 0.
    - Ensures each shape's minimal axis-aligned bounding rectangle (MBR) has a one-cell
      background margin on all sides so the contour (one cell outside the MBR) fits inside
      the grid and does not overlap other shapes or other contours.
    - Produces the output by copying the input and drawing color 9 on background (0)
      cells immediately outside each shape's MBR (top, bottom, left, right edges).
    """
    max_restarts = 40
    for restart in range(max_restarts):
        width = random.randint(8, 30)
        height = random.randint(8, 30)
        grid = common.grid(width, height, 0)

        target_shapes = random.randint(2, 4)
        used_pixels = set()          # cells occupied by shapes
        used_mbr1 = []               # list of rectangles (r1,c1,r2,c2) for MBR expanded by 1
        shapes_info = []             # list of (abs_pixels, color)
        colors_used = set()

        success = True
        # Try placing target_shapes shapes
        for _ in range(target_shapes):
            placed = False
            # Try many random placements for this shape
            for attempt in range(250):
                # Choose sprite size (local bounding box). Keep it modest so placement succeeds.
                max_sprite_w = min(6, max(2, width - 4))
                max_sprite_h = min(6, max(2, height - 4))
                if max_sprite_w < 2 or max_sprite_h < 2:
                    continue
                sprite_w = random.randint(2, max_sprite_w)
                sprite_h = random.randint(2, max_sprite_h)

                # Choose number of pixels for the contiguous creature (at least 1, at most sprite area)
                max_pixels = sprite_w * sprite_h
                size = random.randint(1, min(12, max_pixels))

                # Create contiguous shape in a small local box
                local_pixels = common.continuous_creature(size, sprite_w, sprite_h)
                local_rows = [p[0] for p in local_pixels]
                local_cols = [p[1] for p in local_pixels]
                min_lr, max_lr = min(local_rows), max(local_rows)
                min_lc, max_lc = min(local_cols), max(local_cols)

                # Determine allowed placement range so that MBR + margin 1 fits in the grid
                dx_min = 1 - min_lc
                dx_max = width - 2 - max_lc
                dy_min = 1 - min_lr
                dy_max = height - 2 - max_lr
                if dx_min > dx_max or dy_min > dy_max:
                    continue

                dx = random.randint(dx_min, dx_max)
                dy = random.randint(dy_min, dy_max)

                abs_pixels = [(r + dy, c + dx) for (r, c) in local_pixels]

                # Ensure shape interior doesn't collide with existing shapes
                collision = any(p in used_pixels for p in abs_pixels)
                if collision:
                    continue

                # Compute MBR of the placed shape and the expanded MBR (one-cell border)
                min_r = min(r for r, c in abs_pixels)
                max_r = max(r for r, c in abs_pixels)
                min_c = min(c for r, c in abs_pixels)
                max_c = max(c for r, c in abs_pixels)
                r1, r2 = min_r - 1, max_r + 1
                c1, c2 = min_c - 1, max_c + 1

                # Ensure expanded MBR fits entirely inside the grid
                if r1 < 0 or c1 < 0 or r2 >= height or c2 >= width:
                    continue

                # Ensure expanded MBR does not overlap previously reserved expanded MBRs
                overlap = False
                for (or1, oc1, or2, oc2) in used_mbr1:
                    if not (r2 < or1 or r1 > or2 or c2 < oc1 or c1 > oc2):
                        overlap = True
                        break
                if overlap:
                    continue

                # Ensure expanded MBR does not include any existing shape pixel (safety)
                intersects_shape = False
                for rr in range(r1, r2 + 1):
                    for cc in range(c1, c2 + 1):
                        if (rr, cc) in used_pixels:
                            intersects_shape = True
                            break
                    if intersects_shape:
                        break
                if intersects_shape:
                    continue

                # Choose a unique color for the shape excluding 0 and 9
                color = common.random_color(exclude=[0, 9] + list(colors_used))
                colors_used.add(color)

                # Place the shape
                for (rr, cc) in abs_pixels:
                    grid[rr][cc] = color
                    used_pixels.add((rr, cc))

                used_mbr1.append((r1, c1, r2, c2))
                shapes_info.append((abs_pixels, color))
                placed = True
                break

            if not placed:
                success = False
                break

        if not success or len(shapes_info) < 2:
            # try a fresh layout
            continue

        # Build the output by drawing color 9 on background cells immediately outside each shape's MBR
        output = [row[:] for row in grid]
        for abs_pixels, _color in shapes_info:
            rows = [r for r, c in abs_pixels]
            cols = [c for r, c in abs_pixels]
            min_row, max_row = min(rows), max(rows)
            min_col, max_col = min(cols), max(cols)

            # Top edge (one row above MBR)
            if min_row - 1 >= 0:
                rtop = min_row - 1
                for cc in range(min_col, max_col + 1):
                    if output[rtop][cc] == 0:
                        output[rtop][cc] = 9

            # Bottom edge (one row below MBR)
            if max_row + 1 < height:
                rbot = max_row + 1
                for cc in range(min_col, max_col + 1):
                    if output[rbot][cc] == 0:
                        output[rbot][cc] = 9

            # Left edge (one column left of MBR)
            if min_col - 1 >= 0:
                cleft = min_col - 1
                for rr in range(min_row, max_row + 1):
                    if output[rr][cleft] == 0:
                        output[rr][cleft] = 9

            # Right edge (one column right of MBR)
            if max_col + 1 < width:
                cright = max_col + 1
                for rr in range(min_row, max_row + 1):
                    if output[rr][cright] == 0:
                        output[rr][cright] = 9

        return {"input": grid, "output": output}

    # Fallback (very unlikely): return a minimal valid pair
    w, h = 8, 8
    grid = common.grid(w, h, 0)
    # place a single tiny shape in the middle and its contour
    grid[3][3] = 1
    out = [row[:] for row in grid]
    out[2][3] = 9
    out[4][3] = 9
    out[3][2] = 9
    out[3][4] = 9
    return {"input": grid, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import collections

def p(input_grid):
    # Work on a mutable copy but first discover all shape MBRs without modifying the grid
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    visited = [[False] * width for _ in range(height)]
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    mbrs = []  # list of (min_row, max_row, min_col, max_col)

    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and not visited[r][c]:
                color = grid[r][c]
                queue = collections.deque()
                queue.append((r, c))
                visited[r][c] = True
                region = []
                while queue:
                    cr, cc = queue.popleft()
                    region.append((cr, cc))
                    for dr, dc in directions:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))

                rows = [cr for cr, cc in region]
                cols = [cc for cr, cc in region]
                min_row, max_row = min(rows), max(rows)
                min_col, max_col = min(cols), max(cols)
                mbrs.append((min_row, max_row, min_col, max_col))

    # Now draw contours on a copy, writing color 9 only on background cells (0)
    out = [row[:] for row in grid]
    for (min_row, max_row, min_col, max_col) in mbrs:
        # Top edge
        if min_row - 1 >= 0:
            rtop = min_row - 1
            for cc in range(min_col, max_col + 1):
                if out[rtop][cc] == 0:
                    out[rtop][cc] = 9
        # Bottom edge
        if max_row + 1 < height:
            rbot = max_row + 1
            for cc in range(min_col, max_col + 1):
                if out[rbot][cc] == 0:
                    out[rbot][cc] = 9
        # Left edge
        if min_col - 1 >= 0:
            cleft = min_col - 1
            for rr in range(min_row, max_row + 1):
                if out[rr][cleft] == 0:
                    out[rr][cleft] = 9
        # Right edge
        if max_col + 1 < width:
            cright = max_col + 1
            for rr in range(min_row, max_row + 1):
                if out[rr][cright] == 0:
                    out[rr][cright] = 9

    return tuple(tuple(row) for row in out)

