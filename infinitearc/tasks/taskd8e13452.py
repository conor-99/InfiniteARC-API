# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: d8e13452
Difficulty: hard

=== Tags ===
- Local state machine
- Color modulated motion
- Meta rule switching
- Crop

=== Description ===
Input grids consist of a background color (0) and multiple foreground regions of
distinct colors (1-9), arranged in a non-uniform pattern. The grid also contains
a meta color (e.g., 5) that dynamically alters the direction of motion for all
color-modulated elements.   **Local State Machine**: Each foreground cell (color
c ≠ 0) functions as an independent agent with a state defined by its color. The
agent's movement direction is determined by a fixed mapping (e.g., color 1 →
right, 2 → down, 3 → left, 4 → up) unless overridden by the meta rule.  **Color
Modulated Motion**: The direction of movement for each agent is strictly
modulated by its color. Agents move *once* in their assigned direction if the
target cell is background (0); otherwise, they remain stationary. Agents do not
overwrite non-background cells.  **Meta Rule Switching**: If the meta color (5)
appears in the input grid, the direction mapping is inverted (e.g., color 1 →
left, 2 → up, 3 → right, 4 → down). This reversal applies universally to all
agents.  **Crop**: After all valid movements are applied, the output grid is
cropped to the smallest axis-aligned rectangle containing all non-background
cells. Background cells outside this bounding box are discarded, and the grid
dimensions adjust accordingly.  The task requires recognizing the meta color,
dynamically switching the motion rule, simulating one-step agent movement
without conflicts, and precisely cropping the result. The complexity arises from
the interdependence of the meta color, directional modulation, and the spatial
constraints of the crop operation, demanding multi-layered reasoning to
disentangle the rule interactions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    width = random.randint(2, 30)
    height = random.randint(2, 30)
    has_meta = random.choice([True, False])
    input_grid = [[0] * width for _ in range(height)]
    default_dir = {1: (0, 1), 2: (1, 0), 3: (0, -1), 4: (-1, 0)}
    inverted_dir = {1: (0, -1), 2: (-1, 0), 3: (0, 1), 4: (1, 0)}
    num_agents = random.randint(1, 5)
    for _ in range(num_agents):
        color = random.choice([1, 2, 3, 4])
        dr, dc = default_dir[color] if not has_meta else inverted_dir[color]
        while True:
            r = random.randint(0, height-1)
            c = random.randint(0, width-1)
            agent_r = r - dr
            agent_c = c - dc
            if 0 <= agent_r < height and 0 <= agent_c < width:
                break
        input_grid[agent_r][agent_c] = color
    if has_meta:
        while True:
            r = random.randint(0, height-1)
            c = random.randint(0, width-1)
            if input_grid[r][c] == 0:
                input_grid[r][c] = 5
                break
    for _ in range(random.randint(0, 5)):
        color = random.randint(6, 9)
        while True:
            r = random.randint(0, height-1)
            c = random.randint(0, width-1)
            if input_grid[r][c] == 0:
                input_grid[r][c] = color
                break
    output_grid = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width):
            color = input_grid[r][c]
            if color in [1, 2, 3, 4]:
                dr, dc = default_dir[color] if not has_meta else inverted_dir[color]
                tr = r + dr
                tc = c + dc
                if 0 <= tr < height and 0 <= tc < width and input_grid[tr][tc] == 0:
                    output_grid[r][c] = 0
                    output_grid[tr][tc] = color
    non_zero = [(r, c) for r in range(height) for c in range(width) if output_grid[r][c] != 0]
    if not non_zero:
        cropped = [[0]]
    else:
        min_r = min(r for r, c in non_zero)
        max_r = max(r for r, c in non_zero)
        min_c = min(c for r, c in non_zero)
        max_c = max(c for r, c in non_zero)
        cropped = []
        for r in range(min_r, max_r+1):
            cropped.append(output_grid[r][min_c:max_c+1])
    return {"input": input_grid, "output": cropped}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    height = len(input_list)
    width = len(input_list[0]) if height > 0 else 0
    has_meta = any(5 in row for row in input_list)
    default_dir = {1: (0, 1), 2: (1, 0), 3: (0, -1), 4: (-1, 0)}
    inverted_dir = {1: (0, -1), 2: (-1, 0), 3: (0, 1), 4: (1, 0)}
    output_list = [row[:] for row in input_list]
    for r in range(height):
        for c in range(width):
            color = input_list[r][c]
            if color in [1, 2, 3, 4]:
                dr, dc = default_dir[color] if not has_meta else inverted_dir[color]
                tr = r + dr
                tc = c + dc
                if 0 <= tr < height and 0 <= tc < width and input_list[tr][tc] == 0:
                    output_list[r][c] = 0
                    output_list[tr][tc] = color
    non_zero = [(r, c) for r in range(height) for c in range(width) if output_list[r][c] != 0]
    if not non_zero:
        return [[0]]
    min_r = min(r for r, c in non_zero)
    max_r = max(r for r, c in non_zero)
    min_c = min(c for r, c in non_zero)
    max_c = max(c for r, c in non_zero)
    cropped = []
    for r in range(min_r, max_r+1):
        cropped.append(output_list[r][min_c:max_c+1])
    return cropped
