# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: c5dde5eb
Difficulty: very hard

=== Tags ===
- Pattern analogy
- Recursive mirroring
- Bidirectional escape

=== Description ===
**Task Description:**  **Input Grids:**   Input grids feature a central "core"
pattern composed of multiple distinct colors arranged in a non-symmetrical
shape, surrounded by a ring of identical "mirror markers" (a single, consistent
color) placed along the grid edges adjacent to the core. Each marker indicates a
direction for reflection (e.g., top-edge markers trigger vertical reflection,
right-edge markers trigger horizontal reflection). The core may also contain
internal markers that initiate secondary reflections, creating recursive layers
of mirrored patterns. The grid size ranges from 10×10 to 25×25, with the core
occupying a 3×3 to 7×7 area.  **Output Grids:**   The output grid is generated
by recursively applying bidirectional mirror transformations to the core
pattern. For each marker:   1. **Bidirectional Propagation:** Horizontal markers
(left/right edges) reflect the core in *both* directions simultaneously (e.g., a
right-edge marker reflects the core leftward and rightward), while vertical
markers (top/bottom edges) reflect it in *both* upward and downward directions.
2. **Recursive Mirroring:** Each reflected core becomes a new seed for further
reflections, with its own internal markers triggering additional layers.   3.
**Boundary Handling:** Reflections stop when they would extend beyond the grid
edges, ensuring all patterns remain within the 1×1 to 30×30 grid.   4. **Color
Preservation:** The core’s colors remain unchanged during reflection; only
positions shift. Overlapping reflections are resolved by prioritizing the
deepest recursive layer.    **Key Rules:**   - **Layered Symmetry:** Each
reflection layer must be processed in order of increasing depth (e.g., primary
reflections first, then secondary, etc.).   - **Bidirectional Escape:**
Reflections propagate outward in both directions from every marker, creating
symmetrical extensions until grid boundaries halt the process.   - **Pattern
Integrity:** No colors are altered; only spatial positions change. Internal
markers within reflected cores are treated identically to original markers.   -
**No Overlaps:** Reflected patterns may touch but never overlap, with deeper
layers taking precedence in overlapping regions.    **Complexity:**   This task
requires multi-step spatial reasoning to track recursive reflection layers,
resolve bidirectional propagation paths, and handle overlapping patterns. Inputs
may contain up to 5 recursive layers, with core patterns that partially overlap
across layers. The output must reconstruct all reflected patterns without visual
artifacts, demanding precise analysis of marker positions and reflection depth.
The challenge lies in discerning the recursive order of reflections and
correctly prioritizing overlapping regions, making it a "very hard" task due to
the combinatorial complexity of layer interactions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque
from common import grid

# Generator for ARC task c5dde5eb (Task 426)
# Creates a core pattern and a ring of identical markers on the grid edges adjacent to the core.
# Then produces the output by recursively reflecting the core whenever a marker indicates a direction.


def _pattern_to_tuple(pat):
    return tuple(tuple(row) for row in pat)


def _reflect_all(input_grid, start_top, start_left, pattern, marker_color):
    H = len(input_grid)
    W = len(input_grid[0])
    Hc = len(pattern)
    Wc = len(pattern[0])

    out = [row[:] for row in input_grid]
    depth_map = [[-1] * W for _ in range(H)]

    visited = set()
    q = deque()

    key0 = (start_top, start_left, _pattern_to_tuple(pattern))
    visited.add(key0)
    q.append((start_top, start_left, pattern, 0))

    while q:
        top, left, pat, depth = q.popleft()
        Hc = len(pat)
        Wc = len(pat[0])

        # Paint this pattern into the output, respecting depth priority (deeper overrides)
        for rr in range(Hc):
            for cc in range(Wc):
                r = top + rr
                c = left + cc
                if 0 <= r < H and 0 <= c < W:
                    val = pat[rr][cc]
                    if val != 0 and depth >= depth_map[r][c]:
                        out[r][c] = val
                        depth_map[r][c] = depth

        # Determine internal-edge markers inside this pattern
        top_edge_marker = any(pat[0][c] == marker_color for c in range(Wc))
        bottom_edge_marker = any(pat[Hc - 1][c] == marker_color for c in range(Wc))
        left_edge_marker = any(pat[r][0] == marker_color for r in range(Hc))
        right_edge_marker = any(pat[r][Wc - 1] == marker_color for r in range(Hc))

        # Determine whether the global grid borders (the original marker ring) intersects this seed
        col_start = max(0, left)
        col_end = min(W, left + Wc)
        row_start = max(0, top)
        row_end = min(H, top + Hc)

        top_border_marker = any(input_grid[0][c] == marker_color for c in range(col_start, col_end))
        bottom_border_marker = any(input_grid[H - 1][c] == marker_color for c in range(col_start, col_end))
        left_border_marker = any(input_grid[r][0] == marker_color for r in range(row_start, row_end))
        right_border_marker = any(input_grid[r][W - 1] == marker_color for r in range(row_start, row_end))

        # Bidirectional propagation: any horizontal marker (left/right) causes reflections both left and right,
        # any vertical marker (top/bottom) causes reflections both up and down.
        horizontal_trigger = left_edge_marker or right_edge_marker or left_border_marker or right_border_marker
        vertical_trigger = top_edge_marker or bottom_edge_marker or top_border_marker or bottom_border_marker

        # Create horizontal reflections (mirror left-right)
        if horizontal_trigger:
            # left copy
            new_left = left - Wc
            if new_left >= 0:
                new_pat = [row[::-1] for row in pat]
                key = (top, new_left, _pattern_to_tuple(new_pat))
                if key not in visited:
                    visited.add(key)
                    q.append((top, new_left, new_pat, depth + 1))
            # right copy
            new_left = left + Wc
            if new_left + Wc <= W:
                new_pat = [row[::-1] for row in pat]
                key = (top, new_left, _pattern_to_tuple(new_pat))
                if key not in visited:
                    visited.add(key)
                    q.append((top, new_left, new_pat, depth + 1))

        # Create vertical reflections (mirror top-bottom)
        if vertical_trigger:
            # up copy
            new_top = top - Hc
            if new_top >= 0:
                new_pat = pat[::-1]
                key = (new_top, left, _pattern_to_tuple(new_pat))
                if key not in visited:
                    visited.add(key)
                    q.append((new_top, left, new_pat, depth + 1))
            # down copy
            new_top = top + Hc
            if new_top + Hc <= H:
                new_pat = pat[::-1]
                key = (new_top, left, _pattern_to_tuple(new_pat))
                if key not in visited:
                    visited.add(key)
                    q.append((new_top, left, new_pat, depth + 1))

    return out


def generate():
    # We will try several times to produce an input/output pair where the output differs from input
    for attempt in range(120):
        # Grid size
        W = random.randint(10, 25)
        H = random.randint(10, 25)

        # Core size
        core_size = random.randint(3, 7)

        # Place core with at least one cell margin from the absolute edges so the marker ring can be placed
        max_top = H - core_size - 1
        max_left = W - core_size - 1
        if max_top < 1:
            continue
        if max_left < 1:
            continue
        core_top = random.randint(1, max_top)
        core_left = random.randint(1, max_left)

        # Choose a marker color that is not background
        marker_color = random.randint(1, 9)

        # Choose core colors (exclude marker_color)
        available = [c for c in range(1, 10) if c != marker_color]
        num_core_colors = random.randint(2, min(4, len(available)))
        core_colors = random.sample(available, num_core_colors)

        # Build a non-symmetric core pattern
        def is_symmetric(pat):
            # Check horizontal, vertical and 180-rotation symmetry
            if pat == [row[::-1] for row in pat]:
                return True
            if pat == pat[::-1]:
                return True
            if pat == [row[::-1] for row in pat[::-1]]:
                return True
            return False

        core_pat = [[random.choice(core_colors) for _ in range(core_size)] for _ in range(core_size)]
        for _ in range(100):
            if not is_symmetric(core_pat):
                break
            core_pat = [[random.choice(core_colors) for _ in range(core_size)] for _ in range(core_size)]

        # Optionally place a few internal markers on the core perimeter (these trigger recursive reflections)
        perimeter = set()
        for c in range(core_size):
            perimeter.add((0, c))
            perimeter.add((core_size - 1, c))
        for r in range(core_size):
            perimeter.add((r, 0))
            perimeter.add((r, core_size - 1))
        perimeter = list(perimeter)

        # Randomly choose some perimeter positions to turn into markers
        num_internal_markers = random.randint(0, min(3, len(perimeter)))
        internal_positions = random.sample(perimeter, num_internal_markers)
        for (r, c) in internal_positions:
            core_pat[r][c] = marker_color

        # Decide which global border sides receive the marker ring (must have at least one side)
        top_active = random.choice([True, False])
        bottom_active = random.choice([True, False])
        left_active = random.choice([True, False])
        right_active = random.choice([True, False])
        if not (top_active or bottom_active or left_active or right_active):
            # ensure at least one
            side = random.choice(['top', 'bottom', 'left', 'right'])
            if side == 'top':
                top_active = True
            elif side == 'bottom':
                bottom_active = True
            elif side == 'left':
                left_active = True
            else:
                right_active = True

        input_grid = grid(W, H, 0)

        # Paint core into input
        for r in range(core_size):
            for c in range(core_size):
                input_grid[core_top + r][core_left + c] = core_pat[r][c]

        # Paint global border markers aligned with the core
        for c in range(core_left, core_left + core_size):
            if top_active:
                input_grid[0][c] = marker_color
            if bottom_active:
                input_grid[H - 1][c] = marker_color
        for r in range(core_top, core_top + core_size):
            if left_active:
                input_grid[r][0] = marker_color
            if right_active:
                input_grid[r][W - 1] = marker_color

        # Build the output by applying the recursive bidirectional reflections
        output_grid = _reflect_all(input_grid, core_top, core_left, core_pat, marker_color)

        # Ensure the output differs from the input (there is at least one reflection placed)
        if output_grid != input_grid:
            return {
                'input': input_grid,
                'output': output_grid
            }

    # Fallback: force a configuration that will reflect at least once by moving the core if necessary
    # Place a small core near the middle so that at least one reflection can fit
    W = max(10, W)
    H = max(10, H)
    core_size = min(7, max(3, core_size))
    core_top = core_size
    core_left = core_size
    try:
        marker_color
    except NameError:
        marker_color = 1
    try:
        core_colors
    except NameError:
        available = [c for c in range(1, 10) if c != marker_color]
        core_colors = random.sample(available, 2)
    core_pat = [[random.choice(core_colors) for _ in range(core_size)] for _ in range(core_size)]
    input_grid = grid(W, H, 0)
    for r in range(core_size):
        for c in range(core_size):
            input_grid[core_top + r][core_left + c] = core_pat[r][c]
    # put markers on the top border to ensure vertical reflections
    for c in range(core_left, core_left + core_size):
        input_grid[0][c] = marker_color
    output_grid = _reflect_all(input_grid, core_top, core_left, core_pat, marker_color)
    return {
        'input': input_grid,
        'output': output_grid
    }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    from collections import deque

    # Convert to mutable list-of-lists
    if isinstance(input_grid, tuple):
        grid_in = [list(row) for row in input_grid]
    else:
        grid_in = [list(row) for row in input_grid]

    H = len(grid_in)
    W = len(grid_in[0])

    # Identify marker color by inspecting the outer border (most frequent non-zero color there)
    edge_counts = {}
    for c in range(W):
        v = grid_in[0][c]
        if v != 0:
            edge_counts[v] = edge_counts.get(v, 0) + 1
        v = grid_in[H - 1][c]
        if v != 0:
            edge_counts[v] = edge_counts.get(v, 0) + 1
    for r in range(H):
        v = grid_in[r][0]
        if v != 0:
            edge_counts[v] = edge_counts.get(v, 0) + 1
        v = grid_in[r][W - 1]
        if v != 0:
            edge_counts[v] = edge_counts.get(v, 0) + 1

    if edge_counts:
        marker_color = max(edge_counts, key=lambda k: edge_counts[k])
    else:
        # Fallback: most common non-zero color in the whole grid
        counts = {}
        for r in range(H):
            for c in range(W):
                v = grid_in[r][c]
                if v != 0:
                    counts[v] = counts.get(v, 0) + 1
        if counts:
            marker_color = max(counts, key=lambda k: counts[k])
        else:
            return grid_in

    # Find core bounding box by ignoring marker-colored pixels (they are markers)
    min_r, max_r = H, -1
    min_c, max_c = W, -1
    for r in range(H):
        for c in range(W):
            v = grid_in[r][c]
            if v != 0 and v != marker_color:
                min_r = min(min_r, r)
                max_r = max(max_r, r)
                min_c = min(min_c, c)
                max_c = max(max_c, c)

    if max_r < 0:
        # No core detected
        return grid_in

    core_top = min_r
    core_left = min_c
    core_pat = [grid_in[r][min_c:max_c + 1] for r in range(min_r, max_r + 1)]

    # Reflection engine (same as generator)
    def _pattern_to_tuple(pat):
        return tuple(tuple(row) for row in pat)

    def _reflect_all(input_grid, start_top, start_left, pattern, marker_color):
        H = len(input_grid)
        W = len(input_grid[0])
        Hc = len(pattern)
        Wc = len(pattern[0])

        out = [row[:] for row in input_grid]
        depth_map = [[-1] * W for _ in range(H)]

        visited = set()
        q = deque()

        key0 = (start_top, start_left, _pattern_to_tuple(pattern))
        visited.add(key0)
        q.append((start_top, start_left, pattern, 0))

        while q:
            top, left, pat, depth = q.popleft()
            Hc = len(pat)
            Wc = len(pat[0])

            # Paint pattern into out with depth priority
            for rr in range(Hc):
                for cc in range(Wc):
                    r = top + rr
                    c = left + cc
                    if 0 <= r < H and 0 <= c < W:
                        val = pat[rr][cc]
                        if val != 0 and depth >= depth_map[r][c]:
                            out[r][c] = val
                            depth_map[r][c] = depth

            top_edge_marker = any(pat[0][c] == marker_color for c in range(Wc))
            bottom_edge_marker = any(pat[Hc - 1][c] == marker_color for c in range(Wc))
            left_edge_marker = any(pat[r][0] == marker_color for r in range(Hc))
            right_edge_marker = any(pat[r][Wc - 1] == marker_color for r in range(Hc))

            col_start = max(0, left)
            col_end = min(W, left + Wc)
            row_start = max(0, top)
            row_end = min(H, top + Hc)

            top_border_marker = any(input_grid[0][c] == marker_color for c in range(col_start, col_end))
            bottom_border_marker = any(input_grid[H - 1][c] == marker_color for c in range(col_start, col_end))
            left_border_marker = any(input_grid[r][0] == marker_color for r in range(row_start, row_end))
            right_border_marker = any(input_grid[r][W - 1] == marker_color for r in range(row_start, row_end))

            horizontal_trigger = left_edge_marker or right_edge_marker or left_border_marker or right_border_marker
            vertical_trigger = top_edge_marker or bottom_edge_marker or top_border_marker or bottom_border_marker

            if horizontal_trigger:
                new_left = left - Wc
                if new_left >= 0:
                    new_pat = [row[::-1] for row in pat]
                    key = (top, new_left, _pattern_to_tuple(new_pat))
                    if key not in visited:
                        visited.add(key)
                        q.append((top, new_left, new_pat, depth + 1))
                new_left = left + Wc
                if new_left + Wc <= W:
                    new_pat = [row[::-1] for row in pat]
                    key = (top, new_left, _pattern_to_tuple(new_pat))
                    if key not in visited:
                        visited.add(key)
                        q.append((top, new_left, new_pat, depth + 1))

            if vertical_trigger:
                new_top = top - Hc
                if new_top >= 0:
                    new_pat = pat[::-1]
                    key = (new_top, left, _pattern_to_tuple(new_pat))
                    if key not in visited:
                        visited.add(key)
                        q.append((new_top, left, new_pat, depth + 1))
                new_top = top + Hc
                if new_top + Hc <= H:
                    new_pat = pat[::-1]
                    key = (new_top, left, _pattern_to_tuple(new_pat))
                    if key not in visited:
                        visited.add(key)
                        q.append((new_top, left, new_pat, depth + 1))

        return out

    output = _reflect_all(grid_in, core_top, core_left, core_pat, marker_color)
    return output

