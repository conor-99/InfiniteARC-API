# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: ae156765
Difficulty: hard

=== Tags ===
- Crop
- Draw pattern from point
- Associate colors to colors
- Bridges

=== Description ===
The task involves transforming an input grid into an output grid through a
sequence of abstract operations. The input grid contains two distinct endpoint
markers (e.g., color values 2 and 3) that define a bridge connection. First, a
fixed color association rule is applied, mapping specific input colors to new
output colors (e.g., color 2 → 5, color 3 → 7). Next, a straight-line bridge
pattern is drawn between the original positions of the endpoints using a
dedicated bridge color (e.g., color 4), ignoring the mapped colors. Finally, the
output grid is cropped to the minimal bounding box enclosing the bridge,
discarding all surrounding cells. The challenge lies in identifying the endpoint
markers without relying on their mapped colors, deducing the color association
rule from examples, determining the bridge color, and precisely computing the
crop region. The rules require multi-step reasoning, visual pattern recognition,
and compositional inference, making it difficult to solve without analyzing the
spatial and color relationships in the input-output pairs.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    from common import grid
    def get_line_points(r1, c1, r2, c2):
        points = []
        dx = abs(r2 - r1)
        dy = abs(c2 - c1)
        sx = 1 if r1 < r2 else -1
        sy = 1 if c1 < c2 else -1
        err = dx - dy
        while True:
            points.append((r1, c1))
            if r1 == r2 and c1 == c2:
                break
            e2 = 2 * err
            if e2 > -dy:
                err -= dy
                r1 += sx
            if e2 < dx:
                err += dx
                c1 += sy
        return points

    width = random.randint(3, 30)
    height = random.randint(3, 30)
    input_grid = grid(width, height, 0)
    positions = [(r, c) for r in range(height) for c in range(width)]
    pos1 = random.choice(positions)
    pos2 = random.choice([p for p in positions if p != pos1])
    r1, c1 = pos1
    r2, c2 = pos2
    input_grid[r1][c1] = 2
    input_grid[r2][c2] = 3
    line_points = get_line_points(r1, c1, r2, c2)
    min_row = min(r for r, c in line_points)
    max_row = max(r for r, c in line_points)
    min_col = min(c for r, c in line_points)
    max_col = max(c for r, c in line_points)
    out_width = max_col - min_col + 1
    out_height = max_row - min_row + 1
    output_grid = grid(out_width, out_height, 0)
    for r, c in line_points:
        r_rel = r - min_row
        c_rel = c - min_col
        if (r, c) == (r1, c1):
            output_grid[r_rel][c_rel] = 5
        elif (r, c) == (r2, c2):
            output_grid[r_rel][c_rel] = 7
        else:
            output_grid[r_rel][c_rel] = 4
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    from common import grid
    def get_line_points(r1, c1, r2, c2):
        points = []
        dx = abs(r2 - r1)
        dy = abs(c2 - c1)
        sx = 1 if r1 < r2 else -1
        sy = 1 if c1 < c2 else -1
        err = dx - dy
        while True:
            points.append((r1, c1))
            if r1 == r2 and c1 == c2:
                break
            e2 = 2 * err
            if e2 > -dy:
                err -= dy
                r1 += sx
            if e2 < dx:
                err += dx
                c1 += sy
        return points

    height = len(input_grid)
    width = len(input_grid[0])
    r2, c2 = None, None
    r3, c3 = None, None
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 2:
                r2, c2 = r, c
            elif input_grid[r][c] == 3:
                r3, c3 = r, c
    line_points = get_line_points(r2, c2, r3, c3)
    min_row = min(r for r, c in line_points)
    max_row = max(r for r, c in line_points)
    min_col = min(c for r, c in line_points)
    max_col = max(c for r, c in line_points)
    out_width = max_col - min_col + 1
    out_height = max_row - min_row + 1
    output_grid = grid(out_width, out_height, 0)
    for r, c in line_points:
        r_rel = r - min_row
        c_rel = c - min_col
        if (r, c) == (r2, c2):
            output_grid[r_rel][c_rel] = 5
        elif (r, c) == (r3, c3):
            output_grid[r_rel][c_rel] = 7
        else:
            output_grid[r_rel][c_rel] = 4
    return output_grid
