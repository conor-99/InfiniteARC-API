# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 8806c66b
Difficulty: hard

=== Tags ===
- Tile mutation rule
- Sort colors by index

=== Description ===
The input grid consists of a 2D grid containing multiple disconnected,
contiguous regions (tiles) of non-zero colors (1-9), each tile forming a single
connected component of uniform color. The background color (0) is ignored during
tile identification. Each tile must be a distinct color, with no two tiles
sharing the same color value. The output grid transforms the input by first
sorting all tiles in row-major order (top-left to bottom-right based on the
minimum row and column coordinates of each tile) and then sorting all unique
tile colors numerically (ascending order). The tiles are then reassigned these
sorted colors in sequence, such that the top-leftmost tile receives the smallest
color value, the next tile receives the next smallest, and so on. This results
in the tile shapes remaining unchanged, but their color assignments reflecting
the numerical order of their positions and the sorted color list. The
transformation requires both spatial reasoning (identifying tile positions) and
numerical sorting (reordering colors), making it challenging to discover through
a small number of examples.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    from common import grid, rand_sprite, random_color, randint, choice, sample
    
    while True:
        width = randint(5, 30)
        height = randint(5, 30)
        grid_input = [[0]*width for _ in range(height)]
        tiles = []  # (color, sprite, start_r, start_c)
        used_colors = set()
        
        num_tiles = randint(3, 5)
        for _ in range(num_tiles):
            color = random_color(exclude=used_colors)
            used_colors.add(color)
            name = choice(["el", "aitch", "you"])
            sprite_width = randint(2, 3)
            sprite_height = randint(2, 3)
            sprite_pixels = rand_sprite(name, sprite_width, sprite_height)
            
            placed = False
            for _ in range(100):  # Try up to 100 times to place the sprite
                start_r = randint(0, height - 1)
                start_c = randint(0, width - 1)
                valid = True
                for r, c in sprite_pixels:
                    nr, nc = start_r + r, start_c + c
                    if nr < 0 or nr >= height or nc < 0 or nc >= width:
                        valid = False
                        break
                    if grid_input[nr][nc] != 0:
                        valid = False
                        break
                if valid:
                    for r, c in sprite_pixels:
                        nr, nc = start_r + r, start_c + c
                        grid_input[nr][nc] = color
                    tiles.append((color, sprite_pixels, start_r, start_c))
                    placed = True
                    break
            if not placed:
                # If couldn't place after 100 tries, skip this tile
                continue
        
        # If we have less than 3 tiles, regenerate
        if len(tiles) < 3:
            continue
        
        # Compute output grid
        # Get top-left for each tile
        def get_top_left(tile):
            color, sprite, start_r, start_c = tile
            actual = [(start_r + r, start_c + c) for r, c in sprite]
            min_row = min(r for r, c in actual)
            min_col = min(c for r, c in actual if r == min_row)
            return (min_row, min_col)
        
        sorted_tiles = sorted(tiles, key=get_top_left)
        input_colors = sorted([color for color, _, _, _ in tiles])
        output_grid = [[0]*width for _ in range(height)]
        
        for i, (color, sprite, start_r, start_c) in enumerate(sorted_tiles):
            new_color = input_colors[i]
            for r, c in sprite:
                nr, nc = start_r + r, start_c + c
                output_grid[nr][nc] = new_color
        
        if grid_input != output_grid:
            return {"input": grid_input, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    
    # Find all non-zero colors
    colors_set = set()
    positions = {}
    for r in range(height):
        for c in range(width):
            color = grid[r][c]
            if color != 0:
                colors_set.add(color)
                if color not in positions:
                    positions[color] = []
                positions[color].append((r, c))
    
    # Compute top-left for each color
    top_lefts = {}
    for color, pts in positions.items():
        min_row = min(r for r, c in pts)
        min_col = min(c for r, c in pts if r == min_row)
        top_lefts[color] = (min_row, min_col)
    
    # Sort colors and tiles
    sorted_colors = sorted(colors_set)
    tiles = list(colors_set)
    tiles.sort(key=lambda color: top_lefts[color])
    
    # Map old color to new color
    color_map = {}
    for i, color in enumerate(tiles):
        color_map[color] = sorted_colors[i]
    
    # Build output grid
    output_grid = [[0]*width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            color = grid[r][c]
            if color != 0:
                output_grid[r][c] = color_map[color]
    
    return output_grid
