# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 506ee63f
Difficulty: hard

=== Tags ===
- Simulate billiards shot
- Laser diffusion
- Connect the dots

=== Description ===
The input grid is a 20×20 grid with a background color (0) and contains a laser
source (color 1) positioned on the bottom edge (row 19, column 10), initially
facing upward. Scattered throughout the grid are five mirror cells (color 2),
one obstacle cell (color 3), and no other non-background elements. The laser
travels in a straight line in its current direction until it encounters a mirror
(color 2), an obstacle (color 3), or a grid boundary. Upon hitting a mirror, the
laser turns 90 degrees counterclockwise (e.g., upward → left, left → downward,
etc.) and continues moving. Upon hitting a grid boundary (e.g., moving up from
row 0), the laser reverses direction (e.g., upward → downward) without changing
direction. Upon hitting an obstacle (color 3), the laser path terminates
immediately. The output grid displays the complete laser path as a continuous
line using color 1, connecting the laser source to all mirrors hit in sequence,
with direction changes accurately reflected at each mirror. The path does not
include the obstacle cell, and all input elements (mirrors, obstacle, source)
remain visible in their original positions within the output grid. The sequence
of mirrors hit must follow deterministic reflection rules, and the output grid
must contain no additional elements beyond the path and original grid features.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width, height = 20, 20
    input_grid = grid(width, height, 0)
    input_grid[19][10] = 1  # Laser source
    
    # Place 5 mirrors (color 2)
    mirrors = []
    while len(mirrors) < 5:
        r, c = random.randint(0, 19), random.randint(0, 19)
        if (r, c) == (19, 10) or input_grid[r][c] != 0:
            continue
        input_grid[r][c] = 2
        mirrors.append((r, c))
    
    # Place 1 obstacle (color 3)
    obstacle = None
    while obstacle is None:
        r, c = random.randint(0, 19), random.randint(0, 19)
        if (r, c) == (19, 10) or input_grid[r][c] != 0:
            continue
        input_grid[r][c] = 3
        obstacle = (r, c)
    
    # Simulate laser path
    r, c = 19, 10
    dr, dc = -1, 0  # Moving up
    path = [(r, c)]
    visited = set()
    max_steps = 1000
    
    for _ in range(max_steps):
        nr, nc = r + dr, c + dc
        
        # First check boundary
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            dr, dc = -dr, -dc
            continue
        
        # Obstacle termination
        if input_grid[nr][nc] == 3:
            break
        
        # Mirror reflection
        if input_grid[nr][nc] == 2:
            dr, dc = -dc, dr  # 90° CCW
            path.append((nr, nc))
            r, c = nr, nc
        else:
            path.append((nr, nc))
            r, c = nr, nc
        
        # Check loop
        state = (r, c, dr, dc)
        if state in visited:
            break
        visited.add(state)
    
    output_grid = [row[:] for row in input_grid]
    for r, c in path:
        output_grid[r][c] = 1
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    grid = [list(row) for row in input_grid]
    
    # Laser source position (fixed at bottom edge, column 10)
    r, c = 19, 10
    dr, dc = -1, 0  # Moving up
    path = [(r, c)]
    visited = set()
    
    while True:
        nr, nc = r + dr, c + dc
        
        # Boundary check
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            dr, dc = -dr, -dc
            continue
        
        # Obstacle termination
        if grid[nr][nc] == 3:
            break
        
        # Mirror reflection
        if grid[nr][nc] == 2:
            dr, dc = -dc, dr
            r, c = nr, nc
            path.append((r, c))
        else:
            r, c = nr, nc
            path.append((r, c))
        
        # Check for loops
        state = (r, c, dr, dc)
        if state in visited:
            break
        visited.add(state)
    
    # Draw path in output
    for r, c in path:
        grid[r][c] = 1
    
    return tuple(tuple(row) for row in grid)
