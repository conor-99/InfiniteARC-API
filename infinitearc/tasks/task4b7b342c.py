# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 4b7b342c
Difficulty: hard

=== Tags ===
- Global consistency enforcement

=== Description ===
The input grid features a complex arrangement of colors with asymmetric
patterns, where at least one cell and its symmetric counterpart across both
vertical and horizontal midlines differ in color. The output grid must enforce
global symmetry such that for every cell (r, c), the cell at the position
mirrored across both axes (i.e., (height - r - 1, width - c - 1)) matches the
original cell's color. This requires modifying the input grid to reflect the
color of the original cell for all mirrored positions, ensuring the entire grid
adheres to symmetric constraints. The input is designed with multiple distinct
color regions placed asymmetrically, creating a visually complex pattern that
demands recognition of spatial relationships and application of a multi-step
symmetry transformation to achieve the output grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            mr = height - 1 - r
            mc = width - 1 - c
            if r < mr or (r == mr and c <= mc):
                output_grid[r][c] = input_grid[r][c]
                output_grid[mr][mc] = input_grid[r][c]
    if input_grid == output_grid:
        input_grid[0][0] = (input_grid[0][0] + 1) % 10
        output_grid = [[0] * width for _ in range(height)]
        for r in range(height):
            for c in range(width):
                mr = height - 1 - r
                mc = width - 1 - c
                if r < mr or (r == mr and c <= mc):
                    output_grid[r][c] = input_grid[r][c]
                    output_grid[mr][mc] = input_grid[r][c]
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    h = len(input_grid)
    w = len(input_grid[0])
    output = [[0] * w for _ in range(h)]
    for r in range(h):
        for c in range(w):
            mr = h - 1 - r
            mc = w - 1 - c
            if r < mr or (r == mr and c <= mc):
                output[r][c] = input_grid[r][c]
                output[mr][mc] = input_grid[r][c]
    return output
