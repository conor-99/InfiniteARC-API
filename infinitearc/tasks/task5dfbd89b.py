# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 5dfbd89b
Difficulty: very hard

=== Tags ===
- Path instruction following
- Exclusive or coloring

=== Description ===
Input grids are 20×20 grids with a single background color (0) and walls (1).
The maze contains a continuous path starting at a cell on the left edge (color
6), defined by directional arrows (colors 2–5 representing right, up, left,
down). The path is not directly visible—it is traced by following the arrows'
directions. Scattered along the path are "color nodes" (colors 7–9), each
representing a color cycle transformation rule. The output grid must transform
the path's color sequentially based on the color nodes encountered: nodes of
color 7 trigger a forward cycle (e.g., red → green → blue → red), while nodes of
color 8 trigger a backward cycle (e.g., red → blue → green → red). Nodes of
color 9 use a different cycle (e.g., purple → yellow → orange → purple). The
path's initial color matches the starting cell (6). Each time the path crosses a
color node, the path's color updates to the next (or previous) color in the
cycle defined by the node's color. The output displays the path with updated
colors at each segment, while preserving the original arrows, walls, and color
nodes. The transformation requires recognizing the path, identifying node
colors, deducing cycle directions from node colors, and applying sequential
color changes without overlapping walls or background cells.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Generator for ARC task: path tracing with nodes that change path color
# Grid size fixed 20x20. This version avoids self-touching paths so adjacency
# reconstruction is unambiguous.

def generate():
    size = 20
    # Create empty input grid filled with background (0)
    inp = [[0 for _ in range(size)] for _ in range(size)]

    # Create a self-avoiding random path starting at left edge (col 0)
    # This path avoids touching previously visited cells (except the immediate predecessor)
    def build_path(min_len=8, max_len=60, max_tries=5000):
        tries = 0
        while tries < max_tries:
            tries += 1
            start_row = random.randint(1, size - 2)
            start = (start_row, 0)
            path = [start]
            visited = {start}

            target_len = random.randint(min_len, min(max_len, size * size // 4))

            # Grow path with a bias to move rightwards but allow up/down/left
            stuck = False
            for _ in range(target_len - 1):
                r, c = path[-1]
                candidates = []
                for dr, dc in [(0, 1), (1, 0), (-1, 0), (0, -1)]:
                    nr, nc = r + dr, c + dc
                    if not (0 <= nr < size and 0 <= nc < size):
                        continue
                    if (nr, nc) in visited:
                        continue
                    # Ensure candidate does not touch any earlier visited cell (except current)
                    touches_earlier = False
                    for vr, vc in visited:
                        if (vr, vc) == (r, c):
                            continue
                        if abs(vr - nr) + abs(vc - nc) == 1:
                            touches_earlier = True
                            break
                    if touches_earlier:
                        continue
                    candidates.append((nr, nc))

                if not candidates:
                    stuck = True
                    break

                # Bias towards moving right to ensure path expands into grid
                weights = [3 if nc > c else 1 for (nr, nc) in candidates]
                next_cell = random.choices(candidates, weights=weights, k=1)[0]
                path.append(next_cell)
                visited.add(next_cell)
                # Occasionally stop early to vary lengths
                if len(path) >= min_len and random.random() < 0.08:
                    break

            if stuck:
                continue
            if len(path) >= min_len:
                return path
        # Fallback: simple straight path across a row (guaranteed non-touching)
        row = random.randint(1, size - 2)
        length = random.randint(min_len, min(size - 1, max_len))
        return [(row, c) for c in range(0, length)]

    path = build_path()

    # Choose some nodes along the path (cannot be the start)
    max_nodes = max(2, min(6, len(path) // 4))
    possible_indices = list(range(1, len(path) - 1))
    if possible_indices:
        num_nodes = random.randint(2, max_nodes) if len(possible_indices) >= 2 else 1
        node_idxs = set(random.sample(possible_indices, min(num_nodes, len(possible_indices))))
    else:
        node_idxs = set()

    # Fill input grid: set start, arrows for steps, and nodes (which replace arrows)
    for i, (r, c) in enumerate(path):
        if i == 0:
            inp[r][c] = 6  # start color
            continue
        # If this index is marked as a node, place node color 7/8/9
        if i in node_idxs:
            inp[r][c] = random.choice([7, 8, 9])
            continue
        # Otherwise place an arrow indicating the *next* movement if possible
        if i < len(path) - 1:
            nr, nc = path[i + 1]
            dr, dc = nr - r, nc - c
            if dc == 1:
                arrow = 2  # right
            elif dr == -1:
                arrow = 3  # up
            elif dc == -1:
                arrow = 4  # left
            elif dr == 1:
                arrow = 5  # down
            else:
                arrow = 2
            inp[r][c] = arrow
        else:
            # Last cell of path (make it look like a terminal arrow cell so it's
            # recognized as part of the path). Use the incoming direction if possible.
            pr, pc = path[i - 1]
            dr, dc = r - pr, c - pc
            if dc == 1:
                inp[r][c] = 2
            elif dr == -1:
                inp[r][c] = 3
            elif dc == -1:
                inp[r][c] = 4
            elif dr == 1:
                inp[r][c] = 5
            else:
                inp[r][c] = 2

    # Add some walls (color 1) randomly but make sure not to overwrite path cells
    wall_prob = random.uniform(0.02, 0.08)
    for r in range(size):
        for c in range(size):
            if (r, c) in path:
                continue
            if random.random() < wall_prob:
                inp[r][c] = 1

    # Build the output grid by following the path in order and applying color cycles
    out = [row[:] for row in inp]
    current_color = 6
    cycles = {
        7: [6, 7, 8, 9],  # node 7: forward cycle
        8: [6, 9, 8, 7],  # node 8: backward-ish cycle
        9: [6, 7, 9, 8],  # node 9: alternate cycle
    }

    for idx, (r, c) in enumerate(path):
        val = inp[r][c]
        if idx == 0:
            out[r][c] = 6
            continue
        if val in (7, 8, 9):
            cycle = cycles[val]
            # Ensure current_color is in the cycle; if not, reset to the first entry
            if current_color not in cycle:
                current_color = cycle[0]
            else:
                pos = cycle.index(current_color)
                current_color = cycle[(pos + 1) % len(cycle)]
            # Node cells remain their node color in the output (they are preserved)
        else:
            # Arrow cells are painted with the current path color (overwriting arrows)
            out[r][c] = current_color

    return {"input": inp, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable list of lists
    grid = [list(row) for row in input_grid]
    size = len(grid)

    # Find the start cell on the left edge (color 6)
    start = None
    for r in range(size):
        if grid[r][0] == 6:
            start = (r, 0)
            break
    if start is None:
        # No start found: return the grid as-is
        return grid

    # Define which values belong to the path (start, arrows, nodes)
    path_values = set([2, 3, 4, 5, 6, 7, 8, 9])

    # Collect the connected component of path cells reachable from start
    stack = [start]
    visited = set()
    while stack:
        r, c = stack.pop()
        if (r, c) in visited:
            continue
        if grid[r][c] not in path_values:
            continue
        visited.add((r, c))
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < size and 0 <= nc < size and (nr, nc) not in visited:
                if grid[nr][nc] in path_values:
                    stack.append((nr, nc))

    # Build adjacency for the path cells
    neighbors = {}
    for (r, c) in visited:
        nbrs = []
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if (nr, nc) in visited:
                nbrs.append((nr, nc))
        neighbors[(r, c)] = nbrs

    # Reconstruct the ordered path starting from start by always moving to the neighbor
    # that isn't the previous cell (this assumes the path is a simple non-branching chain)
    ordered = [start]
    prev = None
    cur = start
    while True:
        cand = [n for n in neighbors[cur] if n != prev]
        if not cand:
            break
        # choose the unique continuation (path is generated to be non-branching)
        nxt = cand[0]
        ordered.append(nxt)
        prev, cur = cur, nxt

    # Apply the same color-cycle rules as the generator
    output = [row[:] for row in grid]
    current_color = 6
    cycles = {
        7: [6, 7, 8, 9],
        8: [6, 9, 8, 7],
        9: [6, 7, 9, 8],
    }

    for i, (r, c) in enumerate(ordered):
        val = grid[r][c]
        if i == 0:
            output[r][c] = 6
            continue
        if val in (7, 8, 9):
            cycle = cycles[val]
            if current_color not in cycle:
                current_color = cycle[0]
            else:
                pos = cycle.index(current_color)
                current_color = cycle[(pos + 1) % len(cycle)]
            # node cells remain unchanged in the output
        else:
            # overwrite arrow cells with the current path color
            output[r][c] = current_color

    return output

