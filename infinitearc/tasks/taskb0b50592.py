# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: b0b50592
Difficulty: easy

=== Tags ===
- Bounce
- Detect enclosure
- Color palette

=== Description ===
The input grid displays a closed shape formed by a continuous boundary path that
mimics a bouncing motion (e.g., a zig-zag or diagonal pattern), rendered in a
single color from the palette (e.g., red). The interior of this shape is filled
with the background color (e.g., white), while the boundary remains distinct.
The output grid must identify the enclosed region within the boundary and fill
it with a designated secondary color from the palette (e.g., blue), leaving the
boundary color unchanged. The transformation relies solely on visual detection
of the enclosed area formed by the boundary path, without relying on numerical
properties or pixel-level analysis.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    boundary_color = random.choice([c for c in range(1, 10) if c != 3])
    input_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if r == 0 or r == height - 1 or c == 0 or c == width - 1:
                input_grid[r][c] = boundary_color
    output_grid = [[boundary_color if (r == 0 or r == height - 1 or c == 0 or c == width - 1) else 3 for c in range(width)] for r in range(height)]
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if r == 0 or r == height - 1 or c == 0 or c == width - 1:
                output_grid[r][c] = input_grid[r][c]
            else:
                output_grid[r][c] = 3
    return output_grid
