# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 022ce9f2
Difficulty: hard

=== Tags ===
- L system fractal generation
- Weave patterns
- Pattern differences

=== Description ===
The input grid features a fractal pattern generated by an L-system (e.g., a
Sierpi≈Ñski triangle or similar recursive structure), rendered in a single
foreground color (e.g., color 3) against a background of color 0. The fractal
consists of continuous horizontal and vertical line segments forming its
geometric structure. The output grid transforms the input by applying a weave
pattern to these segments: along each continuous horizontal or vertical segment
of the fractal, the foreground color alternates between 3 and 4 (starting with 3
for the first cell in the segment), while all background cells remain unchanged.
This creates a woven visual effect where the original solid-line fractal is
replaced with an alternating color pattern along its segments. The
transformation requires identifying all connected horizontal and vertical
segments within the fractal structure and applying the alternation rule
sequentially along each segment. The complexity arises from the need to
distinguish fractal segments from background noise, handle varying segment
lengths, and apply the alternation consistently across all segments without
relying on coordinate-based parity or numerical properties.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    width = common.randint(5, 30)
    height = common.randint(5, 30)
    input_grid = common.grid(width, height, 0)
    x = width // 2
    y = height // 2
    size = min(width, height) // 4
    depth = common.randint(1, 3)
    
    def draw_h_tree(grid, x, y, size, depth, color=3):
        if depth <= 0:
            return
        for c in range(x - size, x + size + 1):
            if 0 <= c < len(grid[0]) and 0 <= y < len(grid):
                grid[y][c] = color
        for r in range(y - size, y + size + 1):
            if 0 <= r < len(grid) and 0 <= x - size < len(grid[0]):
                grid[r][x - size] = color
            if 0 <= r < len(grid) and 0 <= x + size < len(grid[0]):
                grid[r][x + size] = color
        draw_h_tree(grid, x - size, y, size // 2, depth - 1, color)
        draw_h_tree(grid, x + size, y, size // 2, depth - 1, color)
    
    draw_h_tree(input_grid, x, y, size, depth, 3)
    output_grid = [row[:] for row in input_grid]
    
    for r in range(height):
        c = 0
        while c < width:
            if input_grid[r][c] == 3:
                start = c
                while c < width and input_grid[r][c] == 3:
                    c += 1
                seg_length = c - start
                for i in range(seg_length):
                    output_grid[r][start + i] = 3 if i % 2 == 0 else 4
            else:
                c += 1
    
    for c in range(width):
        r = 0
        while r < height:
            if input_grid[r][c] == 3:
                start = r
                while r < height and input_grid[r][c] == 3:
                    r += 1
                seg_length = r - start
                for i in range(seg_length):
                    output_grid[start + i][c] = 3 if i % 2 == 0 else 4
            else:
                r += 1
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    height = len(input_list)
    width = len(input_list[0])
    output_grid = [row[:] for row in input_list]
    
    for r in range(height):
        c = 0
        while c < width:
            if input_list[r][c] == 3:
                start = c
                while c < width and input_list[r][c] == 3:
                    c += 1
                seg_length = c - start
                for i in range(seg_length):
                    output_grid[r][start + i] = 3 if i % 2 == 0 else 4
            else:
                c += 1
    
    for c in range(width):
        r = 0
        while r < height:
            if input_list[r][c] == 3:
                start = r
                while r < height and input_list[r][c] == 3:
                    r += 1
                seg_length = r - start
                for i in range(seg_length):
                    output_grid[start + i][c] = 3 if i % 2 == 0 else 4
            else:
                r += 1
    
    return output_grid
