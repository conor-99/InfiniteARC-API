# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 454c09e7
Difficulty: mediumâ€“hard

=== Tags ===
- Boolean color logic
- Local to global rule inference

=== Description ===
Boolean Color Logic Cascade  Input grids consist of a 2D arrangement of ten
distinct colors (0-9), where each color represents a unique logical state. The
output grid is generated by applying a consistent local transformation rule
based on orthogonal neighbor relationships: for each cell, if its left neighbor
matches a specific color and its top neighbor matches another specific color,
the cell transforms into a third color; otherwise, it remains unchanged. The
rule is not explicitly stated but must be inferred from the input-output pairs
through observation of color patterns. The transformation applies simultaneously
to all cells, creating a global pattern where the logical condition propagates
across the grid. The output reveals emergent structures formed by the
accumulation of these local color transitions, such as diagonal lines, nested
shapes, or interconnected regions that visually demonstrate the inferred logic.
The task requires identifying the precise color combination that triggers the
transformation and recognizing how this local rule manifests in the global
structure of the output grid, making it medium-hard due to the need for multi-
step inference across multiple color relationships and spatial configurations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    A, B, C = 3, 7, 1
    h = random.randint(2, 30)
    w = random.randint(2, 30)
    input_grid = [[0] * w for _ in range(h)]
    
    input_grid[0][1] = B
    input_grid[1][0] = A
    input_grid[1][1] = 5
    
    for i in range(h):
        for j in range(w):
            if (i == 0 and j == 1) or (i == 1 and j == 0) or (i == 1 and j == 1):
                continue
            input_grid[i][j] = random.randint(0, 9)
    
    output_grid = [row[:] for row in input_grid]
    for i in range(1, h):
        for j in range(1, w):
            if input_grid[i][j-1] == A and input_grid[i-1][j] == B:
                output_grid[i][j] = C
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    h = len(input_list)
    w = len(input_list[0])
    A, B, C = 3, 7, 1
    output_list = [row[:] for row in input_list]
    for i in range(1, h):
        for j in range(1, w):
            if input_list[i][j-1] == A and input_list[i-1][j] == B:
                output_list[i][j] = C
    return output_list
