# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 145d7b56
Difficulty: very hard

=== Tags ===
- Nested structure detection
- Pattern sync

=== Description ===
**Task Name: Nested Wave Sync**    **Description:**    Input grids are large
(minimum 15×15) with a single background color (0). Overlaid on this background
are multiple disjoint border squares of a single border color (1), arranged in a
regular 3×3 lattice. Each border square has a uniform size (5×5), with 1–2
background cells separating adjacent squares. The lattice is aligned such that
the top-left border square touches the grid’s top-left corner, and the bottom-
right border square touches the grid’s bottom-right corner, forming a grid of
squares with consistent spacing.    Within each border square, a centered
embedded square (3×3) is filled with a unique color (2–9), distinct from the
border and background. This embedded square contains a **wave pattern** composed
of dots (color 3–9) arranged in a repeating wave-like sequence (e.g., a sine
wave with amplitude 1). The wave pattern’s orientation (horizontal, vertical,
diagonal) varies randomly per embedded square in the input. For example, a
horizontal wave pattern has dots aligned along a single row (e.g., positions
(1,0), (1,1), (1,2) in the 3×3 embedded square), while a vertical wave pattern
has dots aligned along a single column.    The **output grid** must preserve all
border squares, embedded squares, and their colors. However, the wave patterns
within each embedded square are **rotated** to align with a global
synchronization rule based on the square’s position in the lattice:    -
**Horizontal waves** (dots aligned horizontally) are required for squares in
**even-numbered rows** (0-indexed: row 0, row 2).   - **Vertical waves** (dots
aligned vertically) are required for squares in **odd-numbered rows** (row 1).
- **This rule overrides column-based rules**, so column parity is irrelevant.
Thus, the top row (i=0, even) must have horizontal waves, middle row (i=1, odd)
vertical waves, and bottom row (i=2, even) horizontal waves.    **Key
Challenges:**   1. **Nested structure detection**: The solver must identify the
lattice structure of border squares (3×3 grid) and distinguish embedded squares
within each border.   2. **Pattern sync**: For each embedded square, detect the
current wave orientation (horizontal, vertical, or diagonal) and rotate it to
match the target orientation (horizontal for even i, vertical for odd i).
Rotations must be exact (e.g., a diagonal wave must be rotated to horizontal or
vertical, not just shifted).    **Visual Cues:**   - The wave pattern is
visually distinct: horizontal waves appear as a single row of dots, vertical as
a single column, and diagonal as a line from corner to corner.   - The output
requires no additional elements—only rotation of the wave pattern within the
embedded square.    This task is **very hard** because it requires:   -
Detecting the lattice structure amid background noise (1–2 cell gaps between
squares).   - Correctly classifying the wave pattern’s current orientation (not
just a simple line, but a wave sequence).   - Applying precise rotations without
overwriting border or embedded square colors.   - Resolving ambiguities in wave
patterns (e.g., a diagonal wave may be mistaken for a horizontal/vertical one if
not carefully analyzed).    The input and output grids contain no other visual
elements besides the described structures, ensuring the task relies solely on
nested wave patterns and lattice structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

# A module-level counter ensures each call uses a different seed and helps produce unique examples
_GEN_CALL_COUNTER = 0

def generate():
    global _GEN_CALL_COUNTER
    seed = _GEN_CALL_COUNTER
    _GEN_CALL_COUNTER += 1
    rng = random.Random(seed + 1234567)

    border_size = 5
    # gap between 5x5 border squares can be 1 or 2
    gap = rng.choice([1, 2])
    size = border_size * 3 + gap * 2

    # Initialize background
    grid = [[0 for _ in range(size)] for _ in range(size)]

    # Draw 3x3 lattice of border squares (outline of size 5x5)
    for i in range(3):
        for j in range(3):
            top = i * (border_size + gap)
            left = j * (border_size + gap)
            for r in range(top, top + border_size):
                for c in range(left, left + border_size):
                    # outline only (1-pixel thick border)
                    if r == top or r == top + border_size - 1 or c == left or c == left + border_size - 1:
                        grid[r][c] = 1

    # Choose embedded-square background colors (2..9). Duplicates allowed.
    embed_bg_colors = [rng.randint(2, 9) for _ in range(9)]

    # Choose dot colors for each embedded square, distinct from that square's background if possible
    dot_colors = []
    for idx in range(9):
        bg = embed_bg_colors[idx]
        choices = [c for c in range(2, 10) if c != bg]
        if not choices:
            dot_colors.append(bg)
        else:
            dot_colors.append(rng.choice(choices))

    # Randomly choose initial orientations for each embedded square: 'h','v','d1','d2'
    orientations = [rng.choice(['h', 'v', 'd1', 'd2']) for _ in range(9)]

    # Ensure at least one embedded square will need rotating (so input != output)
    targets = ['h' if (idx // 3) % 2 == 0 else 'v' for idx in range(9)]
    if all(orientations[idx] == targets[idx] for idx in range(9)):
        pick = rng.randint(0, 8)
        # choose an orientation that is different from the target
        options = ['h', 'v', 'd1', 'd2']
        options.remove(targets[pick])
        orientations[pick] = rng.choice(options)

    # Fill embedded squares (centered 3x3) with background color and overlay the wave dots
    for idx in range(9):
        i = idx // 3
        j = idx % 3
        top = i * (border_size + gap)
        left = j * (border_size + gap)
        top_in = top + 1
        left_in = left + 1

        bg = embed_bg_colors[idx]
        dot = dot_colors[idx]
        ori = orientations[idx]

        # Fill 3x3 interior with background color
        for dr in range(3):
            for dc in range(3):
                grid[top_in + dr][left_in + dc] = bg

        # Overlay dots according to orientation
        if ori == 'h':
            rdot = top_in + 1
            for dc in range(3):
                grid[rdot][left_in + dc] = dot
        elif ori == 'v':
            cdot = left_in + 1
            for dr in range(3):
                grid[top_in + dr][cdot] = dot
        elif ori == 'd1':
            for off in range(3):
                grid[top_in + off][left_in + off] = dot
        else:  # 'd2'
            for off in range(3):
                grid[top_in + off][left_in + (2 - off)] = dot

    # Build the output grid by rotating each embedded wave to the row-parity target
    output = [row[:] for row in grid]
    for idx in range(9):
        i = idx // 3
        j = idx % 3
        top = i * (border_size + gap)
        left = j * (border_size + gap)
        top_in = top + 1
        left_in = left + 1
        bg = embed_bg_colors[idx]
        dot = dot_colors[idx]
        target = 'h' if i % 2 == 0 else 'v'

        # Reset interior to background and draw target wave pattern
        for dr in range(3):
            for dc in range(3):
                output[top_in + dr][left_in + dc] = bg
        if target == 'h':
            rdot = top_in + 1
            for dc in range(3):
                output[rdot][left_in + dc] = dot
        else:
            cdot = left_in + 1
            for dr in range(3):
                output[top_in + dr][cdot] = dot

    return {'input': grid, 'output': output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    from collections import Counter, deque
    # Convert input (tuple of tuples) to mutable list of lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0]) if h > 0 else 0

    # Find connected components of border color (1) using 4-connectivity
    visited = [[False] * w for _ in range(h)]
    components = []  # list of lists of (r,c)
    for r in range(h):
        for c in range(w):
            if grid[r][c] != 1 or visited[r][c]:
                continue
            # BFS/DFS to collect component
            q = deque()
            q.append((r, c))
            visited[r][c] = True
            comp = []
            while q:
                rr, cc = q.popleft()
                comp.append((rr, cc))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] == 1:
                        visited[nr][nc] = True
                        q.append((nr, nc))
            components.append(comp)

    # Compute bounding boxes for components (expect 9 border squares)
    boxes = []
    for comp in components:
        rs = [p[0] for p in comp]
        cs = [p[1] for p in comp]
        top = min(rs)
        left = min(cs)
        bottom = max(rs)
        right = max(cs)
        boxes.append((top, left, bottom, right))

    # Sort boxes by top then left so they map to lattice order
    boxes.sort(key=lambda x: (x[0], x[1]))

    if not boxes:
        return grid

    # Determine the three distinct top positions (rows of the lattice)
    unique_tops = sorted(list({b[0] for b in boxes}))

    # Process each border square: identify embedded 3x3, detect wave orientation, and rotate if needed
    for top, left, bottom, right in boxes:
        # The inner 3x3 region starts at top+1,left+1
        top_in = top + 1
        left_in = left + 1
        # Defensive bounds check
        if top_in + 2 >= h or left_in + 2 >= w:
            continue

        # Collect interior colors
        interior = []
        for dr in range(3):
            for dc in range(3):
                interior.append(grid[top_in + dr][left_in + dc])
        # Determine background color of the embedded square (most common color in the 3x3)
        cnt = Counter(interior)
        # Choose the most common color as the embedded background
        embed_bg, _ = cnt.most_common(1)[0]

        # Identify dot positions (cells that differ from background)
        dot_positions = []
        dot_color = None
        for dr in range(3):
            for dc in range(3):
                val = grid[top_in + dr][left_in + dc]
                if val != embed_bg:
                    dot_positions.append((dr, dc))
                    if dot_color is None:
                        dot_color = val

        # If there are no dots detected, skip
        if not dot_positions or dot_color is None:
            continue

        # Classify current orientation
        orientation = None
        if all(dr == dot_positions[0][0] for dr, dc in dot_positions):
            orientation = 'h'
        elif all(dc == dot_positions[0][1] for dr, dc in dot_positions):
            orientation = 'v'
        elif all(dr == dc for dr, dc in dot_positions):
            orientation = 'd1'
        elif all(dr + dc == 2 for dr, dc in dot_positions):
            orientation = 'd2'
        else:
            # fallback: if the three dots form any line, try to detect approximate horizontal/vertical
            rows = [p[0] for p in dot_positions]
            cols = [p[1] for p in dot_positions]
            if len(set(rows)) == 1:
                orientation = 'h'
            elif len(set(cols)) == 1:
                orientation = 'v'
            else:
                orientation = 'unknown'

        # Determine the row index in the lattice based on the top coordinate
        try:
            row_index = unique_tops.index(top)
        except ValueError:
            # If top isn't found, approximate by comparing to unique_tops
            # Fallback: find nearest top
            diffs = [(abs(top - ut), ut) for ut in unique_tops]
            diffs.sort()
            row_index = unique_tops.index(diffs[0][1])

        target = 'h' if (row_index % 2 == 0) else 'v'

        # If orientation already matches target, do nothing
        if orientation == target:
            continue

        # Otherwise, rewrite the interior: fill with background then draw the target wave with the original dot color
        for dr in range(3):
            for dc in range(3):
                grid[top_in + dr][left_in + dc] = embed_bg

        if target == 'h':
            rdot = top_in + 1
            for dc in range(3):
                grid[rdot][left_in + dc] = dot_color
        else:
            cdot = left_in + 1
            for dr in range(3):
                grid[top_in + dr][cdot] = dot_color

    return grid

