# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 8929c849
Difficulty: insane

=== Tags ===
- Connect components by property
- Temporal wave step
- Sort colors by index

=== Description ===
**Task Description: Temporal Wave Connector**  Input grids are 25×25 to 30×30
grids with background color 0. The grid contains 6–10 disconnected, non-
overlapping components, each a contiguous 4-connected region of a unique color
(1–9). Each component has a distinct size (3–15 cells) and is surrounded by
background (color 0). Components do not touch diagonally or orthogonally.  The
output grid transforms the input by: 1. **Sorting components by color index**
(ascending order: color 1, then 2, ..., up to the highest color present). 2.
**Connecting consecutive sorted components** with a wave path. For components
*Cᵢ* (color *i*) and *Cᵢ₊₁* (color *i+1*):    - The wave path starts at the
**rightmost cell** of the **topmost row** in *Cᵢ* and ends at the **leftmost
cell** of the **bottommost row** in *Cᵢ₊₁*.    - The path follows a **diagonal
wave pattern**: it moves right-up, right-down, right-up, etc., alternating
directions while stepping diagonally toward the target component. Each "wave
step" adds one cell to the path, ensuring the path avoids all non-background
cells (components, other paths) and remains on background.    - The path is
drawn using the **color of the starting component** (*i*), replacing background
cells (0) with *i*. 3. **No path overlaps** with existing components, other
paths, or the grid boundary. All paths are minimal-length wave sequences that
connect the designated start/end points without crossing.  The output grid
retains all original components unchanged, with wave paths added as described.
The wave pattern creates a visually distinct, non-orthogonal, alternating
diagonal path between each consecutive component pair in the sorted order. The
complexity arises from the need to sort components by color, precisely compute
start/end points for paths, and generate the wave pattern without violating
adjacency constraints.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = random.randint(25, 30)
    height = random.randint(25, 30)
    grid = common.grid(width, height, 0)
    num_components = random.randint(6, 9)
    colors = random.sample(range(1, 10), num_components)
    colors.sort()
    for color in colors:
        size = random.randint(3, 15)
        placed = False
        while not placed:
            r = random.randint(0, height - 1)
            c = random.randint(0, width - 1)
            pixels = [(r, c)]
            queue = [(r, c)]
            while len(pixels) < size:
                if not queue:
                    break
                r, c = random.choice(queue)
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0 and (nr, nc) not in pixels:
                        pixels.append((nr, nc))
                        queue.append((nr, nc))
                        if len(pixels) == size:
                            break
                if len(pixels) == size:
                    break
                queue.pop(0)
            if len(pixels) < size:
                continue
            valid = True
            for (r, c) in pixels:
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                        valid = False
                        break
                if not valid:
                    break
            if not valid:
                continue
            for (r, c) in pixels:
                grid[r][c] = color
            placed = True
    output = [row[:] for row in grid]
    components = {}
    for color in colors:
        comp = []
        for r in range(height):
            for c in range(width):
                if grid[r][c] == color:
                    comp.append((r, c))
        components[color] = comp
    sorted_components = [components[color] for color in colors]
    for i in range(len(sorted_components) - 1):
        comp1 = sorted_components[i]
        comp2 = sorted_components[i+1]
        top_row = min(r for r, c in comp1)
        start_col = max(c for r, c in comp1 if r == top_row)
        start = (top_row, start_col)
        bottom_row = max(r for r, c in comp2)
        end_col = min(c for r, c in comp2 if r == bottom_row)
        end = (bottom_row, end_col)
        r1, c1 = start
        r2, c2 = end
        k = c1 - c2
        current_r, current_c = r1, c1
        for step in range(k):
            if step % 2 == 0:
                current_r -= 1
            else:
                current_r += 1
            current_c -= 1
            if 0 <= current_r < height and 0 <= current_c < width and output[current_r][current_c] == 0:
                output[current_r][current_c] = colors[i]
    return {'input': grid, 'output': output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to list of lists
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    components = {}
    for color in range(1, 10):
        comp = []
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == color:
                    comp.append((r, c))
        if comp:
            components[color] = comp
    colors = sorted(components.keys())
    sorted_components = [components[color] for color in colors]
    output = [row[:] for row in input_grid]
    for i in range(len(sorted_components) - 1):
        comp1 = sorted_components[i]
        comp2 = sorted_components[i+1]
        top_row = min(r for r, c in comp1)
        start_col = max(c for r, c in comp1 if r == top_row)
        start = (top_row, start_col)
        bottom_row = max(r for r, c in comp2)
        end_col = min(c for r, c in comp2 if r == bottom_row)
        end = (bottom_row, end_col)
        r1, c1 = start
        r2, c2 = end
        k = c1 - c2
        current_r, current_c = r1, c1
        for step in range(k):
            if step % 2 == 0:
                current_r -= 1
            else:
                current_r += 1
            current_c -= 1
            if 0 <= current_r < height and 0 <= current_c < width and output[current_r][current_c] == 0:
                output[current_r][current_c] = colors[i]
    return output
