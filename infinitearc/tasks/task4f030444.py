# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 4f030444
Difficulty: insane

=== Tags ===
- Route switching
- Wave reflection
- Fractal growth
- Relational projection
- Associate images to bools

=== Description ===
Input grids are large (20×20 or larger) with a single background color (0). The
grid contains four key components: **source cells** (color 1) along the left
edge initiating rightward waves; **reflector cells** (colors 2–5) altering wave
direction upon collision (color 2: up, 3: down, 4: left, 5: right); **fractal
seeds** (colors 6–8) triggering wave splitting when struck; and a **relation
map** (color 9) of sparse directional indicators.   Wave propagation follows
strict rules: Waves originate from sources, moving right until hitting a
reflector or seed. Reflectors change direction per their color. Fractal seeds
split waves into two new paths, with directions determined by the **nearest
relation map cell** (e.g., a map cell pointing "up-right" causes one wave to
travel up and the other right). Each new wave recursively follows these rules,
generating nested fractal paths.   The output grid draws all paths using
**source color (1)** for primary paths and **seed color (6–8)** for fractal
branches. Paths occupy only background cells (0), never overwriting reflectors,
seeds, or the relation map. The relation map remains visible. Fractal growth
terminates when paths exit the grid or no further splits occur.   **Relational
projection** defines split directions via the relation map’s spatial
relationships (e.g., a map cell at (r,c) with a neighbor at (r-1,c+1) implies
up-right splitting). **Associate images to bools** means each fractal seed (a
2×2 block of color 6–8) is an "image" associated with a boolean (true for
presence, triggering splits), while the relation map encodes directional "bools"
(e.g., map configuration dictates split vectors). Wave reflection and route
switching govern directional changes, while fractal growth recursively expands
paths from seeds. No numerical computations or pixel-by-pixel matching are
used—only visual pattern recognition and relational logic.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = random.randint(20,25)
    height = random.randint(20,25)
    grid = common.grid(width, height, 0)

    # Place sources along left edge (column 0), avoid the absolute top/bottom row
    rows_available = list(range(1, height-1))
    n_sources = random.randint(2, min(6, len(rows_available)))
    source_rows = random.sample(rows_available, n_sources)
    for r in source_rows:
        grid[r][0] = 1

    # Place fractal seeds (2x2 blocks) in columns >=2 to avoid immediate blocking of sources
    seeds = []  # list of (tl_r, tl_c, color)
    max_seeds = random.randint(2,5)
    attempts = 0
    while len(seeds) < max_seeds and attempts < 200:
        attempts += 1
        tl_r = random.randint(1, height-2)
        tl_c = random.randint(2, width-2)  # ensure at least column 2 so col1 stays free for sources
        if tl_r + 1 >= height or tl_c + 1 >= width:
            continue
        # ensure 2x2 area is free
        if (grid[tl_r][tl_c] != 0 or grid[tl_r][tl_c+1] != 0 or
            grid[tl_r+1][tl_c] != 0 or grid[tl_r+1][tl_c+1] != 0):
            continue
        color = random.choice([6,7,8])
        grid[tl_r][tl_c] = color
        grid[tl_r][tl_c+1] = color
        grid[tl_r+1][tl_c] = color
        grid[tl_r+1][tl_c+1] = color
        seeds.append((tl_r, tl_c, color))

    # Place reflectors (colors 2-5) not in column 0 or 1 and not on seeds
    reflector_cells = []
    n_reflectors = random.randint(6, 14)
    candidates = [(r,c) for r in range(0,height) for c in range(2,width) if grid[r][c]==0]
    random.shuffle(candidates)
    for (r,c) in candidates[:n_reflectors]:
        grid[r][c] = random.choice([2,3,4,5])
        reflector_cells.append((r,c))

    # Place sparse relation map cells (9), avoid column 1 to keep source path clear
    n_rel = random.randint(4, 12)
    candidates = [(r,c) for r in range(0,height) for c in range(0,width) if grid[r][c]==0 and c!=1]
    random.shuffle(candidates)
    for (r,c) in candidates[:n_rel]:
        grid[r][c] = 9

    # Helper structures for simulation
    reflect_dir = {2:(-1,0), 3:(1,0), 4:(0,-1), 5:(0,1)}

    # Build seeds_map: map any cell of a seed to its top-left and its color
    seeds_map = {}
    for (tl_r, tl_c, color) in seeds:
        for dr in (0,1):
            for dc in (0,1):
                seeds_map[(tl_r+dr, tl_c+dc)] = ((tl_r, tl_c), color)

    relation_positions = [(r,c) for r in range(height) for c in range(width) if grid[r][c] == 9]

    # Find sources
    sources = sorted([(r,0) for r in range(height) if grid[r][0] == 1])

    # Output starts as a copy of input
    output = [row[:] for row in grid]

    from collections import deque
    waves = deque()
    # initialize waves from sources moving right
    for (r,c) in sources:
        waves.append((r, c, 0, 1, 1))  # r,c,dr,dc,color

    visited = set()

    def clamp(x, a, b):
        return max(a, min(b, x))

    while waves:
        r,c,dr,dc,color = waves.popleft()
        key = (r,c,dr,dc,color)
        if key in visited:
            continue
        visited.add(key)

        nr = r + dr
        nc = c + dc
        # bounds
        if not (0 <= nr < height and 0 <= nc < width):
            continue

        val = grid[nr][nc]
        if val == 0:
            # draw path color on background cell (do not overwrite non-bg)
            output[nr][nc] = color
            # continue from new position in same direction
            waves.append((nr, nc, dr, dc, color))
            continue

        # non-background encountered
        if val in reflect_dir:
            new_dr, new_dc = reflect_dir[val]
            # change direction, stay at same position
            waves.append((r, c, new_dr, new_dc, color))
            continue

        if val in (6,7,8):
            # hit a fractal seed: find its top-left and color
            (tl_r, tl_c), seed_color = seeds_map.get((nr,nc), (None, None))
            if tl_r is None:
                # should not happen but skip defensively
                continue
            # compute center and find nearest relation (9)
            center_r = tl_r + 0.5
            center_c = tl_c + 0.5
            if relation_positions:
                nearest = min(relation_positions, key=lambda pos: abs(pos[0]-center_r)+abs(pos[1]-center_c))
                rel_r, rel_c = nearest
                drf = rel_r - center_r
                dcf = rel_c - center_c
            else:
                drf, dcf = 1, 1
            # determine split directions by sign of drf, dcf
            dirs = []
            if drf < 0: dirs.append((-1,0))
            if drf > 0: dirs.append((1,0))
            if dcf < 0: dirs.append((0,-1))
            if dcf > 0: dirs.append((0,1))
            # ensure at least two directions
            if len(dirs) == 0:
                dirs = [(0,1),(1,0)]
            elif len(dirs) == 1:
                if dirs[0][0] != 0:
                    dirs.append((0,1))
                else:
                    dirs.append((1,0))
            # spawn new waves from inside-seed cell adjacent to outbound direction
            for ddr, ddc in dirs:
                if (ddr,ddc) == (-1,0):
                    inside_r = tl_r
                    inside_c = clamp(nc, tl_c, tl_c+1)
                elif (ddr,ddc) == (1,0):
                    inside_r = tl_r + 1
                    inside_c = clamp(nc, tl_c, tl_c+1)
                elif (ddr,ddc) == (0,-1):
                    inside_c = tl_c
                    inside_r = clamp(nr, tl_r, tl_r+1)
                else: # (0,1)
                    inside_c = tl_c + 1
                    inside_r = clamp(nr, tl_r, tl_r+1)
                waves.append((inside_r, inside_c, ddr, ddc, seed_color))
            continue

        # other non-background (including relation map 9 or source 1): stop
        continue

    return {'input': grid, 'output': output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # detect seeds (2x2 blocks of same color 6,7,8)
    seeds = []
    seen_tl = set()
    for r in range(height-1):
        for c in range(width-1):
            val = grid[r][c]
            if val in (6,7,8) and grid[r][c+1]==val and grid[r+1][c]==val and grid[r+1][c+1]==val:
                if (r,c) not in seen_tl:
                    seeds.append((r,c,val))
                    seen_tl.add((r,c))

    # map each seed cell to its top-left and color
    seeds_map = {}
    for (tl_r, tl_c, color) in seeds:
        for dr in (0,1):
            for dc in (0,1):
                seeds_map[(tl_r+dr, tl_c+dc)] = ((tl_r, tl_c), color)

    # relation positions
    relation_positions = [(r,c) for r in range(height) for c in range(width) if grid[r][c] == 9]

    reflect_dir = {2:(-1,0), 3:(1,0), 4:(0,-1), 5:(0,1)}

    # sources on left edge
    sources = sorted([(r,0) for r in range(height) if grid[r][0] == 1])

    output = [row[:] for row in grid]

    from collections import deque
    waves = deque()
    for (r,c) in sources:
        waves.append((r,c,0,1,1))

    visited = set()
    def clamp(x,a,b):
        return max(a, min(b, x))

    while waves:
        r,c,dr,dc,color = waves.popleft()
        key = (r,c,dr,dc,color)
        if key in visited:
            continue
        visited.add(key)

        nr = r + dr
        nc = c + dc
        if not (0 <= nr < height and 0 <= nc < width):
            continue

        val = grid[nr][nc]
        if val == 0:
            output[nr][nc] = color
            waves.append((nr,nc,dr,dc,color))
            continue
        if val in reflect_dir:
            new_dr,new_dc = reflect_dir[val]
            waves.append((r,c,new_dr,new_dc,color))
            continue
        if val in (6,7,8):
            pair = seeds_map.get((nr,nc))
            if pair is None:
                continue
            (tl_r, tl_c), seed_color = pair
            center_r = tl_r + 0.5
            center_c = tl_c + 0.5
            if relation_positions:
                nearest = min(relation_positions, key=lambda pos: abs(pos[0]-center_r)+abs(pos[1]-center_c))
                rel_r, rel_c = nearest
                drf = rel_r - center_r
                dcf = rel_c - center_c
            else:
                drf, dcf = 1, 1
            dirs = []
            if drf < 0: dirs.append((-1,0))
            if drf > 0: dirs.append((1,0))
            if dcf < 0: dirs.append((0,-1))
            if dcf > 0: dirs.append((0,1))
            if len(dirs) == 0:
                dirs = [(0,1),(1,0)]
            elif len(dirs) == 1:
                if dirs[0][0] != 0:
                    dirs.append((0,1))
                else:
                    dirs.append((1,0))
            for ddr, ddc in dirs:
                if (ddr,ddc) == (-1,0):
                    inside_r = tl_r
                    inside_c = clamp(nc, tl_c, tl_c+1)
                elif (ddr,ddc) == (1,0):
                    inside_r = tl_r + 1
                    inside_c = clamp(nc, tl_c, tl_c+1)
                elif (ddr,ddc) == (0,-1):
                    inside_c = tl_c
                    inside_r = clamp(nr, tl_r, tl_r+1)
                else:
                    inside_c = tl_c + 1
                    inside_r = clamp(nr, tl_r, tl_r+1)
                waves.append((inside_r, inside_c, ddr, ddc, seed_color))
            continue
        continue

    return output

