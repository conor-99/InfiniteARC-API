# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 3361a400
Difficulty: hard

=== Tags ===
- Cut and unfold
- Perimeter smoothing
- Pattern reflection

=== Description ===
Input grids are rectangular (e.g., 20×20) with a single background color (0).
The grid contains a shape composed of non-background colors (1–9) and a distinct
cut line (marked with color 5) that spans the grid as a continuous vertical or
horizontal line. The shape is present on one side of the cut line, with the
other side entirely background. The cut line itself is a solid line of color 5
that may not align with grid boundaries (e.g., starting or ending mid-cell),
requiring the solver to infer its exact position.  The output grid is generated
through two sequential transformations:  1. **Unfolding**: The shape is
reflected across the inferred cut line to form a symmetrical whole. For a
vertical cut line, the right side of the grid is mirrored from the left side
(e.g., column *c + d* reflects *c - d*). For a horizontal cut line, the bottom
side mirrors the top side. Reflections are applied to all non-background cells,
preserving their colors and relative positions relative to the cut line.  2.
**Perimeter Smoothing**: After unfolding, the perimeter is smoothed by
eliminating "jagged protrusions." A cell is identified as a jagged protrusion if
it is part of the shape, adjacent to background (i.e., on the perimeter), and
has exactly one neighbor in the shape (forming a sharp corner). These cells are
set to background (0), removing sharp angles and creating a smoother, more
continuous outline. This step requires iterative analysis of perimeter
connectivity and careful distinction between true shape features and artifacts
of the reflection.  The task demands precise identification of the cut line's
position, accurate reflection across a potentially non-grid-aligned line, and
nuanced application of perimeter smoothing rules to distinguish between
intentional shape features and jagged edge artifacts. The complexity arises from
the need to handle both geometric reflection and topological smoothing in a
single coherent process.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    cut_direction = random.choice(['vertical', 'horizontal'])
    if cut_direction == 'vertical':
        cut_x = random.randint(1, width // 2 - 1)
        size = random.randint(5, min(20, cut_x * height))
        pixels = common.continuous_creature(size, cut_x, height)
        rows = [p[0] for p in pixels]
        cols = [p[1] for p in pixels]
        input_grid = common.grid(width, height, 0)
        for r, c in zip(rows, cols):
            input_grid[r][c] = common.random_color(exclude=[0, 5])
        for r in range(height):
            input_grid[r][cut_x] = 5
        output_grid = common.grid(width, height, 0)
        for r in range(height):
            output_grid[r][cut_x] = 5
        for r, c in zip(rows, cols):
            refl_c = 2 * cut_x - c
            output_grid[r][refl_c] = input_grid[r][c]
        smoothed = [row[:] for row in output_grid]
        for r in range(height):
            for c in range(width):
                if smoothed[r][c] in (0, 5):
                    continue
                perimeter = False
                for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and smoothed[nr][nc] == 0:
                        perimeter = True
                        break
                if not perimeter:
                    continue
                neighbors = 0
                for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and smoothed[nr][nc] not in (0, 5):
                        neighbors += 1
                if neighbors == 1:
                    smoothed[r][c] = 0
        return {'input': input_grid, 'output': smoothed}
    else:
        cut_y = random.randint(1, height // 2 - 1)
        size = random.randint(5, min(20, width * cut_y))
        pixels = common.continuous_creature(size, width, cut_y)
        rows = [p[0] for p in pixels]
        cols = [p[1] for p in pixels]
        input_grid = common.grid(width, height, 0)
        for r, c in zip(rows, cols):
            input_grid[r][c] = common.random_color(exclude=[0, 5])
        for c in range(width):
            input_grid[cut_y][c] = 5
        output_grid = common.grid(width, height, 0)
        for c in range(width):
            output_grid[cut_y][c] = 5
        for r, c in zip(rows, cols):
            refl_r = 2 * cut_y - r
            output_grid[refl_r][c] = input_grid[r][c]
        smoothed = [row[:] for row in output_grid]
        for r in range(height):
            for c in range(width):
                if smoothed[r][c] in (0, 5):
                    continue
                perimeter = False
                for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and smoothed[nr][nc] == 0:
                        perimeter = True
                        break
                if not perimeter:
                    continue
                neighbors = 0
                for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and smoothed[nr][nc] not in (0, 5):
                        neighbors += 1
                if neighbors == 1:
                    smoothed[r][c] = 0
        return {'input': input_grid, 'output': smoothed}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    cut_direction = None
    cut_pos = None
    for c in range(width):
        if all(grid[r][c] == 5 for r in range(height)):
            cut_direction = 'vertical'
            cut_pos = c
            break
    if cut_direction is None:
        for r in range(height):
            if all(grid[r][c] == 5 for c in range(width)):
                cut_direction = 'horizontal'
                cut_pos = r
                break
    if cut_direction is None:
        raise ValueError('Cut line not found')
    output = common.grid(width, height, 0)
    if cut_direction == 'vertical':
        for r in range(height):
            output[r][cut_pos] = 5
        shape = []
        for r in range(height):
            for c in range(cut_pos):
                if grid[r][c] != 0 and grid[r][c] != 5:
                    shape.append((r, c))
        for r, c in shape:
            refl_c = 2 * cut_pos - c
            output[r][refl_c] = grid[r][c]
    else:
        for c in range(width):
            output[cut_pos][c] = 5
        shape = []
        for r in range(cut_pos):
            for c in range(width):
                if grid[r][c] != 0 and grid[r][c] != 5:
                    shape.append((r, c))
        for r, c in shape:
            refl_r = 2 * cut_pos - r
            output[refl_r][c] = grid[r][c]
    smoothed = [row[:] for row in output]
    for r in range(height):
        for c in range(width):
            if smoothed[r][c] in (0, 5):
                continue
            perimeter = False
            for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and smoothed[nr][nc] == 0:
                    perimeter = True
                    break
            if not perimeter:
                continue
            neighbors = 0
            for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and smoothed[nr][nc] not in (0, 5):
                    neighbors += 1
            if neighbors == 1:
                smoothed[r][c] = 0
    return smoothed
