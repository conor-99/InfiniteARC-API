# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 522f5f84
Difficulty: insane

=== Tags ===
- Reflect by color
- Shape morphing
- Color signal exchange
- Propagation by rule weight

=== Description ===
Reflective Morphology Exchange  Input grids feature multiple distinct, non-
overlapping colored shapes (each shape is a connected region of uniform color
from 1-9, with 0 representing background). Shapes are surrounded by background
and do not touch other shapes. Each shape has a unique color that determines its
reflection axis, growth direction, and interaction rules.  The output grid is
generated through a sequence of four transformations applied in strict priority
order (highest to lowest weight):  1. **Reflect by Color**: Each shape is
reflected across an axis determined by its color value:    - Color 1 (Blue):
Horizontal reflection (mirroring across vertical midline)    - Color 2 (Red):
Vertical reflection (mirroring across horizontal midline)    - Color 3 (Green):
Main diagonal reflection (top-left to bottom-right)    - Color 4 (Yellow): Anti-
diagonal reflection (top-right to bottom-left)    - Colors 5-9: No reflection
(identity transformation)     Reflections are calculated relative to the shape's
position, with new positions placed to avoid overlapping existing shapes.  2.
**Shape Morphing**: After reflection, each shape expands outward by one cell in
the direction toward the nearest adjacent shape of a primary color (colors 1, 2,
or 3). Expansion occurs only at the perimeter closest to the primary color,
adding cells while maintaining connectivity.  3. **Color Signal Exchange**: For
every pair of adjacent shapes sharing an edge, if one is primary (1, 2, 3) and
the other is secondary (4-9), their colors are swapped simultaneously. Secondary
colors (4-9) never initiate exchanges, only respond to primary colors.  4.
**Propagation by Rule Weight**: All transformations are applied in strict
priority order (reflection weight 4 → morphing weight 3 → exchange weight 2).
When multiple rules apply to a single cell, higher-weight rules take precedence.
Color exchanges occur before morphing is finalized, creating cascading
interactions.  The output grid contains all transformed shapes with no overlaps,
background unchanged except where modified by color exchanges, and all shapes
positioned to maintain separation from other shapes. The transformation sequence
creates complex visual patterns where reflection axes, growth directions, and
color swaps interact in non-linear ways, requiring simultaneous consideration of
multiple overlapping rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, rand_sprite


def _reflect_point(pt, color, size):
    r, c = pt
    if color == 1:
        return (r, size - 1 - c)
    if color == 2:
        return (size - 1 - r, c)
    if color == 3:
        return (c, r)
    if color == 4:
        # reflect across the anti-diagonal (r+c = N-1)
        return (size - 1 - c, size - 1 - r)
    return (r, c)


def _manhattan(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])


def _components_from_grid(g):
    h = len(g)
    w = len(g[0])
    visited = [[False] * w for _ in range(h)]
    comps = []
    cell_to_comp = {}
    for r in range(h):
        for c in range(w):
            if g[r][c] == 0 or visited[r][c]:
                continue
            color = g[r][c]
            stack = [(r, c)]
            visited[r][c] = True
            cells = []
            min_r, min_c = r, c
            while stack:
                x, y = stack.pop()
                cells.append((x, y))
                if x < min_r or (x == min_r and y < min_c):
                    min_r, min_c = x, y
                for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nx, ny = x + dx, y + dy
                    if 0 <= nx < h and 0 <= ny < w and not visited[nx][ny] and g[nx][ny] == color:
                        visited[nx][ny] = True
                        stack.append((nx, ny))
            comp_id = len(comps)
            for cell in cells:
                cell_to_comp[cell] = comp_id
            comps.append({
                'id': comp_id,
                'color': color,
                'cells': set(cells),
                'top_left': (min_r, min_c)
            })
    return comps, cell_to_comp


def generate():
    # We'll keep trying until we produce a grid where the output differs from input
    tries = 0
    while True:
        tries += 1
        size = random.randint(10, 15)
        input_grid = grid(size, size, 0)
        occupied = set()
        shapes = []  # list of dicts: {color:int, cells:set((r,c))}

        # Helper to check adjacency (4-neighborhood)
        def touches_any(cells, occupied_set):
            for (r, c) in cells:
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    if (r + dr, c + dc) in occupied_set:
                        return True
            return False

        # Place a primary shape S1 that will be reflected and a secondary S2 placed near its reflection
        placed_ok = False
        place_attempts = 0
        while not placed_ok and place_attempts < 300:
            place_attempts += 1
            # create a small random sprite
            name = random.choice(['el', 'you', 'aitch'])
            pattern = rand_sprite(name, 3, 3)
            color1 = random.choice([1, 2, 3])
            # choose a candidate origin that keeps the shape away from borders a bit
            max_r = max(p[0] for p in pattern)
            max_c = max(p[1] for p in pattern)
            r0 = random.randint(1, size - 1 - max_r)
            c0 = random.randint(1, size - 1 - max_c)
            s1_cells = set((r0 + r, c0 + c) for (r, c) in pattern)
            # make sure not colliding
            if any((r, c) in occupied for (r, c) in s1_cells):
                continue
            # compute reflection positions of S1
            m1 = set(_reflect_point(p, color1, size) for p in s1_cells)
            # ensure reflected area is at least a few cells away from original to avoid accidental identical grids
            min_dist = min(_manhattan(a, b) for a in s1_cells for b in m1)
            if min_dist < 3:
                continue
            # choose a delta so that S2 (secondary) will be placed adjacent to the reflection m1
            deltas = [(1, 0), (-1, 0), (0, 1), (0, -1)]
            random.shuffle(deltas)
            found_s2 = False
            for dr, dc in deltas:
                s2_cells = set((r + dr, c + dc) for (r, c) in m1)
                # must be inside grid
                if any(not (0 <= rr < size and 0 <= cc < size) for rr, cc in s2_cells):
                    continue
                # must not overlap or touch S1
                if s2_cells & s1_cells:
                    continue
                if touches_any(s2_cells, s1_cells):
                    # they would be adjacent initially - skip (shapes must be separated initially)
                    continue
                # must not overlap any other occupied (none yet)
                if any(cell in occupied for cell in s2_cells):
                    continue
                # Accept this placement
                color2 = random.choice([x for x in range(4, 10)])
                # finalize placement
                shapes.append({'color': color1, 'cells': s1_cells})
                for (rr, cc) in s1_cells:
                    input_grid[rr][cc] = color1
                    occupied.add((rr, cc))
                shapes.append({'color': color2, 'cells': s2_cells})
                for (rr, cc) in s2_cells:
                    input_grid[rr][cc] = color2
                    occupied.add((rr, cc))
                found_s2 = True
                placed_ok = True
                break
            # if no s2 placement found continue trying new origin
        if not placed_ok:
            # fall back - try next overall attempt
            if tries > 100:
                # as a last resort place two simple blocks to ensure change
                size = 10
                input_grid = grid(size, size, 0)
                shapes = []
                occupied = set()
                shapes.append({'color': 1, 'cells': set([(2, 2), (2, 3), (3, 2), (3, 3)])})
                shapes.append({'color': 4, 'cells': set([(6, 6), (6, 7), (7, 6), (7, 7)])})
                for s in shapes:
                    for (rr, cc) in s['cells']:
                        input_grid[rr][cc] = s['color']
            else:
                continue

        # Now add 0-2 extra random shapes (unique colors) that do not touch existing shapes
        available_colors = [c for c in range(1, 10) if c not in [s['color'] for s in shapes]]
        extra_count = random.randint(0, 2)
        add_attempts = 0
        while extra_count > 0 and add_attempts < 400 and available_colors:
            add_attempts += 1
            name = random.choice(['el', 'you', 'aitch'])
            pattern = rand_sprite(name, 3, 3)
            max_r = max(p[0] for p in pattern)
            max_c = max(p[1] for p in pattern)
            r0 = random.randint(0, size - 1 - max_r)
            c0 = random.randint(0, size - 1 - max_c)
            scells = set((r0 + r, c0 + c) for (r, c) in pattern)
            if any(cell in occupied for cell in scells):
                continue
            # ensure not touching
            if touches_any(scells, occupied):
                continue
            # place
            colorx = available_colors.pop(random.randrange(len(available_colors)))
            shapes.append({'color': colorx, 'cells': scells})
            for (rr, cc) in scells:
                input_grid[rr][cc] = colorx
                occupied.add((rr, cc))
            extra_count -= 1

        # At this point we have an input grid with separated shapes
        # Apply the transformation pipeline to produce the output
        output_grid = [row[:] for row in input_grid]

        # Step 1: Reflection
        # Sort shapes by top-left so reflection overlay order is deterministic and matches solver
        def _top_left_of_shape(s):
            mr = min(r for r, _ in s['cells'])
            mc = min(c for _, c in s['cells'])
            return (mr, mc)
        shapes_sorted = sorted(shapes, key=_top_left_of_shape)

        for s in shapes_sorted:
            color = s['color']
            for (r, c) in s['cells']:
                nr, nc = _reflect_point((r, c), color, size)
                if 0 <= nr < size and 0 <= nc < size and output_grid[nr][nc] == 0:
                    output_grid[nr][nc] = color

        # Step 2&3: Color Signal Exchange (we'll treat exchange as happening before morphing finalization)
        comps, cell_to_comp = _components_from_grid(output_grid)
        # build adjacency edges
        edges = []  # list of (primary_id, secondary_id)
        for comp in comps:
            cid = comp['id']
            col = comp['color']
            for (r, c) in comp['cells']:
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < size and 0 <= nc < size and (nr, nc) in cell_to_comp:
                        other = cell_to_comp[(nr, nc)]
                        if other == cid:
                            continue
                        other_col = comps[other]['color']
                        # primary initiates swap, secondary responds
                        if col in (1, 2, 3) and other_col >= 4:
                            edges.append((cid, other))
        # deterministic sort
        def top_left_of(comp_id):
            return comps[comp_id]['top_left']

        edges_sorted = sorted(edges, key=lambda pr: (top_left_of(pr[0])[0], top_left_of(pr[0])[1], top_left_of(pr[1])[0], top_left_of(pr[1])[1]))
        matched = set()
        swap_map = {}
        for a, b in edges_sorted:
            if a in matched or b in matched:
                continue
            matched.add(a)
            matched.add(b)
            swap_map[a] = comps[b]['color']
            swap_map[b] = comps[a]['color']
        # apply swaps simultaneously
        if swap_map:
            for comp_id, new_col in swap_map.items():
                for (r, c) in comps[comp_id]['cells']:
                    output_grid[r][c] = new_col

        # Step 4: Morphing (apply final expansions)
        comps2, cell_to_comp2 = _components_from_grid(output_grid)
        # prepare ordered comps
        comps2_sorted = sorted(comps2, key=lambda x: (x['top_left'][0], x['top_left'][1]))
        planned_adds = {}  # comp_id -> set of cells to add
        occupied_now = set((r, c) for r in range(size) for c in range(size) if output_grid[r][c] != 0)
        # compute centers
        centers = {}
        for comp in comps2_sorted:
            rs = [p[0] for p in comp['cells']]
            cs = [p[1] for p in comp['cells']]
            centers[comp['id']] = (sum(rs) // len(rs), sum(cs) // len(cs))
        # for each comp, find nearest primary comp (other than itself)
        for comp in comps2_sorted:
            cid = comp['id']
            src_center = centers[cid]
            # find candidates that are primary
            primaries = [c for c in comps2_sorted if c['id'] != cid and c['color'] in (1, 2, 3)]
            if not primaries:
                continue
            # choose nearest by manhattan distance between centers
            primaries.sort(key=lambda pc: (_manhattan(centers[cid], centers[pc['id']]), pc['top_left']))
            target = primaries[0]
            tr, tc = centers[target['id']]
            sr, sc = src_center
            dr = tr - sr
            dc = tc - sc
            # choose axis-aligned step to maintain connectivity
            if abs(dr) >= abs(dc):
                step = (1 if dr > 0 else -1, 0) if dr != 0 else (0, 0)
            else:
                step = (0, 1 if dc > 0 else -1)
            if step == (0, 0):
                continue
            # collect candidate perimeter cells in that direction
            cand = set()
            for (r, c) in comp['cells']:
                nr, nc = r + step[0], c + step[1]
                if 0 <= nr < size and 0 <= nc < size and output_grid[nr][nc] == 0:
                    cand.add((nr, nc))
            if cand:
                planned_adds[cid] = (comp['color'], cand)
        # apply planned adds in comp order (sorted already) to avoid conflicts
        for comp in comps2_sorted:
            cid = comp['id']
            if cid not in planned_adds:
                continue
            col, cand = planned_adds[cid]
            for cell in sorted(cand):
                if cell not in occupied_now:
                    r, c = cell
                    output_grid[r][c] = col
                    occupied_now.add(cell)

        # Ensure that output differs from input
        changed = any(output_grid[r][c] != input_grid[r][c] for r in range(size) for c in range(size))
        if not changed:
            # try again
            if tries > 200:
                # force minimal change: recolor one reflected location (this is very unlikely)
                for r in range(size):
                    for c in range(size):
                        if output_grid[r][c] != 0 and input_grid[r][c] == 0:
                            output_grid[r][c] = (output_grid[r][c] % 9) + 1
                            changed = True
                            break
                    if changed:
                        break
                if not changed:
                    continue
            else:
                continue

        return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert tuple-grid to list-grid
    grid_in = [list(row) for row in input_grid]
    size_h = len(grid_in)
    size_w = len(grid_in[0])
    # For this task generator emits square grids; be robust
    size = max(size_h, size_w)

    def _reflect_point(pt, color, size):
        r, c = pt
        if color == 1:
            return (r, size - 1 - c)
        if color == 2:
            return (size - 1 - r, c)
        if color == 3:
            return (c, r)
        if color == 4:
            return (size - 1 - c, size - 1 - r)
        return (r, c)

    def _manhattan(a, b):
        return abs(a[0] - b[0]) + abs(a[1] - b[1])

    def _components_from_grid(g):
        h = len(g)
        w = len(g[0])
        visited = [[False] * w for _ in range(h)]
        comps = []
        cell_to_comp = {}
        for r in range(h):
            for c in range(w):
                if g[r][c] == 0 or visited[r][c]:
                    continue
                color = g[r][c]
                stack = [(r, c)]
                visited[r][c] = True
                cells = []
                min_r, min_c = r, c
                while stack:
                    x, y = stack.pop()
                    cells.append((x, y))
                    if x < min_r or (x == min_r and y < min_c):
                        min_r, min_c = x, y
                    for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nx, ny = x + dx, y + dy
                        if 0 <= nx < h and 0 <= ny < w and not visited[nx][ny] and g[nx][ny] == color:
                            visited[nx][ny] = True
                            stack.append((nx, ny))
                comp_id = len(comps)
                for cell in cells:
                    cell_to_comp[cell] = comp_id
                comps.append({
                    'id': comp_id,
                    'color': color,
                    'cells': set(cells),
                    'top_left': (min_r, min_c)
                })
        return comps, cell_to_comp

    # find shapes in the input and order them by top-left to match generator ordering
    comps_in, _ = _components_from_grid(grid_in)
    comps_in_sorted = sorted(comps_in, key=lambda x: (x['top_left'][0], x['top_left'][1]))
    shapes = [{'color': c['color'], 'cells': set(c['cells'])} for c in comps_in_sorted]

    # Step 1: Reflection onto output grid (only write into background)
    output = [row[:] for row in grid_in]
    h = len(output)
    w = len(output[0])
    # reflect shapes in top-left order (same as generator)
    shapes_sorted = sorted(shapes, key=lambda s: (min(r for r, _ in s['cells']), min(c for _, c in s['cells'])))
    for s in shapes_sorted:
        col = s['color']
        for (r, c) in s['cells']:
            nr, nc = _reflect_point((r, c), col, size)
            if 0 <= nr < h and 0 <= nc < w and output[nr][nc] == 0:
                output[nr][nc] = col

    # Step 2&3: Color exchange before morphing finalization (match generator behavior)
    comps, cell_to_comp = _components_from_grid(output)
    edges = []
    for comp in comps:
        cid = comp['id']
        col = comp['color']
        for (r, c) in comp['cells']:
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = r + dr, c + dc
                if 0 <= nr < h and 0 <= nc < w and (nr, nc) in cell_to_comp:
                    other = cell_to_comp[(nr, nc)]
                    if other == cid:
                        continue
                    other_col = comps[other]['color']
                    if col in (1, 2, 3) and other_col >= 4:
                        edges.append((cid, other))
    def top_left_of(comp_id):
        return comps[comp_id]['top_left']
    edges_sorted = sorted(edges, key=lambda pr: (top_left_of(pr[0])[0], top_left_of(pr[0])[1], top_left_of(pr[1])[0], top_left_of(pr[1])[1]))
    matched = set()
    swap_map = {}
    for a, b in edges_sorted:
        if a in matched or b in matched:
            continue
        matched.add(a)
        matched.add(b)
        swap_map[a] = comps[b]['color']
        swap_map[b] = comps[a]['color']
    if swap_map:
        for comp_id, new_col in swap_map.items():
            for (r, c) in comps[comp_id]['cells']:
                output[r][c] = new_col

    # Step 4: Morphing expansions
    comps2, cell_to_comp2 = _components_from_grid(output)
    comps2_sorted = sorted(comps2, key=lambda x: (x['top_left'][0], x['top_left'][1]))
    occupied_now = set((r, c) for r in range(h) for c in range(w) if output[r][c] != 0)
    centers = {}
    for comp in comps2_sorted:
        rs = [p[0] for p in comp['cells']]
        cs = [p[1] for p in comp['cells']]
        centers[comp['id']] = (sum(rs) // len(rs), sum(cs) // len(cs))
    planned_adds = {}
    for comp in comps2_sorted:
        cid = comp['id']
        src_center = centers[cid]
        primaries = [c for c in comps2_sorted if c['id'] != cid and c['color'] in (1, 2, 3)]
        if not primaries:
            continue
        primaries.sort(key=lambda pc: (_manhattan(centers[cid], centers[pc['id']]), pc['top_left']))
        target = primaries[0]
        tr, tc = centers[target['id']]
        sr, sc = src_center
        dr = tr - sr
        dc = tc - sc
        if abs(dr) >= abs(dc):
            step = (1 if dr > 0 else -1, 0) if dr != 0 else (0, 0)
        else:
            step = (0, 1 if dc > 0 else -1)
        if step == (0, 0):
            continue
        cand = set()
        for (r, c) in comp['cells']:
            nr, nc = r + step[0], c + step[1]
            if 0 <= nr < h and 0 <= nc < w and output[nr][nc] == 0:
                cand.add((nr, nc))
        if cand:
            planned_adds[cid] = (comp['color'], cand)
    for comp in comps2_sorted:
        cid = comp['id']
        if cid not in planned_adds:
            continue
        col, cand = planned_adds[cid]
        for cell in sorted(cand):
            if cell not in occupied_now:
                r, c = cell
                output[r][c] = col
                occupied_now.add(cell)

    return output
