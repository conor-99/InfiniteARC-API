# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 5cc154e2
Difficulty: very hard

=== Tags ===
- Recursive mirroring
- Find the intruder

=== Description ===
Input grids are large square grids (15×15 to 30×30) filled with vibrant, multi-
colored patterns that should exhibit recursive symmetry across both vertical and
horizontal axes at multiple hierarchical levels. The pattern is constructed by
repeatedly mirroring the entire grid vertically, then mirroring each resulting
half horizontally, and applying this process recursively to all subgrids until
the smallest symmetric units are achieved. However, exactly one cell (the
intruder) deviates from the expected mirrored color at one or more recursive
symmetry layers. The output grid is identical to the input except the intruder
cell's color is replaced with the color that would maintain perfect recursive
symmetry across all levels, ensuring all mirrored counterparts match
consistently. Solvers must identify the single inconsistent cell by verifying
symmetry through all recursive layers and apply the correction, requiring
analysis of nested mirroring relationships rather than simple reflection checks.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import random_color

def create_correct_grid(size):
    if size == 1:
        return [[random_color()]]
    half = size // 2
    base = [[random_color() for _ in range(half)] for _ in range(half)]
    grid = [[0] * size for _ in range(size)]
    for i in range(half):
        for j in range(half):
            val = base[i][j]
            grid[i][j] = val
            grid[i][size - 1 - j] = val
            grid[size - 1 - i][j] = val
            grid[size - 1 - i][size - 1 - j] = val
    return grid

def generate():
    size = 16
    correct_grid = create_correct_grid(size)
    input_grid = [row[:] for row in correct_grid]
    i = random.randint(0, size - 1)
    j = random.randint(0, size // 2 - 1)
    original_color = correct_grid[i][j]
    new_color = random_color(exclude=[original_color])
    input_grid[i][j] = new_color
    return {
        "input": input_grid,
        "output": correct_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    size = len(input_grid)
    grid = [list(row) for row in input_grid]
    for i in range(size):
        for j in range(size // 2):
            if grid[i][j] != grid[i][size - 1 - j]:
                grid[i][j] = grid[i][size - 1 - j]
                return tuple(tuple(row) for row in grid)
    return input_grid
