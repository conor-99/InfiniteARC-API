# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 73cc7887
Difficulty: insane

=== Tags ===
- Beam reflection

=== Description ===
Beam Reflection: Input grids feature a background color (0) with two distinct
mirror types (color 1 representing /-shaped mirrors, color 2 representing
\-shaped mirrors), and multiple beam starting points (colors 3-6) positioned
along the grid's edges. Each beam originates at an edge cell and moves inward
perpendicular to that edge (e.g., top-edge beams move downward, left-edge beams
move rightward). Upon encountering a / mirror (color 1), beams reflect according
to standard geometric reflection rules (e.g., a right-moving beam becomes
upward-moving, a downward-moving beam becomes leftward-moving). Upon
encountering a \ mirror (color 2), beams reflect such that right-moving beams
become downward-moving, and downward-moving beams become rightward-moving. Beams
traverse only background cells (color 0), drawing their path in their original
starting color. Mirrors remain visible in the output. The output grid displays
all beam trajectories after complete reflection sequences, with paths
terminating when beams exit the grid. Complex arrangements of mirrors cause
multiple sequential reflections per beam, requiring precise directional updates
based on mirror orientation. No beam paths overlap or intersect, and all
reflections follow consistent geometric rules without loops.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    from common import grid, randint
    
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    input_grid = grid(width, height, 0)
    
    non_edge_cells = []
    for r in range(1, height-1):
        for c in range(1, width-1):
            non_edge_cells.append((r, c))
    num_mirrors = random.randint(10, 20)
    for _ in range(num_mirrors):
        r, c = random.choice(non_edge_cells)
        input_grid[r][c] = random.choice([1, 2])
    
    for c in range(width):
        if input_grid[0][c] == 0 and random.random() > 0.5:
            input_grid[0][c] = random.randint(3, 6)
    for c in range(width):
        if input_grid[height-1][c] == 0 and random.random() > 0.5:
            input_grid[height-1][c] = random.randint(3, 6)
    for r in range(height):
        if input_grid[r][0] == 0 and random.random() > 0.5:
            input_grid[r][0] = random.randint(3, 6)
    for r in range(height):
        if input_grid[r][width-1] == 0 and random.random() > 0.5:
            input_grid[r][width-1] = random.randint(3, 6)
    
    output_grid = [row[:] for row in input_grid]
    
    def reflect_direction(dir, mirror_type):
        dr, dc = dir
        if mirror_type == 1:
            if dr == 0 and dc == 1:
                return (-1, 0)
            elif dr == 1 and dc == 0:
                return (0, -1)
            elif dr == 0 and dc == -1:
                return (1, 0)
            elif dr == -1 and dc == 0:
                return (0, 1)
        else:
            if dr == 0 and dc == 1:
                return (1, 0)
            elif dr == 1 and dc == 0:
                return (0, 1)
            elif dr == 0 and dc == -1:
                return (-1, 0)
            elif dr == -1 and dc == 0:
                return (0, -1)
        return dir
    
    for color in range(3, 7):
        for c in range(width):
            if input_grid[0][c] == color:
                r, c = 0, c
                direction = (1, 0)
                cr, cc = r, c
                while True:
                    nr, nc = cr + direction[0], cc + direction[1]
                    if nr < 0 or nr >= height or nc < 0 or nc >= width:
                        break
                    val = input_grid[nr][nc]
                    if val == 0:
                        output_grid[nr][nc] = color
                    elif val == 1 or val == 2:
                        direction = reflect_direction(direction, val)
                    else:
                        break
                    cr, cc = nr, nc
        for c in range(width):
            if input_grid[height-1][c] == color:
                r, c = height-1, c
                direction = (-1, 0)
                cr, cc = r, c
                while True:
                    nr, nc = cr + direction[0], cc + direction[1]
                    if nr < 0 or nr >= height or nc < 0 or nc >= width:
                        break
                    val = input_grid[nr][nc]
                    if val == 0:
                        output_grid[nr][nc] = color
                    elif val == 1 or val == 2:
                        direction = reflect_direction(direction, val)
                    else:
                        break
                    cr, cc = nr, nc
        for r in range(height):
            if input_grid[r][0] == color:
                r, c = r, 0
                direction = (0, 1)
                cr, cc = r, c
                while True:
                    nr, nc = cr + direction[0], cc + direction[1]
                    if nr < 0 or nr >= height or nc < 0 or nc >= width:
                        break
                    val = input_grid[nr][nc]
                    if val == 0:
                        output_grid[nr][nc] = color
                    elif val == 1 or val == 2:
                        direction = reflect_direction(direction, val)
                    else:
                        break
                    cr, cc = nr, nc
        for r in range(height):
            if input_grid[r][width-1] == color:
                r, c = r, width-1
                direction = (0, -1)
                cr, cc = r, c
                while True:
                    nr, nc = cr + direction[0], cc + direction[1]
                    if nr < 0 or nr >= height or nc < 0 or nc >= width:
                        break
                    val = input_grid[nr][nc]
                    if val == 0:
                        output_grid[nr][nc] = color
                    elif val == 1 or val == 2:
                        direction = reflect_direction(direction, val)
                    else:
                        break
                    cr, cc = nr, nc
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Ensure input_grid is a list of lists
    input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = [row[:] for row in input_grid]
    
    def reflect_direction(dir, mirror_type):
        dr, dc = dir
        if mirror_type == 1:
            if dr == 0 and dc == 1:
                return (-1, 0)
            elif dr == 1 and dc == 0:
                return (0, -1)
            elif dr == 0 and dc == -1:
                return (1, 0)
            elif dr == -1 and dc == 0:
                return (0, 1)
        else:
            if dr == 0 and dc == 1:
                return (1, 0)
            elif dr == 1 and dc == 0:
                return (0, 1)
            elif dr == 0 and dc == -1:
                return (-1, 0)
            elif dr == -1 and dc == 0:
                return (0, -1)
        return dir
    
    for color in range(3, 7):
        for c in range(width):
            if input_grid[0][c] == color:
                direction = (1, 0)
                cr, cc = 0, c
                while True:
                    nr, nc = cr + direction[0], cc + direction[1]
                    if nr < 0 or nr >= height or nc < 0 or nc >= width:
                        break
                    val = input_grid[nr][nc]
                    if val == 0:
                        output_grid[nr][nc] = color
                    elif val == 1 or val == 2:
                        direction = reflect_direction(direction, val)
                    else:
                        break
                    cr, cc = nr, nc
        for c in range(width):
            if input_grid[height-1][c] == color:
                direction = (-1, 0)
                cr, cc = height-1, c
                while True:
                    nr, nc = cr + direction[0], cc + direction[1]
                    if nr < 0 or nr >= height or nc < 0 or nc >= width:
                        break
                    val = input_grid[nr][nc]
                    if val == 0:
                        output_grid[nr][nc] = color
                    elif val == 1 or val == 2:
                        direction = reflect_direction(direction, val)
                    else:
                        break
                    cr, cc = nr, nc
        for r in range(height):
            if input_grid[r][0] == color:
                direction = (0, 1)
                cr, cc = r, 0
                while True:
                    nr, nc = cr + direction[0], cc + direction[1]
                    if nr < 0 or nr >= height or nc < 0 or nc >= width:
                        break
                    val = input_grid[nr][nc]
                    if val == 0:
                        output_grid[nr][nc] = color
                    elif val == 1 or val == 2:
                        direction = reflect_direction(direction, val)
                    else:
                        break
                    cr, cc = nr, nc
        for r in range(height):
            if input_grid[r][width-1] == color:
                direction = (0, -1)
                cr, cc = r, width-1
                while True:
                    nr, nc = cr + direction[0], cc + direction[1]
                    if nr < 0 or nr >= height or nc < 0 or nc >= width:
                        break
                    val = input_grid[nr][nc]
                    if val == 0:
                        output_grid[nr][nc] = color
                    elif val == 1 or val == 2:
                        direction = reflect_direction(direction, val)
                    else:
                        break
                    cr, cc = nr, nc
    return output_grid
