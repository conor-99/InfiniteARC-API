# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 05eabf37
Difficulty: insane

=== Tags ===
- Periodic reflection

=== Description ===
Input grids are large (width and height exceeding 15) with a single background
color. Overlaid are walls (horizontal or vertical segments of 1-3 cells, each
wall a distinct solid color) and a single laser (an L-shaped cluster of three
cells with a background-colored corner as the origin, oriented to face a
diagonal direction). The beam originates at the laser's corner and moves
diagonally in the laser's facing direction. Each time the beam intersects a wall
(horizontal or vertical), it reflects according to standard geometric reflection
rules (e.g., vertical wall flips horizontal direction), and the beam's color
alternates between the laser's color (for segments before the first reflection)
and the color of the *first wall encountered* (for all subsequent segments). The
output grid renders the beam's path as a sequence of diagonal segments, each
colored according to the current color in this alternating cycle. The path is
drawn exclusively on background cells, never overlapping walls, lasers, or other
elements. The beam exits the grid after a finite number of reflections, with no
self-intersections or reflections at wall corners. The first wall hit determines
the periodic color cycle, requiring the solver to track both the reflection path
and the color transition sequence to reproduce the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_color

def generate():
    width = random.randint(16, 30)
    height = random.randint(16, 30)
    bg = 0
    ingrid = grid(width, height, bg)
    
    # Laser placement
    laser_color = random_color(exclude=[bg])
    laser_dir = random.choice(['ne', 'se', 'nw', 'sw'])
    r = random.randint(1, height - 2)
    c = random.randint(1, width - 2)
    
    if laser_dir == 'ne':
        ingrid[r][c] = laser_color
        ingrid[r][c+1] = laser_color
        ingrid[r+1][c] = laser_color
        origin = (r+1, c+1)
        dr, dc = 1, 1
    elif laser_dir == 'se':
        ingrid[r][c] = laser_color
        ingrid[r][c-1] = laser_color
        ingrid[r+1][c] = laser_color
        origin = (r+1, c-1)
        dr, dc = 1, -1
    elif laser_dir == 'nw':
        ingrid[r][c] = laser_color
        ingrid[r][c+1] = laser_color
        ingrid[r-1][c] = laser_color
        origin = (r-1, c+1)
        dr, dc = -1, 1
    else: # sw
        ingrid[r][c] = laser_color
        ingrid[r][c-1] = laser_color
        ingrid[r-1][c] = laser_color
        origin = (r-1, c-1)
        dr, dc = -1, -1
    
    # Wall placement in beam path
    wall_color = random_color(exclude=[bg, laser_color])
    wall_length = random.randint(2, 3)  # Ensure orientation determinable
    wall_row = origin[0] + 2
    wall_col = origin[1] + 2
    
    if laser_dir in ['ne', 'se']:
        # Horizontal wall
        for i in range(wall_length):
            if wall_row < height and wall_col + i < width:
                ingrid[wall_row][wall_col + i] = wall_color
    else:
        # Vertical wall
        for i in range(wall_length):
            if wall_row + i < height and wall_col < width:
                ingrid[wall_row + i][wall_col] = wall_color

    # Simulate beam path
    output = [row[:] for row in ingrid]
    r, c = origin
    current_color = laser_color
    first_wall_color = None

    while 0 <= r < height and 0 <= c < width:
        if ingrid[r][c] != bg:
            if first_wall_color is None:
                first_wall_color = ingrid[r][c]
                current_color = first_wall_color
            # Reflect direction
            if laser_dir in ['ne', 'se']:
                dr = -dr
            else:
                dc = -dc
        else:
            output[r][c] = current_color
        r += dr
        c += dc

    return {'input': ingrid, 'output': output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    bg = 0
    
    # Find laser
    laser_color = None
    origin = None
    dr, dc = 0, 0
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] != bg:
                # Check NE L
                if c+1 < width and r+1 < height and grid[r][c] == grid[r][c+1] == grid[r+1][c]:
                    laser_color = grid[r][c]
                    origin = (r+1, c+1)
                    dr, dc = 1, 1
                    break
                # Check SE L
                if c-1 >= 0 and r+1 < height and grid[r][c] == grid[r][c-1] == grid[r+1][c]:
                    laser_color = grid[r][c]
                    origin = (r+1, c-1)
                    dr, dc = 1, -1
                    break
                # Check NW L
                if c+1 < width and r-1 >= 0 and grid[r][c] == grid[r][c+1] == grid[r-1][c]:
                    laser_color = grid[r][c]
                    origin = (r-1, c+1)
                    dr, dc = -1, 1
                    break
                # Check SW L
                if c-1 >= 0 and r-1 >= 0 and grid[r][c] == grid[r][c-1] == grid[r-1][c]:
                    laser_color = grid[r][c]
                    origin = (r-1, c-1)
                    dr, dc = -1, -1
                    break
        if origin:
            break
    
    # Simulate path
    r, c = origin
    current_color = laser_color
    first_wall_color = None
    
    while 0 <= r < height and 0 <= c < width:
        if grid[r][c] != bg:
            if first_wall_color is None:
                first_wall_color = grid[r][c]
                current_color = first_wall_color
            # Determine wall orientation
            is_horizontal = (c > 0 and grid[r][c-1] == grid[r][c]) or (c < width-1 and grid[r][c+1] == grid[r][c])
            is_vertical = (r > 0 and grid[r-1][c] == grid[r][c]) or (r < height-1 and grid[r+1][c] == grid[r][c])
            
            if is_horizontal:
                dr = -dr
            else:
                dc = -dc
        else:
            grid[r][c] = current_color
        r += dr
        c += dc
    
    return tuple(tuple(row) for row in grid)
