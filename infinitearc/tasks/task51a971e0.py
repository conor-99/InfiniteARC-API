# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 51a971e0
Difficulty: medium

=== Tags ===
- Pattern reflection
- Image filling
- Associate images to patterns

=== Description ===
The input grids contain a distinct pattern of non-zero values (representing an
"image") positioned on one side of a central vertical axis, with the opposite
side entirely filled with zeros (indicating empty space). The output grid is
generated by reflecting the non-zero pattern across the vertical axis, thereby
filling the previously empty side with the mirrored values. For instance, if the
input has a pattern in the left half of the grid, the output will mirror this
pattern to the right half, such that each non-zero value at position (row,
column) in the input corresponds to a mirrored value at (row, width - 1 -
column) in the output. The central column (if the grid width is odd) remains
unchanged as it serves as the axis of reflection. This transformation requires
identifying the pattern's location relative to the center and applying a
deterministic vertical reflection to complete the image.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    width = random.randint(2, 30)
    height = random.randint(1, 30)
    midpoint = (width + 1) // 2
    input_grid = [[0] * width for _ in range(height)]
    
    for r in range(height):
        for c in range(midpoint):
            if random.random() > 0.5:
                input_grid[r][c] = random.randint(1, 9)
    
    if all(all(cell == 0 for cell in row) for row in input_grid):
        r = random.randint(0, height-1)
        c = random.randint(0, midpoint-1)
        input_grid[r][c] = random.randint(1, 9)
    
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if c < midpoint:
                output_grid[r][c] = input_grid[r][c]
            else:
                output_grid[r][c] = input_grid[r][width - 1 - c]
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    midpoint = (width + 1) // 2
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if c < midpoint:
                output_grid[r][c] = input_grid[r][c]
            else:
                output_grid[r][c] = input_grid[r][width - 1 - c]
    return output_grid
