# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 866faed7
Difficulty: medium–hard

=== Tags ===
- Mirrored attribute binding
- Sequential path painting

=== Description ===
Input grids feature a background color (0) with a starting point (color 1)
positioned at the bottom-left corner. The grid contains mirror blocks (colors
2-5) arranged in symmetric pairs across a central vertical axis. Each mirror
block is either a horizontal rectangle (1×N) or vertical rectangle (N×1),
indicating the direction of reflection: horizontal mirrors reverse vertical
movement, vertical mirrors reverse horizontal movement. The output grid depicts
a path starting at the initial point, moving rightward. Upon colliding with a
mirror block, the path reflects according to the mirror's orientation and paints
the segment with the mirror's color. The sequence of colors follows the order of
mirror encounters, creating a sequential painting effect. The path continues
until exiting the grid, with all mirrors remaining visible and unchanged in the
output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    """Generate a grid pair where a path starting at bottom-left moves right and
    reflects off mirrored rectangular blocks (colors 2-5) that are placed in
    symmetric pairs across the central vertical axis. The path paints segments
    after each reflection with the color of the mirror that produced the
    reflection. Mirrors remain visible and unchanged in the output.
    """
    # Try a number of times to build a valid scene; this keeps the generator
    # robust against unlucky placements that produce no painting or loops.
    for attempt in range(1000):
        width = random.randint(10, 30)
        height = random.randint(10, 30)
        ingrid = grid(width, height, 0)

        # Start point at bottom-left
        start_r, start_c = height - 1, 0
        ingrid[start_r][start_c] = 1

        colors = [2, 3, 4, 5]
        num_pairs = random.randint(2, 4)

        placed_coords = set()
        left_max_col = (width // 2) - 1
        if left_max_col < 0:
            left_max_col = 0

        ok = True
        for _ in range(num_pairs):
            placed = False
            # Try several times to place a non-overlapping symmetric pair
            for _try in range(120):
                color = random.choice(colors)
                orientation = random.choice(["horizontal", "vertical"])

                if orientation == "horizontal":
                    # horizontal mirror: 1 x L placed on the left half and mirrored
                    max_len = min(6, left_max_col + 1)
                    if max_len < 2:
                        continue
                    L = random.randint(2, max_len)
                    row = random.randint(0, height - 1)
                    start_col_max = left_max_col - L + 1
                    if start_col_max < 0:
                        continue
                    sc = random.randint(0, start_col_max)
                    coords_left = [(row, c) for c in range(sc, sc + L)]
                    coords_right = [(row, width - 1 - c) for c in range(sc, sc + L)]
                else:
                    # vertical mirror: L x 1 placed on the left half and mirrored
                    max_len = min(6, height)
                    L = random.randint(2, max_len)
                    if left_max_col < 0:
                        continue
                    col = random.randint(0, left_max_col)
                    start_row_max = height - L
                    if start_row_max < 0:
                        continue
                    sr = random.randint(0, start_row_max)
                    coords_left = [(r, col) for r in range(sr, sr + L)]
                    coords_right = [(r, width - 1 - col) for r in range(sr, sr + L)]

                all_coords = coords_left + coords_right
                # Don't overlap the start point or existing mirrors
                if (start_r, start_c) in all_coords:
                    continue
                if any(p in placed_coords for p in all_coords):
                    continue

                # Place the mirror pair
                for (rr, cc) in all_coords:
                    ingrid[rr][cc] = color
                    placed_coords.add((rr, cc))
                placed = True
                break

            if not placed:
                ok = False
                break

        if not ok:
            continue

        # Simulate the path and paint the segments according to the rules.
        def simulate(ingrid):
            h = len(ingrid)
            w = len(ingrid[0])
            out = [row[:] for row in ingrid]

            # Find start (should be bottom-left but search to be robust)
            found = False
            for rr in range(h):
                for cc in range(w):
                    if ingrid[rr][cc] == 1:
                        r, c = rr, cc
                        found = True
                        break
                if found:
                    break
            if not found:
                r, c = h - 1, 0

            dr, dc = 0, 1  # start moving right
            paint_color = None
            visited = set()
            steps = 0

            while True:
                state = (r, c, dr, dc, paint_color)
                if state in visited:
                    # Loop detected
                    return out, False
                visited.add(state)

                nr, nc = r + dr, c + dc
                # If the next cell is outside, the path exits
                if not (0 <= nr < h and 0 <= nc < w):
                    return out, True

                if ingrid[nr][nc] >= 2:
                    # Move into the mirror cell
                    r, c = nr, nc
                    color = ingrid[r][c]
                    # Detect orientation by checking same-color neighbors
                    horizontal = ((c > 0 and ingrid[r][c - 1] == color) or
                                  (c < w - 1 and ingrid[r][c + 1] == color))
                    if horizontal:
                        # horizontal mirror reverses vertical component
                        dr = -dr
                    else:
                        # vertical mirror reverses horizontal component
                        dc = -dc

                    paint_color = color

                    # Step into the cell after the mirror in the new direction
                    nr, nc = r + dr, c + dc
                    if not (0 <= nr < h and 0 <= nc < w):
                        return out, True

                    r, c = nr, nc
                    if ingrid[r][c] == 0:
                        out[r][c] = paint_color
                else:
                    # Normal move into an empty cell (or other non-mirror).
                    r, c = nr, nc
                    if paint_color is not None and ingrid[r][c] == 0:
                        out[r][c] = paint_color

                steps += 1
                if steps > h * w * 20:
                    # Safety cutoff: treat as invalid if path does not terminate
                    return out, False

        output, exited = simulate(ingrid)
        if not exited:
            # bad placement (loop or didn't exit), try again
            continue
        if output == ingrid:
            # no painting was produced; try again to get a meaningful puzzle
            continue

        return {
            'input': ingrid,
            'output': output
        }

    raise RuntimeError('Unable to generate a valid puzzle after many attempts')



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input (tuple of tuples) to mutable list of lists
    ingrid = [list(row) for row in input_grid]
    h = len(ingrid)
    w = len(ingrid[0])

    # Prepare output as a copy so mirrors remain unchanged
    out = [row[:] for row in ingrid]

    # Find start position (robust search, though spec says bottom-left)
    found = False
    for rr in range(h):
        for cc in range(w):
            if ingrid[rr][cc] == 1:
                r, c = rr, cc
                found = True
                break
        if found:
            break
    if not found:
        r, c = h - 1, 0

    dr, dc = 0, 1  # start moving right
    paint_color = None
    visited = set()
    steps = 0

    while True:
        state = (r, c, dr, dc, paint_color)
        if state in visited:
            # Loop detected; stop (generator should avoid producing these)
            break
        visited.add(state)

        nr, nc = r + dr, c + dc
        if not (0 <= nr < h and 0 <= nc < w):
            # Exits the grid
            break

        if ingrid[nr][nc] >= 2:
            # Enter the mirror cell
            r, c = nr, nc
            color = ingrid[r][c]
            horizontal = ((c > 0 and ingrid[r][c - 1] == color) or
                          (c < w - 1 and ingrid[r][c + 1] == color))
            if horizontal:
                dr = -dr
            else:
                dc = -dc
            paint_color = color

            # Step into the next cell after reflection and paint if empty
            nr, nc = r + dr, c + dc
            if not (0 <= nr < h and 0 <= nc < w):
                break
            r, c = nr, nc
            if ingrid[r][c] == 0:
                out[r][c] = paint_color
        else:
            # Normal forward movement
            r, c = nr, nc
            if paint_color is not None and ingrid[r][c] == 0:
                out[r][c] = paint_color

        steps += 1
        if steps > h * w * 20:
            # Safety cutoff
            break

    return out

