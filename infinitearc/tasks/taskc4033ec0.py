# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: c4033ec0
Difficulty: medium

=== Tags ===
- Connect equal color components
- Close line gaps
- Pairwise analogy

=== Description ===
The task involves connecting all disconnected regions of the same color in the
input grid to form a single connected region for each color. For each color
present in the input, if multiple disconnected components exist, the output
fills the minimal gaps between these components with the same color to create a
continuous path. This includes closing gaps within existing lines (e.g., filling
a missing pixel in a horizontal or vertical line) and connecting separate
components. The transformation ensures that all regions of a given color become
a single contiguous block via 4-directional adjacency, with no disconnected
parts remaining. The output grid achieves this by filling the shortest path
between closest components of the same color, maintaining the visual continuity
of lines and shapes without introducing new colors or patterns.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(5, 30)
    height = random.randint(3, 30)
    input_grid = grid(width, height, 0)
    color = random.randint(1, 9)
    row = random.randint(0, height - 1)
    for c in range(width):
        input_grid[row][c] = color
    gap_col = random.randint(1, width - 2)
    input_grid[row][gap_col] = 0
    output_grid = [row[:] for row in input_grid]
    output_grid[row][gap_col] = color
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = [list(row) for row in input_grid]
    
    for color in range(1, 10):
        visited = [[False] * width for _ in range(height)]
        comp_id = [[-1] * width for _ in range(height)]
        comp_count = 0
        
        def dfs(r, c, cid):
            if r < 0 or r >= height or c < 0 or c >= width or visited[r][c] or input_grid[r][c] != color:
                return
            visited[r][c] = True
            comp_id[r][c] = cid
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                dfs(r + dr, c + dc, cid)
        
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == color and not visited[r][c]:
                    dfs(r, c, comp_count)
                    comp_count += 1
        
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] != 0:
                    continue
                neighbors = set()
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == color:
                        neighbors.add(comp_id[nr][nc])
                if len(neighbors) >= 2:
                    output_grid[r][c] = color
    return output_grid
