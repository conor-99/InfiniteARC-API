# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 3b959a72
Difficulty: hard

=== Tags ===
- Multi agent path weaving
- Obstacles

=== Description ===
The input grid is a 2D arrangement of colors where color 5 represents static
obstacles, and colors 1 through 4 each represent a distinct agent. Agents are
uniquely positioned in the grid at the start of their paths. The output grid is
generated by tracing each agent's path from its initial position. Each agent
follows a fixed cyclic direction sequence: right (East) → up (North) → left
(West) → down (South), repeating indefinitely. At each step, the agent moves one
cell in the current direction if the target cell is within grid bounds and not
an obstacle (color 5); otherwise, it turns 90° clockwise to the next direction
in the cycle and attempts to move. This continues until all four directions are
blocked (obstacles or boundaries), at which point the path terminates. The
output grid displays all traversed cells along each agent's path colored by the
agent's original identifier (1–4), with obstacles (color 5) unchanged. Paths may
weave around obstacles, cross each other, or form complex trajectories,
requiring the solver to consistently apply the direction cycle and obstacle
interaction rule across multiple agents and grid regions. Input grids feature
dense obstacle patterns and multiple agents with non-trivial path interactions,
demanding sequential reasoning about direction changes and spatial
relationships.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    while True:
        width = random.randint(5, 20)
        height = random.randint(5, 20)
        input_grid = grid(width, height, 0)
        
        obstacle_count = int(width * height * 0.3)
        for _ in range(obstacle_count):
            r = random.randint(0, height-1)
            c = random.randint(0, width-1)
            input_grid[r][c] = 5
        
        non_obstacle = []
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == 0:
                    non_obstacle.append((r, c))
        
        if len(non_obstacle) < 4:
            continue
        
        agent_positions = random.sample(non_obstacle, 4)
        for i, (r, c) in enumerate(agent_positions):
            input_grid[r][c] = i + 1
        
        output_grid = grid(width, height, 0)
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == 5:
                    output_grid[r][c] = 5
        
        directions = [(0, 1), (-1, 0), (0, -1), (1, 0)]
        
        for color in range(1, 5):
            start = None
            for r in range(height):
                for c in range(width):
                    if input_grid[r][c] == color:
                        start = (r, c)
                        break
                if start:
                    break
            
            if not start:
                continue
            
            path = [start]
            current = start
            dir_index = 0
            while True:
                dr, dc = directions[dir_index]
                nr, nc = current[0] + dr, current[1] + dc
                if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 5:
                    path.append((nr, nc))
                    current = (nr, nc)
                else:
                    dir_index = (dir_index + 1) % 4
                    if dir_index == 0:
                        break
            
            for (r, c) in path:
                output_grid[r][c] = color
        
        if input_grid != output_grid:
            return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = grid(width, height, 0)
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 5:
                output_grid[r][c] = 5
    
    directions = [(0, 1), (-1, 0), (0, -1), (1, 0)]
    
    for color in range(1, 5):
        start = None
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == color:
                    start = (r, c)
                    break
            if start:
                break
        
        if not start:
            continue
        
        path = [start]
        current = start
        dir_index = 0
        while True:
            dr, dc = directions[dir_index]
            nr, nc = current[0] + dr, current[1] + dc
            if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 5:
                path.append((nr, nc))
                current = (nr, nc)
            else:
                dir_index = (dir_index + 1) % 4
                if dir_index == 0:
                    break
        
        for (r, c) in path:
            output_grid[r][c] = color
    
    return output_grid
