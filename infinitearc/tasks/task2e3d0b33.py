# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 2e3d0b33
Difficulty: mediumâ€“hard

=== Tags ===
- Local rule cascade
- Bidirectional mapping
- Grid topology inference
- Out of boundary
- Seal gaps inside shape

=== Description ===
The input grid displays a single, contiguous shape defined by a distinct color,
with internal regions of background color that are completely enclosed by the
shape (i.e., not connected to the grid's outer boundary). The output grid fills
all such enclosed background regions with the shape's color, effectively sealing
them. This transformation requires inferring the shape's topology to identify
enclosed regions through boundary connectivity checks, applying a local rule
that fills background cells whose connected components are entirely surrounded
by the shape, and ignoring background regions that touch the grid's edge. The
task demands precise grid topology inference to distinguish between internal
gaps and boundary-connected regions, with the "out of boundary" condition
ensuring only truly enclosed gaps are sealed.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    size = random.randint(3, 30)
    shape_color = random.randint(1, 9)
    grid = [[0] * size for _ in range(size)]
    for i in range(size):
        grid[0][i] = shape_color
        grid[size-1][i] = shape_color
        grid[i][0] = shape_color
        grid[i][size-1] = shape_color
    output_grid = [row[:] for row in grid]
    for i in range(1, size-1):
        for j in range(1, size-1):
            output_grid[i][j] = shape_color
    return {"input": grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    n = len(grid)
    m = len(grid[0])
    shape_color = None
    for i in range(n):
        for j in range(m):
            if grid[i][j] != 0:
                shape_color = grid[i][j]
                break
        if shape_color is not None:
            break
    if shape_color is None:
        return grid
    from collections import deque
    visited = [[False] * m for _ in range(n)]
    queue = deque()
    for i in range(n):
        for j in (0, m-1):
            if grid[i][j] == 0 and not visited[i][j]:
                visited[i][j] = True
                queue.append((i, j))
    for j in range(m):
        for i in (0, n-1):
            if grid[i][j] == 0 and not visited[i][j]:
                visited[i][j] = True
                queue.append((i, j))
    directions = [(0,1), (0,-1), (1,0), (-1,0)]
    while queue:
        i, j = queue.popleft()
        for di, dj in directions:
            ni, nj = i + di, j + dj
            if 0 <= ni < n and 0 <= nj < m and not visited[ni][nj] and grid[ni][nj] == 0:
                visited[ni][nj] = True
                queue.append((ni, nj))
    for i in range(n):
        for j in range(m):
            if grid[i][j] == 0 and not visited[i][j]:
                grid[i][j] = shape_color
    return grid
