# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 4601ff6c
Difficulty: hard

=== Tags ===
- Cascade fountain
- Bidirectional escape
- Beam splitter
- Flow with decay
- Threshold by area
- Trace perimeter

=== Description ===
# Cascade Fountain Flow Simulation  Input grids feature a background color (0),
with source cells (color 1) positioned along the top edge in empty background
spaces. Within the grid, beam splitters (color 2) are placed at intersections,
obstacles (color 3) block flow paths, and a threshold indicator (color 4) marks
a fixed minimum area size (e.g., 5 cells) for flow propagation. The grid may
contain additional structural elements like walls or connectors that guide flow
direction.  The output grid demonstrates a cascade flow simulation where: 1.
Flow originates from each source cell (color 1), moving downward through
background cells. 2. Each flow step cycles through a predefined color sequence
(e.g., 1 → 4 → 5 → 6 → 4...) representing flow decay. 3. At beam splitters
(color 2), flow splits perpendicularly (e.g., left and right when moving
downward), creating bidirectional paths. 4. Flow propagation continues only if
the connected flow area remains above the threshold area defined by the
threshold indicator (color 4), stopping at obstacles (color 3), grid edges, or
when area drops below threshold. 5. After flow stops, the perimeter of all cells
covered during propagation is traced with a new color (color 7), forming a
continuous outline around the flow region. 6. Bidirectional escape is achieved
when split paths reach opposite grid edges (left and right), resulting in dual
escape routes visible in the output.  The transformation requires simultaneous
application of flow propagation rules, area threshold checks, color decay
sequencing, and perimeter tracing, creating a complex visual pattern where the
output reveals the complete flow path and its structural boundary.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common
from typing import List, Tuple, Dict

def simulate_flow(grid, threshold):
    grid = [row[:] for row in grid]
    height = len(grid)
    width = len(grid[0])
    seq = [1,4,5,6]
    sources = []
    for c in range(width):
        if grid[0][c] == 1:
            sources.append((0, c))
    
    from collections import deque
    q = deque()
    flow_cells = set()
    total_area = 0
    
    for r, c in sources:
        q.append((r, c, 'down', 0))
        flow_cells.add((r, c))
        total_area += 1
        grid[r][c] = 1
    
    while q:
        r, c, direction, idx = q.popleft()
        current_color = seq[idx % len(seq)]
        
        if direction == 'down':
            next_r, next_c = r + 1, c
        elif direction == 'left':
            next_r, next_c = r, c - 1
        elif direction == 'right':
            next_r, next_c = r, c + 1
        else:
            continue
        
        if next_r < 0 or next_r >= height or next_c < 0 or next_c >= width:
            continue
        
        if grid[next_r][next_c] == 3:
            continue
        
        if grid[next_r][next_c] == 2:
            if (next_r, next_c) not in flow_cells:
                flow_cells.add((next_r, next_c))
                total_area += 1
                grid[next_r][next_c] = current_color
                q.append((next_r, next_c, 'left', idx + 1))
                q.append((next_r, next_c, 'right', idx + 1))
            continue
        
        if grid[next_r][next_c] == 0:
            new_area = total_area + 1
            if new_area >= threshold:
                if (next_r, next_c) not in flow_cells:
                    flow_cells.add((next_r, next_c))
                    total_area = new_area
                    grid[next_r][next_c] = current_color
                    q.append((next_r, next_c, direction, idx + 1))
    
    for r, c in flow_cells:
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width:
                if (nr, nc) not in flow_cells and grid[nr][nc] == 0:
                    grid[nr][nc] = 7
    
    return grid

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    grid = common.grid(width, height, 0)
    
    th_r, th_c = random.randint(1, height-2), random.randint(1, width-2)
    grid[th_r][th_c] = 4
    threshold = 5
    
    for c in range(width):
        if random.random() > 0.7 and grid[0][c] == 0:
            grid[0][c] = 1
    
    for _ in range(random.randint(5, 15)):
        r, c = random.randint(2, height-2), random.randint(1, width-2)
        if grid[r][c] == 0:
            grid[r][c] = 3
    
    for _ in range(random.randint(1, 3)):
        r, c = random.randint(2, height-2), random.randint(1, width-2)
        if grid[r][c] == 0:
            grid[r][c] = 2
    
    input_grid = [row[:] for row in grid]
    output_grid = simulate_flow(input_grid, threshold)
    
    if input_grid == output_grid:
        return generate()
    
    return {
        'input': input_grid,
        'output': output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
from typing import Tuple, List

def p(input_grid: Tuple[Tuple[int]]):
    grid = [list(row) for row in input_grid]
    threshold = 5
    
    def simulate_flow(grid, threshold):
        grid = [row[:] for row in grid]
        height = len(grid)
        width = len(grid[0])
        seq = [1,4,5,6]
        sources = []
        for c in range(width):
            if grid[0][c] == 1:
                sources.append((0, c))
        
        from collections import deque
        q = deque()
        flow_cells = set()
        total_area = 0
        
        for r, c in sources:
            q.append((r, c, 'down', 0))
            flow_cells.add((r, c))
            total_area += 1
            grid[r][c] = 1
        
        while q:
            r, c, direction, idx = q.popleft()
            current_color = seq[idx % len(seq)]
            
            if direction == 'down':
                next_r, next_c = r + 1, c
            elif direction == 'left':
                next_r, next_c = r, c - 1
            elif direction == 'right':
                next_r, next_c = r, c + 1
            else:
                continue
            
            if next_r < 0 or next_r >= height or next_c < 0 or next_c >= width:
                continue
            
            if grid[next_r][next_c] == 3:
                continue
            
            if grid[next_r][next_c] == 2:
                if (next_r, next_c) not in flow_cells:
                    flow_cells.add((next_r, next_c))
                    total_area += 1
                    grid[next_r][next_c] = current_color
                    q.append((next_r, next_c, 'left', idx + 1))
                    q.append((next_r, next_c, 'right', idx + 1))
                continue
            
            if grid[next_r][next_c] == 0:
                new_area = total_area + 1
                if new_area >= threshold:
                    if (next_r, next_c) not in flow_cells:
                        flow_cells.add((next_r, next_c))
                        total_area = new_area
                        grid[next_r][next_c] = current_color
                        q.append((next_r, next_c, direction, idx + 1))
        
        for r, c in flow_cells:
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    if (nr, nc) not in flow_cells and grid[nr][nc] == 0:
                        grid[nr][nc] = 7
        
        return grid
    
    output_grid = simulate_flow(grid, threshold)
    return tuple(tuple(row) for row in output_grid)
