# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: a6fb1112
Difficulty: very hard

=== Tags ===
- Local symmetry matching
- Dual grid translation
- Lava flow
- Reflect by color
- Color the column with fewest dots

=== Description ===
Symmetric Lava Streams  Input grids are 20Ã—20 with a background color (0). Each
grid contains multiple disjoint colored regions (1-8), where every region
exhibits local symmetry (each region is symmetric across a vertical or
horizontal axis through its centroid). Scattered across the grid are "lava
sources" (cells of color 9) positioned exclusively in the topmost row. Lava
flows downward from each source until encountering a non-background, non-lava
cell (color 1-8). Upon impact, the lava reflects according to the cell's color:
color 1 (red) reflects left, 2 (green) reflects right, 3 (blue) reflects up, and
4 (yellow) reflects down. Reflection direction is determined solely by the color
of the cell hit, not the lava's origin. The lava path replaces background cells
with color 9 along its trajectory until it exits the grid.   After completing
the lava flow, the output grid is generated by two modifications: (1) preserving
all original non-background cells (1-8) and marking lava paths with color 9; (2)
identifying the column with the fewest non-background cells (1-8) in the
*original input* grid (counting only cells of colors 1-8, not lava or
background), then coloring all background cells in that column with color 5
(gray), while preserving any pre-existing non-background cells (1-8) in the
column. The task requires simultaneously applying local symmetry constraints to
input regions, simulating multi-directional lava flow with color-dependent
reflection, and selecting a column based on a global count of non-background
elements. The complexity arises from the interplay between symmetry requirements
in the input, the non-linear path of lava flow through color-triggered
reflections, and the final column coloring that depends on pre-transformation
grid statistics.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width, height = 20, 20
    grid = [[0]*width for _ in range(height)]
    colors_used = set()
    num_regions = random.randint(3, 5)
    for _ in range(num_regions):
        color = random.randint(1, 8)
        while color in colors_used:
            color = random.randint(1, 8)
        colors_used.add(color)
        symmetry = random.choice(['vertical', 'horizontal'])
        if symmetry == 'vertical':
            c_min = random.randint(0, 9)
            c_max = 19 - c_min
            r_min = random.randint(1, 18)
            r_max = random.randint(r_min, 18)
            for r in range(r_min, r_max+1):
                for c in range(c_min, c_max+1):
                    grid[r][c] = color
        else:
            r_min = random.randint(0, 9)
            r_max = 19 - r_min
            c_min = random.randint(1, 18)
            c_max = random.randint(c_min, 18)
            for r in range(r_min, r_max+1):
                for c in range(c_min, c_max+1):
                    grid[r][c] = color
    lava_sources = []
    for c in range(width):
        if grid[0][c] == 0 and random.random() < 0.5:
            grid[0][c] = 9
            lava_sources.append(c)
    if not lava_sources:
        c = random.randint(0, 19)
        grid[0][c] = 9
        lava_sources.append(c)
    output_grid = [row[:] for row in grid]
    directions = {'down': (1, 0), 'left': (0, -1), 'right': (0, 1), 'up': (-1, 0)}
    for c in lava_sources:
        r, c = 0, c
        current_dir = 'down'
        steps = 0
        max_steps = 1000
        while steps < max_steps:
            steps += 1
            dr, dc = directions[current_dir]
            nr, nc = r + dr, c + dc
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                break
            if output_grid[nr][nc] == 0:
                output_grid[nr][nc] = 9
                r, c = nr, nc
            else:
                color = output_grid[nr][nc]
                if color == 1:
                    current_dir = 'left'
                elif color == 2:
                    current_dir = 'right'
                elif color == 3:
                    current_dir = 'up'
                elif color == 4:
                    current_dir = 'down'
                r, c = nr, nc
                continue
    col_counts = [0]*width
    for c in range(width):
        for r in range(height):
            if grid[r][c] in range(1, 9):
                col_counts[c] += 1
    min_count = min(col_counts)
    selected_col = next(c for c in range(width) if col_counts[c] == min_count)
    for r in range(height):
        if output_grid[r][selected_col] == 0:
            output_grid[r][selected_col] = 5
    return {'input': grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width, height = len(grid[0]), len(grid)
    output_grid = [row[:] for row in grid]
    directions = {'down': (1, 0), 'left': (0, -1), 'right': (0, 1), 'up': (-1, 0)}
    for c in range(width):
        if grid[0][c] == 9:
            r, c = 0, c
            current_dir = 'down'
            steps = 0
            max_steps = 1000
            while steps < max_steps:
                steps += 1
                dr, dc = directions[current_dir]
                nr, nc = r + dr, c + dc
                if nr < 0 or nr >= height or nc < 0 or nc >= width:
                    break
                if output_grid[nr][nc] == 0:
                    output_grid[nr][nc] = 9
                    r, c = nr, nc
                else:
                    color = output_grid[nr][nc]
                    if color == 1:
                        current_dir = 'left'
                    elif color == 2:
                        current_dir = 'right'
                    elif color == 3:
                        current_dir = 'up'
                    elif color == 4:
                        current_dir = 'down'
                    r, c = nr, nc
                    continue
    col_counts = [0] * width
    for c in range(width):
        for r in range(height):
            if grid[r][c] in range(1, 9):
                col_counts[c] += 1
    min_count = min(col_counts)
    selected_col = next(c for c in range(width) if col_counts[c] == min_count)
    for r in range(height):
        if output_grid[r][selected_col] == 0:
            output_grid[r][selected_col] = 5
    return output_grid
