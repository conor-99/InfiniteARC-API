# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: b8e8201b
Difficulty: very hard

=== Tags ===
- Blockwise rule application
- Chain reaction
- Pattern expansion

=== Description ===
Input grids consist of a 15×15 or larger grid with a single background color
(0), containing multiple non-overlapping colored blocks (1-9). Each block is a
4-connected region of uniform color, separated by at least one background cell
from other blocks. Blocks are arranged to form a structured lattice where
adjacent blocks may follow a sequential color relationship (e.g., color 1
adjacent to color 2, color 2 adjacent to color 3, etc., in the color sequence
1→2→3→...→9).   The transformation rule is blockwise: for each block of color C,
if it has a neighboring block (up/down/left/right) of color C+1, the block
expands in that direction by one cell, adopting color C+1. This expansion
creates a new cell in the background, merging the block's region and changing
its color. The newly expanded cell may now form a new adjacency with a block of
color C+2, triggering a chain reaction where the color increment propagates
through the grid. The process repeats iteratively until no further expansions
are possible, with all expansions resolving in a single deterministic direction
(prioritizing the first valid neighbor encountered during a systematic scan).
The output grid reflects the final state after all chain reactions have
completed, resulting in a visually expanded pattern where blocks have grown to
incorporate adjacent lower-numbered blocks, creating a continuous, color-
sequenced structure. Background cells remain unchanged except where expanded
blocks occupy them. The pattern expansion manifests as a growing, color-
sequenced lattice that transforms the input's sparse block arrangement into a
denser, interconnected network through deterministic chain reactions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    """
    Generate an input/output pair for the chain-reaction block expansion task.

    Grid is square with size between 15 and 24. Several chains (horizontal or vertical)
    of small rectangular 4-connected blocks are placed. In a chain the blocks have
    consecutive colors (c, c+1, c+2, ...), and each adjacent block in the chain
    is separated by exactly one background cell. Some stray blocks are also added.

    The output is computed by simulating the deterministic chain-reaction expansion
    rule described in the task: components scan top-to-bottom, left-to-right;
    for each component we check directions in the order up, right, down, left;
    when a valid neighbor is found the component repeatedly expands one cell in
    that direction adopting the neighbor's color (and may continue to adopt
    increasing colors) until no further expansions in that direction are possible.
    After any expansion we recompute components and restart the scan (this
    enforces the deterministic priority).
    """
    # Helper: deep copy grid
    def copy_grid(g):
        return [row[:] for row in g]

    # Simulation: same logic as the solver (kept local so generator can compute output)
    def simulate_grid(grid):
        h = len(grid)
        w = len(grid[0])
        # helper to get components
        def components_from_grid(g):
            visited = [[False] * w for _ in range(h)]
            comps = []
            for r in range(h):
                for c in range(w):
                    col = g[r][c]
                    if col == 0 or visited[r][c]:
                        continue
                    # flood fill
                    stack = [(r, c)]
                    pixels = set()
                    while stack:
                        pr, pc = stack.pop()
                        if visited[pr][pc]:
                            continue
                        if g[pr][pc] != col:
                            continue
                        visited[pr][pc] = True
                        pixels.add((pr, pc))
                        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                            nr, nc = pr + dr, pc + dc
                            if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and g[nr][nc] == col:
                                stack.append((nr, nc))
                    minr = min(p[0] for p in pixels)
                    minc = min(p[1] for p in pixels)
                    comps.append({"color": col, "pixels": pixels, "minr": minr, "minc": minc})
            # sort by topmost then leftmost pixel (deterministic scan order)
            comps.sort(key=lambda x: (x["minr"], x["minc"]))
            return comps

        # Directions: up, right, down, left (priority order)
        directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]

        changed = True
        while changed:
            changed = False
            comps = components_from_grid(grid)
            # iterate components in priority order
            for comp in comps:
                col = comp["color"]
                if col >= 9:
                    continue
                # Try each direction in fixed order
                did_expand = False
                for dr, dc in directions:
                    # Check if there is at least one pixel of comp such that
                    # the cell one step in (dr,dc) is empty and the cell two steps
                    # in (dr,dc) has color col+1. If so, we will expand in this dir.
                    found = False
                    for (pr, pc) in comp["pixels"]:
                        p1r, p1c = pr + dr, pc + dc
                        p2r, p2c = pr + 2 * dr, pc + 2 * dc
                        if not (0 <= p1r < h and 0 <= p1c < w and 0 <= p2r < h and 0 <= p2c < w):
                            continue
                        if grid[p1r][p1c] == 0 and grid[p2r][p2c] == col + 1:
                            found = True
                            break
                    if not found:
                        continue

                    # Expand repeatedly in this direction as long as possible
                    current_color = col
                    # We maintain comp_pixels as the evolving set of pixels belonging to
                    # the expanding component so successive expansions can use the new frontier.
                    comp_pixels = set(comp["pixels"])
                    while current_color < 9:
                        to_fill = set()
                        # find intermediate cells (one step away) that bridge to a color current_color+1
                        for (pr, pc) in list(comp_pixels):
                            p1r, p1c = pr + dr, pc + dc
                            p2r, p2c = pr + 2 * dr, pc + 2 * dc
                            if not (0 <= p1r < h and 0 <= p1c < w and 0 <= p2r < h and 0 <= p2c < w):
                                continue
                            if grid[p1r][p1c] == 0 and grid[p2r][p2c] == current_color + 1:
                                to_fill.add((p1r, p1c))
                        if not to_fill:
                            break
                        # recolor the whole component to the next color
                        next_color = current_color + 1
                        for (pr, pc) in list(comp_pixels):
                            grid[pr][pc] = next_color
                        # fill intermediate cells
                        for (fr, fc) in to_fill:
                            grid[fr][fc] = next_color
                        # update comp_pixels (component grows into the newly filled cells)
                        comp_pixels |= to_fill
                        current_color = next_color
                    # After performing expansions in this direction stop and restart the outer loop
                    did_expand = True
                    changed = True
                    break
                if did_expand:
                    break
            # if changed, the while loop repeats (we recompute components)
        return grid

    # Try generating until we produce a case where at least one expansion occurs (input != output)
    for attempt in range(50):
        size = random.randint(15, 24)
        height = size
        width = size
        grid = [[0 for _ in range(width)] for _ in range(height)]

        def can_place_block_at(gr, cc, bh, bw):
            # gr, cc are top-left, bh,bw block size
            if gr < 0 or cc < 0 or gr + bh > height or cc + bw > width:
                return False
            for rr in range(gr, gr + bh):
                for cc2 in range(cc, cc + bw):
                    if grid[rr][cc2] != 0:
                        return False
                    # 4-neighbors must be empty to ensure at least one background cell separates blocks
                    for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                        nr, nc = rr + dr, cc2 + dc
                        if 0 <= nr < height and 0 <= nc < width:
                            if grid[nr][nc] != 0:
                                return False
            return True

        # Place a few chains
        num_chains = random.randint(2, 4)
        placed_any_chain = False
        for _ in range(num_chains):
            placed = False
            for _try in range(200):
                orientation = random.choice([0, 1])  # 0 = horizontal, 1 = vertical
                bh = random.randint(1, 3)
                bw = random.randint(1, 3)
                # maximum chain length fitting the grid for this block size
                if orientation == 0:
                    maxL = (width + 1) // (bw + 1)
                else:
                    maxL = (height + 1) // (bh + 1)
                if maxL < 3:
                    continue
                L = random.randint(3, min(6, maxL))
                start_color = random.randint(1, 9 - (L - 1))

                # choose start coords so the whole chain fits
                if orientation == 0:
                    max_row = height - bh
                    max_col = width - (L * (bw + 1) - 1)
                    if max_col < 0 or max_row < 0:
                        continue
                    r = random.randint(0, max_row)
                    c = random.randint(0, max_col)
                else:
                    max_row = height - (L * (bh + 1) - 1)
                    max_col = width - bw
                    if max_row < 0 or max_col < 0:
                        continue
                    r = random.randint(0, max_row)
                    c = random.randint(0, max_col)

                # check all blocks in chain can be placed (they must not touch existing blocks)
                ok = True
                block_topleft = []
                for i in range(L):
                    rr = r + (i * (bh + 1) if orientation == 1 else 0)
                    cc = c + (i * (bw + 1) if orientation == 0 else 0)
                    if not can_place_block_at(rr, cc, bh, bw):
                        ok = False
                        break
                    block_topleft.append((rr, cc))
                if not ok:
                    continue
                # place chain blocks with consecutive colors
                for idx, (rr, cc) in enumerate(block_topleft):
                    color = start_color + idx
                    for dr in range(bh):
                        for dc in range(bw):
                            grid[rr + dr][cc + dc] = color
                placed = True
                placed_any_chain = True
                break
            # end tries for this chain
        # add some stray isolated blocks
        stray = random.randint(1, 4)
        stray_placed = 0
        for _ in range(500):
            if stray_placed >= stray:
                break
            bh = random.randint(1, 3)
            bw = random.randint(1, 3)
            r = random.randint(0, height - bh)
            c = random.randint(0, width - bw)
            if not can_place_block_at(r, c, bh, bw):
                continue
            color = random.randint(1, 9)
            for dr in range(bh):
                for dc in range(bw):
                    grid[r + dr][c + dc] = color
            stray_placed += 1

        # require that we actually placed at least one chain; otherwise retry
        if not placed_any_chain:
            continue

        inp = copy_grid(grid)
        out = simulate_grid(copy_grid(grid))
        # ensure input differs from output (some configurations might already be stable)
        if inp != out:
            return {"input": inp, "output": out}
    # Fallback (shouldn't normally happen): return last generated grids
    return {"input": inp, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable list of lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])

    def components_from_grid(g):
        visited = [[False] * w for _ in range(h)]
        comps = []
        for r in range(h):
            for c in range(w):
                col = g[r][c]
                if col == 0 or visited[r][c]:
                    continue
                # flood fill
                stack = [(r, c)]
                pixels = set()
                while stack:
                    pr, pc = stack.pop()
                    if visited[pr][pc]:
                        continue
                    if g[pr][pc] != col:
                        continue
                    visited[pr][pc] = True
                    pixels.add((pr, pc))
                    for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                        nr, nc = pr + dr, pc + dc
                        if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and g[nr][nc] == col:
                            stack.append((nr, nc))
                minr = min(p[0] for p in pixels)
                minc = min(p[1] for p in pixels)
                comps.append({"color": col, "pixels": pixels, "minr": minr, "minc": minc})
        comps.sort(key=lambda x: (x["minr"], x["minc"]))
        return comps

    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]  # up, right, down, left

    changed = True
    while changed:
        changed = False
        comps = components_from_grid(grid)
        for comp in comps:
            col = comp["color"]
            if col >= 9:
                continue
            did_expand = False
            for dr, dc in directions:
                # find whether expansion in this direction is possible
                found = False
                for (pr, pc) in comp["pixels"]:
                    p1r, p1c = pr + dr, pc + dc
                    p2r, p2c = pr + 2 * dr, pc + 2 * dc
                    if not (0 <= p1r < h and 0 <= p1c < w and 0 <= p2r < h and 0 <= p2c < w):
                        continue
                    if grid[p1r][p1c] == 0 and grid[p2r][p2c] == col + 1:
                        found = True
                        break
                if not found:
                    continue

                # perform repeated expansions in this direction
                current_color = col
                comp_pixels = set(comp["pixels"])
                while current_color < 9:
                    to_fill = set()
                    for (pr, pc) in list(comp_pixels):
                        p1r, p1c = pr + dr, pc + dc
                        p2r, p2c = pr + 2 * dr, pc + 2 * dc
                        if not (0 <= p1r < h and 0 <= p1c < w and 0 <= p2r < h and 0 <= p2c < w):
                            continue
                        if grid[p1r][p1c] == 0 and grid[p2r][p2c] == current_color + 1:
                            to_fill.add((p1r, p1c))
                    if not to_fill:
                        break
                    next_color = current_color + 1
                    for (pr, pc) in list(comp_pixels):
                        grid[pr][pc] = next_color
                    for (fr, fc) in to_fill:
                        grid[fr][fc] = next_color
                    comp_pixels |= to_fill
                    current_color = next_color
                did_expand = True
                changed = True
                break
            if did_expand:
                break
    return grid

