# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: b544ed14
Difficulty: very hard

=== Tags ===
- Area based reconstruction
- Color stream
- Deterministic update
- Directed cave maze

=== Description ===
Input grids feature a large (20×20 minimum) cave maze structure with solid walls
(non-background colors) and open background pathways. The maze contains a single
continuous path from the left edge to an exit on the top or right edge, with
walls blocking all alternative routes. A top-left 2×N pattern strip (N ≥ 2)
displays adjacent 2×2 color blocks defining a cyclic color sequence (e.g.,
[blue, green; red, yellow] cycles through blue → green → red → yellow →
blue...). A single source cell of the first color in this sequence is positioned
on the left edge adjacent to background cells. A distinct 2×2 bounce indicator
(color 8) is embedded within maze walls near the bottom-right.    The output
grid is generated by tracing a path starting from the source cell. The path
moves right through background cells, coloring each traversed cell with the next
color in the pattern strip's sequence. Upon hitting a wall, the wall cell is
recolored to bounce color (8), and the path direction alternates (right → up →
right → up...). The sequence cycles strictly through the pattern strip's order,
and direction alternates predictably with each collision. The path continues
until exiting the maze via the top or right edge. Walls, pattern strip, and
bounce indicator remain unchanged, while all path cells (excluding bounce cells)
are recolored according to the sequence. The transformation is deterministic:
direction alternates precisely after each collision, and the sequence cycles
without deviation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from copy import deepcopy

# Generator for ARC task b544ed14 (Task 462)
# Creates a large maze-like grid with a single left-to-top/right path and
# a top-left 2xN pattern of 2x2 blocks. Places a 2x2 bounce indicator (8)
# near the bottom-right. Produces the corresponding output by simulating
# the deterministic bounce-and-color process described in the task.

def generate():
    # Grid size (enforce >= 20)
    size = random.randint(20, 26)

    # Create a grid filled with wall colors (non-background, exclude 0 and 8)
    wall_palette = [c for c in range(1, 10) if c != 8]
    grid = [[random.choice(wall_palette) for _ in range(size)] for _ in range(size)]

    # Pattern strip (top-left): N adjacent 2x2 blocks, N >= 2
    max_N = min(5, size // 2 - 1)
    if max_N < 2:
        max_N = 2
    N = random.randint(2, max_N)
    # pick pattern colors (avoid 8)
    available = [c for c in range(1, 10) if c != 8]
    pattern_colors = random.sample(available, N)
    pattern_width = 2 * N
    for i, col_color in enumerate(pattern_colors):
        base_c = 2 * i
        for r in (0, 1):
            for c in (base_c, base_c + 1):
                grid[r][c] = col_color

    # Bounce indicator: distinct 2x2 of color 8 near bottom-right
    bounce_r = random.randint(size - 4, size - 3)
    bounce_c = random.randint(size - 4, size - 3)
    for r in (bounce_r, bounce_r + 1):
        for c in (bounce_c, bounce_c + 1):
            grid[r][c] = 8

    # Choose a starting row for the source on the left edge (avoid top pattern rows)
    min_row = 3
    max_row = size - 5
    if max_row <= min_row:
        min_row = 3
        max_row = size - 3
    r_start = random.randint(min_row, max_row)

    # Place source (first color of sequence) on left edge
    grid[r_start][0] = pattern_colors[0]

    # Carve a single unique path of background (0) cells.
    r_curr = r_start
    c_curr = 0
    direction = 'right'
    carved = set()

    # helper to ensure we don't carve over the bounce indicator or pattern blocks
    def is_in_bounce(rr, cc):
        return bounce_r <= rr <= bounce_r + 1 and bounce_c <= cc <= bounce_c + 1

    def is_in_pattern(rr, cc):
        return 0 <= rr <= 1 and 0 <= cc < pattern_width

    # Try to build a path by alternating horizontal (right) and vertical (up) segments.
    exit_reached = False
    guard = 0
    while not exit_reached and guard < 40:
        guard += 1
        if direction == 'right':
            if c_curr >= size - 1:
                exit_reached = True
                break

            # Choose the final background column for this horizontal run.
            min_new_col = c_curr + 1
            # Ensure first horizontal run's collision column will be beyond pattern
            if c_curr == 0:
                min_new_col = max(min_new_col, pattern_width - 1)

            max_new_col = size - 1
            # Clamp
            if min_new_col > max_new_col:
                min_new_col = max_new_col

            # Prefer non-exit steps early; but allow exit when we get close to right edge
            if random.random() < 0.25 and max_new_col == size - 1:
                new_col = max_new_col
            else:
                new_col = random.randint(min_new_col, max_new_col)

            # Carve background cells from c_curr+1 .. new_col (inclusive)
            for cc in range(c_curr + 1, new_col + 1):
                if is_in_bounce(r_curr, cc) or is_in_pattern(r_curr, cc):
                    # avoid carving into special blocks; stop earlier
                    new_col = cc - 1
                    break
                grid[r_curr][cc] = 0
                carved.add((r_curr, cc))

            # If we carved into the rightmost column, we exit to the right
            if new_col >= size - 1:
                exit_reached = True
                break

            # Otherwise leave the next cell as a wall (collision cell) and move to it
            collision_col = new_col + 1
            if collision_col >= size:
                exit_reached = True
                break
            c_curr = collision_col
            # direction alternates
            direction = 'up'

        else:  # direction == 'up'
            if r_curr <= 0:
                exit_reached = True
                break

            # Vertical carving upwards from r_curr-1 down to new_row
            max_up_row = r_curr - 1
            if max_up_row < 0:
                exit_reached = True
                break

            # Determine how far we can go up safely
            min_allowed_row = 0
            if c_curr < pattern_width:
                min_allowed_row = 2

            # Clamp
            if min_allowed_row > max_up_row:
                new_row = max_up_row
            else:
                if random.random() < 0.25 and min_allowed_row == 0:
                    new_row = 0
                else:
                    new_row = random.randint(min_allowed_row, max_up_row)

            # Carve background cells from r_curr-1 down to new_row (inclusive)
            carved_ok = True
            for rr in range(r_curr - 1, new_row - 1, -1):
                if is_in_bounce(rr, c_curr) or is_in_pattern(rr, c_curr):
                    # Avoid special blocks; stop earlier
                    carved_ok = False
                    new_row = rr + 1
                    break
                grid[rr][c_curr] = 0
                carved.add((rr, c_curr))

            if not carved_ok and new_row > r_curr - 1:
                exit_reached = True
                break

            # If we carved to top row, we exit upwards
            if new_row <= 0:
                exit_reached = True
                break

            # Otherwise leave the next cell above as a wall (collision cell)
            collision_row = new_row - 1
            if collision_row < 0:
                exit_reached = True
                break
            r_curr = collision_row
            direction = 'right'

    # If for some reason we never reached an exit, force an exit to the right by carving to the last column
    if not exit_reached:
        safe_row = r_start
        for rr in range(2, size - 2):
            if all(not is_in_bounce(rr, cc) and not is_in_pattern(rr, cc) for cc in range(2, size - 2)):
                safe_row = rr
                break
        for cc in range(1, size):
            grid[safe_row][cc] = 0
            carved.add((safe_row, cc))

    # Ensure source adjacency (left edge) is open to a background cell
    if grid[r_start][1] != 0:
        grid[r_start][1] = 0
        carved.add((r_start, 1))

    # Build the output by simulating the deterministic bounce-and-color process
    output = deepcopy(grid)

    # Find pattern colors in order (top-left 2x2 blocks)
    colors = []
    c = 0
    while c + 1 < size:
        val = grid[0][c]
        if val != 0 and val != 8 and grid[0][c + 1] == val and grid[1][c] == val and grid[1][c + 1] == val:
            colors.append(val)
            c += 2
        else:
            break
    if not colors:
        # fallback in the unlikely event pattern detection fails
        colors = [1, 2]

    # Locate source cell on left edge
    src_r = None
    for rr in range(size):
        if grid[rr][0] == colors[0] and (0 < size and grid[rr][1] == 0):
            src_r = rr
            break
    if src_r is None:
        # in a pathological case, pick a carved row that has left-edge adjacency
        for rr in range(size):
            if grid[rr][1] == 0:
                src_r = rr
                grid[rr][0] = colors[0]
                break

    # Simulate
    dr, dc = 0, 1  # start moving right
    r, c = src_r, 1
    color_idx = 1  # first step after the source uses the second color in the pattern
    max_steps = size * size
    steps = 0
    while 0 <= r < size and 0 <= c < size and steps < max_steps:
        steps += 1
        # Only recolor cells that were background in the input (do not recolor special blocks)
        if grid[r][c] == 0:
            output[r][c] = colors[color_idx % len(colors)]
            color_idx += 1

        nr, nc = r + dr, c + dc
        # If next step goes out of bounds, that is an exit
        if not (0 <= nr < size and 0 <= nc < size):
            break

        # If next cell is background, advance into it
        if grid[nr][nc] == 0:
            r, c = nr, nc
            continue

        # Otherwise we hit a wall (or a special block). Mark the hit cell with bounce color 8 if it wasn't already 8.
        if grid[nr][nc] != 8:
            output[nr][nc] = 8
        # Move into the hit cell and toggle direction (right <-> up)
        r, c = nr, nc
        if (dr, dc) == (0, 1):
            dr, dc = -1, 0
        else:
            dr, dc = 0, 1

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from copy import deepcopy

def p(input_grid):
    # Convert input to a mutable list-of-lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])

    # Find pattern colors in the top-left 2xN arrangement of 2x2 blocks
    colors = []
    c = 0
    while c + 1 < w:
        val = grid[0][c]
        if val != 0 and val != 8 and grid[0][c + 1] == val and grid[1][c] == val and grid[1][c + 1] == val:
            colors.append(val)
            c += 2
        else:
            break
    if not colors:
        # fallback
        colors = [1, 2]

    # Find the source cell on the left edge: non-background and adjacent to a background cell
    src_r = None
    for r in range(h):
        if grid[r][0] == colors[0] and w > 1 and grid[r][1] == 0:
            src_r = r
            break
    if src_r is None:
        # fallback: find any left-edge non-background that has a zero to the right
        for r in range(h):
            if grid[r][0] != 0 and w > 1 and grid[r][1] == 0:
                src_r = r
                break
    if src_r is None:
        # no source found; return the grid unchanged
        return grid

    output = deepcopy(grid)

    # Start simulation: first step after the source begins at column 1, moving right
    r, c = src_r, 1
    dr, dc = 0, 1
    color_idx = 1  # first moved-into background cell gets the second color in the pattern
    steps = 0
    max_steps = h * w

    while 0 <= r < h and 0 <= c < w and steps < max_steps:
        steps += 1
        # Color only if this cell was background in the input
        if grid[r][c] == 0:
            output[r][c] = colors[color_idx % len(colors)]
            color_idx += 1

        nr, nc = r + dr, c + dc
        # If moving out of the grid -> exit
        if not (0 <= nr < h and 0 <= nc < w):
            break

        if grid[nr][nc] == 0:
            r, c = nr, nc
            continue

        # Hit a wall or special block: mark bounce if not already 8, toggle direction, move into it
        if grid[nr][nc] != 8:
            output[nr][nc] = 8
        r, c = nr, nc
        if (dr, dc) == (0, 1):
            dr, dc = -1, 0
        else:
            dr, dc = 0, 1

    return output

