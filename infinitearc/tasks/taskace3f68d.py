# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: ace3f68d
Difficulty: hard

=== Tags ===
- Compare image
- Detect symmetry
- Spacing

=== Description ===
The task involves transforming an input grid into an output grid by detecting
the primary axis of symmetry (vertical or horizontal) in the arrangement of non-
zero elements. The input grid contains a sequence of colored pixels (values 1-9)
arranged in a single row or column with inconsistent spacing between consecutive
elements. The output grid must adjust the spacing to be uniform—calculated as
the rounded average of the input's inter-element distances—while ensuring the
sequence is symmetric with respect to the grid's vertical or horizontal center.
The symmetry axis is determined by the input's dominant pattern (e.g.,
horizontal row alignment implies vertical symmetry). The transformation requires
identifying the correct axis, computing the average spacing, and repositioning
elements to achieve both symmetry and uniform spacing, preserving the original
colors of the elements. This process demands multi-step reasoning, including
spatial analysis and arithmetic adjustment, making it challenging to deduce from
limited examples.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

from common import grid
import random

def generate():
    is_horizontal = random.choice([True, False])
    if is_horizontal:
        num_elements = random.randint(3, 5)
        colors = [random.randint(1, 9) for _ in range(num_elements)]
        positions = [0]
        for _ in range(1, num_elements):
            positions.append(positions[-1] + random.randint(1, 4))
        
        # Ensure inconsistent spacing
        while True:
            gaps = [positions[i+1] - positions[i] for i in range(len(positions)-1)]
            if not all(g == gaps[0] for g in gaps):
                break
            positions = [0]
            for _ in range(1, num_elements):
                positions.append(positions[-1] + random.randint(1, 4))
            if positions[-1] >= 30:
                positions = [0]
                for _ in range(1, num_elements):
                    positions.append(positions[-1] + random.randint(1, 4))
                    if positions[-1] >= 30:
                        positions[-1] = 29
        
        input_width = positions[-1] + 1
        input_grid = grid(input_width, 1, 0)
        for i, pos in enumerate(positions):
            input_grid[0][pos] = colors[i]
        
        gaps = [positions[i+1] - positions[i] for i in range(num_elements-1)]
        avg_gap = round(sum(gaps) / len(gaps))
        output_width = (num_elements - 1) * avg_gap + 1
        if output_width > 30:
            avg_gap = (30 - 1) // (num_elements - 1)
            output_width = (num_elements - 1) * avg_gap + 1
        start = (output_width - (num_elements - 1) * avg_gap - 1) // 2
        output_positions = [start + i * avg_gap for i in range(num_elements)]
        output_grid = grid(output_width, 1, 0)
        for i, pos in enumerate(output_positions):
            output_grid[0][pos] = colors[i]
    else:
        num_elements = random.randint(3, 5)
        colors = [random.randint(1, 9) for _ in range(num_elements)]
        positions = [0]
        for _ in range(1, num_elements):
            positions.append(positions[-1] + random.randint(1, 4))
        
        # Ensure inconsistent spacing
        while True:
            gaps = [positions[i+1] - positions[i] for i in range(len(positions)-1)]
            if not all(g == gaps[0] for g in gaps):
                break
            positions = [0]
            for _ in range(1, num_elements):
                positions.append(positions[-1] + random.randint(1, 4))
            if positions[-1] >= 30:
                positions = [0]
                for _ in range(1, num_elements):
                    positions.append(positions[-1] + random.randint(1, 4))
                    if positions[-1] >= 30:
                        positions[-1] = 29
        
        input_height = positions[-1] + 1
        input_grid = grid(1, input_height, 0)
        for i, pos in enumerate(positions):
            input_grid[pos][0] = colors[i]
        
        gaps = [positions[i+1] - positions[i] for i in range(num_elements-1)]
        avg_gap = round(sum(gaps) / len(gaps))
        output_height = (num_elements - 1) * avg_gap + 1
        if output_height > 30:
            avg_gap = (30 - 1) // (num_elements - 1)
            output_height = (num_elements - 1) * avg_gap + 1
        start = (output_height - (num_elements - 1) * avg_gap - 1) // 2
        output_positions = [start + i * avg_gap for i in range(num_elements)]
        output_grid = grid(1, output_height, 0)
        for i, pos in enumerate(output_positions):
            output_grid[pos][0] = colors[i]
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid
import random

def p(input_grid):
    non_zero = []
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] != 0:
                non_zero.append((r, c))
    
    rows = [pos[0] for pos in non_zero]
    cols = [pos[1] for pos in non_zero]
    
    if all(r == rows[0] for r in rows):
        # Horizontal
        sorted_cols = sorted(cols)
        colors = [input_grid[rows[0]][c] for c in sorted_cols]
        num_elements = len(non_zero)
        gaps = [sorted_cols[i+1] - sorted_cols[i] for i in range(num_elements-1)]
        avg_gap = round(sum(gaps) / len(gaps))
        output_width = (num_elements - 1) * avg_gap + 1
        if output_width > 30:
            avg_gap = (30 - 1) // (num_elements - 1)
            output_width = (num_elements - 1) * avg_gap + 1
        start = (output_width - (num_elements - 1) * avg_gap - 1) // 2
        output_positions = [start + i * avg_gap for i in range(num_elements)]
        output_grid = grid(output_width, 1, 0)
        for i, c in enumerate(output_positions):
            output_grid[0][c] = colors[i]
        return output_grid
    elif all(c == cols[0] for c in cols):
        # Vertical
        sorted_rows = sorted(rows)
        colors = [input_grid[r][cols[0]] for r in sorted_rows]
        num_elements = len(non_zero)
        gaps = [sorted_rows[i+1] - sorted_rows[i] for i in range(num_elements-1)]
        avg_gap = round(sum(gaps) / len(gaps))
        output_height = (num_elements - 1) * avg_gap + 1
        if output_height > 30:
            avg_gap = (30 - 1) // (num_elements - 1)
            output_height = (num_elements - 1) * avg_gap + 1
        start = (output_height - (num_elements - 1) * avg_gap - 1) // 2
        output_positions = [start + i * avg_gap for i in range(num_elements)]
        output_grid = grid(1, output_height, 0)
        for i, r in enumerate(output_positions):
            output_grid[r][0] = colors[i]
        return output_grid
    else:
        # Fallback, though shouldn't happen
        return input_grid
