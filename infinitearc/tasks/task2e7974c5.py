# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 2e7974c5
Difficulty: insane

=== Tags ===
- Only one
- Image rotation
- Long range bridge construction
- Take maximum

=== Description ===
The input grid contains exactly one non-zero pixel (all other cells are 0). The
transformation involves rotating the grid 90 degrees clockwise, then
constructing a horizontal "bridge" across the entire row containing the rotated
pixel. This bridge uses the pixel's value, which is the maximum value in the
input grid (as it is the only non-zero value), resulting in the entire row being
filled with this value. The output grid thus features the rotated input with the
row of the rotated pixel expanded into a full bridge of the maximum value.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    while width == 1 and height == 1:
        width = random.randint(1, 30)
        height = random.randint(1, 30)
    color = random.randint(1, 9)
    input_grid = [[0] * width for _ in range(height)]
    r = random.randint(0, height - 1)
    c = random.randint(0, width - 1)
    input_grid[r][c] = color
    rotated = [list(x) for x in zip(*input_grid[::-1])]
    for i in range(len(rotated)):
        if color in rotated[i]:
            rotated[i] = [color] * len(rotated[i])
            break
    return {
        "input": input_grid,
        "output": rotated
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    color = None
    for r in range(len(input_grid)):
        for c in range(len(input_grid[r])):
            if input_grid[r][c] != 0:
                color = input_grid[r][c]
                break
        if color is not None:
            break
    rotated = [list(x) for x in zip(*input_grid[::-1])]
    for i in range(len(rotated)):
        if color in rotated[i]:
            rotated[i] = [color] * len(rotated[i])
            break
    return rotated
