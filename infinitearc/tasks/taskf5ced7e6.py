# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: f5ced7e6
Difficulty: mediumâ€“hard

=== Tags ===
- Rule embedding
- Contextual rule switch
- Cluster by shape

=== Description ===
Input grids consist of multiple clusters of colored cells (each cluster is a
connected region of identical color, with colors ranging from 1 to 9),
categorized by their geometric shape (e.g., L-shaped, T-shaped, square, or
line). Square-shaped clusters serve as contextual reference points for
transforming other clusters. For each non-square cluster, the transformation
applied depends on the relative position of the nearest square-shaped cluster:
if the nearest square is positioned to the right of the non-square cluster, the
non-square cluster is mirrored horizontally; if the nearest square is positioned
to the left, the non-square cluster is rotated 90 degrees clockwise. Square-
shaped clusters remain unchanged in the output. Background cells (color 0) are
preserved without modification. The transformation must be applied to all non-
square clusters based on their contextual relationship with square clusters,
requiring the solver to identify both cluster shapes and spatial relationships
to derive the correct output grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_colors

# Shape templates are small connected shapes (not 2x2 squares)
SHAPES = [
    # L shape (height 3 x width 2)
    [(0,0),(1,0),(2,0),(2,1)],
    # T shape (height 2 x width 3)
    [(0,0),(0,1),(0,2),(1,1)],
    # horizontal line length 3 (height 1 x width 3)
    [(0,0),(0,1),(0,2)],
    # Z-like shape (height 2 x width 3)
    [(0,1),(0,2),(1,0),(1,1)],
    # small L variant (height 2 x width 2 but not full square)
    [(0,0),(1,0),(1,1)]
]


def _bbox(points):
    rs = [p[0] for p in points]
    cs = [p[1] for p in points]
    return min(rs), min(cs), max(rs), max(cs)


def _place_block_free(occupancy, points):
    # Return True if all points are free
    for (r,c) in points:
        if occupancy[r][c]:
            return False
    return True


def _apply_shape(grid_in, occupancy, points, r0, c0, color):
    for (rr, cc) in points:
        r = r0 + rr
        c = c0 + cc
        grid_in[r][c] = color
        occupancy[r][c] = True


def generate():
    # Try generation until a valid arrangement is built.
    for attempt_overall in range(200):
        width = random.randint(7, 20)
        height = random.randint(7, 20)
        input_grid = grid(width, height, 0)
        occupancy = [[False] * width for _ in range(height)]

        # decide how many squares and non-squares
        n_squares = random.randint(1, min(3, max(1, (width * height) // 60)))
        n_non = random.randint(2, min(6, 8 - n_squares))

        total = n_squares + n_non
        # choose distinct colors for all clusters
        colors = random_colors(total, exclude=[0])
        square_colors = colors[:n_squares]
        non_colors = colors[n_squares:]

        squares = []  # list of (top_r, top_c, color)
        failed = False

        # place squares (2x2) non-overlapping
        for sc in square_colors:
            placed = False
            for _ in range(200):
                r0 = random.randint(0, height - 2)
                c0 = random.randint(0, width - 2)
                points = [(r0 + dr, c0 + dc) for dr in (0,1) for dc in (0,1)]
                if not _place_block_free(occupancy, points):
                    continue
                # place square
                for (r,c) in points:
                    input_grid[r][c] = sc
                    occupancy[r][c] = True
                squares.append((r0, c0, sc))
                placed = True
                break
            if not placed:
                failed = True
                break
        if failed:
            continue

        # place non-square shapes
        non_clusters = []  # list of (points_abs_list, color)
        for nc in non_colors:
            placed = False
            for _ in range(400):
                shape = random.choice(SHAPES)
                # shape bbox
                sh_min_r, sh_min_c, sh_max_r, sh_max_c = _bbox(shape)
                sh_h = sh_max_r - sh_min_r + 1
                sh_w = sh_max_c - sh_min_c + 1

                # pick an anchor so original shape fits
                if height - sh_h < 0 or width - sh_w < 0:
                    continue
                r0 = random.randint(0, height - sh_h)
                c0 = random.randint(0, width - sh_w)

                # compute absolute original points
                abs_points = [(r0 + rr, c0 + cc) for (rr, cc) in shape]
                if not _place_block_free(occupancy, abs_points):
                    continue

                # compute rotated bounding box fit (rotation about shape's top-left)
                # rotated dims will be sh_w x sh_h ; top-left stays at (r0, c0)
                if r0 + sh_w - 1 >= height or c0 + sh_h - 1 >= width:
                    # rotated would not fit -> skip anchor
                    continue

                # compute rotated absolute points
                rotated_points = []
                for (rr, cc) in shape:
                    new_r = r0 + cc
                    new_c = c0 + (sh_h - 1 - rr)
                    rotated_points.append((new_r, new_c))

                # ensure rotated positions do not overlap any square cell (we keep squares unchanged)
                collide_with_square = False
                for (sr, sc, scol) in squares:
                    sq_points = [(sr + dr, sc + dc) for dr in (0,1) for dc in (0,1)]
                    for p in rotated_points:
                        if p in sq_points:
                            collide_with_square = True
                            break
                    if collide_with_square:
                        break
                if collide_with_square:
                    continue

                # ensure rotated positions also do not overlap already placed clusters
                if not _place_block_free(occupancy, rotated_points):
                    # if rotated positions would collide with existing placement, skip
                    continue

                # ok place shape and reserve rotated targets so later placements won't collide with them
                _apply_shape(input_grid, occupancy, shape, r0, c0, nc)
                for (nr, nc2) in rotated_points:
                    occupancy[nr][nc2] = True
                non_clusters.append((abs_points, nc))
                placed = True
                break
            if not placed:
                failed = True
                break
        if failed:
            continue

        # Build output grid by transforming non-square clusters depending on nearest square
        output_grid = [row[:] for row in input_grid]

        # precompute square centroids
        square_centroids = []  # (r_centroid, c_centroid, top_r, top_c, color)
        for (sr, sc, scol) in squares:
            square_centroids.append((sr + 0.5, sc + 0.5, sr, sc, scol))

        for (pts, color) in non_clusters:
            # compute centroid of cluster
            cen_r = sum(r for (r, c) in pts) / len(pts)
            cen_c = sum(c for (r, c) in pts) / len(pts)
            # find nearest square by Euclidean squared distance, break ties by preferring rightmost square
            best = None
            for (qr, qc, tr, tc, scol) in square_centroids:
                d2 = (qr - cen_r) ** 2 + (qc - cen_c) ** 2
                key = (d2, -qc)
                item = (key, (qr, qc, tr, tc, scol))
                if best is None or item[0] < best[0]:
                    best = item
            if best is None:
                continue
            (_, _), nearest = best
            qr, qc, tr, tc, scol = nearest

            # bounding box of original cluster
            min_r = min(r for (r, c) in pts)
            max_r = max(r for (r, c) in pts)
            min_c = min(c for (r, c) in pts)
            max_c = max(c for (r, c) in pts)
            sh_h = max_r - min_r + 1
            sh_w = max_c - min_c + 1

            # decide transformation: if square is to the right -> mirror horizontally; else rotate 90 cw
            if qc > cen_c:
                # mirror across vertical axis of bounding box
                new_points = [(r, min_c + max_c - c) for (r, c) in pts]
            else:
                # rotate 90 degrees clockwise around bounding-box top-left
                new_points = [(min_r + (c - min_c), min_c + (sh_h - 1 - (r - min_r))) for (r, c) in pts]

            # clear original cells (unless they're squares, but non-squares won't overlap squares by construction)
            for (r, c) in pts:
                output_grid[r][c] = 0

            # paint new cells (do not overwrite squares)
            square_cells = set()
            for (sr, sc, scol) in squares:
                for dr in (0,1):
                    for dc in (0,1):
                        square_cells.add((sr + dr, sc + dc))

            for (r, c) in new_points:
                if 0 <= r < height and 0 <= c < width and (r, c) not in square_cells:
                    output_grid[r][c] = color

        # ensure output differs from input
        if output_grid == input_grid:
            continue

        return {"input": input_grid, "output": output_grid}

    # if we get here, something went wrong; fallback trivial case
    width = 7
    height = 7
    g = grid(width, height, 0)
    g[1][1] = 1
    g[1][2] = 1
    return {"input": g, "output": g}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])

    # helper to find connected clusters (4-neighborhood)
    visited = [[False] * width for _ in range(height)]
    clusters = []  # list of (color, points_list)

    for r in range(height):
        for c in range(width):
            if visited[r][c] or grid_in[r][c] == 0:
                continue
            color = grid_in[r][c]
            # BFS
            stack = [(r,c)]
            visited[r][c] = True
            pts = []
            while stack:
                cr, cc = stack.pop()
                pts.append((cr, cc))
                for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid_in[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            clusters.append((color, pts))

    # identify square clusters (2x2 filled)
    squares = []  # list of (top_r, top_c, color)
    remaining_clusters = []
    for (color, pts) in clusters:
        if len(pts) == 4:
            min_r = min(r for (r,c) in pts)
            max_r = max(r for (r,c) in pts)
            min_c = min(c for (r,c) in pts)
            max_c = max(c for (r,c) in pts)
            if max_r - min_r == 1 and max_c - min_c == 1:
                # ensure all four cells present
                expected = {(min_r + dr, min_c + dc) for dr in (0,1) for dc in (0,1)}
                if set(pts) == expected:
                    squares.append((min_r, min_c, color))
                    continue
        remaining_clusters.append((color, pts))

    # prepare output grid copy
    output = [row[:] for row in grid_in]

    # prepare square centroid list
    square_centroids = []
    for (sr, sc, scol) in squares:
        square_centroids.append((sr + 0.5, sc + 0.5, sr, sc, scol))

    square_cells = set()
    for (sr, sc, scol) in squares:
        for dr in (0,1):
            for dc in (0,1):
                square_cells.add((sr + dr, sc + dc))

    # transformation helpers (must match generator)
    def mirror_points(pts):
        min_c = min(c for (r,c) in pts)
        max_c = max(c for (r,c) in pts)
        return [(r, min_c + max_c - c) for (r,c) in pts]

    def rotate_90_cw_about_topleft(pts):
        min_r = min(r for (r,c) in pts)
        max_r = max(r for (r,c) in pts)
        min_c = min(c for (r,c) in pts)
        # shape height
        h = max_r - min_r + 1
        return [(min_r + (c - min_c), min_c + (h - 1 - (r - min_r))) for (r,c) in pts]

    # apply rules to each non-square cluster
    for (color, pts) in remaining_clusters:
        # compute centroid
        cen_r = sum(r for (r,c) in pts) / len(pts)
        cen_c = sum(c for (r,c) in pts) / len(pts)
        # find nearest square (tiebreak: prefer rightmost square)
        best = None
        for (qr, qc, tr, tc, scol) in square_centroids:
            d2 = (qr - cen_r) ** 2 + (qc - cen_c) ** 2
            key = (d2, -qc)
            item = (key, (qr, qc, tr, tc, scol))
            if best is None or item[0] < best[0]:
                best = item
        if best is None:
            continue
        (_, _), nearest = best
        qr, qc, tr, tc, scol = nearest

        # choose transformation: if square is to the right (centroid col greater) -> mirror; else rotate
        if qc > cen_c:
            new_pts = mirror_points(pts)
        else:
            new_pts = rotate_90_cw_about_topleft(pts)

        # erase original (do not erase squares)
        for (r,c) in pts:
            if (r,c) not in square_cells:
                output[r][c] = 0
        # paint new (do not overwrite squares)
        for (r,c) in new_pts:
            if 0 <= r < height and 0 <= c < width and (r,c) not in square_cells:
                output[r][c] = color

    return tuple(tuple(row) for row in output)

