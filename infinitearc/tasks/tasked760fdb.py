# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: ed760fdb
Difficulty: hard

=== Tags ===
- Staircase construction
- Infer hidden grid
- Transformation stack
- Gravity
- Find and fix broken symmetry
- Diagonals

=== Description ===
Input grids feature a fragmented diagonal staircase pattern composed of distinct
colors, where each step should form a contiguous block offset diagonally (e.g.,
step 1 at top-left, step 2 one cell down-right, etc.). The staircase is intended
to be symmetric across the main diagonal (top-left to bottom-right), but the
input contains broken symmetry: some diagonal steps are missing or misplaced,
and elements are scattered rather than aligned. Background cells (color 0)
surround all elements.  To generate the output, two key transformations are
applied sequentially:   1. **Gravity Alignment**: All non-background elements
fall downward within their columns until they hit the grid boundary or another
non-background element. This stacks elements into a solid base, resolving
vertical misalignment but preserving column positions.   2. **Symmetry
Restoration**: The base is analyzed for diagonal symmetry. Missing steps on one
side of the main diagonal are inferred and mirrored from existing steps on the
other side. The output completes the staircase into a perfectly symmetric
diagonal structure, with each step offset diagonally and no gaps or overlaps.
The output grid reveals a continuous, symmetric staircase pattern formed by the
original elements, now correctly positioned along the diagonal with all symmetry
broken by the input fixed through mirroring.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_color

def apply_gravity_stack(grid):
    h = len(grid)
    w = len(grid[0])
    new_grid = [[0] * w for _ in range(h)]
    for c in range(w):
        col_vals = [grid[r][c] for r in range(h) if grid[r][c] != 0]
        for idx, val in enumerate(col_vals):
            new_grid[h - len(col_vals) + idx][c] = val
    return new_grid

def apply_symmetry(grid):
    h = len(grid)
    w = len(grid[0])
    sym_grid = [row[:] for row in grid]
    for r in range(h):
        for c in range(w):
            if grid[r][c] != 0 and sym_grid[c][r] == 0:
                sym_grid[c][r] = grid[r][c]
    return sym_grid

def generate():
    width = random.randint(5, 10)
    height = width
    base = grid(width, height, 0)
    for i in range(width):
        base[i][i] = random_color(exclude=[0])
    
    perturbed = [row[:] for row in base]
    non_zero = []
    for r in range(height):
        for c in range(width):
            if base[r][c] != 0:
                non_zero.append((r, c, base[r][c]))
    
    num_to_move = random.randint(1, len(non_zero) // 2)
    for _ in range(num_to_move):
        r, c, color = random.choice(non_zero)
        new_r, new_c = random.randint(0, height-1), random.randint(0, width-1)
        while (new_r, new_c) == (r, c):
            new_r, new_c = random.randint(0, height-1), random.randint(0, width-1)
        perturbed[r][c] = 0
        perturbed[new_r][new_c] = color
        non_zero.remove((r, c, color))
    
    gravity_grid = apply_gravity_stack(perturbed)
    output = apply_symmetry(gravity_grid)
    
    return {"input": perturbed, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random
from common import grid, random_color

def apply_gravity_stack(grid):
    h = len(grid)
    w = len(grid[0])
    new_grid = [[0] * w for _ in range(h)]
    for c in range(w):
        col_vals = [grid[r][c] for r in range(h) if grid[r][c] != 0]
        for idx, val in enumerate(col_vals):
            new_grid[h - len(col_vals) + idx][c] = val
    return new_grid

def apply_symmetry(grid):
    h = len(grid)
    w = len(grid[0])
    sym_grid = [row[:] for row in grid]
    for r in range(h):
        for c in range(w):
            if grid[r][c] != 0 and sym_grid[c][r] == 0:
                sym_grid[c][r] = grid[r][c]
    return sym_grid

def p(input_grid):
    gravity_grid = apply_gravity_stack(input_grid)
    output = apply_symmetry(gravity_grid)
    return output
