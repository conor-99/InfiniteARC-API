# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 3636a150
Difficulty: very hard

=== Tags ===
- Hierarchical agent routing
- Pattern alignment

=== Description ===
Input grids feature three concentric rectangular frames, each centered and
separated by exactly two background cells. Each frame contains a contiguous path
formed by a sequence of connected cells of a single color, representing a
visually distinct geometric pattern (e.g., a spiral, zig-zag, or angular
sequence). The path in each frame is transformed from the previous frame through
a consistent sequence of operations: a 90° clockwise rotation, a horizontal
reflection, and a color shift to the next color in a predefined cycle (e.g., red
→ blue → green → yellow → orange → red, skipping background and zero values).
The background color is distinct from all path colors. The transformation must
be deduced from the three provided frames to generate the fourth frame. The
output grid adds a new innermost frame with a path derived by applying the same
rotation, reflection, and color cycle to the third frame’s path, while
preserving all outer frames and background structure. The challenge lies in
identifying the exact transformation sequence (including the order of
rotation/reflection) and color progression from limited examples, requiring
multi-step visual reasoning to align the paths across hierarchical levels.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Generator for ARC task: concentric rectangular frames with perimeter paths

def perim_length(size):
    return 4 * (size - 1) if size > 1 else 1


def perimeter_coords(size, t):
    """Map perimeter index t to (r, c) within a size x size box.

    Perimeter indexing goes: top edge left->right (0..size-2),
    right edge top->bottom (0..size-2), bottom edge right->left,
    left edge bottom->top.
    """
    seg = size - 1
    if seg == 0:
        return (0, 0)
    if t < seg:
        return (0, t)
    t -= seg
    if t < seg:
        return (t, size - 1)
    t -= seg
    if t < seg:
        return (size - 1, size - 1 - t)
    t -= seg
    return (size - 1 - t, 0)


def coords_to_t(size, r, c):
    seg = size - 1
    if seg == 0:
        return 0
    if r == 0:
        return c
    if c == size - 1:
        return seg + r
    if r == size - 1:
        return 2 * seg + (size - 1 - c)
    if c == 0:
        return 3 * seg + (size - 1 - r)
    # We expect only perimeter coords here in our generator.
    raise ValueError("coords_to_t expects perimeter coordinates")


def map_path_tlist(path_tlist, size_from, size_to):
    """Apply rotation (90 cw) then horizontal reflection to a perimeter path
    represented by perimeter indices (t) in a size_from box and map the
    transformed positions to perimeter indices of a size_to box.

    After mapping individual points we connect successive mapped indices
    along the smaller perimeter in the shortest direction so the result is
    a contiguous path.
    """
    P_from = perim_length(size_from)
    P_to = perim_length(size_to)
    if P_from == 0 or P_to == 0:
        return []

    mapped = []
    for t in path_tlist:
        r, c = perimeter_coords(size_from, t)
        # rotate 90 degrees clockwise
        r1 = c
        c1 = size_from - 1 - r
        # horizontal reflection (mirror left-right)
        r2 = r1
        c2 = size_from - 1 - c1
        t2_frac = coords_to_t(size_from, r2, c2) / float(P_from)
        t2 = int(round(t2_frac * P_to)) % P_to
        mapped.append(t2)

    if not mapped:
        return []

    # Connect successive mapped indices along the target perimeter
    final = [mapped[0]]
    for i in range(1, len(mapped)):
        prev = final[-1]
        curr = mapped[i]
        if curr == prev:
            continue
        diff = (curr - prev) % P_to
        if diff <= P_to - diff:
            step = 1
            steps_needed = diff
        else:
            step = -1
            steps_needed = P_to - diff
        for _ in range(steps_needed):
            prev = (prev + step) % P_to
            final.append(prev)

    # Remove duplicates while preserving order
    seen = set()
    uniq = []
    for t in final:
        if t not in seen:
            seen.add(t)
            uniq.append(t)
    return uniq


def make_perimeter_path(size, seed_val):
    """Deterministic-per-seed perimeter path for a given box size.

    The path is an ordered contiguous run along the perimeter.
    """
    P = perim_length(size)
    if P == 0:
        return []
    # path length at least 6 (or P if P < 6) and at most P-2 to avoid filling whole ring
    min_len = min(6, P)
    max_len = max(6, P - 2)
    if max_len < min_len:
        max_len = min_len
    L = min_len + (seed_val % (max_len - min_len + 1))
    start = (seed_val * 7 + 3) % P
    direction = 1 if ((seed_val // 3) % 2 == 0) else -1
    path = []
    for i in range(L):
        t = (start + direction * i) % P
        path.append(t)
    return path


def pick_three_colors(seed):
    colors = list(range(1, 10))
    out = []
    s = seed
    # pick three distinct colors deterministically
    for _ in range(3):
        idx = s % len(colors)
        out.append(colors.pop(idx))
        s = (s // 2) + 3
    return out


def generate():
    # keep an internal counter so repeated calls produce different examples
    global _counter
    try:
        _counter += 1
    except NameError:
        _counter = 0
    i = _counter

    # Outer grid size must be >= 15 so we can have three nested frames with 2-cell gaps
    G = 15 + (i % 11)  # 15..25

    # Frame sizes (concentric, separated by exactly two background cells)
    S0 = G
    S1 = S0 - 4
    S2 = S1 - 4
    S3 = max(3, S2 - 4)

    # choose a 3-color cycle (colors != 0)
    c1, c2, c3 = pick_three_colors(i + 11)

    # create the outermost perimeter path
    tlist1 = make_perimeter_path(S0, i + 5)
    # derive subsequent frames by applying the fixed transform
    tlist2 = map_path_tlist(tlist1, S0, S1)
    tlist3 = map_path_tlist(tlist2, S1, S2)
    # the new inner frame (for output) is transform of frame3
    tlist4 = map_path_tlist(tlist3, S2, S3)

    # build input and output grids
    input_grid = grid(G, G, 0)
    output_grid = grid(G, G, 0)

    # place the three frames at offsets 0,2,4
    offsets = [0, 2, 4]
    sizes = [S0, S1, S2]
    tlists = [tlist1, tlist2, tlist3]
    colors = [c1, c2, c3]

    for off, sz, tlist, col in zip(offsets, sizes, tlists, colors):
        for t in tlist:
            r, c = perimeter_coords(sz, t)
            input_grid[off + r][off + c] = col
            output_grid[off + r][off + c] = col

    # add the new innermost frame to the output only, offset 6
    off4 = 6
    for t in tlist4:
        r, c = perimeter_coords(S3, t)
        output_grid[off4 + r][off4 + c] = c1  # cycle of 3 -> next after c3 is c1

    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable grid
    grid = [list(row) for row in input_grid]
    G = len(grid)

    def perim_length(size):
        return 4 * (size - 1) if size > 1 else 1

    def perimeter_coords(size, t):
        seg = size - 1
        if seg == 0:
            return (0, 0)
        if t < seg:
            return (0, t)
        t -= seg
        if t < seg:
            return (t, size - 1)
        t -= seg
        if t < seg:
            return (size - 1, size - 1 - t)
        t -= seg
        return (size - 1 - t, 0)

    def coords_to_t(size, r, c):
        seg = size - 1
        if seg == 0:
            return 0
        if r == 0:
            return c
        if c == size - 1:
            return seg + r
        if r == size - 1:
            return 2 * seg + (size - 1 - c)
        if c == 0:
            return 3 * seg + (size - 1 - r)
        # not on perimeter
        return None

    def map_path_tlist(path_tlist, size_from, size_to):
        P_from = perim_length(size_from)
        P_to = perim_length(size_to)
        if P_from == 0 or P_to == 0:
            return []
        mapped = []
        for t in path_tlist:
            r, c = perimeter_coords(size_from, t)
            # rotate 90 cw
            r1 = c
            c1 = size_from - 1 - r
            # horizontal reflection
            r2 = r1
            c2 = size_from - 1 - c1
            t2_frac = coords_to_t(size_from, r2, c2) / float(P_from)
            t2 = int(round(t2_frac * P_to)) % P_to
            mapped.append(t2)
        if not mapped:
            return []
        final = [mapped[0]]
        for i in range(1, len(mapped)):
            prev = final[-1]
            curr = mapped[i]
            if curr == prev:
                continue
            diff = (curr - prev) % P_to
            if diff <= P_to - diff:
                step = 1
                steps_needed = diff
            else:
                step = -1
                steps_needed = P_to - diff
            for _ in range(steps_needed):
                prev = (prev + step) % P_to
                final.append(prev)
        # unique preserve order
        seen = set()
        uniq = []
        for t in final:
            if t not in seen:
                seen.add(t)
                uniq.append(t)
        return uniq

    # detect ring depths where there are non-zero perimeter pixels
    depths = []
    for d in range((G + 1) // 2):
        size = G - 2 * d
        if size <= 1:
            continue
        found = False
        # top row
        for c in range(d, G - d):
            if grid[d][c] != 0:
                found = True
                break
        # right col
        if not found:
            for r in range(d + 1, G - d - 1):
                if grid[r][G - d - 1] != 0:
                    found = True
                    break
        # bottom row
        if not found:
            for c in range(d, G - d):
                if grid[G - d - 1][c] != 0:
                    found = True
                    break
        # left col
        if not found:
            for r in range(d + 1, G - d - 1):
                if grid[r][d] != 0:
                    found = True
                    break
        if found:
            depths.append(d)
        if len(depths) >= 3:
            break

    if len(depths) < 3:
        # fallback: try to estimate standard offsets 0,2,4
        depths = [0, 2, 4]

    # build tlists and colors for the 3 detected frames
    frames = []  # each entry (d,size,tlist,color)
    for d in depths[:3]:
        size = G - 2 * d
        P = perim_length(size)
        tvals = []
        colors = []
        # scan perimeter
        # top
        for c in range(d, G - d):
            v = grid[d][c]
            if v != 0:
                t = coords_to_t(size, 0, c - d)
                tvals.append(t)
                colors.append(v)
        # right
        for r in range(d + 1, G - d - 1):
            v = grid[r][G - d - 1]
            if v != 0:
                t = coords_to_t(size, r - d, size - 1)
                tvals.append(t)
                colors.append(v)
        # bottom
        for c in range(d, G - d):
            v = grid[G - d - 1][c]
            if v != 0:
                t = coords_to_t(size, size - 1, c - d)
                tvals.append(t)
                colors.append(v)
        # left
        for r in range(d + 1, G - d - 1):
            v = grid[r][d]
            if v != 0:
                t = coords_to_t(size, r - d, 0)
                tvals.append(t)
                colors.append(v)
        if not tvals:
            frames.append((d, size, [], 0))
            continue
        # compute most common color on the frame
        from collections import Counter
        col = Counter(colors).most_common(1)[0][0]
        # normalize and deduplicate tvals
        tset = sorted(set(tvals))
        # reconstruct order by rotating at the largest gap so the list is contiguous
        P = perim_length(size)
        if not tset:
            ordered = []
        else:
            tsorted = sorted(tset)
            # find largest gap (consider wrap-around)
            max_gap = -1
            max_idx = 0
            for i in range(len(tsorted)):
                a = tsorted[i]
                b = tsorted[(i + 1) % len(tsorted)] if i + 1 < len(tsorted) else tsorted[0] + P
                gap = (b - a) % P
                if gap > max_gap:
                    max_gap = gap
                    max_idx = i
            # start after the largest gap
            start_idx = (max_idx + 1) % len(tsorted)
            ordered = []
            for j in range(len(tsorted)):
                ordered.append(tsorted[(start_idx + j) % len(tsorted)])
        frames.append((d, size, ordered, col))

    # frames[0] outermost, frames[1] middle, frames[2] inner
    d0, S0, t1, c1 = frames[0]
    d1, S1, t2, c2 = frames[1]
    d2, S2, t3, c3 = frames[2]

    # compute the next color in the 3-color cycle: assume cycle length equals the
    # number of distinct frame colors (here 3), so next color after c3 is c1
    next_color = c1

    # compute tlist for new inner frame by applying the transform to t3
    S4 = max(3, S2 - 4)
    t4 = map_path_tlist(t3, S2, S4)

    # construct output grid: copy input grid and add the new inner path at offset d3 = d2 + 2
    out = [list(row) for row in grid]
    d4 = d2 + 2
    for t in t4:
        r, c = perimeter_coords(S4, t)
        out[d4 + r][d4 + c] = next_color

    return out
