# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 237525e2
Difficulty: medium

=== Tags ===
- Create grid
- Draw path through ordered checkpoints
- Trace perimeter

=== Description ===
The input grid contains a sequence of numbered checkpoints (1, 2, 3, ...)
arranged in a non-linear pattern, where each number represents a specific
position to be visited in order. The output grid must draw the perimeter of the
shape formed by connecting these checkpoints sequentially using the shortest
Manhattan paths (only horizontal or vertical movement between consecutive
points), creating a closed loop that returns to the starting checkpoint. All
cells along the connected path are filled with a designated color (e.g., 5),
while all other cells in the output grid are set to 0. The transformation
requires identifying the sequence of checkpoints, determining the minimal grid-
aligned path between each consecutive pair, and rendering the closed perimeter
without additional features or colors.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    r = random.randint(0, 25)
    c = random.randint(0, 25)
    width = random.randint(2, 5)
    height = random.randint(2, 5)
    
    # Adjust c to ensure c + width < 30
    grid_width = c + width + 1
    if grid_width > 30:
        c = 30 - width - 1
    
    # Adjust r to ensure r + height < 30
    grid_height = r + height + 1
    if grid_height > 30:
        r = 30 - height - 1
    
    grid_width = c + width + 1  # Recalculate after adjustment
    grid_height = r + height + 1
    
    input_grid = grid(grid_width, grid_height, 0)
    input_grid[r][c] = 1
    input_grid[r][c + width] = 2
    input_grid[r + height][c + width] = 3
    input_grid[r + height][c] = 4
    
    output_grid = grid(grid_width, grid_height, 0)
    for col in range(c, c + width + 1):
        output_grid[r][col] = 5
    for row in range(r, r + height + 1):
        output_grid[row][c + width] = 5
    for col in range(c, c + width + 1):
        output_grid[r + height][col] = 5
    for row in range(r, r + height + 1):
        output_grid[row][c] = 5
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    positions = {}
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            val = input_grid[r][c]
            if 1 <= val <= 9:
                if val not in positions:
                    positions[val] = (r, c)
    
    if not positions:
        return grid(len(input_grid[0]), len(input_grid), 0)
    
    sorted_vals = sorted(positions.keys())
    n = len(sorted_vals)
    path_cells = set()
    
    for i in range(n):
        a = sorted_vals[i]
        b = sorted_vals[(i + 1) % n]
        r1, c1 = positions[a]
        r2, c2 = positions[b]
        
        if r1 == r2:
            start = min(c1, c2)
            end = max(c1, c2)
            for c in range(start, end + 1):
                path_cells.add((r1, c))
        elif c1 == c2:
            start = min(r1, r2)
            end = max(r1, r2)
            for r in range(start, end + 1):
                path_cells.add((r, c1))
    
    output = grid(len(input_grid[0]), len(input_grid), 0)
    for (r, c) in path_cells:
        if 0 <= r < len(output) and 0 <= c < len(output[0]):
            output[r][c] = 5
    return output
