# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 623fe18c
Difficulty: medium–hard

=== Tags ===
- Pattern expansion
- Path instruction following
- Local state machine

=== Description ===
Input grids feature a background color (0), a token (color 1) positioned on the
left edge facing right, and scattered instruction cells (colors 2-9) each
encoding a direction change rule (e.g., color 2 = 90° clockwise turn, color 3 =
90° counterclockwise turn, color 4 = 180° turn, color 5 = no turn). The token
moves orthogonally one cell per step in its current direction. Upon entering an
instruction cell, it immediately applies the direction rule before moving to the
next cell. The path is drawn in a color that changes to the instruction cell's
color upon entry, preserving all instruction cells and the starting position.
The output grid displays the complete path as a continuous sequence, forming a
non-repeating, expanding pattern across the grid due to the state machine's
directional transitions. The token exits the grid boundaries without overlapping
instruction cells or looping.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = [[0] * width for _ in range(height)]
    
    start_row = random.randint(1, height-4)
    grid[start_row][0] = 1
    
    k = random.randint(2, width-3)
    grid[start_row][k] = 2
    
    m = random.randint(2, height - start_row - 2)
    grid[start_row + m][k] = 3
    
    output = [row[:] for row in grid]
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    current_dir = 0
    path_color = 1
    
    for c in range(1, k):
        output[start_row][c] = path_color
    path_color = 2
    for r in range(start_row + 1, start_row + m):
        output[r][k] = path_color
    path_color = 3
    for c in range(k + 1, width):
        output[start_row + m][c] = path_color
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    start_row = None
    for r in range(height):
        if grid[r][0] == 1:
            start_row = r
            break
    if start_row is None:
        return grid
    
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    current_dir = 0
    path_color = 1
    
    r, c = start_row, 0
    while True:
        dr, dc = directions[current_dir]
        nr, nc = r + dr, c + dc
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        cell_color = grid[nr][nc]
        if cell_color > 1:
            path_color = cell_color
            if cell_color == 2:
                current_dir = (current_dir + 1) % 4
            elif cell_color == 3:
                current_dir = (current_dir - 1) % 4
            elif cell_color == 4:
                current_dir = (current_dir + 2) % 4
        else:
            grid[nr][nc] = path_color
        r, c = nr, nc
    
    return grid
