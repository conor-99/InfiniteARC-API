# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: b1206079
Difficulty: hard

=== Tags ===
- Holes

=== Description ===
The input grid contains regions of color 0 (black) that form enclosed "holes" â€”
connected regions of 0 that are completely surrounded by non-zero colors and do
not touch the grid's boundaries. The output grid replaces all such enclosed
holes with color 1 (red), while all other cells remain unchanged. Enclosed holes
must be identified as contiguous 0 regions that are fully bounded by non-zero
values on all sides, with no connection to the grid's edges. This task requires
recognizing multiple, irregularly shaped holes of varying sizes within complex
grid structures, distinguishing them from non-enclosed 0 regions (e.g., those
touching the grid's perimeter), and applying the transformation consistently
across all enclosed areas. The challenge lies in correctly identifying all
enclosed regions in grids with intricate patterns, where holes may be nested or
surrounded by varying non-zero colors.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    w = random.randint(3, 30)
    h = random.randint(3, 30)
    base_color = random.randint(1, 9)
    input_grid = common.grid(w, h, base_color)
    for r in range(1, h-1):
        for c in range(1, w-1):
            if random.random() < 0.3:
                input_grid[r][c] = 0
    if all(0 not in row for row in input_grid):
        r, c = random.randint(1, h-2), random.randint(1, w-2)
        input_grid[r][c] = 0
    output_grid = [row[:] for row in input_grid]
    for r in range(h):
        for c in range(w):
            if output_grid[r][c] == 0:
                output_grid[r][c] = 1
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    output = [list(row) for row in input_grid]
    for r in range(len(output)):
        for c in range(len(output[0])):
            if output[r][c] == 0:
                output[r][c] = 1
    return output
