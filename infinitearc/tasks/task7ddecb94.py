# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 7ddecb94
Difficulty: mediumâ€“hard

=== Tags ===
- Guided flow
- Multi condition recolor
- Detect vertical symmetry

=== Description ===
Input grids feature a continuous flow path (represented by a single color)
starting at the top edge and traversing the grid through orthogonally connected
cells, surrounded by background (color 0) and other distinct colored elements
(colors 2-9). The grid may contain partial vertical symmetry. The task requires
detecting the vertical symmetry axis (center column(s) based on grid width) and
applying multi-condition recoloring to each cell in the flow path: cells left of
the axis recolor to color 2 if their mirror cell (right of axis) is part of the
flow path, otherwise to color 3; cells right of the axis follow the same rule
relative to their left mirror; cells directly on the symmetry axis recolor to
color 4. All non-flow path cells (background, obstacles, and other elements)
remain unchanged. The output grid displays the transformed flow path while
preserving all background elements and maintaining the original structure of the
grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    w = random.choice(range(3, 30, 2))
    h = random.randint(3, 30)
    grid = [[0] * w for _ in range(h)]
    s = random.randint(0, w-1)
    path = []
    for i in range(0, 3):
        if i < h:
            path.append((i, s))
    if s + 1 < w and 3 < h:
        path.append((3, s+1))
    for i in range(4, 6):
        if i < h:
            path.append((i, s+1))
    for r, c in path:
        if 0 <= r < h and 0 <= c < w:
            grid[r][c] = 1
    for r in range(h):
        for c in range(w):
            if grid[r][c] == 0 and random.random() < 0.1:
                grid[r][c] = random.randint(2, 9)
    output = [row[:] for row in grid]
    mid = (w - 1) // 2
    for r in range(h):
        for c in range(w):
            if grid[r][c] == 1:
                if c < mid:
                    mirror_c = w - 1 - c
                    if output[r][mirror_c] == 1:
                        output[r][c] = 2
                    else:
                        output[r][c] = 3
                elif c > mid:
                    mirror_c = w - 1 - c
                    if output[r][mirror_c] == 1:
                        output[r][c] = 2
                    else:
                        output[r][c] = 3
                else:
                    output[r][c] = 4
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    h = len(input_grid)
    w = len(input_grid[0])
    mid = (w - 1) // 2
    output = [row[:] for row in input_grid]
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] == 1:
                if c < mid:
                    mirror_c = w - 1 - c
                    if input_grid[r][mirror_c] == 1:
                        output[r][c] = 2
                    else:
                        output[r][c] = 3
                elif c > mid:
                    mirror_c = w - 1 - c
                    if input_grid[r][mirror_c] == 1:
                        output[r][c] = 2
                    else:
                        output[r][c] = 3
                else:
                    output[r][c] = 4
    return output
