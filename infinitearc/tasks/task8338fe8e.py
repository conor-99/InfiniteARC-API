# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 8338fe8e
Difficulty: hard

=== Tags ===
- Multi condition recolor
- Portal momentum pathing
- Mirror twins
- Snap objects to gridlines
- Move object to first unoccupied space

=== Description ===
Input grids are 20x20 or larger, featuring a single background color (0) and
multiple distinct elements: a token (color 1) starting on the left edge facing
right, and mirrored portal pairs (each pair sharing a unique color, e.g., 2, 3,
4) placed as single cells. Each portal has a geometric mirror twin positioned at
(height - r - 1, width - c - 1) for a portal at (r, c), creating symmetric
portal networks. The grid contains no overlapping portals, and all paths between
portals traverse only background cells.  In the output grid, the token's path
replaces the background with a sequence of colors determined by portal
interactions: the initial path uses color 1 until the first portal entry. Upon
entering a portal (color P), the path color instantly shifts to P, the token
teleports to the mirror twin portal, and its direction rotates 90° clockwise
(right → up → left → down → right). This sequence repeats at each portal, with
the path color updating to the portal's color at every entry. The path is drawn
exclusively on background cells, never overlapping portals, the token's starting
position, or other elements. The token exits the grid after a finite number of
steps, with the path fully rendered and all portals unchanged. The mirror twins
create symmetric path patterns, and the multi-condition recolor rule ensures
color transitions occur strictly at portal entries without additional visual
cues.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width, height = 25, 25
    grid = [[0] * width for _ in range(height)]
    start_row = random.randint(1, height-2)
    grid[start_row][0] = 1
    
    colors = random.sample(range(2, 10), 2)
    
    c = random.randint(1, width-2)
    r = start_row
    twin_r, twin_c = height-1 - r, width-1 - c
    grid[r][c] = colors[0]
    grid[twin_r][twin_c] = colors[0]
    
    r2 = random.randint(0, height-1)
    c2 = random.randint(1, width-2)
    twin_r2, twin_c2 = height-1 - r2, width-1 - c2
    grid[r2][c2] = colors[1]
    grid[twin_r2][twin_c2] = colors[1]
    
    output_grid = [row[:] for row in grid]
    current_pos = (start_row, 0)
    current_color = 1
    direction = (0, 1)
    
    while True:
        nr, nc = current_pos[0] + direction[0], current_pos[1] + direction[1]
        if not (0 <= nr < height and 0 <= nc < width):
            break
        if grid[nr][nc] != 0:
            current_color = grid[nr][nc]
            twin_nr = height - 1 - nr
            twin_nc = width - 1 - nc
            current_pos = (twin_nr, twin_nc)
            if direction == (0, 1):
                direction = (-1, 0)
            elif direction == (-1, 0):
                direction = (0, -1)
            elif direction == (0, -1):
                direction = (1, 0)
            else:
                direction = (0, 1)
        else:
            output_grid[nr][nc] = current_color
            current_pos = (nr, nc)
    
    return {"input": grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = [list(row) for row in input_grid]
    
    start_row = None
    for r in range(height):
        if input_grid[r][0] == 1:
            start_row = r
            break
    if start_row is None:
        start_row = 0
    
    current_pos = (start_row, 0)
    current_color = 1
    direction = (0, 1)
    
    while True:
        nr = current_pos[0] + direction[0]
        nc = current_pos[1] + direction[1]
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        if input_grid[nr][nc] != 0:
            current_color = input_grid[nr][nc]
            twin_nr = height - 1 - nr
            twin_nc = width - 1 - nc
            current_pos = (twin_nr, twin_nc)
            if direction == (0, 1):
                direction = (-1, 0)
            elif direction == (-1, 0):
                direction = (0, -1)
            elif direction == (0, -1):
                direction = (1, 0)
            else:
                direction = (0, 1)
        else:
            output_grid[nr][nc] = current_color
            current_pos = (nr, nc)
    
    return output_grid
