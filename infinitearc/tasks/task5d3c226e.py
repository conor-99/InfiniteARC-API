# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 5d3c226e
Difficulty: hard

=== Tags ===
- Pattern analogy
- Pathfinding with state
- Emergent behavior
- Fill smallest enclosed hole
- Fill holes

=== Description ===
Input grids consist of a 2D grid where most cells are background (0) or walls
(non-zero colors). Enclosed holes are maximal connected regions of background
cells completely surrounded by walls (non-zero colors) and not connected to the
grid's boundary. The smallest hole (by area) is identified through connected
component analysis. To determine the fill color, the top-left cell of the
smallest hole's bounding box (the topmost and leftmost background cell within
the hole) is used as the reference point. The four adjacent directions (north,
west, south, east) are checked in clockwise order around this reference cell.
The first non-zero wall cell encountered in this sequence determines the fill
color. All background cells within the smallest hole are then replaced with this
fill color, while walls and other background regions remain unchanged. This
process requires identifying enclosed regions, comparing areas, and following a
deterministic directional scan to establish the fill color, embodying
pathfinding with state through the fixed clockwise direction sequence and
emergent behavior from the grid's structural properties.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(4, 30)
    height = random.randint(4, 30)
    grid = [[1] * width for _ in range(height)]
    
    hole_height = 2
    hole_width = 2
    r1 = random.randint(1, height - hole_height - 1)
    c1 = random.randint(1, width - hole_width - 1)
    
    for r in range(r1, r1 + hole_height):
        for c in range(c1, c1 + hole_width):
            grid[r][c] = 0
    
    fill_color = random.randint(2, 9)
    grid[r1-1][c1] = fill_color
    
    output = [row[:] for row in grid]
    for r in range(r1, r1 + hole_height):
        for c in range(c1, c1 + hole_width):
            output[r][c] = fill_color
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    background = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                background.append((r, c))
    
    if not background:
        return input_grid
    
    edge_background = set()
    queue = []
    
    # Check top and bottom rows
    for c in range(width):
        if input_grid[0][c] == 0:
            edge_background.add((0, c))
            queue.append((0, c))
        if input_grid[height-1][c] == 0:
            edge_background.add((height-1, c))
            queue.append((height-1, c))
    
    # Check left and right columns
    for r in range(1, height-1):
        if input_grid[r][0] == 0:
            edge_background.add((r, 0))
            queue.append((r, 0))
        if input_grid[r][width-1] == 0:
            edge_background.add((r, width-1))
            queue.append((r, width-1))
    
    # BFS to mark all connected to edge
    while queue:
        r, c = queue.pop(0)
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in edge_background and input_grid[nr][nc] == 0:
                edge_background.add((nr, nc))
                queue.append((nr, nc))
    
    # Find enclosed holes
    visited = set()
    enclosed_holes = []
    for cell in background:
        if cell in edge_background or cell in visited:
            continue
        hole = []
        queue = [cell]
        visited.add(cell)
        while queue:
            r, c = queue.pop(0)
            hole.append((r, c))
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in visited and input_grid[nr][nc] == 0:
                    visited.add((nr, nc))
                    queue.append((nr, nc))
        enclosed_holes.append(hole)
    
    if not enclosed_holes:
        return input_grid
    
    smallest_hole = min(enclosed_holes, key=len)
    min_r = min(r for r, c in smallest_hole)
    min_c = min(c for r, c in smallest_hole)
    
    directions = [(-1, 0), (0, -1), (1, 0), (0, 1)]  # north, west, south, east
    fill_color = None
    for dr, dc in directions:
        nr, nc = min_r + dr, min_c + dc
        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0:
            fill_color = input_grid[nr][nc]
            break
    
    if fill_color is None:
        fill_color = 1  # Fallback
    
    output = [list(row) for row in input_grid]  # Fixed: use list(row) instead of row[:]
    for r, c in smallest_hole:
        output[r][c] = fill_color
    
    return output
