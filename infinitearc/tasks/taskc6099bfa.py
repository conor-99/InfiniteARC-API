# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: c6099bfa
Difficulty: insane

=== Tags ===
- Detect enclosure
- Adaptive behavior switch
- Color by distance to edge
- Repeat pattern to fill shape

=== Description ===
Input grids feature a single, continuous, non-intersecting loop boundary formed
by a consistent color (e.g., color 3), enclosing a region of arbitrary shape.
The loop must be a closed curve with no gaps or branches, and all cells strictly
inside the boundary define the enclosed region. Background cells outside the
boundary are color 0.   The output grid transforms the enclosed region through
the following sequence of operations:  1. **Detect Enclosure**: Identify the
enclosed region by traversing inward from a cell adjacent to the boundary (e.g.,
a cell diagonally inside the loop). The boundary must form a simple closed loop
with no self-intersections.  2. **Adaptive Behavior Switch**: Calculate the
enclosed region's area (number of cells inside the boundary). If the area
exceeds 25% of the grid's total cells, trigger a 3-color repeating pattern;
otherwise, use a 2-color repeating pattern.  3. **Color by Distance to Edge**:
For each cell within the enclosed region, compute its Manhattan distance to the
nearest grid edge (top, bottom, left, right). The distance is the minimum of
(row index, grid height - row index - 1, column index, grid width - column index
- 1).  4. **Repeat Pattern to Fill Shape**: Assign a color to each cell based on
the distance modulo the adaptive pattern size (3 for large areas, 2 for small
areas), then add 1. For example:    - Large regions: color = (distance % 3) + 1
- Small regions: color = (distance % 2) + 1  All boundary loop cells retain
their original color (3), and cells outside the enclosed region remain
background (0). The transformation creates a visually distinct repeating color
pattern within the enclosed region, where the pattern period and color sequence
adapt dynamically to the region's size. This requires recognizing the boundary
loop structure, quantifying its area, and applying a conditional distance-based
color mapping that generates complex, non-uniform visual patterns.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Create a random grid and draw a single-pixel-thick rectangular loop (color 3)
    # that encloses a non-empty interior. Then color the interior according to
    # Manhattan distance to the nearest grid edge with an adaptive repeating pattern.
    for _ in range(1000):
        W = random.randint(10, 30)
        H = random.randint(10, 30)

        # Ensure there's room for a rectangle with at least a 1-cell margin on each side
        max_rect_w = W - 2
        max_rect_h = H - 2
        if max_rect_w < 3 or max_rect_h < 3:
            continue

        rect_w = random.randint(3, max_rect_w)
        rect_h = random.randint(3, max_rect_h)

        # place the rectangle so there's at least one cell margin to the outer border
        left = random.randint(1, W - rect_w - 1)
        top = random.randint(1, H - rect_h - 1)

        # build input grid with background 0
        input_grid = [[0 for _ in range(W)] for _ in range(H)]

        # draw 1-pixel-thick rectangular loop with color 3
        for c in range(left, left + rect_w):
            input_grid[top][c] = 3
            input_grid[top + rect_h - 1][c] = 3
        for r in range(top, top + rect_h):
            input_grid[r][left] = 3
            input_grid[r][left + rect_w - 1] = 3

        # collect strictly interior cells (those strictly inside the loop)
        inside_cells = [(r, c)
                        for r in range(top + 1, top + rect_h - 1)
                        for c in range(left + 1, left + rect_w - 1)]

        # require non-empty interior
        if not inside_cells:
            continue

        total = W * H
        area = len(inside_cells)
        pattern_size = 3 if area > 0.25 * total else 2

        # produce output by coloring interior cells by distance-to-edge modulo pattern size
        output_grid = [row[:] for row in input_grid]
        for (r, c) in inside_cells:
            dist = min(r, H - 1 - r, c, W - 1 - c)
            output_grid[r][c] = (dist % pattern_size) + 1

        return {"input": input_grid, "output": output_grid}

    raise RuntimeError("Could not generate a valid grid after many attempts")



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    H = len(grid)
    if H == 0:
        return grid
    W = len(grid[0])

    # Flood fill zeros reachable from the outer edges to identify the outside background
    outside = set()
    stack = []
    for r in range(H):
        for c in range(W):
            if (r == 0 or r == H - 1 or c == 0 or c == W - 1) and grid[r][c] == 0:
                outside.add((r, c))
                stack.append((r, c))
    while stack:
        r, c = stack.pop()
        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
            nr, nc = r + dr, c + dc
            if 0 <= nr < H and 0 <= nc < W and grid[nr][nc] == 0 and (nr, nc) not in outside:
                outside.add((nr, nc))
                stack.append((nr, nc))

    # Any zero cell not reachable from the edges is strictly inside the loop
    inside = [(r, c) for r in range(H) for c in range(W) if grid[r][c] == 0 and (r, c) not in outside]

    if not inside:
        return grid

    total = W * H
    area = len(inside)
    pattern_size = 3 if area > 0.25 * total else 2

    for (r, c) in inside:
        dist = min(r, H - 1 - r, c, W - 1 - c)
        grid[r][c] = (dist % pattern_size) + 1

    return grid

