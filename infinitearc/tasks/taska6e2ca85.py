# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: a6e2ca85
Difficulty: medium

=== Tags ===
- Rectangle guessing
- Mimic pattern
- Reorder blocks by size

=== Description ===
The input grid contains multiple non-overlapping axis-aligned rectangular
regions, each filled with a single non-zero color (background is 0). Each
rectangle is defined as a maximal contiguous block of a single color forming a
perfect rectangle (no gaps or irregular shapes). The task requires identifying
each rectangle, computing its area (width Ã— height), sorting the rectangles by
area in ascending order, and arranging them horizontally in the output grid from
left to right. The output grid is constructed by placing each rectangle
immediately to the right of the previous one, maintaining top alignment. The
grid's width is the sum of all rectangles' widths, and its height is the maximum
height among all rectangles. Any empty spaces within the output grid's
dimensions remain as background color (0). The transformation is purely visual,
relying on rectangle dimensions and spatial arrangement without numerical
operations or color value dependencies.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid
def generate():
    width = random.randint(5, 15)
    height = random.randint(5, 15)
    input_grid = grid(width, height, 0)
    num_rects = random.randint(2, 4)
    colors = random.sample(range(1, 10), num_rects)
    rectangles = []

    for color in colors:
        while True:
            w = random.randint(1, width - 1)
            h = random.randint(1, height - 1)
            top = random.randint(0, height - h)
            left = random.randint(0, width - w)
            overlap = False
            for (c, t, l, w0, h0) in rectangles:
                if top < t + h0 and top + h > t and left < l + w0 and left + w > l:
                    overlap = True
                    break
            if not overlap:
                break
        rectangles.append((color, top, left, w, h))
        for r in range(top, top + h):
            for c in range(left, left + w):
                input_grid[r][c] = color

    rect_info = []
    for color, top, left, w, h in rectangles:
        area = w * h
        rect_info.append((area, color, w, h, top, left))
    rect_info.sort(key=lambda x: (x[0], x[4], x[5]))
    
    max_h = max(h for _, _, _, h, _, _ in rect_info)
    total_w = sum(w for _, _, w, _, _, _ in rect_info)
    if total_w > 30:
        return generate()
    
    output_grid = grid(total_w, max_h, 0)
    
    x = 0
    for area, color, w, h, top, left in rect_info:
        for r in range(h):
            for c in range(w):
                output_grid[r][x + c] = color
        x += w

    if input_grid == output_grid:
        return generate()
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random
from common import grid
def p(input_grid):
    if not input_grid:
        return []
    rows = len(input_grid)
    cols = len(input_grid[0])
    visited = [[False] * cols for _ in range(rows)]
    components = []
    
    for r in range(rows):
        for c in range(cols):
            if input_grid[r][c] != 0 and not visited[r][c]:
                color = input_grid[r][c]
                pixels = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    pixels.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append((color, pixels))
    
    rect_info = []
    for color, pixels in components:
        if not pixels:
            continue
        min_r = min(p[0] for p in pixels)
        max_r = max(p[0] for p in pixels)
        min_c = min(p[1] for p in pixels)
        max_c = max(p[1] for p in pixels)
        w = max_c - min_c + 1
        h = max_r - min_r + 1
        area = w * h
        rect_info.append((area, color, w, h, min_r, min_c))
    
    rect_info.sort(key=lambda x: (x[0], x[4], x[5]))
    
    max_h = max(h for _, _, _, h, _, _ in rect_info) if rect_info else 0
    total_w = sum(w for _, _, w, _, _, _ in rect_info)
    if total_w > 30:
        total_w = 30
    output_grid = [[0] * total_w for _ in range(max_h)]
    
    x = 0
    for area, color, w, h, min_r, min_c in rect_info:
        for r in range(h):
            for c in range(w):
                output_grid[r][x + c] = color
        x += w
    
    return output_grid
