# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: c6741e70
Difficulty: hard

=== Tags ===
- Multi stage color switch
- Synchronized bounce
- Infer hidden grid
- Symmetry completion
- Pattern expansion
- Color the row with most dots

=== Description ===
Input grids are 15×15 to 30×30, with background color 0. The grid contains
scattered colored dots (1–9) arranged asymmetrically, forming a left-half
pattern with no right-side counterpart. The transformation requires multiple
sequential steps:    1. **Infer Hidden Grid (Symmetry Completion)**: The right
half of the grid must mirror the left half vertically across the central axis.
For each dot at (r, c) in the left half (c < mid), the corresponding right half
dot is placed at (r, 2*mid - c - 1).    2. **Multi-stage Color Switch**: Each
mirrored dot’s color cycles through a fixed sequence (1→2→3→4→5→6→7→8→9→1) for a
number of stages equal to its row index (0-based). For example, a dot in row 4
cycles 4 times (e.g., color 7 → 8 → 9 → 1 → 2).    3. **Pattern Expansion**:
After symmetry completion, identify the row with the highest density of non-
background cells (dots). If multiple rows tie, select the topmost. This row is
then fully filled with a color derived from its dot colors.    4. **Color the
Row with Most Dots**: The dominant color in the densest row (ignoring
background) determines the fill color. In case of ties, select the numerically
highest color (e.g., 9 > 8 > ... > 1).    5. **Synchronized Bounce**: For each
original left-half dot, draw a diagonal line from its position to the top-right
grid corner, bouncing off the top and right edges exactly once. The line uses
the original dot’s color and avoids overlapping with the densest row or other
lines. Bounce paths are drawn consistently across all dots, creating a
synchronized visual effect.    The output grid combines all transformations:
symmetric completion with color-switched dots, the densest row filled with its
dominant color, and synchronized bounce paths drawn over background cells only.
No original dots, walls, or obstacles are altered beyond the described rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = random.randint(15, 30)
    height = width
    mid = width // 2

    input_grid = common.grid(width, height, 0)
    left_dots = []

    for r in range(height):
        for c in range(mid):
            if random.random() > 0.5:
                color = random.randint(1, 9)
                input_grid[r][c] = color
                left_dots.append((r, c, color))

    output_grid = [row[:] for row in input_grid]

    for r, c, color in left_dots:
        right_c = width - 1 - c
        if right_c >= mid:
            output_grid[r][right_c] = color

    for r in range(height):
        for c in range(width):
            if output_grid[r][c] != 0:
                new_color = (output_grid[r][c] + r - 1) % 9 + 1
                output_grid[r][c] = new_color

    row_counts = [sum(1 for cell in row if cell != 0) for row in output_grid]
    max_count = max(row_counts)
    densest_rows = [i for i, count in enumerate(row_counts) if count == max_count]
    densest_row = min(densest_rows)

    colors_in_row = [cell for cell in output_grid[densest_row] if cell != 0]
    if colors_in_row:
        color_count = {}
        for color in colors_in_row:
            color_count[color] = color_count.get(color, 0) + 1
        sorted_colors = sorted(color_count.items(), key=lambda x: (-x[1], -x[0]))
        dominant_color = sorted_colors[0][0]
    else:
        dominant_color = 1

    for c in range(width):
        output_grid[densest_row][c] = dominant_color

    for r, c, orig_color in left_dots:
        current_r, current_c = r, c
        path_points = []
        while current_r > 0 and current_c < width - 1:
            path_points.append((current_r, current_c))
            current_r -= 1
            current_c += 1
        path_points.append((0, current_c))
        while current_c < width - 1:
            current_r += 1
            current_c += 1
            path_points.append((current_r, current_c))
        while current_r > 0:
            current_r -= 1
            current_c -= 1
            path_points.append((current_r, current_c))
        for (i, j) in path_points:
            if output_grid[i][j] == 0:
                output_grid[i][j] = orig_color

    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    mid = width // 2

    output_grid = [row[:] for row in input_grid]
    left_dots = []

    for r in range(height):
        for c in range(mid):
            if input_grid[r][c] != 0:
                left_dots.append((r, c, input_grid[r][c]))

    for r, c, color in left_dots:
        right_c = width - 1 - c
        if right_c >= mid:
            output_grid[r][right_c] = color

    for r in range(height):
        for c in range(width):
            if output_grid[r][c] != 0:
                new_color = (output_grid[r][c] + r - 1) % 9 + 1
                output_grid[r][c] = new_color

    row_counts = [sum(1 for cell in row if cell != 0) for row in output_grid]
    max_count = max(row_counts)
    densest_rows = [i for i, count in enumerate(row_counts) if count == max_count]
    densest_row = min(densest_rows)

    colors_in_row = [cell for cell in output_grid[densest_row] if cell != 0]
    if colors_in_row:
        color_count = {}
        for color in colors_in_row:
            color_count[color] = color_count.get(color, 0) + 1
        sorted_colors = sorted(color_count.items(), key=lambda x: (-x[1], -x[0]))
        dominant_color = sorted_colors[0][0]
    else:
        dominant_color = 1

    for c in range(width):
        output_grid[densest_row][c] = dominant_color

    for r, c, orig_color in left_dots:
        current_r, current_c = r, c
        path_points = []
        while current_r > 0 and current_c < width - 1:
            path_points.append((current_r, current_c))
            current_r -= 1
            current_c += 1
        path_points.append((0, current_c))
        while current_c < width - 1:
            current_r += 1
            current_c += 1
            path_points.append((current_r, current_c))
        while current_r > 0:
            current_r -= 1
            current_c -= 1
            path_points.append((current_r, current_c))
        for (i, j) in path_points:
            if output_grid[i][j] == 0:
                output_grid[i][j] = orig_color

    return output_grid
