# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: a5acf9f4
Difficulty: mediumâ€“hard

=== Tags ===
- Sequential path painting
- Pattern cycle
- Signal to structure
- Shape morphing

=== Description ===
Task Name: Path Cycle Morphing  Input grids feature a background color (0), a
starting cell (color S), and a sequence of directional signal cells (distinct
colors D1, D2, ..., Dn) placed along a path that begins at S and extends in a
fixed initial direction (e.g., east). The signals are positioned such that the
path will encounter them in sequence. Each signal color corresponds to a fixed
direction change rule (e.g., red = turn left, blue = turn right, green =
continue straight), while the path itself is painted using a repeating color
cycle (C1, C2, C3, ...) for each background cell traversed. The output grid
displays the path as a continuous painted sequence following the direction
changes dictated by the signals, with the original signals and starting cell
remaining visible. The path continues until the next cell would be non-
background, overlap with an existing non-background cell, or exit the grid. The
painted segments replace only background cells (0), preserving all signals and
starting points in their original colors. The overall path shape evolves through
the sequence of direction changes, forming a morphing structure that cycles
through the pattern dictated by the signal sequence.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # choose grid size
    width = random.randint(6, 20)
    height = random.randint(6, 20)
    grid = [[0 for _ in range(width)] for _ in range(height)]
    cycle = [4,5,6]
    signal_colors = [1,2,3]  # 1=left,2=right,3=straight
    start_color_choices = [7,8,9]
    S = random.choice(start_color_choices)
    # Try to build a non-self-intersecting path with signals
    deltas = [(0,1),(1,0),(0,-1),(-1,0)]  # east,south,west,north
    max_attempts = 200
    for attempt in range(max_attempts):
        # pick starting direction and starting cell with at least some space
        dir_idx = random.randint(0,3)
        # pick start anywhere but ensure there is at least one free cell in that direction
        tries = 0
        found = False
        while tries < 200:
            start_r = random.randint(0, height-1)
            start_c = random.randint(0, width-1)
            # ensure start is not on border so turns are possible, but allow near borders sometimes
            dr, dc = deltas[dir_idx]
            nr = start_r + dr
            nc = start_c + dc
            if 0 <= nr < height and 0 <= nc < width:
                found = True
                break
            tries += 1
        if not found:
            continue
        # initialize path state
        visited = set()
        paint_positions = []
        signal_positions = []
        r, c = start_r, start_c
        visited.add((r,c))
        current_dir = dir_idx
        # choose number of signals
        num_signals = random.randint(1, 4)
        success = True
        for _ in range(num_signals):
            # compute how many free cells are ahead before boundary or visited
            tr, tc = r, c
            available = 0
            dr, dc = deltas[current_dir]
            while True:
                tr += dr; tc += dc
                if not (0 <= tr < height and 0 <= tc < width):
                    break
                if (tr, tc) in visited:
                    break
                available += 1
            if available <= 0:
                success = False
                break
            # place the signal at some distance 1..available ahead
            dist = random.randint(1, available)
            # paint dist-1 intermediate background cells
            for _step in range(dist - 1):
                r += dr; c += dc
                paint_positions.append((r,c))
                visited.add((r,c))
            # place signal at next cell
            r += dr; c += dc
            sig_color = random.choice(signal_colors)
            signal_positions.append(((r,c), sig_color))
            visited.add((r,c))
            # update direction according to signal mapping
            if sig_color == 1:  # left
                current_dir = (current_dir - 1) % 4
            elif sig_color == 2:  # right
                current_dir = (current_dir + 1) % 4
            else:  # straight (3)
                current_dir = current_dir
        if not success:
            continue
        # after placing signals, advance until blocked
        dr, dc = deltas[current_dir]
        while True:
            nr = r + dr; nc = c + dc
            if not (0 <= nr < height and 0 <= nc < width):
                break
            if (nr, nc) in visited:
                break
            r, c = nr, nc
            paint_positions.append((r,c))
            visited.add((r,c))
        # ensure we painted at least one cell (so input != output)
        if len(paint_positions) == 0:
            continue
        # Build input grid
        grid = [[0 for _ in range(width)] for _ in range(height)]
        grid[start_r][start_c] = S
        for (pos, col) in signal_positions:
            rr, cc = pos
            grid[rr][cc] = col
        # Build output grid by painting the paint_positions with cycle colors
        output = [row[:] for row in grid]
        for idx, (rr, cc) in enumerate(paint_positions):
            output[rr][cc] = cycle[idx % len(cycle)]
        return {"input": grid, "output": output}
    # fallback simple example if all attempts fail
    # create a short east path
    width = max(width, 6); height = max(height,6)
    grid = [[0 for _ in range(width)] for _ in range(height)]
    start_r = height // 2; start_c = 1
    grid[start_r][start_c] = S
    paint_positions = []
    for i in range(1,4):
        grid[start_r][start_c + i] = 0
        paint_positions.append((start_r, start_c + i))
    output = [row[:] for row in grid]
    for idx, (rr,cc) in enumerate(paint_positions):
        output[rr][cc] = cycle[idx % len(cycle)]
    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid); width = len(grid[0])
    signal_set = {1,2,3}
    cycle = [4,5,6]
    # find start color (unique non-signal color)
    counts = {}
    signal_positions = set()
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if v == 0: continue
            counts[v] = counts.get(v, 0) + 1
            if v in signal_set:
                signal_positions.add((r,c))
    start_color = None
    for col, cnt in counts.items():
        if col not in signal_set and cnt == 1:
            start_color = col
            break
    if start_color is None:
        for col in counts:
            if col not in signal_set:
                start_color = col
                break
    start_r = start_c = None
    if start_color is not None:
        for r in range(height):
            for c in range(width):
                if grid[r][c] == start_color:
                    start_r, start_c = r, c
                    break
            if start_r is not None:
                break
    if start_r is None:
        return tuple(tuple(row) for row in grid)
    deltas = [(0,1),(1,0),(0,-1),(-1,0)]
    # try all four initial directions and pick the one that visits exactly all signals
    best_paint = None
    best_found = False
    for d_idx in range(4):
        current_dir = d_idx
        r, c = start_r, start_c
        visited = set([(r,c)])
        paint_positions = []
        encountered_signals = []
        while True:
            dr, dc = deltas[current_dir]
            nr, nc = r + dr, c + dc
            if not (0 <= nr < height and 0 <= nc < width):
                break
            if (nr, nc) in visited:
                break
            val = grid[nr][nc]
            if val == 0:
                paint_positions.append((nr, nc))
                visited.add((nr, nc))
                r, c = nr, nc
                continue
            if val in signal_set:
                encountered_signals.append((nr, nc))
                visited.add((nr, nc))
                r, c = nr, nc
                if val == 1:
                    current_dir = (current_dir - 1) % 4
                elif val == 2:
                    current_dir = (current_dir + 1) % 4
                else:
                    current_dir = current_dir
                continue
            # other non-zero (e.g., start) -> stop
            break
        if set(encountered_signals) == signal_positions and len(encountered_signals) == len(signal_positions) and len(paint_positions) > 0:
            best_paint = paint_positions
            best_found = True
            break
    # fallback: if none matched, try heuristic scanning for nearest signal ray
    if not best_found:
        best_dir = None
        best_dist = None
        for d_idx, (dr,dc) in enumerate(deltas):
            tr, tc = start_r, start_c
            dist = 0
            while True:
                tr += dr; tc += dc; dist += 1
                if tr < 0 or tr >= height or tc < 0 or tc >= width:
                    break
                if grid[tr][tc] != 0:
                    if grid[tr][tc] in signal_set:
                        if best_dist is None or dist < best_dist:
                            best_dist = dist
                            best_dir = d_idx
                    break
        if best_dir is None:
            for d_idx, (dr,dc) in enumerate(deltas):
                nr, nc = start_r + dr, start_c + dc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0:
                    best_dir = d_idx
                    break
        if best_dir is None:
            return tuple(tuple(row) for row in grid)
        # simulate with best_dir
        current_dir = best_dir
        r, c = start_r, start_c
        visited = set([(r,c)])
        paint_positions = []
        while True:
            dr, dc = deltas[current_dir]
            nr, nc = r + dr, c + dc
            if not (0 <= nr < height and 0 <= nc < width):
                break
            if (nr, nc) in visited:
                break
            val = grid[nr][nc]
            if val == 0:
                paint_positions.append((nr, nc))
                visited.add((nr, nc))
                r, c = nr, nc
                continue
            if val in signal_set:
                visited.add((nr, nc))
                r, c = nr, nc
                if val == 1:
                    current_dir = (current_dir - 1) % 4
                elif val == 2:
                    current_dir = (current_dir + 1) % 4
                else:
                    current_dir = current_dir
                continue
            break
        best_paint = paint_positions
    # build output
    output = [row[:] for row in grid]
    if best_paint:
        for idx, (rr, cc) in enumerate(best_paint):
            output[rr][cc] = cycle[idx % len(cycle)]
    return tuple(tuple(row) for row in output)

