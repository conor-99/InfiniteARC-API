# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 61addab9
Difficulty: insane

=== Tags ===
- Hierarchical logic composition
- Color modulated logic
- Cut and unfold
- Pattern intersection

=== Description ===
# Hierarchical Cut & Unfold  Input grids are 20×20 grids containing multiple
nested rectangles. Each rectangle is defined by a contiguous border of a single
color (1–9), with the interior filled with a distinct color (not the border
color). The rectangles are arranged hierarchically, with each rectangle
containing the next smaller rectangle within its border. The border color of
each rectangle encodes a cut direction and position:  - Colors 1–3: Horizontal
cuts (1 = top, 2 = middle, 3 = bottom) - Colors 4–6: Vertical cuts (4 = left, 5
= middle, 6 = right) - Colors 7–9: Diagonal cuts (7 = top-left to bottom-right,
8 = top-right to bottom-left, 9 = other diagonal)  The cut position is
determined by the rectangle's boundaries and the color index (e.g., color 2 for
horizontal cuts applies at the midpoint of the border's height).   The output
grid is generated by sequentially applying each rectangle's cut from the
outermost to the innermost. For each cut:  1. The grid is split along the cut
line. 2. The section beyond the cut line is reflected over the cut line (e.g., a
horizontal cut at the middle reflects the top half over to the bottom). 3. The
reflected section's colors are modulated by the border color (e.g., red borders
shift colors by +1, blue by -2).  Pattern intersections occur where multiple
rectangles overlap. At intersections, the color modulation combines the border
colors' effects (e.g., red + blue = purple, using a predefined color mapping
table).  The output grid must maintain the original background color in non-
reflected areas, and all reflections must be applied without overlapping or
distorting the grid. The final grid contains all original border colors but with
the hierarchical structure unfolded through the sequence of reflections.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from typing import List

def generate():
    grid_size = 20
    grid = [[0] * grid_size for _ in range(grid_size)]
    
    rectangles = []
    for level in range(3):
        r_start = 2 * level
        c_start = 2 * level
        r_end = grid_size - 1 - 2 * level
        c_end = grid_size - 1 - 2 * level
        if r_start >= r_end or c_start >= c_end:
            break
        rectangles.append((r_start, c_start, r_end, c_end))
    
    border_colors = random.sample(range(1, 10), len(rectangles))
    interior_colors = []
    for bc in border_colors:
        colors = [c for c in range(1, 10) if c != bc]
        interior_colors.append(random.choice(colors))
    
    for (r_start, c_start, r_end, c_end), bc, ic in zip(rectangles, border_colors, interior_colors):
        for r in [r_start, r_end]:
            for c in range(c_start, c_end + 1):
                grid[r][c] = bc
        for c in [c_start, c_end]:
            for r in range(r_start + 1, r_end):
                grid[r][c] = bc
        for r in range(r_start + 1, r_end):
            for c in range(c_start + 1, c_end):
                grid[r][c] = ic
    
    output = [row[:] for row in grid]
    modulation_map = {
        1: 0,
        2: 1,
        3: 2,
        4: -1,
        5: -2,
        6: -3,
        7: 3,
        8: -4,
        9: 4
    }
    
    for i in range(len(rectangles)):
        r_start, c_start, r_end, c_end = rectangles[i]
        bc = border_colors[i]
        mod = modulation_map[bc]
        interior_h = (r_end - 1) - (r_start + 1) + 1
        interior_w = (c_end - 1) - (c_start + 1) + 1
        cut_type = (bc - 1) // 3
        cut_pos = (bc - 1) % 3
        
        if cut_type == 0:  # Horizontal
            if cut_pos == 0:
                cut_row = r_start + 1 + (interior_h * 1) // 4
            elif cut_pos == 1:
                cut_row = r_start + 1 + interior_h // 2
            else:
                cut_row = r_start + 1 + (interior_h * 3) // 4
            
            if cut_pos == 0:
                src_rows = range(r_start + 1, cut_row)
                dst_rows = range(cut_row, r_end)
            elif cut_pos == 1:
                src_rows = range(r_start + 1, cut_row)
                dst_rows = range(cut_row + 1, r_end)
            else:
                src_rows = range(cut_row + 1, r_end)
                dst_rows = range(r_start + 1, cut_row)
            
            for c in range(c_start + 1, c_end):
                for r in src_rows:
                    r_dst = 2 * cut_row - r
                    color = output[r][c]
                    new_color = (color + mod) % 10
                    output[r_dst][c] = new_color
        
        elif cut_type == 1:  # Vertical
            if cut_pos == 0:
                cut_col = c_start + 1 + (interior_w * 1) // 4
            elif cut_pos == 1:
                cut_col = c_start + 1 + interior_w // 2
            else:
                cut_col = c_start + 1 + (interior_w * 3) // 4
            
            if cut_pos == 0:
                src_cols = range(c_start + 1, cut_col)
                dst_cols = range(cut_col, c_end)
            elif cut_pos == 1:
                src_cols = range(c_start + 1, cut_col)
                dst_cols = range(cut_col + 1, c_end)
            else:
                src_cols = range(cut_col + 1, c_end)
                dst_cols = range(c_start + 1, cut_col)
            
            for r in range(r_start + 1, r_end):
                for c in src_cols:
                    c_dst = 2 * cut_col - c
                    color = output[r][c]
                    new_color = (color + mod) % 10
                    output[r][c_dst] = new_color
    
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from typing import List, Tuple

def p(input_grid: Tuple[Tuple[int, ...], ...]) -> List[List[int]]:
    grid_size = len(input_grid)
    grid = [list(row) for row in input_grid]
    
    rectangles = [
        (0, 0, 19, 19),
        (2, 2, 17, 17),
        (4, 4, 15, 15)
    ]
    
    border_colors = []
    for (r_start, c_start, r_end, c_end) in rectangles:
        border_colors.append(grid[r_start][c_start])
    
    output = [row[:] for row in grid]
    modulation_map = {
        1: 0,
        2: 1,
        3: 2,
        4: -1,
        5: -2,
        6: -3,
        7: 3,
        8: -4,
        9: 4
    }
    
    for i in range(len(rectangles)):
        r_start, c_start, r_end, c_end = rectangles[i]
        bc = border_colors[i]
        mod = modulation_map[bc]
        interior_h = (r_end - 1) - (r_start + 1) + 1
        interior_w = (c_end - 1) - (c_start + 1) + 1
        cut_type = (bc - 1) // 3
        cut_pos = (bc - 1) % 3
        
        if cut_type == 0:  # Horizontal
            if cut_pos == 0:
                cut_row = r_start + 1 + (interior_h * 1) // 4
            elif cut_pos == 1:
                cut_row = r_start + 1 + interior_h // 2
            else:
                cut_row = r_start + 1 + (interior_h * 3) // 4
            
            if cut_pos == 0:
                src_rows = range(r_start + 1, cut_row)
                dst_rows = range(cut_row, r_end)
            elif cut_pos == 1:
                src_rows = range(r_start + 1, cut_row)
                dst_rows = range(cut_row + 1, r_end)
            else:
                src_rows = range(cut_row + 1, r_end)
                dst_rows = range(r_start + 1, cut_row)
            
            for c in range(c_start + 1, c_end):
                for r in src_rows:
                    r_dst = 2 * cut_row - r
                    if 0 <= r_dst < grid_size:
                        color = output[r][c]
                        new_color = (color + mod) % 10
                        output[r_dst][c] = new_color
        
        elif cut_type == 1:  # Vertical
            if cut_pos == 0:
                cut_col = c_start + 1 + (interior_w * 1) // 4
            elif cut_pos == 1:
                cut_col = c_start + 1 + interior_w // 2
            else:
                cut_col = c_start + 1 + (interior_w * 3) // 4
            
            if cut_pos == 0:
                src_cols = range(c_start + 1, cut_col)
                dst_cols = range(cut_col, c_end)
            elif cut_pos == 1:
                src_cols = range(c_start + 1, cut_col)
                dst_cols = range(cut_col + 1, c_end)
            else:
                src_cols = range(cut_col + 1, c_end)
                dst_cols = range(c_start + 1, cut_col)
            
            for r in range(r_start + 1, r_end):
                for c in src_cols:
                    c_dst = 2 * cut_col - c
                    if 0 <= c_dst < grid_size:
                        color = output[r][c]
                        new_color = (color + mod) % 10
                        output[r][c_dst] = new_color
    
    return output
