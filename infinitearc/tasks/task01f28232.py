# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 01f28232
Difficulty: easy

=== Tags ===
- Hierarchical agent routing
- Reactive surface
- Pathfinding with state
- Connect nearest components

=== Description ===
Input grids feature a uniform background color with scattered red and blue
cells. Red cells represent "agents," while blue cells represent "targets." The
output grid retains all background elements and colors, but adds straight-line
connections between each agent and its nearest target using a distinct green
color. Connections are drawn as horizontal or vertical lines occupying only
background cells, with no overlap between lines or crossing over agents or
targets. Each agent connects to exactly one target, and each target serves
exactly one agent. The connections are generated in hierarchical order,
processing agents from top-left to bottom-right, ensuring each agent selects the
closest available target based on Manhattan distance. The "reactive surface"
refers to the grid automatically generating these connections upon detecting
proximity, while "pathfinding with state" describes the dynamic selection of
targets as connections are made. The "connect nearest components" rule ensures
all connections follow the shortest possible path without interference.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 20)
    height = random.randint(5, 20)
    grid = [[0] * width for _ in range(height)]
    n = random.randint(1, 5)
    
    for r in range(n):
        grid[r][0] = 2
    for r in range(n):
        if r < height and 2 < width:
            grid[r][2] = 1
    
    output = [row[:] for row in grid]
    for r in range(n):
        if r < height:
            output[r][1] = 3
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to list of lists if it's a tuple
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    
    agents = []
    targets = []
    height = len(input_grid)
    width = len(input_grid[0])
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 2:
                agents.append((r, c))
            elif input_grid[r][c] == 1:
                targets.append((r, c))
    
    agents.sort(key=lambda x: (x[0], x[1]))
    output = [row[:] for row in input_grid]
    
    for agent in agents:
        min_dist = float('inf')
        closest_target = None
        for target in targets:
            dist = abs(agent[0] - target[0]) + abs(agent[1] - target[1])
            if dist < min_dist:
                min_dist = dist
                closest_target = target
        
        r1, c1 = agent
        r2, c2 = closest_target
        if r1 == r2:
            start = min(c1, c2)
            end = max(c1, c2)
            for c in range(start + 1, end):
                if output[r1][c] == 0:
                    output[r1][c] = 3
        elif c1 == c2:
            start = min(r1, r2)
            end = max(r1, r2)
            for r in range(start + 1, end):
                if output[r][c1] == 0:
                    output[r][c1] = 3
    return output
