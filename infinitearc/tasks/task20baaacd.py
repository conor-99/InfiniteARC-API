# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 20baaacd
Difficulty: very hard

=== Tags ===
- Variable binding by color
- Gravity

=== Description ===
Color-Bound Gravity Flow  Input grids are composed of colored cells (0-9)
arranged in a 10×10 to 30×30 grid. Each color represents a variable that must
bind to a specific partner color according to the rule: color i binds to color
(i + 2) mod 10. A bound pair consists of two adjacent cells (horizontally or
vertically) with binding colors, such as 0 and 2, 1 and 3, 8 and 0, or 9 and 1.
The transformation applies downward gravity to the grid, causing all cells to
fall until they can no longer fall. During this process: - Single cells
(unbound) fall vertically until they hit the grid bottom or another cell. -
Bound pairs maintain their relative horizontal or vertical adjacency throughout
the fall. The entire pair falls as a single unit; if any cell in the pair
encounters an obstacle during descent, the entire pair stops falling. - Cells
may fall past unbound elements but cannot overlap with other cells or bound
pairs. - Bound pairs never split or rotate during the fall.  The output grid
shows all cells in their lowest possible positions under these constraints.
Bound pairs remain visually connected and maintain their original orientation.
The transformation requires identifying all bound pairs, then simulating their
coordinated fall while respecting adjacency constraints, which becomes
increasingly complex with overlapping pairs and obstacles in densely packed
grids.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

# Generator for ARC task: Color-Bound Gravity Flow
# This generator includes an internal solver `p` identical to the external solver
# so the generator can compute the expected output.

def p(input_grid):
    # Solver: simulate gravity with bound pairs that remain connected
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0])

    visited = [[False] * W for _ in range(H)]
    units = []  # each unit is list of (r,c,color)

    for r in range(H):
        for c in range(W):
            if visited[r][c] or grid[r][c] == 0:
                continue
            color = grid[r][c]
            paired = False
            # Prefer horizontal (right) pairing, then vertical (down)
            if c + 1 < W and not visited[r][c + 1] and grid[r][c + 1] != 0:
                neigh = grid[r][c + 1]
                if neigh == (color + 2) % 10 or neigh == (color + 8) % 10:
                    units.append([(r, c, color), (r, c + 1, neigh)])
                    visited[r][c] = True
                    visited[r][c + 1] = True
                    paired = True
            if not paired and r + 1 < H and not visited[r + 1][c] and grid[r + 1][c] != 0:
                neigh = grid[r + 1][c]
                if neigh == (color + 2) % 10 or neigh == (color + 8) % 10:
                    units.append([(r, c, color), (r + 1, c, neigh)])
                    visited[r][c] = True
                    visited[r + 1][c] = True
                    paired = True
            if not paired:
                units.append([(r, c, color)])
                visited[r][c] = True

    # build position -> unit mapping
    pos2unit = {}
    for uid, unit in enumerate(units):
        for (r, c, _) in unit:
            pos2unit[(r, c)] = uid

    # Simulate simultaneous gravity steps until no unit can move
    while True:
        blocked = set()
        # Units that touch the floor are blocked
        for uid, unit in enumerate(units):
            for (r, c, _) in unit:
                if r == H - 1:
                    blocked.add(uid)
                    break
        # Propagate blocked status upward: if any part of a unit rests on a blocked unit, it is blocked
        changed = True
        while changed:
            changed = False
            for uid, unit in enumerate(units):
                if uid in blocked:
                    continue
                for (r, c, _) in unit:
                    below = (r + 1, c)
                    if below in pos2unit:
                        below_uid = pos2unit[below]
                        if below_uid in blocked:
                            blocked.add(uid)
                            changed = True
                            break
        movers = set(range(len(units))) - blocked
        if not movers:
            break

        # Move all movers down by one row simultaneously
        new_pos2unit = {}
        new_units = []
        for uid, unit in enumerate(units):
            if uid in movers:
                moved = [(r + 1, c, col) for (r, c, col) in unit]
                new_units.append(moved)
            else:
                new_units.append(list(unit))
            # fill new_pos2unit
            for (r, c, _) in new_units[-1]:
                if (r, c) in new_pos2unit:
                    # This should not happen in a correct simultaneous-move step
                    raise RuntimeError('Collision detected during gravity move')
                new_pos2unit[(r, c)] = uid

        units = new_units
        pos2unit = new_pos2unit

    # build output grid
    out = [[0] * W for _ in range(H)]
    for unit in units:
        for (r, c, color) in unit:
            out[r][c] = color
    return out


def generate():
    # Keep trying until we create a non-trivial example
    attempts = 0
    while True:
        attempts += 1
        width = random.randint(10, 30)
        height = random.randint(10, 30)
        grid = [[0 for _ in range(width)] for _ in range(height)]

        # Place isolated bound pairs
        max_pairs = random.randint(3, max(3, min(12, (width * height) // 40)))
        placed = 0
        tries = 0
        while placed < max_pairs and tries < max_pairs * 40:
            tries += 1
            orient = random.choice(["h", "v"])
            if orient == "h":
                r = random.randint(0, height - 1)
                c = random.randint(0, width - 2)
                if grid[r][c] != 0 or grid[r][c + 1] != 0:
                    continue
                # ensure neighbors (except the pair mate) are empty so pairs are unambiguous
                bad = False
                for dr, dc in [(-1, 0), (1, 0), (0, -1)]:
                    rr, cc = r + dr, c + dc
                    if 0 <= rr < height and 0 <= cc < width and grid[rr][cc] != 0:
                        bad = True
                        break
                for dr, dc in [(-1, 0), (1, 0), (0, 1)]:
                    rr, cc = r + dr, c + 1 + dc
                    if 0 <= rr < height and 0 <= cc < width and grid[rr][cc] != 0:
                        bad = True
                        break
                if bad:
                    continue
                i = random.randint(0, 9)
                grid[r][c] = i
                grid[r][c + 1] = (i + 2) % 10
                placed += 1
            else:
                r = random.randint(0, height - 2)
                c = random.randint(0, width - 1)
                if grid[r][c] != 0 or grid[r + 1][c] != 0:
                    continue
                bad = False
                for dr, dc in [(-1, 0), (0, -1), (0, 1)]:
                    rr, cc = r + dr, c + dc
                    if 0 <= rr < height and 0 <= cc < width and grid[rr][cc] != 0:
                        bad = True
                        break
                for dr, dc in [(1, 0), (0, -1), (0, 1)]:
                    rr, cc = r + 1 + dr, c + dc
                    if 0 <= rr < height and 0 <= cc < width and grid[rr][cc] != 0:
                        bad = True
                        break
                if bad:
                    continue
                i = random.randint(0, 9)
                grid[r][c] = i
                grid[r + 1][c] = (i + 2) % 10
                placed += 1

        # Place some single cells, avoiding creation of accidental bound adjacencies
        max_singles = random.randint(6, max(6, (width * height) // 30))
        placed_s = 0
        tries = 0
        while placed_s < max_singles and tries < max_singles * 30:
            tries += 1
            r = random.randint(0, height - 1)
            c = random.randint(0, width - 1)
            if grid[r][c] != 0:
                continue
            s = random.randint(0, 9)
            conflict = False
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                rr, cc = r + dr, c + dc
                if 0 <= rr < height and 0 <= cc < width and grid[rr][cc] != 0:
                    g = grid[rr][cc]
                    # binding if either direction holds
                    if g == (s + 2) % 10 or s == (g + 2) % 10:
                        conflict = True
                        break
            if conflict:
                continue
            grid[r][c] = s
            placed_s += 1

        # Ensure we didn't create an initially-final grid; compute expected output
        input_grid = [list(row) for row in grid]
        output_grid = p(tuple(tuple(row) for row in input_grid))

        if input_grid == output_grid:
            # If everything already resting, try again (but avoid infinite loop)
            if attempts > 50:
                # Force at least one movable element: place a single above empty space
                rr = random.randint(0, height - 2)
                cc = random.randint(0, width - 1)
                if grid[rr][cc] == 0 and grid[height - 1][cc] == 0:
                    grid[rr][cc] = random.randint(1, 9)
                    input_grid = [list(row) for row in grid]
                    output_grid = p(tuple(tuple(row) for row in input_grid))
                    if input_grid == output_grid:
                        continue
                else:
                    continue
            else:
                continue

        return {
            "input": input_grid,
            "output": output_grid
        }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Solver: simulate gravity with bound pairs that remain connected
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0])

    visited = [[False] * W for _ in range(H)]
    units = []  # each unit is list of (r,c,color)

    for r in range(H):
        for c in range(W):
            if visited[r][c] or grid[r][c] == 0:
                continue
            color = grid[r][c]
            paired = False
            # Prefer horizontal (right) pairing, then vertical (down)
            if c + 1 < W and not visited[r][c + 1] and grid[r][c + 1] != 0:
                neigh = grid[r][c + 1]
                if neigh == (color + 2) % 10 or neigh == (color + 8) % 10:
                    units.append([(r, c, color), (r, c + 1, neigh)])
                    visited[r][c] = True
                    visited[r][c + 1] = True
                    paired = True
            if not paired and r + 1 < H and not visited[r + 1][c] and grid[r + 1][c] != 0:
                neigh = grid[r + 1][c]
                if neigh == (color + 2) % 10 or neigh == (color + 8) % 10:
                    units.append([(r, c, color), (r + 1, c, neigh)])
                    visited[r][c] = True
                    visited[r + 1][c] = True
                    paired = True
            if not paired:
                units.append([(r, c, color)])
                visited[r][c] = True

    # build position -> unit mapping
    pos2unit = {}
    for uid, unit in enumerate(units):
        for (r, c, _) in unit:
            pos2unit[(r, c)] = uid

    # Simulate simultaneous gravity steps until no unit can move
    while True:
        blocked = set()
        # Units that touch the floor are blocked
        for uid, unit in enumerate(units):
            for (r, c, _) in unit:
                if r == H - 1:
                    blocked.add(uid)
                    break
        # Propagate blocked status upward: if any part of a unit rests on a blocked unit, it is blocked
        changed = True
        while changed:
            changed = False
            for uid, unit in enumerate(units):
                if uid in blocked:
                    continue
                for (r, c, _) in unit:
                    below = (r + 1, c)
                    if below in pos2unit:
                        below_uid = pos2unit[below]
                        if below_uid in blocked:
                            blocked.add(uid)
                            changed = True
                            break
        movers = set(range(len(units))) - blocked
        if not movers:
            break

        # Move all movers down by one row simultaneously
        new_pos2unit = {}
        new_units = []
        for uid, unit in enumerate(units):
            if uid in movers:
                moved = [(r + 1, c, col) for (r, c, col) in unit]
                new_units.append(moved)
            else:
                new_units.append(list(unit))
            # fill new_pos2unit
            for (r, c, _) in new_units[-1]:
                if (r, c) in new_pos2unit:
                    # This should not happen in a correct simultaneous-move step
                    raise RuntimeError('Collision detected during gravity move')
                new_pos2unit[(r, c)] = uid

        units = new_units
        pos2unit = new_pos2unit

    # build output grid
    out = [[0] * W for _ in range(H)]
    for unit in units:
        for (r, c, color) in unit:
            out[r][c] = color
    return out

