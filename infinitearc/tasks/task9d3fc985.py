# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 9d3fc985
Difficulty: medium–hard

=== Tags ===
- Refraction simulation
- Recursive mirroring
- Phase transition path
- Associate colors to ranks

=== Description ===
Phase-Refraction Pathway  Input grids feature a single background color (0) with
a continuous path of colored tiles (1-9) arranged in a sequence where each tile
is 4-directionally adjacent to the next, and the color of each tile corresponds
exactly to its rank in the sequence (color 1 = rank 1, color 2 = rank 2, ...,
color 9 = rank 9). The path begins at the topmost-leftmost tile of rank 1 and
terminates at the highest rank tile present. The grid also contains a single
"beam origin" cell (a background cell adjacent to the rank 1 tile) from which a
beam is projected in a fixed initial direction (e.g., rightward).   The
transformation involves simulating a beam's journey through the grid, where: 1.
Upon reaching a tile of rank C (color C), the beam refracts (changes direction
based on C's value) and the background cells traversed to reach that tile are
colored C in the output. 2. Refraction direction rules are fixed: color 1 = 45°
left turn, color 2 = 45° right turn, color 3 = 90° left turn, color 4 = 90°
right turn, with higher colors cycling through these patterns. 3. The beam
continues until it either exits the grid or encounters a tile whose rank exceeds
the sequence (e.g., after color 8, color 9 would be the final tile). 4.
"Recursive mirroring" occurs when the beam reflects off a mirror tile (color
5-9, each representing a reflection type), causing the path to mirror its
previous segment direction before continuing with the next rank. 5. The output
grid retains all input tiles and background, but replaces the trajectory of the
beam (the background cells the beam traversed) with the color corresponding to
the rank of the tile it last hit, following the phase transition sequence (rank
1 → 2 → 3 → ...). The beam never overlaps with tiles or other path segments, and
all transformations are deterministic based on the sequence of tile colors.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Directions (8 compass): N, NE, E, SE, S, SW, W, NW
    dr = [-1, -1, 0, 1, 1, 1, 0, -1]
    dc = [0, 1, 1, 1, 0, -1, -1, -1]

    # Refraction deltas (in 45-degree steps). Positive = rotate clockwise.
    # color 1 = 45° left (-1), 2 = 45° right (+1), 3 = 90° left (-2), 4 = 90° right (+2)
    base = [-1, 1, -2, 2]
    delta_map = {i: base[(i - 1) % 4] for i in range(1, 10)}

    # Attempt to build a valid random configuration repeatedly until one fits.
    for attempt in range(500):
        size = random.randint(7, 15)
        input_grid = grid(size, size, 0)

        # number of tiles (ranks)
        n_tiles = random.randint(2, min(8, 1 + size // 2))

        # choose a safe margin so we can step a few cells in any direction
        margin = 3

        # pick a random start (tile 1) not too close to borders
        r1 = random.randint(margin, size - margin - 1)
        c1 = random.randint(margin, size - margin - 1)

        # pick an incoming direction (from origin to tile1)
        incoming_dir = random.randint(0, 7)
        origin_r = r1 - dr[incoming_dir]
        origin_c = c1 - dc[incoming_dir]

        # origin must be inside grid and background
        if not (0 <= origin_r < size and 0 <= origin_c < size):
            continue

        # We'll build the chain of tile positions. We require gaps (>=2) between tiles
        # so there are background cells for the beam to color.
        tiles = [(r1, c1)]
        occupied = set(tiles)
        # Reserve origin as a background cell (can't place a tile there)
        origin = (origin_r, origin_c)
        if origin in occupied:
            continue

        success = True
        cur_dir = incoming_dir

        # Build subsequent tiles
        for color in range(1, n_tiles):
            # compute outgoing direction after hitting current tile
            delta = delta_map[color]
            out_dir = (cur_dir + delta) % 8

            # choose a distance for the next tile along out_dir (must be >=2 so there is at least one background cell)
            distances = list(range(2, min(5, max(3, size // 3)) + 1))
            random.shuffle(distances)
            placed = False
            prev_r, prev_c = tiles[-1]

            for d in distances:
                nr = prev_r + dr[out_dir] * d
                nc = prev_c + dc[out_dir] * d
                # bounds check
                if not (0 <= nr < size and 0 <= nc < size):
                    continue
                # cannot place on origin
                if (nr, nc) == origin:
                    continue
                # cannot place where a tile already exists
                if (nr, nc) in occupied:
                    continue
                # check the intermediate cells for collisions with existing tiles
                blocked = False
                for step in range(1, d):
                    ir = prev_r + dr[out_dir] * step
                    ic = prev_c + dc[out_dir] * step
                    if (ir, ic) in occupied:
                        blocked = True
                        break
                if blocked:
                    continue

                # placement looks good
                tiles.append((nr, nc))
                occupied.add((nr, nc))
                cur_dir = out_dir
                placed = True
                break

            if not placed:
                success = False
                break

        if not success:
            continue

        # Place tile colors into input grid
        for idx, (tr, tc) in enumerate(tiles):
            input_grid[tr][tc] = idx + 1

        # Ensure origin is background (it should be)
        input_grid[origin[0]][origin[1]] = 0

        # Build output grid by simulating the beam
        output_grid = [row[:] for row in input_grid]
        cur_pos = origin
        cur_dir = incoming_dir

        for idx, (tr, tc) in enumerate(tiles):
            color = idx + 1
            # step until we hit the tile
            while True:
                nr = cur_pos[0] + dr[cur_dir]
                nc = cur_pos[1] + dc[cur_dir]
                # if we leave grid, stop simulation (this configuration should avoid that)
                if not (0 <= nr < size and 0 <= nc < size):
                    break
                # If next is the tile we expect, stop marking and update
                if (nr, nc) == (tr, tc):
                    cur_pos = (nr, nc)
                    # update direction after refraction
                    cur_dir = (cur_dir + delta_map[color]) % 8
                    break
                # if we hit another tile unexpectedly, this generation failed
                if output_grid[nr][nc] != 0:
                    success = False
                    break
                # mark the traversed background cell with the current tile color
                output_grid[nr][nc] = color
                cur_pos = (nr, nc)
            if not success:
                break

        if not success:
            continue

        # Return the generated pair
        return {"input": input_grid, "output": output_grid}

    # If we failed after many attempts, fall back to a deterministic small example
    size = 9
    input_grid = grid(size, size, 0)
    input_grid[4][4] = 1
    input_grid[4][7] = 2
    input_grid[1][7] = 3
    origin = (4, 3)
    input_grid[origin[0]][origin[1]] = 0
    output_grid = [row[:] for row in input_grid]
    output_grid[4][3] = 1
    output_grid[4][5] = 1
    output_grid[4][6] = 2
    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list
    grid_in = [list(row) for row in input_grid]
    h = len(grid_in)
    w = len(grid_in[0]) if h else 0

    # Directions (N, NE, E, SE, S, SW, W, NW)
    dr = [-1, -1, 0, 1, 1, 1, 0, -1]
    dc = [0, 1, 1, 1, 0, -1, -1, -1]

    # Refraction mapping used by the generator
    base = [-1, 1, -2, 2]
    delta_map = {i: base[(i - 1) % 4] for i in range(1, 10)}

    # find tiles by color (colors 1..9)
    tiles = {}
    max_color = 0
    for r in range(h):
        for c in range(w):
            v = grid_in[r][c]
            if v > 0:
                tiles[v] = (r, c)
                if v > max_color:
                    max_color = v

    if max_color == 0:
        return grid_in

    # We expect colors to start at 1 and be contiguous; collect present colors in order
    present = [c for c in range(1, max_color + 1) if c in tiles]
    if not present:
        return grid_in

    tile_positions = [tiles[c] for c in present]

    # Find candidate origin cells: background neighbors of tile 1
    t1_r, t1_c = tile_positions[0]
    candidates = []
    for d in range(8):
        or_r = t1_r - dr[d]
        or_c = t1_c - dc[d]
        if 0 <= or_r < h and 0 <= or_c < w and grid_in[or_r][or_c] == 0:
            candidates.append(((or_r, or_c), d))

    def try_simulate(origin, incoming_dir):
        # simulate the beam path; return output grid or None on failure
        out = [row[:] for row in grid_in]
        cur_pos = origin
        cur_dir = incoming_dir
        for idx, (tr, tc) in enumerate(tile_positions):
            color = idx + 1
            steps = 0
            while True:
                nr = cur_pos[0] + dr[cur_dir]
                nc = cur_pos[1] + dc[cur_dir]
                steps += 1
                if not (0 <= nr < h and 0 <= nc < w):
                    # beam left grid before reaching expected tile -> fail
                    return None
                # if we encounter a tile that's not the expected one -> fail
                if (nr, nc) != (tr, tc) and out[nr][nc] != 0:
                    return None
                # if we reached expected tile
                if (nr, nc) == (tr, tc):
                    # mark nothing for the tile cell itself, update position and direction
                    cur_pos = (nr, nc)
                    cur_dir = (cur_dir + delta_map[color]) % 8
                    break
                # else mark the traversed background cell with the color
                out[nr][nc] = color
                cur_pos = (nr, nc)
                # safety guard
                if steps > (h * w):
                    return None
        return out

    # Try candidates until one yields a valid simulation
    for (origin, incoming_dir) in candidates:
        res = try_simulate(origin, incoming_dir)
        if res is not None:
            return res

    # If none of the simple neighbors worked, perform a more permissive search: try any zero cell as origin
    for r in range(h):
        for c in range(w):
            if grid_in[r][c] != 0:
                continue
            # determine dir to tile1 if it is one step away; otherwise compute normalized dir if possible
            # try all 8 initial directions from this origin leading into the grid
            for d in range(8):
                nr = r + dr[d]
                nc = c + dc[d]
                if not (0 <= nr < h and 0 <= nc < w):
                    continue
                if (nr, nc) == tile_positions[0]:
                    res = try_simulate((r, c), d)
                    if res is not None:
                        return res
    # Fallback: no valid simulation found, just return input copy
    return [row[:] for row in grid_in]

