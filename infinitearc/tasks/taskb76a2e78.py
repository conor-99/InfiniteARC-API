# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: b76a2e78
Difficulty: very hard

=== Tags ===
- Folded grid reasoning
- Pattern repetition with offset
- Transformation stack
- Recolor object based on neighbor count
- Compare image

=== Description ===
Input grids feature multiple non-overlapping, connected regions (objects) of
distinct colors arranged in a repeating pattern. Each object's position is
offset from its predecessor based on the neighbor count of its top-left cell
within the object—specifically, the number of adjacent cells (up, down, left,
right) sharing the same color. For example, a top-left cell with 3 same-color
neighbors (indicating a 4-cell vertical segment) shifts the next object right by
3 and down by 1. Each object is then recolored according to its adjacency count:
if an object shares edges with N other objects, it adopts color N. Finally, the
grid is folded vertically along its central axis, mirroring the left half onto
the right half. Overlapping objects are resolved by retaining the object with
the higher recolor value, producing the output grid where all
transformations—offset positioning, adjacency-based recoloring, and folding—are
applied sequentially.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def get_components(grid):
    h = len(grid)
    w = len(grid[0])
    visited = [[False]*w for _ in range(h)]
    components = []
    coord_to_comp = {}
    for r in range(h):
        for c in range(w):
            if grid[r][c] > 0 and not visited[r][c]:
                color = grid[r][c]
                stack = [(r,c)]
                comp=[]
                visited[r][c]=True
                while stack:
                    cr,cc = stack.pop()
                    comp.append((cr,cc))
                    coord_to_comp[(cr,cc)] = len(components)
                    for dr,dc in ((1,0),(-1,0),(0,1),(0,-1)):
                        nr,nc = cr+dr, cc+dc
                        if 0<=nr<h and 0<=nc<w and not visited[nr][nc] and grid[nr][nc]==color:
                            visited[nr][nc]=True
                            stack.append((nr,nc))
                components.append((color, comp))
    return components, coord_to_comp

def generate():
    # Create a repeating pattern of a connected shape, place multiple copies
    # offset by the neighbor-count of the top-left cell, recolor by adjacency,
    # and then fold vertically.
    tries = 0
    while True:
        tries += 1
        # limit attempts to avoid infinite loops
        if tries > 200:
            break
        # Number of repeated objects. Keep <=5 so recolor values (0..4) won't conflict with original colors chosen >=5.
        num_objects = random.randint(3, 5)
        # Random shape bounding box
        shape_w = random.randint(1, 4)
        shape_h = random.randint(1, 4)
        # ensure at least 2 cells available to choose a size>1 when possible
        area = shape_w * shape_h
        if area >= 2:
            min_size = 2
        else:
            min_size = 1
        max_size = min(area, 6)
        size = random.randint(min_size, max_size)
        # Create a contiguous shape in its bounding box
        pixels = common.continuous_creature(size, width=shape_w, height=shape_h)
        # normalize to ensure coords are within bounding box
        shape_pixels = list(set(pixels))
        # compute shape bbox dims
        min_r = min(p[0] for p in shape_pixels)
        min_c = min(p[1] for p in shape_pixels)
        # shift to top-left origin for shape coordinates
        shape_pixels = [(r - min_r, c - min_c) for (r,c) in shape_pixels]
        shape_h_real = max(r for r,c in shape_pixels) + 1
        shape_w_real = max(c for r,c in shape_pixels) + 1
        # top-left cell within the shape (coordinates within shape)
        top_left = min(shape_pixels)
        tlr, tlc = top_left
        # neighbor count of top-left within the shape
        shape_set = set(shape_pixels)
        neighbor_count = 0
        for dr,dc in ((1,0),(-1,0),(0,1),(0,-1)):
            if (tlr+dr, tlc+dc) in shape_set:
                neighbor_count += 1
        # choose start position small so pattern grows right and down
        start_r = random.randint(0, 2)
        start_c = random.randint(0, 2)
        margin_r = random.randint(1, 3)
        margin_c = random.randint(1, 3)
        # compute minimal required grid size
        req_width = start_c + shape_w_real + neighbor_count * (num_objects - 1) + margin_c
        req_height = start_r + shape_h_real + (num_objects - 1) + margin_r
        # if too big, reduce number of objects until it fits (but at least 3)
        while (req_width > 30 or req_height > 30) and num_objects > 3:
            num_objects -= 1
            req_width = start_c + shape_w_real + neighbor_count * (num_objects - 1) + margin_c
            req_height = start_r + shape_h_real + (num_objects - 1) + margin_r
        if req_width > 30 or req_height > 30:
            # try again with a different shape
            continue
        width = req_width
        height = req_height
        # create grid
        grid = common.grid(width, height, 0)
        # pick distinct colors for each object from 5..9 (ensures recolor values 0..4 differ)
        palette = list(range(5, 10))
        if num_objects > len(palette):
            # fallback reduce num_objects
            num_objects = len(palette)
        colors = random.sample(palette, num_objects)
        # place objects
        placed = True
        for i in range(num_objects):
            pr = start_r + i * 1
            pc = start_c + i * neighbor_count
            # check bounds
            if pr + shape_h_real > height or pc + shape_w_real > width:
                placed = False
                break
            # check overlap
            for (sr, sc) in shape_pixels:
                r = pr + sr
                c = pc + sc
                if grid[r][c] != 0:
                    placed = False
                    break
            if not placed:
                break
            # place color
            color = colors[i]
            for (sr, sc) in shape_pixels:
                grid[pr + sr][pc + sc] = color
        if not placed:
            # try again
            continue
        # We have an input grid. Now compute output by recoloring by adjacency and folding.
        input_grid = [row[:] for row in grid]
        components, coord_to_comp = get_components(input_grid)
        # safety: require at least 2 components
        if len(components) < 2:
            continue
        # compute adjacency counts using mapping to component indices
        adj_counts = [0] * len(components)
        for comp_idx, (color, comp_pixels) in enumerate(components):
            neighbors = set()
            for (r,c) in comp_pixels:
                for dr,dc in ((1,0),(-1,0),(0,1),(0,-1)):
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        if (nr, nc) in coord_to_comp:
                            other_idx = coord_to_comp[(nr, nc)]
                            if other_idx != comp_idx:
                                neighbors.add(other_idx)
            adj_counts[comp_idx] = len(neighbors)
        # recolor
        output_grid = [row[:] for row in input_grid]
        for comp_idx, (color, comp_pixels) in enumerate(components):
            newcolor = adj_counts[comp_idx]
            for (r,c) in comp_pixels:
                output_grid[r][c] = newcolor
        # fold vertically: mirror left onto right, keep max value on overlap
        w = width
        for r in range(height):
            for c in range(w // 2, w):
                left = w - 1 - c
                output_grid[r][c] = max(output_grid[r][c], output_grid[r][left])
        # ensure output differs from input (should be true because original colors >=5 and adj_counts <=4)
        if output_grid == input_grid:
            # extremely unlikely, try again
            continue
        return {"input": input_grid, "output": output_grid}
    # fallback deterministic simple example (should not be hit)
    grid = common.grid(7, 7, 0)
    grid[0][0] = 5
    grid[1][0] = 5
    input_grid = [row[:] for row in grid]
    output_grid = [row[:] for row in grid]
    output_grid[1][0] = 1
    # fold
    for r in range(7):
        for c in range(7//2, 7):
            left = 7 - 1 - c
            output_grid[r][c] = max(output_grid[r][c], output_grid[r][left])
    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def get_components(grid):
    h = len(grid)
    w = len(grid[0])
    visited = [[False]*w for _ in range(h)]
    components = []
    coord_to_comp = {}
    for r in range(h):
        for c in range(w):
            if grid[r][c] > 0 and not visited[r][c]:
                color = grid[r][c]
                stack = [(r,c)]
                visited[r][c] = True
                comp = []
                while stack:
                    cr, cc = stack.pop()
                    comp.append((cr, cc))
                    coord_to_comp[(cr,cc)] = len(components)
                    for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append((color, comp))
    return components, coord_to_comp

def p(input_grid):
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])
    components, coord_to_comp = get_components(grid)
    if len(components) == 0:
        return tuple(tuple(row) for row in grid)
    # adjacency counts
    adj_counts = [0] * len(components)
    for comp_idx, (color, comp_pixels) in enumerate(components):
        neighbors = set()
        for (r,c) in comp_pixels:
            for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):
                nr, nc = r + dr, c + dc
                if 0 <= nr < h and 0 <= nc < w:
                    if (nr, nc) in coord_to_comp:
                        other_idx = coord_to_comp[(nr, nc)]
                        if other_idx != comp_idx:
                            neighbors.add(other_idx)
        adj_counts[comp_idx] = len(neighbors)
    # recolor grid
    out = [row[:] for row in grid]
    for comp_idx, (color, comp_pixels) in enumerate(components):
        newcolor = adj_counts[comp_idx]
        for (r,c) in comp_pixels:
            out[r][c] = newcolor
    # fold vertically (mirror left onto right, keep larger value)
    for r in range(h):
        for c in range(w // 2, w):
            left = w - 1 - c
            out[r][c] = max(out[r][c], out[r][left])
    return tuple(tuple(row) for row in out)

