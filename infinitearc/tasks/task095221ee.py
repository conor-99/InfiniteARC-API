# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 095221ee
Difficulty: insane

=== Tags ===
- Energy field diffusion
- Mirror bounce
- Local rule cascade
- Stepwise color transition
- Bounce

=== Description ===
Input grids are large (width and height exceeding 20) with a uniform background
color (0). Scattered across the grid are three distinct element types: sources
(color 1), mirrors (color 5), and obstacles (color 9). Sources are positioned on
the left edge of the grid, each emitting a directional energy field moving
rightward. The energy field traverses background cells, replacing them with a
stepwise increasing color sequence (starting at 1 for the source cell,
incrementing to 2, 3, etc. for each subsequent cell). When the energy field
encounters a mirror (color 5) in its path, it bounces 90 degrees clockwise
(right → up → left → down → right), and the color increments. The field
continues in the new direction, replacing background cells with the incremented
color. If the energy field encounters an obstacle (color 9), the path terminates
immediately without further traversal. Mirrors (color 5) and obstacles (color 9)
remain visible and unchanged in the output. The output grid renders all energy
field paths with their stepwise colors, while preserving all source, mirror, and
obstacle elements. Paths never overlap, and all energy fields eventually exit
the grid through a boundary cell. The transformation requires sequential
application of local reflection rules, color progression, and boundary handling,
creating complex, non-linear trajectories that depend on the grid's spatial
arrangement of elements.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    # Try multiple times to build a valid configuration
    for attempt in range(1000):
        width = random.randint(20, 30)
        height = random.randint(20, 30)
        # Create empty grid (common.grid takes width, height)
        input_grid = common.grid(width, height, 0)

        # Place 1-3 sources on the left edge (column 0), avoid corners for variability
        num_sources = random.randint(1, 3)
        source_rows = random.sample(list(range(1, height - 1)), num_sources)
        source_rows.sort()
        for r in source_rows:
            input_grid[r][0] = 1

        # Place mirrors (5) in columns 1..width-1 so they don't collide with left-edge sources
        mirror_count = random.randint(3, 10)
        mirrors = set()
        tries = 0
        while len(mirrors) < mirror_count and tries < mirror_count * 10:
            tries += 1
            r = random.randint(0, height - 1)
            c = random.randint(1, width - 1)
            if input_grid[r][c] != 0:
                continue
            mirrors.add((r, c))
            input_grid[r][c] = 5

        # Place obstacles (9) in columns 1..width-1 as well
        obstacle_count = random.randint(2, 6)
        obstacles = set()
        tries = 0
        while len(obstacles) < obstacle_count and tries < obstacle_count * 10:
            tries += 1
            r = random.randint(0, height - 1)
            c = random.randint(1, width - 1)
            if input_grid[r][c] != 0:
                continue
            obstacles.add((r, c))
            input_grid[r][c] = 9

        # Simulate each source to ensure: (a) paths exit the grid, (b) paths do not overlap,
        # (c) paths do not hit obstacles or other sources, (d) colors never exceed 9,
        # (e) at least one background cell becomes colored (so input != output).
        directions = [(0, 1), (-1, 0), (0, -1), (1, 0)]  # right, up, left, down
        all_colored = []
        used = set()
        valid = True

        for srow in source_rows:
            cr, cc = srow, 0
            dr, dc = 0, 1  # start moving right
            color = 1
            local_path = []
            steps = 0
            visited_states = set()

            while True:
                # Safety guards to avoid infinite loops
                if steps > 500:
                    valid = False
                    break
                state = (cr, cc, dr, dc)
                if state in visited_states:
                    valid = False
                    break
                visited_states.add(state)

                nr = cr + dr
                nc = cc + dc
                # If it leaves the grid, the path successfully exited
                if nr < 0 or nr >= height or nc < 0 or nc >= width:
                    break

                cell = input_grid[nr][nc]
                # Mirror: bounce clockwise, increment color, do not overwrite mirror cell
                if cell == 5:
                    color += 1
                    if color > 9:
                        valid = False
                        break
                    # rotate clockwise (dr,dc) -> (-dc, dr)
                    dr, dc = -dc, dr
                    # step into mirror cell (position of the mirror)
                    cr, cc = nr, nc
                    steps += 1
                    continue

                # Obstacle or another source -> invalid (we must exit via boundary only)
                if cell == 9 or cell == 1:
                    valid = False
                    break

                # Background cell: increment color then paint it
                next_color = color + 1
                if next_color > 9:
                    valid = False
                    break
                if (nr, nc) in used:
                    valid = False
                    break

                local_path.append(((nr, nc), next_color))
                used.add((nr, nc))
                color = next_color
                cr, cc = nr, nc
                steps += 1

            if not valid:
                break

            all_colored.append(local_path)

        if not valid:
            # Try a new configuration
            continue

        # Ensure that we actually painted something (input must differ from output)
        if len(used) == 0:
            continue

        # Build output grid by copying input and painting the paths
        output_grid = [row[:] for row in input_grid]
        for local_path in all_colored:
            for (pos, col) in local_path:
                r, c = pos
                output_grid[r][c] = col

        # Final sanity checks
        if input_grid == output_grid:
            # Shouldn't happen due to used check, but double-check
            continue

        return {"input": input_grid, "output": output_grid}

    # If we failed to construct a valid grid after many attempts, raise an error
    raise RuntimeError('Failed to generate a valid task after many attempts')


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    output = [row[:] for row in grid]

    # Find sources on the left edge (color 1)
    source_rows = [r for r in range(height) if grid[r][0] == 1]

    for srow in source_rows:
        cr, cc = srow, 0
        dr, dc = 0, 1  # start moving right
        color = 1
        steps = 0
        visited_states = set()

        while True:
            # Safety guard against infinite loops
            if steps > 1000:
                break
            state = (cr, cc, dr, dc)
            if state in visited_states:
                break
            visited_states.add(state)

            nr = cr + dr
            nc = cc + dc
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                # exited the grid
                break

            cell = grid[nr][nc]
            if cell == 5:
                # Mirror: increment color, turn clockwise, move into mirror cell
                color += 1
                if color > 9:
                    break
                dr, dc = -dc, dr
                cr, cc = nr, nc
                steps += 1
                continue

            if cell == 9 or cell == 1:
                # obstacle or another source: terminate path
                break

            # Background: increment color and paint the cell
            next_color = color + 1
            if next_color > 9:
                break
            output[nr][nc] = next_color
            color = next_color
            cr, cc = nr, nc
            steps += 1

    return output
