# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: a15a92ca
Difficulty: mediumâ€“hard

=== Tags ===
- Reflect by color
- Symbolic circuit
- Perimeter smoothing

=== Description ===
Input grids consist of a single closed loop (circuit) formed by connected cells
of one or more colors (1-9), surrounded by a uniform background (color 0). The
circuit has a jagged perimeter with multiple 90-degree corners where adjacent
horizontal and vertical segments meet. Each corner cell belongs to the circuit
and has a color value that determines the smoothing behavior.  Output grids
transform the input by smoothing all 90-degree corners: each corner cell is
replaced with a diagonal cell (either / or \) that connects the two adjacent
perimeter cells. The diagonal direction is determined by the parity of the
corner cell's color: if the color is odd (1, 3, 5, 7, 9), the diagonal uses the
top-left to bottom-right direction (/); if even (2, 4, 6, 8), it uses the top-
right to bottom-left direction (\). All other cells remain unchanged, preserving
the circuit's structure while removing sharp corners through color-dependent
diagonal smoothing. The background and non-corner circuit cells retain their
original colors and positions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
def generate():
    size = random.randint(3, 30)
    input_grid = [[0] * size for _ in range(size)]
    for r in range(size):
        for c in range(size):
            if r == 0 or r == size-1 or c == 0 or c == size-1:
                input_grid[r][c] = random.randint(1, 9)
    output_grid = [row[:] for row in input_grid]
    corners = [(0, 0), (0, size-1), (size-1, size-1), (size-1, 0)]
    for r, c in corners:
        if input_grid[r][c] % 2 == 1:
            output_grid[r][c] = 8
        else:
            output_grid[r][c] = 9
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                continue
            neighbors = []
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0:
                    neighbors.append((nr, nc))
            if len(neighbors) != 2:
                continue
            dr1 = neighbors[0][0] - r
            dc1 = neighbors[0][1] - c
            dr2 = neighbors[1][0] - r
            dc2 = neighbors[1][1] - c
            if (dr1 != 0 and dc1 == 0 and dr2 == 0 and dc2 != 0) or \
               (dr1 == 0 and dc1 != 0 and dr2 != 0 and dc2 == 0):
                color = input_grid[r][c]
                if color % 2 == 1:
                    output_grid[r][c] = 8
                else:
                    output_grid[r][c] = 9
    return output_grid
