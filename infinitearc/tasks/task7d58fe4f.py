# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 7d58fe4f
Difficulty: hard

=== Tags ===
- Pattern coloring

=== Description ===
The input grid consists of multiple 4-connected regions of single colors, each
forming a distinct shape. For each region, the bounding box dimensions (width
and height) are calculated. If the width exceeds the height, all cells in the
region are replaced with the next color in the cyclic sequence (0 → 1 → 2 → ...
→ 9 → 0). If the height exceeds the width, all cells are replaced with the
previous color (0 → 9 → 8 → ... → 1 → 0). If width equals height, the region
remains unchanged. The output grid reflects these color transformations applied
to all regions in the input, requiring identification of connected components,
spatial analysis of bounding boxes, and cyclic color sequencing.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, continuous_creature

def generate():
    while True:
        width = random.randint(5, 30)
        height = random.randint(5, 30)
        input_grid = grid(width, height, 0)
        regions = []
        colors = list(range(1, 10))
        random.shuffle(colors)
        placed = 0
        for color in colors:
            if placed >= 5:
                break
            size = random.randint(3, 10)
            pixels = continuous_creature(size, width, height)
            if any(input_grid[r][c] != 0 for r, c in pixels):
                continue
            for r, c in pixels:
                input_grid[r][c] = color
            regions.append((color, pixels))
            placed += 1
        all_square = True
        for color, pixels in regions:
            min_r = min(r for r, c in pixels)
            max_r = max(r for r, c in pixels)
            min_c = min(c for r, c in pixels)
            max_c = max(c for r, c in pixels)
            width_box = max_c - min_c + 1
            height_box = max_r - min_r + 1
            if width_box != height_box:
                all_square = False
        if all_square:
            continue
        output_grid = [row[:] for row in input_grid]
        for color, pixels in regions:
            min_r = min(r for r, c in pixels)
            max_r = max(r for r, c in pixels)
            min_c = min(c for r, c in pixels)
            max_c = max(c for r, c in pixels)
            width_box = max_c - min_c + 1
            height_box = max_r - min_r + 1
            if width_box > height_box:
                new_color = (color + 1) % 10
            elif height_box > width_box:
                new_color = (color - 1) % 10
            else:
                new_color = color
            for r, c in pixels:
                output_grid[r][c] = new_color
        return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    visited = [[False] * width for _ in range(height)]
    output_grid = [list(row) for row in input_grid]
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and input_grid[r][c] != 0:
                color = input_grid[r][c]
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                min_r = min(cr for cr, cc in component)
                max_r = max(cr for cr, cc in component)
                min_c = min(cc for cr, cc in component)
                max_c = max(cc for cr, cc in component)
                width_box = max_c - min_c + 1
                height_box = max_r - min_r + 1
                if width_box > height_box:
                    new_color = (color + 1) % 10
                elif height_box > width_box:
                    new_color = (color - 1) % 10
                else:
                    new_color = color
                for cr, cc in component:
                    output_grid[cr][cc] = new_color
    return output_grid
