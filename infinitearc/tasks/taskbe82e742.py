# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: be82e742
Difficulty: hard

=== Tags ===
- Bring patterns close
- Detect hor lines

=== Description ===
The task involves transforming an input grid where certain rows consist entirely
of a single color (horizontal lines) into an output grid where all such
horizontal lines are gathered at the top of the grid, occupying consecutive rows
in the same order they appeared in the input. The remaining rows in the output
are filled with the background color, which is the most prevalent color in the
input grid's non-horizontal-line rows. This requires identifying all horizontal
lines (rows with uniform color), sorting them by their original row positions,
and repositioning them to the top while preserving their relative order. The
background color fills all other rows, creating a compressed arrangement where
horizontal patterns are brought into close proximity.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    h = random.randint(5, 20)
    w = random.randint(5, 20)
    k = random.randint(1, h-1)
    horizontal_rows = sorted(random.sample(range(h), k))
    input_grid = [[0] * w for _ in range(h)]
    for r in horizontal_rows:
        color = random.randint(1, 9)
        for c in range(w):
            input_grid[r][c] = color
    for r in range(h):
        if r not in horizontal_rows:
            row = [random.randint(1, 9) for _ in range(w)]
            while all(x == row[0] for x in row):
                row = [random.randint(1, 9) for _ in range(w)]
            input_grid[r] = row
    non_horizontal_elements = []
    for r in range(h):
        if r not in horizontal_rows:
            non_horizontal_elements.extend(input_grid[r])
    background = max(set(non_horizontal_elements), key=non_horizontal_elements.count) if non_horizontal_elements else 0
    output_grid = []
    for r in horizontal_rows:
        output_grid.append([input_grid[r][0]] * w)
    for _ in range(h - len(horizontal_rows)):
        output_grid.append([background] * w)
    if input_grid == output_grid:
        return generate()
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random

def p(input_grid):
    h = len(input_grid)
    w = len(input_grid[0])
    horizontal_rows = []
    for r in range(h):
        if all(x == input_grid[r][0] for x in input_grid[r]):
            horizontal_rows.append((r, input_grid[r][0]))
    horizontal_rows.sort(key=lambda x: x[0])
    horizontal_colors = [color for _, color in horizontal_rows]
    non_horizontal_elements = []
    for r in range(h):
        if not all(x == input_grid[r][0] for x in input_grid[r]):
            non_horizontal_elements.extend(input_grid[r])
    background = max(set(non_horizontal_elements), key=non_horizontal_elements.count) if non_horizontal_elements else 0
    output = []
    for color in horizontal_colors:
        output.append([color] * w)
    for _ in range(h - len(horizontal_rows)):
        output.append([background] * w)
    return output
