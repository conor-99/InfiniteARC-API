# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 8c7dad1b
Difficulty: very hard

=== Tags ===
- Obstacles
- Mirrored attribute binding
- Phase transition path
- Close line gaps
- Pairwise analogy

=== Description ===
Input grids feature a background with broken colored paths (each path is a
sequence of adjacent cells of a single color) and obstacle objects. Each
obstacle is a 2Ã—2 block with a distinct color on its left side and a different
color on its right side (e.g., left: red, right: blue). Paths are interrupted by
gaps between obstacles. The output grid closes gaps where the right color of the
left obstacle matches the left color of the right obstacle (mirrored attribute
binding), forming a continuous path. At each closed gap, the path undergoes a
phase transition, changing its color to match the right obstacle's left color
(e.g., path color shifts from red to blue when moving through the gap).
Unmatched gaps remain open. Obstacles, background, and all paths not involved in
gap closure remain unchanged. The transformation requires identifying pairwise
attribute matches between obstacles and applying the phase transition along the
path, with the solution demanding recursive analysis of color relationships
across multiple obstacle pairs in the grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

COUNTER = 0

def generate():
    global COUNTER
    COUNTER += 1

    # Grid size
    width = random.randint(8, 20)
    height = random.randint(5, 12)

    # Empty background
    grid = [[0 for _ in range(width)] for _ in range(height)]

    # Choose the two-row band where obstacles and the path live
    band_r = random.randint(1, height - 3)  # ensures band_r and band_r+1 are inside grid

    # Compute how many obstacles can fit (each obstacle uses 2 columns and requires at least 1 gap to the next)
    max_obstacles = ((width - 3) // 3) + 1
    max_obstacles = max(2, max_obstacles)
    max_obstacles = min(5, max_obstacles)
    num_obstacles = random.randint(2, max_obstacles)

    # Place obstacles from left to right with at least one-column gap between them
    cols = []
    next_min = random.randint(1, 2)
    for i in range(num_obstacles):
        remaining = num_obstacles - i - 1
        max_col = width - 2 - remaining * 3
        if next_min > max_col:
            next_min = max_col
        c = random.randint(next_min, max_col)
        cols.append(c)
        next_min = c + 3

    # Choose left colors for obstacles
    left_colors = [random.randint(1, 9) for _ in range(num_obstacles)]

    # Ensure at least one adjacent matching pair (right color of obstacle i == left color of obstacle i+1)
    possible_pairs = num_obstacles - 1
    kmatches = random.randint(1, min(2, possible_pairs))
    match_idxs = random.sample(range(possible_pairs), kmatches)

    # If a matched pair would produce left==right for the first obstacle, adjust the next left color
    for i in match_idxs:
        if left_colors[i + 1] == left_colors[i]:
            choices = [c for c in range(1, 10) if c != left_colors[i]]
            left_colors[i + 1] = random.choice(choices)

    # Choose right colors; enforce matches for the chosen indices
    right_colors = []
    for i in range(num_obstacles):
        if i in match_idxs:
            # right color equals the left color of the next obstacle
            rc = left_colors[i + 1]
            # ensure it isn't accidentally equal to the left color of this obstacle
            if rc == left_colors[i]:
                choices = [c for c in range(1, 10) if c != rc]
                left_colors[i] = random.choice(choices)
            right_colors.append(rc)
        else:
            rc = random.randint(1, 9)
            while rc == left_colors[i]:
                rc = random.randint(1, 9)
            right_colors.append(rc)

    # Paint obstacles (each is a 2x2 block: left column = left color, right column = right color)
    for c, lc, rc in zip(cols, left_colors, right_colors):
        grid[band_r][c] = lc
        grid[band_r + 1][c] = lc
        grid[band_r][c + 1] = rc
        grid[band_r + 1][c + 1] = rc

    # Paint broken path segments: left of the first obstacle and right of the last obstacle
    left_path_color = random.randint(1, 9)
    for col in range(0, cols[0]):
        grid[band_r][col] = left_path_color
        grid[band_r + 1][col] = left_path_color

    right_path_color = random.randint(1, 9)
    for col in range(cols[-1] + 2, width):
        grid[band_r][col] = right_path_color
        grid[band_r + 1][col] = right_path_color

    # Build output by closing gaps between adjacent obstacles when right_colors[i] == left_colors[i+1]
    output = [row[:] for row in grid]
    for i in range(len(cols) - 1):
        c1 = cols[i]
        c2 = cols[i + 1]
        if right_colors[i] == left_colors[i + 1]:
            start_gap = c1 + 2
            end_gap = c2 - 1
            if start_gap <= end_gap:
                fill = left_colors[i + 1]
                for col in range(start_gap, end_gap + 1):
                    output[band_r][col] = fill
                    output[band_r + 1][col] = fill

    # Add a small uniqueness marker outside the band so repeated runs produce unique pairs
    marker_color = (COUNTER % 9) + 1
    if band_r > 1:
        marker_r = 0
    else:
        marker_r = height - 1
    marker_c = width - 1
    grid[marker_r][marker_c] = marker_color
    output[marker_r][marker_c] = marker_color

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Detect 2x2 obstacles: a 2x2 with a uniform left column and a different uniform right column
    obstacles = []  # list of (r, c, left_color, right_color)
    for r in range(height - 1):
        for c in range(width - 1):
            left = grid[r][c]
            right = grid[r][c + 1]
            if left != 0 and right != 0 and left == grid[r + 1][c] and right == grid[r + 1][c + 1] and left != right:
                obstacles.append((r, c, left, right))

    # Group obstacles by their top row and sort by column
    obstacles.sort(key=lambda x: (x[0], x[1]))
    i = 0
    while i < len(obstacles):
        r0 = obstacles[i][0]
        group = []
        while i < len(obstacles) and obstacles[i][0] == r0:
            group.append(obstacles[i])
            i += 1

        # For each adjacent pair in this row, close gap if right_color of left obstacle == left_color of right obstacle
        for j in range(len(group) - 1):
            _, c1, left1, right1 = group[j]
            _, c2, left2, right2 = group[j + 1]
            if right1 == left2:
                start_gap = c1 + 2
                end_gap = c2 - 1
                if start_gap <= end_gap:
                    fill = left2
                    for col in range(start_gap, end_gap + 1):
                        grid[r0][col] = fill
                        grid[r0 + 1][col] = fill

    return tuple(tuple(row) for row in grid)

