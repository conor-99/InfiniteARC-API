# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 873474ba
Difficulty: hard

=== Tags ===
- Refraction simulation
- Gas expansion
- Swap positions of two objects
- Associate colors to shapes

=== Description ===
Input grids feature a background (color 0) and four distinct visual elements: a
gas cloud (color 3), a refraction medium (color 4), and two shape objects (color
1 representing circles, color 2 representing squares). The gas cloud originates
as a single cell and expands outward in all four cardinal directions to fill all
adjacent background cells, forming a contiguous gas region that stops at non-
background boundaries. The refraction medium (color 4) is a rectangular obstacle
that bends any path entering it 90 degrees to the left. The two objects (circle
and square) are positioned such that their direct line of sight intersects the
gas region. In the output grid, the gas region is fully expanded, the refraction
medium bends the path between the objects, and the objects swap positions: the
circle moves to the square's original location and the square moves to the
circle's original location, following the refracted path. All other grid
elements remain unchanged except for the swapped objects and expanded gas
region. The task requires associating color codes with specific shapes (color 1
= circle, color 2 = square) and applying sequential transformations involving
gas expansion, refraction simulation, and object swapping.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    grid = [[0] * width for _ in range(height)]
    
    # Place circle (1) and square (2)
    x1, y1 = random.randint(0, width-1), random.randint(0, height-1)
    x2, y2 = random.randint(0, width-1), random.randint(0, height-1)
    while (x1, y1) == (x2, y2):
        x2, y2 = random.randint(0, width-1), random.randint(0, height-1)
    
    # Place gas cell on line between them
    x_g = (x1 + x2) // 2
    y_g = (y1 + y2) // 2
    if (x_g, y_g) == (x1, y1) or (x_g, y_g) == (x2, y2):
        x_g = (x1 + x2 + 1) // 2
        y_g = (y1 + y2 + 1) // 2
    
    # Place gas cell (3)
    grid[y_g][x_g] = 3
    
    # Place refraction medium (4) as 2x2 rectangle
    dx = x2 - x1
    dy = y2 - y1
    step_x = 1 if dx > 0 else -1 if dx < 0 else 0
    step_y = 1 if dy > 0 else -1 if dy < 0 else 0
    rx, ry = x1 + step_x, y1 + step_y
    rx = max(0, min(rx, width-2))
    ry = max(0, min(ry, height-2))
    for r in range(ry, ry+2):
        for c in range(rx, rx+2):
            if grid[r][c] == 0:
                grid[r][c] = 4
    
    # Place circle and square
    grid[y1][x1] = 1
    grid[y2][x2] = 2
    
    input_grid = grid
    output_grid = [row[:] for row in grid]
    
    # Expand gas
    gas_pos = None
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 3:
                gas_pos = (r, c)
                break
        if gas_pos:
            break
    if gas_pos:
        queue = deque([gas_pos])
        visited = [[False] * width for _ in range(height)]
        visited[gas_pos[0]][gas_pos[1]] = True
        while queue:
            r, c = queue.popleft()
            for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == 0:
                    visited[nr][nc] = True
                    output_grid[nr][nc] = 3
                    queue.append((nr, nc))
    
    # Swap 1 and 2
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] == 1:
                output_grid[r][c] = 2
            elif output_grid[r][c] == 2:
                output_grid[r][c] = 1
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque
def p(input_grid):
    # Ensure input is list of lists (not tuple of tuples)
    if isinstance(input_grid[0], tuple):
        input_grid = [list(row) for row in input_grid]
    
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = [row[:] for row in input_grid]
    
    # Expand gas (color 3)
    gas_pos = None
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 3:
                gas_pos = (r, c)
                break
        if gas_pos:
            break
    if gas_pos:
        queue = deque([gas_pos])
        visited = [[False] * width for _ in range(height)]
        visited[gas_pos[0]][gas_pos[1]] = True
        while queue:
            r, c = queue.popleft()
            for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == 0:
                    visited[nr][nc] = True
                    output_grid[nr][nc] = 3
                    queue.append((nr, nc))
    
    # Swap 1 and 2
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] == 1:
                output_grid[r][c] = 2
            elif output_grid[r][c] == 2:
                output_grid[r][c] = 1
    
    return output_grid
