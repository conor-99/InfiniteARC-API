# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: ef3ecfec
Difficulty: medium–hard

=== Tags ===
- Draw line of sight
- Multi source interaction
- Rule composition
- Enlarge image

=== Description ===
Input grids are medium to large (15×15 to 30×30) with a single background color
(0). Overlaid on this background are distinct elements: **source cells** (color
1) positioned along the left edge (column 0), spaced vertically to avoid
adjacency; **obstacle blocks** (color 2) as horizontal or vertical segments
(length 2–5 cells) that never touch each other or sources; a **pattern strip**
in the top-left corner (rows 0–1, columns 0–3) composed of repeating 2×2 color
blocks defining a cyclic sequence (e.g., [3,4,5,3,4,5,...]); and a **target
indicator** (color 6) embedded within the grid, not on the edge.    In the
output grid, each source cell emits a horizontal line of sight to the right
(increasing column index), traversing background cells until blocked by an
obstacle (color 2). The line’s color cycles through the pattern strip’s sequence
(starting with the first color in the strip), with each cell in the line colored
sequentially. If multiple lines occupy the same cell (due to overlapping paths),
they merge into a single line continuing the sequence. The target indicator
(color 6) is overwritten by the line’s current color when intersected.
Obstacles, sources, and the pattern strip remain visually unchanged. Lines never
overwrite obstacles, sources, or other lines, and all paths terminate upon
hitting an obstacle or grid edge. The rule composition integrates
directionality, cyclic color propagation, and multi-source merging, while the
pattern strip provides the sequence for line coloring.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Grid size
    size = random.randint(15, 30)
    # Initialize background
    inp = [[0 for _ in range(size)] for _ in range(size)]

    # Pattern strip: make a sequence of 2x2 blocks in rows 0-1
    # Choose sequence length (number of 2x2 blocks)
    max_seq = max(2, min(6, size // 2 - 1))
    seq_len = random.randint(3, max_seq)
    # Choose a small base cycle to repeat across the seq_len
    base_len = random.randint(2, min(4, seq_len))
    palette = [3, 4, 5, 7, 8, 9]
    base_colors = random.sample(palette, base_len)
    pattern_colors = [base_colors[i % base_len] for i in range(seq_len)]
    pattern_width = seq_len * 2

    # Fill the 2x(pattern_width) pattern area at top-left
    for i, col_color in enumerate(pattern_colors):
        c0 = 2 * i
        inp[0][c0] = col_color
        inp[0][c0 + 1] = col_color
        inp[1][c0] = col_color
        inp[1][c0 + 1] = col_color

    # Place sources (color 1) in column 0, rows >= 2, not adjacent vertically
    candidate_rows = list(range(2, size))
    random.shuffle(candidate_rows)
    sources = []
    max_sources = min(5, max(2, (size - 2) // 2))
    n_sources = random.randint(2, max_sources)
    for r in candidate_rows:
        if len(sources) >= n_sources:
            break
        # avoid adjacency to existing sources
        if any(abs(r - sr) == 1 for sr in sources):
            continue
        # don't place a source in the top pattern rows
        if r < 2:
            continue
        sources.append(r)
        inp[r][0] = 1

    # Place obstacles (color 2): segments of length 2-5, horizontal or vertical
    obstacles = []  # list of lists of cells
    occupied = set()
    # mark pattern cells and sources as occupied so obstacles won't touch them
    for rr in [0, 1]:
        for cc in range(pattern_width):
            occupied.add((rr, cc))
    for r in sources:
        occupied.add((r, 0))
    # we will place obstacles with at least one-cell separation (Manhattan) from occupied
    n_obstacles = random.randint(3, 6)
    attempts = 0
    while len(obstacles) < n_obstacles and attempts < 1000:
        attempts += 1
        orient = random.choice(['h', 'v'])
        length = random.randint(2, 5)
        if orient == 'h':
            r = random.randint(2, size - 1)
            c = random.randint(1, size - length)
            cells = [(r, c + i) for i in range(length)]
        else:
            r = random.randint(2, size - length)
            c = random.randint(1, size - 1)
            cells = [(r + i, c) for i in range(length)]

        # Check cells are free and not adjacent (Manhattan) to occupied cells
        ok = True
        for (rr, cc) in cells:
            if rr < 0 or rr >= size or cc < 0 or cc >= size:
                ok = False
                break
            # cannot overlap existing non-background
            if inp[rr][cc] != 0:
                ok = False
                break
            # cannot be adjacent to any occupied cell (so obstacles don't touch sources/pattern/other obstacles)
            for dr, dc in [(0, 0), (1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = rr + dr, cc + dc
                if (nr, nc) in occupied:
                    ok = False
                    break
            if not ok:
                break
        if not ok:
            continue
        # commit obstacle
        for (rr, cc) in cells:
            inp[rr][cc] = 2
            occupied.add((rr, cc))
        obstacles.append(cells)

    # Ensure obstacles do not touch each other (we maintained occupied adjacency check above)

    # Place a single target indicator (color 6) somewhere not on the edge and not on non-zero cells
    interior_positions = [(r, c) for r in range(1, size - 1) for c in range(1, size - 1) if inp[r][c] == 0]
    if interior_positions:
        tr, tc = random.choice(interior_positions)
        inp[tr][tc] = 6
    else:
        # fallback: put target somewhere safe (shouldn't normally happen)
        for r in range(1, size - 1):
            placed = False
            for c in range(1, size - 1):
                if inp[r][c] == 0:
                    inp[r][c] = 6
                    tr, tc = r, c
                    placed = True
                    break
            if placed:
                break

    # Build output by drawing lines from each source to the right
    out = [row[:] for row in inp]
    for r in sources:
        seq_index = 0
        for c in range(1, size):
            # stop at obstacle
            if inp[r][c] == 2:
                break
            # never overwrite obstacles, sources, pattern, or other non-background/non-target
            if out[r][c] != 0 and out[r][c] != 6:
                break
            color = pattern_colors[seq_index % len(pattern_colors)]
            out[r][c] = color
            seq_index += 1

    # Guarantee input and output differ (they should because sources have at least one free cell to the right)
    # Return
    return {'input': inp, 'output': out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])
    out = [row[:] for row in grid]

    # Read pattern of 2x2 blocks starting at (0,0) across the top two rows
    pattern_colors = []
    c = 0
    while c + 1 < w:
        color = grid[0][c]
        # a valid block must be non-background and the 2x2 block must be uniform
        if color in (0, 1, 2, 6):
            break
        if grid[0][c + 1] != color or grid[1][c] != color or grid[1][c + 1] != color:
            break
        pattern_colors.append(color)
        c += 2

    # If for some reason no pattern was detected, try a minimal fallback from the first two blocks
    if not pattern_colors:
        # fallback: try to read at least two colors from (0,0) and (0,2)
        try:
            pattern_colors = [grid[0][0], grid[0][2]]
        except Exception:
            pattern_colors = [3, 4]

    # Find sources along left edge (column 0)
    sources = [r for r in range(h) if grid[r][0] == 1]

    # Draw lines for each source going right, following the cyclic pattern
    for r in sources:
        seq_index = 0
        for c in range(1, w):
            # stop if there's an obstacle in the input
            if grid[r][c] == 2:
                break
            # never overwrite obstacles, sources, pattern, or other non-background/non-target
            if out[r][c] != 0 and out[r][c] != 6:
                break
            color = pattern_colors[seq_index % len(pattern_colors)]
            out[r][c] = color
            seq_index += 1

    return out

