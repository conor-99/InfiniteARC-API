# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: a69af585
Difficulty: easy

=== Tags ===
- Pattern alignment
- Draw rectangle
- Measure distance from side
- Background filling

=== Description ===
The input grid contains exactly one non-zero pixel (the pattern) against a
uniform background (color 0), with all other cells being background. The output
grid draws a 3Ã—3 rectangle centered precisely at the pattern's position, using a
distinct color (e.g., color 2), while all other cells remain background (color
0). The rectangle's placement is determined by measuring the pattern's distance
from the grid's top and left sides, ensuring the rectangle is centered on the
pattern. This task requires recognizing the single pattern pixel, aligning the
rectangle to its position, and filling the background uniformly.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
def generate():
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    r = random.randint(1, height - 2)
    c = random.randint(1, width - 2)
    pattern_color = random.randint(1, 9)
    input_grid = [[0] * width for _ in range(height)]
    input_grid[r][c] = pattern_color
    output_grid = [[0] * width for _ in range(height)]
    for dr in (-1, 0, 1):
        for dc in (-1, 0, 1):
            nr, nc = r + dr, c + dc
            output_grid[nr][nc] = 2
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    h = len(input_grid)
    w = len(input_grid[0])
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] != 0:
                pattern_r, pattern_c = r, c
                break
        else:
            continue
        break
    output_grid = [[0] * w for _ in range(h)]
    for dr in (-1, 0, 1):
        for dc in (-1, 0, 1):
            nr = pattern_r + dr
            nc = pattern_c + dc
            if 0 <= nr < h and 0 <= nc < w:
                output_grid[nr][nc] = 2
    return output_grid
