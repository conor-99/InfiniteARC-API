# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 161fa524
Difficulty: mediumâ€“hard

=== Tags ===
- Color modulated motion
- Fluid spread
- Copy paste patch

=== Description ===
Input grids consist of a 2D array of colors (0-9), where color 0 represents
background. Non-background regions (colors 1-9) are connected components of
uniform color, each representing a distinct "fluid source." Each color has a
predefined spread direction: color 1 (red) spreads right, color 2 (green)
spreads down, color 3 (blue) spreads left, color 4 (yellow) spreads up, color 5
(pink) spreads diagonally down-right, color 6 (orange) spreads diagonally down-
left, color 7 (cyan) spreads diagonally up-right, color 8 (maroon) spreads
diagonally up-left, and color 9 (gray) spreads in all four cardinal directions
simultaneously.   The fluid spread begins from the outermost edge of each source
region in its designated direction, filling background cells (color 0) with the
source color until blocked by non-background cells or grid boundaries. Spreads
from different colors may overlap, but the filling order prioritizes the source
color with the numerically lowest value (e.g., color 1 fills before color 2).
After spreading, the longest continuous spread path (the most cells filled in a
single direction) is identified as the "fluid patch." This patch is copied to a
location mirrored across the grid's horizontal and vertical axes (e.g., a cell
at (r,c) in the original patch is placed at (height-1-r, width-1-c) in the
copy). Each color in the copied patch is modulated by incrementing it by 1
(color 9 wraps to 1), resulting in a color-shifted replica pasted into the grid.
The output grid retains all original regions, the filled spread paths, and the
modulated copy of the fluid patch.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque

# Keep a record of generated signatures so repeated calls to generate() produce unique examples
_seen_signatures = set()


def get_direction(color):
    """Return the primary direction vector for a color. Color 9 is handled specially.

    Directions (dr, dc):
      1 -> right (0, +1)
      2 -> down (+1, 0)
      3 -> left (0, -1)
      4 -> up (-1, 0)
      5 -> down-right (+1, +1)
      6 -> down-left (+1, -1)
      7 -> up-right (-1, +1)
      8 -> up-left (-1, -1)
      9 -> None (handled as four cardinal directions)
    """
    if color == 1:
        return (0, 1)
    if color == 2:
        return (1, 0)
    if color == 3:
        return (0, -1)
    if color == 4:
        return (-1, 0)
    if color == 5:
        return (1, 1)
    if color == 6:
        return (1, -1)
    if color == 7:
        return (-1, 1)
    if color == 8:
        return (-1, -1)
    return None


def find_components(grid):
    """Find connected (4-neighbor) components of each non-zero color.

    Returns a dict color -> list of components, each component is a list of (r,c).
    The scan order is row-major which makes behavior deterministic.
    """
    h = len(grid)
    w = len(grid[0])
    visited = [[False] * w for _ in range(h)]
    comps = {c: [] for c in range(1, 10)}
    for r in range(h):
        for c in range(w):
            color = grid[r][c]
            if color == 0 or visited[r][c]:
                continue
            # BFS to collect the component
            queue = deque()
            queue.append((r, c))
            visited[r][c] = True
            comp = [(r, c)]
            while queue:
                cr, cc = queue.popleft()
                for dr, dc in ((0, 1), (1, 0), (0, -1), (-1, 0)):
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] == color:
                        visited[nr][nc] = True
                        queue.append((nr, nc))
                        comp.append((nr, nc))
            comps[color].append(comp)
    return comps


def _simulate_spread(initial_grid):
    """Simulate the ordered spreading process.

    Returns a tuple (spreads_grid, paths) where spreads_grid is the grid after all
    color spreads (but before the mirrored, modulated copy) and paths is a list of
    path records: each record is a dict with keys 'color','start','dir_idx','cells'.
    """
    h = len(initial_grid)
    w = len(initial_grid[0])
    working = [row[:] for row in initial_grid]
    comps_by_color = find_components(initial_grid)
    paths = []

    # Fixed direction order for color 9 so the behavior is deterministic.
    cardinal_dirs = [(1, 0), (0, 1), (-1, 0), (0, -1)]  # down, right, up, left

    for color in range(1, 10):
        primary = get_direction(color)
        if color == 9:
            directions = cardinal_dirs
        else:
            directions = [primary]

        for comp in comps_by_color[color]:
            # We use the initial_grid to decide which component-edge cells are "outermost"
            # in the direction of flow: a cell is an outer edge for (dr,dc) if the neighbor
            # at (r+dr,c+dc) is inside the grid and is background (0) in the initial grid.
            for dir_idx, (dr, dc) in enumerate(directions):
                boundary_cells = []
                for (r, c) in comp:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < h and 0 <= nc < w and initial_grid[nr][nc] == 0:
                        boundary_cells.append((r, c))
                # deterministic ordering of boundary starts
                boundary_cells.sort()
                for (r0, c0) in boundary_cells:
                    nr, nc = r0 + dr, c0 + dc
                    # If already occupied by previous spreads, this particular start won't fill
                    if not (0 <= nr < h and 0 <= nc < w):
                        continue
                    if working[nr][nc] != 0:
                        continue
                    filled = []
                    while 0 <= nr < h and 0 <= nc < w and working[nr][nc] == 0:
                        working[nr][nc] = color
                        filled.append((nr, nc))
                        nr += dr
                        nc += dc
                    if filled:
                        paths.append({
                            'color': color,
                            'start': filled[0],
                            'dir_idx': dir_idx,
                            'cells': filled
                        })
    return working, paths


def generate():
    """Generate a unique input/output pair following the task description."""
    # Try repeatedly until we create a valid, non-trivial (input != output) unique example.
    attempts = 0
    while True:
        attempts += 1
        # Grid sizes chosen to be moderate so that spreads can happen but generation is fast.
        height = random.randint(6, 18)
        width = random.randint(6, 18)
        grid = [[0 for _ in range(width)] for _ in range(height)]

        # Choose a random subset of colors to create as source regions (2..6 different colors)
        available_colors = list(range(1, 10))
        k = random.randint(2, 6)
        colors = random.sample(available_colors, k)

        # Place one connected component per chosen color. The component size varies.
        for color in colors:
            size = random.randint(1, 6)
            # Choose a random starting cell that is free.
            tries = 0
            placed = False
            while tries < 200 and not placed:
                tries += 1
                sr = random.randrange(height)
                sc = random.randrange(width)
                if grid[sr][sc] != 0:
                    continue
                comp = [(sr, sc)]
                # Grow the component randomly (4-neighbor connectivity)
                for _ in range(1, size):
                    # collect candidate neighbors of current component
                    candidates = []
                    for (pr, pc) in comp:
                        for dr, dc in ((0, 1), (1, 0), (0, -1), (-1, 0)):
                            nr, nc = pr + dr, pc + dc
                            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0 and (nr, nc) not in comp:
                                candidates.append((nr, nc))
                    if not candidates:
                        break
                    comp.append(random.choice(candidates))
                # commit component to grid
                for (r, c) in comp:
                    grid[r][c] = color
                placed = True

        # Ensure there is at least one non-background cell
        nonzero = any(grid[r][c] != 0 for r in range(height) for c in range(width))
        if not nonzero:
            if attempts > 200:
                # fallback: create a single pixel source
                grid[height // 2][width // 2] = random.choice(range(1, 10))
            else:
                continue

        # Simulate the spreads (on a copy) and collect paths
        spreads_grid, paths = _simulate_spread(grid)

        # If no path filled any cell, start over to ensure output differs from input
        if not paths:
            if attempts > 200:
                # If we repeatedly fail, force a small source not on the edge to guarantee a spread
                # place a single-color cell not on an edge
                rmid, cmid = height // 2, width // 2
                grid[rmid][cmid] = random.choice(range(1, 10))
                spreads_grid, paths = _simulate_spread(grid)
                if not paths:
                    # As a last resort, continue looping
                    continue
            else:
                continue

        # Choose the longest continuous path with deterministic tie-breaking
        paths_sorted = sorted(paths, key=lambda p: (-len(p['cells']), p['color'], p['start'][0], p['start'][1], p['dir_idx']))
        chosen = paths_sorted[0]

        # Build the final output by copying the spread grid and pasting the mirrored, modulated patch
        output = [row[:] for row in spreads_grid]
        mod_color = (chosen['color'] % 9) + 1
        for (r, c) in chosen['cells']:
            mr = height - 1 - r
            mc = width - 1 - c
            output[mr][mc] = mod_color

        # Input should be the original grid (only sources), output is after spreads+paste
        input_grid = [row[:] for row in grid]

        # Ensure input != output
        if input_grid == output:
            # extremely unlikely, try again
            if attempts > 500:
                # force a change by toggling a mirrored cell
                r, c = chosen['cells'][0]
                mr, mc = height - 1 - r, width - 1 - c
                output[mr][mc] = ((output[mr][mc] % 9) + 1)
            else:
                continue

        # Ensure uniqueness across generate() calls in this process
        signature = (tuple(tuple(row) for row in input_grid), tuple(tuple(row) for row in output))
        if signature in _seen_signatures:
            # already produced; try again
            if attempts > 1000:
                # give up uniqueness requirement after many attempts (shouldn't happen)
                break
            continue
        _seen_signatures.add(signature)

        return {"input": input_grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(inp):
    """Solver function that implements the described spreading and patch-copying rules.

    Args:
      inp: a Tuple[Tuple[int]] representing the input grid.

    Returns:
      A List[List[int]] representing the output grid after spreads and the mirrored modulated patch.
    """
    from collections import deque

    # Convert to mutable grid
    initial = [list(row) for row in inp]
    h = len(initial)
    w = len(initial[0]) if h > 0 else 0

    def get_direction(color):
        if color == 1:
            return (0, 1)
        if color == 2:
            return (1, 0)
        if color == 3:
            return (0, -1)
        if color == 4:
            return (-1, 0)
        if color == 5:
            return (1, 1)
        if color == 6:
            return (1, -1)
        if color == 7:
            return (-1, 1)
        if color == 8:
            return (-1, -1)
        return None

    def find_components(grid):
        visited = [[False] * w for _ in range(h)]
        comps = {c: [] for c in range(1, 10)}
        for r in range(h):
            for c in range(w):
                color = grid[r][c]
                if color == 0 or visited[r][c]:
                    continue
                queue = deque()
                queue.append((r, c))
                visited[r][c] = True
                comp = [(r, c)]
                while queue:
                    cr, cc = queue.popleft()
                    for dr, dc in ((0, 1), (1, 0), (0, -1), (-1, 0)):
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                            comp.append((nr, nc))
                comps[color].append(comp)
        return comps

    def simulate_spread(initial_grid):
        working = [row[:] for row in initial_grid]
        comps_by_color = find_components(initial_grid)
        paths = []
        cardinal_dirs = [(1, 0), (0, 1), (-1, 0), (0, -1)]

        for color in range(1, 10):
            primary = get_direction(color)
            if color == 9:
                directions = cardinal_dirs
            else:
                directions = [primary]

            for comp in comps_by_color[color]:
                for dir_idx, (dr, dc) in enumerate(directions):
                    boundary_cells = []
                    for (r, c) in comp:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < h and 0 <= nc < w and initial_grid[nr][nc] == 0:
                            boundary_cells.append((r, c))
                    boundary_cells.sort()
                    for (r0, c0) in boundary_cells:
                        nr, nc = r0 + dr, c0 + dc
                        if not (0 <= nr < h and 0 <= nc < w):
                            continue
                        if working[nr][nc] != 0:
                            continue
                        filled = []
                        while 0 <= nr < h and 0 <= nc < w and working[nr][nc] == 0:
                            working[nr][nc] = color
                            filled.append((nr, nc))
                            nr += dr
                            nc += dc
                        if filled:
                            paths.append({
                                'color': color,
                                'start': filled[0],
                                'dir_idx': dir_idx,
                                'cells': filled
                            })
        return working, paths

    spreads_grid, paths = simulate_spread(initial)

    if not paths:
        # Nothing spread; return grid as-is (generator avoids these cases but solver is robust)
        return spreads_grid

    # Choose the longest path with the same tie-breaking as the generator
    paths_sorted = sorted(paths, key=lambda p: (-len(p['cells']), p['color'], p['start'][0], p['start'][1], p['dir_idx']))
    chosen = paths_sorted[0]

    # Paste mirrored, modulated patch
    output = [row[:] for row in spreads_grid]
    mod_color = (chosen['color'] % 9) + 1
    for (r, c) in chosen['cells']:
        mr = h - 1 - r
        mc = w - 1 - c
        output[mr][mc] = mod_color

    return output

