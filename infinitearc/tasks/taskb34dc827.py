# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: b34dc827
Difficulty: very hard

=== Tags ===
- Pattern analogy
- Laser diffusion
- Echo trail
- Reconstruct checkerboard from hint
- Threshold by area

=== Description ===
**Task Description: Laser Diffusion Echoes and Checkerboard Reconstruction**
Input grids feature a complex, multi-reflection laser system within a background
of a single color. A single L-shaped laser (three connected cells) originates
from a background cell at its tip, emitting a diagonal beam that travels at 45°
until it encounters a wall. Walls are solid, single-color (1–9) vertical or
horizontal lines (1–3 cells thick) that never touch other walls or the laser.
Upon hitting a wall, the beam reflects with perfect mirror symmetry, changes
color to match the wall, and leaves a continuous echo trail in the background.
Each segment of the trail (between reflections) maintains the wall color it
encountered. The echo trails form a dense, non-intersecting network of
horizontal and vertical line segments across the grid.  The output grid
reconstructs a checkerboard pattern using the echo trails as structural hints.
First, the longest contiguous horizontal and vertical echo segments (with length
≥ 5 cells) are identified as grid lines—shorter segments are discarded
(threshold by area). These lines divide the grid into regions. The checkerboard
alternates between two distinct colors (e.g., 2 and 3), starting with color 2 in
the top-left region. Regions smaller than the threshold (area < 25 cells) are
merged into adjacent regions before applying the checkerboard pattern. The
laser, walls, and all non-threshold echo segments remain unchanged in the
output. No background cells are overwritten except for the reconstructed
checkerboard pattern. The task requires identifying the structural hints in the
echo network, applying the area threshold, and synthesizing the checkerboard
from the resulting grid lines.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, grid_enhance, grid_intersect, random_pixels, grid, grid_enhance, grid_intersect, random_color

def generate():
    width = random.randint(15, 25)
    height = random.randint(15, 25)
    bg = 0
    grid = [[bg] * width for _ in range(height)]
    
    # Place walls
    walls = []
    for _ in range(random.randint(3, 5)):
        if random.choice([True, False]):
            # horizontal
            row = random.randint(0, height-1)
            start_col = random.randint(0, width-3)
            length = random.randint(1, 3)
            color = random_color(exclude=[bg])
            for c in range(start_col, start_col + length):
                grid[row][c] = color
            walls.append(('h', row, start_col, start_col + length - 1, color))
        else:
            # vertical
            col = random.randint(0, width-1)
            start_row = random.randint(0, height-3)
            length = random.randint(1, 3)
            color = random_color(exclude=[bg])
            for r in range(start_row, start_row + length):
                grid[r][col] = color
            walls.append(('v', col, start_row, start_row + length - 1, color))
    
    # Place laser (L-shape)
    laser_color = random_color(exclude=[bg] + [w[4] for w in walls])
    r, c = random.randint(1, height-2), random.randint(1, width-2)
    grid[r][c] = laser_color
    grid[r][c+1] = laser_color
    grid[r+1][c] = laser_color
    origin = (r+1, c+1)  # background cell
    
    # Simulate beam path
    directions = [(1, 1), (-1, 1), (1, -1), (-1, -1)]
    start_dir = directions[random.randint(0, 3)]
    curr = origin
    curr_dir = start_dir
    curr_color = bg
    
    while True:
        next_r, next_c = curr[0] + curr_dir[0], curr[1] + curr_dir[1]
        if not (0 <= next_r < height and 0 <= next_c < width):
            break
        
        if grid[next_r][next_c] != bg:
            # Hit wall
            curr_color = grid[next_r][next_c]
            # Draw trail from curr to next
            dr, dc = curr_dir
            step_r, step_c = curr[0], curr[1]
            while (step_r, step_c) != (next_r, next_c):
                grid[step_r][step_c] = curr_color
                step_r += dr
                step_c += dc
            
            # Reflect direction
            if curr_dir[0] != 0:  # horizontal wall
                curr_dir = (curr_dir[0], -curr_dir[1])
            else:  # vertical wall
                curr_dir = (-curr_dir[0], curr_dir[1])
            curr = (next_r, next_c)
            continue
        
        # Move to next cell
        grid[next_r][next_c] = curr_color if curr_color != bg else grid[next_r][next_c]
        curr = (next_r, next_c)
    
    # Generate output grid
    output = [row[:] for row in grid]
    
    # Identify grid lines (longest horizontal/vertical segments ≥5)
    horizontal_lines = set()
    vertical_lines = set()
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] == bg:
                continue
            
            # Check horizontal
            if c + 4 < width and all(grid[r][c + i] == grid[r][c] for i in range(5)):
                horizontal_lines.add(r)
            
            # Check vertical
            if r + 4 < height and all(grid[r + i][c] == grid[r][c] for i in range(5)):
                vertical_lines.add(c)
    
    # Create regions
    rows = sorted(horizontal_lines)
    cols = sorted(vertical_lines)
    
    # Merge small regions
    regions = []
    for r1, r2 in zip([0] + rows, rows + [height]):
        for c1, c2 in zip([0] + cols, cols + [width]):
            region = (r1, r2, c1, c2)
            area = (r2 - r1) * (c2 - c1)
            if area >= 25:
                regions.append(region)
            
    # Apply checkerboard
    for r in range(height):
        for c in range(width):
            if grid[r][c] == bg:
                # Find region
                region_idx = next((i for i, (r1, r2, c1, c2) in enumerate(regions) if r1 <= r < r2 and c1 <= c < c2), 0)
                # Checkerboard pattern
                if (region_idx % 2 == 0):
                    output[r][c] = 2
                else:
                    output[r][c] = 3
    
    return {'input': grid, 'output': output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    bg = 0
    
    # Identify grid lines (longest horizontal/vertical segments ≥5)
    horizontal_lines = set()
    vertical_lines = set()
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == bg:
                continue
            
            # Check horizontal
            if c + 4 < width and all(input_grid[r][c + i] == input_grid[r][c] for i in range(5)):
                horizontal_lines.add(r)
            
            # Check vertical
            if r + 4 < height and all(input_grid[r + i][c] == input_grid[r][c] for i in range(5)):
                vertical_lines.add(c)
    
    # Create regions
    rows = sorted(horizontal_lines)
    cols = sorted(vertical_lines)
    
    # Merge small regions
    regions = []
    for r1, r2 in zip([0] + rows, rows + [height]):
        for c1, c2 in zip([0] + cols, cols + [width]):
            area = (r2 - r1) * (c2 - c1)
            if area >= 25:
                regions.append((r1, r2, c1, c2))
    
    # Apply checkerboard
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == bg:
                # Find region
                for i, (r1, r2, c1, c2) in enumerate(regions):
                    if r1 <= r < r2 and c1 <= c < c2:
                        if i % 2 == 0:
                            input_grid[r][c] = 2
                        else:
                            input_grid[r][c] = 3
                        break
    
    return input_grid
