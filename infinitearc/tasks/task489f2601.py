# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 489f2601
Difficulty: hard

=== Tags ===
- Pattern bounce
- Boundary tracing

=== Description ===
Input grids contain a background color (0) and a single "tracer" cell (color 1)
positioned at a location, moving in a diagonal direction (e.g., northeast,
southeast, etc.). The tracer moves one cell per step in its current direction
until it hits a grid boundary (top, bottom, left, or right), at which point it
bounces with perfect reflection (mirroring the direction relative to the
boundary normal). This process continues for exactly four bounces, resulting in
a closed polygonal path. The output grid replaces all cells traversed by the
tracer during its path with a new color (e.g., 2), forming a continuous, closed-
loop boundary trace. The path forms a diamond-shaped polygon for diagonal
movement (e.g., northeast → northwest → southwest → southeast → northeast), and
the output shows this boundary as a filled outline. For hard difficulty, the
initial position and direction are chosen such that the path forms a non-axis-
aligned diamond, and the background contains no additional visual cues to
distinguish the path from other elements. The solver must infer the bounce
rules, trace the path geometry, and replicate the boundary outline without
overlapping or extending beyond the path.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    r = random.randint(1, height-2)
    c = random.randint(1, width-2)
    directions = [(-1, 1), (-1, -1), (1, 1), (1, -1)]
    for dr, dc in directions:
        path = []
        cr, cc = r, c
        path.append((cr, cc))
        bounce_count = 0
        while bounce_count < 4:
            nr = cr + dr
            nc = cc + dc
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                if nr < 0 or nr >= height:
                    dr = -dr
                if nc < 0 or nc >= width:
                    dc = -dc
                bounce_count += 1
                nr = cr + dr
                nc = cc + dc
            path.append((nr, nc))
            cr, cc = nr, nc
        if path[-1] == (r, c):
            break
    else:
        dr, dc = directions[0]
        path = []
        cr, cc = r, c
        path.append((cr, cc))
        bounce_count = 0
        while bounce_count < 4:
            nr = cr + dr
            nc = cc + dc
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                if nr < 0 or nr >= height:
                    dr = -dr
                if nc < 0 or nc >= width:
                    dc = -dc
                bounce_count += 1
                nr = cr + dr
                nc = cc + dc
            path.append((nr, nc))
            cr, cc = nr, nc
    input_grid = grid(width, height, 0)
    input_grid[r][c] = 1
    output_grid = grid(width, height, 0)
    for (r, c) in path:
        output_grid[r][c] = 2
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    height = len(input_list)
    width = len(input_list[0])
    start = None
    for r in range(height):
        for c in range(width):
            if input_list[r][c] == 1:
                start = (r, c)
                break
        if start:
            break
    if not start:
        return input_grid
    r, c = start
    directions = [(-1, 1), (-1, -1), (1, 1), (1, -1)]
    valid_path = None
    for dr, dc in directions:
        cr, cc = r, c
        path = [(cr, cc)]
        bounce_count = 0
        while bounce_count < 4:
            nr = cr + dr
            nc = cc + dc
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                if nr < 0 or nr >= height:
                    dr = -dr
                if nc < 0 or nc >= width:
                    dc = -dc
                bounce_count += 1
                nr = cr + dr
                nc = cc + dc
            path.append((nr, nc))
            cr, cc = nr, nc
        if path[-1] == start:
            valid_path = path
            break
    if valid_path is None:
        dr, dc = directions[0]
        cr, cc = r, c
        path = [(cr, cc)]
        bounce_count = 0
        while bounce_count < 4:
            nr = cr + dr
            nc = cc + dc
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                if nr < 0 or nr >= height:
                    dr = -dr
                if nc < 0 or nc >= width:
                    dc = -dc
                bounce_count += 1
                nr = cr + dr
                nc = cc + dc
            path.append((nr, nc))
            cr, cc = nr, nc
        valid_path = path
    output_grid = grid(width, height, 0)
    for (r, c) in valid_path:
        output_grid[r][c] = 2
    return output_grid
