# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 6f30b7ee
Difficulty: very hard

=== Tags ===
- Coordinate system translation
- Trace perimeter
- Snap to grid

=== Description ===
Input grids feature a complex arrangement of colored shapes (each a connected
region of a single color) overlaid with a reference coordinate system defined by
two perpendicular lines of distinct colors (e.g., red for x-axis, blue for
y-axis). These axis lines are intentionally rotated, shifted, or scaled relative
to the grid’s default orientation, creating a non-standard coordinate framework.
The shapes are positioned such that their perimeters contain diagonal segments
when viewed in the original coordinate system.  The output grid requires three
sequential transformations: 1. **Coordinate System Translation**: Rotate the
entire grid to align the reference axis lines (red and blue) with the grid’s
natural horizontal and vertical axes (e.g., red line becomes perfectly
horizontal, blue line perfectly vertical). 2. **Perimeter Tracing**: For each
shape, identify its outer boundary (perimeter) as the set of cells adjacent to
background or other colors, ignoring interior cells. 3. **Grid Snapping**:
Adjust the traced perimeter to follow only horizontal or vertical grid lines,
replacing diagonal segments with right-angled paths (e.g., a diagonal edge
between two cells is converted into two orthogonal segments moving along the
grid).  The result is an output grid where all perimeters are cleanly outlined
with a new color, perfectly aligned to the grid, and the reference coordinate
system is no longer visible. This task demands precise geometric reasoning,
multi-step transformation, and careful handling of complex shape boundaries—all
while maintaining consistency across varying grid sizes (up to 30×30) and
numerous overlapping shapes.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    size = random.randint(5, 30)
    grid = common.grid(size, size, 0)
    
    # Red axis (slope 1)
    for i in range(size):
        grid[i][i] = 2
    
    # Blue axis (slope -1)
    for i in range(size):
        grid[i][size - 1 - i] = 3
    
    # Place diamond shapes
    colors = [1, 4, 5, 6, 7, 8, 9]
    for color in colors:
        center_r = random.randint(2, size - 3)
        center_c = random.randint(2, size - 3)
        radius = random.randint(1, 3)
        for r in range(size):
            for c in range(size):
                if abs(r - center_r) + abs(c - center_c) <= radius:
                    if grid[r][c] == 0:
                        grid[r][c] = color
    
    output_grid = [row[:] for row in grid]
    for r in range(size):
        for c in range(size):
            if output_grid[r][c] in [2, 3]:
                output_grid[r][c] = 0
    
    for r in range(size):
        for c in range(size):
            if grid[r][c] != 0 and grid[r][c] != 2 and grid[r][c] != 3:
                on_perimeter = False
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < size and 0 <= nc < size and grid[nr][nc] == 0:
                        on_perimeter = True
                        break
                if on_perimeter:
                    output_grid[r][c] = 9
    
    return {
        "input": grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    else:
        input_grid = [list(row) for row in input_grid]
    size = len(input_grid)
    output_grid = [row[:] for row in input_grid]
    
    # Mark perimeter cells based on original input grid
    for r in range(size):
        for c in range(size):
            if input_grid[r][c] not in [0, 2, 3]:
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < size and 0 <= nc < size and input_grid[nr][nc] == 0:
                        output_grid[r][c] = 9
                        break
    
    # Remove axis lines
    for r in range(size):
        for c in range(size):
            if output_grid[r][c] in [2, 3]:
                output_grid[r][c] = 0
    
    return output_grid
