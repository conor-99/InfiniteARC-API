# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: dc4ca6e7
Difficulty: medium–hard

=== Tags ===
- Circuit reflection
- Oscillating rule
- Alternating direction
- Staircase construction
- One yes one no
- Lattice completion

=== Description ===
Input grids display a continuous staircase path formed by color A cells,
starting from the bottom-left corner and moving right, up, right, up in a
repeating pattern. The path includes alternating marker cells of color B at
every other position, creating a strict "one yes (marker present) one no (marker
absent)" sequence along the path. When encountering a "yes" marker (color B),
the path direction changes 90 degrees clockwise (e.g., right → up, up → left);
when encountering a "no" marker (absence of color B), the path continues
straight without changing direction. The input path terminates at a point where
the next step requires applying this oscillating rule. The output grid completes
the staircase by extending the path using the marker-based rule: each "yes"
marker triggers a clockwise direction change, while "no" markers maintain the
current direction. The completed staircase forms a continuous, non-overlapping
lattice structure that fills the grid's lower-left quadrant without gaps, with
all direction changes visually consistent and alternating in a pattern that
creates a larger staircase with oscillating turns. The background (color C)
remains unchanged, and the marker pattern (color B) is preserved at all "yes"
positions in the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Keep a global counter so successive calls to generate() are different and thus
# more likely to be unique across many calls (the validator calls generate many
# times in the same process). This keeps the generator deterministic but varied
# across calls.
CALL_ID = 0


def _pick_three_colors(k):
    # Choose three distinct colors from 1..9 in a deterministic but varied way
    colors = list(range(1, 10))
    A = colors[k % len(colors)]
    remaining = [c for c in colors if c != A]
    B = remaining[(k // len(colors)) % len(remaining)]
    remaining2 = [c for c in colors if c not in (A, B)]
    C = remaining2[(k // len(colors) // len(remaining)) % len(remaining2)]
    return A, B, C


def generate():
    """
    Generate an input/output pair following the rule implemented in the solver:
    - A single connected orthogonal path starts at the bottom-left cell (r=H-1,c=0).
    - The path cells alternate colors A (base) and B (marker): indices 0,2,4... are A; 1,3,5... are B.
    - Starting direction is right. After stepping onto a B cell the moving direction
      is rotated 90 degrees counter-clockwise (right -> up -> left -> down -> right ...).
    - The generator creates a full path until it can no longer extend (out of bounds or would overlap).
    - The input grid contains a prefix of that path (at least 2 cells so there is a B visible),
      and the output grid contains the full path.
    """
    global CALL_ID
    k = CALL_ID
    CALL_ID += 1

    # Choose dimensions deterministically from CALL_ID but keep them smallish and valid
    width = 6 + (k % 15)   # widths in 6..20
    height = 6 + ((k // 15) % 15)  # heights in 6..20

    A, B, C = _pick_three_colors(k)

    # Create empty grids filled with background color C
    out = grid(width, height, C)
    inp = grid(width, height, C)

    # Start at bottom-left
    r, c = height - 1, 0
    out[r][c] = A
    positions = [(r, c)]

    # Directions: right, up, left, down. Rotation on B is counter-clockwise -> index +1
    directions = [(0, 1), (-1, 0), (0, -1), (1, 0)]
    current_dir = 0

    max_steps = width * height  # safe upper bound
    for step in range(1, max_steps):
        dr, dc = directions[current_dir]
        nr, nc = r + dr, c + dc
        # Stop if next move would go outside or collide
        if not (0 <= nr < height and 0 <= nc < width):
            break
        if out[nr][nc] != C:
            break
        color = B if (step % 2 == 1) else A
        out[nr][nc] = color
        positions.append((nr, nc))
        r, c = nr, nc
        if color == B:
            current_dir = (current_dir + 1) % 4

    full_len = len(positions)

    # If the generated path is too short, try a short fallback deterministic construction
    if full_len < 4:
        out = grid(width, height, C)
        r, c = height - 1, 0
        out[r][c] = A
        positions = [(r, c)]
        current_dir = 0
        for step in range(1, max(6, width + height)):
            dr, dc = directions[current_dir]
            nr, nc = r + dr, c + dc
            if not (0 <= nr < height and 0 <= nc < width):
                break
            if out[nr][nc] != C:
                break
            color = B if (step % 2 == 1) else A
            out[nr][nc] = color
            positions.append((nr, nc))
            r, c = nr, nc
            if color == B:
                current_dir = (current_dir + 1) % 4
        full_len = len(positions)

    # Choose a truncation length for the input prefix. Ensure at least one B is present
    # (B is at index 1 in the alternating pattern) so require t >= 2.
    if full_len <= 2:
        # extremely small path: keep at least one cell in input and one extra in output
        t = max(1, full_len - 1)
    else:
        # pick t between 2 and full_len-1 (inclusive) using k to vary deterministically
        t = 2 + (k % max(1, (full_len - 2)))
        if t >= full_len:
            t = full_len - 1

    # Fill the input with the prefix of the path
    for i, (pr, pc) in enumerate(positions[:t]):
        color = B if (i % 2 == 1) else A
        inp[pr][pc] = color

    return {"input": inp, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import Counter

def p(input_grid):
    # Convert input tuple-of-tuples to a mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Identify the background color as the most common color
    all_colors = [cell for row in grid for cell in row]
    color_count = Counter(all_colors)
    background = color_count.most_common(1)[0][0]

    # The starting cell is bottom-left
    start_r, start_c = height - 1, 0
    start_color = grid[start_r][start_c]

    # Identify marker color B as any color present that is not the background and not the start_color
    B = None
    for color in color_count.keys():
        if color != background and color != start_color:
            B = color
            break
    # If not present in the truncated input (shouldn't happen with our generator), choose any
    # permissible color to place markers with (solver needs to pick some color).
    if B is None:
        for c in range(1, 10):
            if c != background and c != start_color:
                B = c
                break

    # Movement rules: right, up, left, down; stepping onto B rotates counter-clockwise (index + 1)
    directions = [(0, 1), (-1, 0), (0, -1), (1, 0)]
    current_dir = 0

    # Walk the existing (possibly truncated) path to find the last occupied cell
    r, c = start_r, start_c
    visited = {(r, c)}
    path_length = 1

    while True:
        dr, dc = directions[current_dir]
        nr, nc = r + dr, c + dc
        if not (0 <= nr < height and 0 <= nc < width):
            break
        if (nr, nc) in visited:
            break
        val = grid[nr][nc]
        if val == start_color or val == B:
            # extend along existing path in input
            visited.add((nr, nc))
            r, c = nr, nc
            path_length += 1
            if val == B:
                current_dir = (current_dir + 1) % 4
            continue
        else:
            break

    # Now extend the path using the same oscillating rule until we cannot (out of bounds or collision)
    next_index = path_length  # the index (0-based) of the next cell along the path
    while True:
        dr, dc = directions[current_dir]
        nr, nc = r + dr, c + dc
        if not (0 <= nr < height and 0 <= nc < width):
            break
        if grid[nr][nc] != background:
            break
        next_color = B if (next_index % 2 == 1) else start_color
        grid[nr][nc] = next_color
        r, c = nr, nc
        next_index += 1
        if next_color == B:
            current_dir = (current_dir + 1) % 4

    return grid

