# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: cd16438c
Difficulty: very hard

=== Tags ===
- Directed field
- Connect equal color components
- Draw diagonal line

=== Description ===
# Task Description: Directed Component Connectors  Input grids are 10×10 to
30×30 in size, with background color 0. Non-zero colors (1-9) represent distinct
regions, each region being a connected component (4-connected) of the same
color. The grid contains multiple regions for several colors, with some colors
having multiple disconnected components.  The transformation requires two main
operations applied in sequence:  1. **Component Identification and Direction
Mapping**: For each color c (1-4), identify all connected components. The
direction for connecting components of color c is determined by the color value
itself: color 1 requires northeast (top-right) connections, color 2 requires
northwest (top-left), color 3 requires southeast (bottom-right), and color 4
requires southwest (bottom-left). Components of colors 5-9 are not connected.
2. **Directed Connection Drawing**: For each color c (1-4) with multiple
components:    - Sort components based on their spatial relationship to the
connection direction (e.g., for northeast connections, sort components by
ascending row and column to find the southwestmost component first).    -
Connect consecutive components in the sorted list using a straight diagonal line
in the specified direction. The line must follow the direction vector (e.g.,
northeast = moving up-right), occupying only background cells (0) and using a
consistent line color (e.g., color 5).    - Lines must not overlap with any
existing regions (non-zero cells) or other lines. If a direct diagonal path
would intersect another region, the line must follow the direction while
avoiding obstacles by taking the shortest possible route along the direction
vector.  Output grids retain all original regions and add diagonal connecting
lines for colors 1-4 with multiple components. The lines are drawn as continuous
diagonal segments (two cells at 45° angles) between components, maintaining the
specified direction for each color. The background remains unchanged except
where lines are drawn.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    grid = [[0]*width for _ in range(height)]
    directions = {
        1: (-1, 1),
        2: (-1, -1),
        3: (1, 1),
        4: (1, -1)
    }
    
    for color in [1,2,3,4]:
        num_components = random.randint(2, 3)
        dr, dc = directions[color]
        start_r_min = 0
        start_r_max = height - 1
        start_c_min = 0
        start_c_max = width - 1
        
        if dr < 0:
            start_r_max -= 2 * (num_components - 1)
        else:
            start_r_min += 2 * (num_components - 1)
        if dc < 0:
            start_c_max -= 2 * (num_components - 1)
        else:
            start_c_min += 2 * (num_components - 1)
        
        start_r = random.randint(start_r_min, start_r_max)
        start_c = random.randint(start_c_min, start_c_max)
        
        for i in range(num_components):
            r = start_r + i * 2 * dr
            c = start_c + i * 2 * dc
            if 0 <= r < height and 0 <= c < width:
                grid[r][c] = color
    
    output_grid = [row[:] for row in grid]
    for color in [1,2,3,4]:
        positions = []
        for r in range(height):
            for c in range(width):
                if grid[r][c] == color:
                    positions.append((r, c))
        if len(positions) < 2:
            continue
        
        if color == 1:
            positions.sort(key=lambda x: (-x[0], x[1]))
        elif color == 2:
            positions.sort(key=lambda x: (-x[0], -x[1]))
        elif color == 3:
            positions.sort(key=lambda x: (x[0], x[1]))
        elif color == 4:
            positions.sort(key=lambda x: (x[0], -x[1]))
        
        dr, dc = directions[color]
        for i in range(1, len(positions)):
            r1, c1 = positions[i-1]
            r2, c2 = positions[i]
            mid_r = r1 + dr
            mid_c = c1 + dc
            if 0 <= mid_r < height and 0 <= mid_c < width and output_grid[mid_r][mid_c] == 0:
                output_grid[mid_r][mid_c] = 5
    
    return {"input": grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    
    directions = {
        1: (-1, 1),
        2: (-1, -1),
        3: (1, 1),
        4: (1, -1)
    }
    
    for color in [1,2,3,4]:
        positions = []
        for r in range(height):
            for c in range(width):
                if grid[r][c] == color:
                    positions.append((r, c))
        if len(positions) < 2:
            continue
        
        if color == 1:
            positions.sort(key=lambda x: (-x[0], x[1]))
        elif color == 2:
            positions.sort(key=lambda x: (-x[0], -x[1]))
        elif color == 3:
            positions.sort(key=lambda x: (x[0], x[1]))
        elif color == 4:
            positions.sort(key=lambda x: (x[0], -x[1]))
        
        dr, dc = directions[color]
        for i in range(1, len(positions)):
            r1, c1 = positions[i-1]
            r2, c2 = positions[i]
            mid_r = r1 + dr
            mid_c = c1 + dc
            if 0 <= mid_r < height and 0 <= mid_c < width and grid[mid_r][mid_c] == 0:
                grid[mid_r][mid_c] = 5
    
    return tuple(tuple(row) for row in grid)
