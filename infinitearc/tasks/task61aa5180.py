# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 61aa5180
Difficulty: hard

=== Tags ===
- Periodic offset matching
- Dual source paths
- Connect the dots
- Add frame
- Collapse duplicates

=== Description ===
Input grids feature two distinct path networks originating from the left and
right edges of the grid. Each path follows a periodic direction offset pattern
(e.g., moving right 2, down 1, right 2, down 1, repeating) and contains color-
coded "dot" markers at regular intervals along their routes. The paths are
composed of multiple colors that cycle through a fixed sequence, with the offset
pattern determining their directional changes.   The output grid requires four
sequential transformations: First, connect corresponding dot markers between the
left and right paths using straight-line segments of a designated color (connect
the dots), preserving the periodic offset pattern in the connection geometry.
Second, add a 1-cell-thick border frame around the entire connected structure
formed by these lines (add frame), using a color distinct from both the
background and path colors. Third, collapse any overlapping or redundant path
segments into single continuous segments (collapse duplicates) by merging
adjacent paths that occupy identical cells. Finally, maintain the periodic
offset pattern in all newly drawn connections while ensuring no two paths
intersect without merging. The background remains unchanged, and all
transformations must strictly adhere to the visual structure of the input
without relying on numerical or positional calculations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Generator for ARC Task 489: dual periodic offset paths with colored dots
# and horizontal connections + 1-cell frame.

def _build_path(start_row, start_col, pattern, width, height, side_limit_check):
    # pattern is a list like ['R','R','D'] or ['L','L','D']
    path = [(start_row, start_col)]
    visited = set(path)
    r, c = start_row, start_col
    while True:
        progressed = False
        for mv in pattern:
            dr = 0
            dc = 0
            if mv == 'R':
                dr, dc = 0, 1
            elif mv == 'L':
                dr, dc = 0, -1
            elif mv == 'D':
                dr, dc = 1, 0
            elif mv == 'U':
                dr, dc = -1, 0
            nr, nc = r + dr, c + dc
            # Check bounds
            if not (0 <= nr < height and 0 <= nc < width):
                return path
            # side limit check (callable) ensures we don't cross into center region
            if not side_limit_check(nr, nc):
                return path
            if (nr, nc) in visited:
                return path
            path.append((nr, nc))
            visited.add((nr, nc))
            r, c = nr, nc
            progressed = True
        if not progressed:
            break
    return path


def generate():
    DOT_COLORS = [1, 2, 3]
    CONNECTION_COLOR = 4
    FRAME_COLOR = 5
    PATH_COLOR_CYCLE = [6, 7, 8]

    # We will attempt a few times to create a valid configuration
    attempts = 0
    while attempts < 200:
        attempts += 1
        width = random.randint(12, 28)
        height = random.randint(9, 24)

        # Pattern: move 2 horizontally then 1 down (period length 3)
        left_pattern = ['R', 'R', 'D']
        right_pattern = ['L', 'L', 'D']
        period = len(left_pattern)

        # Choose a start_row that is not too close to bottom so we can have several downs
        start_row = random.randint(0, max(0, height - 6))
        # For good alignment we choose the same start row for both sides so corresponding dots align
        start_row_right = start_row

        # Define side limits so paths stop before the center (leave gap for connections)
        left_side_limit = width // 2 - 2
        right_side_limit = width - 1 - (width // 2 - 2)

        left_side_check = lambda nr, nc: nc <= left_side_limit
        right_side_check = lambda nr, nc: nc >= right_side_limit

        left_path = _build_path(start_row, 0, left_pattern, width, height, left_side_check)
        right_path = _build_path(start_row_right, width - 1, right_pattern, width, height, right_side_check)

        # Require minimum length so we have a few dots (dot every 'period' steps starting at index 0)
        min_dots = 3
        min_length = period * (min_dots - 1) + 1  # indices 0, period, 2*period ...
        if len(left_path) < min_length or len(right_path) < min_length:
            continue

        # Create input grid and color paths. Dots occur every 'period' cells (0, period, 2*period ...)
        input_grid = grid(width, height, 0)

        # Color left path
        for idx, (r, c) in enumerate(left_path):
            if idx % period == 0:
                # dot
                dot_index = (idx // period) % len(DOT_COLORS)
                input_grid[r][c] = DOT_COLORS[dot_index]
            else:
                input_grid[r][c] = PATH_COLOR_CYCLE[idx % len(PATH_COLOR_CYCLE)]

        # Color right path
        for idx, (r, c) in enumerate(right_path):
            if idx % period == 0:
                dot_index = (idx // period) % len(DOT_COLORS)
                input_grid[r][c] = DOT_COLORS[dot_index]
            else:
                input_grid[r][c] = PATH_COLOR_CYCLE[idx % len(PATH_COLOR_CYCLE)]

        # Build output grid by copying input
        output_grid = [row[:] for row in input_grid]

        # Collect dots by color in left and right paths in left-to-right ordering
        left_dots_by_color = {col: [] for col in DOT_COLORS}
        for (r, c) in left_path:
            val = input_grid[r][c]
            if val in DOT_COLORS:
                left_dots_by_color[val].append((r, c))
        right_dots_by_color = {col: [] for col in DOT_COLORS}
        for (r, c) in right_path:
            val = input_grid[r][c]
            if val in DOT_COLORS:
                right_dots_by_color[val].append((r, c))

        # Connect corresponding dots of the same color (pair by order). We expect the rows to match
        for color in DOT_COLORS:
            pairs = min(len(left_dots_by_color[color]), len(right_dots_by_color[color]))
            for i in range(pairs):
                lr, lc = left_dots_by_color[color][i]
                rr, rc = right_dots_by_color[color][i]
                # If they lie on same row, draw a horizontal straight segment between them
                if lr == rr:
                    r = lr
                    c1 = min(lc, rc)
                    c2 = max(lc, rc)
                    for c in range(c1, c2 + 1):
                        if output_grid[r][c] == 0:
                            output_grid[r][c] = CONNECTION_COLOR
                else:
                    # As a fallback (shouldn't generally happen because of alignment), draw an L-shaped
                    # Manhattan connection: horizontal to column of target then vertical.
                    # First horizontal from left to right column at left row
                    r1, r2 = lr, rr
                    c1, c2 = lc, rc
                    for c in range(min(c1, c2), max(c1, c2) + 1):
                        if output_grid[lr][c] == 0:
                            output_grid[lr][c] = CONNECTION_COLOR
                    # then vertical between lr and rr at column rc
                    for rr_ in range(min(r1, r2), max(r1, r2) + 1):
                        if output_grid[rr_][rc] == 0:
                            output_grid[rr_][rc] = CONNECTION_COLOR

        # Add a 1-cell-thick frame around all non-background cells
        non_bg = [(r, c) for r in range(height) for c in range(width) if output_grid[r][c] != 0]
        if not non_bg:
            # Should never happen, but guard
            continue
        min_r = min(r for r, c in non_bg)
        max_r = max(r for r, c in non_bg)
        min_c = min(c for r, c in non_bg)
        max_c = max(c for r, c in non_bg)

        fr = max(0, min_r - 1)
        fc = max(0, min_c - 1)
        br = min(height - 1, max_r + 1)
        bc = min(width - 1, max_c + 1)

        # Top and bottom rows of frame
        for c in range(fc, bc + 1):
            if fr >= 0 and fr < height and c >= 0 and c < width and output_grid[fr][c] == 0:
                output_grid[fr][c] = FRAME_COLOR
            if br >= 0 and br < height and c >= 0 and c < width and output_grid[br][c] == 0:
                output_grid[br][c] = FRAME_COLOR
        # Left and right columns of frame
        for r in range(fr, br + 1):
            if fc >= 0 and fc < width and r >= 0 and r < height and output_grid[r][fc] == 0:
                output_grid[r][fc] = FRAME_COLOR
            if bc >= 0 and bc < width and r >= 0 and r < height and output_grid[r][bc] == 0:
                output_grid[r][bc] = FRAME_COLOR

        # Ensure output differs from input (connections or frame must have changed something)
        if output_grid != input_grid:
            return {'input': input_grid, 'output': output_grid}

    # Fallback (unlikely): return a very small fixed example
    input_grid = grid(12, 9, 0)
    # Draw simple left and right dots
    input_grid[2][0] = 1
    input_grid[2][1] = 6
    input_grid[2][2] = 6
    input_grid[2][3] = 2
    input_grid[2][11] = 1
    input_grid[2][10] = 6
    input_grid[2][9] = 6
    input_grid[2][8] = 2
    output_grid = [row[:] for row in input_grid]
    for c in range(2, 9):
        if output_grid[2][c] == 0:
            output_grid[2][c] = 4
    # add small frame
    for c in range(0, 12):
        if output_grid[1][c] == 0:
            output_grid[1][c] = 5
        if output_grid[3][c] == 0:
            output_grid[3][c] = 5
    return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable grid
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    DOT_COLORS = [1, 2, 3]
    CONNECTION_COLOR = 4
    FRAME_COLOR = 5

    if height == 0 or width == 0:
        return grid

    # Find connected components of non-background cells
    from collections import deque
    visited = [[False] * width for _ in range(height)]
    components = []

    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 or visited[r][c]:
                continue
            # BFS to collect component
            comp = []
            dq = deque([(r, c)])
            visited[r][c] = True
            while dq:
                rr, cc = dq.popleft()
                comp.append((rr, cc))
                for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] != 0:
                        visited[nr][nc] = True
                        dq.append((nr, nc))
            components.append(comp)

    # Identify left and right components (the ones that touch column 0 and column width-1)
    left_comp = None
    right_comp = None
    for comp in components:
        cols = [c for r, c in comp]
        if any(c == 0 for c in cols):
            left_comp = comp
        if any(c == width - 1 for c in cols):
            right_comp = comp

    # If we don't have both, return original grid
    if left_comp is None or right_comp is None:
        # still may need to add frame around existing structure
        non_bg = [(r,c) for r in range(height) for c in range(width) if grid[r][c] != 0]
        if not non_bg:
            return grid
        min_r = min(r for r,c in non_bg)
        max_r = max(r for r,c in non_bg)
        min_c = min(c for r,c in non_bg)
        max_c = max(c for r,c in non_bg)
        fr = max(0, min_r - 1)
        fc = max(0, min_c - 1)
        br = min(height - 1, max_r + 1)
        bc = min(width - 1, max_c + 1)
        for c in range(fc, bc + 1):
            if 0 <= fr < height and 0 <= c < width and grid[fr][c] == 0:
                grid[fr][c] = FRAME_COLOR
            if 0 <= br < height and 0 <= c < width and grid[br][c] == 0:
                grid[br][c] = FRAME_COLOR
        for r in range(fr, br + 1):
            if 0 <= fc < width and 0 <= r < height and grid[r][fc] == 0:
                grid[r][fc] = FRAME_COLOR
            if 0 <= bc < width and 0 <= r < height and grid[r][bc] == 0:
                grid[r][bc] = FRAME_COLOR
        return grid

    # Collect dot positions for left and right components grouped by color
    left_dots = {col: [] for col in DOT_COLORS}
    for r, c in left_comp:
        val = grid[r][c]
        if val in DOT_COLORS:
            left_dots[val].append((r, c))
    right_dots = {col: [] for col in DOT_COLORS}
    for r, c in right_comp:
        val = grid[r][c]
        if val in DOT_COLORS:
            right_dots[val].append((r, c))

    # Sort left dots by column ascending, right dots by column descending so they pair across
    for col in DOT_COLORS:
        left_dots[col] = sorted(left_dots[col], key=lambda x: (x[1], x[0]))
        right_dots[col] = sorted(right_dots[col], key=lambda x: (-x[1], x[0]))

    # Connect corresponding dots by drawing horizontal segments when they share a row.
    for col in DOT_COLORS:
        pairs = min(len(left_dots[col]), len(right_dots[col]))
        for i in range(pairs):
            lr, lc = left_dots[col][i]
            rr, rc = right_dots[col][i]
            if lr == rr:
                r = lr
                for c in range(min(lc, rc), max(lc, rc) + 1):
                    if grid[r][c] == 0:
                        grid[r][c] = CONNECTION_COLOR
            else:
                # Fallback L-shaped Manhattan connection
                r1, r2 = lr, rr
                c1, c2 = lc, rc
                for c in range(min(c1, c2), max(c1, c2) + 1):
                    if grid[lr][c] == 0:
                        grid[lr][c] = CONNECTION_COLOR
                for rr_ in range(min(r1, r2), max(r1, r2) + 1):
                    if grid[rr_][rc] == 0:
                        grid[rr_][rc] = CONNECTION_COLOR

    # Add frame around non-background
    non_bg = [(r, c) for r in range(height) for c in range(width) if grid[r][c] != 0]
    if non_bg:
        min_r = min(r for r, c in non_bg)
        max_r = max(r for r, c in non_bg)
        min_c = min(c for r, c in non_bg)
        max_c = max(c for r, c in non_bg)
        fr = max(0, min_r - 1)
        fc = max(0, min_c - 1)
        br = min(height - 1, max_r + 1)
        bc = min(width - 1, max_c + 1)
        for c in range(fc, bc + 1):
            if 0 <= fr < height and 0 <= c < width and grid[fr][c] == 0:
                grid[fr][c] = FRAME_COLOR
            if 0 <= br < height and 0 <= c < width and grid[br][c] == 0:
                grid[br][c] = FRAME_COLOR
        for r in range(fr, br + 1):
            if 0 <= fc < width and 0 <= r < height and grid[r][fc] == 0:
                grid[r][fc] = FRAME_COLOR
            if 0 <= bc < width and 0 <= r < height and grid[r][bc] == 0:
                grid[r][bc] = FRAME_COLOR

    return grid

