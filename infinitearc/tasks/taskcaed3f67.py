# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: caed3f67
Difficulty: mediumâ€“hard

=== Tags ===
- Deterministic reflection
- Pattern concatenation
- Alternating agents
- Intersecting currents
- Maze

=== Description ===
Input grids depict a maze-like structure where two distinct path colors (e.g.,
red and blue) form continuous, non-overlapping paths that intersect at specific
grid cells. Each intersection occurs where a horizontal path segment (left-
right) crosses a vertical path segment (up-down). The transformation rule
applies a deterministic reflection at every intersection: the horizontal path
continues vertically through the intersection (up/down), and the vertical path
continues horizontally (left/right). This reflection is applied consistently
across all intersections, redirecting paths to flow perpendicularly at crossing
points. The output grid maintains the original maze boundaries and background,
with all path segments adjusted to reflect this perpendicular redirection. The
transformation creates a new path structure where intersecting currents merge
into a continuous flow, alternating between the two path colors at each
intersection point. The maze pattern is preserved, but path directions are
systematically transformed at every crossing, resulting in a visually cohesive
and logically consistent output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(8, 20)
    height = random.randint(5, 20)
    grid_input = [[0] * width for _ in range(height)]
    A, B = 2, 3
    mid_row = height // 2
    start_col = random.randint(2, width - 6)
    end_col = start_col + 5
    for c in range(start_col, end_col + 1):
        grid_input[mid_row][c] = A
    for c in range(start_col + 1, end_col):
        if mid_row > 0 and mid_row < height - 1:
            grid_input[mid_row - 1][c] = B
            grid_input[mid_row + 1][c] = B
    grid_output = [row[:] for row in grid_input]
    for c in range(start_col + 1, end_col):
        grid_output[mid_row - 1][c] = A
        grid_output[mid_row + 1][c] = A
        grid_output[mid_row][c - 1] = B
        grid_output[mid_row][c + 1] = B
    return {"input": grid_input, "output": grid_output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    A, B = 2, 3
    intersections = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] != A:
                continue
            if c > 0 and c < width - 1 and grid[r][c-1] == A and grid[r][c+1] == A:
                if r > 0 and r < height - 1 and grid[r-1][c] == B and grid[r+1][c] == B:
                    intersections.append((r, c))
    output_grid = [row[:] for row in grid]
    for (r, c) in intersections:
        output_grid[r-1][c] = A
        output_grid[r+1][c] = A
        output_grid[r][c-1] = B
        output_grid[r][c+1] = B
    return tuple(tuple(row) for row in output_grid)
