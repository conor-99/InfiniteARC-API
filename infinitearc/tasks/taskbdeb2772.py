# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: bdeb2772
Difficulty: insane

=== Tags ===
- Laser diffusion
- Path following

=== Description ===
# Laser Diffusion Network  Input grids are large (20×20 or larger) with a single
background color (0). Overlaid on this background are two distinct elements:
1. **Walls**: Horizontal or vertical lines (1 cell thick) of colors 1–9, placed
such that no walls touch each other or other elements. Walls form a complex
maze-like structure with passages between them.  2. **Lasers**: L-shaped
clusters of three connected cells (all the same color) oriented to face one of
four diagonal directions (northeast, southeast, southwest, northwest). Each
laser has a background cell (color 0) at the inner corner of the L, serving as
the beam's origin. The origin cell is never adjacent to walls.  Each laser's
beam travels diagonally from its origin at 45° until it encounters a wall. Upon
impact with a wall:  - **Color 1 walls** cause the beam to **split** into two
perpendicular beams (e.g., a northeast-moving beam splits into east and north
beams), each continuing with color 1. - **Color 2 walls** cause the beam to
**reflect** (mirroring direction), changing to color 2. - **Colors 3–9 walls**
cause the beam to **absorb** (end the path at the wall contact point).  Beams
occupy only background cells and never overwrite walls, lasers, or other beams.
All beams follow their paths until exiting the grid or being absorbed. The
output grid retains all input elements unchanged except for the new beam paths,
which are drawn as diagonal lines on background cells. The diffusion pattern
results in a complex, non-overlapping network of beams that visually spreads
from the lasers through the maze, with color transitions reflecting the wall
interactions. The task requires tracking multiple simultaneous path splits,
reflections, and absorptions across a densely packed grid with 8+ lasers and 15+
walls.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque

def generate():
    # Grid size
    size = random.randint(20, 25)
    grid = [[0 for _ in range(size)] for _ in range(size)]

    # Helper to check if a set of candidate cells is isolated (no touching other non-zero cells)
    def candidates_isolated(cells):
        for (r, c) in cells:
            for dr in (-1, 0, 1):
                for dc in (-1, 0, 1):
                    rr, cc = r + dr, c + dc
                    if rr < 0 or rr >= size or cc < 0 or cc >= size:
                        continue
                    if (rr, cc) in cells:
                        continue
                    if grid[rr][cc] != 0:
                        return False
        return True

    walls = []  # store (cells_list, color)
    wall_cells = set()

    # Place a number of short walls (horizontal or vertical), ensuring they do not touch.
    target_walls = random.randint(15, 22)
    attempts = 0
    while len(walls) < target_walls and attempts < target_walls * 30:
        attempts += 1
        orientation = random.choice(['H', 'V'])
        # lengths skewed so walls are varied but not too long
        length = random.randint(1, 5)
        if orientation == 'H':
            r = random.randint(0, size - 1)
            c = random.randint(0, size - length)
            cells = [(r, c + i) for i in range(length)]
        else:
            c = random.randint(0, size - 1)
            r = random.randint(0, size - length)
            cells = [(r + i, c) for i in range(length)]

        # Ensure all candidate cells are background and isolated from other elements
        ok = True
        for (rr, cc) in cells:
            if grid[rr][cc] != 0:
                ok = False
                break
        if not ok:
            continue
        if not candidates_isolated(set(cells)):
            continue

        color = random.randint(1, 9)
        for (rr, cc) in cells:
            grid[rr][cc] = color
            wall_cells.add((rr, cc))
        walls.append((cells, color))

    # Ensure at least one splitter (color 1) and one reflector (color 2) exist among walls
    colors_present = {color for _, color in walls}
    if 1 not in colors_present and walls:
        # change a random wall's color to 1
        i = random.randrange(len(walls))
        cells, _ = walls[i]
        for (rr, cc) in cells:
            grid[rr][cc] = 1
        walls[i] = (cells, 1)
        wall_cells.update(cells)
    if 2 not in colors_present and walls:
        i = random.randrange(len(walls))
        cells, _ = walls[i]
        for (rr, cc) in cells:
            grid[rr][cc] = 2
        walls[i] = (cells, 2)
        wall_cells.update(cells)

    # Place lasers (L-shaped clusters of three same-colored cells) with an empty origin (inner corner)
    lasers = []  # store (origin_r, origin_c, dr, dc, color)
    laser_cells = set()
    orientations = [(-1, 1), (1, 1), (1, -1), (-1, -1)]  # NE, SE, SW, NW (dr, dc)

    target_lasers = random.randint(8, 12)
    attempts = 0
    while len(lasers) < target_lasers and attempts < target_lasers * 50:
        attempts += 1
        r = random.randint(1, size - 2)
        c = random.randint(1, size - 2)
        if grid[r][c] != 0:
            continue
        # choose orientation and compute arm positions: (r+dr, c), (r, c-dc), (r+dr, c-dc)
        dr, dc = random.choice(orientations)
        arm1 = (r + dr, c)
        arm2 = (r, c - dc)
        arm3 = (r + dr, c - dc)
        # bounds check
        ok = True
        for (rr, cc) in (arm1, arm2, arm3):
            if rr < 0 or rr >= size or cc < 0 or cc >= size:
                ok = False
                break
            if grid[rr][cc] != 0:
                ok = False
                break
        if not ok:
            continue
        # ensure the 3x3 neighborhood around the origin is clear (origin must not be adjacent to walls)
        neighborhood_clear = True
        for drn in (-1, 0, 1):
            for dcn in (-1, 0, 1):
                rr, cc = r + drn, c + dcn
                if rr < 0 or rr >= size or cc < 0 or cc >= size:
                    continue
                if grid[rr][cc] != 0:
                    neighborhood_clear = False
                    break
            if not neighborhood_clear:
                break
        if not neighborhood_clear:
            continue

        # place the laser arms
        color = random.randint(1, 9)
        for (rr, cc) in (arm1, arm2, arm3):
            grid[rr][cc] = color
            laser_cells.add((rr, cc))
        lasers.append((r, c, dr, dc, color))

    # Now simulate beam diffusion using the same logic that the solver will use
    def simulate_beams(input_grid):
        from collections import deque
        size_local = len(input_grid)
        # Detect lasers the same way the solver does
        lasers_local = []
        laser_cells_local = set()
        orientations_local = [(-1, 1), (1, 1), (1, -1), (-1, -1)]
        for rr in range(1, size_local - 1):
            for cc in range(1, size_local - 1):
                if input_grid[rr][cc] != 0:
                    continue
                for (drl, dcl) in orientations_local:
                    a1 = (rr + drl, cc)
                    a2 = (rr, cc - dcl)
                    a3 = (rr + drl, cc - dcl)
                    r1, c1 = a1
                    r2, c2 = a2
                    r3, c3 = a3
                    if not (0 <= r1 < size_local and 0 <= c1 < size_local and 0 <= r2 < size_local and 0 <= c2 < size_local and 0 <= r3 < size_local and 0 <= c3 < size_local):
                        continue
                    v1 = input_grid[r1][c1]
                    v2 = input_grid[r2][c2]
                    v3 = input_grid[r3][c3]
                    if v1 != 0 and v1 == v2 and v2 == v3:
                        lasers_local.append((rr, cc, drl, dcl, v1))
                        laser_cells_local.update([a1, a2, a3])
                        break
        walls_set_local = set((rr, cc) for rr in range(size_local) for cc in range(size_local) if input_grid[rr][cc] != 0 and (rr, cc) not in laser_cells_local)

        def get_wall_orientation_local(rr, cc):
            color_local = input_grid[rr][cc]
            if (rr, cc - 1) in walls_set_local and input_grid[rr][cc - 1] == color_local:
                return 'horizontal'
            if (rr, cc + 1) in walls_set_local and input_grid[rr][cc + 1] == color_local:
                return 'horizontal'
            if (rr - 1, cc) in walls_set_local and input_grid[rr - 1][cc] == color_local:
                return 'vertical'
            if (rr + 1, cc) in walls_set_local and input_grid[rr + 1][cc] == color_local:
                return 'vertical'
            return 'vertical'

        def split_dirs_local(drl, dcl):
            if drl != 0 and dcl != 0:
                return [(drl, 0), (0, dcl)]
            if drl == 0 and dcl != 0:
                if dcl == 1:
                    return [(-1, 1), (1, 1)]
                else:
                    return [(-1, -1), (1, -1)]
            if dcl == 0 and drl != 0:
                if drl == -1:
                    return [(-1, -1), (-1, 1)]
                else:
                    return [(1, -1), (1, 1)]
            return []

        output_local = [row[:] for row in input_grid]
        beam_queue_local = deque()
        visited_local = set()
        for (rr, cc, drl, dcl, col) in sorted(lasers_local, key=lambda x: (x[0], x[1])):
            st = (rr, cc, drl, dcl, col)
            beam_queue_local.append(st)
            visited_local.add(st)
        max_steps_local = size_local * size_local * 4
        while beam_queue_local:
            rcur, ccur, drcur, dccur, colcur = beam_queue_local.popleft()
            steps_local = 0
            while True:
                steps_local += 1
                if steps_local > max_steps_local:
                    break
                nr, nc = rcur + drcur, ccur + dccur
                if nr < 0 or nr >= size_local or nc < 0 or nc >= size_local:
                    break
                if (nr, nc) in walls_set_local:
                    wcol = input_grid[nr][nc]
                    if wcol == 1:
                        for (sdr, sdc) in split_dirs_local(drcur, dccur):
                            newst = (nr, nc, sdr, sdc, 1)
                            if newst not in visited_local:
                                visited_local.add(newst)
                                beam_queue_local.append(newst)
                    elif wcol == 2:
                        orient = get_wall_orientation_local(nr, nc)
                        if orient == 'vertical':
                            new_dr, new_dc = drcur, -dccur
                        else:
                            new_dr, new_dc = -drcur, dccur
                        newst = (nr, nc, new_dr, new_dc, 2)
                        if newst not in visited_local:
                            visited_local.add(newst)
                            beam_queue_local.append(newst)
                    break
                if output_local[nr][nc] != 0:
                    break
                output_local[nr][nc] = colcur
                rcur, ccur = nr, nc
        return output_local

    output_grid = simulate_beams(grid)
    return {'input': grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    from collections import deque
    # Convert input to mutable list of lists
    grid = [list(row) for row in input_grid]
    size = len(grid)

    # Detect lasers: pattern where origin is 0 and the three arm cells exist and share color
    lasers = []  # (origin_r, origin_c, dr, dc, color)
    laser_cells = set()
    orientations = [(-1, 1), (1, 1), (1, -1), (-1, -1)]  # NE, SE, SW, NW
    for r in range(1, size - 1):
        for c in range(1, size - 1):
            if grid[r][c] != 0:
                continue
            for (dr, dc) in orientations:
                arm1 = (r + dr, c)
                arm2 = (r, c - dc)
                arm3 = (r + dr, c - dc)
                rr1, cc1 = arm1
                rr2, cc2 = arm2
                rr3, cc3 = arm3
                if not (0 <= rr1 < size and 0 <= cc1 < size and 0 <= rr2 < size and 0 <= cc2 < size and 0 <= rr3 < size and 0 <= cc3 < size):
                    continue
                v1 = grid[rr1][cc1]
                v2 = grid[rr2][cc2]
                v3 = grid[rr3][cc3]
                if v1 != 0 and v1 == v2 and v2 == v3:
                    # Found a laser
                    color = v1
                    lasers.append((r, c, dr, dc, color))
                    laser_cells.update([arm1, arm2, arm3])
                    break

    # Walls are all non-zero cells that are not laser arm cells
    walls_set = set((r, c) for r in range(size) for c in range(size) if grid[r][c] != 0 and (r, c) not in laser_cells)

    def get_wall_orientation(r, c):
        color = grid[r][c]
        if (r, c - 1) in walls_set and grid[r][c - 1] == color:
            return 'horizontal'
        if (r, c + 1) in walls_set and grid[r][c + 1] == color:
            return 'horizontal'
        if (r - 1, c) in walls_set and grid[r - 1][c] == color:
            return 'vertical'
        if (r + 1, c) in walls_set and grid[r + 1][c] == color:
            return 'vertical'
        return 'vertical'

    # Splitting mapping (same logic as generator)
    def split_dirs(dr, dc):
        if dr != 0 and dc != 0:
            return [(dr, 0), (0, dc)]
        if dr == 0 and dc != 0:
            if dc == 1:
                return [(-1, 1), (1, 1)]
            else:
                return [(-1, -1), (1, -1)]
        if dc == 0 and dr != 0:
            if dr == -1:
                return [(-1, -1), (-1, 1)]
            else:
                return [(1, -1), (1, 1)]
        return []

    # Prepare output grid as a copy of input
    output = [row[:] for row in grid]

    # Beam queue and visited states
    beam_queue = deque()
    visited = set()

    # Seed initial beams in deterministic row-major order to match generator
    for (r, c, dr, dc, color) in sorted(lasers, key=lambda x: (x[0], x[1])):
        state = (r, c, dr, dc, color)
        beam_queue.append(state)
        visited.add(state)

    max_steps = size * size * 4

    while beam_queue:
        r, c, dr, dc, color = beam_queue.popleft()
        steps = 0
        while True:
            steps += 1
            if steps > max_steps:
                break
            nr, nc = r + dr, c + dc
            if nr < 0 or nr >= size or nc < 0 or nc >= size:
                break
            if (nr, nc) in walls_set:
                wall_color = grid[nr][nc]
                if wall_color == 1:
                    for (sdr, sdc) in split_dirs(dr, dc):
                        new_state = (nr, nc, sdr, sdc, 1)
                        if new_state not in visited:
                            visited.add(new_state)
                            beam_queue.append(new_state)
                elif wall_color == 2:
                    orient = get_wall_orientation(nr, nc)
                    if orient == 'vertical':
                        new_dr, new_dc = dr, -dc
                    else:
                        new_dr, new_dc = -dr, dc
                    new_state = (nr, nc, new_dr, new_dc, 2)
                    if new_state not in visited:
                        visited.add(new_state)
                        beam_queue.append(new_state)
                break
            if output[nr][nc] != 0:
                break
            output[nr][nc] = color
            r, c = nr, nc

    return tuple(tuple(row) for row in output)

