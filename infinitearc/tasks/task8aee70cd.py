# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 8aee70cd
Difficulty: hard

=== Tags ===
- Rule transfer between regions
- Multi layer projection
- Cyclic painting

=== Description ===
# Cyclic Layered Projection  Input grids consist of multiple concentric or
nested regions, each defined by a contiguous area of a single color (e.g., a red
circle inside a blue square inside a green triangle). These regions are layered
such that each inner region is completely contained within the area of the
immediately surrounding region. The background color is distinct from all region
colors.  The transformation follows a multi-layer cyclic painting rule: each
region's color cycles through a fixed sequence (e.g., red → blue → green → red),
but the direction of the cycle (forward or backward) is determined by the color
of the immediately surrounding region. If the outer region's color is a "warm"
hue (red, orange, yellow), the inner region cycles forward; if the outer
region's color is a "cool" hue (blue, green, purple), the inner region cycles
backward. This rule transfers the cycle direction from the outer region to the
inner region (rule transfer between regions).  The output grid is generated by
shifting each region's color one step in the direction determined by its
enclosing region's color. This transformation must be applied across all nested
layers simultaneously (multi-layer projection), meaning the innermost region's
cycle direction depends on the next outer layer, which in turn depends on the
next, and so on. The background remains unchanged, and no regions are altered in
shape or position, only their colors shift according to the cyclic rule.  The
task requires identifying the fixed cycle sequence and the color-based direction
rule through visual pattern recognition rather than numerical computation,
making it challenging to deduce from minimal input-output examples.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    w = random.randint(7, 30)
    h = random.randint(7, 30)
    input_grid = [[0] * w for _ in range(h)]
    
    num_layers = random.choice([2, 3])
    sequence = [2, 1, 3]
    warm_colors = [2, 4, 7]
    cool_colors = [1, 3, 8]
    
    # Ensure distinct colors for each layer
    colors = random.sample(sequence, num_layers)
    
    for i in range(num_layers):
        top = i + 1
        left = i + 1
        bottom = h - i - 2
        right = w - i - 2
        color = colors[i]
        for r in range(top, bottom + 1):
            for c in range(left, right + 1):
                input_grid[r][c] = color
    
    output_grid = [row[:] for row in input_grid]
    
    for i in range(1, num_layers):
        outer_color = colors[i-1]
        current_color = colors[i]
        if outer_color in warm_colors:
            idx = sequence.index(current_color)
            new_idx = (idx + 1) % len(sequence)
        else:
            idx = sequence.index(current_color)
            new_idx = (idx - 1) % len(sequence)
        new_color = sequence[new_idx]
        top = i + 1
        left = i + 1
        bottom = h - i - 2
        right = w - i - 2
        for r in range(top, bottom + 1):
            for c in range(left, right + 1):
                output_grid[r][c] = new_color
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])
    
    colors_present = set()
    for r in range(h):
        for c in range(w):
            if grid[r][c] != 0:
                colors_present.add(grid[r][c])
    
    if len(colors_present) < 2:
        return grid
    
    color_boxes = {}
    for color in colors_present:
        min_r, max_r = h, 0
        min_c, max_c = w, 0
        for r in range(h):
            for c in range(w):
                if grid[r][c] == color:
                    min_r = min(min_r, r)
                    max_r = max(max_r, r)
                    min_c = min(min_c, c)
                    max_c = max(max_c, c)
        color_boxes[color] = (min_r, max_r, min_c, max_c)
    
    sorted_colors = sorted(colors_present, key=lambda c: (color_boxes[c][1] - color_boxes[c][0] + 1) * (color_boxes[c][3] - color_boxes[c][2] + 1), reverse=True)
    
    sequence = [2, 1, 3]
    warm_colors = [2, 4, 7]
    cool_colors = [1, 3, 8]
    
    new_colors = {}
    for i in range(1, len(sorted_colors)):
        outer_color = sorted_colors[i-1]
        current_color = sorted_colors[i]
        if outer_color in warm_colors:
            idx = sequence.index(current_color)
            new_idx = (idx + 1) % len(sequence)
        else:
            idx = sequence.index(current_color)
            new_idx = (idx - 1) % len(sequence)
        new_color = sequence[new_idx]
        new_colors[current_color] = new_color
    
    for r in range(h):
        for c in range(w):
            if grid[r][c] in new_colors:
                grid[r][c] = new_colors[grid[r][c]]
    
    return grid
