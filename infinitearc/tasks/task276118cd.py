# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 276118cd
Difficulty: very hard

=== Tags ===
- Gravity with barriers
- Local physics rule
- Pattern activation
- Energy field diffusion
- Reflect across detected axis

=== Description ===
**Task Name: Symmetric Energy Cascade**  **Description:**    Input grids consist
of a uniform background color (0), fixed barrier structures (color 1), and
mobile objects (colors 2–9). Barriers form non-overlapping, contiguous regions
that block vertical movement. Mobile objects fall downward under gravity until
they collide with barriers or the grid bottom, settling directly atop barrier
cells.    Upon collision, each mobile object triggers a directional energy
diffusion field. The diffusion direction (horizontal or vertical) is determined
by the object’s color: even-numbered objects diffuse horizontally (left/right
based on parity), while odd-numbered objects diffuse vertically (up/down based
on parity). The diffusion field spreads unidirectionally until blocked by
barriers or the grid boundary, marking traversed background cells with a unique
energy color (6–9) without overwriting barriers or other diffusion paths.
After all diffusion fields propagate, the grid is reflected across a vertical
axis detected from the input grid’s barrier configuration. The axis is
identified as the central column containing a continuous vertical barrier line
spanning the grid height. Reflection swaps cells symmetrically across this axis,
preserving all energy fields, barriers, and background patterns.    The output
grid must reflect the combined effects of gravity-driven settling, directional
diffusion, and axis-based reflection. Barriers remain fixed throughout, and no
cell is left unchanged if it was part of a diffusion path or reflection. The
task requires identifying the barrier-based axis, mapping object colors to
diffusion directions, and sequencing transformations without relying on
numerical values or pixel-level patterns.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
def generate():
    width = random.choice([3,5,7,9,11,13,15,17,19,21,23,25,27,29])
    height = random.randint(3, 30)
    grid_in = [[0] * width for _ in range(height)]
    mid = width // 2
    for r in range(height):
        grid_in[r][mid] = 1
    
    for c in range(width):
        if c == mid:
            continue
        for r in range(height):
            if random.random() < 0.3:
                grid_in[r][c] = 1
    
    mobile_colors = list(range(2, 10))
    for c in range(width):
        if c == mid:
            continue
        for r in range(height-2, -1, -1):
            if grid_in[r+1][c] == 1:
                if random.random() < 0.4:
                    grid_in[r][c] = random.choice(mobile_colors)
    
    grid_out = [row[:] for row in grid_in]
    
    for r in range(height):
        for c in range(width):
            color = grid_out[r][c]
            if 2 <= color <= 9:
                if color % 2 == 0:
                    for dc in range(1, c+1):
                        if grid_out[r][c - dc] != 0:
                            break
                        grid_out[r][c - dc] = 6
                else:
                    for dr in range(1, r+1):
                        if grid_out[r - dr][c] != 0:
                            break
                        grid_out[r - dr][c] = 6
    
    new_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            new_grid[r][c] = grid_out[r][width - 1 - c]
    
    return {"input": grid_in, "output": new_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    
    for r in range(height):
        for c in range(width):
            color = grid[r][c]
            if 2 <= color <= 9:
                if color % 2 == 0:
                    for dc in range(1, c+1):
                        if grid[r][c - dc] != 0:
                            break
                        grid[r][c - dc] = 6
                else:
                    for dr in range(1, r+1):
                        if grid[r - dr][c] != 0:
                            break
                        grid[r - dr][c] = 6
    
    new_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            new_grid[r][c] = grid[r][width - 1 - c]
    
    return tuple(tuple(row) for row in new_grid)
