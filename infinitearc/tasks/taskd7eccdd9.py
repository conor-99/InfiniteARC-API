# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: d7eccdd9
Difficulty: hard

=== Tags ===
- Deterministic update
- Pattern analogy
- Fill between lines

=== Description ===
The task, "Patterned Region Filling," requires transforming input grids into
output grids by filling regions bounded by parallel boundary lines with a
transformed reference pattern. Input grids are 10×10 to 30×30 grids containing
two key elements: (1) parallel boundary lines (horizontal or vertical sequences
of a single color, e.g., color 5) that define disjoint rectangular regions
between pairs of lines, and (2) a reference pattern—a contiguous block of a
distinct color (e.g., color 2), typically 2×2 or 3×3, located outside boundary
regions. The output grid preserves all boundary lines while filling each region
between parallel lines with a transformation of the reference pattern. For
regions bounded by horizontal lines, the reference pattern is rotated 90°
clockwise and tiled to fill the region’s height and width. For regions bounded
by vertical lines, the reference pattern is reflected across its vertical axis
and tiled to fill the region. The reference pattern must be present, non-
overlapping with boundaries, and its transformation is fixed based solely on
line orientation. Filled regions must not overlap boundaries or other regions,
and unused areas retain background color. This task demands multi-step
reasoning: identifying the reference pattern, detecting line orientations,
applying deterministic transformations, and ensuring spatial alignment within
variable-sized regions. The complexity arises from the need to generalize across
varying region sizes, reference pattern placements, and precise transformation
application without visual or numerical shortcuts.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import random_color

def rotate_90(matrix):
    return [list(x)[::-1] for x in zip(*matrix)]

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    width = width // 2 * 2
    height = height // 2 * 2
    boundary_color = 5
    input_grid = [[0] * width for _ in range(height)]
    output_grid = [[0] * width for _ in range(height)]
    
    orientation = random.choice(['horizontal', 'vertical'])
    
    if orientation == 'horizontal':
        num_lines = random.randint(2, 4)
        y_positions = []
        current = 2
        for _ in range(num_lines):
            if current >= height - 2:
                break
            y_positions.append(current)
            current += 3
        for y in y_positions:
            for x in range(width):
                input_grid[y][x] = boundary_color
                output_grid[y][x] = boundary_color
    else:
        num_lines = random.randint(2, 4)
        x_positions = []
        current = 2
        for _ in range(num_lines):
            if current >= width - 2:
                break
            x_positions.append(current)
            current += 3
        for x in x_positions:
            for y in range(height):
                input_grid[y][x] = boundary_color
                output_grid[y][x] = boundary_color
    
    ref_pattern = [[random_color(exclude=[boundary_color, 0]) for _ in range(2)] for _ in range(2)]
    for r in range(2):
        for c in range(2):
            input_grid[r][c] = ref_pattern[r][c]
            output_grid[r][c] = ref_pattern[r][c]

    if orientation == 'horizontal':
        transformed_pattern = rotate_90(ref_pattern)
        for i in range(len(y_positions) - 1):
            top = y_positions[i] + 1
            bottom = y_positions[i+1] - 1
            for r in range(top, bottom + 1):
                for c in range(width):
                    pattern_r = (r - top) % len(transformed_pattern)
                    pattern_c = c % len(transformed_pattern[0])
                    output_grid[r][c] = transformed_pattern[pattern_r][pattern_c]
    else:
        transformed_pattern = [row[::-1] for row in ref_pattern]
        for i in range(len(x_positions) - 1):
            left = x_positions[i] + 1
            right = x_positions[i+1] - 1
            for c in range(left, right + 1):
                for r in range(height):
                    pattern_c = (c - left) % len(transformed_pattern[0])
                    pattern_r = r % len(transformed_pattern)
                    output_grid[r][c] = transformed_pattern[pattern_r][pattern_c]
    
    return {
        'input': input_grid,
        'output': output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import random_color

def rotate_90(matrix):
    return [list(x)[::-1] for x in zip(*matrix)]

def find_boundary_color(grid):
    height = len(grid)
    width = len(grid[0])
    for r in range(height):
        if all(grid[r][c] == grid[r][0] for c in range(width)) and grid[r][0] != 0:
            return grid[r][0]
    for c in range(width):
        if all(grid[r][c] == grid[0][c] for r in range(height)) and grid[0][c] != 0:
            return grid[0][c]
    return 0

def find_reference_pattern(grid, boundary_color, orientation, boundary_positions):
    height = len(grid)
    width = len(grid[0])
    for r in range(height - 1):
        for c in range(width - 1):
            if all(grid[r + dr][c + dc] != 0 and grid[r + dr][c + dc] != boundary_color for dr in (0, 1) for dc in (0, 1)):
                if orientation == 'horizontal':
                    in_region = any(boundary_positions[i] < r < boundary_positions[i+1] or boundary_positions[i] < r+1 < boundary_positions[i+1] for i in range(len(boundary_positions)-1))
                else:
                    in_region = any(boundary_positions[i] < c < boundary_positions[i+1] or boundary_positions[i] < c+1 < boundary_positions[i+1] for i in range(len(boundary_positions)-1))
                if not in_region:
                    return [[grid[r][c], grid[r][c+1]], [grid[r+1][c], grid[r+1][c+1]]]
    return [[1, 2], [3, 4]]

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    boundary_color = find_boundary_color(grid)
    
    horizontal_lines = any(all(grid[r][c] == boundary_color for c in range(width)) for r in range(height))
    vertical_lines = any(all(grid[r][c] == boundary_color for r in range(height)) for c in range(width))
    
    if horizontal_lines:
        orientation = 'horizontal'
        boundary_positions = [r for r in range(height) if all(grid[r][c] == boundary_color for c in range(width))]
    else:
        orientation = 'vertical'
        boundary_positions = [c for c in range(width) if all(grid[r][c] == boundary_color for r in range(height))]
    
    ref_pattern = find_reference_pattern(grid, boundary_color, orientation, boundary_positions)
    
    if orientation == 'horizontal':
        transformed_pattern = rotate_90(ref_pattern)
    else:
        transformed_pattern = [row[::-1] for row in ref_pattern]
    
    output_grid = [row[:] for row in grid]
    
    if orientation == 'horizontal':
        for i in range(len(boundary_positions) - 1):
            top = boundary_positions[i] + 1
            bottom = boundary_positions[i+1] - 1
            for r in range(top, bottom + 1):
                for c in range(width):
                    pattern_r = (r - top) % len(transformed_pattern)
                    pattern_c = c % len(transformed_pattern[0])
                    output_grid[r][c] = transformed_pattern[pattern_r][pattern_c]
    else:
        for i in range(len(boundary_positions) - 1):
            left = boundary_positions[i] + 1
            right = boundary_positions[i+1] - 1
            for c in range(left, right + 1):
                for r in range(height):
                    pattern_c = (c - left) % len(transformed_pattern[0])
                    pattern_r = r % len(transformed_pattern)
                    output_grid[r][c] = transformed_pattern[pattern_r][pattern_c]
    
    return output_grid
