# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 61f1ed16
Difficulty: hard

=== Tags ===
- Pattern imitation
- Connect all dots of same color

=== Description ===
Input grids consist of a background color (typically 0) with scattered clusters
of non-background colors (1-9) distributed across the grid. For each non-
background color present, the output grid must enclose all cells of that color
within a minimal axis-aligned rectangular boundary drawn using the same color.
The boundary is formed by the hollow perimeter of the smallest rectangle that
contains every cell of the color, with the interior of the rectangle remaining
unaffected (retaining background or other colors). This requires identifying the
topmost, bottommost, leftmost, and rightmost cells of each color cluster, then
drawing the outer edges of the bounding rectangle. If multiple colors'
rectangles overlap, their boundaries are rendered independently in their
respective colors without merging or erasing. The original positions of all non-
background cells remain unchanged, with only the rectangular boundaries added
where necessary. The transformation creates a visual pattern that imitates the
spatial arrangement of the input clusters, requiring precise geometric reasoning
to determine each color's bounding rectangle and its perimeter.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    while True:
        width = random.randint(1, 30)
        height = random.randint(1, 30)
        grid_input = common.grid(width, height, 0)
        
        num_colors = random.randint(2, 5)
        colors = sorted(random.sample(list(range(1, 10)), num_colors))
        
        for color in colors:
            num_cells = random.randint(2, 5)
            for _ in range(num_cells):
                r = random.randint(0, height-1)
                c = random.randint(0, width-1)
                grid_input[r][c] = color
        
        grid_output = [row[:] for row in grid_input]
        
        for color in colors:
            positions = []
            for r in range(height):
                for c in range(width):
                    if grid_input[r][c] == color:
                        positions.append((r, c))
            
            if not positions:
                continue
            
            min_r = min(r for r, _ in positions)
            max_r = max(r for r, _ in positions)
            min_c = min(c for _, c in positions)
            max_c = max(c for _, c in positions)
            
            for c in range(min_c, max_c + 1):
                if grid_input[min_r][c] == 0:
                    grid_output[min_r][c] = color
                if grid_input[max_r][c] == 0:
                    grid_output[max_r][c] = color
            
            for r in range(min_r, max_r + 1):
                if grid_input[r][min_c] == 0:
                    grid_output[r][min_c] = color
                if grid_input[r][max_c] == 0:
                    grid_output[r][max_c] = color
        
        if grid_input != grid_output:
            return {"input": grid_input, "output": grid_output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    w = len(input_list[0])
    h = len(input_list)
    
    colors = set()
    for r in range(h):
        for c in range(w):
            if input_list[r][c] != 0:
                colors.add(input_list[r][c])
    
    colors = sorted(colors)
    output_list = [row[:] for row in input_list]
    
    for color in colors:
        positions = []
        for r in range(h):
            for c in range(w):
                if input_list[r][c] == color:
                    positions.append((r, c))
        
        if not positions:
            continue
        
        min_r = min(r for r, _ in positions)
        max_r = max(r for r, _ in positions)
        min_c = min(c for _, c in positions)
        max_c = max(c for _, c in positions)
        
        for c in range(min_c, max_c + 1):
            if input_list[min_r][c] == 0:
                output_list[min_r][c] = color
            if input_list[max_r][c] == 0:
                output_list[max_r][c] = color
        
        for r in range(min_r, max_r + 1):
            if input_list[r][min_c] == 0:
                output_list[r][min_c] = color
            if input_list[r][max_c] == 0:
                output_list[r][max_c] = color
    
    return output_list
