# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 053ba1af
Difficulty: hard

=== Tags ===
- Multi step traversal
- Assemble from parts
- Rule embedding
- Reactive surface

=== Description ===
Input grids are large (20×20) grids with a background color (0) and multiple
contiguous colored regions ("parts") each defined by a unique color (1–9).
Embedded within the top-left 3×3 subgrid is a rule matrix where each cell's
color encodes a transformation rule. For a part of color `c`, the transformation
rule is determined by the cell at position `(c % 3, c // 3)` in the matrix
(e.g., part color 5 uses the rule from matrix cell (2, 1)). Each part undergoes
a multi-step transformation sequence (e.g., rotation, reflection, or spatial
shift) based on its color's rule, applied iteratively across the part's cells.
The transformation is reactive: intermediate states during traversal affect
subsequent steps (e.g., a cell's new state depends on its neighbors after each
step). After full transformation, parts are assembled into the output grid with
top-left corners aligned to their original positions, avoiding overlaps. The
rule matrix is non-obvious, requiring solvers to infer transformation sequences
from input-output pairs. The "reactive surface" manifests as context-dependent
changes during traversal, where the transformation of one cell directly
influences adjacent cells' transformations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import continuous_creature

# Generator for ARC task 436

def generate():
    GRID = 20

    def rects_intersect(a, b):
        # a and b are (r0, r1, c0, c1) inclusive
        a_r0, a_r1, a_c0, a_c1 = a
        b_r0, b_r1, b_c0, b_c1 = b
        return not (a_r1 < b_r0 or b_r1 < a_r0 or a_c1 < b_c0 or b_c1 < a_c0)

    # Try until we produce an input != output
    for attempt in range(100):
        # Initialize empty input grid
        input_grid = [[0 for _ in range(GRID)] for _ in range(GRID)]

        # Create a 3x3 rule matrix (values 1..9)
        rule_matrix = [[random.randint(1, 9) for _ in range(3)] for _ in range(3)]

        # Place rule matrix into top-left 3x3 of the input grid
        for r in range(3):
            for c in range(3):
                input_grid[r][c] = rule_matrix[r][c]

        # Keep track of reserved rectangles so parts don't overlap each other or the rule matrix
        reserved = []
        reserved.append((0, 2, 0, 2))  # top-left 3x3 reserved for rule matrix

        parts_info = {}  # color -> dict with anchor and local pixels

        success_place_all = True

        # Place nine colored contiguous parts (colors 1..9) avoiding the top-left 3x3
        for color in range(1, 10):
            placed = False
            # Try many anchors/sizes until one fits
            for _ in range(300):
                box_h = random.randint(3, 6)
                box_w = random.randint(3, 6)
                # limit size so the creature isn't the full box always
                max_pixels = box_h * box_w - 1
                if max_pixels < 2:
                    continue
                size = random.randint(2, max_pixels)

                # create a contiguous creature in local coordinates
                local_pixels = continuous_creature(size, box_w, box_h)

                # choose an anchor so the whole box lies within grid and outside top-left area
                anchor_r = random.randint(3, GRID - box_h)
                anchor_c = random.randint(3, GRID - box_w)

                # rectangle for this box
                rect = (anchor_r, anchor_r + box_h - 1, anchor_c, anchor_c + box_w - 1)

                # check collision with reserved
                collision = False
                for res in reserved:
                    if rects_intersect(rect, res):
                        collision = True
                        break
                if collision:
                    continue

                # Place pixels for this color into the input grid
                for (lr, lc) in local_pixels:
                    if 0 <= lr < box_h and 0 <= lc < box_w:
                        input_grid[anchor_r + lr][anchor_c + lc] = color

                # record placed rectangle
                reserved.append(rect)
                parts_info[color] = {
                    "tentative_anchor": (anchor_r, anchor_c),
                    "box_h": box_h,
                    "box_w": box_w,
                }
                placed = True
                break

            if not placed:
                success_place_all = False
                break

        if not success_place_all:
            # try again from scratch
            continue

        # Now recompute the exact bounding boxes from the actual placed pixels
        # so solver and generator will derive the same anchors and sizes.
        exact_parts = {}
        for color in range(1, 10):
            coords = []
            for r in range(3, GRID):
                for c in range(3, GRID):
                    if input_grid[r][c] == color:
                        coords.append((r, c))
            if not coords:
                continue
            min_r = min(p[0] for p in coords)
            max_r = max(p[0] for p in coords)
            min_c = min(p[1] for p in coords)
            max_c = max(p[1] for p in coords)
            h = max_r - min_r + 1
            w = max_c - min_c + 1
            bitmap = [[0 for _ in range(w)] for _ in range(h)]
            for (r, c) in coords:
                bitmap[r - min_r][c - min_c] = 1
            exact_parts[color] = {"anchor": (min_r, min_c), "h": h, "w": w, "bitmap": bitmap}

        # Define transformation rules applied inside each part's bounding box
        def apply_rule_inplace(bitmap, rule_id, steps):
            H = len(bitmap)
            W = len(bitmap[0]) if H > 0 else 0

            def get_val(g, r, c):
                if r < 0 or r >= H or c < 0 or c >= W:
                    return 0
                return g[r][c]

            for _ in range(max(1, rule_id)):
                if rule_id == 1:
                    # sweep right (left-to-right, reactive)
                    for r in range(H):
                        for c in range(0, W - 1):
                            if bitmap[r][c] == 1 and bitmap[r][c + 1] == 0:
                                bitmap[r][c] = 0
                                bitmap[r][c + 1] = 1
                elif rule_id == 2:
                    # sweep left (right-to-left)
                    for r in range(H):
                        for c in range(W - 1, 0, -1):
                            if bitmap[r][c] == 1 and bitmap[r][c - 1] == 0:
                                bitmap[r][c] = 0
                                bitmap[r][c - 1] = 1
                elif rule_id == 3:
                    # sweep down (top-to-bottom)
                    for r in range(0, H - 1):
                        for c in range(W):
                            if bitmap[r][c] == 1 and bitmap[r + 1][c] == 0:
                                bitmap[r][c] = 0
                                bitmap[r + 1][c] = 1
                elif rule_id == 4:
                    # sweep up (bottom-to-top)
                    for r in range(H - 1, 0, -1):
                        for c in range(W):
                            if bitmap[r][c] == 1 and bitmap[r - 1][c] == 0:
                                bitmap[r][c] = 0
                                bitmap[r - 1][c] = 1
                elif rule_id == 5:
                    # expand: fill empty cells that have at least one 8-neighbor filled (reactive)
                    for r in range(H):
                        for c in range(W):
                            if bitmap[r][c] == 0:
                                found = False
                                for dr in (-1, 0, 1):
                                    for dc in (-1, 0, 1):
                                        if dr == 0 and dc == 0:
                                            continue
                                        if get_val(bitmap, r + dr, c + dc) == 1:
                                            found = True
                                            break
                                    if found:
                                        break
                                if found:
                                    bitmap[r][c] = 1
                elif rule_id == 6:
                    # erode: remove cells with fewer than 2 orthogonal neighbors (reactive)
                    for r in range(H):
                        for c in range(W):
                            if bitmap[r][c] == 1:
                                neigh = 0
                                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                                    if get_val(bitmap, r + dr, c + dc) == 1:
                                        neigh += 1
                                if neigh < 2:
                                    bitmap[r][c] = 0
                elif rule_id == 7:
                    # diagonal down-right slide (reactive)
                    for r in range(0, H - 1):
                        for c in range(0, W - 1):
                            if bitmap[r][c] == 1 and bitmap[r + 1][c + 1] == 0:
                                bitmap[r][c] = 0
                                bitmap[r + 1][c + 1] = 1
                elif rule_id == 8:
                    # reflect left-right (simultaneous copy)
                    new = [[0 for _ in range(W)] for _ in range(H)]
                    for r in range(H):
                        for c in range(W):
                            new[r][c] = bitmap[r][W - 1 - c]
                    bitmap[:] = new
                elif rule_id == 9:
                    # rotate 180 (simultaneous copy)
                    new = [[0 for _ in range(W)] for _ in range(H)]
                    for r in range(H):
                        for c in range(W):
                            new[r][c] = bitmap[H - 1 - r][W - 1 - c]
                    bitmap[:] = new
                else:
                    # unknown rule -> no-op
                    pass

        # Build the output by transforming each part inside its bounding box and placing it back
        output_grid = [[0 for _ in range(GRID)] for _ in range(GRID)]
        for color, info in exact_parts.items():
            anchor_r, anchor_c = info["anchor"]
            h, w = info["h"], info["w"]
            # copy local bitmap so we don't change the input representation
            local = [row[:] for row in info["bitmap"]]

            # determine rule index mapping: map color -> matrix cell
            # We map colors 1..9 to rule_matrix rows/cols as row=(color-1)//3, col=(color-1)%3
            rule_r = (color - 1) // 3
            rule_c = (color - 1) % 3
            rule_id = rule_matrix[rule_r][rule_c]

            # apply the rule rule_id, rule_id times (ensures multi-step behavior)
            apply_rule_inplace(local, rule_id, rule_id)

            # place into output anchored at the same top-left
            for lr in range(h):
                for lc in range(w):
                    if local[lr][lc] == 1:
                        output_grid[anchor_r + lr][anchor_c + lc] = color

        # Ensure input and output are not identical
        if input_grid == output_grid:
            # try again
            continue

        return {"input": input_grid, "output": output_grid}

    # Fallback (should not normally happen)
    raise RuntimeError("Failed to generate a valid example")



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid_in = [list(row) for row in input_grid]
    GRID = len(grid_in)

    # read rule matrix from top-left 3x3
    rule_matrix = [[grid_in[r][c] for c in range(3)] for r in range(3)]

    # helper: find parts of each color ignoring top-left 3x3
    parts = {}
    for color in range(1, 10):
        coords = []
        for r in range(3, GRID):
            for c in range(3, GRID):
                if grid_in[r][c] == color:
                    coords.append((r, c))
        if not coords:
            continue
        min_r = min(p[0] for p in coords)
        max_r = max(p[0] for p in coords)
        min_c = min(p[1] for p in coords)
        max_c = max(p[1] for p in coords)
        h = max_r - min_r + 1
        w = max_c - min_c + 1
        bitmap = [[0 for _ in range(w)] for _ in range(h)]
        for (r, c) in coords:
            bitmap[r - min_r][c - min_c] = 1
        parts[color] = {"anchor": (min_r, min_c), "h": h, "w": w, "bitmap": bitmap}

    # same transformation logic as generator
    def apply_rule_inplace(bitmap, rule_id, steps):
        H = len(bitmap)
        W = len(bitmap[0]) if H > 0 else 0

        def get_val(g, r, c):
            if r < 0 or r >= H or c < 0 or c >= W:
                return 0
            return g[r][c]

        for _ in range(max(1, rule_id)):
            if rule_id == 1:
                for r in range(H):
                    for c in range(0, W - 1):
                        if bitmap[r][c] == 1 and bitmap[r][c + 1] == 0:
                            bitmap[r][c] = 0
                            bitmap[r][c + 1] = 1
            elif rule_id == 2:
                for r in range(H):
                    for c in range(W - 1, 0, -1):
                        if bitmap[r][c] == 1 and bitmap[r][c - 1] == 0:
                            bitmap[r][c] = 0
                            bitmap[r][c - 1] = 1
            elif rule_id == 3:
                for r in range(0, H - 1):
                    for c in range(W):
                        if bitmap[r][c] == 1 and bitmap[r + 1][c] == 0:
                            bitmap[r][c] = 0
                            bitmap[r + 1][c] = 1
            elif rule_id == 4:
                for r in range(H - 1, 0, -1):
                    for c in range(W):
                        if bitmap[r][c] == 1 and bitmap[r - 1][c] == 0:
                            bitmap[r][c] = 0
                            bitmap[r - 1][c] = 1
            elif rule_id == 5:
                for r in range(H):
                    for c in range(W):
                        if bitmap[r][c] == 0:
                            found = False
                            for dr in (-1, 0, 1):
                                for dc in (-1, 0, 1):
                                    if dr == 0 and dc == 0:
                                        continue
                                    if get_val(bitmap, r + dr, c + dc) == 1:
                                        found = True
                                        break
                                if found:
                                    break
                            if found:
                                bitmap[r][c] = 1
            elif rule_id == 6:
                for r in range(H):
                    for c in range(W):
                        if bitmap[r][c] == 1:
                            neigh = 0
                            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                                if get_val(bitmap, r + dr, c + dc) == 1:
                                    neigh += 1
                            if neigh < 2:
                                bitmap[r][c] = 0
            elif rule_id == 7:
                for r in range(0, H - 1):
                    for c in range(0, W - 1):
                        if bitmap[r][c] == 1 and bitmap[r + 1][c + 1] == 0:
                            bitmap[r][c] = 0
                            bitmap[r + 1][c + 1] = 1
            elif rule_id == 8:
                new = [[0 for _ in range(W)] for _ in range(H)]
                for r in range(H):
                    for c in range(W):
                        new[r][c] = bitmap[r][W - 1 - c]
                bitmap[:] = new
            elif rule_id == 9:
                new = [[0 for _ in range(W)] for _ in range(H)]
                for r in range(H):
                    for c in range(W):
                        new[r][c] = bitmap[H - 1 - r][W - 1 - c]
                bitmap[:] = new
            else:
                pass

    # build output
    output = [[0 for _ in range(GRID)] for _ in range(GRID)]
    for color, info in parts.items():
        anchor_r, anchor_c = info["anchor"]
        local = [row[:] for row in info["bitmap"]]
        rule_r = (color - 1) // 3
        rule_c = (color - 1) % 3
        rule_id = rule_matrix[rule_r][rule_c]
        apply_rule_inplace(local, rule_id, rule_id)
        h = info["h"]
        w = info["w"]
        for lr in range(h):
            for lc in range(w):
                if local[lr][lc] == 1:
                    output[anchor_r + lr][anchor_c + lc] = color

    return output

