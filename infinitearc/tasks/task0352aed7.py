# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 0352aed7
Difficulty: insane

=== Tags ===
- Substitution rule discovery
- Beam reflection
- Pattern to sequence mapping
- Rule based tiling
- Pattern deconstruction

=== Description ===
Beam Reflection Tiling  Input grids are rectangular (15×15 to 25×25) with a
uniform background (color 0). The grid contains a dense arrangement of colored
tiles (colors 1–9) forming an irregular pattern, each tile representing a unique
reflection behavior. The exact mapping between tile color and reflection rule
(e.g., "color 1: 90° clockwise reflection", "color 2: 90° counterclockwise",
"color 3: beam absorption") is not given and must be deduced from input-output
examples. A single "beam origin" cell is positioned on the grid's perimeter
(e.g., top edge at column 10), emitting a beam traveling inward along the grid's
axis. The beam moves straight until intersecting a tile, then reflects according
to that tile's color rule. The process repeats until the beam is absorbed or
exits the grid boundary.  The output grid retains all input tiles but recolors
the beam's path segments. Each segment (from one reflection point to the next)
is colored using the tile color at the reflection point. If a tile absorbs the
beam (color 3), the path terminates there. The path must be traced precisely,
with reflection angles determined by the deduced substitution rules. The task
requires layered reasoning: first discovering the color-reflection mapping
(substitution rule discovery), then simulating the beam's trajectory through the
tile pattern (beam reflection), and finally mapping the path sequence to the
output grid's tiling (pattern to sequence mapping). The "insane" difficulty
arises from the need to reverse-engineer multiple non-intuitive reflection rules
from sparse examples, while ensuring the path adheres to geometric constraints
(no diagonal movement, strict 90° reflection angles) and the output remains
consistent with all rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Choose a random size within the specified range
    width = random.randint(15, 25)
    height = random.randint(15, 25)
    inp = grid(width, height, 0)

    # Fill the grid with a fairly dense, irregular pattern of tiles (colors 1..9)
    prob = random.uniform(0.28, 0.55)
    for r in range(height):
        for c in range(width):
            if random.random() < prob:
                inp[r][c] = random.randint(1, 9)

    # Place the beam origin at the top-center cell and ensure it's background (0)
    start_r = 0
    start_c = width // 2
    inp[start_r][start_c] = 0

    # Ensure there is at least one tile in the start column below the origin
    if not any(inp[r][start_c] != 0 for r in range(1, height)):
        rr = random.randint(1, height - 1)
        inp[rr][start_c] = random.randint(1, 9)

    # Reflection rule mapping (fixed for generator)
    def reflect(color, dr, dc):
        # color 9 absorbs
        if color == 9:
            return None
        # 1-3: rotate clockwise 90 degrees
        if color in (1, 2, 3):
            return (dc, -dr)
        # 4-6: rotate counterclockwise 90 degrees
        if color in (4, 5, 6):
            return (-dc, dr)
        # 7-8: reverse direction 180 degrees
        if color in (7, 8):
            return (-dr, -dc)
        # fallback
        return (dc, -dr)

    # Simulate the beam and paint the output grid accordingly
    out = [row[:] for row in inp]
    r, c = start_r, start_c
    dr, dc = 1, 0  # beam goes downward from the top edge
    prev_tile_color = None

    while True:
        # Walk forward to find the next tile or the boundary
        cr, cc = r, c
        path = []  # background cells between current pos and next tile/boundary
        collided = False
        tile_color = None

        while True:
            cr += dr
            cc += dc
            if cr < 0 or cr >= height or cc < 0 or cc >= width:
                break
            if inp[cr][cc] != 0:
                collided = True
                tile_color = inp[cr][cc]
                break
            path.append((cr, cc))

        # If current cell is background (origin or empty cell), include it in the segment
        if inp[r][c] == 0:
            path.insert(0, (r, c))

        if not collided:
            # Beam exits the grid; color the final segment with the previous tile color (if any)
            if prev_tile_color is not None:
                for pr, pc in path:
                    # never overwrite original tiles
                    if inp[pr][pc] == 0:
                        out[pr][pc] = prev_tile_color
            break

        # Paint the segment (do not overwrite original tiles)
        for pr, pc in path:
            if inp[pr][pc] == 0:
                out[pr][pc] = tile_color

        prev_tile_color = tile_color
        # If this tile absorbs, terminate
        if tile_color == 9:
            break

        # Move beam to the tile cell and reflect
        r, c = cr, cc
        new_dir = reflect(tile_color, dr, dc)
        if new_dir is None:
            break
        dr, dc = new_dir

    return {"input": inp, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(grid):
    # Convert tuple-of-tuples to a mutable list-of-lists
    inp = [list(row) for row in grid]
    height = len(inp)
    width = len(inp[0]) if height > 0 else 0
    out = [row[:] for row in inp]

    # Beam origin is at the top-center and beam initially travels downward
    r, c = 0, width // 2
    dr, dc = 1, 0

    def reflect(color, dr, dc):
        if color == 9:
            return None
        if color in (1, 2, 3):
            return (dc, -dr)
        if color in (4, 5, 6):
            return (-dc, dr)
        if color in (7, 8):
            return (-dr, -dc)
        return (dc, -dr)

    prev_tile_color = None

    while True:
        cr, cc = r, c
        path = []
        collided = False
        tile_color = None

        while True:
            cr += dr
            cc += dc
            if cr < 0 or cr >= height or cc < 0 or cc >= width:
                break
            if inp[cr][cc] != 0:
                collided = True
                tile_color = inp[cr][cc]
                break
            path.append((cr, cc))

        # include current cell if it's background
        if inp[r][c] == 0:
            path.insert(0, (r, c))

        if not collided:
            if prev_tile_color is not None:
                for pr, pc in path:
                    if inp[pr][pc] == 0:
                        out[pr][pc] = prev_tile_color
            break

        for pr, pc in path:
            if inp[pr][pc] == 0:
                out[pr][pc] = tile_color

        prev_tile_color = tile_color
        if tile_color == 9:
            break

        r, c = cr, cc
        new_dir = reflect(tile_color, dr, dc)
        if new_dir is None:
            break
        dr, dc = new_dir

    return out

