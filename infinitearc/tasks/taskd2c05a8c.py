# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: d2c05a8c
Difficulty: very hard

=== Tags ===
- Terrain erosion
- Reflect by color
- Mirrored attribute binding
- Pattern translation

=== Description ===
Input grids depict a landscape composed of colored terrain cells, where each
color represents a distinct terrain type. Colors 1 through 4 function as erosion
agents, each propagating erosion in a fixed cardinal direction (color 1: east,
color 2: west, color 3: north, color 4: south). Colors 5 through 8 act as mirror
boundaries, with each color binding to a specific reflection rule (color 5:
horizontal reflection, color 6: vertical reflection, color 7: diagonal
reflection, color 8: 90Â° rotation). Color 9 represents resistant terrain that
halts erosion propagation. The background (color 0) is non-erodible.  The output
grid is generated by simulating erosion propagation from all agents. Each
agent's erosion spreads cell-by-cell in its designated direction until
encountering a mirror boundary or resistant terrain. Upon contact with a mirror
boundary, the erosion direction is reflected according to the boundary's color
attribute, and the erosion color updates to match the boundary's color. Erosion
continues with the new color and direction until it stops at resistant terrain,
a mirror boundary, or the grid edge. Cells affected by erosion display their
final erosion color, while the original mirror boundaries and resistant terrain
remain visible. Background cells (color 0) retain their color unless eroded.
This process requires tracking multiple overlapping erosion paths, color changes
upon reflection, and directional reflection rules, making the task highly
complex and requiring deep spatial reasoning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

# Global store to ensure uniqueness across multiple generate() calls
_GENERATED_PAIRS = set()


def _reflect_dir(dr, dc, mirror_color):
    # Mirror behaviors (cardinal directions only)
    # dr: row delta, dc: col delta
    if mirror_color == 5:
        # horizontal reflection: reflect across horizontal axis -> flip vertical component
        return -dr, dc
    if mirror_color == 6:
        # vertical reflection: reflect across vertical axis -> flip horizontal component
        return dr, -dc
    if mirror_color == 7:
        # diagonal reflection across main diagonal (r,c) -> (c,r)
        return dc, dr
    if mirror_color == 8:
        # 90 degree clockwise rotation
        return dc, -dr
    return dr, dc


def generate():
    global _GENERATED_PAIRS

    # Try multiple times to produce a unique, non-trivial pair
    for attempt in range(1000):
        # Size chosen moderately to allow interesting paths but remain fast
        width = random.randint(6, 14)
        height = random.randint(6, 14)
        all_cells = [(r, c) for r in range(height) for c in range(width)]

        # Start with all background
        grid_input = [[0 for _ in range(width)] for _ in range(height)]

        # Place some resistant terrain (9)
        max_res = min(10, max(3, (width * height) // 12))
        num_resistant = random.randint(3, max_res)
        resistant_cells = random.sample(all_cells, num_resistant)
        for (r, c) in resistant_cells:
            grid_input[r][c] = 9

        # Direction map for agents (1..4)
        dir_map = {1: (0, 1), 2: (0, -1), 3: (-1, 0), 4: (1, 0)}

        # Place agents (colors 1..4). Ensure at least one agent can move at least one cell.
        agents = []
        max_agents = min(4, max(1, (width * height) // 30 + 1))
        num_agents = random.randint(1, max_agents)

        # Candidate empty cells to place agents (not resistant)
        empty_cells = [(r, c) for (r, c) in all_cells if grid_input[r][c] == 0]
        random.shuffle(empty_cells)

        for _ in range(num_agents):
            placed = False
            # Try to find a starting cell where the agent can step forward (not off-grid and not immediately blocked by 9)
            for _ in range(len(empty_cells)):
                if not empty_cells:
                    break
                r, c = empty_cells.pop()
                color = random.randint(1, 4)
                dr, dc = dir_map[color]
                nr, nc = r + dr, c + dc
                if not (0 <= nr < height and 0 <= nc < width):
                    # avoid placing agent that immediately goes off-grid
                    continue
                if grid_input[nr][nc] == 9:
                    # avoid immediate blocker
                    continue
                # Accept this position
                grid_input[r][c] = color
                agents.append((r, c, color))
                placed = True
                break
            if not placed:
                # Fallback: place wherever available (rare)
                if empty_cells:
                    r, c = empty_cells.pop()
                    color = random.randint(1, 4)
                    grid_input[r][c] = color
                    agents.append((r, c, color))

        if not agents:
            # ensure at least one agent exists
            r, c = random.choice(all_cells)
            grid_input[r][c] = 1
            agents = [(r, c, 1)]

        # Sort agents by position (row-major). This ensures a canonical processing order
        agents.sort(key=lambda x: (x[0], x[1]))

        # Place mirrors (5..8) along agent paths to create reflections.
        # For each agent we attempt to place a small number of mirrors along its forward trajectory.
        for (ar, ac, acolor) in agents:
            dr, dc = dir_map[acolor]
            cur_r, cur_c = ar, ac
            # choose how many mirrors to attempt to place along this agent's future path
            mirror_attempts = random.randint(0, 3)
            steps = 0
            while mirror_attempts > 0 and steps < (width * height):
                steps += 1
                # Walk forward until an empty cell is found (0) where we can place a mirror,
                # or until we hit a resistant cell or another non-empty cell.
                nr, nc = cur_r + dr, cur_c + dc
                found = None
                while 0 <= nr < height and 0 <= nc < width:
                    if grid_input[nr][nc] == 0:
                        found = (nr, nc)
                        break
                    if grid_input[nr][nc] == 9:
                        # blocked by resistant terrain; stop placing mirrors along this ray
                        break
                    # if we encounter any other non-zero (agent or existing mirror), we do not place on top
                    # and treat it as a blocking element for placing new mirrors in front of it
                    if grid_input[nr][nc] != 0:
                        break
                    nr += dr
                    nc += dc
                if not found:
                    break
                mr, mc = found
                mirror_color = random.randint(5, 8)
                grid_input[mr][mc] = mirror_color
                # after placing a mirror, update direction as if the agent would reflect there
                dr, dc = _reflect_dir(dr, dc, mirror_color)
                cur_r, cur_c = mr, mc
                mirror_attempts -= 1

        # Simulate erosion from all agents in the sorted order to produce the output grid
        grid_output = [row[:] for row in grid_input]
        step_limit = width * height * 4

        for (ar, ac, acolor) in agents:
            cur_r, cur_c = ar, ac
            cur_color = acolor
            dr, dc = dir_map[acolor]
            steps = 0
            while 0 <= cur_r < height and 0 <= cur_c < width and steps < step_limit:
                steps += 1
                # Erode the current cell (write current erosion color). Mirror/resistant cells keep their color
                grid_output[cur_r][cur_c] = cur_color

                nr, nc = cur_r + dr, cur_c + dc
                if not (0 <= nr < height and 0 <= nc < width):
                    break
                next_color = grid_input[nr][nc]
                if next_color == 9:
                    # Resistant terrain halts propagation
                    break
                if next_color in (5, 6, 7, 8):
                    # Reflect at the mirror, update erosion color to the mirror's color, step into mirror
                    cur_color = next_color
                    dr, dc = _reflect_dir(dr, dc, next_color)
                    cur_r, cur_c = nr, nc
                else:
                    # Move forward without color-change
                    cur_r, cur_c = nr, nc

        # Ensure output differs from input and the pair was not generated before
        key = (tuple(tuple(row) for row in grid_input), tuple(tuple(row) for row in grid_output))
        if key in _GENERATED_PAIRS:
            continue
        if grid_input == grid_output:
            # trivial, try again
            continue

        _GENERATED_PAIRS.add(key)
        return {"input": grid_input, "output": grid_output}

    # Fallback (should not normally happen) - produce a tiny fixed non-trivial example
    width, height = 6, 6
    grid_input = [[0 for _ in range(width)] for _ in range(height)]
    grid_input[2][1] = 1
    grid_input[2][3] = 5
    grid_input[2][5] = 9
    grid_output = [row[:] for row in grid_input]
    # Simple simulated erosion
    grid_output[2][1] = 1
    grid_output[2][2] = 1
    grid_output[2][3] = 5
    _GENERATED_PAIRS.add((tuple(tuple(row) for row in grid_input), tuple(tuple(row) for row in grid_output)))
    return {"input": grid_input, "output": grid_output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid_input = [list(row) for row in input_grid]
    height = len(grid_input)
    width = len(grid_input[0]) if height > 0 else 0

    # Direction map for agents (1..4)
    dir_map = {1: (0, 1), 2: (0, -1), 3: (-1, 0), 4: (1, 0)}

    def _reflect_dir(dr, dc, mirror_color):
        if mirror_color == 5:
            return -dr, dc
        if mirror_color == 6:
            return dr, -dc
        if mirror_color == 7:
            return dc, dr
        if mirror_color == 8:
            return dc, -dr
        return dr, dc

    # Collect agents in row-major order (so ordering matches generator's canonical ordering)
    agents = []
    for r in range(height):
        for c in range(width):
            v = grid_input[r][c]
            if 1 <= v <= 4:
                agents.append((r, c, v))

    # Prepare output as a copy of input and simulate agents sequentially
    grid_output = [row[:] for row in grid_input]
    step_limit = max(1, width * height * 4)

    for (ar, ac, acolor) in agents:
        cur_r, cur_c = ar, ac
        cur_color = acolor
        dr, dc = dir_map[acolor]
        steps = 0
        while 0 <= cur_r < height and 0 <= cur_c < width and steps < step_limit:
            steps += 1
            grid_output[cur_r][cur_c] = cur_color

            nr, nc = cur_r + dr, cur_c + dc
            if not (0 <= nr < height and 0 <= nc < width):
                break
            next_color = grid_input[nr][nc]
            if next_color == 9:
                break
            if next_color in (5, 6, 7, 8):
                cur_color = next_color
                dr, dc = _reflect_dir(dr, dc, next_color)
                cur_r, cur_c = nr, nc
            else:
                cur_r, cur_c = nr, nc

    # Return as an immutable tuple of tuples
    return tuple(tuple(row) for row in grid_output)

