# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 0f485c72
Difficulty: easy

=== Tags ===
- Detect wall
- Color by distance to a single point
- Row parity coloring
- Maze

=== Description ===
The input grid represents a maze where walls (non-zero values) and paths (zero
values) are present. The output grid retains the walls as black (0), while path
cells are colored based on two factors: their Manhattan distance from the grid's
center and the parity of their row index. For path cells in even-indexed rows,
cells at even distances from the center are colored blue (1), and odd distances
are green (2). For path cells in odd-indexed rows, even distances are red (3),
and odd distances are yellow (4). This creates a visually distinct pattern where
the coloring alternates in a way that depends on both the cell's position
relative to the center and its row's parity, making the rule discoverable
through simple observation of a few examples.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    input_grid = [[0] * width for _ in range(height)]
    
    max_walls = width * height - 1
    if max_walls > 0:
        num_walls = random.randint(1, min((width * height) // 2, max_walls))
        for _ in range(num_walls):
            r = random.randint(0, height-1)
            c = random.randint(0, width-1)
            if input_grid[r][c] == 0:
                input_grid[r][c] = random.randint(1, 9)
    
    output_grid = [[0] * width for _ in range(height)]
    center_r = height // 2
    center_c = width // 2
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                distance = abs(r - center_r) + abs(c - center_c)
                if r % 2 == 0:
                    output_grid[r][c] = 1 if distance % 2 == 0 else 2
                else:
                    output_grid[r][c] = 3 if distance % 2 == 0 else 4
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = [[0] * width for _ in range(height)]
    center_r = height // 2
    center_c = width // 2
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                distance = abs(r - center_r) + abs(c - center_c)
                if r % 2 == 0:
                    output_grid[r][c] = 1 if distance % 2 == 0 else 2
                else:
                    output_grid[r][c] = 3 if distance % 2 == 0 else 4
    
    return output_grid
