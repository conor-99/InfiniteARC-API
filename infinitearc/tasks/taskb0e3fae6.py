# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: b0e3fae6
Difficulty: easy

=== Tags ===
- Loop filling
- Out of boundary

=== Description ===
The input grid contains a closed rectangular loop formed by a single color
(e.g., color 1) that encloses an empty region within the grid. The loop does not
touch the grid boundaries, ensuring the enclosed area is a single contiguous
region. The output grid replaces all pixels inside this loop with a distinct
color (e.g., color 2), while preserving the loop's original color and all other
grid elements unchanged. This transformation requires identifying the enclosed
region bounded by the loop and filling it uniformly, with no additional
transformations applied.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = grid(width, height, 0)
    t = random.randint(1, height-4)
    b = random.randint(t+2, height-2)
    l = random.randint(1, width-4)
    r = random.randint(l+2, width-2)
    
    for c in range(l, r+1):
        input_grid[t][c] = 1
        input_grid[b][c] = 1
    for row in range(t, b+1):
        input_grid[row][l] = 1
        input_grid[row][r] = 1
    
    output_grid = [row[:] for row in input_grid]
    for row in range(t+1, b):
        for col in range(l+1, r):
            output_grid[row][col] = 2
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    rows = len(input_grid)
    cols = len(input_grid[0])
    ones = []
    for r in range(rows):
        for c in range(cols):
            if input_grid[r][c] == 1:
                ones.append((r, c))
    if not ones:
        return input_grid
    min_r = min(r for r, c in ones)
    max_r = max(r for r, c in ones)
    min_c = min(c for r, c in ones)
    max_c = max(c for r, c in ones)
    
    output = [list(row) for row in input_grid]
    for r in range(min_r+1, max_r):
        for c in range(min_c+1, max_c):
            output[r][c] = 2
    return output
