# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 7239dda6
Difficulty: insane

=== Tags ===
- Pixel shader execution
- Adapt image to grid
- Bridges

=== Description ===
The input grid features multiple disconnected regions of distinct colors, each
separated by background (zero) pixels. These regions represent isolated
"islands" within the grid. The task requires adapting the input to form a single
connected structure by adding bridges between these islands. Bridges are
straight or minimal-path connections of a fixed color (color 5) drawn between
the closest points of consecutive regions. Regions are ordered by their top-
leftmost pixel coordinates (row-major order), and the shortest path (moving only
horizontally/vertically through background pixels) is used to connect each pair
sequentially. The bridges must avoid overlapping existing regions and ensure all
regions become part of one cohesive component in the output grid. This
transformation requires precise spatial reasoning to determine optimal bridge
placements while maintaining visual consistency and adhering to the fixed bridge
color.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    grid_input = [[0] * width for _ in range(height)]
    
    num_regions = random.randint(2, 5)
    colors = list(range(1, 5)) + list(range(6, 10))
    random.shuffle(colors)
    region_colors = colors[:num_regions]
    
    regions = []
    
    def is_adjacent(r, c):
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and grid_input[nr][nc] != 0:
                return True
        return False

    def generate_region(color):
        while True:
            r_start = random.randint(0, height - 1)
            c_start = random.randint(0, width - 1)
            if not is_adjacent(r_start, c_start):
                break
        size = random.randint(3, 5)
        region_pixels = []
        stack = [(r_start, c_start)]
        region_pixels.append((r_start, c_start))
        grid_input[r_start][c_start] = color
        while len(region_pixels) < size:
            if not stack:
                break
            r, c = stack.pop()
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid_input[nr][nc] == 0:
                    grid_input[nr][nc] = color
                    region_pixels.append((nr, nc))
                    stack.append((nr, nc))
                    if len(region_pixels) >= size:
                        break
        return region_pixels
    
    for color in region_colors:
        region_pixels = generate_region(color)
        regions.append(region_pixels)
    
    regions.sort(key=lambda r: (min(p[0] for p in r), min(p[1] for p in r)))
    
    grid_output = [row[:] for row in grid_input]
    
    def bfs(start, end, grid, width, height):
        visited = [[False] * width for _ in range(height)]
        parent = {}
        queue = [start]
        visited[start[0]][start[1]] = True
        while queue:
            r, c = queue.pop(0)
            if (r, c) == end:
                break
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == 0:
                    visited[nr][nc] = True
                    parent[(nr, nc)] = (r, c)
                    queue.append((nr, nc))
        else:
            return None
        path = []
        current = end
        while current != start:
            path.append(current)
            current = parent.get(current, None)
            if current is None:
                break
        path.append(start)
        return path[::-1]
    
    for i in range(len(regions) - 1):
        region1 = regions[i]
        region2 = regions[i + 1]
        
        # Find 0 neighbors of region1
        neighbors1 = set()
        for r, c in region1:
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid_input[nr][nc] == 0:
                    neighbors1.add((nr, nc))
        
        # Find 0 neighbors of region2
        neighbors2 = set()
        for r, c in region2:
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid_input[nr][nc] == 0:
                    neighbors2.add((nr, nc))
        
        if not neighbors1 or not neighbors2:
            continue
        
        # Sort neighbors to ensure deterministic selection
        neighbors1 = sorted(neighbors1, key=lambda x: (x[0], x[1]))
        neighbors2 = sorted(neighbors2, key=lambda x: (x[0], x[1]))
        
        # Find closest pair between neighbors1 and neighbors2
        closest_pair = None
        min_dist = float('inf')
        for p1 in neighbors1:
            for p2 in neighbors2:
                dist = abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])
                if dist < min_dist:
                    min_dist = dist
                    closest_pair = (p1, p2)
        p1, p2 = closest_pair
        
        path = bfs(p1, p2, grid_input, width, height)
        if path:
            for r, c in path:
                grid_output[r][c] = 5
    
    return {"input": grid_input, "output": grid_output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    
    # Convert input_grid to list of lists if it's a tuple
    if isinstance(input_grid[0], tuple):
        input_grid = [list(row) for row in input_grid]
    
    visited = [[False] * width for _ in range(height)]
    regions = []
    
    def dfs(r, c, color):
        stack = [(r, c)]
        component = []
        visited[r][c] = True
        while stack:
            r, c = stack.pop()
            component.append((r, c))
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                    visited[nr][nc] = True
                    stack.append((nr, nc))
        return component
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and input_grid[r][c] != 0 and input_grid[r][c] != 5:
                color = input_grid[r][c]
                component = dfs(r, c, color)
                regions.append(component)
    
    regions.sort(key=lambda r: (min(p[0] for p in r), min(p[1] for p in r)))
    
    output = [row[:] for row in input_grid]
    
    def bfs(start, end, grid, width, height):
        visited = [[False] * width for _ in range(height)]
        parent = {}
        queue = [start]
        visited[start[0]][start[1]] = True
        while queue:
            r, c = queue.pop(0)
            if (r, c) == end:
                break
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == 0:
                    visited[nr][nc] = True
                    parent[(nr, nc)] = (r, c)
                    queue.append((nr, nc))
        else:
            return None
        path = []
        current = end
        while current != start:
            path.append(current)
            current = parent.get(current, None)
            if current is None:
                break
        path.append(start)
        return path[::-1]
    
    for i in range(len(regions) - 1):
        region1 = regions[i]
        region2 = regions[i + 1]
        
        # Find 0 neighbors of region1
        neighbors1 = set()
        for r, c in region1:
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 0:
                    neighbors1.add((nr, nc))
        
        # Find 0 neighbors of region2
        neighbors2 = set()
        for r, c in region2:
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 0:
                    neighbors2.add((nr, nc))
        
        if not neighbors1 or not neighbors2:
            continue
        
        # Sort neighbors to ensure deterministic selection
        neighbors1 = sorted(neighbors1, key=lambda x: (x[0], x[1]))
        neighbors2 = sorted(neighbors2, key=lambda x: (x[0], x[1]))
        
        # Find closest pair between neighbors1 and neighbors2
        closest_pair = None
        min_dist = float('inf')
        for p1 in neighbors1:
            for p2 in neighbors2:
                dist = abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])
                if dist < min_dist:
                    min_dist = dist
                    closest_pair = (p1, p2)
        p1, p2 = closest_pair
        
        path = bfs(p1, p2, input_grid, width, height)
        if path:
            for r, c in path:
                output[r][c] = 5
    
    return output
