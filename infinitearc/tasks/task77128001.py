# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 77128001
Difficulty: medium–hard

=== Tags ===
- Refraction simulation
- Cooperative rule network

=== Description ===
Task Description: Refractive Path Network  Input grids are large (20×20 or
larger) with a single background color (0). Overlaid on this background are
multiple rectangular blocks of distinct colors (1-9), arranged to form a
continuous path from the left edge to the right edge of the grid. Each block is
separated by at least one background cell, and no two blocks touch. The path is
defined such that a beam traveling rightward from the left edge will encounter a
sequence of blocks, each dictating the beam's direction change upon entry. The
direction change is determined by the block's color: color 1 causes a 90° left
turn, color 2 a 90° right turn, color 3 continues straight, color 4 reverses
direction, and colors 5-9 each correspond to a unique, fixed direction change.
Additionally, the grid contains a color sequence strip along the top edge—a
horizontal sequence of 2×2 blocks (separated by background cells) that defines a
cyclic color pattern (e.g., [2, 4, 1, 3]). In the output grid, beams originate
from background cells immediately left of the path's starting block. Each beam
travels rightward until entering a colored block, where it refracts according to
the block's color and continues in the new direction. The beam's color cycles
through the sequence strip's pattern, starting with the first color in the
sequence for the initial segment (before entering the first block), the second
color for the segment within the first block, and so on. Background cells along
the beam's path are replaced with the current sequence color, while blocks, the
sequence strip, and all other elements remain unchanged. Beams never intersect,
and all paths exit the grid after a finite number of refractions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(20, 30)
    height = random.randint(20, 30)
    grid_input = grid(width, height, 0)
    
    # Create sequence strip at top (rows 0-1)
    seq_colors = random.sample(range(1, 10), random.randint(2, 4))
    current_col = 0
    for i in range(len(seq_colors)):
        color = seq_colors[i % len(seq_colors)]
        if current_col + 1 >= width:
            break
        grid_input[0][current_col] = color
        grid_input[0][current_col+1] = color
        grid_input[1][current_col] = color
        grid_input[1][current_col+1] = color
        current_col += 3
    
    # Create path of blocks in a single row
    path_row = random.randint(5, height-6)
    for c in range(3, width-3, 3):
        if random.random() > 0.2:
            grid_input[path_row][c] = 3  # color 3 for straight path
    
    # Create output grid with beam path
    grid_output = [row[:] for row in grid_input]
    
    # Draw beam path (straight line)
    start_col = 3
    while start_col < width and grid_input[path_row][start_col] == 0:
        start_col += 1
    if start_col >= width:
        start_col = 3
    
    seq_index = 0
    for c in range(start_col-1, width):
        if grid_input[path_row][c] == 0:
            grid_output[path_row][c] = seq_colors[seq_index]
            seq_index = (seq_index + 1) % len(seq_colors)
    
    return {
        "input": grid_input,
        "output": grid_output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    # Extract sequence from top strip (rows 0-1, 2x2 blocks)
    seq_colors = []
    col = 0
    while col < width - 1:
        if grid[0][col] != 0 and grid[0][col+1] != 0:
            seq_colors.append(grid[0][col])
            col += 3
        else:
            col += 1
    if not seq_colors:
        seq_colors = [1, 2, 3]

    # Find path row (first row with blocks after top strip)
    path_row = 10
    for r in range(2, height):
        if any(grid[r][c] != 0 for c in range(width)):
            path_row = r
            break

    # Draw beam path (straight line to right)
    start_col = 0
    for c in range(width):
        if grid[path_row][c] != 0:
            start_col = c - 1
            break
    
    seq_index = 0
    for c in range(start_col, width):
        if grid[path_row][c] == 0:
            grid[path_row][c] = seq_colors[seq_index]
            seq_index = (seq_index + 1) % len(seq_colors)
    
    return grid
