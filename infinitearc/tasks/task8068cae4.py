# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 8068cae4
Difficulty: hard

=== Tags ===
- Count shapes
- Recoloring
- Substitution rule discovery

=== Description ===
The task involves input grids composed of multiple distinct shapes, defined as
4-connected regions of identical non-zero color values. Each shape must be
counted individually, regardless of its size or orientation. The output grid is
generated by applying a color substitution rule that depends solely on the total
number of shapes (N) present in the input grid. The substitution rule for each N
is a fixed permutation of color values, where specific colors are replaced with
others according to a consistent pattern that varies with N. For example, if
N=2, the rule might swap color 3 with color 7; if N=3, it might cycle colors
1→4→9→1. The solver must first identify all shapes by analyzing connected
components (ignoring color differences), count them to determine N, then apply
the corresponding substitution mapping to transform the input grid into the
output grid. This requires recognizing that the substitution pattern changes
with N, not with individual shape properties, and deducing the exact permutation
from the examples. The complexity arises from the need to simultaneously count
shapes, recognize the dependency on N, and infer a non-obvious substitution
pattern from limited examples, especially when shapes are irregular or colors
overlap in visually ambiguous ways.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

substitution_rules = {
    2: {3: 7, 7: 3},
    3: {1: 4, 4: 9, 9: 1},
    4: {2: 5, 5: 7, 7: 8, 8: 2},
    5: {1: 2, 2: 3, 3: 4, 4: 5, 5: 1}
}

def generate():
    N = random.randint(2, 5)
    colors = list(substitution_rules[N].keys())
    random.shuffle(colors)
    grid_size = max(3 * N, random.randint(5, 30))
    input_grid = grid(grid_size, grid_size, 0)
    for i in range(N):
        color = colors[i]
        x, y = 3 * i, 3 * i
        for r in range(x, x + 2):
            for c in range(y, y + 2):
                if r < grid_size and c < grid_size:
                    input_grid[r][c] = color
    output_grid = [row[:] for row in input_grid]
    for r in range(grid_size):
        for c in range(grid_size):
            if input_grid[r][c] in substitution_rules[N]:
                output_grid[r][c] = substitution_rules[N][input_grid[r][c]]
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

substitution_rules = {
    2: {3: 7, 7: 3},
    3: {1: 4, 4: 9, 9: 1},
    4: {2: 5, 5: 7, 7: 8, 8: 2},
    5: {1: 2, 2: 3, 3: 4, 4: 5, 5: 1}
}

def count_components(grid):
    visited = set()
    components = 0
    height = len(grid)
    width = len(grid[0])
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and (r, c) not in visited:
                components += 1
                stack = [(r, c)]
                visited.add((r, c))
                while stack:
                    cr, cc = stack.pop()
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == grid[r][c] and (nr, nc) not in visited:
                            visited.add((nr, nc))
                            stack.append((nr, nc))
    return components

def p(input_grid):
    # Ensure input_grid is list of lists
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    N = count_components(input_grid)
    output_grid = [row[:] for row in input_grid]
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] in substitution_rules[N]:
                output_grid[r][c] = substitution_rules[N][input_grid[r][c]]
    return output_grid
