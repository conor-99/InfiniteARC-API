# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: b76f0971
Difficulty: very hard

=== Tags ===
- Hierarchical reflection
- Multi condition recolor
- Minimal path fill
- Color carving

=== Description ===
Input grids feature a complex background of color 0 with multiple non-
overlapping walls of colors 1-9 arranged as horizontal or vertical segments
(never touching). A single source cell (color S) appears on the left edge of the
grid, and a color carving indicator (a 2×2 block of color C) is embedded within
the wall structure. The output grid must display a minimal path carved through
the background by a beam originating from the source, following these rules:  1.
**Hierarchical Reflection**: The beam starts moving right from the source. Upon
hitting a wall, it reflects based on wall orientation: vertical walls reverse
horizontal direction, horizontal walls reverse vertical direction. Each
reflection level modifies the beam's direction relative to the previous
reflection's orientation, creating a nested reflection hierarchy where the
direction change depends on the cumulative reflection history.  2. **Multi-
Condition Recolor**: After each reflection, the beam's color changes based on
three conditions: (a) the current beam color, (b) the wall color it struck, and
(c) its movement direction (horizontal/vertical). The new color is determined by
a visual color sequence: if moving horizontally, shift to the next color in the
sequence (1→2→3→...→9→1); if moving vertically, shift to the previous color
(1→9→8→...→2→1). The sequence wraps cyclically, ensuring no arithmetic
operations are used.  3. **Minimal Path Fill**: The beam follows the shortest
possible path to exit the grid, avoiding unnecessary reflections. If multiple
paths exist, the solver must select the path requiring the fewest reflections
while respecting the recolor rules. The path fills only background cells, never
overwriting walls, the source, or the carving indicator.  4. **Color Carving**:
The beam's path is "carved" into the background by filling each cell along the
path with the beam's current color after each reflection. The carved path forms
a continuous visual trail that reveals the reflection hierarchy and recolor
sequence. Walls, the source, and carving indicator remain unchanged, while all
other background cells retain color 0.  The output grid must satisfy all rules
simultaneously: the path must be minimal, colors must follow the multi-condition
recolor sequence at each reflection, and the hierarchical reflection pattern
must be visually evident through the direction changes. No path overlaps, and
all reflections strictly obey wall orientation constraints.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import heapq
from collections import deque

def generate():
    # We'll embed the same solver logic here to produce a matching output for each generated input.
    def next_color(c):
        return (c % 9) + 1
    def prev_color(c):
        return (c - 2) % 9 + 1

    def find_source(grid):
        H = len(grid)
        for r in range(H):
            if grid[r][0] > 0:
                return (r, 0)
        return None

    def find_indicator(grid):
        H = len(grid)
        W = len(grid[0])
        for r in range(H - 1):
            for c in range(W - 1):
                v = grid[r][c]
                if v > 0 and grid[r][c+1] == v and grid[r+1][c] == v and grid[r+1][c+1] == v:
                    return (r, c, v)
        return None

    def component_orientation(grid, start_r, start_c, indicator_coords, source_pos):
        # BFS 4-connected for same-color component, ignoring source cell and indicator block
        H = len(grid); W = len(grid[0])
        color = grid[start_r][start_c]
        q = deque()
        q.append((start_r, start_c))
        seen = {(start_r, start_c)}
        while q:
            r,c = q.popleft()
            for dr,dc in ((1,0),(-1,0),(0,1),(0,-1)):
                nr,nc = r+dr, c+dc
                if 0 <= nr < H and 0 <= nc < W and (nr,nc) not in seen:
                    if (nr,nc) == source_pos: continue
                    if indicator_coords and (nr >= indicator_coords[0] and nr <= indicator_coords[0]+1 and nc >= indicator_coords[1] and nc <= indicator_coords[1]+1):
                        continue
                    if grid[nr][nc] == color:
                        seen.add((nr,nc))
                        q.append((nr,nc))
        rs = [p[0] for p in seen]
        cs = [p[1] for p in seen]
        if not seen:
            return 'vertical'
        h = max(rs) - min(rs) + 1
        w = max(cs) - min(cs) + 1
        # If component is taller than wide -> vertical, else horizontal
        return 'vertical' if h >= w else 'horizontal'

    def compute_output_from_input(grid):
        H = len(grid); W = len(grid[0])
        source = find_source(grid)
        if not source:
            return [row[:] for row in grid]
        sr, sc = source
        source_color = grid[sr][sc]
        indicator = find_indicator(grid)
        indicator_coords = (indicator[0], indicator[1]) if indicator else None

        # Reflection and movement helper
        def reflect_and_step(r, c, dr, dc, reflections):
            # Attempt to step; if blocked, reflect according to component orientation, possibly repeatedly
            while True:
                nr, nc = r + dr, c + dc
                # Exiting the grid
                if not (0 <= nr < H and 0 <= nc < W):
                    return ('EXIT', r, c, dr, dc, reflections)
                # If background, we can move into it
                if grid[nr][nc] == 0:
                    return ('MOVE', nr, nc, dr, dc, reflections)
                # Blocked by non-background (wall, source or indicator)
                # Determine component orientation and reflect
                orientation = component_orientation(grid, nr, nc, indicator, (sr, sc))
                reflections += 1
                # Flip the axis corresponding to orientation
                if orientation == 'vertical':
                    # reverse horizontal component
                    dr, dc = dr, -dc
                else:
                    # horizontal wall -> reverse vertical component
                    dr, dc = -dr, dc
                # Hierarchical reflection: if this is an odd reflection level, rotate clockwise by 90 degrees
                if reflections % 2 == 1:
                    dr, dc = (dc, -dr)
                # loop to see whether the new direction immediately hits another obstacle
                continue

        # Dijkstra-like search minimizing (reflections, steps)
        start_key = (sr, sc, 0, 1, 0)  # r, c, dr, dc, parity
        heap = []
        entry_id = 0
        heapq.heappush(heap, (0, 0, entry_id, start_key))
        entry_id += 1
        best = {start_key: (0, 0)}
        prev = {start_key: None}
        exit_key = ('EXIT',)
        prev_exit = None
        best_exit_cost = None

        while heap:
            refls, steps, _, key = heapq.heappop(heap)
            if key == exit_key:
                best_exit_cost = (refls, steps)
                break
            if best.get(key, (9999, 999999)) < (refls, steps):
                continue
            r, c, dr, dc, parity = key
            outcome = reflect_and_step(r, c, dr, dc, refls)
            if outcome[0] == 'EXIT':
                # push exit node with cost
                _, er, ec, edr, edc, erefls = outcome
                new_cost = (erefls, steps + 1)
                if best_exit_cost is None or new_cost < best_exit_cost:
                    best_exit_cost = new_cost
                    prev[exit_key] = key
                    heapq.heappush(heap, (new_cost[0], new_cost[1], entry_id, exit_key))
                    entry_id += 1
                continue
            # MOVE
            _, nr, nc, ndr, ndc, nrefls = outcome
            new_parity = nrefls % 2
            new_key = (nr, nc, ndr, ndc, new_parity)
            new_cost = (nrefls, steps + 1)
            if best.get(new_key, (9999, 999999)) > new_cost:
                best[new_key] = new_cost
                prev[new_key] = key
                heapq.heappush(heap, (new_cost[0], new_cost[1], entry_id, new_key))
                entry_id += 1

        # If no exit found, return original grid
        if exit_key not in prev:
            return [row[:] for row in grid]

        # Reconstruct path (states) from start to last in-grid position
        # exit_key -> prev -> ... -> start_key
        seq = []
        node = exit_key
        while node is not None:
            seq.append(node)
            node = prev.get(node)
        seq = list(reversed(seq))
        # seq[0] should be start_key, last is exit_key; we want the list of in-grid states (exclude exit_key)
        states = [s for s in seq if s != exit_key]
        # states are tuples (r,c,dr,dc,parity)

        # Paint path on a copy of the grid
        out = [row[:] for row in grid]
        current_color = source_color
        prev_dir = (0, 1)
        for i in range(len(states) - 1):
            r, c, dr, dc, p = states[i]
            nr, nc, _, _, _ = states[i+1]
            move_dir = (nr - r, nc - c)
            # If direction changed compared to previous movement, a reflection occurred at (r,c)
            if move_dir != prev_dir:
                # recolor according to movement axis
                if move_dir[0] == 0:  # horizontal
                    current_color = next_color(current_color)
                else:  # vertical
                    current_color = prev_color(current_color)
            prev_dir = move_dir
            # Fill the target cell if it's background
            if out[nr][nc] == 0:
                out[nr][nc] = current_color
        return out

    # Generator: try building varied grids until one has a valid carved path
    tries = 0
    while True:
        tries += 1
        size = random.randint(8, 15)
        grid = [[0 for _ in range(size)] for _ in range(size)]

        # carving indicator
        carve_color = random.randint(1, 9)
        # ensure 2x2 fits away from edges
        ir = random.randint(1, size - 3)
        ic = random.randint(2, size - 3)
        for dr in range(2):
            for dc in range(2):
                grid[ir+dr][ic+dc] = carve_color

        # source on left edge
        source_color = random.randint(1, 9)
        while source_color == carve_color:
            source_color = random.randint(1, 9)
        sr = random.randint(1, size - 2)
        grid[sr][0] = source_color

        # Place several non-touching walls (horizontal or vertical segments)
        occupied = set()
        # mark indicator and source as occupied to avoid walls touching them
        for dr in range(2):
            for dc in range(2):
                occupied.add((ir+dr, ic+dc))
        occupied.add((sr, 0))

        wall_count = random.randint(3, 7)
        wall_colors = [c for c in range(1, 10) if c != carve_color and c != source_color]
        random.shuffle(wall_colors)
        walls_placed = 0
        attempts_place = 0
        while walls_placed < wall_count and attempts_place < 400:
            attempts_place += 1
            orient = random.choice(['h', 'v'])
            length = random.randint(3, max(3, size // 3))
            if orient == 'h':
                r0 = random.randint(1, size - 2)
                c0 = random.randint(1, size - length - 1)
                cells = [(r0, c0 + i) for i in range(length)]
            else:
                r0 = random.randint(1, size - length - 1)
                c0 = random.randint(1, size - 2)
                cells = [(r0 + i, c0) for i in range(length)]
            # check cells not occupied and not adjacent (4-neighbor) to existing occupied
            conflict = False
            for (r, c) in cells:
                if (r, c) in occupied: conflict = True; break
                for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):
                    if (r+dr, c+dc) in occupied: conflict = True; break
                if conflict: break
            if conflict:
                continue
            # choose color for this wall
            wcolor = random.choice(wall_colors)
            for (r, c) in cells:
                grid[r][c] = wcolor
                occupied.add((r, c))
            walls_placed += 1

        out = compute_output_from_input(grid)
        # ensure path actually carved something (output differs from input)
        if out != grid:
            return {'input': grid, 'output': out}
        # safety fallback
        if tries > 800:
            # as a fallback, carve a simple straight path to the right
            out = [row[:] for row in grid]
            for c in range(1, size-1):
                if out[sr][c] == 0:
                    out[sr][c] = source_color
            return {'input': grid, 'output': out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import heapq
from collections import deque

def p(input_grid):
    grid = [list(row) for row in input_grid]
    H = len(grid); W = len(grid[0])

    def next_color(c):
        return (c % 9) + 1
    def prev_color(c):
        return (c - 2) % 9 + 1

    def find_source(grid):
        for r in range(len(grid)):
            if grid[r][0] > 0:
                return (r, 0)
        return None

    def find_indicator(grid):
        H = len(grid); W = len(grid[0])
        for r in range(H - 1):
            for c in range(W - 1):
                v = grid[r][c]
                if v > 0 and grid[r][c+1] == v and grid[r+1][c] == v and grid[r+1][c+1] == v:
                    return (r, c, v)
        return None

    def component_orientation(grid, start_r, start_c, indicator_coords, source_pos):
        H = len(grid); W = len(grid[0])
        color = grid[start_r][start_c]
        q = deque()
        q.append((start_r, start_c))
        seen = {(start_r, start_c)}
        while q:
            r,c = q.popleft()
            for dr,dc in ((1,0),(-1,0),(0,1),(0,-1)):
                nr,nc = r+dr, c+dc
                if 0 <= nr < H and 0 <= nc < W and (nr,nc) not in seen:
                    if (nr,nc) == source_pos: continue
                    if indicator_coords and (nr >= indicator_coords[0] and nr <= indicator_coords[0]+1 and nc >= indicator_coords[1] and nc <= indicator_coords[1]+1):
                        continue
                    if grid[nr][nc] == color:
                        seen.add((nr,nc))
                        q.append((nr,nc))
        rs = [p[0] for p in seen]
        cs = [p[1] for p in seen]
        if not seen:
            return 'vertical'
        h = max(rs) - min(rs) + 1
        w = max(cs) - min(cs) + 1
        return 'vertical' if h >= w else 'horizontal'

    def reflect_and_step(r, c, dr, dc, reflections, sr, sc, indicator):
        while True:
            nr, nc = r + dr, c + dc
            if not (0 <= nr < H and 0 <= nc < W):
                return ('EXIT', r, c, dr, dc, reflections)
            if grid[nr][nc] == 0:
                return ('MOVE', nr, nc, dr, dc, reflections)
            orientation = component_orientation(grid, nr, nc, indicator, (sr, sc))
            reflections += 1
            if orientation == 'vertical':
                dr, dc = dr, -dc
            else:
                dr, dc = -dr, dc
            if reflections % 2 == 1:
                dr, dc = (dc, -dr)
            continue

    source = find_source(grid)
    if not source:
        return grid
    sr, sc = source
    source_color = grid[sr][sc]
    indicator = find_indicator(grid)

    start_key = (sr, sc, 0, 1, 0)
    heap = []
    entry_id = 0
    heapq.heappush(heap, (0, 0, entry_id, start_key))
    entry_id += 1
    best = {start_key: (0, 0)}
    prev = {start_key: None}
    exit_key = ('EXIT',)

    while heap:
        refls, steps, _, key = heapq.heappop(heap)
        if key == exit_key:
            break
        if best.get(key, (9999, 999999)) < (refls, steps):
            continue
        r, c, dr, dc, parity = key
        outcome = reflect_and_step(r, c, dr, dc, refls, sr, sc, indicator)
        if outcome[0] == 'EXIT':
            _, er, ec, edr, edc, erefls = outcome
            new_cost = (erefls, steps + 1)
            # push exit node
            if exit_key not in prev or new_cost < best.get(exit_key, (9999, 999999)):
                prev[exit_key] = key
                best[exit_key] = new_cost
                heapq.heappush(heap, (new_cost[0], new_cost[1], entry_id, exit_key))
                entry_id += 1
            continue
        _, nr, nc, ndr, ndc, nrefls = outcome
        new_parity = nrefls % 2
        new_key = (nr, nc, ndr, ndc, new_parity)
        new_cost = (nrefls, steps + 1)
        if best.get(new_key, (9999, 999999)) > new_cost:
            best[new_key] = new_cost
            prev[new_key] = key
            heapq.heappush(heap, (new_cost[0], new_cost[1], entry_id, new_key))
            entry_id += 1

    if exit_key not in prev:
        return grid

    # Reconstruct path
    seq = []
    node = exit_key
    while node is not None:
        seq.append(node)
        node = prev.get(node)
    seq = list(reversed(seq))
    states = [s for s in seq if s != exit_key]

    out = [row[:] for row in grid]
    current_color = source_color
    prev_dir = (0, 1)
    for i in range(len(states) - 1):
        r, c, dr, dc, p = states[i]
        nr, nc, _, _, _ = states[i+1]
        move_dir = (nr - r, nc - c)
        if move_dir != prev_dir:
            if move_dir[0] == 0:
                current_color = next_color(current_color)
            else:
                current_color = prev_color(current_color)
        prev_dir = move_dir
        if out[nr][nc] == 0:
            out[nr][nc] = current_color
    return out

