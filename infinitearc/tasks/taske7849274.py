# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: e7849274
Difficulty: hard

=== Tags ===
- Palette compression
- Contouring
- Obstacles

=== Description ===
The input grid contains multiple distinct colored objects (each a connected
region of the same non-zero color), background (color 0), and obstacles (color
5). The output grid applies two sequential transformations: first, palette
compression replaces all object colors (1-4) with a single uniform color (7),
merging all objects into one color category. Second, contouring adds a 1-pixel
border around each compressed object using color 6, but only in positions that
were background (color 0) in the input grid. This means the contour avoids areas
occupied by obstacles (color 5), creating an outline that navigates around these
predefined barriers. The task requires recognizing connected regions, applying
color merging, and selectively generating borders while respecting obstacle
constraints, making it challenging due to the interplay of multiple rules and
the need to distinguish between background, objects, and obstacles in complex
configurations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    input_grid = [[0] * width for _ in range(height)]
    
    num_obstacles = random.randint(5, 20)
    for _ in range(num_obstacles):
        r = random.randint(0, height - 1)
        c = random.randint(0, width - 1)
        input_grid[r][c] = 5
    
    for color in [1, 2, 3, 4]:
        while True:
            r = random.randint(0, height - 1)
            c = random.randint(0, width - 1)
            if input_grid[r][c] == 0:
                break
        input_grid[r][c] = color
        pixels = [(r, c)]
        size = random.randint(5, 15)
        count = 1
        while count < size:
            neighbors = []
            for (pr, pc) in pixels:
                for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
                    nr, nc = pr + dr, pc + dc
                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 0:
                        neighbors.append((nr, nc))
            if not neighbors:
                break
            nr, nc = random.choice(neighbors)
            input_grid[nr][nc] = color
            pixels.append((nr, nc))
            count += 1
    
    output_grid = [list(row) for row in input_grid]
    for i in range(height):
        for j in range(width):
            if 1 <= output_grid[i][j] <= 4:
                output_grid[i][j] = 7
    
    for i in range(height):
        for j in range(width):
            if output_grid[i][j] == 7:
                for di, dj in [(-1,0), (1,0), (0,-1), (0,1)]:
                    ni, nj = i + di, j + dj
                    if 0 <= ni < height and 0 <= nj < width and input_grid[ni][nj] == 0:
                        output_grid[ni][nj] = 6
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output = [list(row) for row in input_grid]
    
    for i in range(height):
        for j in range(width):
            if 1 <= output[i][j] <= 4:
                output[i][j] = 7
    
    for i in range(height):
        for j in range(width):
            if output[i][j] == 7:
                for di, dj in [(-1,0), (1,0), (0,-1), (0,1)]:
                    ni, nj = i + di, j + dj
                    if 0 <= ni < height and 0 <= nj < width and input_grid[ni][nj] == 0:
                        output[ni][nj] = 6
    return output
