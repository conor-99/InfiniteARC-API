# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: fca45b4d
Difficulty: mediumâ€“hard

=== Tags ===
- Enclosure completion

=== Description ===
The task involves input grids containing a single continuous boundary loop
formed by a specific non-zero color, with exactly one background cell (value 0)
missing from the loop. The missing cell is positioned such that it is adjacent
to two boundary cells either horizontally or vertically. The output grid
completes the loop by replacing this single background cell with the boundary
color, resulting in a fully enclosed shape. All other cells remain unchanged.
The boundary must form a closed loop with only one gap, and the solution
requires identifying the precise location of the missing segment based on
adjacency to two boundary cells, without relying on numerical values or pixel-
level patterns.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    c = random.randint(1, 9)
    grid_input = grid(width, height, 0)
    for r in range(height):
        for c_idx in range(width):
            if r == 0 or r == height - 1 or c_idx == 0 or c_idx == width - 1:
                grid_input[r][c_idx] = c
    border_cells = []
    for r in range(height):
        for c_idx in range(width):
            if r == 0 or r == height - 1 or c_idx == 0 or c_idx == width - 1:
                border_cells.append((r, c_idx))
    r, c_idx = random.choice(border_cells)
    grid_input[r][c_idx] = 0
    grid_output = [row[:] for row in grid_input]
    grid_output[r][c_idx] = c
    return {
        "input": grid_input,
        "output": grid_output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    c = None
    for r in range(height):
        for c_idx in range(width):
            if input_grid[r][c_idx] != 0:
                c = input_grid[r][c_idx]
                break
        if c is not None:
            break
    candidates = []
    for r in range(height):
        for c_idx in range(width):
            if input_grid[r][c_idx] == 0 and (r == 0 or r == height - 1 or c_idx == 0 or c_idx == width - 1):
                count = 0
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c_idx + dc
                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == c:
                        count += 1
                if count >= 2:
                    candidates.append((r, c_idx))
    r, c_idx = candidates[0]
    input_grid[r][c_idx] = c
    return input_grid
