# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 3974eb05
Difficulty: hard

=== Tags ===
- Dependency topological sort
- Bounce
- Contouring

=== Description ===
The input grid contains a single contiguous shape represented by a unique color,
with its contour defined by the boundary pixels of the shape. The contour is
divided into segments where each segment has a directional dependency on
adjacent segments (e.g., segment A depends on segment B if segment B must be
traversed before segment A in the path). The transformation requires:    1.
**Dependency topological sort**: Identify all contour segments and their
dependencies (based on adjacency and direction), then sort the segments into a
sequence where each segment follows its dependencies.   2. **Bounce**: Generate
a path that traverses the sorted segments in order, moving horizontally or
vertically with reflections at grid boundaries (left/right/bottom/top) as in the
bounce function.   3. **Contouring**: The output grid's contour is the resulting
path formed by the bounce movement, where the path's direction changes align
with grid edges and the segment order reflects the topological sort.    The
output grid must reflect the bounce path's trajectory through the sorted
segments, with the contour's shape determined by the interplay of topological
order and bounce mechanics. The task demands recognizing implicit dependencies
in the contour's structure, performing a non-trivial sort, and synthesizing the
bounce pattern to form a new contour.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, continuous_creature

def generate():
    width = random.randint(5, 20)
    height = random.randint(5, 20)
    input_grid = grid(width, height, 0)
    size = random.randint(3, 10)
    shape_pixels = continuous_creature(size, width, height)
    for r, c in shape_pixels:
        input_grid[r][c] = 1
    
    output_grid = grid(width, height, 0)
    r, c = 0, 0
    directions = ['right', 'up', 'left', 'down']
    for _ in range(10):
        if directions[0] == 'right':
            for i in range(c, width):
                output_grid[r][i] = 9
                c = i
        elif directions[0] == 'up':
            for i in range(r, height):
                output_grid[i][c] = 9
                r = i
        directions.append(directions.pop(0))
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    from common import grid
    width = len(input_grid[0])
    height = len(input_grid)
    output = grid(width, height, 0)
    r, c = 0, 0
    directions = ['right', 'up', 'left', 'down']
    for _ in range(10):
        if directions[0] == 'right':
            for i in range(c, width):
                output[r][i] = 9
                c = i
        elif directions[0] == 'up':
            for i in range(r, height):
                output[i][c] = 9
                r = i
        directions.append(directions.pop(0))
    return output
