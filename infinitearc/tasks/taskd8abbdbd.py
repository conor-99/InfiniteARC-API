# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: d8abbdbd
Difficulty: insane

=== Tags ===
- Nested structure detection
- Motif extraction
- Boolean color logic
- Diagonal symmetry

=== Description ===
Input grids feature multiple concentric geometric structures formed by distinct
colors, where each structure is a closed, contiguous region surrounded by
background. The innermost structure—identified as the smallest region enclosed
by a single color boundary—is the target for motif extraction. The output grid
is generated by reflecting all cells of this innermost structure's color across
the main diagonal (top-left to bottom-right), ensuring diagonal symmetry: for
every cell (i,j) in the extracted motif, the cell (j,i) must also be present in
the output. This requires adding missing symmetric cells to the motif while
preserving all background elements and non-motif colors exactly as they appear
in the input. The transformation applies only to the motif's color, leaving all
other grid elements unchanged, and the output grid maintains the same dimensions
as the input. The task demands precise nested structure identification, motif
isolation based on boundary analysis, and application of diagonal symmetry
through Boolean color logic (presence/absence of the motif color).
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    """Generates a square grid with several concentric square frames (each a different color)
    and a small connected motif (another color) placed inside the central square. The
    output is the same grid but with the motif reflected across the main diagonal
    (for every (r,c) in motif we also set (c,r) to the motif color), without
    overwriting any other non-motif colors.

    The generator guarantees:
    - The grid is square (so reflections lie inside the grid).
    - The motif is a small connected shape inside the innermost frame's interior.
    - The motif is not already fully symmetric across the main diagonal, so
      input != output.
    """
    # Try generation until we satisfy constraints (should be quick)
    for overall_attempt in range(200):
        # number of nested square frames (thickness 1)
        frames = random.randint(2, 4)  # number of colored frames
        # minimum size so that there is at least a 1x1 interior after frames
        min_size = max(8, 2 * (frames + 1) + 1)
        size = random.randint(min_size, 30)
        # initialize background
        grid = [[0 for _ in range(size)] for _ in range(size)]

        # choose distinct colors: one for each frame plus one for motif
        colors = random.sample(range(1, 10), frames + 1)
        frame_colors = colors[:-1]
        motif_color = colors[-1]

        # draw concentric square frames at offsets 1..frames
        for k, col in enumerate(frame_colors, start=1):
            offset = k
            top = offset
            bottom = size - 1 - offset
            left = offset
            right = size - 1 - offset
            # top and bottom rows
            for c in range(left, right + 1):
                grid[top][c] = col
                grid[bottom][c] = col
            # left and right columns (excluding corners already set)
            for r in range(top + 1, bottom):
                grid[r][left] = col
                grid[r][right] = col

        # interior (innermost) square coordinates
        inner_start = frames + 1
        inner_end = size - 2 - frames
        inner_len = inner_end - inner_start + 1
        if inner_len <= 0:
            continue

        # motif size: small so it will be the smallest colored region
        max_motif = min(6, inner_len * inner_len)
        motif_size = random.randint(1, max_motif)

        # generate a small connected motif inside the inner square
        cells = [(r, c) for r in range(inner_start, inner_end + 1) for c in range(inner_start, inner_end + 1)]

        def make_connected(seed, n):
            shape = {seed}
            attempts = 0
            while len(shape) < n and attempts < 1000:
                attempts += 1
                base = random.choice(tuple(shape))
                neighs = []
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = base[0] + dr, base[1] + dc
                    if nr < inner_start or nr > inner_end or nc < inner_start or nc > inner_end:
                        continue
                    if (nr, nc) in shape:
                        continue
                    neighs.append((nr, nc))
                if neighs:
                    shape.add(random.choice(neighs))
                else:
                    # try a different existing cell in next iteration
                    continue
            return shape if len(shape) == n else None

        motif_shape = None
        for attempt in range(400):
            seed = random.choice(cells)
            result = make_connected(seed, motif_size)
            if result is None:
                continue
            # require at least one off-diagonal cell and at least one cell without its symmetric partner
            has_offdiag = any(r != c for (r, c) in result)
            has_unpaired = any(((c, r) not in result) for (r, c) in result)
            if has_offdiag and has_unpaired:
                motif_shape = result
                break
        if motif_shape is None:
            # try with a different motif_size or different outer parameters
            continue

        # paint motif into grid
        for (r, c) in motif_shape:
            grid[r][c] = motif_color

        # create output by reflecting motif across main diagonal without overwriting other colors
        output = [row[:] for row in grid]
        for (r, c) in motif_shape:
            if 0 <= c < size and 0 <= r < size:
                # do not overwrite non-background and non-motif colors
                if output[c][r] == 0:
                    output[c][r] = motif_color
                # if it's already motif_color, nothing to do; if it's another color we preserve it

        # ensure input != output (we enforced motif had at least one unpaired off-diagonal cell)
        if output != grid:
            return {"input": grid, "output": output}

    # Fallback (should not happen): small deterministic example
    grid = [[0] * 8 for _ in range(8)]
    # two frames and a small motif that will change when reflected
    grid[1][1:6] = [7] * 5
    grid[6][1:6] = [7] * 5
    for r in range(2, 6):
        grid[r][1] = 7
        grid[r][5] = 7
    # inner small motif
    grid[3][3] = 8
    output = [row[:] for row in grid]
    output[3][3] = 8
    output[3][3] = 8
    output[3][3] = 8
    output[3][3] = 8
    output[3][3] = 8
    output[3][3] = 8
    output[3][3] = 8
    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # Find all connected components of non-zero colors (4-connected)
    visited = [[False] * width for _ in range(height)]
    components = []  # list of tuples (size, color, cells)

    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 or visited[r][c]:
                continue
            color = grid[r][c]
            # BFS to collect the component
            queue = [(r, c)]
            visited[r][c] = True
            comp = []
            while queue:
                rr, cc = queue.pop(0)
                comp.append((rr, cc))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                        visited[nr][nc] = True
                        queue.append((nr, nc))
            components.append((len(comp), color, comp))

    if not components:
        return tuple(tuple(row) for row in grid)

    # The target motif is the smallest connected colored region (generator ensures this)
    components.sort(key=lambda x: x[0])
    _, motif_color, motif_cells = components[0]

    # Create output by reflecting motif cells across the main diagonal
    output = [row[:] for row in grid]
    for (i, j) in motif_cells:
        # reflect (i, j) -> (j, i) if within bounds
        if 0 <= j < height and 0 <= i < width:
            # do not overwrite other colors (only paint if background or already motif color)
            if output[j][i] == 0:
                output[j][i] = motif_color

    return tuple(tuple(row) for row in output)

