# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: fff3f01b
Difficulty: insane

=== Tags ===
- Global property defines local rule
- Diagonal symmetry
- Associate color to bools

=== Description ===
The task involves transforming input grids into output grids based on a global
property defined by the top-left corner's color, which associates to a boolean
value (color 2 = True, color 3 = False). The output grid must exhibit diagonal
symmetry: if the top-left color is 2 (True), the output is the main diagonal
transpose (cell [i][j] becomes [j][i]); if the top-left color is 3 (False), the
output is the anti-diagonal transpose (cell [i][j] becomes [n-1-j][n-1-i] for an
n×n grid). Input grids are square (1×1 to 30×30), filled with diverse color
patterns, but the transformation rule is solely determined by the top-left
color. The output must differ from the input, ensuring non-symmetric input
patterns for the chosen transformation. This requires recognizing the top-left
color as the key to selecting the symmetry axis, despite complex visual patterns
in the grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    n = random.randint(2, 30)
    top_left_color = random.choice([2, 3])
    input_grid = common.grid(n, n, 0)
    input_grid[0][0] = top_left_color
    for i in range(n):
        for j in range(n):
            if i == 0 and j == 0:
                continue
            input_grid[i][j] = common.random_color()
    if top_left_color == 2:
        output_grid = common.transpose(input_grid)
    else:
        output_grid = anti_transpose(input_grid)
    while input_grid == output_grid:
        i, j = 0, 1
        new_color = common.random_color(exclude=[input_grid[i][j]])
        input_grid[i][j] = new_color
        if top_left_color == 2:
            output_grid = common.transpose(input_grid)
        else:
            output_grid = anti_transpose(input_grid)
    return {"input": input_grid, "output": output_grid}

def anti_transpose(grid):
    n = len(grid)
    return [[grid[n-1-j][n-1-i] for i in range(n)] for j in range(n)]


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def anti_transpose(grid):
    n = len(grid)
    return [[grid[n-1-j][n-1-i] for i in range(n)] for j in range(n)]

def p(input_grid):
    if input_grid[0][0] == 2:
        return common.transpose(input_grid)
    elif input_grid[0][0] == 3:
        return anti_transpose(input_grid)
    else:
        return input_grid
