# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 2d6ff5da
Difficulty: medium–hard

=== Tags ===
- Color particle fall
- Path following

=== Description ===
**Task Name: Particle Pathway Flow**    **Description:**   Input grids feature a
background color (0) and two distinct non-background elements:   1.
**Particles:** Single-cell entities of color 1, positioned at various locations
within the grid.   2. **Pathways:** Continuous, straight-line structures of
color 2, which may extend horizontally, vertically, or diagonally (top-left to
bottom-right). Pathways are unbroken sequences of connected cells (orthogonally
or diagonally adjacent) and do not intersect particles, other pathways, or grid
boundaries.    In the output grid, each particle transforms via a two-phase
process:   - **Falling Phase:** Particles fall vertically downward (increasing
row index) through background cells (0) until they collide with a pathway cell
(color 2).   - **Path Following Phase:** Upon collision, particles move *along
the pathway's direction* until they exit the grid:     - **Horizontal pathways**
(same row) → particles move left or right to the grid edge.     - **Vertical
pathways** (same column) → particles continue falling downward to the grid
bottom.     - **Diagonal pathways** (top-left to bottom-right) → particles move
diagonally down-right to the grid bottom-right edge.    Pathways are strictly
straight and continuous; particles follow the pathway without deviation. If a
particle’s path would exit the grid, it stops at the edge. Pathways do not block
or alter each other, and particles move independently.    **Key Complexity:**
- Particles must distinguish pathway orientations *from spatial arrangement
alone* (e.g., horizontal = same-row cells, diagonal = consistent row+column
increments).   - Multiple pathways in different orientations require parallel
rule application.   - Output grids show particles at the *terminal edge* of
their path, with no overlap or residual traces.    **Example Insight:**   A
particle falling onto a horizontal pathway (row 5, columns 2–6) moves right to
column 6 (grid edge), while a particle hitting a diagonal pathway (cells (3,3),
(4,4), (5,5)) moves to (5,5) before exiting. Vertical pathways simply continue
the downward fall.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    """Generate an ARC-style input/output pair for the Particle Pathway Flow task.

    Rules implemented:
    - Background color 0.
    - Pathways color 2: straight, continuous, length>=2, orientation horizontal, vertical or diagonal (top-left to bottom-right).
      Pathway cells are strictly inside the grid (do not touch the outer boundary) and do not touch each other (1-cell padding).
    - Particles color 1: single-cell placed on background, not on pathway cells.
    - Each particle falls straight down until it first encounters a pathway cell in its column (if any).
      * If it hits a pathway cell, it adopts the pathway's orientation and then moves along that direction until it exits the grid:
          - horizontal -> move to the right until column = width-1
          - vertical   -> continue falling until row = height-1
          - diagonal   -> move down-right until one of row==height-1 or col==width-1 is reached
      * If there is no pathway below the particle, it simply falls to row = height-1 (same column).
    - Final particle positions (after movement) must be unique (no overlap).

    The function returns a dict {'input': input_grid, 'output': output_grid} where each grid is a list of lists of ints.
    """
    # We will try several times to construct a valid grid; if a placement attempt fails we restart.
    for attempt in range(2000):
        width = random.randint(6, 20)
        height = random.randint(6, 20)

        # Start with an empty background
        ingrid = grid(width, height, 0)

        path_cells = set()

        orientations = ['horizontal', 'vertical', 'diagonal']
        num_paths = random.randint(1, min(3, len(orientations)))
        # Prefer different orientations on the same grid when possible
        path_orients = random.sample(orientations, num_paths)

        ok = True
        # Place each pathway so that it does not touch the grid boundary and does not touch other pathways
        for orient in path_orients:
            if orient == 'horizontal':
                max_len = width - 2
            elif orient == 'vertical':
                max_len = height - 2
            else:
                max_len = min(width, height) - 2

            if max_len < 2:
                ok = False
                break

            placed = False
            for _ in range(120):
                length = random.randint(2, max_len)

                if orient == 'horizontal':
                    r = random.randint(1, height - 2)
                    c_min = 1
                    c_max = width - length - 1
                    if c_max < c_min:
                        continue
                    c = random.randint(c_min, c_max)
                    coords = [(r, c + k) for k in range(length)]
                elif orient == 'vertical':
                    c = random.randint(1, width - 2)
                    r_min = 1
                    r_max = height - length - 1
                    if r_max < r_min:
                        continue
                    r = random.randint(r_min, r_max)
                    coords = [(r + k, c) for k in range(length)]
                else:  # diagonal top-left to bottom-right
                    r_min = 1
                    r_max = height - length - 1
                    c_min = 1
                    c_max = width - length - 1
                    if r_max < r_min or c_max < c_min:
                        continue
                    r = random.randint(r_min, r_max)
                    c = random.randint(c_min, c_max)
                    coords = [(r + k, c + k) for k in range(length)]

                # Ensure the candidate path cells do not touch any existing path (including diagonally)
                conflict = False
                for (pr, pc) in coords:
                    # defensive: ensure we are not placing on the border
                    if pr == 0 or pr == height - 1 or pc == 0 or pc == width - 1:
                        conflict = True
                        break
                    if (pr, pc) in path_cells:
                        conflict = True
                        break
                    # ensure no adjacency to existing path cells
                    for dr in (-1, 0, 1):
                        for dc in (-1, 0, 1):
                            if (pr + dr, pc + dc) in path_cells:
                                conflict = True
                                break
                        if conflict:
                            break
                    if conflict:
                        break
                if conflict:
                    continue

                # place the path
                for (pr, pc) in coords:
                    ingrid[pr][pc] = 2
                    path_cells.add((pr, pc))
                placed = True
                break

            if not placed:
                ok = False
                break

        if not ok:
            continue

        # Place particles (color 1). We place them so that final positions do not overlap
        max_particles = min(6, max(1, (width * height) // 10))
        num_particles = random.randint(1, max_particles)

        particles = []  # list of ((r,c), (final_r,final_c))
        reserved_final = set()

        particle_attempts = 0
        while len(particles) < num_particles and particle_attempts < 800:
            particle_attempts += 1
            # choose a background cell for the particle (avoid placing on a path)
            row = random.randint(0, height - 2)  # avoid placing on the bottom row to make movement visible
            col = random.randint(0, width - 1)
            if ingrid[row][col] != 0:
                continue

            # find the first pathway cell below the particle in the same column
            hit = None
            for r2 in range(row + 1, height):
                if ingrid[r2][col] == 2:
                    hit = (r2, col)
                    break

            if hit is None:
                # falls to bottom of same column
                final = (height - 1, col)
            else:
                hit_r, hit_c = hit
                # detect pathway orientation by examining neighbors of the hit cell
                is_horizontal = ((hit_c + 1 < width and ingrid[hit_r][hit_c + 1] == 2) or
                                 (hit_c - 1 >= 0 and ingrid[hit_r][hit_c - 1] == 2))
                is_vertical = ((hit_r + 1 < height and ingrid[hit_r + 1][hit_c] == 2) or
                               (hit_r - 1 >= 0 and ingrid[hit_r - 1][hit_c] == 2))
                is_diagonal = ((hit_r + 1 < height and hit_c + 1 < width and ingrid[hit_r + 1][hit_c + 1] == 2) or
                               (hit_r - 1 >= 0 and hit_c - 1 >= 0 and ingrid[hit_r - 1][hit_c - 1] == 2))

                if is_horizontal:
                    final = (hit_r, width - 1)
                elif is_vertical:
                    final = (height - 1, hit_c)
                elif is_diagonal:
                    delta = min(height - 1 - hit_r, width - 1 - hit_c)
                    final = (hit_r + delta, hit_c + delta)
                else:
                    # Path length should be >=2, but as a defensive fallback treat as vertical
                    final = (height - 1, hit_c)

            # avoid overlapping final positions and avoid trivial placement where particle is already at final
            if final in reserved_final:
                continue
            if (row, col) == final:
                continue

            # place particle
            ingrid[row][col] = 1
            particles.append(((row, col), final))
            reserved_final.add(final)

        if len(particles) == 0:
            # couldn't place any particle; retry the whole grid
            continue

        # Build the output grid: clear original particle cells and set their final positions
        out = [r[:] for r in ingrid]
        for (r0, c0), final in particles:
            out[r0][c0] = 0
        for _, final in particles:
            fr, fc = final
            out[fr][fc] = 1

        # Ensure the input is not identical to the output (at least one particle must move)
        if out == ingrid:
            continue

        return {'input': ingrid, 'output': out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable grid
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Work from a copy so that path detection uses original input (particles should not act as blockers)
    orig = [row[:] for row in grid]

    # Find all particles
    particles = []
    for r in range(height):
        for c in range(width):
            if orig[r][c] == 1:
                particles.append((r, c))

    # Compute final positions for each particle
    finals = []  # list of (start_r, start_c, final_r, final_c)
    for (row, col) in particles:
        hit = None
        for r2 in range(row + 1, height):
            if orig[r2][col] == 2:
                hit = (r2, col)
                break

        if hit is None:
            final = (height - 1, col)
        else:
            hit_r, hit_c = hit
            is_horizontal = ((hit_c + 1 < width and orig[hit_r][hit_c + 1] == 2) or
                             (hit_c - 1 >= 0 and orig[hit_r][hit_c - 1] == 2))
            is_vertical = ((hit_r + 1 < height and orig[hit_r + 1][hit_c] == 2) or
                           (hit_r - 1 >= 0 and orig[hit_r - 1][hit_c] == 2))
            is_diagonal = ((hit_r + 1 < height and hit_c + 1 < width and orig[hit_r + 1][hit_c + 1] == 2) or
                           (hit_r - 1 >= 0 and hit_c - 1 >= 0 and orig[hit_r - 1][hit_c - 1] == 2))

            if is_horizontal:
                final = (hit_r, width - 1)
            elif is_vertical:
                final = (height - 1, hit_c)
            elif is_diagonal:
                delta = min(height - 1 - hit_r, width - 1 - hit_c)
                final = (hit_r + delta, hit_c + delta)
            else:
                # Defensive fallback
                final = (height - 1, hit_c)

        finals.append((row, col, final[0], final[1]))

    # Build output grid: remove original particles and place particles at their terminal positions
    out = [row[:] for row in orig]
    for (sr, sc, fr, fc) in finals:
        out[sr][sc] = 0
    for (sr, sc, fr, fc) in finals:
        out[fr][fc] = 1

    return tuple(tuple(row) for row in out)

