# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: d888ede2
Difficulty: mediumâ€“hard

=== Tags ===
- Signal to structure
- Pattern juxtaposition
- Measure area

=== Description ===
Input grids consist of multiple distinct colored connected regions (each a solid
color) and a single yellow signal region. Each colored region's area (number of
cells it occupies) is unique. The output grid rearranges all colored regions
into a vertical column starting from the signal's position, ordered from
smallest to largest area (top to bottom). The signal region is removed from the
output. All background cells maintain their original color. The regions are
placed without overlapping, preserving their original shapes and orientations.
The arrangement must accurately reflect the measured area of each region, with
no numerical calculations or color-based constraints beyond the visual area
measurement.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_color

def make_random_connected_shape(area, max_w, max_h, max_tries=300):
    """Generate a connected shape of exactly `area` cells within a box max_w x max_h.

    Returns a list of (r,c) coordinates normalized so min r and min c are 0, or None on failure.
    """
    if area < 1 or area > max_w * max_h:
        return None
    for _ in range(max_tries):
        pixels = set()
        pixels.add((0, 0))
        # attempt to grow until we have `area` pixels
        grow_tries = 0
        while len(pixels) < area and grow_tries < 2000:
            grow_tries += 1
            base = random.choice(list(pixels))
            neighbors = [(base[0] + 1, base[1]), (base[0] - 1, base[1]), (base[0], base[1] + 1), (base[0], base[1] - 1)]
            nr, nc = random.choice(neighbors)
            if 0 <= nr < max_h and 0 <= nc < max_w:
                pixels.add((nr, nc))
        if len(pixels) != area:
            continue
        # normalize so min r and min c are 0
        minr = min(r for r, c in pixels)
        minc = min(c for r, c in pixels)
        norm = [(r - minr, c - minc) for r, c in pixels]
        # check bounding box
        bh = max(r for r, c in norm) + 1
        bw = max(c for r, c in norm) + 1
        if bh <= max_h and bw <= max_w:
            return norm
    return None


def generate():
    # Try several times to construct a valid grid
    for attempt in range(500):
        width = random.randint(6, 18)
        height = random.randint(6, 18)
        num_regions = random.randint(3, 5)

        # pick distinct colors (exclude 4 which is the signal/yellow)
        available_colors = [c for c in range(1, 10) if c != 4]
        if len(available_colors) < num_regions:
            continue
        colors = random.sample(available_colors, num_regions)

        # pick distinct areas (small sizes to keep bounding heights reasonable)
        max_area_candidate = min(8, width * height // (num_regions + 1))
        if max_area_candidate < 1:
            continue
        areas = random.sample(range(1, max_area_candidate + 1), num_regions)

        # attempt to build connected shapes for each area
        shapes = []
        per_shape_max_h = max(1, height // num_regions)
        # give a little leeway
        per_shape_max_h = min(per_shape_max_h + 1, height, 6)

        ok = True
        for a in areas:
            # choose a reasonable max width for the shape
            max_w = min(a, width, 6)
            max_h = per_shape_max_h
            # ensure the box can contain the area
            if max_w * max_h < a:
                needed_h = (a + max_w - 1) // max_w
                if needed_h > height:
                    ok = False
                    break
                max_h = min(needed_h, height)
            shape_pixels = make_random_connected_shape(a, max_w, max_h)
            if shape_pixels is None:
                ok = False
                break
            # compute normalized bounding box size
            bh = max(r for r, c in shape_pixels) + 1
            bw = max(c for r, c in shape_pixels) + 1
            shapes.append({
                'area': a,
                'pixels': shape_pixels,
                'h': bh,
                'w': bw
            })
        if not ok:
            continue

        total_stack_height = sum(s['h'] for s in shapes)
        if total_stack_height > height:
            # too tall to stack, try again
            continue

        max_bounding_w = max(s['w'] for s in shapes)
        if max_bounding_w > width:
            continue

        # choose signal anchor so the stacked column (using left-aligned shapes) fits
        max_signal_col = width - max_bounding_w
        if max_signal_col < 0:
            continue
        signal_col = random.randint(0, max_signal_col)
        max_signal_row = height - total_stack_height
        if max_signal_row < 0:
            continue
        signal_row = random.randint(0, max_signal_row)
        signal_pos = (signal_row, signal_col)

        # Place shapes randomly in the input grid, avoiding the signal cell
        input_grid = grid(width, height, 0)
        occupied = set()
        placement_info = []  # list of (top,left) anchors for each shape
        placement_ok = True
        # randomize order of placement to get varied layouts
        order = list(range(len(shapes)))
        random.shuffle(order)
        for idx in order:
            s = shapes[idx]
            placed = False
            # generate all possible anchors and shuffle
            possible_rows = list(range(0, height - s['h'] + 1))
            possible_cols = list(range(0, width - s['w'] + 1))
            random.shuffle(possible_rows)
            random.shuffle(possible_cols)
            for r0 in possible_rows:
                for c0 in possible_cols:
                    # make sure this placement does not touch the reserved signal cell and does not overlap existing shapes
                    conflict = False
                    for pr, pc in s['pixels']:
                        rr, cc = r0 + pr, c0 + pc
                        if (rr, cc) == signal_pos or (rr, cc) in occupied:
                            conflict = True
                            break
                    if conflict:
                        continue
                    # place it
                    for pr, pc in s['pixels']:
                        rr, cc = r0 + pr, c0 + pc
                        input_grid[rr][cc] = colors[idx]
                        occupied.add((rr, cc))
                    placement_info.append((idx, r0, c0))
                    placed = True
                    break
                if placed:
                    break
            if not placed:
                placement_ok = False
                break
        if not placement_ok:
            continue

        # If the reserved signal_pos ended up occupied (shouldn't), skip
        if signal_pos in occupied:
            continue

        # place the signal cell
        input_grid[signal_pos[0]][signal_pos[1]] = 4

        # Build the output grid: start from the input but remove all original colored region pixels and the signal
        output_grid = [row[:] for row in input_grid]
        for (r, c) in list(occupied):
            output_grid[r][c] = 0
        output_grid[signal_pos[0]][signal_pos[1]] = 0

        # Now place the shapes in a vertical column starting at signal_pos (top to bottom) ordered by area (smallest first)
        shapes_with_colors = list(zip(shapes, colors))
        shapes_with_colors.sort(key=lambda x: x[0]['area'])
        current_row = signal_pos[0]
        for s, col in shapes_with_colors:
            # place each shape left-aligned at signal_col and at current_row
            for pr, pc in s['pixels']:
                rr = current_row + pr
                cc = signal_pos[1] + pc
                # safety checks (should never fail because we reserved space)
                if rr < 0 or rr >= height or cc < 0 or cc >= width:
                    placement_ok = False
                    break
                output_grid[rr][cc] = col
            if not placement_ok:
                break
            current_row += s['h']

        if not placement_ok:
            continue

        # Final validation for this attempt: ensure input != output
        if input_grid == output_grid:
            # something wrong, try again
            continue

        return {"input": input_grid, "output": output_grid}

    # If we exhaust attempts, as a fallback produce a trivial valid example (rare)
    width, height = 6, 6
    input_grid = grid(width, height, 0)
    # three simple vertical regions of different areas
    input_grid[0][0] = 2
    input_grid[1][0] = 2
    input_grid[2][0] = 3
    input_grid[3][0] = 3
    input_grid[4][0] = 3
    input_grid[5][2] = 5
    input_grid[0][5] = 4
    output_grid = [row[:] for row in input_grid]
    # clear originals
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] in (2,3,5,4):
                output_grid[r][c] = 0
    # stack at signal (0,5)
    cur = 0
    # place smallest(area 2) color 2
    output_grid[cur][5] = 2
    output_grid[cur+1][5] = 2
    cur += 2
    # place area 3 color 3
    output_grid[cur][5] = 3
    output_grid[cur+1][5] = 3
    output_grid[cur+2][5] = 3
    cur += 3
    # place area 1 color 5
    output_grid[cur][5] = 5
    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0]) if height > 0 else 0

    # find signal position (color 4)
    signal_pos = None
    for r in range(height):
        for c in range(width):
            if grid_in[r][c] == 4:
                signal_pos = (r, c)
                break
        if signal_pos is not None:
            break
    if signal_pos is None:
        # nothing to do
        return tuple(tuple(row) for row in grid_in)

    # collect regions by color (exclude background 0 and signal 4)
    regions = {}
    for r in range(height):
        for c in range(width):
            val = grid_in[r][c]
            if val == 0 or val == 4:
                continue
            regions.setdefault(val, []).append((r, c))

    # build shape data: area, normalized pixels, bounding box sizes
    shapes = []  # list of dicts with keys: color, area, pixels(norm), h, w
    for color, pixels in regions.items():
        area = len(pixels)
        minr = min(p[0] for p in pixels)
        minc = min(p[1] for p in pixels)
        norm = [(r - minr, c - minc) for (r, c) in pixels]
        bh = max(pr for pr, pc in norm) + 1
        bw = max(pc for pr, pc in norm) + 1
        shapes.append({'color': color, 'area': area, 'pixels': norm, 'h': bh, 'w': bw})

    # prepare output as a copy of input, then clear original colored regions and the signal
    output = [row[:] for row in grid_in]
    for color, pixels in regions.items():
        for (r, c) in pixels:
            output[r][c] = 0
    # clear the signal cell
    output[signal_pos[0]][signal_pos[1]] = 0

    # sort shapes by area ascending
    shapes.sort(key=lambda x: x['area'])

    # place shapes stacked top-to-bottom starting at the signal position, left-aligned at signal column
    cur_row = signal_pos[0]
    anchor_col = signal_pos[1]
    for s in shapes:
        for pr, pc in s['pixels']:
            rr = cur_row + pr
            cc = anchor_col + pc
            # safety: only write inside bounds
            if 0 <= rr < height and 0 <= cc < width:
                output[rr][cc] = s['color']
        cur_row += s['h']

    return tuple(tuple(row) for row in output)

