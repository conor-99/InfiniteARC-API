# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: e1223fb9
Difficulty: very hard

=== Tags ===
- Analogical mapping between pairs

=== Description ===
Input grids feature three distinct, non-overlapping regions: Source, Target, and
Query. The Source and Target regions form a pair where the Target is a
transformed version of the Source via a consistent visual transformation
involving both spatial rearrangement and color mapping. The transformation may
combine multiple operations (e.g., rotation, reflection, color inversion, or
positional shift) that must be deduced from the Source-Target relationship. The
Query region must be transformed using the same rule, with its spatial
arrangement and color scheme adjusted accordingly. The output grid retains the
Source and Target regions unchanged while displaying the transformed Query
region. For example, if the Source contains a red vertical line with a blue dot
to its right and the Target contains a green horizontal line with a yellow dot
above it, the transformation rule might involve a 90-degree clockwise rotation
combined with red→green and blue→yellow color mapping. The Query region (e.g., a
purple diagonal line with a black dot below it) would then transform to a
magenta line rotated 90 degrees clockwise with a white dot positioned
accordingly. The challenge arises from identifying the precise combination of
transformations from the Source-Target pair, as multiple plausible rules may
exist, and the Query region may require applying the rule in a non-intuitive
orientation or context.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, flip_horiz, transpose, random_color

def generate():
    size = 3
    source = grid(size, size, 0)
    color = random_color(exclude=[0])
    row = random.randint(0, size-1)
    for c in range(size):
        source[row][c] = color
    colors = set()
    for r in range(size):
        for c in range(size):
            if source[r][c] != 0:
                colors.add(source[r][c])
    colors = list(colors)
    if len(colors) == 1:
        new_color = random_color(exclude=[0, colors[0]])
        color_map = {colors[0]: new_color}
    else:
        perm = random.sample(colors, len(colors))
        color_map = {colors[i]: perm[i] for i in range(len(colors))}
        while color_map == {c: c for c in colors}:
            perm = random.sample(colors, len(colors))
            color_map = {colors[i]: perm[i] for i in range(len(colors))}
    target = flip_horiz(transpose(source))
    for r in range(size):
        for c in range(size):
            if target[r][c] != 0:
                target[r][c] = color_map[target[r][c]]
    query = grid(size, size, 0)
    color = random.choice(colors)
    col = random.randint(0, size-1)
    for r in range(size):
        query[r][col] = color
    transformed_query = flip_horiz(transpose(query))
    for r in range(size):
        for c in range(size):
            if transformed_query[r][c] != 0:
                transformed_query[r][c] = color_map[transformed_query[r][c]]
    grid_width = 6
    grid_height = 6
    input_grid = grid(grid_width, grid_height, 0)
    for r in range(size):
        for c in range(size):
            input_grid[r][c] = source[r][c]
    for r in range(size):
        for c in range(size):
            input_grid[r][c + grid_width - size] = target[r][c]
    for r in range(size):
        for c in range(size):
            input_grid[r + grid_height - size][c] = query[r][c]
    output_grid = [row[:] for row in input_grid]
    for r in range(size):
        for c in range(size):
            output_grid[r + grid_height - size][c] = transformed_query[r][c]
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import flip_horiz, transpose

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    size = 3
    grid_width = len(input_grid[0])
    grid_height = len(input_grid)
    source = [row[:size] for row in input_grid[:size]]
    target = [row[grid_width - size:] for row in input_grid[:size]]
    query = [row[:size] for row in input_grid[grid_height - size:]]
    def rotate_90_cw(grid):
        return flip_horiz(transpose(grid))
    rotated_source = rotate_90_cw(source)
    color_map = {}
    for r in range(size):
        for c in range(size):
            if rotated_source[r][c] != 0:
                color_map[rotated_source[r][c]] = target[r][c]
    transformed_query = rotate_90_cw(query)
    for r in range(size):
        for c in range(size):
            if transformed_query[r][c] != 0:
                transformed_query[r][c] = color_map.get(transformed_query[r][c], transformed_query[r][c])
    for r in range(size):
        for c in range(size):
            input_grid[grid_height - size + r][c] = transformed_query[r][c]
    return input_grid
