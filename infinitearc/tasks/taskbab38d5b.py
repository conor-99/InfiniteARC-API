# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: bab38d5b
Difficulty: very hard

=== Tags ===
- Dual grid translation
- Spatial signal
- Analogical mapping between pairs
- Detect enclosure
- Rotate each quadrant

=== Description ===
The task involves input grids divided into four quadrants (top-left, top-right,
bottom-left, bottom-right). Each quadrant may contain a distinct, closed-loop
enclosure formed by a single color (e.g., red, blue, green) that is visually
distinct from the background. The enclosure must be a simple, gap-free loop
(e.g., a square or circle) fully enclosed within the quadrant, with no
connections to the grid edges or other colors. The color of the enclosure
determines the rotation direction for the entire quadrant: red enclosures
require 90째 clockwise rotation, blue enclosures require 90째 counterclockwise
rotation, and green enclosures leave the quadrant unchanged. The output grid is
formed by applying these rotations to each quadrant that contains a valid
enclosure, while quadrants without enclosures remain unmodified. The rotation
must be applied to the entire quadrant content (including all colored cells
within the quadrant), not just the enclosure. The task requires visual detection
of enclosures (closed loops), mapping enclosure color to rotation direction, and
executing quadrant rotations without altering grid dimensions or overlapping
elements. The complexity arises from distinguishing enclosures from partial
loops, handling variable grid sizes (requiring dynamic quadrant splitting), and
ensuring rotations are applied consistently across all valid quadrants.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, red, blue, green


def generate():
    """Generates an input/output pair for the quadrant-rotation task.

    The grid size is even and at least 12x12 so each quadrant has room for a
    small closed rectangular loop and an asymmetric marker that guarantees a
    non-trivial rotation. Each quadrant may contain either: no enclosure, or a
    single closed-loop frame (one-pixel-thick rectangle) of a single color
    (red/blue/green). Red -> rotate 90째 clockwise, Blue -> rotate 90째 counter-
    clockwise, Green -> unchanged. At least one quadrant is guaranteed to be
    red or blue so input != output.
    """
    size = random.choice(list(range(12, 31, 2)))  # even sizes, quadrant >= 6
    q = size // 2

    # Initialize input grid with background color 0
    input_grid = grid(size, size, 0)

    # Decide for each of the 4 quadrants whether to place an enclosure
    assignments = []  # each element is None or 'red'/'blue'/'green'
    for _ in range(4):
        if random.random() < 0.6:
            assignments.append(random.choice(['red', 'blue', 'green']))
        else:
            assignments.append(None)
    # Guarantee at least one rotating enclosure (red or blue)
    if not any(a in ('red', 'blue') for a in assignments):
        idx = random.randrange(4)
        assignments[idx] = random.choice(['red', 'blue'])

    # Populate quadrants
    for idx, assign in enumerate(assignments):
        i = idx // 2
        j = idx % 2
        top = i * q
        left = j * q

        if assign is None:
            # Small random noise in empty quadrants to increase variety
            if random.random() < 0.4:
                for _ in range(random.randint(1, 3)):
                    r = random.randint(top, top + q - 1)
                    c = random.randint(left, left + q - 1)
                    input_grid[r][c] = random.randint(4, 9)
            continue

        colornum = {'red': red(), 'blue': blue(), 'green': green()}[assign]

        # Choose a rectangular loop (frame) that doesn't touch quadrant edges
        # and leaves at least one cell of padding on both sides.
        max_dim = q - 3
        if max_dim < 3:
            H = W = 3
        else:
            H = random.randint(3, max_dim)
            W = random.randint(3, max_dim)
        r0_rel = random.randint(1, q - H - 1)
        c0_rel = random.randint(1, q - W - 1)

        # Draw the frame (one-pixel thick border)
        for rr in range(H):
            for cc in range(W):
                gr = top + r0_rel + rr
                gc = left + c0_rel + cc
                if rr == 0 or rr == H - 1 or cc == 0 or cc == W - 1:
                    input_grid[gr][gc] = colornum
                else:
                    input_grid[gr][gc] = 0

        # For red/blue (rotating) frames, add a single asymmetric marker (other color)
        # placed so it does not touch the loop (no 4-neighbor adjacency) and is not
        # inside the frame interior. This ensures the rotation is not a trivial
        # symmetry and guarantees input != output.
        if assign in ('red', 'blue'):
            possible_marker_colors = [c for c in range(4, 10) if c != colornum]
            marker_color = random.choice(possible_marker_colors)
            safe_positions = []
            for rr in range(q):
                for cc in range(q):
                    gr = top + rr
                    gc = left + cc
                    if input_grid[gr][gc] != 0:
                        continue
                    # avoid placing inside the frame interior
                    if r0_rel < rr < r0_rel + H - 1 and c0_rel < cc < c0_rel + W - 1:
                        continue
                    # avoid the central fixed point for odd quadrant sizes
                    if q % 2 == 1:
                        center_r = top + q // 2
                        center_c = left + q // 2
                        if gr == center_r and gc == center_c:
                            continue
                    # ensure no 4-neighbor is the loop color
                    adjacent = False
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr = gr + dr
                        nc = gc + dc
                        if nr < top or nr >= top + q or nc < left or nc >= left + q:
                            continue
                        if input_grid[nr][nc] == colornum:
                            adjacent = True
                            break
                    if adjacent:
                        continue
                    safe_positions.append((gr, gc))
            if safe_positions:
                gr, gc = random.choice(safe_positions)
                input_grid[gr][gc] = marker_color
            else:
                # fallback: put the marker in a quadrant corner (should be safe given the padding)
                corners = [
                    (top, left),
                    (top, left + q - 1),
                    (top + q - 1, left),
                    (top + q - 1, left + q - 1),
                ]
                gr, gc = random.choice(corners)
                input_grid[gr][gc] = marker_color

    # Build output by rotating quadrants according to the loop color
    output_grid = [row[:] for row in input_grid]

    def rotate_cw(mat):
        return [list(row) for row in zip(*mat[::-1])]

    def rotate_ccw(mat):
        return [list(row) for row in zip(*mat)][::-1]

    for idx, assign in enumerate(assignments):
        i = idx // 2
        j = idx % 2
        top = i * q
        left = j * q
        quad = [input_grid[top + r][left:left + q] for r in range(q)]
        if assign == 'red':
            newquad = rotate_cw(quad)
        elif assign == 'blue':
            newquad = rotate_ccw(quad)
        else:
            newquad = quad
        for r in range(q):
            for c in range(q):
                output_grid[top + r][left + c] = newquad[r][c]

    return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    import common
    # Convert to mutable list-of-lists
    grid_list = [list(row) for row in input_grid]
    size = len(grid_list)
    q = size // 2

    def rotate_cw(mat):
        return [list(row) for row in zip(*mat[::-1])]

    def rotate_ccw(mat):
        return [list(row) for row in zip(*mat)][::-1]

    output = [row[:] for row in grid_list]

    # Examine each quadrant independently
    for i in range(2):
        for j in range(2):
            top = i * q
            left = j * q
            sub = [grid_list[top + r][left:left + q] for r in range(q)]

            enclosure_color = None
            # find candidate non-zero colors
            colors = sorted({cell for row in sub for cell in row if cell != 0})
            for color in colors:
                # gather pixels of this color
                pix = [(r, c) for r in range(q) for c in range(q) if sub[r][c] == color]
                if not pix:
                    continue
                rmin = min(r for r, c in pix)
                rmax = max(r for r, c in pix)
                cmin = min(c for r, c in pix)
                cmax = max(c for r, c in pix)

                # must be strictly inside the quadrant (not touching quadrant edge)
                if rmin <= 0 or cmin <= 0 or rmax >= q - 1 or cmax >= q - 1:
                    continue

                h = rmax - rmin + 1
                w = cmax - cmin + 1
                if h < 3 or w < 3:
                    continue

                # border must be all color and interior must be background
                ok = True
                for rr in range(rmin, rmax + 1):
                    for cc in range(cmin, cmax + 1):
                        if rr == rmin or rr == rmax or cc == cmin or cc == cmax:
                            if sub[rr][cc] != color:
                                ok = False
                                break
                        else:
                            if sub[rr][cc] != 0:
                                ok = False
                                break
                    if not ok:
                        break
                if not ok:
                    continue

                # connectedness (4-neighbor) of the color component
                visited = set()
                stack = [pix[0]]
                visited.add(pix[0])
                while stack:
                    rr, cc = stack.pop()
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr = rr + dr
                        nc = cc + dc
                        if 0 <= nr < q and 0 <= nc < q and sub[nr][nc] == color and (nr, nc) not in visited:
                            visited.add((nr, nc))
                            stack.append((nr, nc))
                if len(visited) != len(pix):
                    continue

                # the number of pixels must equal the frame perimeter
                if len(pix) != 2 * (h + w) - 4:
                    continue

                # ensure frame pixels are not directly adjacent to other colors
                adjacent_other = False
                for rr, cc in pix:
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr = rr + dr
                        nc = cc + dc
                        if 0 <= nr < q and 0 <= nc < q:
                            if sub[nr][nc] != 0 and sub[nr][nc] != color:
                                adjacent_other = True
                                break
                    if adjacent_other:
                        break
                if adjacent_other:
                    continue

                enclosure_color = color
                break

            # If an enclosure was found, map its color to a rotation and apply it
            if enclosure_color is None:
                continue
            if enclosure_color == common.red():
                newquad = rotate_cw([grid_list[top + r][left:left + q] for r in range(q)])
            elif enclosure_color == common.blue():
                newquad = rotate_ccw([grid_list[top + r][left:left + q] for r in range(q)])
            else:
                # green (or other non-rotating colors) => leave unchanged
                newquad = [grid_list[top + r][left:left + q] for r in range(q)]

            for r in range(q):
                for c in range(q):
                    output[top + r][left + c] = newquad[r][c]

    return tuple(tuple(row) for row in output)

