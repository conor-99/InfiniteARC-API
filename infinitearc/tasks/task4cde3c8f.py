# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 4cde3c8f
Difficulty: hard

=== Tags ===
- Stacked layer alignment
- Rotating signal

=== Description ===
Input grids feature three concentric rectangular frames, each centered and
separated by uniform background cells. Each frame contains a continuous path of
a single color forming a spiral that starts at the top edge and spirals inward.
The spiral direction alternates starting with clockwise for the outermost frame,
counterclockwise for the middle frame, and clockwise for the innermost frame.
The paths are precisely aligned such that their starting points at the top edge
are vertically stacked, creating a continuous visual flow between layers.  The
output grid extends this pattern by adding a fourth concentric frame inside the
innermost layer. This new frame's spiral direction continues the alternating
pattern (counterclockwise), and its path is rotated 90 degrees counterclockwise
relative to the previous frame's path direction. The starting point of the new
spiral aligns precisely with the inner edge of the third frame's spiral path,
maintaining vertical alignment and continuity. The new spiral uses a distinct
color not present in the input to ensure visual differentiation, while all
existing frames remain unchanged in both position and pattern. The
transformation requires recognizing both the alternating direction pattern and
the consistent 90-degree rotational offset between consecutive layers.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    size = random.randint(10, 30)
    grid_in = grid(size, size, 0)
    grid_out = [row[:] for row in grid_in]
    
    # Randomly select 3 distinct colors for frames
    colors = random.sample(range(1, 9), 3)
    
    for i in range(1, 4):
        top = i
        left = i
        bottom = size - i - 1
        right = size - i - 1
        color = colors[i-1]
        for c in range(left, right + 1):
            grid_in[top][c] = color
            grid_out[top][c] = color
        for r in range(top + 1, bottom + 1):
            grid_in[r][right] = color
            grid_out[r][right] = color
        for c in range(right - 1, left - 1, -1):
            grid_in[bottom][c] = color
            grid_out[bottom][c] = color
        for r in range(bottom - 1, top, -1):
            grid_in[r][left] = color
            grid_out[r][left] = color

    # Choose new color not in input
    used_colors = set(colors)
    new_color = 4
    while new_color in used_colors:
        new_color += 1

    top, left, bottom, right = 4, 4, size - 5, size - 5
    for c in range(left, right + 1):
        grid_out[top][c] = new_color
    for r in range(top + 1, bottom + 1):
        grid_out[r][right] = new_color
    for c in range(right - 1, left - 1, -1):
        grid_out[bottom][c] = new_color
    for r in range(bottom - 1, top, -1):
        grid_out[r][left] = new_color

    return {
        "input": grid_in,
        "output": grid_out
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    size = len(input_grid)
    # Convert input from tuple of tuples to list of lists
    output_grid = [list(row) for row in input_grid]
    
    # Identify used colors in input
    used_colors = set()
    for row in input_grid:
        for cell in row:
            if cell > 0:
                used_colors.add(cell)
    
    # Find next available color
    new_color = 4
    while new_color in used_colors:
        new_color += 1

    # Add fourth frame
    top, left, bottom, right = 4, 4, size - 5, size - 5
    for c in range(left, right + 1):
        output_grid[top][c] = new_color
    for r in range(top + 1, bottom + 1):
        output_grid[r][right] = new_color
    for c in range(right - 1, left - 1, -1):
        output_grid[bottom][c] = new_color
    for r in range(bottom - 1, top, -1):
        output_grid[r][left] = new_color

    return output_grid
