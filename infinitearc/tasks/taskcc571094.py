# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: cc571094
Difficulty: hard

=== Tags ===
- Inference from demonstration
- Recursive path tracing
- Stateful propagation

=== Description ===
Input grids are 15×15 to 25×25 grids with a single background color (0).
Overlaid on the background are two key elements: a "root" cell (color 1)
positioned near the top-left corner, and a sequence of "state" cells (colors
2-9) arranged in a non-linear path through the grid. Each state cell contains a
unique color that encodes a directional transformation rule relative to the
path's current orientation: color 2 = rotate 90° clockwise, color 3 = rotate 90°
counterclockwise, color 4 = reverse direction, color 5 = continue straight, and
colors 6-9 = apply the corresponding directional rule from a hidden recursive
sequence (e.g., color 6 = apply color 2's rule, color 7 = apply color 3's rule,
etc.).  The path originates at the root cell and begins moving right. As it
traverses the grid, each time it encounters a state cell, the path's current
direction is updated according to the cell's color. Crucially, colors 6-9
require recursive inference: the rule for color 6 mirrors the rule for color 2
(clockwise), color 7 mirrors color 3 (counterclockwise), color 8 mirrors color 4
(reverse), and color 9 mirrors color 5 (straight). This creates a recursive
transformation layer where higher-numbered colors indirectly reference lower-
numbered rules.  The path continues until it exits the grid boundary. The output
grid preserves all input elements (root cell, state cells, background) but adds
a continuous "trace" line (color 10) along the path's route. The trace occupies
only background cells (0) and never overlaps with state cells or the root. The
trace must correctly reflect all directional changes at each state cell,
including the recursive application of rules for colors 6-9. The path's sequence
must form a single continuous line without crossings, and the recursive
inference must be deduced from the input-output examples to determine the hidden
color-to-rule mapping for colors 6-9.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    DIRS = [(-1, 0), (0, 1), (1, 0), (0, -1)]  # up, right, down, left
    alias = {6: 2, 7: 3, 8: 5}

    def apply_base_rule(dir_idx, base):
        if base == 2:  # clockwise (right turn)
            return (dir_idx + 1) % 4
        if base == 3:  # counterclockwise (left turn)
            return (dir_idx - 1) % 4
        if base == 5:  # straight
            return dir_idx
        if base == 4:  # reverse (avoid if possible)
            return (dir_idx + 2) % 4
        return dir_idx

    for attempt in range(500):
        size = random.randint(15, 25)
        grid = [[0 for _ in range(size)] for _ in range(size)]

        # Place root near top-left
        root_r = random.randint(1, min(3, size - 3))
        root_c = random.randint(1, min(3, size - 3))
        root = (root_r, root_c)

        dir_idx = 1  # start moving right
        path = [root]
        visited = {root}

        # Decide number of state cells
        num_states = random.randint(3, 6)

        ok = True
        cur_r, cur_c = root

        for _ in range(num_states):
            # compute how many free steps are available straight ahead
            max_ahead = 0
            tr, tc = cur_r, cur_c
            dr, dc = DIRS[dir_idx]
            while True:
                tr += dr
                tc += dc
                if tr < 0 or tr >= size or tc < 0 or tc >= size:
                    break
                if (tr, tc) in visited:
                    break
                max_ahead += 1

            if max_ahead <= 0:
                ok = False
                break

            # choose steps to move before placing a state (at least 1, prefer 2+)
            min_steps = 1
            max_steps = min(max_ahead, 6)
            steps = random.randint(min_steps, max_steps)

            # move forward 'steps' times
            for _s in range(steps):
                dr, dc = DIRS[dir_idx]
                cur_r += dr
                cur_c += dc
                if cur_r < 0 or cur_r >= size or cur_c < 0 or cur_c >= size:
                    ok = False
                    break
                if (cur_r, cur_c) in visited:
                    ok = False
                    break
                path.append((cur_r, cur_c))
                visited.add((cur_r, cur_c))
            if not ok:
                break

            # Now at the place to put a state. Choose a color such that the resulting
            # new forward cell is valid (not visited and inside grid). Prefer base colors
            possible_state_colors = [2, 3, 5, 6, 7, 8]
            random.shuffle(possible_state_colors)
            placed = False
            for color in possible_state_colors:
                base = alias.get(color, color)
                new_dir = apply_base_rule(dir_idx, base)
                # the next cell after applying the rule (i.e., the step leaving this state)
                nr = cur_r + DIRS[new_dir][0]
                nc = cur_c + DIRS[new_dir][1]
                # allow next cell to be outside only if this is the final segment; otherwise require inside and unused
                if nr < 0 or nr >= size or nc < 0 or nc >= size:
                    # We might accept an exit only if this is the last state (or occasionally) but reserve exit for after all states
                    continue
                if (nr, nc) in visited:
                    continue
                # Good candidate
                grid[cur_r][cur_c] = color
                dir_idx = new_dir
                placed = True
                break

            if not placed:
                # Couldn't place a state here without causing immediate collision; fail this attempt
                ok = False
                break

        if not ok:
            continue

        # After placing all states, continue straight until exiting the grid
        while True:
            dr, dc = DIRS[dir_idx]
            nr = cur_r + dr
            nc = cur_c + dc
            if nr < 0 or nr >= size or nc < 0 or nc >= size:
                # we've reached a point where the next step would exit the grid
                break
            if (nr, nc) in visited:
                ok = False
                break
            cur_r, cur_c = nr, nc
            path.append((cur_r, cur_c))
            visited.add((cur_r, cur_c))

        if not ok:
            continue

        # Path must be reasonably long
        if len(path) < 8:
            continue

        # Place root color
        grid[root[0]][root[1]] = 1

        # Build output by marking the trace (color 9) on all path cells that are background
        output = [row[:] for row in grid]
        trace_color = 9
        for (r, c) in path:
            if grid[r][c] == 0:
                output[r][c] = trace_color

        # Ensure input and output differ
        if grid == output:
            continue

        return {"input": grid, "output": output}

    # Fallback
    size = 15
    grid = [[0 for _ in range(size)] for _ in range(size)]
    grid[1][1] = 1
    output = [row[:] for row in grid]
    output[1][2] = 9
    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to a mutable list of lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0]) if h > 0 else 0

    # Find the root cell (color 1)
    root = None
    for r in range(h):
        for c in range(w):
            if grid[r][c] == 1:
                root = (r, c)
                break
        if root is not None:
            break

    if root is None:
        return grid

    DIRS = [(-1, 0), (0, 1), (1, 0), (0, -1)]  # up, right, down, left
    dir_idx = 1  # start moving right

    # Base rules
    base_rules = {2: 'R', 3: 'L', 5: 'S', 4: 'REV'}
    # Aliases: indirect colors point to base colors
    alias = {6: 2, 7: 3, 8: 5}

    def resolve_rule(color):
        # Resolve aliases recursively until we find a base rule
        seen = set()
        c = color
        while True:
            if c in base_rules:
                return base_rules[c]
            if c in alias:
                c = alias[c]
                if c in seen:
                    # fallback
                    return 'S'
                seen.add(c)
                continue
            # Unknown color: treat as straight
            return 'S'

    path = [root]
    r, c = root

    # Walk until we exit the grid boundary
    while True:
        dr, dc = DIRS[dir_idx]
        nr, nc = r + dr, c + dc
        # If next cell is outside, we have exited
        if nr < 0 or nr >= h or nc < 0 or nc >= w:
            break

        path.append((nr, nc))

        cell = grid[nr][nc]
        # If this is a state cell, update direction according to its rule
        if cell != 0 and cell != 1:
            rule = resolve_rule(cell)
            if rule == 'R':
                dir_idx = (dir_idx + 1) % 4
            elif rule == 'L':
                dir_idx = (dir_idx - 1) % 4
            elif rule == 'REV':
                dir_idx = (dir_idx + 2) % 4
            # 'S' means keep direction

        # Move forward
        r, c = nr, nc

        # Safety: prevent infinite loops by bounding visits
        if len(path) > h * w + 5:
            break

    # Produce output grid marking the trace with color 9 on background cells only
    out = [row[:] for row in grid]
    trace_color = 9
    for (rr, cc) in path:
        if out[rr][cc] == 0:
            out[rr][cc] = trace_color

    return out

