# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 9a41ab38
Difficulty: very hard

=== Tags ===
- Oscillating rule
- Wavefront timing
- Color implication network

=== Description ===
Input grids are 2D matrices (1×1 to 30×30) with background color 0. Sources are
non-background cells (colors 1-9) that emit wavefronts propagating in four
cardinal directions (up, down, left, right) at one cell per time step.
Obstacles—non-background cells (colors 1-9, distinct from sources)—block
wavefront propagation. Wavefronts traverse only background cells (0), changing
their color to the current wavefront color. Wavefront color alternates between
the source color and the next color in a cyclic sequence (1→2→…→9→1) with each
step away from the source. For each background cell, the output color is
determined by the closest source (minimum Manhattan distance), with the color
set to the source color if the distance is even, or the next color in the cycle
if the distance is odd. Obstacles remain unchanged, and all background cells in
the output are colored (no background cells remain). Wavefronts propagate until
blocked by obstacles or grid edges, and the transformation requires resolving
multiple overlapping wavefronts with oscillating color rules and distance-based
color implications.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque
import heapq

def generate():
    """Generates an input/output pair for the oscillating wavefront task.

    The generator creates a grid with 2-4 sources (distinct non-zero colors) and
    several obstacle cells (a single obstacle color distinct from source colors).
    Obstacles block propagation of wavefronts. The output is computed by
    simulating multi-source wavefronts that propagate only through background
    cells (0). For determinism, all obstacles share the same color and appear
    at least twice so the solver can unambiguously identify which colors are
    sources (colors that occur exactly once).
    """
    # Grid size
    width = random.randint(5, 20)
    height = random.randint(5, 20)
    grid = [[0 for _ in range(width)] for _ in range(height)]

    # Place sources: 2-4 distinct colors
    num_sources = random.randint(2, 4)
    source_colors = random.sample(range(1, 10), num_sources)
    source_positions = []  # list of tuples (r, c, color)

    for color in source_colors:
        placed = False
        for _ in range(200):
            r = random.randint(0, height - 1)
            c = random.randint(0, width - 1)
            if grid[r][c] == 0:
                grid[r][c] = color
                source_positions.append((r, c, color))
                placed = True
                break
        if not placed:
            # fallback: find first empty cell
            for r in range(height):
                for c in range(width):
                    if grid[r][c] == 0:
                        grid[r][c] = color
                        source_positions.append((r, c, color))
                        placed = True
                        break
                if placed: break

    # Prepare obstacle colors (must not reuse source colors)
    available_colors = [c for c in range(1, 10) if c not in set(source_colors)]

    # Decide how many obstacles to attempt (leave at least one background cell)
    max_obstacles = max(2, min(12, width * height - len(source_positions) - 1))
    num_obstacles = random.randint(2, max_obstacles)

    # Choose a single obstacle color so that obstacles are easily identifiable
    obstacle_color = random.choice(available_colors) if available_colors else random.randint(1, 9)

    # Candidate positions for obstacles (exclude sources)
    candidates = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == 0]
    random.shuffle(candidates)

    # Helper: check that all background cells are reachable from some source
    def background_reachable(tempgrid):
        h = len(tempgrid)
        w = len(tempgrid[0])
        visited = set()
        q = deque()
        # Start from background neighbors of every source (distance 1)
        for sr, sc, _ in source_positions:
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = sr + dr, sc + dc
                if 0 <= nr < h and 0 <= nc < w and tempgrid[nr][nc] == 0 and (nr, nc) not in visited:
                    visited.add((nr, nc))
                    q.append((nr, nc))
        while q:
            r, c = q.popleft()
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = r + dr, c + dc
                if 0 <= nr < h and 0 <= nc < w and tempgrid[nr][nc] == 0 and (nr, nc) not in visited:
                    visited.add((nr, nc))
                    q.append((nr, nc))
        total_bg = sum(1 for r in range(h) for c in range(w) if tempgrid[r][c] == 0)
        return len(visited) == total_bg

    obstacles = []
    for (r, c) in candidates:
        if len(obstacles) >= num_obstacles:
            break
        grid[r][c] = obstacle_color
        if background_reachable(grid):
            obstacles.append((r, c, obstacle_color))
        else:
            grid[r][c] = 0

    # If not enough obstacles placed, try again with different ordering,
    # then try border-first heuristic to find safe placements.
    if len(obstacles) < 2:
        # second pass
        random.shuffle(candidates)
        for (r, c) in candidates:
            if len(obstacles) >= num_obstacles:
                break
            if grid[r][c] != 0:
                continue
            grid[r][c] = obstacle_color
            if background_reachable(grid):
                obstacles.append((r, c, obstacle_color))
            else:
                grid[r][c] = 0

    if len(obstacles) < 2:
        # Try border-first candidates (often safe)
        border_cells = [(r, c) for r in range(height) for c in range(width)
                        if r in (0, height - 1) or c in (0, width - 1)]
        for (r, c) in border_cells:
            if len(obstacles) >= num_obstacles:
                break
            if grid[r][c] != 0:
                continue
            grid[r][c] = obstacle_color
            if background_reachable(grid):
                obstacles.append((r, c, obstacle_color))
            else:
                grid[r][c] = 0

    # If still not enough, reduce obstacle target to what we managed to place
    if len(obstacles) < 2:
        # ensure at least two obstacles exist; if impossible (very unlikely), place them without reachability check
        remaining = [pos for pos in candidates if grid[pos[0]][pos[1]] == 0]
        idx = 0
        while len(obstacles) < 2 and idx < len(remaining):
            r, c = remaining[idx]
            grid[r][c] = obstacle_color
            obstacles.append((r, c, obstacle_color))
            idx += 1

    # Multi-source Dijkstra-like search (heap) to compute shortest path lengths through background cells
    INF = 10 ** 9
    dist = [[INF] * width for _ in range(height)]
    owner = [[None] * width for _ in range(height)]

    heap = []  # elements are tuples (distance, owner_color, r, c)

    # Seed heap with neighbors of sources (distance 1) so we never traverse through non-zero cells
    for sr, sc, color in source_positions:
        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
            nr, nc = sr + dr, sc + dc
            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0:
                if 1 < dist[nr][nc] or (1 == dist[nr][nc] and (owner[nr][nc] is None or color < owner[nr][nc])):
                    dist[nr][nc] = 1
                    owner[nr][nc] = color
                    heapq.heappush(heap, (1, color, nr, nc))

    # Process the heap ensuring tie-breaking on (distance, owner color)
    while heap:
        d, col, r, c = heapq.heappop(heap)
        # If this entry is outdated, skip
        if d != dist[r][c] or col != owner[r][c]:
            continue
        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0:
                nd = d + 1
                if nd < dist[nr][nc] or (nd == dist[nr][nc] and (owner[nr][nc] is None or col < owner[nr][nc])):
                    dist[nr][nc] = nd
                    owner[nr][nc] = col
                    heapq.heappush(heap, (nd, col, nr, nc))

    # Build output grid: non-zero cells unchanged; zeros recolored according to parity
    output = [[grid[r][c] for c in range(width)] for r in range(height)]
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0:
                d = dist[r][c]
                if d == INF:
                    # This should not happen because we guarded obstacle placement, but
                    # provide a deterministic fallback: nearest (Manhattan) source with tie
                    # by smaller source color.
                    min_d = 10 ** 9
                    min_color = 100
                    for sr, sc, color in source_positions:
                        md = abs(sr - r) + abs(sc - c)
                        if md < min_d or (md == min_d and color < min_color):
                            min_d = md
                            min_color = color
                    d = min_d
                    owner_color = min_color
                else:
                    owner_color = owner[r][c]
                if d % 2 == 0:
                    output[r][c] = owner_color
                else:
                    output[r][c] = (owner_color % 9) + 1

    return {
        "input": grid,
        "output": output
    }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import heapq
from collections import Counter

def p(input_grid):
    """Solver that applies the same multi-source wavefront rules used in the
    generator. It computes shortest paths through background cells (0) from
    each source (non-zero cells). Ties at equal distance are resolved by picking
    the source with smaller numeric color. The color placed at distance d is
    source color if d is even, otherwise the next color in the cycle.

    The solver first infers which non-zero cells are sources by checking color
    frequencies: the generator ensures source colors occur exactly once while
    obstacle colors occur multiple times (all obstacles share one color). This
    makes source detection unambiguous.
    """
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height else 0

    # Find colors and their frequencies to distinguish sources vs obstacles
    color_counts = Counter()
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if v != 0:
                color_counts[v] += 1

    # Colors that occur exactly once are treated as sources
    source_colors = {color for color, cnt in color_counts.items() if cnt == 1}
    sources = []
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if v != 0 and v in source_colors:
                sources.append((r, c, v))

    INF = 10 ** 9
    dist = [[INF] * width for _ in range(height)]
    owner = [[None] * width for _ in range(height)]

    heap = []
    # Seed heap with neighbors of sources (distance 1)
    for sr, sc, color in sources:
        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
            nr, nc = sr + dr, sc + dc
            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0:
                if 1 < dist[nr][nc] or (1 == dist[nr][nc] and (owner[nr][nc] is None or color < owner[nr][nc])):
                    dist[nr][nc] = 1
                    owner[nr][nc] = color
                    heapq.heappush(heap, (1, color, nr, nc))

    # Process heap by (distance, owner color)
    while heap:
        d, col, r, c = heapq.heappop(heap)
        if d != dist[r][c] or col != owner[r][c]:
            continue
        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0:
                nd = d + 1
                if nd < dist[nr][nc] or (nd == dist[nr][nc] and (owner[nr][nc] is None or col < owner[nr][nc])):
                    dist[nr][nc] = nd
                    owner[nr][nc] = col
                    heapq.heappush(heap, (nd, col, nr, nc))

    # Build output grid
    output = [[grid[r][c] for c in range(width)] for r in range(height)]
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0:
                d = dist[r][c]
                if d == INF:
                    # Fallback: nearest Manhattan source (deterministic tie by color)
                    min_d = 10 ** 9
                    min_color = 100
                    for sr, sc, color in sources:
                        md = abs(sr - r) + abs(sc - c)
                        if md < min_d or (md == min_d and color < min_color):
                            min_d = md
                            min_color = color
                    d = min_d
                    owner_color = min_color
                else:
                    owner_color = owner[r][c]
                if d % 2 == 0:
                    output[r][c] = owner_color
                else:
                    output[r][c] = (owner_color % 9) + 1

    return tuple(tuple(row) for row in output)

