# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 287c8faa
Difficulty: hard

=== Tags ===
- Path merging
- Contouring
- Local physics rule
- Progressive rule shift
- Diagonal symmetry

=== Description ===
Input grids feature multiple distinct colored paths (each path is a contiguous
sequence of cells with a uniform color, distinct from other paths) positioned
asymmetrically relative to the main diagonal (i.e., paths may exist above or
below the diagonal, but not necessarily symmetrically). Each path moves
diagonally toward the main diagonal according to a local physics rule: paths
above the diagonal (r < c) move down-left (increasing row, decreasing column),
while paths below the diagonal (r > c) move up-right (decreasing row, increasing
column). Movement continues until a cell is occupied by another path or the main
diagonal is reached.  When two paths collide (i.e., move into the same cell),
they merge into a single path using a progressive rule shift: the first
collision combines the two path colors into a new color via a fixed rule (e.g.,
color A + color B = color C), the second collision uses a modified rule (e.g.,
color A + color B = color D), cycling through a predefined sequence of color
combination rules. The output grid is constrained to exhibit perfect diagonal
symmetry (i.e., the color at cell (i,j) equals the color at cell (j,i) for all
i,j), which is inherently satisfied because:  1. Paths moving toward the
diagonal from both sides merge on the diagonal (a symmetric position), and the
merged color is applied to the diagonal cell (which is symmetric by definition).
2. Paths moving to non-diagonal cells are adjusted via the progressive rule
shift to maintain symmetry; for example, if a path moves to cell (i,j) where i â‰ 
j, the color is simultaneously applied to cell (j,i) to preserve symmetry, with
the progressive rule ensuring consistent color combinations across symmetric
pairs.  Background cells (color 0) remain unchanged, and all paths are fully
absorbed into the main diagonal or symmetric path pairs. The transformation
ensures the output grid's diagonal symmetry is a direct consequence of the path
movement, collision, and progressive color rule application.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Size between small and medium to keep generation fast but varied
    size = random.randint(6, 18)
    input_grid = grid(size, size, 0)
    output_grid = grid(size, size, 0)

    # Choose 1-3 collision anti-diagonals (k positions on main diagonal)
    max_collisions = min(3, max(1, size - 2))
    num_collisions = random.randint(1, max_collisions)

    # pick distinct k positions away from the edges so paths can exist
    ks = random.sample(range(1, size - 1), num_collisions)
    ks_sorted = sorted(ks)

    # pick distinct colors for the paths (2 colors per collision)
    all_colors = list(range(1, 10))
    random.shuffle(all_colors)
    needed = 2 * num_collisions
    if needed <= len(all_colors):
        colors = all_colors[:needed]
    else:
        # fallback: reuse colors if somehow needed > available (shouldn't happen here)
        colors = [random.choice(range(1, 10)) for _ in range(needed)]

    ci = 0
    for k in ks_sorted:
        color_above = colors[ci]; color_below = colors[ci + 1]
        ci += 2

        # maximum length so the path stays within bounds and doesn't touch the main grid edges
        max_len = min(k, size - 1 - k)
        if max_len < 1:
            max_len = 1
        len_above = random.randint(1, max_len)
        len_below = random.randint(1, max_len)

        # Place an "above" path: cells with r < c, along the anti-diagonal r+c == 2*k
        for m in range(1, len_above + 1):
            r, c = k - m, k + m
            if 0 <= r < size and 0 <= c < size:
                input_grid[r][c] = color_above

        # Place a "below" path: cells with r > c, along the same anti-diagonal r+c == 2*k
        for m in range(1, len_below + 1):
            r, c = k + m, k - m
            if 0 <= r < size and 0 <= c < size:
                input_grid[r][c] = color_below

    # Build output by merging colors that target the same diagonal cell.
    # Group colors by k = (r+c)//2 for even r+c only.
    k_to_colors = {}
    for r in range(size):
        for c in range(size):
            col = input_grid[r][c]
            if col == 0:
                continue
            s = r + c
            if s % 2 != 0:
                # generator avoids odd sums, but ignore if any appear
                continue
            k = s // 2
            k_to_colors.setdefault(k, []).append(col)

    # Apply a progressive rule shift based on the sorted order of the collision ks.
    # For each diagonal index k (in ascending order) use its index as an offset to the merge.
    for idx, k in enumerate(sorted(k_to_colors.keys())):
        cols = k_to_colors[k]
        if len(cols) == 1:
            merged = cols[0]
        else:
            # deterministic progressive rule: sum of colors plus the collision index,
            # then wrap into the 1..9 color range
            merged = (sum(cols) + idx) % 9 + 1
        output_grid[k][k] = merged

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input (possibly Tuple[Tuple[int]]) to a mutable list of lists
    grid_in = [list(row) for row in input_grid]
    size = len(grid_in)

    # Group colors by the anti-diagonal sum (per-cell), matching the generator behavior
    k_to_colors = {}
    for r in range(size):
        for c in range(size):
            col = grid_in[r][c]
            if col == 0:
                continue
            s = r + c
            if s % 2 != 0:
                continue
            k = s // 2
            k_to_colors.setdefault(k, []).append(col)

    # Build output grid: diagonal symmetry is satisfied by placing merges on the main diagonal
    output = [[0] * size for _ in range(size)]
    for idx, k in enumerate(sorted(k_to_colors.keys())):
        cols = k_to_colors[k]
        if len(cols) == 1:
            merged = cols[0]
        else:
            merged = (sum(cols) + idx) % 9 + 1
        output[k][k] = merged

    return output

