# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 5206e808
Difficulty: hard

=== Tags ===
- Local rule cascade
- Deterministic reflection
- Find the odd shape out
- Detect hor lines

=== Description ===
Input grids are composed of a background color (0) and multiple distinct,
connected shapes (each shape is a contiguous region of a single non-background
color, 1–9). The grid contains exactly one horizontal line—a full row where all
cells share a uniform non-background color (e.g., all cells in row 5 are color
3), forming a solid horizontal reference. Each shape (except one) is symmetric
with respect to this horizontal line: for every cell (r, c) in the shape, the
cell reflected across the horizontal line (2*line_row - r, c) is also part of
the shape. The "odd" shape is the one lacking this symmetry.   The output grid
is generated by reflecting the odd shape across the horizontal line to restore
symmetry (filling background cells with the shape’s color), while all other
shapes and the horizontal line remain unchanged. Reflection is deterministic:
only cells in the odd shape’s reflection that were background are overwritten;
non-background cells (e.g., from other shapes) are preserved. The horizontal
line itself is never altered, and the output grid retains all original shapes
except the corrected odd shape.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    """
    Generate an ARC-style input/output pair matching the task description.
    - A single full-row horizontal line of a non-zero color.
    - Several colored connected clusters (placed strictly off the line),
      where all but one color have a mirrored counterpart across the line.
    - One "odd" color has only one side present; the output fills its mirror
      cells on the other side wherever those cells are background (0).
    """
    # Grid size
    width = random.randint(5, 15)
    height = random.randint(5, 15)

    # Create empty grid
    grid = [[0 for _ in range(width)] for _ in range(height)]

    # Choose horizontal reference line row and its color
    line_row = random.randint(1, height - 2)
    h_color = random.randint(1, 9)
    for c in range(width):
        grid[line_row][c] = h_color

    # Colors available for shapes (exclude the line color)
    available = [c for c in range(1, 10) if c != h_color]

    # Decide how many shapes to place (including the odd one).
    # Keep small to ensure placement succeeds quickly.
    max_shapes = min(3, len(available))
    n_shapes = random.randint(2, max_shapes)

    # Choose odd color and symmetric colors (distinct)
    odd_color = random.choice(available)
    other_colors = [c for c in available if c != odd_color]
    sym_count = n_shapes - 1
    if sym_count > len(other_colors):
        sym_colors = other_colors[:]
    else:
        sym_colors = random.sample(other_colors, sym_count)

    # Track occupied coordinates to avoid overlapping shapes
    occupied = set((line_row, c) for c in range(width))

    # Helper: allowed row ranges for above/below so reflecting stays in bounds
    def allowed_rows_above():
        # r in [top_min, line_row-1] where top_min chosen so 2*line_row - r < height
        return max(0, 2 * line_row - (height - 1)), line_row - 1

    def allowed_rows_below():
        # r in [line_row+1, bottom_max] where bottom_max chosen so 2*line_row - r >= 0
        return line_row + 1, min(height - 1, 2 * line_row)

    # Helper: generate a connected cluster (4-neighborhood) within given row bounds
    def gen_cluster(rmin, rmax, max_size=6):
        # Build list of candidate cells not currently occupied
        candidates = [(r, c) for r in range(rmin, rmax + 1) for c in range(width) if (r, c) not in occupied]
        if not candidates:
            return None
        size = random.randint(1, min(max_size, max(1, len(candidates))))
        for _ in range(200):
            start = random.choice(candidates)
            cluster = {start}
            frontier = set()
            r0, c0 = start
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = r0 + dr, c0 + dc
                if nr >= rmin and nr <= rmax and 0 <= nc < width and (nr, nc) not in occupied:
                    frontier.add((nr, nc))
            # Grow until desired size or fail
            while len(cluster) < size and frontier:
                cell = random.choice(tuple(frontier))
                frontier.discard(cell)
                if cell in occupied or cell in cluster:
                    continue
                cluster.add(cell)
                r1, c1 = cell
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = r1 + dr, c1 + dc
                    if nr >= rmin and nr <= rmax and 0 <= nc < width and (nr, nc) not in occupied and (nr, nc) not in cluster:
                        frontier.add((nr, nc))
            if len(cluster) == size:
                return cluster
        return None

    # Place symmetric shapes: for each color, place a connected cluster on one side and mirror it
    for color in sym_colors:
        placed = False
        for _ in range(200):
            side = random.choice(("above", "below"))
            if side == "above":
                rmin, rmax = allowed_rows_above()
            else:
                rmin, rmax = allowed_rows_below()
            if rmin > rmax:
                continue
            # choose a sensible max cluster size relative to available space
            max_possible = max(1, min(6, (rmax - rmin + 1) * width // 4))
            cluster = gen_cluster(rmin, rmax, max_size=max_possible)
            if not cluster:
                continue
            # compute mirror and ensure it's free and in-bounds and not on the line
            mirror = set((2 * line_row - r, c) for (r, c) in cluster)
            ok = True
            for (mr, mc) in mirror:
                if not (0 <= mr < height and 0 <= mc < width) or (mr, mc) in occupied or mr == line_row:
                    ok = False
                    break
            if not ok:
                continue
            # place both halves
            for (r, c) in cluster.union(mirror):
                grid[r][c] = color
                occupied.add((r, c))
            placed = True
            break
        # if can't place after many tries, skip this symmetric color (keeps generator robust)
        if not placed:
            continue

    # Place the odd shape (only one side present). Ensure at least one mirrored cell will be background
    odd_cluster = set()
    for _ in range(400):
        side = random.choice(("above", "below"))
        if side == "above":
            rmin, rmax = allowed_rows_above()
        else:
            rmin, rmax = allowed_rows_below()
        if rmin > rmax:
            continue
        max_possible = max(1, min(6, (rmax - rmin + 1) * width // 4))
        cluster = gen_cluster(rmin, rmax, max_size=max_possible)
        if not cluster:
            continue
        if any((r, c) in occupied for (r, c) in cluster):
            continue
        # check that at least one mirror cell is currently background and in bounds
        will_change = False
        for (r, c) in cluster:
            mr = 2 * line_row - r
            if 0 <= mr < height and (mr, c) not in occupied:
                will_change = True
                break
        if not will_change:
            continue
        # place odd cluster
        for (r, c) in cluster:
            grid[r][c] = odd_color
            occupied.add((r, c))
        odd_cluster = cluster
        break

    # As a fallback (very unlikely), put a single odd pixel where its mirror is empty
    if not odd_cluster:
        for r in range(0, line_row):
            for c in range(width):
                mr = 2 * line_row - r
                if 0 <= mr < height and grid[r][c] == 0 and grid[mr][c] == 0:
                    grid[r][c] = odd_color
                    odd_cluster = {(r, c)}
                    break
            if odd_cluster:
                break

    # Build output by reflecting odd cluster into background cells only
    output = [row[:] for row in grid]
    for (r, c) in odd_cluster:
        mr = 2 * line_row - r
        if 0 <= mr < height and output[mr][c] == 0:
            output[mr][c] = odd_color

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Find the horizontal full-row reference (non-zero and all equal)
    line_row = None
    line_color = None
    for r in range(height):
        first = grid[r][0]
        if first != 0 and all(grid[r][c] == first for c in range(width)):
            line_row = r
            line_color = first
            break
    if line_row is None:
        # Fallback: choose middle row if nothing obvious (shouldn't happen in valid inputs)
        line_row = height // 2
        line_color = grid[line_row][0]

    # Collect colors (exclude background and the line color)
    colors = set()
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if v != 0 and v != line_color:
                colors.add(v)

    # For each color count how many pixels are not mirrored by the same color
    asym_counts = {}
    for color in colors:
        asym_counts[color] = 0

    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if v in colors:
                mr = 2 * line_row - r
                if not (0 <= mr < height) or grid[mr][c] != v:
                    asym_counts[v] += 1

    # Choose the odd color: the one with positive asymmetry (largest if multiple)
    odd_color = None
    max_asym = 0
    for color, count in asym_counts.items():
        if count > max_asym:
            max_asym = count
            odd_color = color

    # If none found (edge cases), pick any available color
    if odd_color is None:
        if colors:
            odd_color = next(iter(colors))
        else:
            # Nothing to do
            return tuple(tuple(row) for row in grid)

    # Make a copy for output and reflect odd color's pixels into any background cells
    output = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if grid[r][c] == odd_color:
                mr = 2 * line_row - r
                if 0 <= mr < height and output[mr][c] == 0:
                    output[mr][c] = odd_color

    return tuple(tuple(row) for row in output)

