# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 9934166e
Difficulty: hard

=== Tags ===
- Bidirectional mapping
- Chain reaction
- Staircase construction
- Find the two identical shapes

=== Description ===
Input grids consist of a background color (0) with multiple non-background
shapes (contiguous groups of cells with colors 1-9) that surround a central
region. Among these shapes, exactly two are identical in both form and color
(same pattern of cells relative to their bounding boxes), with all other shapes
being unique. These two identical shapes must be surrounded by background cells
and positioned such that a clear diagonal path exists between them without
overlapping other shapes.  The output grid transforms the input by adding a
staircase path connecting the two identical shapes. The staircase is constructed
by moving alternately right and down from the top-left corner of the first shape
toward the bottom-right corner of the second shape, with each step occupying a
single background cell. The path forms a continuous zig-zag pattern (right,
down, right, down, etc.) and uses a new color (e.g., color 2) not present in the
original shapes. The transformation requires identifying the two identical
shapes through bidirectional pattern matching (the relative cell positions
within each shape must be identical), then generating the staircase path via
sequential step placement (chain reaction) that strictly adheres to background-
only cells. The staircase must align with the relative positions of the shapes,
forming a geometrically consistent step pattern without overlapping existing
elements.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

# Predefined small connected patterns (each pattern uses coordinates relative to its own min corner)
SMALL_PATTERNS = [
    ((0,0),),
    ((0,0),(0,1)),
    ((0,0),(1,0)),
    ((0,0),(0,1),(1,0)),
    ((0,1),(1,0),(1,1)),
    ((0,0),(0,1),(0,2)),
    ((0,0),(1,0),(2,0)),
    ((0,0),(0,1),(1,0),(1,1)),
    ((0,1),(1,0),(1,1),(1,2)),
    ((0,1),(1,0),(1,1),(2,1)),
]


def generate():
    """Faster generator using a small set of patterns. Produces two identical shapes
    and several unique other shapes, and draws a staircase (color 2) in the output.
    """
    PATH_COLOR = 2
    MAX_TRIES = 300
    for _ in range(60):
        width = random.randint(9, 15)
        height = random.randint(9, 15)
        grid = [[0] * width for _ in range(height)]

        # pick pair color (not PATH_COLOR)
        colors = [c for c in range(1, 10) if c != PATH_COLOR]
        pair_color = random.choice(colors)

        # choose a pair pattern
        pattern = list(random.choice(SMALL_PATTERNS))
        # compute bounding box of pattern
        box_h = max(r for r, c in pattern) + 1
        box_w = max(c for r, c in pattern) + 1

        # candidate placements for pair shapes (first top-left, second bottom-right)
        success = False
        for _try in range(MAX_TRIES):
            # keep a 1-cell border from edges
            r1 = random.randint(1, height - box_h - 3)
            c1 = random.randint(1, width - box_w - 3)
            r2_min = r1 + box_h + 1
            c2_min = c1 + box_w + 1
            if r2_min > (height - box_h - 2) or c2_min > (width - box_w - 2):
                continue
            r2 = random.randint(r2_min, height - box_h - 2)
            c2 = random.randint(c2_min, width - box_w - 2)

            # compute staircase cells
            max_r2 = r2 + box_h - 1
            max_c2 = c2 + box_w - 1
            dx = max_c2 - c1 - 1
            dy = max_r2 - r1 - 1
            if dx < 1 or dy < 1:
                continue
            cur_r, cur_c = r1, c1
            path = []
            valid_path = True
            for i in range(dx + dy):
                if i % 2 == 0:
                    cur_c += 1
                else:
                    cur_r += 1
                if not (0 <= cur_r < height and 0 <= cur_c < width):
                    valid_path = False
                    break
                path.append((cur_r, cur_c))
            if not valid_path:
                continue
            path_set = set(path)

            # ensure pattern placements do not intersect the path
            abs1 = set((r1 + rr, c1 + cc) for rr, cc in pattern)
            abs2 = set((r2 + rr, c2 + cc) for rr, cc in pattern)
            if abs1 & path_set:
                continue
            if abs2 & path_set:
                continue

            # ensure abs1 and abs2 are within bounds and not overlapping
            if abs1 & abs2:
                continue
            ok = True
            for (rr, cc) in abs1 | abs2:
                if not (0 <= rr < height and 0 <= cc < width):
                    ok = False
                    break
            if not ok:
                continue

            # place the pair
            for (rr, cc) in abs1:
                grid[rr][cc] = pair_color
            for (rr, cc) in abs2:
                grid[rr][cc] = pair_color

            # prepare reserved cells (path + 1-cell neighborhood around pair shapes)
            reserved = set(path)
            for (pr, pc) in list(abs1 | abs2):
                for dr in (-1, 0, 1):
                    for dc in (-1, 0, 1):
                        nr, nc = pr + dr, pc + dc
                        if 0 <= nr < height and 0 <= nc < width:
                            reserved.add((nr, nc))

            # place other unique shapes (unique pattern signatures and distinct colors)
            avail_colors = [c for c in range(1, 10) if c != PATH_COLOR and c != pair_color]
            random.shuffle(avail_colors)
            other_count = random.randint(2, min(5, len(avail_colors)))
            used_signatures = {tuple(sorted(pattern))}
            placed_ok = True
            for color in avail_colors[:other_count]:
                placed = False
                for pat in random.sample(SMALL_PATTERNS, k=len(SMALL_PATTERNS)):
                    sig = tuple(sorted(pat))
                    if sig in used_signatures:
                        continue
                    # try to place this pattern somewhere quickly
                    bh2 = max(r for r, c in pat) + 1
                    bw2 = max(c for r, c in pat) + 1
                    # attempt a few random placements
                    for _place in range(60):
                        tr = random.randint(1, height - bh2 - 2)
                        tc = random.randint(1, width - bw2 - 2)
                        abscoords = [(tr + rr, tc + cc) for rr, cc in pat]
                        conflict = False
                        for (ar, ac) in abscoords:
                            if grid[ar][ac] != 0:
                                conflict = True
                                break
                            # neighbors must avoid reserved and other shapes
                            for dr in (-1, 0, 1):
                                for dc in (-1, 0, 1):
                                    nr, nc = ar + dr, ac + dc
                                    if 0 <= nr < height and 0 <= nc < width:
                                        if (nr, nc) in reserved or grid[nr][nc] != 0:
                                            conflict = True
                                            break
                                if conflict:
                                    break
                            if conflict:
                                break
                        if conflict:
                            continue
                        # place
                        for (ar, ac) in abscoords:
                            grid[ar][ac] = color
                        # update reserved by neighbors of this shape
                        for (ar, ac) in abscoords:
                            for dr in (-1, 0, 1):
                                for dc in (-1, 0, 1):
                                    nr, nc = ar + dr, ac + dc
                                    if 0 <= nr < height and 0 <= nc < width:
                                        reserved.add((nr, nc))
                        used_signatures.add(sig)
                        placed = True
                        break
                    if placed:
                        break
                if not placed:
                    placed_ok = False
                    break

            if not placed_ok:
                # rollback and try another placement
                grid = [[0] * width for _ in range(height)]
                continue

            # build input and output
            input_grid = [row[:] for row in grid]
            output_grid = [row[:] for row in grid]
            # color the staircase in the output
            conflict_path = False
            for (pr, pc) in path:
                if input_grid[pr][pc] != 0:
                    conflict_path = True
                    break
                output_grid[pr][pc] = PATH_COLOR
            if conflict_path:
                grid = [[0] * width for _ in range(height)]
                continue

            # quick verification: ensure exactly one signature appears twice
            def components(g):
                H = len(g)
                W = len(g[0])
                vis = [[False]*W for _ in range(H)]
                comps = []
                for rr in range(H):
                    for cc in range(W):
                        if g[rr][cc] == 0 or vis[rr][cc]:
                            continue
                        col = g[rr][cc]
                        stack = [(rr, cc)]
                        vis[rr][cc] = True
                        cells = []
                        while stack:
                            ar, ac = stack.pop()
                            cells.append((ar, ac))
                            for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):
                                nr, nc = ar + dr, ac + dc
                                if 0 <= nr < H and 0 <= nc < W and not vis[nr][nc] and g[nr][nc] == col:
                                    vis[nr][nc] = True
                                    stack.append((nr, nc))
                        minr = min(r for r,c in cells)
                        minc = min(c for r,c in cells)
                        rel = tuple(sorted(((r-minr, c-minc) for r,c in cells)))
                        comps.append((col, rel))
                return comps

            comps = components(input_grid)
            counts = {}
            for s in comps:
                counts[s] = counts.get(s, 0) + 1
            doubles = [k for k,v in counts.items() if v == 2]
            if len(doubles) != 1:
                grid = [[0] * width for _ in range(height)]
                continue

            return {"input": input_grid, "output": output_grid}

    # fallback deterministic tiny instance
    width, height = 10, 10
    grid = [[0]*width for _ in range(height)]
    grid[2][2] = 1
    grid[6][6] = 1
    input_grid = [row[:] for row in grid]
    output_grid = [row[:] for row in grid]
    cur_r, cur_c = 2, 2
    for i in range(7):
        if i % 2 == 0:
            cur_c += 1
        else:
            cur_r += 1
        output_grid[cur_r][cur_c] = PATH_COLOR
    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])
    # find connected components (4-neighborhood) of non-zero cells
    visited = [[False] * w for _ in range(h)]
    components = []  # list of (color, cells list)
    for r in range(h):
        for c in range(w):
            if grid[r][c] == 0 or visited[r][c]:
                continue
            col = grid[r][c]
            stack = [(r, c)]
            visited[r][c] = True
            cells = []
            while stack:
                cr, cc = stack.pop()
                cells.append((cr, cc))
                for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] == col:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            components.append((col, cells))

    # build normalized signatures (color, sorted relative coords)
    sigs = []
    for col, cells in components:
        minr = min(r for r, c in cells)
        minc = min(c for r, c in cells)
        rel = tuple(sorted(((r - minr, c - minc) for r, c in cells)))
        sigs.append((col, rel, minr, minc, cells))

    # find pair: same (color, rel)
    pair = None
    for i in range(len(sigs)):
        for j in range(i+1, len(sigs)):
            if sigs[i][0] == sigs[j][0] and sigs[i][1] == sigs[j][1]:
                pair = (i, j)
                break
        if pair:
            break
    if not pair:
        # nothing to do
        return tuple(tuple(row) for row in grid)

    i, j = pair
    col1, rel1, minr1, minc1, cells1 = sigs[i]
    col2, rel2, minr2, minc2, cells2 = sigs[j]

    # ensure comp1 is top-left of comp2; if not, swap
    if not (minr1 <= minr2 and minc1 <= minc2):
        minr1, minc1, cells1, minr2, minc2, cells2 = minr2, minc2, cells2, minr1, minc1, cells1

    # compute bounding extents for comp2
    maxr2 = max(r for r, c in cells2)
    maxc2 = max(c for r, c in cells2)

    # build staircase path starting from (minr1, minc1)
    start_r, start_c = minr1, minc1
    dx = maxc2 - minc1 - 1
    dy = maxr2 - minr1 - 1
    steps = dx + dy
    cur_r, cur_c = start_r, start_c
    PATH_COLOR = 2
    for t in range(steps):
        if t % 2 == 0:
            cur_c += 1
        else:
            cur_r += 1
        if 0 <= cur_r < h and 0 <= cur_c < w:
            if grid[cur_r][cur_c] == 0:
                grid[cur_r][cur_c] = PATH_COLOR
    return tuple(tuple(row) for row in grid)

