# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 35e2ea86
Difficulty: hard

=== Tags ===
- Color matching

=== Description ===
The task involves transforming an input grid into an output grid where each cell
(i,j) is replaced with color 9 if the color at (i,j) appears again on the
diagonal extending from (i,j) to the bottom-right (i+k, j+k) for some k > 0.
Otherwise, the cell retains its original color. This requires identifying
repeated colors along diagonals, which is a non-trivial pattern that must be
discovered through examples. The transformation is deterministic, relies on
abstract relational reasoning between cell colors and their positional
relationships, and is not immediately obvious from a single input-output pair,
making it suitable for a hard difficulty level.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    width = random.randint(2, 30)
    height = random.randint(2, 30)
    grid_input = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
    
    has_repeat = False
    for i in range(height):
        for j in range(width):
            for k in range(1, min(height - i, width - j)):
                if grid_input[i][j] == grid_input[i + k][j + k]:
                    has_repeat = True
                    break
            if has_repeat:
                break
        if has_repeat:
            break
    
    if not has_repeat:
        candidates = []
        for i in range(height - 1):
            for j in range(width - 1):
                if grid_input[i][j] != 9:
                    candidates.append((i, j))
        if candidates:
            i, j = random.choice(candidates)
            grid_input[i + 1][j + 1] = grid_input[i][j]
        else:
            grid_input[0][0] = 0
            grid_input[1][1] = 0
    
    grid_output = []
    for i in range(height):
        row = []
        for j in range(width):
            found = False
            for k in range(1, min(height - i, width - j)):
                if grid_input[i + k][j + k] == grid_input[i][j]:
                    found = True
                    break
            row.append(9 if found else grid_input[i][j])
        grid_output.append(row)
    
    return {"input": grid_input, "output": grid_output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0]) if height else 0
    output = [[0] * width for _ in range(height)]
    for i in range(height):
        for j in range(width):
            found = False
            for k in range(1, min(height - i, width - j)):
                if input_grid[i + k][j + k] == input_grid[i][j]:
                    found = True
                    break
            output[i][j] = 9 if found else input_grid[i][j]
    return output
