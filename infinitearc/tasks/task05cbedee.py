# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 05cbedee
Difficulty: hard

=== Tags ===
- Recursive partition
- Pattern juxtaposition

=== Description ===
The task involves a recursive partitioning of the input grid into quadrants,
followed by a specific pattern rearrangement. For grids where the width and
height are powers of two, the grid is recursively divided into four quadrants
(top-left, top-right, bottom-left, bottom-right) until each quadrant is 2×2 in
size. Each 2×2 quadrant undergoes a local transformation: the top-left and
bottom-right cells are swapped. After all quadrants are transformed, they are
reassembled by rotating their positions 90 degrees clockwise (top-left → top-
right, top-right → bottom-right, bottom-right → bottom-left, bottom-left → top-
left). This recursive partitioning combined with the rotational rearrangement of
quadrants creates a pattern juxtaposition effect in the output grid, where the
spatial arrangement of patterns is systematically altered through multiple
levels of recursion.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def transform(grid):
    grid_copy = [row[:] for row in grid]
    n = len(grid_copy)
    if n == 2:
        grid_copy[0][0], grid_copy[1][1] = grid_copy[1][1], grid_copy[0][0]
        return grid_copy
    else:
        half = n // 2
        tl = [row[:half] for row in grid_copy[:half]]
        tr = [row[half:] for row in grid_copy[:half]]
        bl = [row[:half] for row in grid_copy[half:]]
        br = [row[half:] for row in grid_copy[half:]]
        tl = transform(tl)
        tr = transform(tr)
        bl = transform(bl)
        br = transform(br)
        new_grid = []
        for i in range(half):
            new_grid.append(bl[i] + tl[i])
        for i in range(half):
            new_grid.append(br[i] + tr[i])
        return new_grid

def generate():
    size = random.choice([2,4,8,16])
    input_grid = [[random.randint(0,9) for _ in range(size)] for _ in range(size)]
    output_grid = transform(input_grid)
    while input_grid == output_grid:
        input_grid = [[random.randint(0,9) for _ in range(size)] for _ in range(size)]
        output_grid = transform(input_grid)
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def transform(grid):
    if isinstance(grid, tuple):
        grid = [list(row) for row in grid]
    grid_copy = [row[:] for row in grid]
    n = len(grid_copy)
    if n == 2:
        grid_copy[0][0], grid_copy[1][1] = grid_copy[1][1], grid_copy[0][0]
        return grid_copy
    else:
        half = n // 2
        tl = [row[:half] for row in grid_copy[:half]]
        tr = [row[half:] for row in grid_copy[:half]]
        bl = [row[:half] for row in grid_copy[half:]]
        br = [row[half:] for row in grid_copy[half:]]
        tl = transform(tl)
        tr = transform(tr)
        bl = transform(bl)
        br = transform(br)
        new_grid = []
        for i in range(half):
            new_grid.append(bl[i] + tl[i])
        for i in range(half):
            new_grid.append(br[i] + tr[i])
        return new_grid

def p(input_grid):
    return transform(input_grid)
