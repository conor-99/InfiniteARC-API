# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 3c5adc37
Difficulty: insane

=== Tags ===
- Mirror pair coordination
- Periodic run length encoding

=== Description ===
Input grids are large (20×20 or larger) with vertical mirror symmetry across a
central axis. All non-background horizontal runs (background color is fixed at
0) have identical counterparts on the opposite side of the mirror line, with
matching run lengths. Each run of a non-zero color is part of a coordinated
mirror pair. The output grid applies a periodic run length encoding: every
horizontal run of length L is transformed into a repeating sequence of three
distinct foreground colors (e.g., 1→2→3→1→2→3...) for exactly L cells. The
sequence cycles through a fixed triplet (e.g., [1, 2, 3]) regardless of the
original run color. Mirror symmetry is preserved in the output because identical
run lengths on mirrored pairs produce identical encoded sequences. The
transformation requires recognizing run boundaries, applying the cyclic color
pattern consistently, and maintaining vertical symmetry across all runs.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = 21
    height = 20
    input_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        left_half = [0] * ((width - 1) // 2)
        idx = 0
        while idx < len(left_half):
            if random.random() > 0.3:
                color = random.randint(1, 9)
                length = random.randint(1, 3)
                if idx + length > len(left_half):
                    length = len(left_half) - idx
                for i in range(length):
                    left_half[idx + i] = color
                idx += length
                if idx < len(left_half) and random.random() > 0.7:
                    left_half[idx] = 0
                    idx += 1
            else:
                idx += 1
        for c in range(len(left_half)):
            input_grid[r][c] = left_half[c]
            input_grid[r][width - 1 - c] = left_half[c]
    output_grid = [row[:] for row in input_grid]
    triplet = [1, 2, 3]
    for r in range(height):
        c = 0
        while c < width:
            if output_grid[r][c] != 0:
                start = c
                while c < width and output_grid[r][c] != 0:
                    c += 1
                run_len = c - start
                for i in range(run_len):
                    output_grid[r][start + i] = triplet[i % 3]
            else:
                c += 1
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    triplet = [1, 2, 3]
    for r in range(len(grid)):
        c = 0
        while c < len(grid[0]):
            if grid[r][c] != 0:
                start = c
                while c < len(grid[0]) and grid[r][c] != 0:
                    c += 1
                run_len = c - start
                for i in range(run_len):
                    grid[r][start + i] = triplet[i % 3]
            else:
                c += 1
    return grid
