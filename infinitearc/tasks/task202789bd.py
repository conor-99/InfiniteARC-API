# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 202789bd
Difficulty: mediumâ€“hard

=== Tags ===
- Local convolution rule
- Stateful propagation
- Modular sequence
- Recursive agent following
- Mark extrema corners
- Reorder blocks by size

=== Description ===
The input grid contains multiple axis-aligned rectangular blocks, each filled
with a distinct internal pattern (non-uniform colors) and surrounded by
background (value 0). Each block is defined by its bounding box (top-left, top-
right, bottom-left, bottom-right corners), and the task requires marking these
four corner positions with a consistent marker color (e.g., red) in the output.
First, all blocks are reordered by their area (smallest to largest) to form a
sequence. For each block in this sequence, a stateful local convolution is
applied to its internal pattern: the pattern is shifted right by one cell
(wrapping horizontally) for blocks at positions 0, 3, 6, ... (mod 3 = 0),
shifted down by one cell (wrapping vertically) for positions 1, 4, 7, ... (mod 3
= 1), and shifted left by one cell (wrapping horizontally) for positions 2, 5,
8, ... (mod 3 = 2). This modular sequence of shift directions ensures the
transformation cycles through three distinct directional patterns based on the
block's position in the sorted list.  The output grid preserves all background
cells and the original block positions, but modifies the internal pattern of
each block per the convolution rule and marks the four bounding box corners of
every block with the marker color. The transformation is fully deterministic,
relies solely on visual structure (not numerical values), and requires
identifying block boundaries, sorting, and applying a context-dependent
convolution rule.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    # Grid size
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    grid = [[0 for _ in range(width)] for _ in range(height)]

    # Occupancy to ensure blocks have a 1-cell zero border between them
    occ = [[0 for _ in range(width)] for _ in range(height)]

    blocks = []
    target_blocks = random.randint(2, 5)
    attempts = 0
    max_attempts = 1000

    while len(blocks) < target_blocks and attempts < max_attempts:
        attempts += 1
        # block size at least 3x3 to have interior and corners
        h = random.randint(3, min(8, height - 4))
        w = random.randint(3, min(8, width - 4))
        r1 = random.randint(1, height - h - 2)
        c1 = random.randint(1, width - w - 2)
        r2 = r1 + h - 1
        c2 = c1 + w - 1

        # ensure one-cell zero border around the proposed block
        ok = True
        for rr in range(r1 - 1, r2 + 2):
            for cc in range(c1 - 1, c2 + 2):
                if rr < 0 or rr >= height or cc < 0 or cc >= width:
                    continue
                if occ[rr][cc]:
                    ok = False
                    break
            if not ok:
                break
        if not ok:
            continue

        # create a non-uniform internal pattern (colors 1..9)
        pattern = [[random.randint(1, 9) for _ in range(w)] for __ in range(h)]
        flat = [c for row in pattern for c in row]
        if len(set(flat)) == 1:
            # change one cell to ensure non-uniform
            for val in range(1, 10):
                if val != flat[0]:
                    pattern[0][0] = val
                    break

        # write pattern into grid and mark occupancy (but leave one-cell outer border free)
        for i in range(h):
            for j in range(w):
                grid[r1 + i][c1 + j] = pattern[i][j]
                occ[r1 + i][c1 + j] = 1

        blocks.append((r1, c1, r2, c2))

    # If not enough blocks were placed, retry generation (rare)
    if len(blocks) < 2:
        return generate()

    # Input is the unmodified grid
    input_grid = [row[:] for row in grid]

    # Prepare output by applying the modular shift per sorted-area sequence
    output_grid = [row[:] for row in grid]

    # Sort blocks by area (ascending), tie-break by top-left row then col for determinism
    blocks.sort(key=lambda b: ((b[2] - b[0] + 1) * (b[3] - b[1] + 1), b[0], b[1]))

    marker = 2

    for idx, (r1, c1, r2, c2) in enumerate(blocks):
        h = r2 - r1 + 1
        w = c2 - c1 + 1
        # extract internal pattern (deep copy)
        internal = [output_grid[r1 + i][c1:c1 + w] for i in range(h)]

        # apply modular shift: 0 -> right, 1 -> down, 2 -> left
        if idx % 3 == 0:
            # shift each row right by 1 (wrap)
            for i in range(h):
                row = internal[i]
                internal[i] = [row[-1]] + row[:-1]
        elif idx % 3 == 1:
            # shift each column down by 1 (wrap)
            for j in range(w):
                col = [internal[i][j] for i in range(h)]
                col = [col[-1]] + col[:-1]
                for i in range(h):
                    internal[i][j] = col[i]
        else:
            # shift each row left by 1 (wrap)
            for i in range(h):
                row = internal[i]
                internal[i] = row[1:] + [row[0]]

        # write back the transformed internal pattern
        for i in range(h):
            for j in range(w):
                output_grid[r1 + i][c1 + j] = internal[i][j]

        # mark the four bounding box corners with the marker color
        output_grid[r1][c1] = marker
        output_grid[r1][c2] = marker
        output_grid[r2][c1] = marker
        output_grid[r2][c2] = marker

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert immutable input to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    visited = [[False] * width for _ in range(height)]
    blocks = []

    # Find connected non-zero components and their bounding boxes
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and not visited[r][c]:
                # BFS/DFS to collect component
                stack = [(r, c)]
                visited[r][c] = True
                pixels = []
                while stack:
                    rr, cc = stack.pop()
                    pixels.append((rr, cc))
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = rr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] != 0:
                            visited[nr][nc] = True
                            stack.append((nr, nc))

                rs = [p[0] for p in pixels]
                cs = [p[1] for p in pixels]
                r1, r2 = min(rs), max(rs)
                c1, c2 = min(cs), max(cs)

                # Verify component is a filled axis-aligned rectangle
                is_rect = True
                for rr in range(r1, r2 + 1):
                    for cc in range(c1, c2 + 1):
                        if grid[rr][cc] == 0:
                            is_rect = False
                            break
                    if not is_rect:
                        break

                # If it's a filled rectangle (as generator guarantees), record it
                if is_rect:
                    blocks.append((r1, c1, r2, c2))
                else:
                    # As a fallback, treat each pixel as a 1x1 block (shouldn't happen with the generator)
                    for (rr, cc) in pixels:
                        blocks.append((rr, cc, rr, cc))

    # Sort blocks by area then by top-left coordinates (must match generator)
    blocks.sort(key=lambda b: ((b[2] - b[0] + 1) * (b[3] - b[1] + 1), b[0], b[1]))

    out = [row[:] for row in grid]
    marker = 2

    # Apply the same modular shift sequence to each block and mark corners
    for idx, (r1, c1, r2, c2) in enumerate(blocks):
        h = r2 - r1 + 1
        w = c2 - c1 + 1
        internal = [out[r1 + i][c1:c1 + w] for i in range(h)]

        if idx % 3 == 0:
            for i in range(h):
                row = internal[i]
                internal[i] = [row[-1]] + row[:-1]
        elif idx % 3 == 1:
            for j in range(w):
                col = [internal[i][j] for i in range(h)]
                col = [col[-1]] + col[:-1]
                for i in range(h):
                    internal[i][j] = col[i]
        else:
            for i in range(h):
                row = internal[i]
                internal[i] = row[1:] + [row[0]]

        for i in range(h):
            for j in range(w):
                out[r1 + i][c1 + j] = internal[i][j]

        out[r1][c1] = marker
        out[r1][c2] = marker
        out[r2][c1] = marker
        out[r2][c2] = marker

    return out

