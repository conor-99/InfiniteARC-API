# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: ab98d842
Difficulty: medium–hard

=== Tags ===
- Shape attribute projection

=== Description ===
Input grids feature a background color (0) with multiple distinct, solid shapes
(each shape is a contiguous region of a single non-background color 1–9,
connected via 4-directional adjacency). Each shape has a bounding box where the
width (horizontal span) is strictly greater than the height (vertical span) for
horizontal shapes, or the height is strictly greater than the width for vertical
shapes. Shapes are separated by background cells and do not touch or overlap.
The output grid transforms the input by projecting each shape's color along its
dominant orientation. For horizontal shapes (width > height), the shape's color
is drawn to the right for up to 3 cells through background areas (cells with
value 0), stopping at the grid boundary or a non-background cell. For vertical
shapes (height > width), the shape's color is drawn downward for up to 3 cells
through background areas, stopping at the grid boundary or a non-background
cell. The original shapes and background remain unchanged; only background cells
are modified to include the projected lines. Projections do not overwrite
existing shapes or other projections, and the grid dimensions remain identical
between input and output. No loops or recursive behavior occurs in the
projection rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    """Generate a random ARC-style input/output pair for the projection task.

    The generator creates a grid with several non-touching solid rectangular shapes
    (each a contiguous block of a single non-background color). Each shape's
    bounding box is strictly wider than tall (horizontal) or strictly taller
    than wide (vertical). For each shape we then project its color along its
    dominant orientation (rightwards for horizontal, downwards for vertical)
    up to 3 cells, stopping at the grid boundary or any non-background cell.

    Returns:
        dict with keys 'input' and 'output', each a list of lists of ints.
    """
    # Keep trying until we produce a pair where at least one projection occurs
    # and all shapes were placed successfully.
    while True:
        # Choose a reasonably sized grid to allow multiple shapes and projections
        width = random.randint(6, 20)
        height = random.randint(6, 20)
        grid = [[0] * width for _ in range(height)]

        num_shapes = random.randint(2, 5)
        colors = random.sample(list(range(1, 10)), num_shapes)

        success = True
        # Place solid rectangular shapes that do not touch (keep a 1-cell padding)
        for color in colors:
            placed = False
            # Try a number of random placements/sizes before giving up and restarting
            for _attempt in range(300):
                # Randomly choose orientation: 0 = horizontal (width > height), 1 = vertical (height > width)
                orient = random.choice([0, 1])

                if orient == 0:  # horizontal shape: width strictly greater than height
                    max_h = min(4, height)
                    if max_h < 1:
                        continue
                    h_shape = random.randint(1, max_h)
                    min_w = h_shape + 1
                    max_w = min(8, width)
                    if min_w > max_w:
                        continue
                    w_shape = random.randint(min_w, max_w)
                    max_r = height - h_shape
                    max_c = width - w_shape
                    if max_r < 0 or max_c < 0:
                        continue
                    r = random.randint(0, max_r)
                    c = random.randint(0, max_c)
                else:  # vertical shape: height strictly greater than width
                    max_w = min(4, width)
                    if max_w < 1:
                        continue
                    w_shape = random.randint(1, max_w)
                    min_h = w_shape + 1
                    max_h = min(8, height)
                    if min_h > max_h:
                        continue
                    h_shape = random.randint(min_h, max_h)
                    max_r = height - h_shape
                    max_c = width - w_shape
                    if max_r < 0 or max_c < 0:
                        continue
                    r = random.randint(0, max_r)
                    c = random.randint(0, max_c)

                # Ensure the chosen rectangle and its 1-cell border (if within grid)
                # are free of other shapes to guarantee separation.
                ok = True
                for dr in range(-1, h_shape + 1):
                    for dc in range(-1, w_shape + 1):
                        rr = r + dr
                        cc = c + dc
                        if 0 <= rr < height and 0 <= cc < width:
                            if grid[rr][cc] != 0:
                                ok = False
                                break
                    if not ok:
                        break
                if not ok:
                    continue

                # Place the solid rectangle
                for dr in range(h_shape):
                    for dc in range(w_shape):
                        grid[r + dr][c + dc] = color
                placed = True
                break

            if not placed:
                success = False
                break

        if not success:
            # Failed to place all shapes without touching — try a new grid
            continue

        # Build the output by projecting each shape's color along its dominant axis
        input_grid = grid
        output_grid = [row[:] for row in input_grid]
        rows = height
        cols = width

        visited = [[False] * cols for _ in range(rows)]
        for r in range(rows):
            for c in range(cols):
                if not visited[r][c] and input_grid[r][c] != 0:
                    color = input_grid[r][c]
                    # BFS to collect the connected component
                    comp = []
                    queue = [(r, c)]
                    visited[r][c] = True
                    while queue:
                        cr, cc = queue.pop(0)
                        comp.append((cr, cc))
                        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                            nr, nc = cr + dr, cc + dc
                            if (
                                0 <= nr < rows
                                and 0 <= nc < cols
                                and not visited[nr][nc]
                                and input_grid[nr][nc] == color
                            ):
                                visited[nr][nc] = True
                                queue.append((nr, nc))

                    min_r = min(p[0] for p in comp)
                    max_r = max(p[0] for p in comp)
                    min_c = min(p[1] for p in comp)
                    max_c = max(p[1] for p in comp)
                    bwidth = max_c - min_c + 1
                    bheight = max_r - min_r + 1

                    if bwidth > bheight:  # horizontal: project to the right up to 3 cells
                        for cr in range(min_r, max_r + 1):
                            for step in range(1, 4):
                                cc = max_c + step
                                if cc >= cols:
                                    break
                                # stop if we'd hit any non-background cell (shape or prior projection)
                                if output_grid[cr][cc] != 0:
                                    break
                                output_grid[cr][cc] = color
                    else:  # vertical: project downward up to 3 cells
                        for cc in range(min_c, max_c + 1):
                            for step in range(1, 4):
                                cr = max_r + step
                                if cr >= rows:
                                    break
                                if output_grid[cr][cc] != 0:
                                    break
                                output_grid[cr][cc] = color

        # Ensure at least one projection changed the grid; otherwise regenerate
        if input_grid == output_grid:
            continue

        return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    """Project each solid shape's color along its dominant orientation.

    Input: tuple-of-tuples or list-of-lists; shapes are solid connected regions
    of non-zero color. For horizontal shapes (bounding box width > height),
    draw the shape's color to the right up to 3 cells through background (0),
    stopping at the grid edge or any non-background cell. For vertical shapes
    (height > width), draw the color downward similarly. Projections do not
    overwrite shapes or prior projections. The original shapes remain.

    Returns a list-of-lists representing the output grid.
    """
    grid = [list(row) for row in input_grid]
    rows = len(grid)
    cols = len(grid[0]) if rows > 0 else 0
    if rows == 0 or cols == 0:
        return grid

    # We'll write projections into this working output so we can avoid
    # overwriting shapes or earlier projections.
    output_grid = [row[:] for row in grid]

    visited = [[False] * cols for _ in range(rows)]
    for r in range(rows):
        for c in range(cols):
            if not visited[r][c] and grid[r][c] != 0:
                color = grid[r][c]
                comp = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    comp.append((cr, cc))
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = cr + dr, cc + dc
                        if (
                            0 <= nr < rows
                            and 0 <= nc < cols
                            and not visited[nr][nc]
                            and grid[nr][nc] == color
                        ):
                            visited[nr][nc] = True
                            queue.append((nr, nc))

                min_r = min(p[0] for p in comp)
                max_r = max(p[0] for p in comp)
                min_c = min(p[1] for p in comp)
                max_c = max(p[1] for p in comp)
                bwidth = max_c - min_c + 1
                bheight = max_r - min_r + 1

                if bwidth > bheight:  # horizontal: project right
                    for cr in range(min_r, max_r + 1):
                        for step in range(1, 4):
                            cc = max_c + step
                            if cc >= cols:
                                break
                            if output_grid[cr][cc] != 0:
                                break
                            output_grid[cr][cc] = color
                else:  # vertical: project downward
                    for cc in range(min_c, max_c + 1):
                        for step in range(1, 4):
                            cr = max_r + step
                            if cr >= rows:
                                break
                            if output_grid[cr][cc] != 0:
                                break
                            output_grid[cr][cc] = color

    return output_grid

