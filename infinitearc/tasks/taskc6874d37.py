# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: c6874d37
Difficulty: very hard

=== Tags ===
- Dynamic channel painting
- Pattern imitation
- Recoloring

=== Description ===
**Dynamic Channel Recoloration**  Input grids depict a complex network of
interconnected channels, each represented by a contiguous region of identical
non-zero color. Channels are organized into distinct flow zones based on their
vertical position within the grid: channels in the top half (rows 0 to
floor((height-1)/2)) flow downward, while channels in the bottom half (rows
ceil((height-1)/2) to height-1) flow upward. Each channel segment shifts by one
cell in its designated flow direction during the transformation. If a channel
segment moves into a background cell (value 0), it occupies that cell, leaving
the original cell as background. If it moves into a cell occupied by another
channel, the segments merge, adopting the color of the channel they merge into.
After this dynamic shift, the output grid must imitate a specific secondary
pattern present in the input grid. This pattern is a compact arrangement of non-
background colors located in the top-right quadrant (rows 0 to floor(height/4),
columns width - floor(width/4) to width-1). The channel segments in the output
grid are recolored to exactly match the color sequence of this secondary
pattern, preserving the structure of the channel network but replacing all
colors with those from the pattern. The recoloring is applied in row-major
order: the topmost channel segment in the output is assigned the color of the
top-left cell in the secondary pattern, the next segment (moving right, then
down) takes the next color in the pattern, and so on. The transformation ensures
all channel segments are preserved without overlap, and colors strictly follow
the pattern's sequence.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random


def generate():
    # Choose grid size ensuring the pattern quadrant is non-empty
    width = random.randint(6, 20)
    height = random.randint(6, 20)
    input_grid = [[0 for _ in range(width)] for _ in range(height)]

    mid = (height + 1) // 2  # top half rows: 0..mid-1

    # Pattern (top-right quadrant) dimensions
    top_rows = max(1, height // 4)
    right_cols = max(1, width // 4)
    pattern_area = top_rows * right_cols

    # Candidate positions inside the pattern quadrant (row-major)
    start_col = width - right_cols
    pattern_positions = [(r, c) for r in range(top_rows) for c in range(start_col, width)]

    # Choose pattern candidate subset with even-even parity to avoid adjacency (keeps singletons isolated)
    parity_candidates = [(r, c) for (r, c) in pattern_positions if (r % 2 == 0 and c % 2 == 0)]
    if not parity_candidates:
        parity_candidates = pattern_positions[:]

    # Available columns for placing channels: avoid pattern columns so pattern pixels remain distinct
    available_cols = list(range(0, start_col))
    if not available_cols:
        available_cols = [0]

    # Limit number of channels to what's feasible (must fit into available columns and candidate slots)
    maxK = min(len(available_cols), len(parity_candidates), pattern_area)
    K = random.randint(1, max(1, maxK))

    # Choose K distinct columns for channels
    cols = random.sample(available_cols, K)

    # Create K vertical contiguous channels (each with length >= 2 to distinguish from pattern singletons)
    channel_colors = []
    for col in cols:
        half = random.choice(['top', 'bottom'])
        if half == 'top':
            r_low, r_high = 0, mid - 1
        else:
            r_low, r_high = mid, height - 1
        # Ensure we can create a run of at least length 2
        if r_high - r_low + 1 < 2:
            # fallback: place a single cell (should be rare given chosen sizes)
            r1 = r_low
            r2 = r_low
        else:
            r1 = random.randint(r_low, r_high - 1)
            r2 = random.randint(r1 + 1, r_high)
        color = random.randint(1, 9)
        channel_colors.append(color)
        for r in range(r1, r2 + 1):
            input_grid[r][col] = color

    # Choose K pattern positions among parity_candidates (sorted in row-major for deterministic order)
    parity_candidates_sorted = sorted(parity_candidates, key=lambda p: (p[0], p[1]))
    if len(parity_candidates_sorted) < K:
        # this shouldn't happen because of the maxK calculation, but be defensive
        chosen_pattern_positions = parity_candidates_sorted[:K] + pattern_positions[:max(0, K - len(parity_candidates_sorted))]
    else:
        chosen_pattern_positions = random.sample(parity_candidates_sorted, K)
        chosen_pattern_positions = sorted(chosen_pattern_positions, key=lambda p: (p[0], p[1]))

    # Choose pattern colors that do not collide with channel colors to keep identification simple
    all_colors = list(range(1, 10))
    avoid = set(channel_colors)
    pattern_palette = [c for c in all_colors if c not in avoid]
    if not pattern_palette:
        pattern_palette = all_colors[:]
    # If not enough unique colors, allow repeats but prefer unique
    pattern_colors = [random.choice(pattern_palette) for _ in range(K)]

    # Place pattern colors into the input grid (top-right quadrant)
    # Ensure other pattern cells (unused positions) are background 0
    # We'll first zero out whole pattern area then place the chosen ones
    for (pr, pc) in pattern_positions:
        input_grid[pr][pc] = 0

    for i, (pr, pc) in enumerate(chosen_pattern_positions):
        input_grid[pr][pc] = pattern_colors[i]

    # Helper: find connected components in a grid of identical colors (4-neighbor)
    def components_of(grid):
        h = len(grid)
        w = len(grid[0])
        vis = [[False] * w for _ in range(h)]
        comps = []
        for rr in range(h):
            for cc in range(w):
                if grid[rr][cc] == 0 or vis[rr][cc]:
                    continue
                col = grid[rr][cc]
                stack = [(rr, cc)]
                vis[rr][cc] = True
                comp = []
                while stack:
                    r0, c0 = stack.pop()
                    comp.append((r0, c0))
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = r0 + dr, c0 + dc
                        if 0 <= nr < h and 0 <= nc < w and not vis[nr][nc] and grid[nr][nc] == col:
                            vis[nr][nc] = True
                            stack.append((nr, nc))
                comps.append(comp)
        return comps

    # Identify original components and channel components (size >= 2)
    orig_comps = components_of(input_grid)
    channel_orig_comps = [comp for comp in orig_comps if len(comp) >= 2]

    # Compute the synchronous shift using the complete input grid (channels + pattern)
    orig = [row[:] for row in input_grid]
    shifted = [[0 for _ in range(width)] for _ in range(height)]
    origin_to_target = {}  # map original non-zero cell -> its target coordinate
    for r in range(height):
        for c in range(width):
            v = orig[r][c]
            if v == 0:
                continue
            if r < mid:
                nr = r + 1
            else:
                nr = r - 1
            if 0 <= nr < height:
                # record mapping
                origin_to_target[(r, c)] = (nr, c)
                if orig[nr][c] != 0:
                    shifted[nr][c] = orig[nr][c]
                else:
                    shifted[nr][c] = v

    # Build a reverse mapping target -> set(origins)
    target_to_origins = {}
    for orig_cell, targ in origin_to_target.items():
        target_to_origins.setdefault(targ, set()).add(orig_cell)

    # Compute components in the shifted grid
    shifted_comps = components_of(shifted)
    coord_to_shift_comp = {}
    for idx, comp in enumerate(shifted_comps):
        for (r, c) in comp:
            coord_to_shift_comp[(r, c)] = idx

    # Determine which shifted components correspond to original channel components.
    # A shifted component corresponds to a channel if any of its cells was produced by an origin cell
    # that belonged to a channel component.
    channel_shift_comp_indices = []
    # Build a set of origin coordinates that are part of channel original components
    channel_origin_cells = set()
    for comp in channel_orig_comps:
        for cell in comp:
            channel_origin_cells.add(cell)

    # For each target coordinate, if any origin that maps to it is in channel_origin_cells,
    # then the shifted component containing that target is a channel component.
    for targ, origins in target_to_origins.items():
        if any(o in channel_origin_cells for o in origins):
            if targ in coord_to_shift_comp:
                idx = coord_to_shift_comp[targ]
                if idx not in channel_shift_comp_indices:
                    channel_shift_comp_indices.append(idx)

    # Build list of shifted components that represent channels
    channel_shift_comps = [shifted_comps[i] for i in channel_shift_comp_indices]

    # Sort the channel components by their topmost then leftmost cell (row-major of components)
    channel_shift_comps_sorted = sorted(channel_shift_comps, key=lambda comp: (min(p[0] for p in comp), min(p[1] for p in comp)))

    # Now recolor these channel components according to the pattern colors (pattern colors were placed
    # into the input grid in row-major order of chosen_pattern_positions)
    output_grid = [[0 for _ in range(width)] for _ in range(height)]
    # Extract the pattern colors from the input grid in row-major order of the pattern quadrant
    extracted_pattern_colors = []
    for (pr, pc) in pattern_positions:
        v = input_grid[pr][pc]
        if v != 0:
            extracted_pattern_colors.append(v)

    # There should be exactly K pattern colors and exactly K channel components; be defensive
    # but assume generator construction guarantees equality
    if len(extracted_pattern_colors) < len(channel_shift_comps_sorted):
        # pad with a safe color (shouldn't be necessary)
        filler = extracted_pattern_colors[-1] if extracted_pattern_colors else 1
        extracted_pattern_colors += [filler] * (len(channel_shift_comps_sorted) - len(extracted_pattern_colors))

    for idx, comp in enumerate(channel_shift_comps_sorted):
        col = extracted_pattern_colors[idx]
        for (r, c) in comp:
            output_grid[r][c] = col

    # Safety: ensure input != output (if equal, tweak a pattern cell)
    if input_grid == output_grid:
        if pattern_positions:
            pr, pc = pattern_positions[0]
            old = input_grid[pr][pc]
            newc = old
            for _ in range(10):
                newc = random.randint(1, 9)
                if newc != old:
                    break
            input_grid[pr][pc] = newc
            # recompute straightforwardly: recolor first channel component
            if channel_shift_comps_sorted:
                for (r, c) in channel_shift_comps_sorted[0]:
                    output_grid[r][c] = newc

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    mid = (height + 1) // 2
    top_rows = max(1, height // 4)
    right_cols = max(1, width // 4)
    start_col = width - right_cols

    # Helper: components of identical colors (4-neighbor)
    def components_of(g):
        h = len(g)
        w = len(g[0])
        vis = [[False] * w for _ in range(h)]
        comps = []
        for rr in range(h):
            for cc in range(w):
                if g[rr][cc] == 0 or vis[rr][cc]:
                    continue
                col = g[rr][cc]
                stack = [(rr, cc)]
                vis[rr][cc] = True
                comp = []
                while stack:
                    r0, c0 = stack.pop()
                    comp.append((r0, c0))
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = r0 + dr, c0 + dc
                        if 0 <= nr < h and 0 <= nc < w and not vis[nr][nc] and g[nr][nc] == col:
                            vis[nr][nc] = True
                            stack.append((nr, nc))
                comps.append(comp)
        return comps

    # Identify original components and channel components (size >= 2)
    orig_comps = components_of(grid)
    channel_orig_comps = [comp for comp in orig_comps if len(comp) >= 2]

    # Compute synchronous shift using the input grid
    orig = [row[:] for row in grid]
    shifted = [[0 for _ in range(width)] for _ in range(height)]
    origin_to_target = {}
    for r in range(height):
        for c in range(width):
            v = orig[r][c]
            if v == 0:
                continue
            if r < mid:
                nr = r + 1
            else:
                nr = r - 1
            if 0 <= nr < height:
                origin_to_target[(r, c)] = (nr, c)
                if orig[nr][c] != 0:
                    shifted[nr][c] = orig[nr][c]
                else:
                    shifted[nr][c] = v

    # Build reverse mapping target -> origins
    target_to_origins = {}
    for o, t in origin_to_target.items():
        target_to_origins.setdefault(t, set()).add(o)

    # Components in shifted grid
    shifted_comps = components_of(shifted)
    coord_to_shift_comp = {}
    for idx, comp in enumerate(shifted_comps):
        for (r, c) in comp:
            coord_to_shift_comp[(r, c)] = idx

    # Build set of origin coordinates that belonged to channel components
    channel_origin_cells = set()
    for comp in channel_orig_comps:
        for cell in comp:
            channel_origin_cells.add(cell)

    # Identify shifted components that correspond to channels (if any of their target origins are channel-origin)
    channel_shift_comp_indices = []
    for targ, origins in target_to_origins.items():
        if any(o in channel_origin_cells for o in origins):
            if targ in coord_to_shift_comp:
                idx = coord_to_shift_comp[targ]
                if idx not in channel_shift_comp_indices:
                    channel_shift_comp_indices.append(idx)

    channel_shift_comps = [shifted_comps[i] for i in channel_shift_comp_indices]

    # Sort channel components by their topmost then leftmost cell
    channel_shift_comps_sorted = sorted(channel_shift_comps, key=lambda comp: (min(p[0] for p in comp), min(p[1] for p in comp)))

    # Extract pattern colors from the top-right quadrant in row-major order
    pattern_positions = [(r, c) for r in range(top_rows) for c in range(start_col, width)]
    extracted_pattern_colors = []
    for (pr, pc) in pattern_positions:
        v = grid[pr][pc]
        if v != 0:
            extracted_pattern_colors.append(v)

    # Ensure enough pattern colors (generator guarantees this), be defensive
    if len(extracted_pattern_colors) < len(channel_shift_comps_sorted):
        filler = extracted_pattern_colors[-1] if extracted_pattern_colors else 1
        extracted_pattern_colors += [filler] * (len(channel_shift_comps_sorted) - len(extracted_pattern_colors))

    # Recolor the sorted channel components using the pattern colors
    output = [[0 for _ in range(width)] for _ in range(height)]
    for idx, comp in enumerate(channel_shift_comps_sorted):
        color = extracted_pattern_colors[idx]
        for (r, c) in comp:
            output[r][c] = color

    return tuple(tuple(row) for row in output)

