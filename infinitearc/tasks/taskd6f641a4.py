# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: d6f641a4
Difficulty: insane

=== Tags ===
- Alternating direction
- Path instruction following
- Path merging
- Multi source interaction
- Recoloring

=== Description ===
# Path Convergence Sequence  Input grids feature a uniform background color (0)
with multiple distinct colored source cells (1-9) positioned along the grid
edges. Each source is paired with a unique path sequence defined by a cyclic
color pattern (e.g., source color 1 follows [1,2,3,1,2,3...], source color 2
follows [2,3,4,2,3,4...]). The grid contains no obstacles, allowing paths to
traverse freely through background cells.   Path movement begins immediately
from each source cell in the direction dictated by the source's edge placement
(left-edge sources move right, bottom-edge sources move up, etc.). Each step
alternates direction between horizontal and vertical movement (e.g., right → up
→ left → down → right...), continuing until paths collide or reach grid
boundaries. When two paths occupy the same cell simultaneously, they merge into
a single path that continues the alternating direction sequence from the last
direction before collision. The merged path adopts the color sequence of the
first path to arrive at the collision point.  Recoloring occurs at each step:
the path cell takes the next color in its source-defined cyclic sequence. Merged
paths continue using the adopted sequence without restarting. Paths continue
moving until they exit the grid through any edge, with all intermediate cells
retaining their step-specific colors. No two paths may occupy the same cell at
the same time before merging, and all color transitions must strictly follow the
cyclic sequences. The output grid displays all merged paths with their
continuous color sequences, showing how multiple sources interact through path
merging while maintaining strict alternating direction movement.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = grid(width, height, 0)
    output_grid = grid(width, height, 0)
    
    # Place sources only on left/right edges
    left_edges = [(r, 0) for r in range(1, height-1)]
    right_edges = [(r, width-1) for r in range(1, height-1)]
    sources = []
    
    num_sources = random.randint(2, 4)
    for _ in range(num_sources):
        if left_edges and right_edges:
            if random.choice([True, False]):
                pos = random.choice(left_edges)
                left_edges.remove(pos)
            else:
                pos = random.choice(right_edges)
                right_edges.remove(pos)
        elif left_edges:
            pos = random.choice(left_edges)
            left_edges.remove(pos)
        else:
            pos = random.choice(right_edges)
            right_edges.remove(pos)
        r, c = pos
        color = random.randint(1, 9)
        input_grid[r][c] = color
        output_grid[r][c] = color
        sources.append((r, c, color))
    
    # Simulate paths
    paths = []
    for (r, c, color) in sources:
        edge = 'left' if c == 0 else 'right'
        paths.append({'r': r, 'c': c, 'color': color, 'edge': edge, 'step': 1})

    for step in range(1, 100):
        next_positions = []
        for path in paths:
            r, c = path['r'], path['c']
            edge = path['edge']
            if step % 2 == 1:
                dr, dc = (0, 1) if edge == 'left' else (0, -1)
            else:
                dr, dc = (-1, 0) if (step // 2) % 2 == 1 else (1, 0)
            nr, nc = r + dr, c + dc
            next_positions.append((nr, nc, path))

        cell_to_paths = {}
        for (nr, nc, path) in next_positions:
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                continue
            if (nr, nc) not in cell_to_paths:
                cell_to_paths[(nr, nc)] = []
            cell_to_paths[(nr, nc)].append(path)

        for (r, c), paths_at_cell in cell_to_paths.items():
            if len(paths_at_cell) > 1:
                paths_at_cell.sort(key=lambda p: p['color'])
                merged_path = paths_at_cell[0]
                paths = [p for p in paths if p not in paths_at_cell[1:]]
                color_val = (merged_path['color'] + step) % 9
                color_val = 9 if color_val == 0 else color_val
                output_grid[r][c] = color_val
            else:
                path = paths_at_cell[0]
                color_val = (path['color'] + step) % 9
                color_val = 9 if color_val == 0 else color_val
                output_grid[r][c] = color_val

        # Update paths
        new_paths = []
        for path in paths:
            r, c = path['r'], path['c']
            edge = path['edge']
            if step % 2 == 1:
                dr, dc = (0, 1) if edge == 'left' else (0, -1)
            else:
                dr, dc = (-1, 0) if (step // 2) % 2 == 1 else (1, 0)
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width:
                path['r'], path['c'] = nr, nc
                new_paths.append(path)
        paths = new_paths
        if not paths:
            break

    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = [list(row) for row in input_grid]
    
    # Identify sources on left/right edges
    sources = []
    for r in range(1, height-1):
        if input_grid[r][0] != 0:
            sources.append((r, 0, input_grid[r][0]))
        if input_grid[r][width-1] != 0:
            sources.append((r, width-1, input_grid[r][width-1]))

    paths = []
    for (r, c, color) in sources:
        edge = 'left' if c == 0 else 'right'
        paths.append({'r': r, 'c': c, 'color': color, 'edge': edge, 'step': 1})

    for step in range(1, 100):
        next_positions = []
        for path in paths:
            r, c = path['r'], path['c']
            edge = path['edge']
            if step % 2 == 1:
                dr, dc = (0, 1) if edge == 'left' else (0, -1)
            else:
                dr, dc = (-1, 0) if (step // 2) % 2 == 1 else (1, 0)
            nr, nc = r + dr, c + dc
            next_positions.append((nr, nc, path))

        cell_to_paths = {}
        for (nr, nc, path) in next_positions:
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                continue
            if (nr, nc) not in cell_to_paths:
                cell_to_paths[(nr, nc)] = []
            cell_to_paths[(nr, nc)].append(path)

        for (r, c), paths_at_cell in cell_to_paths.items():
            if len(paths_at_cell) > 1:
                paths_at_cell.sort(key=lambda p: p['color'])
                merged_path = paths_at_cell[0]
                paths = [p for p in paths if p not in paths_at_cell[1:]]
                color_val = (merged_path['color'] + step) % 9
                color_val = 9 if color_val == 0 else color_val
                output_grid[r][c] = color_val
            else:
                path = paths_at_cell[0]
                color_val = (path['color'] + step) % 9
                color_val = 9 if color_val == 0 else color_val
                output_grid[r][c] = color_val

        # Update paths
        new_paths = []
        for path in paths:
            r, c = path['r'], path['c']
            edge = path['edge']
            if step % 2 == 1:
                dr, dc = (0, 1) if edge == 'left' else (0, -1)
            else:
                dr, dc = (-1, 0) if (step // 2) % 2 == 1 else (1, 0)
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width:
                path['r'], path['c'] = nr, nc
                new_paths.append(path)
        paths = new_paths
        if not paths:
            break
    
    return output_grid
