# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: ce8c8890
Difficulty: hard

=== Tags ===
- Count hor lines
- Color palette

=== Description ===
In this task, the input grid contains colors represented by integers from 0 to
9. For each non-zero color present in the input, count the total number of
horizontal line segments (maximal contiguous sequences of the same color within
a single row) across the entire grid. The output grid is generated by replacing
each non-zero cell with the count corresponding to its original color, while
retaining 0 values as 0. The transformation is deterministic and ensures that
all output values remain within the 0â€“9 range. The task requires identifying
horizontal runs, aggregating counts per color, and applying the mapping to each
cell.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    color_runs = {}
    color_rows = []
    colors_used = []
    remaining = height
    while remaining > 0:
        possible_colors = [c for c in range(1, 10) if color_runs.get(c, 0) < 9]
        if not possible_colors:
            break
        color = random.choice(possible_colors)
        max_count = 9 - color_runs.get(color, 0)
        count = random.randint(1, min(max_count, remaining))
        color_runs[color] = color_runs.get(color, 0) + count
        color_rows.append(count)
        colors_used.append(color)
        remaining -= count
    if remaining > 0:
        color_rows.append(remaining)
        colors_used.append(0)
    input_grid = []
    current_row = 0
    for i in range(len(color_rows)):
        rows = color_rows[i]
        color = colors_used[i]
        for _ in range(rows):
            input_grid.append([color] * width)
            current_row += 1
            if current_row >= height:
                break
        if current_row >= height:
            break
    while len(input_grid) < height:
        input_grid.append([0] * width)
    output_grid = []
    for row in input_grid:
        output_row = []
        for cell in row:
            if cell == 0:
                output_row.append(0)
            else:
                output_row.append(color_runs[cell])
        output_grid.append(output_row)
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid or not input_grid[0]:
        return input_grid
    height = len(input_grid)
    width = len(input_grid[0])
    color_runs = {c: 0 for c in range(1, 10)}
    for r in range(height):
        c = 0
        while c < width:
            if input_grid[r][c] == 0:
                c += 1
                continue
            color = input_grid[r][c]
            while c < width and input_grid[r][c] == color:
                c += 1
            color_runs[color] += 1
    output_grid = []
    for r in range(height):
        output_row = []
        for c in range(width):
            cell = input_grid[r][c]
            if cell == 0:
                output_row.append(0)
            else:
                output_row.append(color_runs[cell])
        output_grid.append(output_row)
    return output_grid
