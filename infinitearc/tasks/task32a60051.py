# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 32a60051
Difficulty: insane

=== Tags ===
- Summarize
- Meta rewriting system
- Transformational equivalence

=== Description ===
The input grid is a 2D array of integers between 0 and 9, where non-zero values
represent distinct "objects" or "colors." The transformation requires
identifying the most frequent non-zero color (key color) in the input grid. The
grid is then divided into 2x2 blocks, with padding applied using the key color
for any incomplete blocks at the grid's edges. Each cell in the output grid
corresponds to one 2x2 block, containing the count of key color cells within
that block. This process demonstrates "summarize" by condensing spatial patterns
into numerical counts, "meta rewriting system" through the key color
determination derived from the input itself, and "transformational equivalence"
as grids with identical key colors and structural block patterns will produce
identical outputs regardless of other color distributions. The challenge lies in
correctly inferring the dynamic key color rule and applying block-based
summarization without prior knowledge of the color hierarchy.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    key_color = random.randint(1, 9)
    grid = [[0] * width for _ in range(height)]
    total_cells = width * height
    key_count = int(total_cells * 0.7)
    
    for _ in range(key_count):
        r = random.randint(0, height - 1)
        c = random.randint(0, width - 1)
        grid[r][c] = key_color
    
    other_colors = [c for c in range(1, 10) if c != key_color]
    remaining = total_cells - key_count
    for _ in range(remaining):
        r = random.randint(0, height - 1)
        c = random.randint(0, width - 1)
        if grid[r][c] == 0:
            grid[r][c] = random.choice(other_colors)
    
    output = []
    for i in range((height + 1) // 2):
        row = []
        for j in range((width + 1) // 2):
            count = 0
            for dr in [0, 1]:
                for dc in [0, 1]:
                    r_idx = 2 * i + dr
                    c_idx = 2 * j + dc
                    if r_idx < height and c_idx < width:
                        if grid[r_idx][c_idx] == key_color:
                            count += 1
                    else:
                        count += 1
            row.append(count)
        output.append(row)
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0]) if height > 0 else 0
    
    non_zero_colors = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                non_zero_colors.append(input_grid[r][c])
    
    if not non_zero_colors:
        key_color = 1
    else:
        color_count = {}
        for color in non_zero_colors:
            color_count[color] = color_count.get(color, 0) + 1
        key_color = max(color_count, key=color_count.get)
    
    output = []
    for i in range((height + 1) // 2):
        row = []
        for j in range((width + 1) // 2):
            count = 0
            for dr in [0, 1]:
                for dc in [0, 1]:
                    r_idx = 2 * i + dr
                    c_idx = 2 * j + dc
                    if r_idx < height and c_idx < width:
                        if input_grid[r_idx][c_idx] == key_color:
                            count += 1
                    else:
                        count += 1
            row.append(count)
        output.append(row)
    return output
