# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 88fe20b9
Difficulty: easy

=== Tags ===
- One yes one no
- Find and double the smallest object
- Count tiles
- Enlarge image

=== Description ===
The input grid features a black background (0) with multiple distinct colored
objects, each formed by connected cells of the same non-zero color. The smallest
object, identified by having the fewest cells (typically a single isolated
cell), is located such that its expansion into a 2x2 block will not overlap with
other objects. The output grid transforms this smallest object by replacing its
single cell with a contiguous 2x2 block of the same color, while all other
objects and background cells remain unchanged. This operation effectively
doubles the object's size in both dimensions without altering the grid's overall
dimensions, as the isolated placement ensures the 2x2 block fits within the
existing grid boundaries. The task requires recognizing the smallest object
through counting cells and applying a straightforward spatial scaling rule.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    from common import continuous_creature, grid
    width = random.randint(3, 10)
    height = random.randint(3, 10)
    grid_input = [[0] * width for _ in range(height)]
    color_smallest = random.randint(1, 9)
    r = random.randint(1, height - 2)
    c = random.randint(1, width - 2)
    grid_input[r][c] = color_smallest
    other_colors = [c for c in range(1, 10) if c != color_smallest]
    random.shuffle(other_colors)
    for color in other_colors:
        pixels = continuous_creature(2, width, height)
        for (row, col) in pixels:
            if row == r and col == c:
                continue
            grid_input[row][col] = color
        if len(other_colors) > 2:
            break
    grid_output = [row[:] for row in grid_input]
    for dr in [0, 1]:
        for dc in [0, 1]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width:
                grid_output[nr][nc] = color_smallest
    return {"input": grid_input, "output": grid_output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    visited = [[False] * width for _ in range(height)]
    components = []
    def bfs(r, c, color):
        queue = [(r, c)]
        visited[r][c] = True
        comp = []
        while queue:
            r1, c1 = queue.pop(0)
            comp.append((r1, c1))
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r1 + dr, c1 + dc
                if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                    visited[nr][nc] = True
                    queue.append((nr, nc))
        return comp
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and input_grid[r][c] != 0:
                color = input_grid[r][c]
                comp = bfs(r, c, color)
                components.append((color, comp))
    min_size = float('inf')
    smallest_color = None
    smallest_pos = None
    for color, comp in components:
        size = len(comp)
        if size < min_size:
            min_size = size
            smallest_color = color
            smallest_pos = comp[0]
    if min_size == 1:
        r, c = smallest_pos
        output = [list(row) for row in input_grid]
        for dr in [0, 1]:
            for dc in [0, 1]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    output[nr][nc] = smallest_color
        return output
    return input_grid
