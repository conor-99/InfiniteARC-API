# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 67bb32ae
Difficulty: hard

=== Tags ===
- Portal momentum pathing
- Gravity with barriers
- Momentum conservation path
- Maze
- Color palette

=== Description ===
**Portal Momentum Maze**    Input grids depict a complex maze environment with
walls, multiple portal pairs, and a token. Walls are represented by a single
color (e.g., color 1), portals are pairs of matching colors (e.g., color 2 for a
portal pair, color 3 for another), and the token is a distinct color (e.g.,
color 4) positioned at the top edge of the grid. Gravity dictates the token's
initial downward movement direction.    The token moves one cell at a time in
its current direction. Upon encountering a wall (color 1), it reflects off the
wall, reversing its horizontal or vertical direction (e.g., moving down hits a
wall → moves up; moving right hits a wall → moves left). Upon entering a portal
(color 2), the token instantly teleports to the paired portal of the same color,
then turns 90 degrees clockwise before continuing. The path is drawn using the
token's initial color (4) until the first portal is encountered, after which
segments are drawn using the portal's color (e.g., color 2). Walls and portals
remain visible in the output, unchanged. The token exits the grid when it moves
beyond any boundary, and the path stops.    Output grids must visually trace the
token’s complete trajectory with color-coded segments, adhering to reflection on
walls and teleportation with directional rotation on portals. The task demands
identifying the sequence of directional changes, portal pairings, and gravity-
driven movement to reconstruct the path without prior memorization.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    grid = [[0] * width for _ in range(height)]
    
    # Place walls (color 1)
    wall_count = width * height // 5
    for _ in range(wall_count):
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        if grid[r][c] == 0:
            grid[r][c] = 1
    
    # Place token at top edge
    start_col = random.randint(0, width-1)
    grid[0][start_col] = 4
    
    # Ensure cell below token is not a wall
    if height > 1 and grid[1][start_col] == 1:
        grid[1][start_col] = 0
    
    # Place portal pairs
    portal_colors = [2, 3, 5, 6]
    random.shuffle(portal_colors)
    num_portals = random.randint(1, len(portal_colors))
    for color in portal_colors[:num_portals]:
        placed = 0
        while placed < 2:
            r = random.randint(0, height-1)
            c = random.randint(0, width-1)
            if grid[r][c] == 0:
                grid[r][c] = color
                placed += 1
    
    # Simulate path to create output
    output = [row[:] for row in grid]
    current_r, current_c = 0, start_col
    direction = 'down'
    path_color = 4
    
    for _ in range(1000):
        next_r, next_c = current_r, current_c
        if direction == 'down':
            next_r += 1
        elif direction == 'up':
            next_r -= 1
        elif direction == 'right':
            next_c += 1
        elif direction == 'left':
            next_c -= 1
        
        if next_r < 0 or next_r >= height or next_c < 0 or next_c >= width:
            break
        
        if grid[next_r][next_c] == 1:
            if direction == 'down':
                direction = 'up'
            elif direction == 'up':
                direction = 'down'
            elif direction == 'right':
                direction = 'left'
            elif direction == 'left':
                direction = 'right'
            next_r, next_c = current_r, current_c
            if direction == 'down':
                next_r += 1
            elif direction == 'up':
                next_r -= 1
            elif direction == 'right':
                next_c += 1
            elif direction == 'left':
                next_c -= 1
            if next_r < 0 or next_r >= height or next_c < 0 or next_c >= width:
                break
        
        if grid[next_r][next_c] > 1:
            portal_color = grid[next_r][next_c]
            other_pos = None
            for r in range(height):
                for c in range(width):
                    if grid[r][c] == portal_color and (r, c) != (next_r, next_c):
                        other_pos = (r, c)
                        break
                if other_pos:
                    break
            if other_pos:
                current_r, current_c = other_pos
                if direction == 'down':
                    direction = 'right'
                elif direction == 'right':
                    direction = 'up'
                elif direction == 'up':
                    direction = 'left'
                elif direction == 'left':
                    direction = 'down'
                path_color = portal_color
                continue
        
        output[next_r][next_c] = path_color
        current_r, current_c = next_r, next_c
    
    return {'input': grid, 'output': output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    start_col = None
    for c in range(width):
        if grid[0][c] == 4:
            start_col = c
            break
    if start_col is None:
        return grid
    
    current_r, current_c = 0, start_col
    direction = 'down'
    path_color = 4
    output = [row[:] for row in grid]
    
    for _ in range(1000):
        next_r, next_c = current_r, current_c
        if direction == 'down':
            next_r += 1
        elif direction == 'up':
            next_r -= 1
        elif direction == 'right':
            next_c += 1
        elif direction == 'left':
            next_c -= 1
        
        if next_r < 0 or next_r >= height or next_c < 0 or next_c >= width:
            break
        
        if grid[next_r][next_c] == 1:
            if direction == 'down':
                direction = 'up'
            elif direction == 'up':
                direction = 'down'
            elif direction == 'right':
                direction = 'left'
            elif direction == 'left':
                direction = 'right'
            next_r, next_c = current_r, current_c
            if direction == 'down':
                next_r += 1
            elif direction == 'up':
                next_r -= 1
            elif direction == 'right':
                next_c += 1
            elif direction == 'left':
                next_c -= 1
            if next_r < 0 or next_r >= height or next_c < 0 or next_c >= width:
                break
        
        if grid[next_r][next_c] > 1:
            portal_color = grid[next_r][next_c]
            other_pos = None
            for r in range(height):
                for c in range(width):
                    if grid[r][c] == portal_color and (r, c) != (next_r, next_c):
                        other_pos = (r, c)
                        break
                if other_pos:
                    break
            if other_pos:
                current_r, current_c = other_pos
                if direction == 'down':
                    direction = 'right'
                elif direction == 'right':
                    direction = 'up'
                elif direction == 'up':
                    direction = 'left'
                elif direction == 'left':
                    direction = 'down'
                path_color = portal_color
                continue
        
        output[next_r][next_c] = path_color
        current_r, current_c = next_r, next_c
    
    return output
