# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 9f271435
Difficulty: medium

=== Tags ===
- Path following
- Remove intruders
- Recolor object based on its size
- Diagonal symmetry

=== Description ===
The input grids contain a single connected path (a sequence of adjacent pixels
forming a continuous line) and extraneous pixels that do not belong to the path
(intruders). The task requires three sequential operations: first, identify and
remove all intruders to isolate the main path; second, recolor the path based on
its sizeâ€”paths with 5 or fewer pixels become green (color 3), while longer paths
become gray (color 5); third, enforce diagonal symmetry by mirroring the path
over the main diagonal (ensuring that for every pixel at position (i, j), the
pixel at (j, i) matches its color). The output grid must maintain the same
dimensions as the input, with all non-path pixels set to 0, and the path fully
reflected across the diagonal to satisfy symmetry. This transformation requires
recognizing the path, applying a size-based color rule, and systematically
enforcing symmetry, making it a medium-difficulty task that combines spatial
reasoning with compositional rule application.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, continuous_creature

def generate():
    width = random.randint(5, 15)
    height = random.randint(5, 15)
    path_length = random.randint(9, 20)
    path = continuous_creature(path_length, width, height)
    L = len(path)
    output_color = 3 if L <= 5 else 5
    input_grid = grid(width, height, 0)
    path_color = random.randint(1, 9)
    while path_color == output_color or path_color == 0:
        path_color = random.randint(1, 9)
    for (r, c) in path:
        input_grid[r][c] = path_color
    intruder_count = random.randint(3, 8)
    for _ in range(intruder_count):
        while True:
            r = random.randint(0, height-1)
            c = random.randint(0, width-1)
            if (r, c) not in path:
                # Ensure intruder is not adjacent to path
                adjacent = False
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and (nr, nc) in path:
                        adjacent = True
                        break
                if not adjacent:
                    break
        color = random.randint(1, 9)
        while color == 0 or color == path_color or color == output_color:
            color = random.randint(1, 9)
        input_grid[r][c] = color
    output_grid = grid(width, height, 0)
    for (r, c) in path:
        output_grid[r][c] = output_color
        if c < height and r < width:
            output_grid[c][r] = output_color
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    visited = [[False] * width for _ in range(height)]
    components = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                stack = [(r, c)]
                visited[r][c] = True
                comp = []
                while stack:
                    cr, cc = stack.pop()
                    comp.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append(comp)
    if not components:
        return grid(width, height, 0)
    path = max(components, key=len)
    L = len(path)
    output_color = 3 if L <= 5 else 5
    output_grid = grid(width, height, 0)
    for (r, c) in path:
        output_grid[r][c] = output_color
        if c < height and r < width:
            output_grid[c][r] = output_color
    return output_grid
