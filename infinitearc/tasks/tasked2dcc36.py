# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: ed2dcc36
Difficulty: medium–hard

=== Tags ===
- Elastic wave
- Guided flow
- Boundary tracing

=== Description ===
The task involves transforming a grid where a specific colored region (the
"source region") is surrounded by boundaries with adjacent regions of different
colors. The input grid features a background color (0), multiple distinct
colored regions (1–9), and a single source cell (e.g., color 5) located entirely
within one region, not on its boundary. The output grid must trace the boundary
of the source region with an elastic wave pattern.   The boundary is defined as
all 4-connected edges between the source region and neighboring regions
(excluding background). For horizontal boundary segments (left-right), the
output replaces every other cell along the segment with the source color,
creating a wave-like pattern (e.g., source color at even columns). For vertical
boundary segments (top-bottom), every other cell is replaced (e.g., source color
at even rows). The wave alternates direction at corners (e.g., where the
boundary turns 90 degrees), ensuring the pattern flows continuously along the
boundary's path. All non-boundary cells and regions remain unchanged. This
transformation requires identifying the source region, tracing its boundary, and
applying the wave pattern in a directionally consistent manner, making it a
medium-hard task that combines boundary detection, directional reasoning, and
pattern application.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = 15
    height = 15
    bg = 0
    colors = list(range(1, 10))
    S = random.choice(colors)
    colors.remove(S)
    C = random.choice(colors)
    
    input_grid = [[bg] * width for _ in range(height)]
    
    source_size = 3
    x = random.randint(1, height - source_size - 2)
    y = random.randint(1, width - source_size - 2)
    
    for i in range(source_size):
        for j in range(source_size):
            input_grid[x + i][y + j] = S
    
    for i in range(-1, source_size + 1):
        for j in range(-1, source_size + 1):
            r, c = x + i, y + j
            if 0 <= r < height and 0 <= c < width:
                if i >= 0 and i < source_size and j >= 0 and j < source_size:
                    continue
                input_grid[r][c] = C
    
    output_grid = [row[:] for row in input_grid]
    
    top_row = x - 1
    for col in range(y, y + source_size):
        if top_row >= 0 and col < width and output_grid[top_row][col] == C:
            if col % 2 == 0:
                output_grid[top_row][col] = S
    
    right_col = y + source_size
    for row in range(x, x + source_size):
        if row < height and right_col < width and output_grid[row][right_col] == C:
            if row % 2 == 0:
                output_grid[row][right_col] = S
    
    bottom_row = x + source_size
    for col in range(y, y + source_size):
        if bottom_row < height and col < width and output_grid[bottom_row][col] == C:
            if col % 2 == 0:
                output_grid[bottom_row][col] = S
    
    left_col = y - 1
    for row in range(x, x + source_size):
        if row < height and left_col >= 0 and output_grid[row][left_col] == C:
            if row % 2 == 0:
                output_grid[row][left_col] = S
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque
def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    non_bg = set()
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                non_bg.add(grid[r][c])
    
    visited = [[False] * width for _ in range(height)]
    regions = {}
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and grid[r][c] != 0:
                color = grid[r][c]
                component = []
                queue = deque([(r, c)])
                visited[r][c] = True
                while queue:
                    cr, cc = queue.popleft()
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                regions[color] = component
    
    source_color = None
    c_color = None
    smallest_region_size = float('inf')
    
    for color, comp in regions.items():
        neighbor_colors = set()
        for r, c in comp:
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0 and grid[nr][nc] != color:
                    neighbor_colors.add(grid[nr][nc])
        if len(neighbor_colors) == 1:
            if len(comp) < smallest_region_size:
                smallest_region_size = len(comp)
                source_color = color
                c_color = neighbor_colors.pop()
    
    if source_color is None:
        source_color = next(iter(non_bg))
        for r in range(height):
            for c in range(width):
                if grid[r][c] == source_color:
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0 and grid[nr][nc] != source_color:
                            c_color = grid[nr][nc]
                            break
                    if c_color is not None:
                        break
            if c_color is not None:
                break
    
    boundary_cells = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] == c_color:
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == source_color:
                        boundary_cells.append((r, c))
                        break
    
    for r, c in boundary_cells:
        left = (r, c-1)
        right = (r, c+1)
        if 0 <= left[1] < width and 0 <= right[1] < width and grid[left[0]][left[1]] == c_color and grid[right[0]][right[1]] == c_color:
            if c % 2 == 0:
                grid[r][c] = source_color
        else:
            top = (r-1, c)
            bottom = (r+1, c)
            if 0 <= top[0] < height and 0 <= bottom[0] < height and grid[top[0]][top[1]] == c_color and grid[bottom[0]][bottom[1]] == c_color:
                if r % 2 == 0:
                    grid[r][c] = source_color
    return [tuple(row) for row in grid]
