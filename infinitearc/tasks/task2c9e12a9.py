# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 2c9e12a9
Difficulty: mediumâ€“hard

=== Tags ===
- Fluid spread
- Inside out
- Mark centroid

=== Description ===
Input grids contain multiple disconnected, solid-colored regions (each region is
a single, connected shape of identical color) on a uniform background. Each
region has a distinct color, and the background is a neutral color (e.g., 0).
The output grid transforms each region by first marking its centroid (the
geometric center of the region's pixels) with a unique marker color (e.g., 9),
then spreading the region's original color fluidly from the centroid into all
reachable background cells. The spread moves outward from the centroid through
background cells (not through other regions), filling connected background areas
that connect to the centroid without crossing region boundaries. The spread
halts when it encounters another region or the grid edge, creating a visually
continuous "fluid" expansion from the centroid. All original regions and
background remain unchanged except for the marked centroids and the expanded
color regions. The marker color (9) must be distinct from all region colors and
the background.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque
import common


def generate():
    """Generate a grid with several non-touching connected colored regions on a zero background.

    For each region we pick a connected shape (random walk growth) and a unique color from 1..8.
    The output grid marks the region's centroid (closest boundary pixel to the centroid) with 9
    and then fluidly spreads the region's color from that marked centroid into all reachable
    background (0) cells, stopping at other regions or the grid edge. Regions are expanded in
    scanning order (top-to-bottom, left-to-right) so the solver can reproduce the same ordering.
    """
    # Grid size
    width = common.randint(8, 20)
    height = common.randint(8, 20)

    max_grid_attempts = 60
    max_region_place_attempts = 200

    for _ in range(max_grid_attempts):
        input_grid = [[0 for _ in range(width)] for _ in range(height)]
        # available colors (exclude 0 and 9)
        colors = list(range(1, 9))
        random.shuffle(colors)
        num_regions = common.randint(2, 4)
        regions = []  # list of (color, list_of_pixels)
        success = True

        for _region in range(num_regions):
            if not colors:
                success = False
                break
            placed = False
            # Try to create and place one connected region
            for attempt in range(max_region_place_attempts):
                # Choose a random size for the region
                max_size = min(12, max(3, (width * height) // 12))
                size = common.randint(3, max_size)

                # Pick a random start cell that is free and not adjacent (4-nei) to already placed regions
                start_candidates = []
                for r in range(height):
                    for c in range(width):
                        if input_grid[r][c] != 0:
                            continue
                        # ensure candidate is not 4-adjacent to an existing region cell
                        conflict = False
                        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                            nr, nc = r + dr, c + dc
                            if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0:
                                conflict = True
                                break
                        if not conflict:
                            start_candidates.append((r, c))
                if not start_candidates:
                    break

                sr, sc = random.choice(start_candidates)
                shape = set()
                shape.add((sr, sc))

                # Grow the shape by adding neighbors until desired size or we get stuck
                for _grow in range(size - 1):
                    # collect possible candidate neighbors to add (neighbors of current shape)
                    candidates = []
                    for (pr, pc) in list(shape):
                        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                            nr, nc = pr + dr, pc + dc
                            if not (0 <= nr < height and 0 <= nc < width):
                                continue
                            if (nr, nc) in shape:
                                continue
                            if input_grid[nr][nc] != 0:
                                continue
                            # Ensure this new cell would not be 4-adjacent to already-placed regions
                            adjacent_to_other = False
                            for adr, adc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                                ar, ac = nr + adr, nc + adc
                                if 0 <= ar < height and 0 <= ac < width and input_grid[ar][ac] != 0:
                                    adjacent_to_other = True
                                    break
                            if adjacent_to_other:
                                continue
                            candidates.append((nr, nc))
                    if not candidates:
                        break
                    shape.add(random.choice(candidates))

                # If we didn't reach the requested size, try again
                if len(shape) != size:
                    continue

                # Check the shape has at least one boundary pixel (a pixel with an adjacent background or the edge)
                has_boundary = False
                for (r, c) in shape:
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = r + dr, c + dc
                        if not (0 <= nr < height and 0 <= nc < width):
                            has_boundary = True
                            break
                        if input_grid[nr][nc] == 0 and (nr, nc) not in shape:
                            has_boundary = True
                            break
                    if has_boundary:
                        break
                if not has_boundary:
                    # This shape would be isolated from background; try again
                    continue

                # Place the shape with a chosen color
                color = colors.pop()
                pixels = list(shape)
                for (r, c) in pixels:
                    input_grid[r][c] = color
                regions.append((color, pixels))
                placed = True
                break

            if not placed:
                success = False
                break

        if not success:
            # Try new grid
            continue

        # Create the output starting from the input
        output_grid = [row[:] for row in input_grid]

        # Process regions in scanning order so the solver can reproduce the same ordering
        regions.sort(key=lambda rc: (min(p[0] for p in rc[1]), min(p[1] for p in rc[1])))

        for color, pixels in regions:
            # centroid (geometric center) of pixels
            total_r = sum(r for r, c in pixels)
            total_c = sum(c for r, c in pixels)
            n = len(pixels)
            centroid_r = total_r / n
            centroid_c = total_c / n

            # boundary pixels are pixels that have at least one neighbor that's background (or edge)
            boundary = []
            for r, c in pixels:
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = r + dr, c + dc
                    if not (0 <= nr < height and 0 <= nc < width):
                        boundary.append((r, c))
                        break
                    # neighbor is background in the original input
                    if input_grid[nr][nc] == 0 and (nr, nc) not in pixels:
                        boundary.append((r, c))
                        break
                # next pixel
            if boundary:
                # pick the boundary pixel closest to the centroid (euclidean), tie-break by row,col
                pick = min(boundary, key=lambda p: (((p[0] - centroid_r) ** 2 + (p[1] - centroid_c) ** 2), p[0], p[1]))
            else:
                # fallback: choose the region pixel closest to centroid (manhattan), tie-break by row,col
                pick = min(pixels, key=lambda p: (abs(p[0] - centroid_r) + abs(p[1] - centroid_c), p[0], p[1]))

            pr, pc = pick
            # mark centroid with 9
            output_grid[pr][pc] = 9

            # Spread the region color from the picked pixel into reachable background cells (zeros) only
            dq = deque([(pr, pc)])
            visited = set([(pr, pc)])
            while dq:
                r, c = dq.popleft()
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in visited and output_grid[nr][nc] == 0:
                        output_grid[nr][nc] = color
                        visited.add((nr, nc))
                        dq.append((nr, nc))

        # ensure at least one centroid marker was placed
        found9 = any(output_grid[r][c] == 9 for r in range(height) for c in range(width))
        if not found9:
            # unlikely, try another grid
            continue

        return {"input": input_grid, "output": output_grid}

    # if we failed to construct a grid (very unlikely), raise
    raise RuntimeError("generate failed")



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    # Convert to a mutable list-of-lists and keep original for reference
    original = [list(row) for row in input_grid]
    height = len(original)
    width = len(original[0])

    # Find all connected regions (4-connected) of non-zero color
    visited = [[False] * width for _ in range(height)]
    regions = []  # list of (color, pixels)

    for r in range(height):
        for c in range(width):
            if visited[r][c] or original[r][c] == 0:
                continue
            color = original[r][c]
            dq = deque([(r, c)])
            visited[r][c] = True
            pixels = []
            while dq:
                cr, cc = dq.popleft()
                pixels.append((cr, cc))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and original[nr][nc] == color:
                        visited[nr][nc] = True
                        dq.append((nr, nc))
            regions.append((color, pixels))

    # Process regions in scanning order (top-to-bottom, left-to-right) to match the generator
    regions.sort(key=lambda rc: (min(p[0] for p in rc[1]), min(p[1] for p in rc[1])))

    out = [row[:] for row in original]

    for color, pixels in regions:
        # compute centroid of the pixel coordinates
        total_r = sum(r for r, c in pixels)
        total_c = sum(c for r, c in pixels)
        n = len(pixels)
        centroid_r = total_r / n
        centroid_c = total_c / n

        # find boundary pixels (adjacent to background or grid edge) relative to the original input
        boundary = []
        for r, c in pixels:
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if not (0 <= nr < height and 0 <= nc < width):
                    boundary.append((r, c))
                    break
                if original[nr][nc] == 0 and (nr, nc) not in pixels:
                    boundary.append((r, c))
                    break

        if boundary:
            pick = min(boundary, key=lambda p: (((p[0] - centroid_r) ** 2 + (p[1] - centroid_c) ** 2), p[0], p[1]))
        else:
            pick = min(pixels, key=lambda p: (abs(p[0] - centroid_r) + abs(p[1] - centroid_c), p[0], p[1]))

        pr, pc = pick
        out[pr][pc] = 9

        # Spread the region color from the picked pixel into reachable background cells (zeros) only
        dq = deque([(pr, pc)])
        visited_spread = set([(pr, pc)])
        while dq:
            cr, cc = dq.popleft()
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = cr + dr, cc + dc
                if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in visited_spread and out[nr][nc] == 0:
                    out[nr][nc] = color
                    visited_spread.add((nr, nc))
                    dq.append((nr, nc))

    # Return as a tuple of tuples (immutable)
    return tuple(tuple(row) for row in out)

