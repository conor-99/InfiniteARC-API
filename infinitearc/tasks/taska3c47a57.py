# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: a3c47a57
Difficulty: very hard

=== Tags ===
- Momentum transfer
- Hierarchical reflection
- Gravity

=== Description ===
Momentum Transfer Hierarchical Reflection with Gravity  Input grids feature a 2D
canvas with cells colored using values 0-9 (0 = background). Three key color
types define the transformation rules: - **Momentum Cells** (e.g., red): Move
one cell per step in a fixed direction (right for red, down for blue). -
**Reflector Cells** (e.g., green): Change direction of momentum cells upon
collision (e.g., right-moving momentum becomes up-moving after hitting green). -
**Gravity Cells** (e.g., yellow): Apply downward pull to all momentum cells
after reflection steps.  The transformation process applies these steps
hierarchically: 1. **Momentum Propagation**: All momentum cells advance one cell
in their direction. Upon colliding with a reflector, their direction changes per
the reflector's properties (e.g., right → up). 2. **Hierarchical Reflection**:
After each momentum step, the grid undergoes recursive reflection: first
vertically (top-bottom), then horizontally (left-right), creating nested
mirrored copies of the momentum paths. This reflection depth increases with each
interaction (e.g., 1st collision → 1 reflection layer, 2nd collision → 2
layers). 3. **Gravity Application**: After each reflection cycle, all momentum
cells are pulled downward until they land on a non-background cell or the grid
bottom.  The process repeats until no further movement occurs. Output grids
display all momentum paths traced by their original colors, with reflector and
gravity cells unchanged. The hierarchical reflection creates complex, fractal-
like patterns where each reflection layer is itself reflected, requiring solvers
to track multiple nested transformation layers simultaneously. Gravity ensures
downward alignment of paths, while momentum transfer dictates direction changes
at reflectors. This combination of dynamic movement, recursive reflection, and
gravitational constraints creates a visually intricate transformation demanding
multi-step abstract reasoning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, all_pixels

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    grid = [[0] * width for _ in range(height)]
    
    # Place momentum cells (red=2, blue=1)
    for _ in range(random.randint(1, min(5, width*height//2))):
        r, c = random.randint(0, height-1), random.randint(0, width-1)
        if grid[r][c] != 0: continue
        grid[r][c] = random.choice([1, 2])
    
    # Place reflectors (green=3)
    for _ in range(random.randint(1, min(3, width*height//4))):
        r, c = random.randint(0, height-1), random.randint(0, width-1)
        if grid[r][c] != 0: continue
        grid[r][c] = 3
    
    # Place gravity cells (yellow=4)
    for _ in range(random.randint(1, min(2, width*height//4))):
        r, c = random.randint(0, height-1), random.randint(0, width-1)
        if grid[r][c] != 0: continue
        grid[r][c] = 4
    
    # Ensure at least one momentum cell can move
    can_move = False
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 2 and c+1 < width and grid[r][c+1] == 0:
                can_move = True
            elif grid[r][c] == 1 and r+1 < height and grid[r+1][c] == 0:
                can_move = True
    if not can_move:
        return generate()

    input_grid = [row[:] for row in grid]
    output_grid = [row[:] for row in grid]
    
    # Apply transformation steps
    for _ in range(10):
        # Move momentum cells
        momentum_cells = []
        for r in range(height):
            for c in range(width):
                if output_grid[r][c] in [1, 2]:
                    momentum_cells.append((r, c, output_grid[r][c]))
        
        new_output = [row[:] for row in output_grid]
        for r, c, color in momentum_cells:
            dr, dc = 0, 0
            if color == 2: dc = 1
            elif color == 1: dr = 1
            nr, nc = r + dr, c + dc
            
            if 0 <= nr < height and 0 <= nc < width:
                if output_grid[nr][nc] == 3:  # Reflector
                    # Change direction
                    if color == 2: new_color = 1
                    else: new_color = 2
                    new_output[r][c] = 0
                    new_output[nr][nc] = new_color
                elif output_grid[nr][nc] == 0:
                    new_output[r][c] = 0
                    new_output[nr][nc] = color
                
        output_grid = new_output
        
        # Apply vertical reflection
        output_grid = output_grid[::-1]
        # Apply horizontal reflection
        output_grid = [row[::-1] for row in output_grid]
        
        # Apply gravity
        for c in range(width):
            for r in range(height-1, -1, -1):
                if output_grid[r][c] in [1, 2]:
                    # Move down as far as possible
                    while r + 1 < height and output_grid[r+1][c] == 0:
                        output_grid[r+1][c] = output_grid[r][c]
                        output_grid[r][c] = 0
                        r += 1

    # Ensure input != output
    if input_grid == output_grid:
        return generate()
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    
    # Apply transformation steps
    for _ in range(10):
        momentum_cells = []
        for r in range(height):
            for c in range(width):
                if grid[r][c] in [1, 2]:
                    momentum_cells.append((r, c, grid[r][c]))
        
        new_grid = [row[:] for row in grid]
        for r, c, color in momentum_cells:
            dr, dc = (1, 0) if color == 1 else (0, 1)
            nr, nc = r + dr, c + dc
            
            if 0 <= nr < height and 0 <= nc < width:
                if grid[nr][nc] == 3:  # Reflector
                    new_color = 1 if color == 2 else 2
                    new_grid[r][c] = 0
                    new_grid[nr][nc] = new_color
                elif grid[nr][nc] == 0:
                    new_grid[r][c] = 0
                    new_grid[nr][nc] = color
                
        grid = new_grid
        
        # Apply vertical reflection
        grid = grid[::-1]
        # Apply horizontal reflection
        grid = [row[::-1] for row in grid]
        
        # Apply gravity
        for c in range(width):
            for r in range(height-1, -1, -1):
                if grid[r][c] in [1, 2]:
                    while r + 1 < height and grid[r+1][c] == 0:
                        grid[r+1][c] = grid[r][c]
                        grid[r][c] = 0
                        r += 1
    
    return grid
