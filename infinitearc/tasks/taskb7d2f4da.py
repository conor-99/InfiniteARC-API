# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: b7d2f4da
Difficulty: insane

=== Tags ===
- Analogical mapping between pairs
- Pattern repetition
- Add frame

=== Description ===
Input grids feature a central repeating pattern of colored tiles (e.g., a
periodic arrangement of colors forming a recognizable motif) surrounded by a
uniform background. Scattered within the grid are two distinct reference pairs:
each pair consists of two adjacent cells (horizontally or vertically) with
colors forming a mirror relationship (e.g., color A followed by color B in one
pair, and color B followed by color A in the other pair). The output grid must
first apply an analogical mapping that swaps the colors in each reference pair
(e.g., A becomes B and B becomes A), then generate a frame around the entire
grid. The frame's edge colors alternate between the mapped colors along each
edge, creating a repeating pattern that reflects the swapped reference pairs.
The central pattern remains unchanged, while the frame's color sequence is
derived from the analogical mapping of the reference pairs.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    if not hasattr(generate, 'cache'):
        generate.cache = set()
        sizes = list(range(20, 31))
        colors = [1, 2, 8, 9]
        all_combinations = []
        for size in sizes:
            for a in colors:
                for b in colors:
                    if a != b:
                        all_combinations.append((size, a, b))
        random.shuffle(all_combinations)
        generate.combinations = all_combinations
    
    while generate.combinations:
        size, A, B = generate.combinations.pop()
        if (size, A, B) not in generate.cache:
            generate.cache.add((size, A, B))
            break
    else:
        size = random.randint(20, 30)
        A, B = random.sample([1, 2, 8, 9], 2)
    
    width = size
    height = size
    bg = 0
    input_grid = grid(width, height, bg)
    
    for r in range(5, 15):
        for c in range(5, 15):
            if r < height and c < width:
                input_grid[r][c] = (r + c) % 5 + 3
    
    input_grid[2][2] = A
    input_grid[2][3] = B
    input_grid[4][5] = B
    input_grid[5][5] = A
    
    output_grid = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] == A:
                output_grid[r][c] = B
            elif output_grid[r][c] == B:
                output_grid[r][c] = A
    
    for c in range(width):
        output_grid[0][c] = B if c % 2 == 0 else A
        output_grid[height-1][c] = B if c % 2 == 0 else A
    for r in range(height):
        output_grid[r][0] = A if r % 2 == 0 else B
        output_grid[r][width-1] = A if r % 2 == 0 else B
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    
    pairs = []
    for r in range(height):
        for c in range(width - 1):
            if input_grid[r][c] != 0 and input_grid[r][c+1] != 0:
                pairs.append((input_grid[r][c], input_grid[r][c+1]))
        for c in range(width):
            if r < height - 1 and input_grid[r][c] != 0 and input_grid[r+1][c] != 0:
                pairs.append((input_grid[r][c], input_grid[r+1][c]))
    
    A, B = None, None
    for i in range(len(pairs)):
        for j in range(i+1, len(pairs)):
            if pairs[i] == (pairs[j][1], pairs[j][0]):
                A, B = pairs[i]
                break
        if A is not None:
            break
    
    output_grid = [list(row) for row in input_grid]
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] == A:
                output_grid[r][c] = B
            elif output_grid[r][c] == B:
                output_grid[r][c] = A
    
    for c in range(width):
        output_grid[0][c] = B if c % 2 == 0 else A
        output_grid[height-1][c] = B if c % 2 == 0 else A
    for r in range(height):
        output_grid[r][0] = A if r % 2 == 0 else B
        output_grid[r][width-1] = A if r % 2 == 0 else B
    
    return output_grid
