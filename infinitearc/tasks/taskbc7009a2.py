# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: bc7009a2
Difficulty: very hard

=== Tags ===
- Reflective maze
- Energy absorption
- Rule transfer between regions
- If then color switch

=== Description ===
Input grids consist of a large 2D grid divided into two distinct regions: a
"rule source" region (typically a compact 3x3 to 5x5 subgrid) and a "target
maze" region occupying the remainder of the grid. The rule source contains
color-coded mirror tiles (each color representing a unique reflection angle) and
a predefined energy path that demonstrates how each mirror type redirects
movement. The target maze contains a complex arrangement of mirror tiles, energy
absorbers (color-coded tiles that absorb energy and change color), and
background cells. Energy originates from a fixed starting point in the target
maze (e.g., the top-left corner of the maze region) moving rightward.  The
transformation applies four layered rules sequentially:   1. **Rule Transfer**:
The reflection behavior of each color in the rule source (e.g., color 3 reflects
upward-left) is mapped to the target maze. All mirror tiles in the target region
adopt the reflection behavior defined by their corresponding color in the rule
source.   2. **Energy Absorption**: When energy encounters an absorber tile (a
predefined color, e.g., color 5), it stops moving, and the absorber tile
permanently changes color (e.g., to color 6).   3. **Conditional Color Switch**:
If the current energy color matches a trigger color (e.g., red) and the tile it
hits matches a condition color (e.g., blue), the energy color instantly switches
to a target color (e.g., green). This switch is applied *before* reflection or
absorption.   4. **Path Tracing**: The energy path is drawn in real-time using
its current color, continuing until it exits the grid, hits an absorber, or is
blocked by non-mirror obstacles.    The output grid preserves all original
background elements and absorbers (post-absorption), renders the full energy
path as a continuous line using the energy's color at each step, and retains the
rule source region unchanged. The complexity arises from the need to infer
mirror behavior from the rule source, track dynamic color switches, and resolve
absorption events without overlapping paths.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = 20
    height = 20
    rule_source_size = 4
    input_grid = grid(width, height, 0)
    rule_source = grid(rule_source_size, rule_source_size, 0)
    rule_source[1][1] = 1
    rule_source[1][2] = 2
    rule_source[2][1] = 3
    rule_source[2][2] = 4
    for r in range(rule_source_size):
        for c in range(rule_source_size):
            input_grid[r][c] = rule_source[r][c]
    for r in range(rule_source_size, height):
        for c in range(width):
            if random.random() < 0.3:
                input_grid[r][c] = random.choice([1,2,3,4])
            elif random.random() < 0.1:
                input_grid[r][c] = 5
            else:
                input_grid[r][c] = 0
    input_grid[4][0] = 0
    output_grid = [row[:] for row in input_grid]
    r, c = 4, 0
    direction = (0, 1)
    current_color = 1
    steps = 0
    max_steps = 1000
    while 0 <= r < height and 0 <= c < width and steps < max_steps:
        cell_color = input_grid[r][c]
        if current_color == 2 and cell_color == 3:
            current_color = 4
        if cell_color == 5:
            output_grid[r][c] = 6
            break
        output_grid[r][c] = current_color
        if cell_color in [1,2,3,4]:
            if cell_color == 1:
                direction = (-1, -1)
            elif cell_color == 2:
                direction = (-1, 1)
            elif cell_color == 3:
                direction = (1, -1)
            elif cell_color == 4:
                direction = (1, 1)
        r += direction[0]
        c += direction[1]
        steps += 1
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    rule_source_map = {
        1: (-1, -1),
        2: (-1, 1),
        3: (1, -1),
        4: (1, 1)
    }
    r, c = 4, 0
    direction = (0, 1)
    current_color = 1
    output_grid = [row[:] for row in input_grid]
    steps = 0
    max_steps = 1000
    while 0 <= r < height and 0 <= c < width and steps < max_steps:
        cell_color = input_grid[r][c]
        if current_color == 2 and cell_color == 3:
            current_color = 4
        if cell_color == 5:
            output_grid[r][c] = 6
            break
        output_grid[r][c] = current_color
        if cell_color in [1,2,3,4]:
            direction = rule_source_map[cell_color]
        r += direction[0]
        c += direction[1]
        steps += 1
    return output_grid
