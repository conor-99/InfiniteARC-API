# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: d3e402f4
Difficulty: medium

=== Tags ===
- Remove intruder
- Path following

=== Description ===
The input grid contains a continuous path formed by a single color (e.g., blue)
where all cells are connected horizontally or vertically. This path is the
largest connected region of its color. Additionally, there is exactly one
"intruder" cell—a single cell of a different color (e.g., red)—that is adjacent
to the path but does not belong to it. The output grid removes this intruder
cell by setting it to the background color (0), while preserving the integrity
of the continuous path. The transformation requires identifying the main path as
the largest connected region of a single non-zero color and eliminating the sole
non-path cell that disrupts its continuity.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = common.grid(width, height, 0)
    path_size = random.randint(5, 20)
    path_pixels = common.continuous_creature(path_size, width, height)
    path_color = common.random_color(exclude=[0])
    for r, c in path_pixels:
        grid[r][c] = path_color
    intruder_color = common.random_color(exclude=[0, path_color])
    adjacent_cells = []
    for r, c in path_pixels:
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0:
                adjacent_cells.append((nr, nc))
    r, c = random.choice(adjacent_cells)
    grid[r][c] = intruder_color
    output_grid = [row[:] for row in grid]
    output_grid[r][c] = 0
    return {
        "input": grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    visited = [[False] * width for _ in range(height)]
    largest_region = None
    largest_size = 0
    path_color = None
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] > 0 and not visited[r][c]:
                color = input_grid[r][c]
                queue = [(r, c)]
                visited[r][c] = True
                region = [(r, c)]
                while queue:
                    cr, cc = queue.pop(0)
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                            region.append((nr, nc))
                size = len(region)
                if size > largest_size:
                    largest_size = size
                    largest_region = region
                    path_color = color
    
    intruder_pos = None
    for r, c in largest_region:
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width:
                if input_grid[nr][nc] != 0 and input_grid[nr][nc] != path_color:
                    if intruder_pos is None:
                        intruder_pos = (nr, nc)
    
    if intruder_pos:
        output = [list(row) for row in input_grid]
        r, c = intruder_pos
        output[r][c] = 0
        return output
    else:
        return input_grid
