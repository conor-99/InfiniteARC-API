# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: d5cda21c
Difficulty: medium

=== Tags ===
- Sort objects in row by size
- Connect nearest components
- One yes one no
- Take intersection

=== Description ===
The input grid consists of a 2D arrangement of colored cells where each row
contains distinct "objects" formed by consecutive cells of the same color. The
transformation involves two consistent, visual steps:    1. **Sort objects in
each row by size**: For each row, the consecutive color blocks (objects) are
sorted based on their size (number of cells in the block), from smallest to
largest. This rearranges the row so that smaller blocks appear before larger
ones. For example, a row containing a 2-cell block followed by a 3-cell block
and a 1-cell block becomes a 1-cell block followed by the 2-cell block followed
by the 3-cell block.    2. **Connect nearest components**: After sorting, for
each color present in the grid, identify the two closest components (blocks) of
that color (measured by Manhattan distance between their nearest cells). If such
a pair exists, fill all cells between them (along the shortest path) with the
color to create a visual connection. Components of the same color that are not
the nearest pair remain unconnected.    The "one yes one no" tag reflects that
for each color, exactly one pair of components is connected (the nearest pair,
"yes"), while other components of the same color remain disconnected ("no"). The
"take intersection" tag refers to the process of identifying the minimal
distance (intersection of spatial proximity) between components to determine
which pair to connect.    This task requires visual reasoning about object size,
spatial proximity, and color-based connections, with rules discoverable through
examining a small number of input-output examples.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(3, 10)
    height = random.randint(3, 10)
    input_grid = grid(width, height, 0)
    
    for r in range(height):
        num_blocks = random.randint(2, 4)
        colors = random.sample(range(1, 10), num_blocks)
        sizes = []
        remaining = width
        for i in range(num_blocks - 1):
            max_size = min(3, remaining - (num_blocks - 1 - i))
            if max_size < 1:
                max_size = 1
            size = random.randint(1, max_size)
            sizes.append(size)
            remaining -= size
        sizes.append(remaining)
        
        c = 0
        for i in range(num_blocks):
            color = colors[i]
            for _ in range(sizes[i]):
                input_grid[r][c] = color
                c += 1
    
    output_grid = [row[:] for row in input_grid]
    
    for r in range(height):
        blocks = []
        current_color = input_grid[r][0]
        current_size = 0
        for c in range(width):
            if input_grid[r][c] == current_color:
                current_size += 1
            else:
                blocks.append((current_color, current_size))
                current_color = input_grid[r][c]
                current_size = 1
        blocks.append((current_color, current_size))
        blocks.sort(key=lambda x: x[1])
        c = 0
        for color, size in blocks:
            for i in range(size):
                output_grid[r][c] = color
                c += 1
    
    visited = [[False] * width for _ in range(height)]
    color_components = {color: [] for color in range(1, 10)}
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and output_grid[r][c] != 0:
                color = output_grid[r][c]
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and output_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                color_components[color].append(component)
    
    for color, components in color_components.items():
        if len(components) >= 2:
            min_dist = float('inf')
            pair = (0, 1)
            for i in range(len(components)):
                for j in range(i+1, len(components)):
                    dist = float('inf')
                    for (r1, c1) in components[i]:
                        for (r2, c2) in components[j]:
                            d = abs(r1 - r2) + abs(c1 - c2)
                            if d < dist:
                                dist = d
                    if dist < min_dist:
                        min_dist = dist
                        pair = (i, j)
            comp1 = components[pair[0]]
            comp2 = components[pair[1]]
            min_point1 = None
            min_point2 = None
            min_dist = float('inf')
            for (r1, c1) in comp1:
                for (r2, c2) in comp2:
                    d = abs(r1 - r2) + abs(c1 - c2)
                    if d < min_dist:
                        min_dist = d
                        min_point1 = (r1, c1)
                        min_point2 = (r2, c2)
            r1, c1 = min_point1
            r2, c2 = min_point2
            start_c, end_c = min(c1, c2), max(c1, c2)
            for c in range(start_c, end_c + 1):
                output_grid[r1][c] = color
            start_r, end_r = min(r1, r2), max(r1, r2)
            for r in range(start_r, end_r + 1):
                output_grid[r][c2] = color
    
    if input_grid == output_grid:
        return generate()
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random
from common import grid

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = [list(row) for row in input_grid]  # Fixed: Convert to list of lists
    
    for r in range(height):
        blocks = []
        current_color = input_grid[r][0]
        current_size = 0
        for c in range(width):
            if input_grid[r][c] == current_color:
                current_size += 1
            else:
                blocks.append((current_color, current_size))
                current_color = input_grid[r][c]
                current_size = 1
        blocks.append((current_color, current_size))
        blocks.sort(key=lambda x: x[1])
        c = 0
        for color, size in blocks:
            for i in range(size):
                output_grid[r][c] = color
                c += 1
    
    visited = [[False] * width for _ in range(height)]
    color_components = {color: [] for color in range(1, 10)}
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and output_grid[r][c] != 0:
                color = output_grid[r][c]
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and output_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                color_components[color].append(component)
    
    for color, components in color_components.items():
        if len(components) >= 2:
            min_dist = float('inf')
            pair = (0, 1)
            for i in range(len(components)):
                for j in range(i+1, len(components)):
                    dist = float('inf')
                    for (r1, c1) in components[i]:
                        for (r2, c2) in components[j]:
                            d = abs(r1 - r2) + abs(c1 - c2)
                            if d < dist:
                                dist = d
                    if dist < min_dist:
                        min_dist = dist
                        pair = (i, j)
            comp1 = components[pair[0]]
            comp2 = components[pair[1]]
            min_point1 = None
            min_point2 = None
            min_dist = float('inf')
            for (r1, c1) in comp1:
                for (r2, c2) in comp2:
                    d = abs(r1 - r2) + abs(c1 - c2)
                    if d < min_dist:
                        min_dist = d
                        min_point1 = (r1, c1)
                        min_point2 = (r2, c2)
            r1, c1 = min_point1
            r2, c2 = min_point2
            start_c, end_c = min(c1, c2), max(c1, c2)
            for c in range(start_c, end_c + 1):
                output_grid[r1][c] = color
            start_r, end_r = min(r1, r2), max(r1, r2)
            for r in range(start_r, end_r + 1):
                output_grid[r][c2] = color
    return output_grid
