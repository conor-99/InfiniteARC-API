# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 47ab6bc1
Difficulty: very hard

=== Tags ===
- Pattern intersection
- Flood fill region

=== Description ===
Input grids feature a background color (0) and multiple contiguous colored
regions (1-9), each region defined by a unique geometric pattern visible in its
shape. Pattern types are determined as follows: a region has a *linear pattern*
if it forms a straight horizontal or vertical line spanning its entire bounding
box; a *block pattern* if it completely fills a square bounding box; and a
*diamond pattern* if its shape resembles a diamond (e.g., a 3x3 square with the
four corners and center missing, leaving only the diagonal edges).   The output
grid applies a *flood fill* operation to all background cells (0) that lie
within the *intersection zone* of two regions with compatible patterns.
Compatibility requires: (1) a linear region (horizontal or vertical) adjacent to
a block region aligned with the linear direction (e.g., horizontal linear +
horizontal block), or (2) a diamond region touching any other region. For
compatible intersections, the output fills the connected background region
surrounding the intersection point with a specific color: color 5 for linear-
block intersections, color 7 for diamond intersections. All other regions,
patterns, and background cells remain unchanged. The filled areas must be
contiguous background regions entirely enclosed by the intersecting patterns,
with no overlap or interference from other elements. No two regions share the
same color, and all patterns must be visually distinguishable by their shape
alone.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

# Keep a module-level counter to help ensure unique outputs across multiple calls
CALL_COUNT = 0


def generate():
    global CALL_COUNT
    CALL_COUNT += 1

    # Grid size: choose a moderately large grid so patterns can be placed safely
    width = random.randint(9, 20)
    height = random.randint(9, 20)

    # Create empty grid background 0
    grid = [[0 for _ in range(width)] for _ in range(height)]

    # Reserve a special marker color (9) and ensure region colors don't use it.
    marker_color = 9

    # Place a small marker in the corner to bias uniqueness across calls
    grid[0][0] = marker_color

    # Choose two distinct colors from 1..8 for the regions (exclude marker_color)
    region_colors = random.sample(list(range(1, 9)), 2)
    diamond_color, other_color = region_colors[0], region_colors[1]

    # Choose a safe margin so shapes don't touch the grid edges or the marker at (0,0)
    margin = 3
    max_row_span = max(1, height - 2 * margin)
    max_col_span = max(1, width - 2 * margin)

    # Base random center in inner area
    base_cr = random.randint(margin, height - margin - 1)
    base_cc = random.randint(margin, width - margin - 1)

    # Use CALL_COUNT to shift the center deterministically so repeated calls are likely unique
    cr = margin + ((base_cr - margin + CALL_COUNT) % max_row_span)
    cc = margin + ((base_cc - margin + CALL_COUNT * 2) % max_col_span)

    # Ensure the center is clear (should be 0 initially)
    if not (0 <= cr < height and 0 <= cc < width):
        cr = margin
        cc = margin

    # Place a 'diamond' pattern: a 3x3 plus-shape with an empty center
    diamond_cells = [(cr - 1, cc), (cr, cc - 1), (cr, cc + 1), (cr + 1, cc)]
    for (r, c) in diamond_cells:
        grid[r][c] = diamond_color

    # Randomly choose a second region type: block or line
    region_type = random.choice(["block", "line"])

    # We'll attempt to place the second region so that it touches at least one diamond arm
    arms = diamond_cells[:]
    random.shuffle(arms)

    placed = False
    attempts = 0
    while not placed and attempts < 80:
        attempts += 1
        arm = arms[attempts % len(arms)]
        ar, ac = arm
        # outward direction from diamond center through the arm
        dr = ar - cr
        dc = ac - cc
        adj_r, adj_c = ar + dr, ac + dc  # the cell just outside the arm

        # If adj cell is out-of-bounds, try another arm
        if not (0 <= adj_r < height and 0 <= adj_c < width):
            continue

        if region_type == "block":
            # Try square block sizes 2..4
            S = random.randint(2, min(4, min(height, width) - 1))
            # Choose an offset so that the adjacent cell adj_r,adj_c lies somewhere inside the square
            off_r = random.randint(0, S - 1)
            off_c = random.randint(0, S - 1)
            top_r = adj_r - off_r
            left_c = adj_c - off_c
            # Check bounds
            if top_r < 1 or left_c < 1 or top_r + S > height - 1 or left_c + S > width - 1:
                continue
            # Ensure block doesn't overlap existing non-zero cells (including diamond and marker)
            overlap = False
            for r in range(top_r, top_r + S):
                for c in range(left_c, left_c + S):
                    if grid[r][c] != 0:
                        overlap = True
                        break
                if overlap:
                    break
            if overlap:
                continue
            # Place the block
            for r in range(top_r, top_r + S):
                for c in range(left_c, left_c + S):
                    grid[r][c] = other_color
            placed = True
            break

        else:  # region_type == "line"
            # Choose orientation and length
            orientation = random.choice(["h", "v"])
            if orientation == "h":
                L = random.randint(3, max(3, width // 3))
                row = adj_r
                # choose a start column so adj_c lies within the line
                start_c = adj_c - random.randint(0, L - 1)
                start_c = max(1, min(start_c, width - L - 1))
                end_c = start_c + L
                # Check overlap
                overlap = any(grid[row][c] != 0 for c in range(start_c, end_c))
                if overlap:
                    continue
                # Place the line
                for c in range(start_c, end_c):
                    grid[row][c] = other_color
                placed = True
                break
            else:
                L = random.randint(3, max(3, height // 3))
                col = adj_c
                start_r = adj_r - random.randint(0, L - 1)
                start_r = max(1, min(start_r, height - L - 1))
                end_r = start_r + L
                overlap = any(grid[r][col] != 0 for r in range(start_r, end_r))
                if overlap:
                    continue
                for r in range(start_r, end_r):
                    grid[r][col] = other_color
                placed = True
                break

    # If no placement succeeded, force a small block adjacent to the right arm (fallback)
    if not placed:
        # pick rightmost possible arm or fallback to first
        arm = arms[0]
        ar, ac = arm
        dr = ar - cr
        dc = ac - cc
        adj_r, adj_c = ar + dr, ac + dc
        S = 2
        # prefer placing block where adj cell sits at top-left of the block
        top_r = adj_r
        left_c = adj_c
        # Clip into bounds
        top_r = max(1, min(top_r, height - S - 1))
        left_c = max(1, min(left_c, width - S - 1))
        for r in range(top_r, top_r + S):
            for c in range(left_c, left_c + S):
                if grid[r][c] == 0:
                    grid[r][c] = other_color

    # Prepare output grid: for diamond intersections (diamond touching any other region) fill the diamond center
    output_grid = [row[:] for row in grid]

    # detect if any arm has an orthogonally adjacent cell of a different non-zero color
    touched = False
    for (ar, ac) in diamond_cells:
        for dr_nb, dc_nb in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = ar + dr_nb, ac + dc_nb
            if 0 <= nr < height and 0 <= nc < width:
                val = grid[nr][nc]
                if val != 0 and val != diamond_color:
                    touched = True
                    break
        if touched:
            break

    if touched and 0 <= cr < height and 0 <= cc < width:
        output_grid[cr][cc] = 7

    return {"input": grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # We'll scan for the diamond "plus" pattern: an empty center with four orthogonal neighbors
    # all of the same non-zero color. If any other non-zero color touches any of the arm cells,
    # we fill the center with color 7.

    # Copy grid for output modifications
    out = [row[:] for row in grid]

    for r in range(1, height - 1):
        for c in range(1, width - 1):
            # center must be background
            if grid[r][c] != 0:
                continue
            # four arms must exist and share the same non-zero color
            arms = [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]
            arm_vals = [grid[ar][ac] for (ar, ac) in arms]
            if any(val == 0 for val in arm_vals):
                continue
            # All arms must have the same color
            if not (arm_vals.count(arm_vals[0]) == 4):
                continue
            diamond_color = arm_vals[0]
            if diamond_color == 0:
                continue

            # Check if any neighbor of any arm cell is a different non-zero color
            touched = False
            for (ar, ac) in arms:
                for dr_nb, dc_nb in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = ar + dr_nb, ac + dc_nb
                    if nr < 0 or nr >= height or nc < 0 or nc >= width:
                        continue
                    val = grid[nr][nc]
                    if val != 0 and val != diamond_color:
                        touched = True
                        break
                if touched:
                    break

            if touched:
                out[r][c] = 7

    # Return as immutable tuple of tuples
    return tuple(tuple(row) for row in out)

