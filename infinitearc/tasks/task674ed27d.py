# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 674ed27d
Difficulty: very hard

=== Tags ===
- Synchronized bounce
- Alternating direction
- Topological invariance

=== Description ===
The input grid consists of a horizontal sequence of distinct colored elements
(each representing a unique entity) arranged along a single row, with each color
encoding a specific movement direction (e.g., color 1 = right, color 2 = left,
color 3 = up, color 4 = down). The grid contains no other non-background
elements, and boundaries are defined by the grid edges. The output grid must
reflect the positions of all elements after a single step of movement, governed
by these synchronized rules:    1. Each element moves one cell in its current
direction.   2. Upon reaching a grid boundary, the element reverses direction
immediately.   3. If two elements move into the same cell (collision), both
reverse their directions *before* proceeding.   4. Direction reversals due to
collisions or boundaries must be applied *simultaneously* across all elements.
5. Topological invariance requires the relative adjacency and sequence of
elements to be preserved in the output; elements must maintain their
connectivity (e.g., if elements A-B-C were contiguous left-to-right in the
input, they must remain contiguous in the output, though their order may reverse
due to directional changes).    The transformation is deterministic but requires
sequential resolution of collisions and boundary interactions. For example, if
two elements collide while moving toward each other, both reverse direction,
effectively swapping their positions and directions. Elements moving upward or
downward would exit the grid vertically, but the task focuses on horizontal
movement to maintain topological consistency. The output grid must show all
elements within valid grid boundaries, with no overlapping or missing cells in
the sequence. This task demands precise simulation of multi-element dynamics
while enforcing structural invariance, making it extremely challenging to
generalize from limited input-output examples.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import defaultdict

def simulate_step_row(width, positions, colors):
    # positions: list of column indices (sorted ascending)
    # colors: list of colors corresponding to positions
    # width: grid width
    n = len(positions)
    # directions by parity: odd->right(+1), even->left(-1)
    dirs = [1 if c % 2 == 1 else -1 for c in colors]

    final_pos = [None] * n
    final_dir = [None] * n
    unresolved = set(range(n))

    # cap iterations to ensure termination
    for _iter in range(n * 4 + 10):
        if not unresolved:
            break
        changed = False

        # Step 1: boundary flips
        for i in list(unresolved):
            t = positions[i] + dirs[i]
            if t < 0 or t >= width:
                dirs[i] = -dirs[i]
                changed = True

        # Step 2: detect swap (head-on) collisions among unresolved
        # Only adjacent positions can swap in a contiguous block
        # We'll scan unresolved indices in order
        unresolved_sorted = sorted(unresolved)
        to_resolve = set()
        for idx in range(len(unresolved_sorted) - 1):
            i = unresolved_sorted[idx]
            j = unresolved_sorted[idx + 1]
            # ensure they are adjacent cells
            if positions[j] != positions[i] + 1:
                continue
            # compute tentative targets
            ti = positions[i] + dirs[i]
            tj = positions[j] + dirs[j]
            # detect head-on crossing (each intends to move into the other's cell)
            if ti == positions[j] and tj == positions[i]:
                # swap positions and reverse directions as per task description
                final_pos[i] = positions[j]
                final_dir[i] = -dirs[i]
                final_pos[j] = positions[i]
                final_dir[j] = -dirs[j]
                to_resolve.add(i)
                to_resolve.add(j)
                changed = True
        # remove resolved swap pairs from unresolved
        for i in to_resolve:
            if i in unresolved:
                unresolved.remove(i)

        # Step 3: for remaining unresolved, compute tentative targets and detect collisions
        # Recompute targets
        targets = defaultdict(list)
        for i in list(unresolved):
            t = positions[i] + dirs[i]
            targets[t].append(i)

        # If any target already occupied by a resolved final_pos, those unresolved must flip
        occupied_targets = set([p for p in final_pos if p is not None])
        for t, idxs in list(targets.items()):
            if t in occupied_targets:
                # any unresolved trying to move into already-reserved cell collides and must flip
                for i in idxs:
                    dirs[i] = -dirs[i]
                    changed = True
                # will recompute targets next iteration
                continue

        # Multi-target collisions
        for t, idxs in list(targets.items()):
            if len(idxs) > 1:
                # all participants reverse direction and will try opposite in next iteration
                for i in idxs:
                    dirs[i] = -dirs[i]
                    changed = True
                # will recompute next iteration

        # Assign unique targets (no collisions and not reserved)
        # Rebuild targets after above flips because some dirs changed
        if changed:
            # restart loop to re-evaluate with updated dirs
            continue

        # Now no candidate collisions remain, finalize remaining unresolved
        # recompute targets
        targets = defaultdict(list)
        for i in list(unresolved):
            t = positions[i] + dirs[i]
            targets[t].append(i)

        # Final assignment for all targets (these should be singletons and not in occupied)
        for t, idxs in targets.items():
            # if somehow t in occupied_targets, handle by flipping (fallback)
            if t in occupied_targets:
                for i in idxs:
                    dirs[i] = -dirs[i]
                # we'll go another iteration
                changed = True
                break
            if len(idxs) == 1:
                i = idxs[0]
                final_pos[i] = t
                final_dir[i] = dirs[i]
                unresolved.remove(i)
            else:
                # shouldn't happen here, but flip directions as fallback
                for i in idxs:
                    dirs[i] = -dirs[i]
                changed = True
                break
        if changed:
            continue
        # if nothing changed and unresolved remains, break to avoid infinite loop
        if not changed:
            break

    # After loop, some unresolved may remain due to pathological interactions
    if unresolved:
        # fallback deterministic placement: keep relative order, place them contiguously
        # find minimal available positions within grid to place contiguous block of size len(unresolved)
        # We'll preserve the relative order of unresolved as they appeared left-to-right or reversed based on majority direction
        remaining = sorted(list(unresolved), key=lambda i: positions[i])
        # choose starting position as min available position among reserved region or original min
        assigned = set([p for p in final_pos if p is not None])
        all_positions = set(range(width))
        free_positions = sorted(list(all_positions - assigned))
        # try to find a contiguous run of length len(remaining) in free_positions
        run_length = len(remaining)
        start_choice = None
        # search all possible starts
        for s in range(0, width - run_length + 1):
            run = list(range(s, s + run_length))
            if all(x in free_positions for x in run):
                start_choice = s
                break
        if start_choice is None:
            # place them at their original positions that are free or nearest free
            for i in remaining:
                # find nearest free position to original
                orig = positions[i]
                # find free pos by minimal distance
                best = min(free_positions, key=lambda x: abs(x - orig)) if free_positions else None
                if best is None:
                    # no free pos, overwrite something (shouldn't happen)
                    best = positions[i]
                final_pos[i] = best
                final_dir[i] = -dirs[i]
                if best in free_positions:
                    free_positions.remove(best)
        else:
            # assign contiguous run keeping left-to-right order
            for k, i in enumerate(remaining):
                final_pos[i] = start_choice + k
                final_dir[i] = dirs[i]

    # Build resulting arrays of colors placed at final_pos
    result = {}
    for i in range(n):
        p = final_pos[i]
        if p is None:
            # as last resort place at original position
            p = positions[i]
        result[p] = (colors[i], final_dir[i] if final_dir[i] is not None else dirs[i])
    # prepare ordered lists by positions
    final_positions = sorted(result.keys())
    final_colors = [result[p][0] for p in final_positions]
    final_dirs = [result[p][1] for p in final_positions]
    return final_positions, final_colors, final_dirs


def generate():
    # produce a contiguous block of unique colored elements on a single row
    width = random.randint(6, 20)
    height = random.randint(1, 4)
    row = random.randint(0, height - 1)

    # number of elements
    max_elements = min(7, width - 2)
    n = random.randint(3, max_elements)

    # choose starting column so block fits
    start = random.randint(0, width - n)

    # unique colors
    colors = random.sample(list(range(1, 10)), n)

    # create input grid
    grid_in = [[0 for _ in range(width)] for _ in range(height)]
    positions = []
    for k in range(n):
        c = start + k
        grid_in[row][c] = colors[k]
        positions.append(c)

    # compute output using same simulation
    final_positions, final_colors, final_dirs = simulate_step_row(width, positions, colors)

    grid_out = [[0 for _ in range(width)] for _ in range(height)]
    for p, col in zip(final_positions, final_colors):
        grid_out[row][p] = col

    # avoid trivial identity
    if grid_in == grid_out:
        return generate()

    return {"input": grid_in, "output": grid_out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import defaultdict

def simulate_step_row(width, positions, colors):
    n = len(positions)
    dirs = [1 if c % 2 == 1 else -1 for c in colors]

    final_pos = [None] * n
    final_dir = [None] * n
    unresolved = set(range(n))

    for _iter in range(n * 4 + 10):
        if not unresolved:
            break
        changed = False

        # Step 1: boundary flips
        for i in list(unresolved):
            t = positions[i] + dirs[i]
            if t < 0 or t >= width:
                dirs[i] = -dirs[i]
                changed = True

        # Step 2: detect swap (head-on) collisions among unresolved
        unresolved_sorted = sorted(unresolved)
        to_resolve = set()
        for idx in range(len(unresolved_sorted) - 1):
            i = unresolved_sorted[idx]
            j = unresolved_sorted[idx + 1]
            if positions[j] != positions[i] + 1:
                continue
            ti = positions[i] + dirs[i]
            tj = positions[j] + dirs[j]
            if ti == positions[j] and tj == positions[i]:
                final_pos[i] = positions[j]
                final_dir[i] = -dirs[i]
                final_pos[j] = positions[i]
                final_dir[j] = -dirs[j]
                to_resolve.add(i)
                to_resolve.add(j)
                changed = True
        for i in to_resolve:
            if i in unresolved:
                unresolved.remove(i)

        # Step 3: detect other collisions and assign unique targets
        targets = defaultdict(list)
        for i in list(unresolved):
            t = positions[i] + dirs[i]
            targets[t].append(i)

        occupied_targets = set([p for p in final_pos if p is not None])
        for t, idxs in list(targets.items()):
            if t in occupied_targets:
                for i in idxs:
                    dirs[i] = -dirs[i]
                    changed = True
                continue

        for t, idxs in list(targets.items()):
            if len(idxs) > 1:
                for i in idxs:
                    dirs[i] = -dirs[i]
                    changed = True

        if changed:
            continue

        # finalize remaining unresolved
        targets = defaultdict(list)
        for i in list(unresolved):
            t = positions[i] + dirs[i]
            targets[t].append(i)

        for t, idxs in targets.items():
            if t in occupied_targets:
                for i in idxs:
                    dirs[i] = -dirs[i]
                changed = True
                break
            if len(idxs) == 1:
                i = idxs[0]
                final_pos[i] = t
                final_dir[i] = dirs[i]
                unresolved.remove(i)
            else:
                for i in idxs:
                    dirs[i] = -dirs[i]
                changed = True
                break
        if changed:
            continue
        if not changed:
            break

    if unresolved:
        remaining = sorted(list(unresolved), key=lambda i: positions[i])
        assigned = set([p for p in final_pos if p is not None])
        all_positions = set(range(width))
        free_positions = sorted(list(all_positions - assigned))
        run_length = len(remaining)
        start_choice = None
        for s in range(0, width - run_length + 1):
            run = list(range(s, s + run_length))
            if all(x in free_positions for x in run):
                start_choice = s
                break
        if start_choice is None:
            for i in remaining:
                orig = positions[i]
                if free_positions:
                    best = min(free_positions, key=lambda x: abs(x - orig))
                    final_pos[i] = best
                    final_dir[i] = -dirs[i]
                    free_positions.remove(best)
                else:
                    final_pos[i] = positions[i]
                    final_dir[i] = -dirs[i]
        else:
            for k, i in enumerate(remaining):
                final_pos[i] = start_choice + k
                final_dir[i] = dirs[i]

    result = {}
    for i in range(n):
        p = final_pos[i]
        if p is None:
            p = positions[i]
        result[p] = (colors[i], final_dir[i] if final_dir[i] is not None else dirs[i])
    final_positions = sorted(result.keys())
    final_colors = [result[p][0] for p in final_positions]
    final_dirs = [result[p][1] for p in final_positions]
    return final_positions, final_colors, final_dirs


def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # find the single row that contains elements
    rows_with_elements = [r for r in range(height) if any(grid[r][c] != 0 for c in range(width))]
    if not rows_with_elements:
        return tuple(tuple(row) for row in grid)
    row = rows_with_elements[0]

    positions = []
    colors = []
    for c in range(width):
        if grid[row][c] != 0:
            positions.append(c)
            colors.append(grid[row][c])

    if not positions:
        return tuple(tuple(row) for row in grid)

    final_positions, final_colors, final_dirs = simulate_step_row(width, positions, colors)

    out = [[0 for _ in range(width)] for _ in range(height)]
    for ppos, col in zip(final_positions, final_colors):
        out[row][ppos] = col

    return tuple(tuple(r) for r in out)

