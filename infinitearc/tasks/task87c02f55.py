# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 87c02f55
Difficulty: hard

=== Tags ===
- Propagation by rule weight
- Connect the dots
- Multi condition recolor
- Copy paste patch

=== Description ===
# Rule-Weighted Path Network  Input grids feature a uniform background (color 0)
with multiple distinct source nodes (colors 1-5) positioned at various
locations. A dedicated rule matrix (a 3×3 subgrid in the bottom-right corner)
contains color-coded weights (1-9), where each weight value corresponds to a
specific movement direction (1=right, 2=up, 3=left, 4=down, with weights 5-9
cycling through these directions sequentially). A top-left pattern strip (2×2
grid) defines a cyclic color sequence used for path coloring. The grid also
contains non-walkable "obstacles" (color 9) that must be avoided during path
construction.  The output grid must connect all source nodes into a single
continuous path network through the following rules: 1. Paths propagate from
each source cell following the rule matrix's directional weights, moving one
cell per step. When moving into the rule matrix, direction is determined by the
weight's value. 2. Path segments sequentially cycle through the pattern strip's
colors (e.g., if the strip is [2,4,5,4], segments use colors 2→4→5→4→2→4→...).
3. When multiple paths would occupy the same cell, the path with the higher
weight value (from the rule matrix) takes precedence, recoloring the cell
according to its current position in the pattern cycle. 4. Any path segment
overlapping a rule matrix cell must match the cell's color in the output. 5. A
copy of the pattern strip (the 2×2 block) is pasted to the bottom-right corner
of the output grid as a visual reference, maintaining its original color
arrangement.  All paths must connect sources without crossing, follow
directional rules from the matrix, and dynamically recolor based on the pattern
cycle and weight interactions. The solution requires tracking multiple path
states simultaneously while respecting the rule matrix's directional constraints
and pattern cycle progression.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    """
    Generator for the rule-weighted path network task.
    Creates a square grid (12-18) with:
      - a 2x2 pattern strip in the top-left (colors 6-8)
      - a 3x3 rule matrix in the bottom-right (weights 6-8 stored as colors)
      - 3 or 4 sources placed on different sides and assigned colors that map to directions
      - random obstacles (color 9) avoiding source corridors and reserved areas
    Then simulates path propagation from the sources using the described rules and
    returns both the input and the computed output (with the pattern strip copied to
    the bottom-right corner of the output).
    """
    # grid size
    size = random.randint(12, 18)
    height = width = size

    # initialize input grid with background 0
    grid_in = [[0 for _ in range(width)] for _ in range(height)]

    # create pattern strip (2x2) at top-left. Use colors (6..8) to avoid confusion with sources 1..5
    pattern_strip = [[random.randint(6, 8) for _ in range(2)] for _ in range(2)]
    for r in range(2):
        for c in range(2):
            grid_in[r][c] = pattern_strip[r][c]

    # create 3x3 rule matrix (bottom-right). Use weights/colors (6..8) to avoid collision with source colors.
    rule_matrix = [[random.randint(6, 8) for _ in range(3)] for _ in range(3)]
    for r in range(3):
        for c in range(3):
            grid_in[height - 3 + r][width - 3 + c] = rule_matrix[r][c]

    # center coordinates
    center_r = height // 2
    center_c = width // 2

    # choose number of sources and sides
    num_sources = random.choice([3, 4])
    sides = random.sample(["left", "right", "top", "bottom"], k=num_sources)

    # helper to clamp ranges
    def clamp_range(a, b):
        if a > b:
            return (b, b)
        return (a, b)

    # place sources at strategic positions so they will move toward the center
    sources = []  # list of (r, c, color)
    for side in sides:
        if side == "left":
            r = center_r
            c_min, c_max = clamp_range(2, max(2, center_c - 2))
            c = random.randint(c_min, c_max)
            color = 1  # (1 -> right)
        elif side == "right":
            r = center_r
            c_min, c_max = clamp_range(min(center_c + 2, width - 4), width - 4)
            c = random.randint(c_min, c_max)
            color = 3  # (3 -> left)
        elif side == "top":
            c = center_c
            r_min, r_max = clamp_range(2, max(2, center_r - 2))
            r = random.randint(r_min, r_max)
            color = 4  # (4 -> down)
        else:  # bottom
            c = center_c
            r_min, r_max = clamp_range(min(center_r + 2, height - 4), height - 4)
            r = random.randint(r_min, r_max)
            color = 2  # (2 -> up)

        # if chosen cell is occupied (very unlikely), find the nearest free cell in the safe region
        if grid_in[r][c] != 0:
            placed = False
            for rr in range(2, height - 3):
                if placed: break
                for cc in range(2, width - 3):
                    if grid_in[rr][cc] == 0:
                        r, c = rr, cc
                        placed = True
                        break
        grid_in[r][c] = color
        sources.append((r, c, color))

    # mark reserved cells that must not receive obstacles
    reserved = set()
    # top-left 2x2 (pattern)
    for rr in range(2):
        for cc in range(2):
            reserved.add((rr, cc))
    # bottom-right 3x3 (rule matrix)
    for rr in range(height - 3, height):
        for cc in range(width - 3, width):
            reserved.add((rr, cc))
    # keep source positions and straight corridors to center free of obstacles
    for (sr, sc, col) in sources:
        reserved.add((sr, sc))
        if sr == center_r:
            for cc in range(min(sc, center_c), max(sc, center_c) + 1):
                reserved.add((sr, cc))
        if sc == center_c:
            for rr in range(min(sr, center_r), max(sr, center_r) + 1):
                reserved.add((rr, sc))

    # place obstacles (color 9) avoiding reserved cells
    obstacle_candidates = []
    for rr in range(height):
        for cc in range(width):
            if (rr, cc) in reserved:  # don't place obstacles on reserved cells
                continue
            if grid_in[rr][cc] != 0:
                continue
            obstacle_candidates.append((rr, cc))
    random.shuffle(obstacle_candidates)
    obstacle_count = random.randint(12, 22)
    for i in range(min(obstacle_count, len(obstacle_candidates))):
        r, c = obstacle_candidates[i]
        grid_in[r][c] = 9

    # prepare the output starting from the input layout
    out = [row[:] for row in grid_in]

    # weight matrix stores the 'current weight' that occupies each cell (used for precedence)
    weight_mat = [[None for _ in range(width)] for _ in range(height)]
    # initialize weights for sources and rule cells
    for (sr, sc, col) in sources:
        weight_mat[sr][sc] = col
    for rr in range(height - 3, height):
        for cc in range(width - 3, width):
            weight_mat[rr][cc] = grid_in[rr][cc]

    # flatten pattern sequence row-major for cycling
    pattern_seq = [pattern_strip[0][0], pattern_strip[0][1], pattern_strip[1][0], pattern_strip[1][1]]

    # direction mapping: 0=right,1=up,2=left,3=down
    dirs = [(0, 1), (-1, 0), (0, -1), (1, 0)]

    # sort sources by coordinates so generator and solver will use the same deterministic order
    sources_sorted = sorted(sources, key=lambda x: (x[0], x[1]))

    max_steps = (width + height) * 3

    # simulate paths
    for (sr, sc, col) in sources_sorted:
        cur_r, cur_c = sr, sc
        weight = col
        dir_idx = (weight - 1) % 4
        color_idx = 0
        visited = set()
        for _ in range(max_steps):
            dr, dc = dirs[dir_idx]
            nr, nc = cur_r + dr, cur_c + dc
            # boundary check
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                break
            # do not invade the top-left pattern strip
            if nr < 2 and nc < 2:
                break
            # obstacle check
            if grid_in[nr][nc] == 9:
                break
            # if we're stepping into the rule matrix area, update weight and direction
            if nr >= height - 3 and nc >= width - 3:
                weight = grid_in[nr][nc]
                weight_mat[nr][nc] = weight
                out[nr][nc] = grid_in[nr][nc]
                dir_idx = (weight - 1) % 4
                cur_r, cur_c = nr, nc
                if (nr, nc) in visited:
                    break
                visited.add((nr, nc))
                continue
            # if next is a source, connect and stop (do not overwrite the source)
            if 1 <= out[nr][nc] <= 5:
                break
            occ = out[nr][nc]
            occ_weight = weight_mat[nr][nc] if weight_mat[nr][nc] is not None else 0
            new_color = pattern_seq[color_idx % 4]
            if occ == 0:
                out[nr][nc] = new_color
                weight_mat[nr][nc] = weight
                cur_r, cur_c = nr, nc
                color_idx += 1
                if (nr, nc) in visited:
                    break
                visited.add((nr, nc))
                continue
            else:
                # conflict: allow overwrite only if current path's weight is strictly greater
                if weight > occ_weight:
                    out[nr][nc] = new_color
                    weight_mat[nr][nc] = weight
                    cur_r, cur_c = nr, nc
                    color_idx += 1
                    if (nr, nc) in visited:
                        break
                    visited.add((nr, nc))
                    continue
                else:
                    break

    # finally copy the pattern strip to bottom-right corner of the output
    for r in range(2):
        for c in range(2):
            out[height - 2 + r][width - 2 + c] = pattern_strip[r][c]

    # ensure the output differs from the input (guarantee rule)
    if out == grid_in:
        out[2][2] = pattern_seq[0]

    return {'input': [row[:] for row in grid_in], 'output': [row[:] for row in out]}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])

    # Extract pattern strip (top-left 2x2)
    pattern_strip = [[grid_in[0][0], grid_in[0][1]], [grid_in[1][0], grid_in[1][1]]]
    pattern_seq = [pattern_strip[0][0], pattern_strip[0][1], pattern_strip[1][0], pattern_strip[1][1]]

    # Extract rule matrix from bottom-right 3x3
    rule_matrix = [[grid_in[height - 3 + r][width - 3 + c] for c in range(3)] for r in range(3)]

    # Find sources (colors 1-5) but ignore pattern/top-left and rule/bottom-right areas
    sources = []
    for r in range(height):
        for c in range(width):
            val = grid_in[r][c]
            # ignore top-left pattern and bottom-right rule matrix area
            if (r < 2 and c < 2) or (r >= height - 3 and c >= width - 3):
                continue
            if 1 <= val <= 5:
                sources.append((r, c, val))

    # Prepare output as a copy of input
    out = [row[:] for row in grid_in]

    # weight matrix for precedence
    weight_mat = [[None for _ in range(width)] for _ in range(height)]

    # Initialize weights for sources and rule area
    for (sr, sc, col) in sources:
        weight_mat[sr][sc] = col
    for r in range(height - 3, height):
        for c in range(width - 3, width):
            weight_mat[r][c] = grid_in[r][c]

    # directions mapping
    dirs = [(0, 1), (-1, 0), (0, -1), (1, 0)]  # right, up, left, down

    # sort sources to have a deterministic order that matches the generator
    sources_sorted = sorted(sources, key=lambda x: (x[0], x[1]))

    max_steps = (width + height) * 3

    # Simulate paths using the same rules as generator
    for (sr, sc, col) in sources_sorted:
        cur_r, cur_c = sr, sc
        weight = col
        dir_idx = (weight - 1) % 4
        color_idx = 0
        visited = set()
        for _ in range(max_steps):
            dr, dc = dirs[dir_idx]
            nr, nc = cur_r + dr, cur_c + dc
            # boundary
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                break
            # do not enter top-left pattern
            if nr < 2 and nc < 2:
                break
            # obstacle
            if grid_in[nr][nc] == 9:
                break
            # rule matrix area: update weight and direction
            if nr >= height - 3 and nc >= width - 3:
                weight = grid_in[nr][nc]
                weight_mat[nr][nc] = weight
                out[nr][nc] = grid_in[nr][nc]
                dir_idx = (weight - 1) % 4
                cur_r, cur_c = nr, nc
                if (nr, nc) in visited:
                    break
                visited.add((nr, nc))
                continue
            # connecting to a source stops (do not overwrite)
            if 1 <= out[nr][nc] <= 5:
                break
            occ = out[nr][nc]
            occ_weight = weight_mat[nr][nc] if weight_mat[nr][nc] is not None else 0
            new_color = pattern_seq[color_idx % 4]
            if occ == 0:
                out[nr][nc] = new_color
                weight_mat[nr][nc] = weight
                cur_r, cur_c = nr, nc
                color_idx += 1
                if (nr, nc) in visited:
                    break
                visited.add((nr, nc))
                continue
            else:
                if weight > occ_weight:
                    out[nr][nc] = new_color
                    weight_mat[nr][nc] = weight
                    cur_r, cur_c = nr, nc
                    color_idx += 1
                    if (nr, nc) in visited:
                        break
                    visited.add((nr, nc))
                    continue
                else:
                    break

    # paste pattern strip to bottom-right of the output
    for r in range(2):
        for c in range(2):
            out[height - 2 + r][width - 2 + c] = pattern_strip[r][c]

    # ensure the output differs from the input (same fallback as generator)
    if out == grid_in:
        out[2][2] = pattern_seq[0]

    # return as tuple of tuples
    return tuple(tuple(row) for row in out)
