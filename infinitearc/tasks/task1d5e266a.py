# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 1d5e266a
Difficulty: easy

=== Tags ===
- Color by distance to center
- Recolor smallest component

=== Description ===
The task involves transforming an input grid into an output grid through two
primary steps. First, each cell in the output grid is colored based on its
Manhattan distance to the grid's center (closer cells to the center use one
color, farther cells use another). Second, the smallest connected component (by
area, considering 4-directional connectivity) in the input grid—defined as the
smallest region of contiguous cells sharing the same color—is identified. All
cells within this smallest component in the output grid are then recolored to a
fixed color (e.g., gray, color 5), overriding the distance-based color. The
transformation is deterministic, visually intuitive, and requires only basic
spatial reasoning about distance and component size, making it suitable for an
"easy" difficulty level.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    H = random.randint(1, 30)
    W = random.randint(1, 30)
    while True:
        input_grid = [[random.randint(0, 9) for _ in range(W)] for _ in range(H)]
        if len(set(cell for row in input_grid for cell in row)) > 1:
            break
    visited = [[False] * W for _ in range(H)]
    components = []
    for r in range(H):
        for c in range(W):
            if not visited[r][c]:
                color = input_grid[r][c]
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                components.append((color, component))
    smallest_component = min(components, key=lambda x: len(x[1]))
    center_r = (H - 1) / 2.0
    center_c = (W - 1) / 2.0
    max_distance = 0
    for r in range(H):
        for c in range(W):
            distance = abs(r - center_r) + abs(c - center_c)
            if distance > max_distance:
                max_distance = distance
    threshold = max_distance // 2
    output_grid = [[0] * W for _ in range(H)]
    for r in range(H):
        for c in range(W):
            distance = abs(r - center_r) + abs(c - center_c)
            if distance <= threshold:
                output_grid[r][c] = 1
            else:
                output_grid[r][c] = 2
    _, positions = smallest_component
    for (r, c) in positions:
        output_grid[r][c] = 5
    while input_grid == output_grid:
        while True:
            input_grid = [[random.randint(0, 9) for _ in range(W)] for _ in range(H)]
            if len(set(cell for row in input_grid for cell in row)) > 1:
                break
        visited = [[False] * W for _ in range(H)]
        components = []
        for r in range(H):
            for c in range(W):
                if not visited[r][c]:
                    color = input_grid[r][c]
                    component = []
                    queue = [(r, c)]
                    visited[r][c] = True
                    while queue:
                        cr, cc = queue.pop(0)
                        component.append((cr, cc))
                        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc] and input_grid[nr][nc] == color:
                                visited[nr][nc] = True
                                queue.append((nr, nc))
                    components.append((color, component))
        smallest_component = min(components, key=lambda x: len(x[1]))
        center_r = (H - 1) / 2.0
        center_c = (W - 1) / 2.0
        max_distance = 0
        for r in range(H):
            for c in range(W):
                distance = abs(r - center_r) + abs(c - center_c)
                if distance > max_distance:
                    max_distance = distance
        threshold = max_distance // 2
        output_grid = [[0] * W for _ in range(H)]
        for r in range(H):
            for c in range(W):
                distance = abs(r - center_r) + abs(c - center_c)
                if distance <= threshold:
                    output_grid[r][c] = 1
                else:
                    output_grid[r][c] = 2
        _, positions = smallest_component
        for (r, c) in positions:
            output_grid[r][c] = 5
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    H = len(input_grid)
    W = len(input_grid[0])
    visited = [[False] * W for _ in range(H)]
    components = []
    for r in range(H):
        for c in range(W):
            if not visited[r][c]:
                color = input_grid[r][c]
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                components.append((color, component))
    smallest_component = min(components, key=lambda x: len(x[1]))
    center_r = (H - 1) / 2.0
    center_c = (W - 1) / 2.0
    max_distance = 0
    for r in range(H):
        for c in range(W):
            distance = abs(r - center_r) + abs(c - center_c)
            if distance > max_distance:
                max_distance = distance
    threshold = max_distance // 2
    output_grid = [[0] * W for _ in range(H)]
    for r in range(H):
        for c in range(W):
            distance = abs(r - center_r) + abs(c - center_c)
            if distance <= threshold:
                output_grid[r][c] = 1
            else:
                output_grid[r][c] = 2
    _, positions = smallest_component
    for (r, c) in positions:
        output_grid[r][c] = 5
    return output_grid
