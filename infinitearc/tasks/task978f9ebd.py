# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 978f9ebd
Difficulty: insane

=== Tags ===
- Non rectangular tiling
- Background filling
- Algebra

=== Description ===
# Non Rectangular Tiling with Algebraic Background Filling  Input grids are
15×15 to 30×30 in size, featuring a single background color (0) with multiple
non-rectangular colored tiles. Each tile is a connected region of identical
color (1-9) that forms a non-rectangular shape (e.g., L-shaped, T-shaped, or
other irregular polygons that cannot be bounded by a rectangle with all cells
filled). Tiles are fully surrounded by background color, do not overlap, and are
placed such that no two tiles of the same color are adjacent.  The
transformation involves multiple sequential steps: 1. Identify all tiles
(connected components of same color that form non-rectangular shapes) in the
input grid. 2. For each row i, calculate row_count[i] as the number of distinct
tiles that have at least one cell in that row. 3. For each column j, calculate
col_count[j] as the number of distinct tiles that have at least one cell in that
column. 4. For every background cell (i,j) (where input[i][j] = 0), compute the
output color as (row_count[i] × col_count[j]) mod 10. 5. All tile cells remain
unchanged in the output grid, while the background is filled according to the
algebraic rule.  The output grid maintains all tile positions and colors exactly
as in the input, with the background color replaced by the computed values. The
algebraic rule ensures that background colors follow a consistent mathematical
pattern based on the spatial distribution of the non-rectangular tiles, creating
a visually complex pattern that requires understanding both the tile geometry
and the algebraic relationship between row and column tile counts.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def is_rectangular(pixels):
    if not pixels:
        return False
    rows = [p[0] for p in pixels]
    cols = [p[1] for p in pixels]
    min_r, max_r = min(rows), max(rows)
    min_c, max_c = min(cols), max(cols)
    bbox_area = (max_r - min_r + 1) * (max_c - min_c + 1)
    return len(pixels) == bbox_area

def generate():
    while True:
        width = random.randint(15, 30)
        height = random.randint(15, 30)
        grid = [[0] * width for _ in range(height)]
        num_tiles = random.randint(3, 6)
        colors = random.sample(range(1, 10), num_tiles)
        tiles = []
        
        for color in colors:
            while True:
                size = random.randint(3, 5)
                pixels = common.continuous_creature(size, width=10, height=10)
                if not is_rectangular(pixels):
                    break
            
            shift_r = random.randint(0, height - 1)
            shift_c = random.randint(0, width - 1)
            shifted_pixels = []
            for r, c in pixels:
                new_r = r + shift_r
                new_c = c + shift_c
                if 0 <= new_r < height and 0 <= new_c < width:
                    shifted_pixels.append((new_r, new_c))
            
            valid_placement = True
            for r, c in shifted_pixels:
                if grid[r][c] != 0:
                    valid_placement = False
                    break
            if not valid_placement:
                continue
            
            for r, c in shifted_pixels:
                grid[r][c] = color
            tiles.append((color, shifted_pixels))
        
        row_colors = [set() for _ in range(height)]
        col_colors = [set() for _ in range(width)]
        for color, pixels in tiles:
            for r, c in pixels:
                row_colors[r].add(color)
                col_colors[c].add(color)
        
        row_count = [len(row_colors[r]) for r in range(height)]
        col_count = [len(col_colors[c]) for c in range(width)]
        
        output = [[0] * width for _ in range(height)]
        for r in range(height):
            for c in range(width):
                if grid[r][c] != 0:
                    output[r][c] = grid[r][c]
                else:
                    output[r][c] = (row_count[r] * col_count[c]) % 10
        
        if grid != output:
            return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    
    row_colors = [set() for _ in range(height)]
    col_colors = [set() for _ in range(width)]
    
    for r in range(height):
        for c in range(width):
            color = input_grid[r][c]
            if color != 0:
                row_colors[r].add(color)
                col_colors[c].add(color)
    
    row_count = [len(row_colors[r]) for r in range(height)]
    col_count = [len(col_colors[c]) for c in range(width)]
    
    output = []
    for r in range(height):
        row = []
        for c in range(width):
            if input_grid[r][c] != 0:
                row.append(input_grid[r][c])
            else:
                row.append((row_count[r] * col_count[c]) % 10)
        output.append(row)
    
    return output
