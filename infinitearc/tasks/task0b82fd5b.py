# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 0b82fd5b
Difficulty: hard

=== Tags ===
- Pattern rotation
- Image rotation
- Summarize
- Mimic pattern

=== Description ===
The input grid contains a dominant pattern represented by the largest connected
component (identified via 4-directional connectivity). The output grid is formed
by rotating this dominant pattern 90 degrees clockwise and placing it in the
top-left corner of the grid, with all other cells set to 0. The rotation is
applied to the pattern's bounding box, preserving its relative structure, and
the output grid maintains the same dimensions as the input. This transformation
requires identifying the largest pattern, performing a consistent rotation, and
summarizing the grid to retain only the rotated pattern, mimicking its
orientation in the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(2, 30)
    height = random.randint(3, 30)
    grid = [[0] * width for _ in range(height)]
    r_size, c_size = 3, 2
    r_start = random.randint(0, height - r_size)
    c_start = random.randint(0, width - c_size)
    for r in range(r_start, r_start + r_size):
        for c in range(c_start, c_start + c_size):
            grid[r][c] = 1
    for _ in range(random.randint(1, 5)):
        r = random.randint(0, height - 1)
        c = random.randint(0, width - 1)
        if grid[r][c] == 0:
            grid[r][c] = random.randint(2, 9)
    visited = [[False] * width for _ in range(height)]
    components = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and not visited[r][c]:
                component = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == grid[r][c]:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append(component)
    largest = max(components, key=len)
    rows = [p[0] for p in largest]
    cols = [p[1] for p in largest]
    r_min, r_max = min(rows), max(rows)
    c_min, c_max = min(cols), max(cols)
    bbox = [grid[r][c_min:c_max+1] for r in range(r_min, r_max+1)]
    rotated_bbox = [list(x) for x in zip(*bbox[::-1])]
    output = [[0] * width for _ in range(height)]
    for r in range(len(rotated_bbox)):
        for c in range(len(rotated_bbox[0])):
            if r < height and c < width:
                output[r][c] = rotated_bbox[r][c]
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0]) if height > 0 else 0
    if height == 0 or width == 0:
        return []
    visited = [[False] * width for _ in range(height)]
    components = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                component = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == input_grid[r][c]:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append(component)
    if not components:
        return [[0] * width for _ in range(height)]
    largest = max(components, key=len)
    rows = [p[0] for p in largest]
    cols = [p[1] for p in largest]
    r_min, r_max = min(rows), max(rows)
    c_min, c_max = min(cols), max(cols)
    bbox = [input_grid[r][c_min:c_max+1] for r in range(r_min, r_max+1)]
    rotated_bbox = [list(x) for x in zip(*bbox[::-1])]
    output = [[0] * width for _ in range(height)]
    for r in range(len(rotated_bbox)):
        for c in range(len(rotated_bbox[0])):
            if r < height and c < width:
                output[r][c] = rotated_bbox[r][c]
    return output
