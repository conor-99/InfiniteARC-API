# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 60a843cb
Difficulty: hard

=== Tags ===
- Pattern activation
- Detect symmetry
- Color particle fall
- Rule priority resolution
- Dominant color

=== Description ===
Input grids are 20×20 to 30×30 with a background color (0) and multiple
connected regions of single non-zero colors (1-9). Each region is a 4-connected
group of identical colors. The grid may exhibit vertical or horizontal symmetry
(mirror symmetry across a central axis), though this symmetry may be subtly
broken in regions. The dominant color is defined as the most frequent non-zero
color across the entire grid.  In the output grid, each non-zero cell moves in a
direction determined by a priority-resolved rule system: 1. **Symmetry
Detection**: If the entire grid is vertically symmetric (left-right mirror), all
cells fall downward (south) until blocked by another non-zero cell or grid
boundary. 2. **Symmetry Detection**: If horizontally symmetric (top-bottom
mirror), all cells fall rightward (east). 3. **Dominant Color**: If no symmetry
exists, cells fall right if the dominant color is even (2,4,6,8), left if odd
(1,3,5,7,9).  Movement follows these rules: - All cells move simultaneously in
their determined direction. - Cells fall until they encounter a non-zero cell or
grid edge. - Background cells (0) remain unchanged during movement. - The final
configuration preserves all original cell counts, only relocating non-zero
cells. - Symmetry detection takes absolute priority over dominant color,
requiring careful visual analysis to distinguish subtle symmetry breaks (e.g.,
one misplaced cell disrupting vertical symmetry).
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def fall_south(grid):
    H = len(grid)
    W = len(grid[0])
    output = [[0] * W for _ in range(H)]
    for c in range(W):
        non_zeros = [grid[r][c] for r in range(H) if grid[r][c] != 0]
        for r in range(H - len(non_zeros), H):
            output[r][c] = non_zeros[r - (H - len(non_zeros))]
    return output

def fall_east(grid):
    H = len(grid)
    W = len(grid[0])
    output = [[0] * W for _ in range(H)]
    for r in range(H):
        non_zeros = [grid[r][c] for c in range(W) if grid[r][c] != 0]
        for c in range(W - len(non_zeros), W):
            output[r][c] = non_zeros[c - (W - len(non_zeros))]
    return output

def fall_west(grid):
    H = len(grid)
    W = len(grid[0])
    output = [[0] * W for _ in range(H)]
    for r in range(H):
        non_zeros = [grid[r][c] for c in range(W) if grid[r][c] != 0]
        for c in range(len(non_zeros)):
            output[r][c] = non_zeros[c]
    return output

def is_vertical_symmetric(grid):
    H = len(grid)
    W = len(grid[0])
    for r in range(H):
        for c in range(W // 2):
            if grid[r][c] != grid[r][W - 1 - c]:
                return False
    return True

def is_horizontal_symmetric(grid):
    H = len(grid)
    W = len(grid[0])
    for c in range(W):
        for r in range(H // 2):
            if grid[r][c] != grid[H - 1 - r][c]:
                return False
    return True

def generate():
    H = random.randint(20, 30)
    W = random.randint(20, 30)
    case = random.choice([0, 1, 2])
    input_grid = [[0] * W for _ in range(H)]
    
    if case == 0:
        for r in range(H):
            for c in range(W // 2):
                if random.random() > 0.5:
                    input_grid[r][c] = random.randint(1, 9)
            for c in range(W // 2, W):
                input_grid[r][c] = input_grid[r][W - 1 - c]
        output_grid = fall_south(input_grid)
    
    elif case == 1:
        for c in range(W):
            for r in range(H // 2):
                if random.random() > 0.5:
                    input_grid[r][c] = random.randint(1, 9)
            for r in range(H // 2, H):
                input_grid[r][c] = input_grid[H - 1 - r][c]
        output_grid = fall_east(input_grid)
    
    else:
        for r in range(H):
            for c in range(W):
                if random.random() > 0.7:
                    input_grid[r][c] = random.randint(1, 9)
        non_zero = [cell for row in input_grid for cell in row if cell != 0]
        if not non_zero:
            return generate()
        dominant = max(set(non_zero), key=non_zero.count)
        if dominant % 2 == 0:
            output_grid = fall_east(input_grid)
        else:
            output_grid = fall_west(input_grid)
    
    if input_grid == output_grid:
        return generate()
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    def is_vertical_symmetric(grid):
        H = len(grid)
        W = len(grid[0])
        for r in range(H):
            for c in range(W // 2):
                if grid[r][c] != grid[r][W - 1 - c]:
                    return False
        return True
    
    def is_horizontal_symmetric(grid):
        H = len(grid)
        W = len(grid[0])
        for c in range(W):
            for r in range(H // 2):
                if grid[r][c] != grid[H - 1 - r][c]:
                    return False
        return True
    
    def fall_south(grid):
        H = len(grid)
        W = len(grid[0])
        output = [[0] * W for _ in range(H)]
        for c in range(W):
            non_zeros = [grid[r][c] for r in range(H) if grid[r][c] != 0]
            for r in range(H - len(non_zeros), H):
                output[r][c] = non_zeros[r - (H - len(non_zeros))]
        return output
    
    def fall_east(grid):
        H = len(grid)
        W = len(grid[0])
        output = [[0] * W for _ in range(H)]
        for r in range(H):
            non_zeros = [grid[r][c] for c in range(W) if grid[r][c] != 0]
            for c in range(W - len(non_zeros), W):
                output[r][c] = non_zeros[c - (W - len(non_zeros))]
        return output
    
    def fall_west(grid):
        H = len(grid)
        W = len(grid[0])
        output = [[0] * W for _ in range(H)]
        for r in range(H):
            non_zeros = [grid[r][c] for c in range(W) if grid[r][c] != 0]
            for c in range(len(non_zeros)):
                output[r][c] = non_zeros[c]
        return output
    
    if is_vertical_symmetric(input_grid):
        return fall_south(input_grid)
    elif is_horizontal_symmetric(input_grid):
        return fall_east(input_grid)
    else:
        non_zero = [cell for row in input_grid for cell in row if cell != 0]
        if not non_zero:
            return input_grid
        dominant = max(set(non_zero), key=non_zero.count)
        if dominant % 2 == 0:
            return fall_east(input_grid)
        else:
            return fall_west(input_grid)
