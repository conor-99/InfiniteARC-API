# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 3a86be53
Difficulty: very hard

=== Tags ===
- Rotational pattern mapping
- Sequential path painting
- Interleaved streams
- Hollow core detection
- Detect grid

=== Description ===
The input grid features a central hollow core (a background-colored region
enclosed on all sides by a non-background frame) surrounded by two interwoven,
color-alternating paths (e.g., red and blue) that spiral inward toward the core.
Each path consists of contiguous cells where adjacent cells along the path
strictly alternate between two distinct colors (interleaved streams), with paths
never overlapping, touching the core, or crossing through background cells. The
output grid must rotate the entire path structure 90 degrees clockwise around
the core's center while preserving the hollow core. Crucially, the rotation must
maintain the interleaved color sequence such that the path's color progression
continues seamlessly from its endpoint in the input (sequential path painting),
ensuring that color alternation remains consistent across the rotated path. The
hollow core must remain unchanged and undisturbed during rotation, with all non-
core elements (paths) repositioned around the core's center without altering
their color patterns. The transformation requires detecting the core's geometric
center, applying precise rotational mapping, and verifying that the interleaved
color sequence aligns perfectly after rotation without introducing
inconsistencies.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common


def generate():
    # Produce a grid with a centered hollow core and two disjoint paths that spiral/inward-snake toward the core.
    # Try several attempts if generation fails to meet constraints (e.g., very short paths or accidental symmetry).
    for attempt in range(200):
        # pick an odd size between 15 and 30 to have a clear integer center
        size = random.randint(15, 30)
        if size % 2 == 0:
            if size < 30:
                size += 1
            else:
                size -= 1
        cx = cy = size // 2

        # core interior half-size (radius in Chebyshev distance). Keep core small enough to allow spirals.
        core_half = random.randint(1, 3)
        # ensure at least one cell gap between frame and paths
        min_dist = core_half + 2

        # choose colors: base color (fills non-core area), plus frame and two alternating pairs for two paths
        base_color = common.random_color(exclude=[0])
        # pick 5 distinct other colors (frame + 4 path colors) excluding base_color and 0
        other_colors = common.random_colors(5, exclude=[0, base_color])
        frame_color = other_colors[0]
        a1, a2, b1, b2 = other_colors[1], other_colors[2], other_colors[3], other_colors[4]

        # start with the whole grid painted with base_color
        grid = common.grid(size, size, base_color)

        # carve out a centered square hollow core (background color 0)
        core_coords = set()
        for r in range(cx - core_half, cx + core_half + 1):
            for c in range(cy - core_half, cy + core_half + 1):
                grid[r][c] = 0
                core_coords.add((r, c))

        # draw a frame (one-cell-thick) around the core using frame_color
        frame_coords = set()
        ring_radius = core_half + 1
        for r in range(size):
            for c in range(size):
                if max(abs(r - cx), abs(c - cy)) == ring_radius:
                    grid[r][c] = frame_color
                    frame_coords.add((r, c))

        # Allowed coordinates for paths: cells that are at least `min_dist` away (Chebyshev) from center
        allowed = set()
        for r in range(size):
            for c in range(size):
                if max(abs(r - cx), abs(c - cy)) >= min_dist:
                    allowed.add((r, c))

        # quick safety: if allowed area too small, retry
        if len(allowed) < 30:
            continue

        # helper: is a cell adjacent (edge-adjacent) to any cell in a set
        def adjacent_to_any(cell, cells_set):
            r, c = cell
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                if (r + dr, c + dc) in cells_set:
                    return True
            return False

        # Build a greedy inward-moving snake path. It avoids `forbidden_set` and doesn't touch cells in other_set.
        def build_path(start, max_steps, allowed_set, other_set):
            path = [start]
            # defensive: if start is adjacent to the other path, abort quickly
            if adjacent_to_any(start, other_set):
                return path
            while len(path) < max_steps:
                r, c = path[-1]
                candidates = []
                # try neighbors, preferring those that move closer (Chebyshev) to the center
                for dr, dc in ((0, 1), (1, 0), (0, -1), (-1, 0)):
                    nr, nc = r + dr, c + dc
                    if not (0 <= nr < size and 0 <= nc < size):
                        continue
                    if (nr, nc) not in allowed_set:
                        continue
                    if (nr, nc) in path:
                        continue
                    if (nr, nc) in other_set:
                        continue
                    # don't place a path cell adjacent to any other path cell
                    if adjacent_to_any((nr, nc), other_set):
                        continue
                    # heuristic: prefer smaller chebyshev distance to center and small randomness tie-breaker
                    d = max(abs(nr - cx), abs(nc - cy))
                    candidates.append(((nr, nc), d, random.random()))
                if not candidates:
                    break
                candidates.sort(key=lambda x: (x[1], x[2]))
                nxt = candidates[0][0]
                path.append(nxt)
            return path

        # pick outer starting candidates so the paths travel inward
        max_possible_dist = max(abs(0 - cx), abs(size - 1 - cx), abs(0 - cy), abs(size - 1 - cy))
        outer_threshold = max_possible_dist - random.randint(0, 1)
        outer_coords = [p for p in allowed if max(abs(p[0] - cx), abs(p[1] - cy)) >= outer_threshold]
        if not outer_coords:
            continue

        used = set()

        # attempt building two paths with a few retries
        success = False
        for tries in range(60):
            used.clear()
            start1 = random.choice(outer_coords)
            max_steps1 = random.randint(max(8, size // 3), max(12, size))
            path1 = build_path(start1, max_steps1, allowed, set())
            # require a reasonable length
            if len(path1) < 8:
                continue
            # mark used by path1
            used1 = set(path1)

            # choose start for path2 that is not adjacent to path1
            possible_starts2 = [p for p in outer_coords if p not in used1 and not adjacent_to_any(p, used1)]
            if not possible_starts2:
                continue
            start2 = random.choice(possible_starts2)
            max_steps2 = random.randint(max(6, size // 4), max(10, size // 1))
            path2 = build_path(start2, max_steps2, allowed, used1)
            if len(path2) < 6:
                continue

            # ensure the two paths never touch (edge-adjacent)
            touches = False
            for cell in path1:
                if adjacent_to_any(cell, set(path2)):
                    touches = True
                    break
            if touches:
                continue

            # Good paths found
            used = set(path1) | set(path2)
            success = True
            break

        if not success:
            continue

        # assign alternating colors for each path
        for i, (r, c) in enumerate(path1):
            grid[r][c] = a1 if i % 2 == 0 else a2
        for i, (r, c) in enumerate(path2):
            grid[r][c] = b1 if i % 2 == 0 else b2

        # create output by rotating all non-core cells 90 degrees clockwise around (cx, cy)
        output = common.grid(size, size, base_color)
        for r in range(size):
            for c in range(size):
                if (r, c) in core_coords:
                    # preserve the hollow core untouched
                    output[r][c] = 0
                    continue
                dr = r - cx
                dc = c - cy
                new_r = cx + dc
                new_c = cy - dr
                # rotation should keep everything inside bounds
                if 0 <= new_r < size and 0 <= new_c < size:
                    output[new_r][new_c] = grid[r][c]

        # ensure input and output are not identical (avoid accidental symmetry)
        if output == grid:
            continue

        # final return with lists (not tuples)
        return {'input': grid, 'output': output}

    # if many attempts failed, as a fallback construct something simple but valid
    size = 15
    cx = cy = size // 2
    core_half = 1
    base_color = 6
    frame_color = 1
    a1, a2, b1, b2 = 2, 3, 4, 5
    grid = common.grid(size, size, base_color)
    core_coords = set()
    for r in range(cx - core_half, cx + core_half + 1):
        for c in range(cy - core_half, cy + core_half + 1):
            grid[r][c] = 0
            core_coords.add((r, c))
    ring_radius = core_half + 1
    for r in range(size):
        for c in range(size):
            if max(abs(r - cx), abs(c - cy)) == ring_radius:
                grid[r][c] = frame_color
    # two simple snakes
    path1 = [(0, cx - 2 + i) for i in range(6)]
    path2 = [(size - 1, cx + 2 - i) for i in range(6)]
    for i, (r, c) in enumerate(path1): grid[r][c] = a1 if i % 2 == 0 else a2
    for i, (r, c) in enumerate(path2): grid[r][c] = b1 if i % 2 == 0 else b2
    output = common.grid(size, size, base_color)
    for r in range(size):
        for c in range(size):
            if (r, c) in core_coords:
                output[r][c] = 0
                continue
            dr = r - cx
            dc = c - cy
            new_r = cx + dc
            new_c = cy - dr
            if 0 <= new_r < size and 0 <= new_c < size:
                output[new_r][new_c] = grid[r][c]
    return {'input': grid, 'output': output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import collections
import common

def p(input_grid):
    # Convert input to mutable list of lists
    grid = [list(row) for row in input_grid]
    size = len(grid)

    # Find all zero-valued connected components (4-neighborhood)
    visited = [[False] * size for _ in range(size)]
    components = []

    for r in range(size):
        for c in range(size):
            if grid[r][c] != 0 or visited[r][c]:
                continue
            # BFS for this component
            comp = []
            queue = collections.deque([(r, c)])
            visited[r][c] = True
            touches_border = False
            while queue:
                cr, cc = queue.popleft()
                comp.append((cr, cc))
                if cr == 0 or cc == 0 or cr == size - 1 or cc == size - 1:
                    touches_border = True
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < size and 0 <= nc < size and not visited[nr][nc] and grid[nr][nc] == 0:
                        visited[nr][nc] = True
                        queue.append((nr, nc))
            components.append((comp, touches_border))

    if not components:
        # nothing to do
        return grid

    # Prefer a zero-component that is enclosed (not touching border). If multiple, choose the largest enclosed one.
    enclosed = [comp for comp, touch in components if not touch]
    if enclosed:
        core = max(enclosed, key=len)
    else:
        # fallback: choose the largest zero component
        core = max((comp for comp, _ in components), key=len)

    core_set = set(core)
    rs = [p[0] for p in core]
    cs = [p[1] for p in core]
    minr, maxr = min(rs), max(rs)
    minc, maxc = min(cs), max(cs)

    # center coordinates (core is constructed to be symmetric so integer center expected)
    cx = (minr + maxr) // 2
    cy = (minc + maxc) // 2

    # Create output grid by rotating all non-core cells 90 degrees clockwise about (cx, cy)
    output = common.grid(size, size, 0)

    for r in range(size):
        for c in range(size):
            if (r, c) in core_set:
                output[r][c] = grid[r][c]
                continue
            dr = r - cx
            dc = c - cy
            new_r = cx + dc
            new_c = cy - dr
            if 0 <= new_r < size and 0 <= new_c < size:
                output[new_r][new_c] = grid[r][c]

    return output

