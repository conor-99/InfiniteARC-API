# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 6f2a7be4
Difficulty: medium–hard

=== Tags ===
- Color wavefront
- Shape attribute projection

=== Description ===
Input grids feature a background color (0) with multiple disjoint rectangular
regions, each uniformly colored (1-5), and a horizontal "pattern strip" along
the top edge composed of alternating 2×2 color blocks. The pattern strip defines
a repeating color sequence (e.g., [2,4,5,4]) that determines wavefront coloring.
Output grids transform the input by drawing wavefront paths from each region's
top-left corner. The wavefront direction is determined by the region's shape
attribute: regions wider than tall propagate rightward, while taller than wide
regions propagate upward. Wavefronts use colors from the pattern strip in
sequence (starting with the first block for the leftmost-topmost region, cycling
as needed), coloring background cells until encountering a grid boundary or
another region. Wavefronts do not overwrite existing regions, the pattern strip,
or other wavefronts, and paths remain strictly on background cells. This task
requires simultaneous analysis of region geometry, pattern strip sequencing, and
directional propagation to generate the output grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    # Grid size
    width = common.randint(10, 30)
    height = common.randint(10, 30)
    grid = [[0 for _ in range(width)] for _ in range(height)]

    # Pattern strip: a sequence of contiguous 2x2 blocks along the top (rows 0 and 1)
    max_blocks = max(2, min(4, width // 2))
    num_blocks = common.randint(2, max_blocks)
    seq = [common.randint(1, 5) for _ in range(num_blocks)]

    for i, color in enumerate(seq):
        start_col = i * 2
        if start_col + 1 >= width:
            break
        for r in (0, 1):
            for c in range(start_col, start_col + 2):
                grid[r][c] = color

    # Helper to detect overlap between rectangles (r1,c1,r2,c2)
    def overlaps(a, b):
        return not (a[2] <= b[0] or a[0] >= b[2] or a[3] <= b[1] or a[1] >= b[3])

    # Helper to detect if two rectangles are too close (we require at least one cell gap)
    def too_close(a, b):
        # expand a by 1 cell in all directions and check overlap
        a_exp = (a[0] - 1, a[1] - 1, a[2] + 1, a[3] + 1)
        return overlaps(a_exp, b)

    regions = []  # list of tuples (r, c, r2, c2, color)

    target_regions = common.randint(2, 5)
    attempts = 0
    max_attempts = 2000

    # We will ensure at least one region produces a visible wave (i.e. has a free starting cell).
    good_region_present = False

    while len(regions) < target_regions and attempts < max_attempts:
        attempts += 1
        # choose width and height for the region
        w = common.randint(2, min(6, max(2, width - 2)))
        h = common.randint(2, min(6, max(2, height - 3)))

        # place region so it does not overlap the pattern (rows 0-1)
        r = common.randint(2, height - h)
        c = common.randint(0, width - w)

        cand = (r, c, r + h, c + w)
        bad = False
        for reg in regions:
            if too_close(cand, reg[:4]):
                bad = True
                break
        if bad:
            continue

        # decide direction based on shape
        direction = 'right' if w > h else 'up'

        # check that starting cell for the wave is inside the grid and currently background
        if direction == 'right':
            start_r, start_c = r, c + w
            if start_c >= width:
                continue
            # starting cell must not be covered by an existing region
            blocked = False
            for reg in regions:
                rr1, cc1, rr2, cc2 = reg[0], reg[1], reg[2], reg[3]
                if start_r >= rr1 and start_r < rr2 and start_c >= cc1 and start_c < cc2:
                    blocked = True
                    break
            if blocked:
                continue
        else:  # up
            start_r, start_c = r - 1, c
            # must not hit pattern (rows 0-1) and must be within grid
            if start_r < 2:
                continue
            blocked = False
            for reg in regions:
                rr1, cc1, rr2, cc2 = reg[0], reg[1], reg[2], reg[3]
                if start_r >= rr1 and start_r < rr2 and start_c >= cc1 and start_c < cc2:
                    blocked = True
                    break
            if blocked:
                continue

        color = common.randint(1, 5)
        # paint region
        for rr in range(r, r + h):
            for cc in range(c, c + w):
                grid[rr][cc] = color
        regions.append((r, c, r + h, c + w, color))
        good_region_present = True

    # If we failed to create any valid regions, create at least one guaranteed region that can propagate.
    if not regions:
        # place a simple 2x2 region that will propagate to the right
        h, w = 2, 2
        placed = False
        for r in range(3, height - h + 1):
            for c in range(0, width - w):
                cand = (r, c, r + h, c + w)
                if any(too_close(cand, reg[:4]) for reg in regions):
                    continue
                color = common.randint(1, 5)
                for rr in range(r, r + h):
                    for cc in range(c, c + w):
                        grid[rr][cc] = color
                regions.append((r, c, r + h, c + w, color))
                placed = True
                good_region_present = True
                break
            if placed:
                break

    # If we don't have at least two regions, try to add more (safe fallback)
    extra_attempts = 0
    while len(regions) < 2 and extra_attempts < 500:
        extra_attempts += 1
        w = common.randint(2, min(6, max(2, width - 2)))
        h = common.randint(2, min(6, max(2, height - 3)))
        r = common.randint(2, height - h)
        c = common.randint(0, width - w)
        cand = (r, c, r + h, c + w)
        if any(too_close(cand, reg[:4]) for reg in regions):
            continue
        color = common.randint(1, 5)
        for rr in range(r, r + h):
            for cc in range(c, c + w):
                grid[rr][cc] = color
        regions.append((r, c, r + h, c + w, color))

    # Sort regions in reading order (top to bottom, left to right)
    regions.sort(key=lambda x: (x[0], x[1]))

    # Build the output by propagating wavefronts from each region's top-left corner
    output = [row[:] for row in grid]
    for idx, (r1, c1, r2, c2, _) in enumerate(regions):
        width_reg = c2 - c1
        height_reg = r2 - r1
        direction = 'right' if width_reg > height_reg else 'up'
        wave_color = seq[idx % len(seq)]
        if direction == 'right':
            c = c2  # start just to the right of the region
            while c < width and output[r1][c] == 0:
                output[r1][c] = wave_color
                c += 1
        else:
            r = r1 - 1  # start just above the region
            while r >= 0 and output[r][c1] == 0:
                output[r][c1] = wave_color
                r -= 1

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Extract pattern sequence from the top 2 rows by scanning for 2x2 blocks left-to-right
    seq = []
    c = 0
    while c < width:
        if grid[0][c] != 0:
            # Check that a 2x2 block exists and is uniform
            if c + 1 < width and grid[0][c + 1] == grid[0][c] and grid[1][c] == grid[0][c] and grid[1][c + 1] == grid[0][c]:
                seq.append(grid[0][c])
                c += 2
                continue
        c += 1

    if not seq:
        seq = [1, 2, 3, 4]

    # Find rectangular regions in the area below the pattern (rows >= 2)
    seen = [[False] * width for _ in range(height)]
    regions = []  # (r1, c1, r2_exclusive, c2_exclusive, color)

    for r in range(2, height):
        for c in range(width):
            if grid[r][c] == 0 or seen[r][c]:
                continue
            color = grid[r][c]
            # BFS/DFS to find the connected component of this color (4-neighbors)
            stack = [(r, c)]
            comp = []
            seen[r][c] = True
            while stack:
                rr, cc = stack.pop()
                comp.append((rr, cc))
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = rr + dr, cc + dc
                    if nr < 2 or nr < 0 or nr >= height or nc < 0 or nc >= width:
                        continue
                    if seen[nr][nc]:
                        continue
                    if grid[nr][nc] != color:
                        continue
                    seen[nr][nc] = True
                    stack.append((nr, nc))
            # Determine bounding box
            min_r = min(p[0] for p in comp)
            max_r = max(p[0] for p in comp)
            min_c = min(p[1] for p in comp)
            max_c = max(p[1] for p in comp)
            # Verify the component is a full rectangle filled with the color
            is_rectangle = True
            for rr in range(min_r, max_r + 1):
                for cc in range(min_c, max_c + 1):
                    if grid[rr][cc] != color:
                        is_rectangle = False
                        break
                if not is_rectangle:
                    break
            if is_rectangle:
                regions.append((min_r, min_c, max_r + 1, max_c + 1, color))

    # Sort regions in reading order (top to bottom, left to right)
    regions.sort(key=lambda x: (x[0], x[1]))

    # Create output and propagate waves
    output = [row[:] for row in grid]
    for idx, (r1, c1, r2, c2, _) in enumerate(regions):
        width_reg = c2 - c1
        height_reg = r2 - r1
        direction = 'right' if width_reg > height_reg else 'up'
        wave_color = seq[idx % len(seq)]
        if direction == 'right':
            c = c2
            while c < width and output[r1][c] == 0:
                output[r1][c] = wave_color
                c += 1
        else:
            r = r1 - 1
            while r >= 0 and output[r][c1] == 0:
                output[r][c1] = wave_color
                r -= 1

    return output

