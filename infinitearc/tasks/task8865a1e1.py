# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 8865a1e1
Difficulty: very hard

=== Tags ===
- Pattern analogy
- Field interference pattern
- Swap rows
- Holes

=== Description ===
Input grids consist of a background color (0) and multiple contiguous colored
regions (1-9), each region containing a geometric pattern of holes (background
cells) arranged in a unique motif (e.g., diagonal lines, concentric rings, or
grid-aligned clusters). The "field interference pattern" emerges when hole
patterns from regions in horizontally adjacent columns intersect such that a
hole in column *c* of a left-region aligns with a hole in column *width-1-c* of
its right-region, creating a vertical interference axis at column *c*.   For
each vertical interference axis, all rows containing holes aligned along this
axis are identified. The output grid swaps each such row *i* with its
horizontally symmetric counterpart *height-1-i*. The swap applies only to rows
with interference alignment, preserving all original hole patterns, region
colors, and geometric motifs. The transformation requires recognizing the
interference pattern through visual symmetry matching, determining the affected
rows via geometric alignment, and executing the symmetric row swaps without
altering the grid's structural or color properties. This task demands layered
visual analysis of overlapping patterns, symmetry detection, and precise row
manipulation across a complex grid structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    while True:
        width = random.randint(5, 30)
        height = random.randint(5, 30)
        grid = [[0] * width for _ in range(height)]
        
        colors = list(range(1, 10))
        L = random.choice(colors)
        R = random.choice([c for c in colors if c != L])
        
        L_end = width // 2 - 1
        R_start = width // 2
        
        for r in range(height):
            for c in range(L_end + 1):
                grid[r][c] = L
        
        for r in range(height):
            for c in range(R_start, width):
                grid[r][c] = R
        
        k = random.randint(2, 4)
        
        for r in range(height):
            for c in range(L_end + 1):
                if (r + c) % k == 0:
                    grid[r][c] = 0
        
        for r in range(height):
            for c in range(L_end + 1):
                if (r + c) % k == 0:
                    mirror_c = width - 1 - c
                    if R_start <= mirror_c < width:
                        grid[r][mirror_c] = 0
        
        interference_rows = []
        for r in range(height):
            for c in range(L_end + 1):
                if grid[r][c] == 0 and grid[r][width - 1 - c] == 0:
                    interference_rows.append(r)
                    break
        
        output = [row[:] for row in grid]
        for r in interference_rows:
            if r < height - 1 - r:
                output[r], output[height - 1 - r] = output[height - 1 - r], output[r]
        
        if grid != output:
            break
    
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    
    interference_rows = []
    for r in range(height):
        for c in range(width // 2):
            if input_grid[r][c] == 0 and input_grid[r][width - 1 - c] == 0:
                interference_rows.append(r)
                break
    
    for r in interference_rows:
        if r < height - 1 - r:
            input_grid[r], input_grid[height - 1 - r] = input_grid[height - 1 - r], input_grid[r]
    
    return tuple(tuple(row) for row in input_grid)
