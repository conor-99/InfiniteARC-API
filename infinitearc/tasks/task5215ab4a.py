# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 5215ab4a
Difficulty: hard

=== Tags ===
- Associate images to bools
- Pairwise analogy

=== Description ===
The input grid consists of a 2D arrangement of integers between 0 and 9,
representing colored cells. The transformation rule requires analyzing connected
components (4-directionally adjacent cells of the same non-zero color) for each
color present in the grid. For each cell in the output grid, the value is 1 if
the color of the corresponding cell in the input appears in exactly two distinct
connected components; otherwise, the value is 0. This rule demands identifying
all connected components per color, verifying their count equals two, and
mapping this Boolean condition to the output grid. The task is challenging due
to the multi-step reasoning required: connectivity analysis, component counting,
and conditional Boolean mapping, all without explicit visual cues for the
component counts.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(4, 30)
    height = random.randint(4, 30)
    color = random.randint(2, 9)
    input_grid = [[0] * width for _ in range(height)]
    
    for r in range(2):
        for c in range(2):
            input_grid[r][c] = color
    
    for r in range(height-2, height):
        for c in range(width-2, width):
            input_grid[r][c] = color
    
    output_grid = [[1 if input_grid[r][c] == color else 0 for c in range(width)] for r in range(height)]
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid or not input_grid[0]:
        return []
    
    height = len(input_grid)
    width = len(input_grid[0])
    
    colors = set()
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                colors.add(input_grid[r][c])
    
    comp_counts = {}
    for color_val in colors:
        comp_counts[color_val] = 0
        visited = [[False] * width for _ in range(height)]
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == color_val and not visited[r][c]:
                    comp_counts[color_val] += 1
                    queue = [(r, c)]
                    visited[r][c] = True
                    while queue:
                        cur_r, cur_c = queue.pop(0)
                        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                            nr, nc = cur_r + dr, cur_c + dc
                            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color_val:
                                visited[nr][nc] = True
                                queue.append((nr, nc))
    
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and comp_counts[input_grid[r][c]] == 2:
                output_grid[r][c] = 1
    
    return output_grid
