# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 69ee1b6c
Difficulty: hard

=== Tags ===
- Color particle fall
- Field based motion
- Meta rule switching
- Sort colors by index

=== Description ===
Input grids feature a background (color 0) with scattered colored particles
(colors 1–9) positioned in the upper half. Below these particles, a grid of
directional field cells (colors 1–4 representing down, right, up, left) is
embedded, with some cells containing obstacles (colors 5–9) that block movement.
The field cells may undergo dynamic meta rule switching: when a particle of
color *c* enters a field cell, the cell’s direction updates based on *c* (e.g.,
color 3 particles switch down fields to right fields).   The transformation
sequence first applies field-based motion: particles fall or move according to
the current field direction, triggering meta rule switching upon entry into
field cells. Particles continue moving until hitting obstacles, boundaries, or
field cells whose direction changes mid-motion. After all particles settle,
their colors are sorted in ascending order (1 to 9) and arranged left-to-right
in the bottommost row of the grid, with background (0) filling remaining
positions. Obstacles, field cells (post-switching), and background are
preserved, while particles are repositioned exclusively into the sorted bottom
row. The output requires recognizing dynamic field interactions during movement
and executing a spatial sort based on color index.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    """
    Generator that creates an ARC-like grid according to the task description.
    - Upper half: scattered particles (1..9)
    - Lower half: mix of fields (1..4), obstacles (5..9) and background (0)
    It simulates particle motion through the field (updating field directions when a
    particle enters a field cell). After all particles move (only fields are changed),
    the particle colors are sorted ascending and placed left-to-right in the bottommost
    row's background cells. The upper half particle cells are cleared in the output.
    """
    # Dimensions: choose moderately sized grid to ensure interesting interactions
    width = random.randint(4, 14)
    height = random.randint(6, 20)

    grid = [[0 for _ in range(width)] for _ in range(height)]

    upper_end = height // 2

    # Place particles in the upper half. Ensure at least one particle and at most width
    # so they can all be placed into the bottom row left-to-right.
    max_particles = max(1, min(width, upper_end * width))
    n_particles = random.randint(1, max(1, min(width, max(1, upper_end))))

    upper_positions = [(r, c) for r in range(upper_end) for c in range(width)]
    # sample unique positions for particles
    particle_positions = random.sample(upper_positions, n_particles)

    particles = []
    for (r, c) in particle_positions:
        color = random.randint(1, 9)
        grid[r][c] = color
        particles.append((r, c, color))

    # Fill the lower half with fields (1..4), obstacles (5..9) or background 0.
    # Use probabilities so we often get fields but leave some empty spaces.
    for r in range(upper_end, height):
        for c in range(width):
            p = random.random()
            if p < 0.55:
                grid[r][c] = random.randint(1, 4)  # field
            elif p < 0.85:
                grid[r][c] = random.randint(5, 9)  # obstacle
            else:
                grid[r][c] = 0  # background

    # Ensure there is at least one field cell in the lower region (so meta-switching can occur)
    has_field = any(1 <= grid[r][c] <= 4 for r in range(upper_end, height) for c in range(width))
    if not has_field:
        r = random.randint(upper_end, height - 1)
        c = random.randint(0, width - 1)
        grid[r][c] = random.randint(1, 4)

    # Ensure bottom row has at least as many background cells as particles so we can place them
    bottom_row = height - 1
    background_positions = [c for c in range(width) if grid[bottom_row][c] == 0]
    if len(background_positions) < n_particles:
        # Turn some non-background cells into background until there is room
        non_bg = [c for c in range(width) if grid[bottom_row][c] != 0]
        random.shuffle(non_bg)
        needed = n_particles - len(background_positions)
        for i in range(min(needed, len(non_bg))):
            grid[bottom_row][non_bg[i]] = 0

    # Simulate particle movement, updating fields as particles enter them.
    # Work on a separate field grid that treats upper half as background (particles are not fields).
    field_grid = [row[:] for row in grid]
    for r in range(upper_end):
        for c in range(width):
            # clear upper-half cells so they don't act as fields/obstacles during sim
            field_grid[r][c] = 0

    # Movement helper
    def rotate_field(old_dir, particle_color):
        # old_dir in 1..4, particle_color in 1..9 -> rotate by particle_color steps modulo 4
        return ((old_dir - 1 + particle_color) % 4) + 1

    max_steps = width * height * 10

    # Process particles in reading order (top-to-bottom, left-to-right)
    particles_sorted_for_sim = sorted(particles, key=lambda x: (x[0], x[1]))

    for (sr, sc, scolor) in particles_sorted_for_sim:
        r, c = sr, sc
        steps = 0
        while True:
            # gravity: fall while cell below is background
            while r + 1 < height and field_grid[r + 1][c] == 0:
                r += 1
                steps += 1
                if steps > max_steps:
                    break
            if steps > max_steps:
                break

            # if we've reached the bottom row, stop
            if r == height - 1:
                break

            below = field_grid[r + 1][c]
            # If below is an obstacle (5..9), particle stops above it
            if below >= 5:
                break

            # If below is a field (1..4), move into it and follow the directions
            if 1 <= below <= 4:
                # step into the field cell
                r += 1
                steps += 1
                if steps > max_steps:
                    break

                # update the field cell upon entry
                old_dir = field_grid[r][c]
                new_dir = rotate_field(old_dir, scolor)
                field_grid[r][c] = new_dir

                # Now follow the field arrows until we either hit boundary/obstacle,
                # or move into a background cell (and then gravity resumes), or exceed steps
                while True:
                    if field_grid[r][c] == 1:
                        dr, dc = 1, 0
                    elif field_grid[r][c] == 2:
                        dr, dc = 0, 1
                    elif field_grid[r][c] == 3:
                        dr, dc = -1, 0
                    else:
                        dr, dc = 0, -1

                    nr, nc = r + dr, c + dc
                    # boundary or obstacle stops the particle at current cell
                    if nr < 0 or nr >= height or nc < 0 or nc >= width:
                        r, c = r, c
                        break
                    if field_grid[nr][nc] >= 5:
                        break

                    # move into next cell
                    r, c = nr, nc
                    steps += 1
                    if steps > max_steps:
                        break

                    # if moved into background, gravity resumes in outer loop
                    if field_grid[r][c] == 0:
                        break

                    # if moved into another field, update it and continue following directions
                    old_dir = field_grid[r][c]
                    new_dir = rotate_field(old_dir, scolor)
                    field_grid[r][c] = new_dir

                if steps > max_steps:
                    break

                # after following arrows either we are in background (to fall), at boundary/obstacle, or at a field
                # the outer while will handle falling or stopping
                continue

            # otherwise, no movement possible
            break

    # Gather particle colors and sort ascending
    colors = [p[2] for p in particles]
    colors.sort()

    # Build output: start from the final field grid (post-switching)
    output_grid = [row[:] for row in field_grid]

    # Clear any particles that were in the upper half of the input
    for r in range(upper_end):
        for c in range(width):
            output_grid[r][c] = 0

    # Place sorted colors left-to-right into bottommost row but ONLY into background cells (preserve fields/obstacles)
    bottom = height - 1
    place_idx = 0
    for c in range(width):
        if output_grid[bottom][c] == 0 and place_idx < len(colors):
            output_grid[bottom][c] = colors[place_idx]
            place_idx += 1

    return {"input": grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    upper_end = height // 2

    # Collect particles from the upper half (cells > 0 are particles there)
    particles = []
    for r in range(upper_end):
        for c in range(width):
            if grid[r][c] > 0:
                particles.append((r, c, grid[r][c]))

    # Prepare field grid by copying and clearing upper half so particles don't act as fields
    field_grid = [row[:] for row in grid]
    for r in range(upper_end):
        for c in range(width):
            field_grid[r][c] = 0

    def rotate_field(old_dir, particle_color):
        return ((old_dir - 1 + particle_color) % 4) + 1

    max_steps = width * height * 10

    # Process particles in reading order (top-to-bottom, left-to-right)
    particles_sorted = sorted(particles, key=lambda x: (x[0], x[1]))

    for (sr, sc, scolor) in particles_sorted:
        r, c = sr, sc
        steps = 0
        while True:
            # gravity: fall while below is background
            while r + 1 < height and field_grid[r + 1][c] == 0:
                r += 1
                steps += 1
                if steps > max_steps:
                    break
            if steps > max_steps:
                break

            if r == height - 1:
                break

            below = field_grid[r + 1][c]
            if below >= 5:
                break

            if 1 <= below <= 4:
                # step into field
                r += 1
                steps += 1
                if steps > max_steps:
                    break

                # update the field cell upon entry
                old_dir = field_grid[r][c]
                new_dir = rotate_field(old_dir, scolor)
                field_grid[r][c] = new_dir

                # follow field arrows
                while True:
                    if field_grid[r][c] == 1:
                        dr, dc = 1, 0
                    elif field_grid[r][c] == 2:
                        dr, dc = 0, 1
                    elif field_grid[r][c] == 3:
                        dr, dc = -1, 0
                    else:
                        dr, dc = 0, -1

                    nr, nc = r + dr, c + dc
                    if nr < 0 or nr >= height or nc < 0 or nc >= width:
                        break
                    if field_grid[nr][nc] >= 5:
                        break

                    r, c = nr, nc
                    steps += 1
                    if steps > max_steps:
                        break

                    if field_grid[r][c] == 0:
                        break

                    old_dir = field_grid[r][c]
                    new_dir = rotate_field(old_dir, scolor)
                    field_grid[r][c] = new_dir

                if steps > max_steps:
                    break

                continue

            break

    # Sort particle colors and place them in bottom row's background cells left-to-right
    colors = [p[2] for p in particles]
    colors.sort()

    output_grid = [row[:] for row in field_grid]
    for r in range(upper_end):
        for c in range(width):
            output_grid[r][c] = 0

    bottom = height - 1
    place_idx = 0
    for c in range(width):
        if output_grid[bottom][c] == 0 and place_idx < len(colors):
            output_grid[bottom][c] = colors[place_idx]
            place_idx += 1

    return tuple(tuple(row) for row in output_grid)

