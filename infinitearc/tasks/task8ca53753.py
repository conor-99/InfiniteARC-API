# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 8ca53753
Difficulty: insane

=== Tags ===
- Inside out
- Image juxtaposition
- Order numbers

=== Description ===
The task involves a grid transformation that combines three key concepts:
"inside out," "image juxtaposition," and "order numbers." The input grid is a 2D
array of integers (0-9) representing a pattern with concentric layers. The
transformation requires two primary steps:   1. **Inside Out**: The grid's
concentric layers are reversed. For example, the outermost layer (border)
becomes the innermost, and the innermost layer (center) becomes the outermost.
This is achieved by mapping each cell's value to a new position based on its
distance from the grid's center, effectively flipping the layer hierarchy. The
transformation is consistent across all grid sizes, handling odd and even
dimensions by centering the reversal around the grid's geometric center.  2.
**Image Juxtaposition and Order Numbers**: After reversing layers, the grid is
split vertically into two halves (left and right). The left half is sorted in
ascending order row-wise, while the right half is sorted in descending order
row-wise. These sorted halves are then juxtaposed (placed side by side) to form
the output grid. The sorting is applied independently to each row within the
halves, ensuring the relative order of rows is preserved while the values within
each row are reordered.  This task demands recognition of layer-based geometry,
understanding of dual sorting patterns, and the ability to combine spatial and
numerical transformations, making it challenging to deduce from minimal
examples.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.choice(range(4, 31, 2))
    height = random.randint(3, 30)
    if width > 17:
        height = random.randint(3, 17)
    input_grid = [[0] * width for _ in range(height)]
    max_layer = (min(width, height) - 1) // 2
    for r in range(height):
        for c in range(width):
            layer = min(r, c, height - 1 - r, width - 1 - c)
            input_grid[r][c] = layer + 1
    intermediate = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            layer = min(r, c, height - 1 - r, width - 1 - c)
            intermediate[r][c] = (max_layer - layer) + 1
    output_grid = []
    for row in intermediate:
        left = row[:width//2]
        right = row[width//2:]
        output_grid.append(sorted(left) + sorted(right, reverse=True))
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    h = len(input_grid)
    w = len(input_grid[0])
    max_layer = (min(h, w) - 1) // 2
    intermediate = [[0] * w for _ in range(h)]
    for r in range(h):
        for c in range(w):
            layer = min(r, c, h - 1 - r, w - 1 - c)
            intermediate[r][c] = (max_layer - layer) + 1
    output = []
    for row in intermediate:
        left = row[:w//2]
        right = row[w//2:]
        output.append(sorted(left) + sorted(right, reverse=True))
    return output
