# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 7b1395f6
Difficulty: very hard

=== Tags ===
- Pattern analogy
- Color carving
- Tiled majority vote
- Duplicate row pattern

=== Description ===
Input grids are 15×15 or larger (divisible by 3), with a background color (0)
and scattered non-background colors (1-9) forming patterns within 3×3 tiles.
Each tile's majority non-background color (ties resolved by smallest color
number) determines its "carved" state: only cells matching this majority color
are retained in the output, others become background.   The "duplicate row
pattern" rule activates as follows: for each row of tiles (e.g., rows 0-4 in a
5×5 tile grid), the dominant color (most frequent majority color across the row)
is identified. In the output, the carved pattern of this dominant color within
its tile row is vertically duplicated, extending downward by one tile height (3
cells), creating a stacked visual effect. The duplication preserves the dominant
color and excludes background, resulting in a grid where each tile row displays
its dominant pattern twice vertically. All other elements (non-dominant
patterns, background) remain unchanged. This creates a complex interplay between
tile-level majority voting, visual carving, and vertical pattern repetition,
requiring multi-step reasoning to reverse-engineer.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
def generate():
    size = 15
    tile_size = 3
    num_tiles = size // tile_size
    
    input_grid = [[0] * size for _ in range(size)]
    
    for i in range(num_tiles):
        for j in range(num_tiles):
            C = random.randint(1, 9)
            positions = random.sample(range(9), 5)
            for idx in positions:
                r = i * tile_size + idx // 3
                c = j * tile_size + idx % 3
                input_grid[r][c] = C
            other_positions = [p for p in range(9) if p not in positions]
            for idx in other_positions:
                r = i * tile_size + idx // 3
                c = j * tile_size + idx % 3
                input_grid[r][c] = random.randint(1, 9)
    
    carved_grid = [[0] * size for _ in range(size)]
    for i in range(num_tiles):
        for j in range(num_tiles):
            tile = []
            for r in range(i * tile_size, (i + 1) * tile_size):
                for c in range(j * tile_size, (j + 1) * tile_size):
                    tile.append(input_grid[r][c])
            counts = [0] * 10
            for color in tile:
                if color != 0:
                    counts[color] += 1
            majority = 0
            max_count = 0
            for color in range(1, 10):
                if counts[color] > max_count:
                    max_count = counts[color]
                    majority = color
                elif counts[color] == max_count and color < majority:
                    majority = color
            for r in range(i * tile_size, (i + 1) * tile_size):
                for c in range(j * tile_size, (j + 1) * tile_size):
                    if input_grid[r][c] == majority:
                        carved_grid[r][c] = majority
                    else:
                        carved_grid[r][c] = 0
    
    dominant_colors = []
    for i in range(num_tiles):
        colors_in_row = []
        for j in range(num_tiles):
            tile = []
            for r in range(i * tile_size, (i + 1) * tile_size):
                for c in range(j * tile_size, (j + 1) * tile_size):
                    tile.append(input_grid[r][c])
            counts = [0] * 10
            for color in tile:
                if color != 0:
                    counts[color] += 1
            majority = 0
            max_count = 0
            for color in range(1, 10):
                if counts[color] > max_count:
                    max_count = counts[color]
                    majority = color
                elif counts[color] == max_count and color < majority:
                    majority = color
            colors_in_row.append(majority)
        count_color = [0] * 10
        for color in colors_in_row:
            if color != 0:
                count_color[color] += 1
        dominant = 0
        max_count = 0
        for color in range(1, 10):
            if count_color[color] > max_count:
                max_count = count_color[color]
                dominant = color
            elif count_color[color] == max_count and color < dominant:
                dominant = color
        dominant_colors.append(dominant)
    
    output_grid = [row[:] for row in carved_grid]
    for i in range(num_tiles - 1):
        for j in range(num_tiles):
            tile = []
            for r in range(i * tile_size, (i + 1) * tile_size):
                for c in range(j * tile_size, (j + 1) * tile_size):
                    tile.append(input_grid[r][c])
            counts = [0] * 10
            for color in tile:
                if color != 0:
                    counts[color] += 1
            majority = 0
            max_count = 0
            for color in range(1, 10):
                if counts[color] > max_count:
                    max_count = counts[color]
                    majority = color
                elif counts[color] == max_count and color < majority:
                    majority = color
            if majority == dominant_colors[i]:
                for r in range(i * tile_size, (i + 1) * tile_size):
                    for c in range(j * tile_size, (j + 1) * tile_size):
                        if carved_grid[r][c] != 0:
                            new_r = (i + 1) * tile_size + (r - i * tile_size)
                            new_c = c
                            output_grid[new_r][new_c] = carved_grid[r][c]
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    size = len(input_grid)
    tile_size = 3
    num_tiles = size // tile_size
    
    carved_grid = [[0] * size for _ in range(size)]
    for i in range(num_tiles):
        for j in range(num_tiles):
            tile = []
            for r in range(i * tile_size, (i + 1) * tile_size):
                for c in range(j * tile_size, (j + 1) * tile_size):
                    tile.append(input_grid[r][c])
            counts = [0] * 10
            for color in tile:
                if color != 0:
                    counts[color] += 1
            majority = 0
            max_count = 0
            for color in range(1, 10):
                if counts[color] > max_count:
                    max_count = counts[color]
                    majority = color
                elif counts[color] == max_count and color < majority:
                    majority = color
            for r in range(i * tile_size, (i + 1) * tile_size):
                for c in range(j * tile_size, (j + 1) * tile_size):
                    if input_grid[r][c] == majority:
                        carved_grid[r][c] = majority
                    else:
                        carved_grid[r][c] = 0
    
    dominant_colors = []
    for i in range(num_tiles):
        colors_in_row = []
        for j in range(num_tiles):
            tile = []
            for r in range(i * tile_size, (i + 1) * tile_size):
                for c in range(j * tile_size, (j + 1) * tile_size):
                    tile.append(input_grid[r][c])
            counts = [0] * 10
            for color in tile:
                if color != 0:
                    counts[color] += 1
            majority = 0
            max_count = 0
            for color in range(1, 10):
                if counts[color] > max_count:
                    max_count = counts[color]
                    majority = color
                elif counts[color] == max_count and color < majority:
                    majority = color
            colors_in_row.append(majority)
        count_color = [0] * 10
        for color in colors_in_row:
            if color != 0:
                count_color[color] += 1
        dominant = 0
        max_count = 0
        for color in range(1, 10):
            if count_color[color] > max_count:
                max_count = count_color[color]
                dominant = color
            elif count_color[color] == max_count and color < dominant:
                dominant = color
        dominant_colors.append(dominant)
    
    output_grid = [row[:] for row in carved_grid]
    for i in range(num_tiles - 1):
        for j in range(num_tiles):
            tile = []
            for r in range(i * tile_size, (i + 1) * tile_size):
                for c in range(j * tile_size, (j + 1) * tile_size):
                    tile.append(input_grid[r][c])
            counts = [0] * 10
            for color in tile:
                if color != 0:
                    counts[color] += 1
            majority = 0
            max_count = 0
            for color in range(1, 10):
                if counts[color] > max_count:
                    max_count = counts[color]
                    majority = color
                elif counts[color] == max_count and color < majority:
                    majority = color
            if majority == dominant_colors[i]:
                for r in range(i * tile_size, (i + 1) * tile_size):
                    for c in range(j * tile_size, (j + 1) * tile_size):
                        if carved_grid[r][c] != 0:
                            new_r = (i + 1) * tile_size + (r - i * tile_size)
                            new_c = c
                            output_grid[new_r][new_c] = carved_grid[r][c]
    return output_grid
