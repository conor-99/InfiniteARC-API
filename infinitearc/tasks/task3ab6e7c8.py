# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 3ab6e7c8
Difficulty: medium–hard

=== Tags ===
- Shape morphing
- Mutual reflection
- Spring chain
- Feature binding

=== Description ===
Input grids feature a horizontal sequence of symmetric shape pairs arranged
around a central vertical axis. Each pair consists of a shape and its vertical
mirror image (mutual reflection), with the shapes progressively morphing (e.g.,
square → triangle → circle) as the sequence extends. The color of each shape
follows a consistent progression (e.g., red → green → blue), and the spacing
between consecutive pairs increases with each morphing step (spring chain
effect).   The output grid extends this sequence by adding a new shape pair at
the end. The new shape is the next morphed version in the sequence (e.g., circle
→ star), its color is the next in the progression, and the spacing is increased
to maintain the spring chain pattern. The reflection of the new shape is placed
symmetrically opposite, and all existing elements remain unchanged. Feature
binding is applied during color progression, where the color of the new shape is
derived by blending the colors of the two most recently added shapes (e.g., blue
+ yellow = purple), ensuring visual continuity in the sequence.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Shape bounding box
    SH, SW = 5, 3

    # Define a sequence of small prototypes (each is a set of (r,c) inside SHxSW box)
    shapes = []
    # 0: filled 3x3 square centered vertically
    shapes.append({(1,0),(1,1),(1,2),(2,0),(2,1),(2,2),(3,0),(3,1),(3,2)})
    # 1: diamond
    shapes.append({(1,1),(2,0),(2,1),(2,2),(3,1)})
    # 2: plus/cross
    shapes.append({(0,1),(1,1),(2,0),(2,1),(2,2),(3,1),(4,1)})
    # 3: L-shape
    shapes.append({(1,0),(2,0),(3,0),(3,1),(3,2)})
    # 4: T-shape
    shapes.append({(1,0),(1,1),(1,2),(2,1),(3,1)})
    # 5: V-shape
    shapes.append({(1,0),(1,2),(2,1),(3,0),(3,2)})
    # 6: U-shape / chunky U
    shapes.append({(1,0),(1,1),(1,2),(2,0),(3,0),(3,1),(3,2)})

    palette = list(range(1, 10))

    def blend(a, b):
        # Blend by summing and reducing mod 9 into 1..9
        x = (a + b) % 9
        return 9 if x == 0 else x

    # number of existing pairs (must be >=3 so solver can infer spacing + colors)
    n = 3

    max_tries = 200
    for _ in range(max_tries):
        base_gap = random.randint(1, 3)
        inc = random.randint(1, 2)
        left_margin = random.randint(0, 2)

        pair_total = 2 * SW + 1
        # compute start positions including the appended new pair at index n
        starts = [left_margin]
        for i in range(1, n + 1):
            gap_i = base_gap + (i - 1) * inc
            starts.append(starts[-1] + pair_total + gap_i)
        # compute rightmost occupied column
        last_occupied = max(s + 2 * SW for s in starts)
        if last_occupied <= 29:
            width = last_occupied + 1  # minimal width to include last column
            if 1 <= width <= 30:
                break
    else:
        # deterministic fallback layout that fits within 30 columns
        base_gap = 1
        inc = 1
        left_margin = 0
        pair_total = 2 * SW + 1
        starts = [left_margin]
        for i in range(1, n + 1):
            gap_i = base_gap + (i - 1) * inc
            starts.append(starts[-1] + pair_total + gap_i)
        last_occupied = max(s + 2 * SW for s in starts)
        width = min(30, last_occupied + 1)

    height = SH

    # choose a run of shapes (morphing sequence) and colors
    max_start_shape = len(shapes) - (n + 1)
    shape_start = random.randint(0, max_start_shape)

    c0 = random.choice(palette)
    c1 = random.choice([c for c in palette if c != c0])
    colors = [c0, c1]
    for i in range(2, n):
        colors.append(blend(colors[i - 2], colors[i - 1]))

    # input grid: n pairs
    input_grid = grid(width, height, 0)
    for i in range(n):
        shape = shapes[shape_start + i]
        color = colors[i]
        x = starts[i]
        # place left shape
        for (r, c) in shape:
            input_grid[r][x + c] = color
        # place mirror to the right of a central blank column
        mirror_start = x + SW + 1
        for (r, c) in shape:
            input_grid[r][mirror_start + (SW - 1 - c)] = color

    # output grid: input with appended new pair
    output_grid = [row[:] for row in input_grid]
    new_shape = shapes[shape_start + n]
    new_color = blend(colors[-2], colors[-1])
    x_new = starts[n]
    for (r, c) in new_shape:
        if 0 <= r < height and 0 <= x_new + c < width:
            output_grid[r][x_new + c] = new_color
    mirror_start = x_new + SW + 1
    for (r, c) in new_shape:
        mc = mirror_start + (SW - 1 - c)
        if 0 <= r < height and 0 <= mc < width:
            output_grid[r][mc] = new_color

    return {
        "input": input_grid,
        "output": output_grid
    }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    # Convert to mutable list of lists
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])

    SH, SW = 5, 3

    # same prototypes as generator
    shapes = []
    shapes.append({(1,0),(1,1),(1,2),(2,0),(2,1),(2,2),(3,0),(3,1),(3,2)})
    shapes.append({(1,1),(2,0),(2,1),(2,2),(3,1)})
    shapes.append({(0,1),(1,1),(2,0),(2,1),(2,2),(3,1),(4,1)})
    shapes.append({(1,0),(2,0),(3,0),(3,1),(3,2)})
    shapes.append({(1,0),(1,1),(1,2),(2,1),(3,1)})
    shapes.append({(1,0),(1,2),(2,1),(3,0),(3,2)})
    shapes.append({(1,0),(1,1),(1,2),(2,0),(3,0),(3,1),(3,2)})

    def blend(a, b):
        x = (a + b) % 9
        return 9 if x == 0 else x

    # find columns that contain any non-zero pixel
    col_has = [any(input_grid[r][c] != 0 for r in range(height)) for c in range(width)]

    # find contiguous non-empty column blocks
    blocks = []
    c = 0
    while c < width:
        if col_has[c]:
            start = c
            while c < width and col_has[c]:
                c += 1
            end = c - 1
            blocks.append((start, end))
        else:
            c += 1

    pair_starts = []
    pair_shape_ids = []
    pair_colors = []

    i = 0
    while i < len(blocks) - 1:
        s1, e1 = blocks[i]
        s2, e2 = blocks[i + 1]
        gap = s2 - e1 - 1
        # candidate pairs will often be adjacent with a small central blank gap; verify mirror and equal color
        # quick filter: widths should match expected SW
        w1 = e1 - s1 + 1
        w2 = e2 - s2 + 1
        if gap >= 0 and w1 == SW and w2 == SW:
            # pick color (first non-zero in left block)
            left_color = None
            for r in range(height):
                for cc in range(s1, e1 + 1):
                    if input_grid[r][cc] != 0:
                        left_color = input_grid[r][cc]
                        break
                if left_color is not None:
                    break
            right_color = None
            for r in range(height):
                for cc in range(s2, e2 + 1):
                    if input_grid[r][cc] != 0:
                        right_color = input_grid[r][cc]
                        break
                if right_color is not None:
                    break
            if left_color is not None and right_color is not None and left_color == right_color:
                # check mirror pattern
                mirror_ok = True
                for r in range(height):
                    for offset in range(w1):
                        a = (input_grid[r][s1 + offset] != 0)
                        b = (input_grid[r][s2 + (w2 - 1 - offset)] != 0)
                        if a != b:
                            mirror_ok = False
                            break
                    if not mirror_ok:
                        break
                if mirror_ok:
                    # record this pair
                    pair_starts.append(s1)
                    # extract positions of left shape
                    pos = set()
                    for r in range(height):
                        for offset in range(w1):
                            if input_grid[r][s1 + offset] != 0:
                                pos.add((r, offset))
                    # match prototype
                    matched = None
                    for idx, proto in enumerate(shapes):
                        if proto == pos:
                            matched = idx
                            break
                    if matched is None:
                        # If exact match fails (shouldn't for valid generator), try vertical shift
                        for idx, proto in enumerate(shapes):
                            # try shifting proto down/up within SH
                            for shift in range(-2, 3):
                                shifted = {(r + shift, c) for (r, c) in proto}
                                if shifted == pos:
                                    matched = idx
                                    break
                            if matched is not None:
                                break
                    pair_shape_ids.append(matched if matched is not None else 0)
                    pair_colors.append(left_color)
                    i += 2
                    continue
        i += 1

    # need at least 2 pairs to infer color blending and at least 3 to infer spacing increment
    if len(pair_starts) < 2:
        return input_grid

    # compute spacing between the starts
    deltas = [pair_starts[i] - pair_starts[i - 1] for i in range(1, len(pair_starts))]
    if len(deltas) >= 2:
        inc = deltas[-1] - deltas[-2]
    else:
        inc = 0
    last_delta = deltas[-1]
    next_start = pair_starts[-1] + last_delta + inc

    # next shape is the next prototype in the ordering
    next_shape_id = pair_shape_ids[-1] + 1
    if next_shape_id >= len(shapes):
        # fallback: if out of prototypes, reuse last
        next_shape_id = len(shapes) - 1

    next_color = blend(pair_colors[-2], pair_colors[-1])

    output = [row[:] for row in input_grid]
    # place new left shape
    shape = shapes[next_shape_id]
    x = next_start
    for (r, c) in shape:
        if 0 <= r < height and 0 <= x + c < width:
            output[r][x + c] = next_color
    mirror_start = x + SW + 1
    for (r, c) in shape:
        mc = mirror_start + (SW - 1 - c)
        if 0 <= r < height and 0 <= mc < width:
            output[r][mc] = next_color

    return output

