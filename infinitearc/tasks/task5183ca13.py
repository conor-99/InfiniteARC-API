# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 5183ca13
Difficulty: very hard

=== Tags ===
- Color by distance to edge
- Folded grid reasoning
- Connect the dots
- Associate images to colors

=== Description ===
The input grids are folded representations of larger grids, where the folding
occurs along a vertical or horizontal axis, causing overlapping regions. Each
cell in the input grid displays a color that visually represents its Manhattan
distance to the nearest edge of the original, unfolded grid (e.g., edge cells
are a light color, mid-grid cells a darker hue, with colors forming a gradient).
The input also contains scattered colored dots at specific positions, where each
color corresponds to a unique geometric shape (e.g., red dots connect to form a
square, blue dots form a triangle, green dots form a circle).   The output grid
must reverse the folding by unfolding the grid along the correct axis
(determined by the pattern of color gradients), restoring each cell’s color to
reflect its true distance to the original grid’s edge. Simultaneously, the
colored dots are connected in sequence using lines of their corresponding color
to form their associated geometric shape. Connections must follow the visual
gradient of the distance colors without overlapping other shapes, with line
paths determined by the direction of the color transitions (e.g., lines follow
the gradient from edge toward the center for closer-to-edge connections). The
folding axis and shape associations are not explicitly labeled, requiring the
solver to infer both from the visual pattern of colors and dot positions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

global all_pairs, current_index
w_values = [i for i in range(8, 31) if i % 2 == 0]
h_values = [i for i in range(8, 31) if i % 2 == 0]
all_pairs = [(w, h) for w in w_values for h in h_values]
random.shuffle(all_pairs)
current_index = 0

def generate():
    global current_index
    w, h = all_pairs[current_index]
    current_index = (current_index + 1) % len(all_pairs)
    dist_grid = [[0]*w for _ in range(h)]
    for r in range(h):
        for c in range(w):
            d = min(r, h-1-r, c, w-1-c)
            dist_grid[r][c] = d
    color_grid = [[min(d + 1, 9) for d in row] for row in dist_grid]
    input_grid = [row[:w//2] for row in color_grid]
    output_grid = color_grid
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    output_grid = []
    for row in input_grid:
        mirrored_row = row[::-1]
        output_row = row + mirrored_row
        output_grid.append(output_row)
    return output_grid
