# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: fba8edf0
Difficulty: hard

=== Tags ===
- Hollow core detection
- Coordinate warp
- Gravity

=== Description ===
Input grids consist of multiple connected shapes (geometric regions formed by
adjacent non-background cells) that may enclose hollow regionsâ€”empty spaces
completely surrounded by a single shape's boundary. The task requires two
primary operations: detecting hollow cores within shapes and applying a
coordinate warp influenced by gravity direction.   First, hollow cores are
identified by locating the largest enclosed empty regions within each shape
(using 4-connectivity to define shape boundaries). For each shape containing a
hollow core, the outer boundary undergoes a coordinate warp that contracts
toward the core's centroid, with the contraction strength amplified in the
direction of a fixed gravity vector (e.g., downward). This creates a non-uniform
distortion where the shape appears "squeezed" toward the core along the gravity
axis.   Second, the entire grid undergoes a gravitational shift: all non-
background cells move strictly in the gravity direction until they collide with
another cell, the grid boundary, or a non-moving obstacle (e.g., a shape without
a hollow core). The shift preserves relative positions of cells within each
shape but may separate previously connected elements.   The output grid reflects
both transformations: warped shapes with their hollow cores visually contracted
toward the gravity-aligned centroid, and all elements shifted downward (or in
the gravity direction) to their final resting positions. The background (color
0) remains unchanged, and no overlapping or self-intersections occur during the
gravitational shift.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import math
from common import grid

def generate():
    # Parameters
    width = random.randint(8, 20)
    height = random.randint(8, 20)
    bg = 0

    # Initialize empty grid
    inp = [[bg for _ in range(width)] for _ in range(height)]

    # Decide number of shapes and colors
    shape_count = random.randint(2, 4)
    colors = random.sample(list(range(1, 10)), shape_count)

    # Decide which shapes are hollow (at least one)
    hollow_flags = [False] * shape_count
    num_hollow = random.randint(1, max(1, shape_count - 1))
    for idx in random.sample(range(shape_count), num_hollow):
        hollow_flags[idx] = True

    placed_shapes = []  # list of dicts: {color, pixels(set), hollow}

    def bbox_intersects(r0, c0, h, w):
        for r in range(r0, r0 + h):
            for c in range(c0, c0 + w):
                if inp[r][c] != bg:
                    return True
        return False

    # Place shapes sequentially, trying to avoid overlap
    for si in range(shape_count):
        color = colors[si]
        is_hollow = hollow_flags[si]
        placed = False
        tries = 0
        while not placed and tries < 200:
            tries += 1
            if is_hollow:
                # Hollow shapes: rectangle border that does not touch grid border
                max_h = min(10, height - 4)
                max_w = min(10, width - 4)
                if max_h < 3 or max_w < 3:
                    # not enough room, fall back to small hollow
                    rect_h = 3
                    rect_w = 3
                else:
                    rect_h = random.randint(3, max_h)
                    rect_w = random.randint(3, max_w)
                r0 = random.randint(1, height - rect_h - 1)
                c0 = random.randint(1, width - rect_w - 1)
                if bbox_intersects(r0, c0, rect_h, rect_w):
                    continue
                # draw border
                pixels = set()
                for r in range(r0, r0 + rect_h):
                    for c in range(c0, c0 + rect_w):
                        if r == r0 or r == r0 + rect_h - 1 or c == c0 or c == c0 + rect_w - 1:
                            inp[r][c] = color
                            pixels.add((r, c))
                placed_shapes.append({"color": color, "pixels": pixels, "hollow": True})
                placed = True
            else:
                # Solid filled rectangle (may touch borders)
                max_h = min(8, height)
                max_w = min(8, width)
                rect_h = random.randint(2, max(3, max_h))
                rect_w = random.randint(2, max(3, max_w))
                r0 = random.randint(0, height - rect_h)
                c0 = random.randint(0, width - rect_w)
                if bbox_intersects(r0, c0, rect_h, rect_w):
                    continue
                pixels = set()
                for r in range(r0, r0 + rect_h):
                    for c in range(c0, c0 + rect_w):
                        inp[r][c] = color
                        pixels.add((r, c))
                placed_shapes.append({"color": color, "pixels": pixels, "hollow": False})
                placed = True
        if not placed:
            # as a fallback, place a single pixel
            for r in range(height):
                for c in range(width):
                    if inp[r][c] == bg:
                        inp[r][c] = color
                        placed_shapes.append({"color": color, "pixels": {(r, c)}, "hollow": False})
                        placed = True
                        break
                if placed: break

    # Ensure at least one hollow shape exists (should by construction)
    if not any(s["hollow"] for s in placed_shapes):
        # convert first shape into hollow by carving a hole if possible
        s = placed_shapes[0]
        s["hollow"] = True
        # Make a small ring at its pixels' bounding box
        rs = [p[0] for p in s["pixels"]]
        cs = [p[1] for p in s["pixels"]]
        if rs and cs:
            r0, r1 = max(1, min(rs)), min(height - 2, max(rs))
            c0, c1 = max(1, min(cs)), min(width - 2, max(cs))
            if r1 - r0 >= 2 and c1 - c0 >= 2:
                # carve interior to bg and draw border
                for r in range(r0, r1 + 1):
                    for c in range(c0, c1 + 1):
                        inp[r][c] = bg
                for r in range(r0, r1 + 1):
                    for c in range(c0, c1 + 1):
                        if r == r0 or r == r1 or c == c0 or c == c1:
                            inp[r][c] = s["color"]
                s["pixels"] = set((r, c) for r in range(r0, r1 + 1) for c in range(c0, c1 + 1) if (r == r0 or r == r1 or c == c0 or c == c1))

    # Transformation parameters (must be mirrored by the solver)
    gravity_dir = (1, 0)  # downward gravity
    warp_factor = 0.30
    gravity_amp = 0.6

    # Helper: get zero-connected components (4-connectivity)
    def zero_components(grid):
        h = len(grid)
        w = len(grid[0])
        visited = [[False] * w for _ in range(h)]
        comps = []
        for r in range(h):
            for c in range(w):
                if grid[r][c] != 0 or visited[r][c]:
                    continue
                # BFS
                stack = [(r, c)]
                comp = []
                visited[r][c] = True
                while stack:
                    rr, cc = stack.pop()
                    comp.append((rr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = rr + dr, cc + dc
                        if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] == 0:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                comps.append(comp)
        return comps

    # Helper: get nonzero connected components with color
    def shape_components(grid):
        h = len(grid)
        w = len(grid[0])
        visited = [[False] * w for _ in range(h)]
        comps = []  # each comp: {color, pixels(list)}
        for r in range(h):
            for c in range(w):
                if grid[r][c] == bg or visited[r][c]:
                    continue
                col = grid[r][c]
                stack = [(r, c)]
                comp = []
                visited[r][c] = True
                while stack:
                    rr, cc = stack.pop()
                    comp.append((rr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = rr + dr, cc + dc
                        if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] == col:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                comps.append({"color": col, "pixels": comp})
        return comps

    # Identify enclosed zero components (those not touching grid border)
    zcomps = zero_components(inp)
    enclosed_z = []
    for comp in zcomps:
        touches_border = any(r == 0 or r == height - 1 or c == 0 or c == width - 1 for r, c in comp)
        if not touches_border:
            enclosed_z.append(comp)

    # Map zero components to the surrounding shape (by majority of neighbor colored pixels)
    mapping_z_to_shape = {}
    shape_comps = shape_components(inp)
    # build quick map from pixel pos to shape index
    pos_to_shape = {}
    for si, sc in enumerate(shape_comps):
        for p in sc["pixels"]:
            pos_to_shape[p] = si

    for zi, zc in enumerate(enclosed_z):
        neighbor_shape_counts = {}
        for (zr, zc0) in zc:
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = zr + dr, zc0 + dc
                if 0 <= nr < height and 0 <= nc < width and inp[nr][nc] != bg:
                    sid = pos_to_shape.get((nr, nc))
                    if sid is not None:
                        neighbor_shape_counts[sid] = neighbor_shape_counts.get(sid, 0) + 1
        if neighbor_shape_counts:
            # assign to the shape with the most adjacent pixels
            sid = max(neighbor_shape_counts.items(), key=lambda x: x[1])[0]
            mapping_z_to_shape[zi] = sid

    # For each shape component, pick the largest enclosed zero assigned to it (if any) and compute centroid
    shape_hollow_centroid = {}  # shape index -> (cy, cx)
    for zi, sid in mapping_z_to_shape.items():
        comp = enclosed_z[zi]
        # find largest for each sid
        if sid not in shape_hollow_centroid:
            shape_hollow_centroid[sid] = (comp)
        else:
            if len(comp) > len(shape_hollow_centroid[sid]):
                shape_hollow_centroid[sid] = comp
    # convert to centroids
    for sid, comp in list(shape_hollow_centroid.items()):
        pts = comp
        cx = sum(p[1] for p in pts) / len(pts)
        cy = sum(p[0] for p in pts) / len(pts)
        shape_hollow_centroid[sid] = (cy, cx)

    # Which shapes are movable? A shape is movable if it has an enclosed hollow core
    movable_shape_colors = set()
    for si, sc in enumerate(shape_comps):
        if si in shape_hollow_centroid:
            movable_shape_colors.add(sc["color"])

    # Warp step: remove movable shapes from working grid and place warped pixels
    warp_grid = [row[:] for row in inp]
    # clear movable shapes
    for si, sc in enumerate(shape_comps):
        if sc["color"] in movable_shape_colors and si in shape_hollow_centroid:
            for (r, c) in sc["pixels"]:
                warp_grid[r][c] = bg

    # We'll place warped pixels into warp_grid with a deterministic nearest-free-cell tie-break
    h = height
    w = width

    def clamp(rr, cc):
        return max(0, min(h - 1, rr)), max(0, min(w - 1, cc))

    # Helper to find nearest free cell (BFS) starting from target
    from collections import deque
    def find_nearest_free(tr, tc, occupied):
        # occupied is a set of (r,c) considered already taken
        if (tr, tc) not in occupied and warp_grid[tr][tc] == bg:
            return tr, tc
        q = deque()
        q.append((tr, tc))
        seen = { (tr, tc) }
        while q:
            rr, cc = q.popleft()
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = rr + dr, cc + dc
                if 0 <= nr < h and 0 <= nc < w and (nr, nc) not in seen:
                    if (nr, nc) not in occupied and warp_grid[nr][nc] == bg:
                        return nr, nc
                    seen.add((nr, nc))
                    q.append((nr, nc))
        return None

    # Place warped pixels
    placed_positions = set()  # keep track of positions we've filled in warp_grid
    for si, sc in enumerate(shape_comps):
        if sc["color"] not in movable_shape_colors or si not in shape_hollow_centroid:
            continue
        cy, cx = shape_hollow_centroid[si]
        for (r, c) in sc["pixels"]:
            v_row = cy - r
            v_col = cx - c
            # amplify vertical component because gravity is down (1,0)
            v_row *= (1.0 + gravity_amp)
            # horizontal unchanged
            # compute displacement
            dr = int(round(v_row * warp_factor))
            dc = int(round(v_col * warp_factor))
            tr, tc = clamp(r + dr, c + dc)
            if (tr, tc) in placed_positions or warp_grid[tr][tc] != bg:
                found = find_nearest_free(tr, tc, placed_positions)
                if found is not None:
                    tr, tc = found
                else:
                    # as fallback, leave it at original position if free
                    if warp_grid[r][c] == bg and (r, c) not in placed_positions:
                        tr, tc = r, c
                    else:
                        # find any free cell
                        found2 = find_nearest_free(r, c, placed_positions)
                        if found2 is None:
                            # give up placing this pixel (should be rare)
                            continue
                        tr, tc = found2
            warp_grid[tr][tc] = sc["color"]
            placed_positions.add((tr, tc))

    # Gravity step: drop connected components that are movable as blocks until they hit obstacles or boundary
    # Build static obstacles occupancy from non-movable colors (these do not move)
    static_occ = set()
    for r in range(h):
        for c in range(w):
            if warp_grid[r][c] != bg and warp_grid[r][c] not in movable_shape_colors:
                static_occ.add((r, c))

    # Build components on warp_grid (post-warp)
    visited = [[False] * w for _ in range(h)]
    comps_post = []  # each comp: (color, pixels(list))
    for r in range(h):
        for c in range(w):
            if warp_grid[r][c] == bg or visited[r][c]:
                continue
            col = warp_grid[r][c]
            stack = [(r, c)]
            comp = []
            visited[r][c] = True
            while stack:
                rr, cc = stack.pop()
                comp.append((rr, cc))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and warp_grid[nr][nc] == col:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            comps_post.append((col, comp))

    # final grid starts with static obstacles
    final = [[bg] * w for _ in range(h)]
    for (r, c) in static_occ:
        final[r][c] = warp_grid[r][c]

    # occupancy per column as sorted list (to quickly find nearest occupied row below)
    occ_cols = {c: sorted([r for (r, cc) in static_occ if cc == c]) for c in range(w)}

    # Process movable components sorted by their lowest pixel first (drop lowest first)
    movable_comps = []
    for col, comp in comps_post:
        if col in movable_shape_colors:
            max_r = max(r for r, _ in comp)
            movable_comps.append((max_r, col, comp))
    movable_comps.sort(reverse=True, key=lambda x: x[0])

    for _, col, comp in movable_comps:
        # group by column to find bottommost in each column
        by_col = {}
        for (r, c) in comp:
            by_col.setdefault(c, []).append(r)
        # compute allowed drop per column
        drop = h  # large
        for c0, rs in by_col.items():
            bottom_r = max(rs)
            occ_list = occ_cols.get(c0, [])
            # find first occupied row > bottom_r
            next_occ = None
            for occ_r in occ_list:
                if occ_r > bottom_r:
                    next_occ = occ_r
                    break
            if next_occ is None:
                allowed = (h - 1) - bottom_r
            else:
                allowed = next_occ - 1 - bottom_r
            if allowed < drop:
                drop = allowed
        if drop < 0:
            drop = 0
        # place component at new positions
        for (r, c) in comp:
            final[r + drop][c] = col
        # update occ_cols
        for c0, rs in by_col.items():
            new_rows = [r0 + drop for r0 in rs]
            occ_cols.setdefault(c0, [])
            # merge and sort
            occ_cols[c0].extend(new_rows)
            occ_cols[c0] = sorted(set(occ_cols[c0]))

    # final output
    out = final

    # ensure input != output; regenerate small chance of equality
    if inp == out:
        # perturb slightly by moving one pixel of the first movable shape down by one if possible
        for si, sc in enumerate(shape_comps):
            if sc["color"] in movable_shape_colors:
                for (r, c) in sc["pixels"]:
                    if r + 1 < h and out[r + 1][c] == bg:
                        out[r][c] = bg
                        out[r + 1][c] = sc["color"]
                        break
                break

    return {"input": inp, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import math
from collections import deque

def p(input_grid):
    # convert to mutable list of lists
    grid_in = [list(row) for row in input_grid]
    h = len(grid_in)
    w = len(grid_in[0])
    bg = 0

    # Transformation parameters (must match generator)
    gravity_dir = (1, 0)
    warp_factor = 0.30
    gravity_amp = 0.6

    # Helpers
    def zero_components(grid):
        visited = [[False] * w for _ in range(h)]
        comps = []
        for r in range(h):
            for c in range(w):
                if grid[r][c] != 0 or visited[r][c]:
                    continue
                stack = [(r, c)]
                comp = []
                visited[r][c] = True
                while stack:
                    rr, cc = stack.pop()
                    comp.append((rr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = rr + dr, cc + dc
                        if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] == 0:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                comps.append(comp)
        return comps

    def shape_components(grid):
        visited = [[False] * w for _ in range(h)]
        comps = []
        for r in range(h):
            for c in range(w):
                if grid[r][c] == bg or visited[r][c]:
                    continue
                col = grid[r][c]
                stack = [(r, c)]
                comp = []
                visited[r][c] = True
                while stack:
                    rr, cc = stack.pop()
                    comp.append((rr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = rr + dr, cc + dc
                        if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] == col:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                comps.append({"color": col, "pixels": comp})
        return comps

    # Step 1: detect enclosed zero components and map them to shapes
    zcomps = zero_components(grid_in)
    enclosed_z = []
    for comp in zcomps:
        if any(r == 0 or r == h - 1 or c == 0 or c == w - 1 for r, c in comp):
            continue
        enclosed_z.append(comp)

    shape_comps = shape_components(grid_in)
    pos_to_shape = {}
    for si, sc in enumerate(shape_comps):
        for p in sc["pixels"]:
            pos_to_shape[p] = si

    mapping_z_to_shape = {}
    for zi, comp in enumerate(enclosed_z):
        neighbor_shape_counts = {}
        for zr, zc in comp:
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = zr + dr, zc + dc
                if 0 <= nr < h and 0 <= nc < w and grid_in[nr][nc] != bg:
                    sid = pos_to_shape.get((nr, nc))
                    if sid is not None:
                        neighbor_shape_counts[sid] = neighbor_shape_counts.get(sid, 0) + 1
        if neighbor_shape_counts:
            sid = max(neighbor_shape_counts.items(), key=lambda x: x[1])[0]
            mapping_z_to_shape[zi] = sid

    shape_hollow_centroid = {}
    for zi, sid in mapping_z_to_shape.items():
        comp = enclosed_z[zi]
        if sid not in shape_hollow_centroid or len(comp) > len(shape_hollow_centroid[sid]):
            shape_hollow_centroid[sid] = comp
    for sid, comp in list(shape_hollow_centroid.items()):
        pts = comp
        cx = sum(p[1] for p in pts) / len(pts)
        cy = sum(p[0] for p in pts) / len(pts)
        shape_hollow_centroid[sid] = (cy, cx)

    movable_shape_colors = set()
    for si, sc in enumerate(shape_comps):
        if si in shape_hollow_centroid:
            movable_shape_colors.add(sc["color"])

    # Warp step
    warp_grid = [row[:] for row in grid_in]
    for si, sc in enumerate(shape_comps):
        if sc["color"] in movable_shape_colors and si in shape_hollow_centroid:
            for (r, c) in sc["pixels"]:
                warp_grid[r][c] = bg

    def clamp(rr, cc):
        return max(0, min(h - 1, rr)), max(0, min(w - 1, cc))

    def find_nearest_free(tr, tc, occupied):
        if (tr, tc) not in occupied and warp_grid[tr][tc] == bg:
            return tr, tc
        q = deque()
        q.append((tr, tc))
        seen = { (tr, tc) }
        while q:
            rr, cc = q.popleft()
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = rr + dr, cc + dc
                if 0 <= nr < h and 0 <= nc < w and (nr, nc) not in seen:
                    if (nr, nc) not in occupied and warp_grid[nr][nc] == bg:
                        return nr, nc
                    seen.add((nr, nc))
                    q.append((nr, nc))
        return None

    placed_positions = set()
    for si, sc in enumerate(shape_comps):
        if sc["color"] not in movable_shape_colors or si not in shape_hollow_centroid:
            continue
        cy, cx = shape_hollow_centroid[si]
        for (r, c) in sc["pixels"]:
            v_row = cy - r
            v_col = cx - c
            v_row *= (1.0 + gravity_amp)
            dr = int(round(v_row * warp_factor))
            dc = int(round(v_col * warp_factor))
            tr, tc = clamp(r + dr, c + dc)
            if (tr, tc) in placed_positions or warp_grid[tr][tc] != bg:
                found = find_nearest_free(tr, tc, placed_positions)
                if found is not None:
                    tr, tc = found
                else:
                    if warp_grid[r][c] == bg and (r, c) not in placed_positions:
                        tr, tc = r, c
                    else:
                        found2 = find_nearest_free(r, c, placed_positions)
                        if found2 is None:
                            continue
                        tr, tc = found2
            warp_grid[tr][tc] = sc["color"]
            placed_positions.add((tr, tc))

    # Gravity step
    static_occ = set()
    for r in range(h):
        for c in range(w):
            if warp_grid[r][c] != bg and warp_grid[r][c] not in movable_shape_colors:
                static_occ.add((r, c))

    visited = [[False] * w for _ in range(h)]
    comps_post = []
    for r in range(h):
        for c in range(w):
            if warp_grid[r][c] == bg or visited[r][c]:
                continue
            col = warp_grid[r][c]
            stack = [(r, c)]
            comp = []
            visited[r][c] = True
            while stack:
                rr, cc = stack.pop()
                comp.append((rr, cc))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and warp_grid[nr][nc] == col:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            comps_post.append((col, comp))

    final = [[bg] * w for _ in range(h)]
    for (r, c) in static_occ:
        final[r][c] = warp_grid[r][c]

    occ_cols = {c: sorted([r for (r, cc) in static_occ if cc == c]) for c in range(w)}

    movable_comps = []
    for col, comp in comps_post:
        if col in movable_shape_colors:
            max_r = max(r for r, _ in comp)
            movable_comps.append((max_r, col, comp))
    movable_comps.sort(reverse=True, key=lambda x: x[0])

    for _, col, comp in movable_comps:
        by_col = {}
        for (r, c) in comp:
            by_col.setdefault(c, []).append(r)
        drop = h
        for c0, rs in by_col.items():
            bottom_r = max(rs)
            occ_list = occ_cols.get(c0, [])
            next_occ = None
            for occ_r in occ_list:
                if occ_r > bottom_r:
                    next_occ = occ_r
                    break
            if next_occ is None:
                allowed = (h - 1) - bottom_r
            else:
                allowed = next_occ - 1 - bottom_r
            if allowed < drop:
                drop = allowed
        if drop < 0:
            drop = 0
        for (r, c) in comp:
            final[r + drop][c] = col
        for c0, rs in by_col.items():
            new_rows = [r0 + drop for r0 in rs]
            occ_cols.setdefault(c0, [])
            occ_cols[c0].extend(new_rows)
            occ_cols[c0] = sorted(set(occ_cols[c0]))

    # If final equals input, apply same small perturbation as generator does
    if final == grid_in:
        for si, sc in enumerate(shape_comps):
            if sc["color"] in movable_shape_colors:
                moved = False
                for (r, c) in sc["pixels"]:
                    if r + 1 < h and final[r + 1][c] == bg:
                        final[r][c] = bg
                        final[r + 1][c] = sc["color"]
                        moved = True
                        break
                if moved:
                    break

    return final

