# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 905b5859
Difficulty: insane

=== Tags ===
- Role dependent behavior
- Simple tile repeat

=== Description ===
Input grids feature a background color (0) alongside multiple distinct non-
background colored tiles. One specific color serves as the "base" pattern (e.g.,
color 5) that must be repeated, while all other non-background colors represent
directional roles (e.g., color 1 = right, color 2 = left, color 3 = up, color 4
= down). The exact mapping between color and direction must be inferred by the
solver through examination of input-output pairs, as it is not explicitly
provided. For every tile of a directional role color, the base pattern is
replicated in the direction specified by its role, starting from the directional
tile's position and propagating outward until grid boundaries or non-background
cells are encountered. Replication occurs only on background cells (0),
preserving all input tiles (directional roles, base pattern, and other non-
background elements) in the output. The transformation requires identifying the
base color, deducing the directional color mapping, and applying directional
replication rules simultaneously across the grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, randint, random_color

# Generator for ARC task: base rectangular pattern + directional tiles that cause repeats
# The generator places a filled rectangular base pattern (base_color) somewhere in the grid.
# It then places one or more directional tiles (colors 1..4) adjacent to the base rectangle.
# Each tile implicitly indicates the cardinal direction by being placed just outside the rectangle on
# the opposite side (so the base rectangle is the immediate neighbor in the indicated direction).
# Replication copies the whole rectangle repeatedly along that cardinal direction in steps equal
# to the rectangle size (so copies sit flush next to each other) until boundaries or non-background
# cells block further copies.


def generate_base_configuration(width, height, H, W):
    """Return a list of candidate top-left positions (r0,c0) such that at least one replication
    is possible from that rectangle (i.e., there is room to place at least one additional
    copy of the rectangle to left/right/up/down in steps of W/H)."""
    candidates = []
    for r0 in range(1, max(2, height - H - 1)):
        for c0 in range(1, max(2, width - W - 1)):
            # count how many block-sized steps fit in each direction
            count_right = 0
            col = c0 + W
            while col + W - 1 < width:
                count_right += 1
                col += W
            count_left = 0
            col = c0 - W
            while col >= 0:
                count_left += 1
                col -= W
            count_down = 0
            row = r0 + H
            while row + H - 1 < height:
                count_down += 1
                row += H
            count_up = 0
            row = r0 - H
            while row >= 0:
                count_up += 1
                row -= H
            if (count_right + count_left + count_up + count_down) >= 1:
                candidates.append((r0, c0, count_right, count_left, count_down, count_up))
    return candidates


def generate():
    # Try repeatedly until a valid configuration is found.
    for _ in range(200):
        width = randint(6, 20)
        height = randint(6, 20)
        # Choose a small rectangular base pattern
        H = randint(1, 3)
        W = randint(1, 3)
        # choose a base color that won't collide with the directional tile palette (1..4)
        base_color = random_color(exclude=[0, 1, 2, 3, 4])

        candidates = generate_base_configuration(width, height, H, W)
        if not candidates:
            continue
        r0, c0, cr, cl, cd, cu = random.choice(candidates)

        # Build input grid and place the filled rectangle
        input_grid = grid(width, height, 0)
        for rr in range(H):
            for cc in range(W):
                input_grid[r0 + rr][c0 + cc] = base_color

        # Determine candidate directional tile positions (one cell outside the rectangle near top-left corner)
        possible_dir_info = []  # tuples (dir_name, tile_pos, max_steps)
        # To encode a tile that means 'right' we put the tile to the left of the rectangle so the rectangle is to its right.
        if c0 - 1 >= 0 and cr > 0 and input_grid[r0][c0 - 1] == 0:
            possible_dir_info.append(("right", (r0, c0 - 1), cr))
        # To encode 'left' place the tile to the right of rectangle
        if c0 + W < width and cl > 0 and input_grid[r0][c0 + W] == 0:
            possible_dir_info.append(("left", (r0, c0 + W), cl))
        # To encode 'down' place tile above rectangle
        if r0 - 1 >= 0 and cd > 0 and input_grid[r0 - 1][c0] == 0:
            possible_dir_info.append(("down", (r0 - 1, c0), cd))
        # To encode 'up' place tile below rectangle
        if r0 + H < height and cu > 0 and input_grid[r0 + H][c0] == 0:
            possible_dir_info.append(("up", (r0 + H, c0), cu))

        if not possible_dir_info:
            # somehow no available directions despite candidate check
            continue

        # Choose a random non-empty subset of these directions, but ensure at least one direction will actually produce
        # at least one replication.
        random.shuffle(possible_dir_info)
        take_count = randint(1, len(possible_dir_info))
        chosen = possible_dir_info[:take_count]

        # Assign distinct colors (from 1..4) to each chosen direction
        tile_colors = [1, 2, 3, 4]
        random.shuffle(tile_colors)
        assignment = {}
        output_grid = [row[:] for row in input_grid]
        for (info, color) in zip(chosen, tile_colors):
            dir_name, tile_pos, maxsteps = info
            tr, tc = tile_pos
            # place the tile color in input (and output copy)
            input_grid[tr][tc] = color
            output_grid[tr][tc] = color
            assignment[color] = dir_name

        # Now apply replication rules to the output grid based on the assigned directions.
        dir_vectors = {"right": (0, 1), "left": (0, -1), "down": (1, 0), "up": (-1, 0)}
        any_added = False
        for color, dir_name in assignment.items():
            dr, dc = dir_vectors[dir_name]
            step_r = dr * H
            step_c = dc * W
            n = 1
            while True:
                anchor_r = r0 + n * step_r
                anchor_c = c0 + n * step_c
                # bounds check: anchor rectangle must fit entirely
                if anchor_r < 0 or anchor_c < 0 or anchor_r + H > height or anchor_c + W > width:
                    break
                # replication only occurs on background cells (0) of the input grid (preserve non-background)
                can_place = True
                for rr in range(H):
                    for cc in range(W):
                        if input_grid[anchor_r + rr][anchor_c + cc] != 0:
                            can_place = False
                            break
                    if not can_place:
                        break
                if not can_place:
                    break
                # place the base_color in the output copy
                any_added = True
                for rr in range(H):
                    for cc in range(W):
                        output_grid[anchor_r + rr][anchor_c + cc] = base_color
                n += 1

        # ensure the output is different from input (we must have added at least one replicated block)
        if not any_added:
            continue

        return {"input": input_grid, "output": output_grid}

    # Fallback: contrive a tiny example if above failed (should be extremely rare)
    width, height = 6, 6
    H, W = 2, 2
    base_color = random_color(exclude=[0, 1, 2, 3, 4])
    input_grid = grid(width, height, 0)
    r0, c0 = 2, 2
    for rr in range(H):
        for cc in range(W):
            input_grid[r0 + rr][c0 + cc] = base_color
    # place a single right-direction tile (color 1) on the left
    input_grid[r0][c0 - 1] = 1
    output_grid = [row[:] for row in input_grid]
    # place one replicated block to the right
    for rr in range(H):
        for cc in range(W):
            output_grid[r0 + rr][c0 + W + cc] = base_color
    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from typing import List, Tuple

def p(input_grid: Tuple[Tuple[int, ...], ...]) -> List[List[int]]:
    # Convert immutable input to a mutable grid
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])

    # First try: base color is any non-tile color (we expect directional tiles to be 1..4).
    counts = {c: 0 for c in range(10)}
    for r in range(height):
        for c in range(width):
            counts[grid_in[r][c]] += 1

    base_color = None
    # prefer colors outside 1..4
    candidates = [(c, counts[c]) for c in range(5, 10) if counts[c] > 0]
    if candidates:
        # pick the most frequent among them (robust even if base is a single cell)
        base_color = max(candidates, key=lambda x: x[1])[0]
    else:
        # fallback to previous rectangle heuristic
        for color in range(1, 10):
            pixels = [(r, c) for r in range(height) for c in range(width) if grid_in[r][c] == color]
            if len(pixels) <= 1:
                continue
            minr = min(r for r, c in pixels)
            maxr = max(r for r, c in pixels)
            minc = min(c for r, c in pixels)
            maxc = max(c for r, c in pixels)
            rect_area = (maxr - minr + 1) * (maxc - minc + 1)
            if rect_area == len(pixels):
                base_color = color
                break
        if base_color is None:
            # ultimate fallback to any non-zero color
            for color in range(1, 10):
                if counts[color] > 0:
                    base_color = color
                    break

    # Determine base rectangle bounds
    pixels = [(r, c) for r in range(height) for c in range(width) if grid_in[r][c] == base_color]
    minr = min(r for r, c in pixels)
    maxr = max(r for r, c in pixels)
    minc = min(c for r, c in pixels)
    maxc = max(c for r, c in pixels)
    base_r, base_c = minr, minc
    H = maxr - minr + 1
    W = maxc - minc + 1

    # Find tiles (directional colors)
    tiles = []  # list of (r,c,color)
    for r in range(height):
        for c in range(width):
            val = grid_in[r][c]
            if val != 0 and val != base_color:
                tiles.append((r, c, val))

    # For each tile color, deduce its direction by checking adjacency to the base_color.
    color_to_vector = {}
    for r, c, val in tiles:
        if val in color_to_vector:
            continue
        found = False
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and grid_in[nr][nc] == base_color:
                color_to_vector[val] = (dr, dc)
                found = True
                break
        if not found:
            # If we cannot find an adjacent sample, infer vector by relative position to the base rectangle
            br, bc = base_r, base_c
            if r < br:
                color_to_vector[val] = (1, 0)
            elif r > br:
                color_to_vector[val] = (-1, 0)
            elif c < bc:
                color_to_vector[val] = (0, 1)
            elif c > bc:
                color_to_vector[val] = (0, -1)
            else:
                color_to_vector[val] = (0, 1)

    # Now produce the output by replicating the filled rectangle along the deduced directions.
    out = [row[:] for row in grid_in]
    for r, c, val in tiles:
        dr, dc = color_to_vector[val]
        # step is whole-rectangle sized so copies sit flush next to each other
        step_r = dr * H
        step_c = dc * W
        n = 1
        while True:
            anchor_r = base_r + n * step_r
            anchor_c = base_c + n * step_c
            # check bounds
            if anchor_r < 0 or anchor_c < 0 or anchor_r + H > height or anchor_c + W > width:
                break
            # replication only on background cells of the input
            can_place = True
            for rr in range(H):
                for cc in range(W):
                    if grid_in[anchor_r + rr][anchor_c + cc] != 0:
                        can_place = False
                        break
                if not can_place:
                    break
            if not can_place:
                break
            for rr in range(H):
                for cc in range(W):
                    out[anchor_r + rr][anchor_c + cc] = base_color
            n += 1

    return out

