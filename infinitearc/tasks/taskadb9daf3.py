# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: adb9daf3
Difficulty: hard

=== Tags ===
- Blockwise rule application
- Staircase construction
- Flow with decay
- Refraction simulation

=== Description ===
Input grids are large (15×15 or larger) with a single background color (0). A
single start cell (color 1) is positioned on the left edge, not adjacent to any
refractor blocks. Scattered throughout the grid are 2×2 refractor blocks (colors
2-9), each color uniquely determining a direction change (e.g., color 2: 90°
clockwise, color 3: 90° counterclockwise, color 4: 180°, color 5: continue
straight, etc.). The flow begins moving right from the start cell. Each step,
the flow moves one cell in its current direction, coloring the cell with the
next color in a fixed sequence (1 → 2 → 3 → ... → 9 → 0 → 1), representing flow
decay. Upon entering any cell of a refractor block, the flow immediately changes
direction according to the block's color and continues. The flow continues until
it exits the grid boundaries. The output grid displays the complete path with
decayed colors, forming a staircase pattern (alternating right/up movements due
to consecutive direction changes), while refractor blocks remain visually
unchanged. The path never overlaps itself or refractor blocks, and all direction
changes strictly follow the refractor color mappings. The staircase pattern
emerges from the consistent alternation of direction changes triggered by the
arrangement of refractor blocks, with color decay providing a visual indicator
of the flow's progression.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    sequence = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
    
    def change_direction(current_dir, color):
        dr, dc = current_dir
        if color == 2:
            return (dc, -dr)
        elif color == 3:
            return (-dc, dr)
        elif color == 4:
            return (-dr, -dc)
        else:
            return (dr, dc)
    
    while True:
        width = random.randint(15, 30)
        height = random.randint(15, 30)
        input_grid = grid(width, height, 0)
        start_row = random.randint(5, height - 6)
        input_grid[start_row][0] = 1
        
        refractors = []
        max_refractors = random.randint(3, 5)
        for _ in range(max_refractors):
            color = random.randint(2, 9)
            placed = False
            while not placed:
                r = random.randint(0, height - 2)
                c = random.randint(2, width - 2)
                valid = True
                for (r0, c0, _) in refractors:
                    if r <= r0 + 1 and r + 1 >= r0 and c <= c0 + 1 and c + 1 >= c0:
                        valid = False
                        break
                if valid:
                    for dr in [0, 1]:
                        for dc in [0, 1]:
                            input_grid[r + dr][c + dc] = color
                    refractors.append((r, c, color))
                    placed = True
        
        output_grid = [row[:] for row in input_grid]
        direction = (0, 1)
        color_idx = 0
        current_r, current_c = start_row, 0
        step_count = 0
        max_steps = 1000
        while step_count < max_steps:
            nr = current_r + direction[0]
            nc = current_c + direction[1]
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                break
            cell_color = input_grid[nr][nc]
            if 2 <= cell_color <= 9:
                direction = change_direction(direction, cell_color)
                color_idx = (color_idx + 1) % len(sequence)
            else:
                next_color_idx = (color_idx + 1) % len(sequence)
                output_grid[nr][nc] = sequence[next_color_idx]
                color_idx = next_color_idx
            current_r, current_c = nr, nc
            step_count += 1
        
        if step_count < max_steps:
            return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    sequence = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
    
    def change_direction(current_dir, color):
        dr, dc = current_dir
        if color == 2:
            return (dc, -dr)
        elif color == 3:
            return (-dc, dr)
        elif color == 4:
            return (-dr, -dc)
        else:
            return (dr, dc)
    
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    
    start_row = None
    for r in range(height):
        if input_grid[r][0] == 1:
            start_row = r
            break
    if start_row is None:
        return input_grid
    
    current_r, current_c = start_row, 0
    direction = (0, 1)
    color_idx = 0
    output_grid = [row[:] for row in input_grid]
    
    step_count = 0
    max_steps = 1000
    while step_count < max_steps:
        nr = current_r + direction[0]
        nc = current_c + direction[1]
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        cell_color = input_grid[nr][nc]
        if 2 <= cell_color <= 9:
            direction = change_direction(direction, cell_color)
            color_idx = (color_idx + 1) % len(sequence)
        else:
            next_color_idx = (color_idx + 1) % len(sequence)
            output_grid[nr][nc] = sequence[next_color_idx]
            color_idx = next_color_idx
        current_r, current_c = nr, nc
        step_count += 1
    
    return output_grid
