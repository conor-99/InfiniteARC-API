# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 4f91bded
Difficulty: hard

=== Tags ===
- Associate images to bools
- Substitution rule discovery
- Take complement

=== Description ===
The input grids are 2D arrays of integers from 0 to 9. Each grid contains a
single connected region (the "image") formed by a specific color, which is the
largest such region in terms of pixel count (using 4-directional connectivity).
The output grid is generated by identifying this image region and applying a
substitution rule: all cells within the image are replaced with 0, while all
other cells are replaced with 1. This process requires discovering the image's
color through its connectivity and size, associating it with a boolean (true for
the image, false elsewhere), and then taking the complement of this boolean mask
(inverting true/false values to 0/1 in the output). The task demands recognizing
the largest connected component as the image and applying the complement
substitution rule, making it challenging due to the need for connectivity
analysis and rule generalization across varying grid structures.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import continuous_creature, grid

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    total = width * height
    image_size = total // 2 + 1
    if image_size < 1:
        image_size = 1
    image_pixels = continuous_creature(image_size, width, height)
    image_color = random.randint(1, 9)
    input_grid = grid(width, height, 0)
    for r, c in image_pixels:
        input_grid[r][c] = image_color
    output_grid = grid(width, height, 1)
    for r, c in image_pixels:
        output_grid[r][c] = 0
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid or not input_grid[0]:
        return []
    width = len(input_grid[0])
    height = len(input_grid)
    visited = [[False] * width for _ in range(height)]
    max_size = 0
    target_color = None

    for r in range(height):
        for c in range(width):
            if not visited[r][c]:
                color = input_grid[r][c]
                queue = [(r, c)]
                visited[r][c] = True
                component = []
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                size = len(component)
                if size > max_size:
                    max_size = size
                    target_color = color
    output_grid = [[1] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == target_color:
                output_grid[r][c] = 0
    return output_grid
