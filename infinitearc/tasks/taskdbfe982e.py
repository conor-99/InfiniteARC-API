# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: dbfe982e
Difficulty: very hard

=== Tags ===
- Cooperative rule network
- Color matching
- Holes

=== Description ===
Input grids feature a background color (0) and multiple contiguous colored
regions (1-9) arranged in a complex, interconnected pattern. Within this
pattern, "holes" are defined as 2×2 blocks of background cells completely
enclosed by colored regions on all four sides (top, bottom, left, right), with
no adjacency to grid edges or other background regions. Each hole is bordered by
four distinct colored strips: the top border (cells directly above the hole),
bottom border (below), left border (to the left), and right border (to the
right), each strip being a single solid color. The colored regions forming the
borders are contiguous and do not overlap with other regions.  The output grid
is generated by replacing each hole with a 2×2 block of color determined by a
cooperative rule network: the fill color is the most frequently occurring border
color among the four borders. In cases of ties (e.g., two colors appear twice),
the tiebreaker prioritizes colors in the order: red (2) > blue (1) > green (3) >
yellow (4) > other colors (5-9). This rule is applied independently to each
hole, ensuring deterministic transformation. The surrounding regions, non-hole
background cells, and grid geometry remain unchanged. The task requires
recognizing enclosed holes, identifying border colors, and applying the tie-
breaking hierarchy to fill the holes with the correct color, making it
challenging due to the need to process multiple overlapping border color
relationships across a large, intricate grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

from common import grid
import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = grid(width, height, 0)
    
    num_holes = random.randint(1, 5)
    for _ in range(num_holes):
        max_retries = 10
        for _ in range(max_retries):
            r = random.randint(1, height - 3)
            c = random.randint(1, width - 3)
            
            if input_grid[r-1][c] != 0 or input_grid[r-1][c+1] != 0:
                continue
            if input_grid[r+2][c] != 0 or input_grid[r+2][c+1] != 0:
                continue
            if input_grid[r][c-1] != 0 or input_grid[r+1][c-1] != 0:
                continue
            if input_grid[r][c+2] != 0 or input_grid[r+1][c+2] != 0:
                continue
            
            T = random.randint(1, 9)
            B = random.randint(1, 9)
            L = random.randint(1, 9)
            R = random.randint(1, 9)
            
            input_grid[r-1][c] = T
            input_grid[r-1][c+1] = T
            input_grid[r+2][c] = B
            input_grid[r+2][c+1] = B
            input_grid[r][c-1] = L
            input_grid[r+1][c-1] = L
            input_grid[r][c+2] = R
            input_grid[r+1][c+2] = R
            
            break
        else:
            continue
    
    output_grid = [row[:] for row in input_grid]
    
    for r in range(1, height - 2):
        for c in range(1, width - 2):
            if input_grid[r][c] == 0 and input_grid[r][c+1] == 0 and input_grid[r+1][c] == 0 and input_grid[r+1][c+1] == 0:
                if input_grid[r-1][c] != 0 and input_grid[r-1][c+1] != 0 and \
                   input_grid[r+2][c] != 0 and input_grid[r+2][c+1] != 0 and \
                   input_grid[r][c-1] != 0 and input_grid[r+1][c-1] != 0 and \
                   input_grid[r][c+2] != 0 and input_grid[r+1][c+2] != 0:
                    
                    T = input_grid[r-1][c]
                    B = input_grid[r+2][c]
                    L = input_grid[r][c-1]
                    R = input_grid[r][c+2]
                    
                    colors = [T, B, L, R]
                    color_count = {color: colors.count(color) for color in set(colors)}
                    max_count = max(color_count.values())
                    candidates = [color for color in set(colors) if color_count[color] == max_count]
                    
                    priority_order = [2, 1, 3, 4, 5, 6, 7, 8, 9]
                    fill_color = next((color for color in priority_order if color in candidates), T)
                    
                    output_grid[r][c] = fill_color
                    output_grid[r][c+1] = fill_color
                    output_grid[r+1][c] = fill_color
                    output_grid[r+1][c+1] = fill_color
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    
    for r in range(1, height - 2):
        for c in range(1, width - 2):
            if grid[r][c] == 0 and grid[r][c+1] == 0 and grid[r+1][c] == 0 and grid[r+1][c+1] == 0:
                if grid[r-1][c] != 0 and grid[r-1][c+1] != 0 and \
                   grid[r+2][c] != 0 and grid[r+2][c+1] != 0 and \
                   grid[r][c-1] != 0 and grid[r+1][c-1] != 0 and \
                   grid[r][c+2] != 0 and grid[r+1][c+2] != 0:
                    
                    T = grid[r-1][c]
                    B = grid[r+2][c]
                    L = grid[r][c-1]
                    R = grid[r][c+2]
                    
                    colors = [T, B, L, R]
                    color_count = {}
                    for color in colors:
                        color_count[color] = color_count.get(color, 0) + 1
                    max_count = max(color_count.values())
                    candidates = [color for color in colors if color_count[color] == max_count]
                    
                    priority_order = [2, 1, 3, 4, 5, 6, 7, 8, 9]
                    fill_color = next((color for color in priority_order if color in candidates), T)
                    
                    grid[r][c] = fill_color
                    grid[r][c+1] = fill_color
                    grid[r+1][c] = fill_color
                    grid[r+1][c+1] = fill_color
    
    return tuple(tuple(row) for row in grid)
