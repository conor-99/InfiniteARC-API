# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 9ad8f9eb
Difficulty: insane

=== Tags ===
- Recursive path tracing
- Dual source paths

=== Description ===
Input grids feature a uniform background color (e.g., gray) and two distinct
colored sources (e.g., red at top-left and blue at bottom-right) positioned at
opposite corners. The grid contains scattered obstacle cells of varying colors
that block path propagation. From each source, paths propagate in all four
cardinal directions (up, down, left, right) until encountering an obstacle, grid
edge, or non-background cell. When a red path segment (originating from the top-
left source) and a blue path segment (originating from the bottom-right source)
occupy the same cell, they trigger a recursive interaction: a new purple path
segment is generated that propagates diagonally in the direction determined by
the relative positions of the colliding paths (e.g., NE if red approached
horizontally from the left and blue vertically from below). This purple path
segment then becomes a secondary source, initiating its own propagation in four
cardinal directions, which may collide with other paths to generate additional
diagonal segments. The process repeats recursively—each new diagonal segment can
collide with existing paths to spawn further diagonals—until no more collisions
occur. All path segments (red, blue, purple) are drawn exclusively on background
cells, preserving obstacles and background. The output grid displays the final
configuration after all recursive propagation ceases, with no overlapping paths
and all segments clearly distinguishable by their originating color. The
transformation requires detecting source positions, simulating multi-level path
interactions, and resolving recursive dependencies through spatial reasoning
rather than numerical computation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, all_pixels

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    
    # Create background grid (gray = 5)
    input_grid = grid(width, height, 5)
    
    # Place red source at (0,0)
    input_grid[0][0] = 2  # red
    
    # Place blue source at (bottom-right)
    input_grid[height-1][width-1] = 1  # blue
    
    # Place obstacles (random colors 3-9, not 1,2,5)
    for _ in range(random.randint(5, 15)):
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        if (r, c) != (0, 0) and (r, c) != (height-1, width-1):
            input_grid[r][c] = random.randint(3, 9)
    
    # Create output grid by simulating paths
    output_grid = [row[:] for row in input_grid]
    
    # Propagate red path from (0,0)
    red_path = [[False] * width for _ in range(height)]
    queue = [(0, 0)]
    red_path[0][0] = True
    while queue:
        r, c = queue.pop(0)
        for dr, dc in [(-1, 0), (1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not red_path[nr][nc] and input_grid[nr][nc] == 5:
                red_path[nr][nc] = True
                queue.append((nr, nc))

    # Propagate blue path from (bottom-right)
    blue_path = [[False] * width for _ in range(height)]
    queue = [(height-1, width-1)]
    blue_path[height-1][width-1] = True
    while queue:
        r, c = queue.pop(0)
        for dr, dc in [(-1, 0), (1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not blue_path[nr][nc] and input_grid[nr][nc] == 5:
                blue_path[nr][nc] = True
                queue.append((nr, nc))

    # Mark red and blue paths
    for r in range(height):
        for c in range(width):
            if red_path[r][c] and blue_path[r][c]:
                output_grid[r][c] = 3  # purple
            elif red_path[r][c]:
                output_grid[r][c] = 2
            elif blue_path[r][c]:
                output_grid[r][c] = 1

    # Handle purple propagation from collisions
    purple_queue = []
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] == 3:
                # Determine direction from red and blue paths
                red_dir = None
                for dr, dc in [(-1, 0), (1, 0), (0, 1), (0, -1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and red_path[nr][nc]:
                        red_dir = (dr, dc)
                        break
                blue_dir = None
                for dr, dc in [(-1, 0), (1, 0), (0, 1), (0, -1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and blue_path[nr][nc]:
                        blue_dir = (dr, dc)
                        break
                if red_dir and blue_dir:
                    dx = 1 if red_dir[1] > 0 else -1
                    dy = 1 if blue_dir[0] > 0 else -1
                    purple_queue.append((r, c, dx, dy))

    while purple_queue:
        r, c, dx, dy = purple_queue.pop(0)
        nr, nc = r + dx, c + dy
        while 0 <= nr < height and 0 <= nc < width and output_grid[nr][nc] == 5:
            output_grid[nr][nc] = 3
            if red_path[nr][nc] or blue_path[nr][nc]:
                # New collision point
                red_dir = None
                for dr, dc in [(-1, 0), (1, 0), (0, 1), (0, -1)]:
                    nr2, nc2 = nr + dr, nc + dc
                    if 0 <= nr2 < height and 0 <= nc2 < width and red_path[nr2][nc2]:
                        red_dir = (dr, dc)
                        break
                blue_dir = None
                for dr, dc in [(-1, 0), (1, 0), (0, 1), (0, -1)]:
                    nr2, nc2 = nr + dr, nc + dc
                    if 0 <= nr2 < height and 0 <= nc2 < width and blue_path[nr2][nc2]:
                        blue_dir = (dr, dc)
                        break
                if red_dir and blue_dir:
                    dx2 = 1 if red_dir[1] > 0 else -1
                    dy2 = 1 if blue_dir[0] > 0 else -1
                    purple_queue.append((nr, nc, dx2, dy2))
            nr += dx
            nc += dy
    
    return {
        'input': input_grid,
        'output': output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])
    BG = 5
    
    # Track red and blue paths
    red_path = [[False] * w for _ in range(h)]
    blue_path = [[False] * w for _ in range(h)]
    directions = [(-1, 0), (1, 0), (0, 1), (0, -1)]
    
    # Propagate red from (0,0)
    queue = [(0, 0)]
    red_path[0][0] = True
    while queue:
        r, c = queue.pop(0)
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            if 0 <= nr < h and 0 <= nc < w and not red_path[nr][nc] and grid[nr][nc] == BG:
                red_path[nr][nc] = True
                queue.append((nr, nc))
    
    # Propagate blue from (h-1, w-1)
    queue = [(h-1, w-1)]
    blue_path[h-1][w-1] = True
    while queue:
        r, c = queue.pop(0)
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            if 0 <= nr < h and 0 <= nc < w and not blue_path[nr][nc] and grid[nr][nc] == BG:
                blue_path[nr][nc] = True
                queue.append((nr, nc))
    
    # Create output grid as copy of input
    output = [row[:] for row in grid]
    for r in range(h):
        for c in range(w):
            if red_path[r][c] and blue_path[r][c]:
                output[r][c] = 3
            elif red_path[r][c]:
                output[r][c] = 2
            elif blue_path[r][c]:
                output[r][c] = 1
    
    # Handle purple propagation from collisions
    purple_queue = []
    for r in range(h):
        for c in range(w):
            if output[r][c] == 3:
                # Determine red and blue directions
                red_dir = None
                for dr, dc in directions:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < h and 0 <= nc < w and red_path[nr][nc]:
                        red_dir = (dr, dc)
                        break
                blue_dir = None
                for dr, dc in directions:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < h and 0 <= nc < w and blue_path[nr][nc]:
                        blue_dir = (dr, dc)
                        break
                if red_dir and blue_dir:
                    dx = 1 if red_dir[1] > 0 else -1
                    dy = 1 if blue_dir[0] > 0 else -1
                    purple_queue.append((r, c, dx, dy))
    
    while purple_queue:
        r, c, dx, dy = purple_queue.pop(0)
        nr, nc = r + dx, c + dy
        while 0 <= nr < h and 0 <= nc < w and output[nr][nc] == BG:
            output[nr][nc] = 3
            if red_path[nr][nc] or blue_path[nr][nc]:
                # New collision
                red_dir = None
                for dr, dc in directions:
                    nr2, nc2 = nr + dr, nc + dc
                    if 0 <= nr2 < h and 0 <= nc2 < w and red_path[nr2][nc2]:
                        red_dir = (dr, dc)
                        break
                blue_dir = None
                for dr, dc in directions:
                    nr2, nc2 = nr + dr, nc + dc
                    if 0 <= nr2 < h and 0 <= nc2 < w and blue_path[nr2][nc2]:
                        blue_dir = (dr, dc)
                        break
                if red_dir and blue_dir:
                    dx2 = 1 if red_dir[1] > 0 else -1
                    dy2 = 1 if blue_dir[0] > 0 else -1
                    purple_queue.append((nr, nc, dx2, dy2))
            nr += dx
            nc += dy
    
    return tuple(tuple(row) for row in output)
