# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 84f0f078
Difficulty: medium–hard

=== Tags ===
- Rule switch on context
- Pattern juxtaposition
- Homeomorphism

=== Description ===
Contextual Shape Morphology  Input grids are large (at least 20×20) with a
uniform background color (0). The grid contains multiple "main" shapes, each a
connected region of a single non-background color (1-9), and "context" shapes,
each a connected region of a distinct non-background color (1-9) positioned
immediately to the right of each main shape. The context color determines a
geometric transformation to be applied to the main shape: color 5 rotates the
main shape 90° clockwise, color 6 reflects it vertically, color 7 reflects it
horizontally, and color 8 rotates 180°. The output grid displays all main shapes
transformed according to their context's color, with context shapes and
background unchanged. Transformations are applied locally to each main shape's
bounding box, preserving connectivity. No two main shapes overlap, and context
shapes do not overlap with main shapes or each other. The transformation rules
switch based on context color, creating visual pattern juxtaposition between
main and context shapes. The transformed main shapes maintain topological
equivalence (homeomorphism) with their original shapes through the geometric
operations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

# Generator for ARC task 452: Contextual Shape Morphology
# Produces large grids (20-30) with multiple main shapes and an immediate
# context column to the right that determines a local geometric transform.

MAIN_COLORS = [1, 2, 3, 4, 9]
CONTEXT_COLORS = [5, 6, 7, 8]


def _transform_grid(ingrid):
    """Deterministic transform: finds main shapes and applies transforms
    according to the context color immediately to the right of each shape's
    rightmost column. This function is used both by the generator (to create
    the output) and by the solver (to compute the expected output).
    """
    h = len(ingrid)
    w = len(ingrid[0])
    out = [row[:] for row in ingrid]

    visited = [[False] * w for _ in range(h)]

    for r0 in range(h):
        for c0 in range(w):
            color = ingrid[r0][c0]
            if color not in MAIN_COLORS or visited[r0][c0]:
                continue

            # BFS to collect connected component of this main color
            queue = [(r0, c0)]
            comp = []
            visited[r0][c0] = True
            qi = 0
            while qi < len(queue):
                cr, cc = queue[qi]
                qi += 1
                comp.append((cr, cc))
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and ingrid[nr][nc] == color:
                        visited[nr][nc] = True
                        queue.append((nr, nc))

            if not comp:
                continue

            min_r = min(r for (r, c) in comp)
            max_r = max(r for (r, c) in comp)
            min_c = min(c for (r, c) in comp)
            max_c = max(c for (r, c) in comp)

            # Build a square local array whose side is the larger of the two dimensions.
            s_r = max_r - min_r + 1
            s_c = max_c - min_c + 1
            s = max(s_r, s_c)

            local = [[0] * s for _ in range(s)]
            for (pr, pc) in comp:
                local[pr - min_r][pc - min_c] = 1

            # Determine the context color: look immediately to the right of the rightmost column
            context = None
            if max_c + 1 < w:
                # Prefer a context cell that is adjacent to an actual rightmost pixel
                for (pr, pc) in comp:
                    if pc == max_c and ingrid[pr][max_c + 1] in CONTEXT_COLORS:
                        context = ingrid[pr][max_c + 1]
                        break
                # fallback: check the bounding rows to the right
                if context is None:
                    for rr in range(min_r, max_r + 1):
                        if ingrid[rr][max_c + 1] in CONTEXT_COLORS:
                            context = ingrid[rr][max_c + 1]
                            break

            if context is None:
                # No context found, leave the shape unchanged
                continue

            # Clear the original main pixels in the output (but never clear context colors)
            for (pr, pc) in comp:
                if out[pr][pc] == color:
                    out[pr][pc] = 0

            # Apply transformation inside the square local box and write back
            for lr in range(s):
                for lc in range(s):
                    if not local[lr][lc]:
                        continue
                    if context == 5:
                        # rotate 90 deg clockwise: (r,c) -> (c, s-1-r)
                        nr_local, nc_local = lc, s - 1 - lr
                    elif context == 6:
                        # reflect vertically (top <-> bottom)
                        nr_local, nc_local = s - 1 - lr, lc
                    elif context == 7:
                        # reflect horizontally (left <-> right)
                        nr_local, nc_local = lr, s - 1 - lc
                    elif context == 8:
                        # rotate 180
                        nr_local, nc_local = s - 1 - lr, s - 1 - lc
                    else:
                        nr_local, nc_local = lr, lc

                    nr = min_r + nr_local
                    nc = min_c + nc_local
                    # Do not overwrite context cells
                    if 0 <= nr < h and 0 <= nc < w and out[nr][nc] not in CONTEXT_COLORS:
                        out[nr][nc] = color

    return out


def generate():
    # Create a large empty grid
    width = random.randint(20, 30)
    height = random.randint(20, 30)
    grid_in = common.grid(width, height, 0)

    occupancy = [[False] * width for _ in range(height)]

    num_shapes = random.randint(2, 5)

    placements = []
    attempts = 0
    # Try to place non-overlapping square bounding boxes (with an extra column for the context)
    while len(placements) < num_shapes and attempts < 2000:
        attempts += 1
        # square side
        max_box = min(8, width - 3, height - 3)
        if max_box < 3:
            break
        s = random.randint(3, max_box)

        r0 = random.randint(0, height - s)
        c0 = random.randint(0, width - s - 1)  # leave space for the context column at c0 + s

        # Ensure bounding area and the context column are free
        conflict = False
        for rr in range(r0, r0 + s):
            for cc in range(c0, c0 + s + 1):
                if occupancy[rr][cc]:
                    conflict = True
                    break
            if conflict:
                break
        if conflict:
            continue

        # create a contiguous creature inside s x s
        max_cells = s * s
        min_cells = max(3, max_cells // 6)
        cell_count = random.randint(min_cells, max_cells - 1)
        rel_pixels = common.continuous_creature(cell_count, width=s, height=s)

        # Ensure the shape touches the rightmost column of its bounding box so the context
        # column at c0 + s is immediately to the right of at least one main pixel.
        if not any(pc == s - 1 for (pr, pc) in rel_pixels):
            current_max_c = max(pc for (pr, pc) in rel_pixels)
            rows_with = [pr for (pr, pc) in rel_pixels if pc == current_max_c]
            anchor_row = random.choice(rows_with)
            for extra_c in range(current_max_c + 1, s):
                rel_pixels.append((anchor_row, extra_c))

        # Deduplicate and map to absolute coordinates
        seen = set()
        abs_pixels = []
        for (pr, pc) in rel_pixels:
            key = (pr, pc)
            if key in seen:
                continue
            seen.add(key)
            abs_pixels.append((r0 + pr, c0 + pc))

        # Verify no collisions
        if any(occupancy[r][c] for (r, c) in abs_pixels):
            continue

        # Colors
        main_color = random.choice(MAIN_COLORS)
        context_color = random.choice(CONTEXT_COLORS)

        # Place main pixels
        for (r, c) in abs_pixels:
            grid_in[r][c] = main_color
            occupancy[r][c] = True

        # Place context as a connected vertical column immediately to the right of the bounding box
        context_col = c0 + s
        for rr in range(r0, r0 + s):
            grid_in[rr][context_col] = context_color
            occupancy[rr][context_col] = True

        placements.append((r0, c0, s, main_color, context_color, abs_pixels))

    # If not enough shapes were placed, fall back to a simple deterministic placement
    if len(placements) < 2:
        grid_in = common.grid(width, height, 0)
        placements = []
        occupancy = [[False] * width for _ in range(height)]
        fixed = [((2, 2), 3, MAIN_COLORS[0], CONTEXT_COLORS[0]), ((8, 6), 4, MAIN_COLORS[1], CONTEXT_COLORS[1])]
        for (r0, c0), s, main_color, context_color in fixed:
            rel_pixels = common.continuous_creature(max(3, s * s // 3), width=s, height=s)
            # ensure rightmost contact
            if not any(pc == s - 1 for (pr, pc) in rel_pixels):
                current_max_c = max(pc for (pr, pc) in rel_pixels)
                rows_with = [pr for (pr, pc) in rel_pixels if pc == current_max_c]
                anchor_row = rows_with[0]
                for extra_c in range(current_max_c + 1, s):
                    rel_pixels.append((anchor_row, extra_c))
            seen = set()
            abs_pixels = []
            for (pr, pc) in rel_pixels:
                if (pr, pc) in seen:
                    continue
                seen.add((pr, pc))
                abs_pixels.append((r0 + pr, c0 + pc))
            for (r, c) in abs_pixels:
                grid_in[r][c] = main_color
            for rr in range(r0, r0 + s):
                grid_in[rr][c0 + s] = context_color
            placements.append((r0, c0, s, main_color, context_color, abs_pixels))

    # Deterministically compute output from the input
    grid_out = _transform_grid(grid_in)

    return {"input": grid_in, "output": grid_out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert tuple-of-tuples input to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    MAIN_COLORS = [1, 2, 3, 4, 9]
    CONTEXT_COLORS = [5, 6, 7, 8]

    out = [row[:] for row in grid]
    visited = [[False] * width for _ in range(height)]

    for r0 in range(height):
        for c0 in range(width):
            color = grid[r0][c0]
            if color not in MAIN_COLORS or visited[r0][c0]:
                continue

            # BFS to get connected component of the main shape
            queue = [(r0, c0)]
            comp = []
            visited[r0][c0] = True
            qi = 0
            while qi < len(queue):
                cr, cc = queue[qi]
                qi += 1
                comp.append((cr, cc))
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                        visited[nr][nc] = True
                        queue.append((nr, nc))

            if not comp:
                continue

            min_r = min(r for (r, c) in comp)
            max_r = max(r for (r, c) in comp)
            min_c = min(c for (r, c) in comp)
            max_c = max(c for (r, c) in comp)

            s_r = max_r - min_r + 1
            s_c = max_c - min_c + 1
            s = max(s_r, s_c)

            # local square representation
            local = [[0] * s for _ in range(s)]
            for (pr, pc) in comp:
                local[pr - min_r][pc - min_c] = 1

            # Determine context color to the right of the rightmost column
            context = None
            if max_c + 1 < width:
                for (pr, pc) in comp:
                    if pc == max_c and grid[pr][max_c + 1] in CONTEXT_COLORS:
                        context = grid[pr][max_c + 1]
                        break
                if context is None:
                    for rr in range(min_r, max_r + 1):
                        if grid[rr][max_c + 1] in CONTEXT_COLORS:
                            context = grid[rr][max_c + 1]
                            break

            if context is None:
                # No context found; leave shape as-is
                continue

            # Clear original main pixels (do not clear context cells)
            for (pr, pc) in comp:
                if out[pr][pc] == color:
                    out[pr][pc] = 0

            # Apply the requested transform inside the local square and write back
            for lr in range(s):
                for lc in range(s):
                    if not local[lr][lc]:
                        continue
                    if context == 5:
                        nr_local, nc_local = lc, s - 1 - lr
                    elif context == 6:
                        nr_local, nc_local = s - 1 - lr, lc
                    elif context == 7:
                        nr_local, nc_local = lr, s - 1 - lc
                    elif context == 8:
                        nr_local, nc_local = s - 1 - lr, s - 1 - lc
                    else:
                        nr_local, nc_local = lr, lc

                    nr = min_r + nr_local
                    nc = min_c + nc_local

                    if 0 <= nr < height and 0 <= nc < width and out[nr][nc] not in CONTEXT_COLORS:
                        out[nr][nc] = color

    return out

