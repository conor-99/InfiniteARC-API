# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 1c785e00
Difficulty: medium

=== Tags ===
- Tiled majority vote
- Concentric

=== Description ===
The task involves transforming an input grid into an output grid where each
concentric layer (defined by Chebyshev distance from the grid's center) is
filled with the majority color present in the corresponding layer of the input
grid. The majority color for a layer is determined by the most frequently
occurring color (including zero) within that layer. The output grid preserves
the grid dimensions and structure, with each cell set to the majority color of
its concentric layer. This process requires identifying concentric rings around
the grid's center, computing the dominant color in each ring, and applying it
uniformly across the ring in the output. The task tests the ability to recognize
spatial patterns and apply consistent majority-based transformations across
layered structures.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import defaultdict

def generate():
    width = random.randint(2, 30)
    height = random.randint(2, 30)
    input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
    
    def compute_output(grid):
        height = len(grid)
        width = len(grid[0])
        layers = defaultdict(list)
        for r in range(height):
            for c in range(width):
                d_val = max(abs(2*c - (width-1)), abs(2*r - (height-1)))
                d = d_val // 2
                layers[d].append(grid[r][c])
        
        majority_colors = {}
        for d, colors in layers.items():
            count = {}
            for color in colors:
                count[color] = count.get(color, 0) + 1
            max_count = max(count.values())
            candidates = [color for color, cnt in count.items() if cnt == max_count]
            candidates.sort()
            majority_colors[d] = candidates[0]
        
        output = [[0] * width for _ in range(height)]
        for r in range(height):
            for c in range(width):
                d_val = max(abs(2*c - (width-1)), abs(2*r - (height-1)))
                d = d_val // 2
                output[r][c] = majority_colors[d]
        return output
    
    output_grid = compute_output(input_grid)
    if input_grid == output_grid:
        for _ in range(10):
            input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
            output_grid = compute_output(input_grid)
            if input_grid != output_grid:
                break
        else:
            input_grid[0][0] = (input_grid[0][0] + 1) % 10
            output_grid = compute_output(input_grid)
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import defaultdict

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    layers = defaultdict(list)
    for r in range(height):
        for c in range(width):
            d_val = max(abs(2*c - (width-1)), abs(2*r - (height-1)))
            d = d_val // 2
            layers[d].append(input_grid[r][c])
    
    majority_colors = {}
    for d, colors in layers.items():
        count = {}
        for color in colors:
            count[color] = count.get(color, 0) + 1
        max_count = max(count.values())
        candidates = [color for color, cnt in count.items() if cnt == max_count]
        candidates.sort()
        majority_colors[d] = candidates[0]
    
    output = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            d_val = max(abs(2*c - (width-1)), abs(2*r - (height-1)))
            d = d_val // 2
            output[r][c] = majority_colors[d]
    return output
