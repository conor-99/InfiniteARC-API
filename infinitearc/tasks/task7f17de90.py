# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 7f17de90
Difficulty: mediumâ€“hard

=== Tags ===
- Connect components by property
- Field interference pattern
- Detect hor lines
- Recolor

=== Description ===
The input grid features a background color (0), horizontal lines (a distinct
color, e.g., gray), and scattered colored components (1-4) distributed across
the regions between these horizontal lines. Each component is a single cell. The
task requires connecting components of identical color within the same
horizontal band (the region bounded by two consecutive horizontal lines) using
horizontal lines of their color. For components of the same color in different
bands, vertical connections must be drawn through the horizontal lines; each
vertical segment crossing a horizontal line changes to the horizontal line's
color for all subsequent segments. The output grid retains all input elements
(background, horizontal lines, components) but overlays these connections as new
lines on the background, with colors dynamically adjusted upon crossing
horizontal lines. Connections never overlap, and all paths terminate at valid
component locations without intersecting other connections. The transformation
relies on detecting horizontal bands, identifying component groupings by color,
and applying field interference rules (color change upon horizontal line
traversal) to generate the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

# Generator for ARC task: connect components by color within horizontal bands

def generate():
    # Grid size
    width = random.randint(7, 20)
    height = random.randint(7, 20)
    HL = 5  # horizontal line color (distinct)

    # Initialize input grid with background 0
    grid_input = [[0 for _ in range(width)] for _ in range(height)]

    # Place a random number of full-row horizontal lines (not on first/last row)
    candidate_rows = list(range(1, height - 1))
    num_horizontal = random.randint(2, min(4, len(candidate_rows)))
    horizontal_rows = sorted(random.sample(candidate_rows, num_horizontal))
    for r in horizontal_rows:
        for c in range(width):
            grid_input[r][c] = HL

    # Define bands as ranges [start, end) (rows between horizontal lines)
    bands = []
    if horizontal_rows:
        bands.append((0, horizontal_rows[0]))
        for i in range(len(horizontal_rows) - 1):
            bands.append((horizontal_rows[i] + 1, horizontal_rows[i + 1]))
        bands.append((horizontal_rows[-1] + 1, height))
    else:
        bands.append((0, height))

    # Choose 2-4 colors for components
    available_colors = [1, 2, 3, 4]
    num_colors = random.randint(2, min(4, len(available_colors)))
    colors = random.sample(available_colors, num_colors)

    # Bookkeeping to avoid overlapping connections
    reserved_draw = set()      # cells that will be drawn in the output (connections)
    reserved_columns = set()   # columns reserved for vertical connectors
    reserved_rows = set()      # rows reserved for horizontal connectors
    horizontal_conns = []      # list of (color, row, minc, maxc)
    vertical_conns = []        # list of (color, col, minr, maxr)
    components = {c: [] for c in colors}

    # Ensure we create a mix: make sure at least one H and one V if possible
    types = {}
    if len(colors) >= 2:
        types[colors[0]] = 'H'
        types[colors[1]] = 'V'
        for col in colors[2:]:
            types[col] = random.choice(['H', 'V'])
    else:
        types[colors[0]] = 'H'

    # Place components and reserve connector paths
    for color in colors:
        typ = types[color]

        # Attempt horizontal connection
        if typ == 'H':
            placed = False
            for _ in range(40):
                band = random.choice(bands)
                bstart, bend = band
                if bstart >= bend:
                    continue
                r = random.randint(bstart, bend - 1)
                # avoid stacking two different horizontal connectors on same row
                if r in reserved_rows:
                    continue
                # choose number of components in this horizontal connector
                max_k = min(3, width)
                k = random.randint(2, max_k)
                # candidate columns that are free
                valid_cols = [c for c in range(width) if grid_input[r][c] == 0 and (r, c) not in reserved_draw]
                # also avoid columns already reserved for vertical connectors
                valid_cols = [c for c in valid_cols if c not in reserved_columns]
                if len(valid_cols) < k:
                    continue
                cols = sorted(random.sample(valid_cols, k))
                minc, maxc = cols[0], cols[-1]
                # ensure the entire segment is free (no previously reserved draw)
                conflict = False
                for c in range(minc, maxc + 1):
                    if (r, c) in reserved_draw:
                        conflict = True
                        break
                    if grid_input[r][c] != 0:
                        conflict = True
                        break
                if conflict:
                    continue
                # place component pixels (these appear in input)
                for c in cols:
                    grid_input[r][c] = color
                    components[color].append((r, c))
                # reserve the whole drawn horizontal segment so nothing else will overlap
                for c in range(minc, maxc + 1):
                    reserved_draw.add((r, c))
                reserved_rows.add(r)
                horizontal_conns.append((color, r, minc, maxc))
                placed = True
                break
            if not placed:
                # fallback: try to make it a vertical connector instead
                types[color] = 'V'

        # Attempt vertical connection
        if types[color] == 'V':
            placed = False
            band_count = len(bands)
            for _ in range(80):
                # choose a column not already reserved
                candidate_cols = [c for c in range(width) if c not in reserved_columns]
                if not candidate_cols:
                    break
                c = random.choice(candidate_cols)
                # avoid columns that slice through any existing horizontal connector
                conflict_with_horiz = False
                for (_col, hr, hminc, hmaxc) in horizontal_conns:
                    if hminc <= c <= hmaxc:
                        conflict_with_horiz = True
                        break
                if conflict_with_horiz:
                    continue
                # choose how many bands this color will appear in (at least 2)
                k_bands = random.randint(2, band_count)
                if k_bands > band_count:
                    k_bands = band_count
                chosen_bands = sorted(random.sample(range(band_count), k_bands))
                rows_for_components = []
                ok = True
                for bi in chosen_bands:
                    bstart, bend = bands[bi]
                    if bstart >= bend:
                        ok = False
                        break
                    # choose row in band where column c is free
                    possible_rows = [r for r in range(bstart, bend) if grid_input[r][c] == 0 and (r, c) not in reserved_draw]
                    if not possible_rows:
                        ok = False
                        break
                    rows_for_components.append(random.choice(possible_rows))
                if not ok:
                    continue
                minr, maxr = min(rows_for_components), max(rows_for_components)
                # Ensure that the vertical span doesn't cross any already-reserved drawn cell
                conflict = False
                for r in range(minr, maxr + 1):
                    if (r, c) in reserved_draw:
                        conflict = True
                        break
                if conflict:
                    continue
                # place component pixels (they appear in input)
                for r in rows_for_components:
                    grid_input[r][c] = color
                    components[color].append((r, c))
                # reserve the vertical drawn cells (including horizontal-line rows) to avoid overlap
                for r in range(minr, maxr + 1):
                    reserved_draw.add((r, c))
                reserved_columns.add(c)
                vertical_conns.append((color, c, minr, maxr))
                placed = True
                break
            # if not placed, we'll leave color with only isolated components (handled later)

    # If no connections were constructed (rare), force a simple horizontal connection
    if not horizontal_conns and not vertical_conns:
        color = colors[0]
        # pick first non-empty band
        for bstart, bend in bands:
            if bstart < bend:
                r = bstart
                break
        # pick two different columns
        c1 = 1
        c2 = max(2, width - 2)
        if c1 == c2:
            c2 = (c1 + 1) % width
        grid_input[r][c1] = color
        grid_input[r][c2] = color
        components[color].append((r, c1))
        components[color].append((r, c2))
        minc, maxc = min(c1, c2), max(c1, c2)
        horizontal_conns.append((color, r, minc, maxc))
        for c in range(minc, maxc + 1):
            reserved_draw.add((r, c))

    # Build output grid as copy of input and then overlay connections
    grid_output = [row[:] for row in grid_input]

    # Apply horizontal connection drawings
    for (color, r, minc, maxc) in horizontal_conns:
        for c in range(minc, maxc + 1):
            if grid_output[r][c] == 0:
                grid_output[r][c] = color

    # Apply vertical connection drawings (respect color changes when crossing HL rows)
    horizontal_row_set = set(horizontal_rows)
    for (color, c, minr, maxr) in vertical_conns:
        current_color = color
        for r in range(minr, maxr + 1):
            if r in horizontal_row_set:
                current_color = HL
            if grid_output[r][c] == 0:
                grid_output[r][c] = current_color

    # Guarantee that input != output (should be true, but just in case)
    if grid_input == grid_output:
        # flip a single background pixel
        for r in range(height):
            for c in range(width):
                if grid_output[r][c] == 0:
                    grid_output[r][c] = colors[0]
                    r = height  # break outer
                    break

    return {"input": grid_input, "output": grid_output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0
    HL = 5

    # Detect horizontal full-row lines (color HL)
    horizontal_lines = [r for r in range(height) if all(grid[r][c] == HL for c in range(width))]
    horizontal_set = set(horizontal_lines)

    # Find component pixels (colors 1-4)
    components = {}
    for r in range(height):
        for c in range(width):
            val = grid[r][c]
            if 1 <= val <= 4:
                components.setdefault(val, []).append((r, c))

    # Start with a copy of the input as the base of the output
    output = [row[:] for row in grid]

    # For each color draw horizontal and vertical connectors according to the rules
    for color, pixels in components.items():
        # Horizontal: if two or more pixels share the same row, draw horizontal line between them
        rows = {}
        for (r, c) in pixels:
            rows.setdefault(r, []).append(c)
        for r, cols in rows.items():
            if len(cols) >= 2:
                minc, maxc = min(cols), max(cols)
                for cc in range(minc, maxc + 1):
                    if output[r][cc] == 0:
                        output[r][cc] = color

        # Vertical: if two or more pixels share the same column, draw a continuous vertical segment from min to max
        cols = {}
        for (r, c) in pixels:
            cols.setdefault(c, []).append(r)
        for c, rows_list in cols.items():
            if len(rows_list) >= 2:
                minr, maxr = min(rows_list), max(rows_list)
                current_color = color
                for rr in range(minr, maxr + 1):
                    if rr in horizontal_set:
                        current_color = HL
                    if output[rr][c] == 0:
                        output[rr][c] = current_color

    return output

