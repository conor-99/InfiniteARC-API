# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 691e6bb3
Difficulty: hard

=== Tags ===
- Unfold paper crease pattern
- Minimal path fill

=== Description ===
The task involves transforming a folded paper crease pattern into its unfolded
state while filling the minimal path between two designated points. Input grids
feature a folded paper representation with crease lines (denoted by color 1) and
two distinct points (colors 2 and 3). The transformation requires two sequential
steps: first, unfolding the grid by reflecting across all crease lines (vertical
or horizontal) to reconstruct the full paper pattern; second, identifying the
shortest path between the two points (color 2 and 3) that avoids crease lines
(color 1), then filling this path with a new color (color 4). The unfolding
process must correctly mirror grid sections across each crease line, and the
minimal path must navigate around creases using only orthogonal moves (no
diagonals). For hard difficulty, input grids include multiple intersecting
crease lines (e.g., vertical and horizontal), requiring layered reflections, and
the path must navigate complex obstacles formed by the creases. The output grid
must reflect both the fully unfolded structure and the filled minimal path, with
all transformations strictly derived from the input's visual structure without
relying on numerical properties.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, all_pixels, choice

def generate():
    width, height = random.randint(5, 30), random.randint(5, 30)
    output_base = grid(width, height, 0)
    
    # Randomly fill output_base with colors 0-9, ensuring color 2 and 3 exist
    for r in range(height):
        for c in range(width):
            output_base[r][c] = random.randint(0, 9)
    
    # Ensure color 2 and 3 are present
    while 2 not in [cell for row in output_base for cell in row]:
        output_base[random.randint(0, height-1)][random.randint(0, width-1)] = 2
    while 3 not in [cell for row in output_base for cell in row]:
        output_base[random.randint(0, height-1)][random.randint(0, width-1)] = 3

    # Choose vertical crease line (x)
    x = random.randint(1, width-2)
    
    # Ensure crease line is color 1 and grid is symmetric
    for r in range(height):
        output_base[r][x] = 1
    
    # Make grid symmetric across crease line
    for r in range(height):
        for c in range(x+1, width):
            output_base[r][c] = output_base[r][2*x - c]

    input_grid = grid(width, height, 0)
    
    # Create input grid by mirroring (should match output_base due to symmetry)
    for r in range(height):
        for c in range(width):
            if c == x:
                input_grid[r][c] = 1
            elif c < x:
                input_grid[r][c] = output_base[r][c]
            else:
                input_grid[r][c] = output_base[r][2*x - c]

    # Find shortest path between 2 and 3 in output_base (avoiding 1)
    def bfs(start, target, grid):
        from collections import deque
        visited = [[False] * len(grid[0]) for _ in range(len(grid))]
        parent = [[None] * len(grid[0]) for _ in range(len(grid))]
        queue = deque([start])
        visited[start[0]][start[1]] = True
        
        while queue:
            r, c = queue.popleft()
            if grid[r][c] == target:
                path = []
                while (r, c) != start:
                    path.append((r, c))
                    r, c = parent[r][c]
                return path[::-1]
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and not visited[nr][nc] and grid[nr][nc] != 1:
                    visited[nr][nc] = True
                    parent[nr][nc] = (r, c)
                    queue.append((nr, nc))
        return []

    # Find positions of 2 and 3 in output_base
    pos2 = None
    pos3 = None
    for r in range(height):
        for c in range(width):
            if output_base[r][c] == 2:
                pos2 = (r, c)
            elif output_base[r][c] == 3:
                pos3 = (r, c)

    if pos2 is None or pos3 is None:
        return generate()  # Retry if points missing

    path = bfs(pos2, 3, output_base)
    if not path:
        return generate()  # Retry if no path

    # Fill path with color 4 in output_base
    for r, c in path:
        output_base[r][c] = 4

    return {
        'input': input_grid,
        'output': output_base
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import numpy as np
from collections import deque

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    
    # Detect vertical crease (line of 1s)
    crease_x = None
    for c in range(width):
        if all(input_grid[r][c] == 1 for r in range(height)):
            crease_x = c
            break
    
    if crease_x is None:
        # Fallback to horizontal crease (shouldn't happen for valid input)
        for r in range(height):
            if all(input_grid[r][c] == 1 for c in range(width)):
                crease_x = r
                break

    # Unfold input grid to get output_base (should be same as input_grid due to symmetry)
    output_base = grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            if c == crease_x:
                output_base[r][c] = 1
            elif c < crease_x:
                output_base[r][c] = input_grid[r][c]
            else:
                output_base[r][c] = input_grid[r][2*crease_x - c]

    # Find positions of 2 and 3
    pos2 = None
    pos3 = None
    for r in range(height):
        for c in range(width):
            if output_base[r][c] == 2:
                pos2 = (r, c)
            elif output_base[r][c] == 3:
                pos3 = (r, c)

    # BFS for shortest path (avoiding 1)
    def bfs(start, target, grid):
        visited = [[False] * len(grid[0]) for _ in range(len(grid))]
        parent = [[None] * len(grid[0]) for _ in range(len(grid))]
        queue = deque([start])
        visited[start[0]][start[1]] = True
        
        while queue:
            r, c = queue.popleft()
            if grid[r][c] == target:
                path = []
                while (r, c) != start:
                    path.append((r, c))
                    r, c = parent[r][c]
                return path[::-1]
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and not visited[nr][nc] and grid[nr][nc] != 1:
                    visited[nr][nc] = True
                    parent[nr][nc] = (r, c)
                    queue.append((nr, nc))
        return []

    path = bfs(pos2, 3, output_base)
    for r, c in path:
        output_base[r][c] = 4
    
    return output_base

# Helper to create grid
def grid(width, height, color=0):
    return [[color for _ in range(width)] for _ in range(height)]
