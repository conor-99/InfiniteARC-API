# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 06c1cb25
Difficulty: insane

=== Tags ===
- Sequential path painting
- Hollow shape detection
- Cut and unfold
- Momentum conservation path

=== Description ===
Input grids feature a single background color (0) overlaid with multiple
disjoint hollow rectangles, each defined by a continuous border of a unique non-
background color (1-9) enclosing a background-filled interior. Hollow rectangles
vary in size (3×3 to 6×6) and aspect ratio (1:1 to 4:1), positioned such that
their borders do not touch other objects or grid edges, with 2-5 background
cells separating adjacent hollows. Each hollow rectangle is detected via
4-connectivity (borders form closed loops with no gaps) and confirmed by empty
interior cells.  The output grid is generated through the following sequence:
1. **Hollow Shape Detection**: Identify all hollow rectangles by locating closed
border loops (4-connected borders) with background-filled interiors.   2. **Path
Initialization**: Start a path from the top-left background cell (0,0) moving
right.   3. **Momentum Conservation Pathing**:      - Move one cell at a time in
the current direction.      - When the path encounters a border cell of a hollow
rectangle, reflect the direction:        - **Vertical border** (left/right sides
of taller hollows): turn 90° counterclockwise.        - **Horizontal border**
(top/bottom sides of wider hollows): turn 90° clockwise.      - Each segment
between reflections is painted with the border color of the hollow causing the
reflection.   4. **Cut and Unfold**: The path's reflection points "cut" the
grid's geometry at hollow borders, "unfolding" the path into a continuous
trajectory that follows momentum conservation (angle of incidence = angle of
reflection).   5. **Sequential Path Painting**: The path uses hollow rectangle
border colors in the order of reflection events, painting each segment with the
corresponding color (no overwriting of hollow borders or background).    The
output grid retains all input hollow rectangles unchanged, with the path painted
as a continuous sequence of color segments reflecting off hollow borders,
adhering to the physical principles of momentum conservation and geometric
unfolding.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid


def generate():
    # Grid size
    width, height = 25, 25
    input_grid = grid(width, height, 0)

    # Number of hollow rectangles
    num_hollows = random.randint(3, 5)
    colors = random.sample(list(range(1, 10)), num_hollows)

    hollows = []  # store tuples (r, c, w, h, color)
    min_sep = 2  # minimum background cells between rectangles

    # We'll force the first rectangle to cross row 1 so a start position exists
    start_row = 1

    for i, color in enumerate(colors):
        placed = False
        tries = 0
        while not placed and tries < 400:
            tries += 1
            w = random.randint(3, 6)
            h = random.randint(3, 6)
            # Ensure rectangle does not touch the grid edges
            r_min = 1
            r_max = height - h - 1
            c_min = 1
            c_max = width - w - 1
            if r_max < r_min or c_max < c_min:
                continue
            if i == 0:
                # force first rect to cover start_row
                r_low = max(r_min, start_row - (h - 1))
                r_high = min(r_max, start_row)
                if r_low > r_high:
                    continue
                r = random.randint(r_low, r_high)
            else:
                r = random.randint(r_min, r_max)
            c = random.randint(c_min, c_max)

            # Check separation from existing hollows
            ok = True
            for (pr, pc, pw, ph, pcol) in hollows:
                # Expand candidate rectangle by min_sep and check overlap
                if (r - min_sep <= pr + ph - 1) and (r + h - 1 + min_sep >= pr) and (
                    c - min_sep <= pc + pw - 1) and (c + w - 1 + min_sep >= pc):
                    ok = False
                    break
            if not ok:
                continue

            # Draw border of hollow rectangle
            for col in range(c, c + w):
                input_grid[r][col] = color
                input_grid[r + h - 1][col] = color
            for row in range(r + 1, r + h - 1):
                input_grid[row][c] = color
                input_grid[row][c + w - 1] = color

            hollows.append((r, c, w, h, color))
            placed = True

        # If we failed to place after many tries, relax spacing and try again once
        if not placed:
            # Relax spacing and try one more time without overlap constraint
            for _ in range(200):
                w = random.randint(3, 6)
                h = random.randint(3, 6)
                r = random.randint(1, height - h - 1)
                c = random.randint(1, width - w - 1)
                # Draw border
                for col in range(c, c + w):
                    input_grid[r][col] = color
                    input_grid[r + h - 1][col] = color
                for row in range(r + 1, r + h - 1):
                    input_grid[row][c] = color
                    input_grid[row][c + w - 1] = color
                hollows.append((r, c, w, h, color))
                placed = True
                break

    # Build a quick color->rect map (generator knows placements)
    color_map = {col: (r, c, w, h) for (r, c, w, h, col) in hollows}

    # Helper: find start position in the input grid.
    # The start is defined as the first background cell (row-major) with row >= 1
    # such that a ray going right from that cell will hit a border before leaving the grid.
    def find_start(g):
        for rr in range(1, height):
            for cc in range(width):
                if g[rr][cc] != 0:
                    continue
                # look right
                hit = False
                for ny in range(cc + 1, width):
                    if g[rr][ny] != 0:
                        hit = True
                        break
                if hit:
                    return rr, cc
        # fallback
        return 0, 0

    sx, sy = find_start(input_grid)

    # Simulate the momentum-conserving path using ray-casting to the nearest border in direction
    output_grid = [row[:] for row in input_grid]
    x, y = sx, sy
    dx, dy = 0, 1  # moving right
    last_r, last_c = x, y

    step_limit = width * height * 20
    steps = 0
    while True:
        steps += 1
        if steps > step_limit:
            break
        # Cast ray to find nearest border cell in (dx,dy)
        k = 1
        found = False
        while True:
            nx = x + dx * k
            ny = y + dy * k
            if nx < 0 or nx >= height or ny < 0 or ny >= width:
                found = False
                break
            if input_grid[nx][ny] != 0:
                found = True
                break
            k += 1

        if not found:
            # No more reflections; done
            break

        border_r, border_c = nx, ny
        color = input_grid[border_r][border_c]

        # Determine which side of the rectangle this border cell belongs to
        if color in color_map:
            rr, cc, ww, hh = color_map[color]
            # Prefer vertical classification when both are true (corner)
            if border_c == cc or border_c == cc + ww - 1:
                orient = "vertical"
            elif border_r == rr or border_r == rr + hh - 1:
                orient = "horizontal"
            else:
                # fallback to neighborhood test
                if (border_r > 0 and input_grid[border_r - 1][border_c] != 0 and
                    border_r < height - 1 and input_grid[border_r + 1][border_c] != 0):
                    orient = "vertical"
                else:
                    orient = "horizontal"
        else:
            # Should not happen, but fall back to neighbor test
            if (border_r > 0 and input_grid[border_r - 1][border_c] != 0 and
                border_r < height - 1 and input_grid[border_r + 1][border_c] != 0):
                orient = "vertical"
            else:
                orient = "horizontal"

        # Save previous direction for painting
        prev_dx, prev_dy = dx, dy

        # Update direction: vertical -> CCW, horizontal -> CW
        if orient == "vertical":
            dx, dy = -dy, dx  # 90° CCW
        else:
            dx, dy = dy, -dx  # 90° CW

        # Endpoint of this segment is the cell just before the border
        end_r = x + prev_dx * (k - 1)
        end_c = y + prev_dy * (k - 1)

        # Paint the segment from last position to end (inclusive) with the border color
        pr, pc = last_r, last_c
        while True:
            if output_grid[pr][pc] == 0:
                output_grid[pr][pc] = color
            if pr == end_r and pc == end_c:
                break
            pr += prev_dx
            pc += prev_dy

        last_r, last_c = end_r, end_c
        # Move current position to the end cell (we do not step into the border cell)
        x, y = end_r, end_c

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Detect hollow rectangles by color -> bounding box
    color_map = {}
    seen_colors = set()
    for r in range(height):
        for c in range(width):
            val = grid[r][c]
            if val == 0:
                continue
            if val in seen_colors:
                continue
            seen_colors.add(val)
            # Gather all positions of this color
            positions = [(rr, cc) for rr in range(height) for cc in range(width) if grid[rr][cc] == val]
            rs = [p[0] for p in positions]
            cs = [p[1] for p in positions]
            min_r, max_r = min(rs), max(rs)
            min_c, max_c = min(cs), max(cs)
            w = max_c - min_c + 1
            h = max_r - min_r + 1
            # Validate rectangle border and empty interior
            ok = True
            for rr in range(min_r, max_r + 1):
                for cc in range(min_c, max_c + 1):
                    if rr == min_r or rr == max_r or cc == min_c or cc == max_c:
                        if grid[rr][cc] != val:
                            ok = False
                            break
                    else:
                        if grid[rr][cc] != 0:
                            ok = False
                            break
                if not ok:
                    break
            if ok:
                color_map[val] = (min_r, min_c, w, h)
            else:
                # If this color does not form a proper hollow rectangle, still add a best-effort bbox
                color_map[val] = (min_r, min_c, w, h)

    # Find the start position: first background cell (row-major) with row >= 1
    # such that a ray going right will hit a border before leaving the grid.
    def find_start(g):
        for rr in range(1, height):
            for cc in range(width):
                if g[rr][cc] != 0:
                    continue
                # look right
                hit = False
                for ny in range(cc + 1, width):
                    if g[rr][ny] != 0:
                        hit = True
                        break
                if hit:
                    return rr, cc
        return 0, 0

    sx, sy = find_start(grid)

    # Simulate the path using the same ray-casting technique as the generator
    x, y = sx, sy
    dx, dy = 0, 1  # moving right
    output = [row[:] for row in grid]
    last_r, last_c = x, y

    step_limit = width * height * 20
    steps = 0
    while True:
        steps += 1
        if steps > step_limit:
            break
        k = 1
        found = False
        while True:
            nx = x + dx * k
            ny = y + dy * k
            if nx < 0 or nx >= height or ny < 0 or ny >= width:
                found = False
                break
            if grid[nx][ny] != 0:
                found = True
                break
            k += 1

        if not found:
            break

        border_r, border_c = nx, ny
        color = grid[border_r][border_c]

        if color in color_map:
            rr, cc, ww, hh = color_map[color]
            if border_c == cc or border_c == cc + ww - 1:
                orient = "vertical"
            elif border_r == rr or border_r == rr + hh - 1:
                orient = "horizontal"
            else:
                if (border_r > 0 and grid[border_r - 1][border_c] != 0 and
                    border_r < height - 1 and grid[border_r + 1][border_c] != 0):
                    orient = "vertical"
                else:
                    orient = "horizontal"
        else:
            if (border_r > 0 and grid[border_r - 1][border_c] != 0 and
                border_r < height - 1 and grid[border_r + 1][border_c] != 0):
                orient = "vertical"
            else:
                orient = "horizontal"

        prev_dx, prev_dy = dx, dy
        if orient == "vertical":
            dx, dy = -dy, dx
        else:
            dx, dy = dy, -dx

        end_r = x + prev_dx * (k - 1)
        end_c = y + prev_dy * (k - 1)

        pr, pc = last_r, last_c
        while True:
            if output[pr][pc] == 0:
                output[pr][pc] = color
            if pr == end_r and pc == end_c:
                break
            pr += prev_dx
            pc += prev_dy

        last_r, last_c = end_r, end_c
        x, y = end_r, end_c

    return output

