# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: ad5d0ee3
Difficulty: insane

=== Tags ===
- Execute grid based program
- Detect grid

=== Description ===
The input grid features a distinct program section in the leftmost column, where
each cell's color encodes a specific transformation command. The remainder of
the grid constitutes the data section containing complex visual patterns. The
program commands are interpreted based on color semantics (e.g., blue = rotate,
red = flip), not numerical values. Each command must be executed sequentially on
the evolving data section, with later transformations depending on the state
after prior steps. For "insane" difficulty, the program contains 4-5
interdependent commands requiring nested reasoning (e.g., rotation alters object
alignment, affecting subsequent shifts or pattern detection). The data section
includes overlapping shapes, hidden patterns, and multi-color structures that
interact with transformations. Output generation requires detecting 3x3 green
regions after rotation, replacing them with cross patterns, while simultaneously
shifting objects and flipping the grid. All transformations must be applied in
exact program order, with each step's result feeding into the next. The task
demands simultaneous tracking of spatial relationships, color dependencies, and
sequential execution logic across a densely packed 25x25 grid with 8+ distinct
visual elements.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def shift_up(grid):
    if not grid:
        return []
    h = len(grid)
    w = len(grid[0])
    new_grid = [[0] * w for _ in range(h)]
    for r in range(h-1):
        new_grid[r] = grid[r+1][:]
    return new_grid

def shift_right(grid):
    if not grid:
        return []
    h = len(grid)
    w = len(grid[0])
    new_grid = [[0] * w for _ in range(h)]
    for r in range(h):
        for c in range(w-1):
            new_grid[r][c+1] = grid[r][c]
    return new_grid

def detect_and_replace(grid):
    h = len(grid)
    w = len(grid[0])
    new_grid = [row[:] for row in grid]
    for r in range(h-2):
        for c in range(w-2):
            all_green = True
            for dr in range(3):
                for dc in range(3):
                    if grid[r+dr][c+dc] != 3:
                        all_green = False
                        break
                if not all_green:
                    break
            if all_green:
                for dr, dc in [(0,1), (1,0), (1,1), (1,2), (2,1)]:
                    nr, nc = r+dr, c+dc
                    if 0 <= nr < h and 0 <= nc < w:
                        new_grid[nr][nc] = 4
                for dr, dc in [(0,0), (0,2), (2,0), (2,2)]:
                    nr, nc = r+dr, c+dc
                    if 0 <= nr < h and 0 <= nc < w:
                        new_grid[nr][nc] = 0
    return new_grid

def flip_vert(grid):
    return grid[::-1]

def generate():
    H = random.randint(5, 30)
    W = random.randint(6, 30)
    program = [random.choice([1, 2, 3, 4, 5, 6, 7, 8]) for _ in range(H)]
    data = [[random.randint(0, 9) for _ in range(W-1)] for _ in range(H)]
    current = data
    for cmd in program:
        if cmd == 1:
            current = [list(x)[::-1] for x in zip(*current)]
        elif cmd == 2:
            current = common.flip_horiz(current)
        elif cmd == 3:
            current = shift_up(current)
        elif cmd == 4:
            current = shift_right(current)
        elif cmd == 5:
            current = detect_and_replace(current)
        elif cmd == 6:
            current = flip_vert(current)
        elif cmd == 7:
            current = [row[::-1] for row in current][::-1]
        elif cmd == 8:
            current = common.transpose(current)
    input_grid = []
    for r in range(H):
        input_row = [program[r]] + data[r]
        input_grid.append(input_row)
    return {"input": input_grid, "output": current}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
def p(input_grid):
    def shift_up(grid):
        if not grid:
            return []
        h = len(grid)
        w = len(grid[0])
        new_grid = [[0] * w for _ in range(h)]
        for r in range(h-1):
            new_grid[r] = grid[r+1][:]
        return new_grid

    def shift_right(grid):
        if not grid:
            return []
        h = len(grid)
        w = len(grid[0])
        new_grid = [[0] * w for _ in range(h)]
        for r in range(h):
            for c in range(w-1):
                new_grid[r][c+1] = grid[r][c]
        return new_grid

    def detect_and_replace(grid):
        h = len(grid)
        w = len(grid[0])
        new_grid = [row[:] for row in grid]
        for r in range(h-2):
            for c in range(w-2):
                all_green = True
                for dr in range(3):
                    for dc in range(3):
                        if grid[r+dr][c+dc] != 3:
                            all_green = False
                            break
                    if not all_green:
                        break
                if all_green:
                    for dr, dc in [(0,1), (1,0), (1,1), (1,2), (2,1)]:
                        nr, nc = r+dr, c+dc
                        if 0 <= nr < h and 0 <= nc < w:
                            new_grid[nr][nc] = 4
                    for dr, dc in [(0,0), (0,2), (2,0), (2,2)]:
                        nr, nc = r+dr, c+dc
                        if 0 <= nr < h and 0 <= nc < w:
                            new_grid[nr][nc] = 0
        return new_grid

    def flip_vert(grid):
        return grid[::-1]

    H = len(input_grid)
    W = len(input_grid[0])
    if W < 2:
        return input_grid
    program = [row[0] for row in input_grid]
    data = [row[1:] for row in input_grid]
    current = data
    for cmd in program:
        if cmd == 1:
            current = [list(x)[::-1] for x in zip(*current)]
        elif cmd == 2:
            current = common.flip_horiz(current)
        elif cmd == 3:
            current = shift_up(current)
        elif cmd == 4:
            current = shift_right(current)
        elif cmd == 5:
            current = detect_and_replace(current)
        elif cmd == 6:
            current = flip_vert(current)
        elif cmd == 7:
            current = [row[::-1] for row in current][::-1]
        elif cmd == 8:
            current = common.transpose(current)
    return current
