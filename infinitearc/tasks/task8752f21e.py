# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 8752f21e
Difficulty: very hard

=== Tags ===
- Contouring
- Phase transition path
- Color carving
- Color space mapping

=== Description ===
# Task Description: Phase-Contoured Color Carving  Input grids feature a complex
arrangement of non-overlapping, contiguous regions on a uniform background
(color 0), each region filled with a distinct, non-background color from 1 to 9.
The regions form a topologically connected network where each region is adjacent
(sharing an edge) to at least one other region. The background color (0) is the
only color not used for region filling.  The output grid transforms the input by
creating a continuous, non-branching path that traverses the boundaries between
regions. This path follows the exact contour of region edges (not interior
cells) and transitions through regions in a specific color sequence determined
by a cyclic phase transition rule: each subsequent region in the path must have
a color that is exactly one increment higher in a predefined color cycle
(1→2→3→...→9→1), with no skipping or jumping. The path must be a Hamiltonian
path that visits every region exactly once.  The path is carved into the
background by replacing background cells along the shared boundary between
consecutive regions with the color of the *target* region (the next color in the
sequence). For example, when transitioning from a region of color 5 to color 6,
the background cells along their shared edge are replaced with color 6. The path
is always exactly one cell wide, never overlapping with region interiors, and
never crossing itself. The carving process preserves all original region colors
and background cells outside the path.  The challenge lies in identifying the
unique sequence of regions that satisfies the cyclic phase transition rule while
maintaining a continuous contour path. Multiple regions may share edges with
regions of non-sequential colors, requiring the solver to deduce the correct
sequence purely from color values rather than spatial arrangement. The solution
must also correctly identify the precise contour path along shared boundaries,
which may follow complex, non-straight routes through the grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    n = random.randint(3, 6)
    start_color = random.randint(1, 9)
    colors = [(start_color + i) % 9 for i in range(n)]
    colors = [c if c != 0 else 9 for c in colors]
    
    width = 25
    height = 25
    input_grid = [[0]*width for _ in range(height)]
    
    current_x = 0
    region_sizes = []
    for color in colors:
        size = random.randint(2, 3)
        region_sizes.append(size)
        for r in range(size):
            for c in range(size):
                if current_x + c < width and r < height:
                    input_grid[r][current_x + c] = color
        current_x += size + 1
    
    output_grid = [row[:] for row in input_grid]
    current_x = 0
    for i in range(n - 1):
        gap_x = current_x + region_sizes[i]
        if 0 <= gap_x < width:
            output_grid[0][gap_x] = colors[i+1]
        current_x += region_sizes[i] + 1
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    
    def get_regions(grid):
        height = len(grid)
        width = len(grid[0])
        visited = [[False] * width for _ in range(height)]
        regions = []
        for r in range(height):
            for c in range(width):
                if not visited[r][c] and grid[r][c] != 0:
                    color = grid[r][c]
                    stack = [(r, c)]
                    component = []
                    visited[r][c] = True
                    while stack:
                        cr, cc = stack.pop()
                        component.append((cr, cc))
                        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                                visited[nr][nc] = True
                                stack.append((nr, nc))
                    regions.append((color, component))
        return regions

    def find_adjacent_background_cell(reg1, reg2, grid):
        height = len(grid)
        width = len(grid[0])
        for r in range(height):
            for c in range(width):
                if grid[r][c] != 0:
                    continue
                adj_to_reg1 = False
                adj_to_reg2 = False
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and (nr, nc) in reg1[1]:
                        adj_to_reg1 = True
                    if 0 <= nr < height and 0 <= nc < width and (nr, nc) in reg2[1]:
                        adj_to_reg2 = True
                if adj_to_reg1 and adj_to_reg2:
                    return (r, c)
        return None

    def find_hamiltonian_path(graph, n):
        visited = [False] * n
        path = []
        
        def backtrack(node):
            visited[node] = True
            path.append(node)
            if len(path) == n:
                return True
            for neighbor in graph[node]:
                if not visited[neighbor]:
                    if backtrack(neighbor):
                        return True
            visited[node] = False
            path.pop()
            return False
        
        for i in range(n):
            if backtrack(i):
                return path
        return None

    regions = get_regions(input_grid)
    n = len(regions)
    graph = [[] for _ in range(n)]
    
    for i in range(n):
        for j in range(i + 1, n):
            color1, _ = regions[i]
            color2, _ = regions[j]
            diff = (color2 - color1) % 9
            if diff != 1:
                continue
            cell = find_adjacent_background_cell(regions[i], regions[j], input_grid)
            if cell is not None:
                graph[i].append(j)
                graph[j].append(i)
    
    path = find_hamiltonian_path(graph, n)
    if not path:
        return input_grid
    
    output_grid = [row[:] for row in input_grid]
    for i in range(len(path) - 1):
        idx1, idx2 = path[i], path[i + 1]
        color2 = regions[idx2][0]
        cell = find_adjacent_background_cell(regions[idx1], regions[idx2], input_grid)
        if cell:
            r, c = cell
            output_grid[r][c] = color2
    return output_grid
