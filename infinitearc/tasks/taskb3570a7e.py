# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: b3570a7e
Difficulty: hard

=== Tags ===
- Paint on collision
- Symmetry axis completion
- Friction path
- Pattern cycle

=== Description ===
Input grids are 25×25 with a background color (0). A continuous path of color 1
starts along the bottom edge (row 24), moving upward. The grid contains walls of
color 2 (1-cell-thick horizontal or vertical barriers) that block the path. At
the top-left corner, a pattern strip consists of 2×2 blocks (e.g., colors
[3,4,5]) defining a repeating color cycle for path movement. The grid has a
vertical symmetry axis at column 12 (center of 25 columns), with the input grid
asymmetric (path only on the left side).   In the output grid, the path follows
these rules: it moves upward until hitting a wall (color 2), then bounces
(changing direction in a fixed sequence: up → right → down → left → up), and the
collision point changes to the current color in the pattern cycle (advancing the
cycle with each movement step). The path continues until exiting the grid
(reaching top/right edge). After path completion, the grid is mirrored across
the vertical axis (column 12), ensuring all non-background elements (path
trajectory, collision colors) are symmetric. The background remains unchanged,
and no elements overwrite walls or the pattern strip. The output displays the
path’s trajectory with color-cycled collisions and the completed vertical
symmetry.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width, height = 25, 25
    grid = [[0]*width for _ in range(height)]
    
    num_blocks = random.randint(2, 4)
    cycle_colors = random.sample([3,4,5,6,7,8,9], num_blocks)
    for i in range(num_blocks):
        for r in range(2):
            for c in range(2*i, 2*i+2):
                if c < width:
                    grid[r][c] = cycle_colors[i]
    
    bounce_color = random.choice([c for c in [3,4,5,6,7,8,9] if c not in cycle_colors])
    for r in range(height-2, height):
        for c in range(width-2, width):
            grid[r][c] = bounce_color
    
    num_walls = random.randint(5, 10)
    walls = []
    for _ in range(num_walls):
        r = random.randint(1, height-2)
        c = random.randint(1, width-2)
        if r < 2 and c < 2*(num_blocks):
            continue
        if r >= height-2 and c >= width-2:
            continue
        walls.append((r, c))
    for r, c in walls:
        grid[r][c] = 2
    
    start_col = random.randint(0, 11)
    path = []
    current_r = height-1
    while current_r > 0:
        path.append((current_r, start_col))
        current_r -= 1
        if current_r > 0 and (current_r, start_col) in walls:
            break
    for r, c in path:
        if 0 <= r < height and 0 <= c < width:
            grid[r][c] = 1
    
    output_grid = [row[:] for row in grid]
    
    cycle = []
    for i in range(0, width, 2):
        if i < width and grid[0][i] != 0:
            cycle.append(grid[0][i])
        else:
            break
    if not cycle:
        cycle = [3,4]
    
    start_col = None
    for c in range(width):
        if output_grid[height-1][c] == 1:
            start_col = c
            break
    if start_col is None:
        start_col = 0
    
    current_pos = (height-1, start_col)
    direction = 0
    cycle_index = 0
    while True:
        dr, dc = [(-1,0), (0,1), (1,0), (0,-1)][direction]
        next_pos = (current_pos[0] + dr, current_pos[1] + dc)
        if not (0 <= next_pos[0] < height and 0 <= next_pos[1] < width):
            break
        if output_grid[next_pos[0]][next_pos[1]] == 2:
            output_grid[next_pos[0]][next_pos[1]] = cycle[cycle_index]
            cycle_index = (cycle_index + 1) % len(cycle)
            direction = (direction + 1) % 4
        else:
            output_grid[current_pos[0]][current_pos[1]] = cycle[cycle_index]
            cycle_index = (cycle_index + 1) % len(cycle)
            current_pos = next_pos
    
    mirrored_grid = [[0]*width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            mirrored_grid[r][c] = output_grid[r][width-1-c]
    
    return {
        "input": grid,
        "output": mirrored_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    
    cycle = []
    for c in range(0, width, 2):
        if c < width and grid[0][c] != 0:
            cycle.append(grid[0][c])
        else:
            break
    if len(cycle) < 2:
        cycle = [3,4]
    
    start_col = None
    for c in range(width):
        if grid[height-1][c] == 1:
            start_col = c
            break
    if start_col is None:
        start_col = 0
    
    current_pos = (height-1, start_col)
    direction = 0
    cycle_index = 0
    while True:
        dr, dc = [(-1,0), (0,1), (1,0), (0,-1)][direction]
        next_pos = (current_pos[0] + dr, current_pos[1] + dc)
        if not (0 <= next_pos[0] < height and 0 <= next_pos[1] < width):
            break
        if grid[next_pos[0]][next_pos[1]] == 2:
            grid[next_pos[0]][next_pos[1]] = cycle[cycle_index]
            cycle_index = (cycle_index + 1) % len(cycle)
            direction = (direction + 1) % 4
        else:
            grid[current_pos[0]][current_pos[1]] = cycle[cycle_index]
            cycle_index = (cycle_index + 1) % len(cycle)
            current_pos = next_pos
    
    mirrored_grid = [[0]*width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            mirrored_grid[r][c] = grid[r][width-1-c]
    
    return tuple(tuple(row) for row in mirrored_grid)
