# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: f4ad2c7a
Difficulty: very hard

=== Tags ===
- Lava flow
- Gate chain construction
- Implicit topology
- Infer hidden grid
- Create image from info
- Loop filling

=== Description ===
Task Description: Lava Gate Loop  Input grids feature a large background
(minimum 15×15) with a single background color (0). Overlaid are exactly 9
distinct "gate" cells (color 1-9), each occupying a single cell. These gates are
scattered without obvious alignment, forming no visible pattern. Additionally,
the grid contains a single "lava source" cell (color 10, but represented as 0 in
input since 10 is invalid; in practice, the source is a specific pattern like a
diagonal marker).  The hidden topology is implicit: the gates must be sorted
into a 3×3 grid by their row-major order (sorted first by row, then column).
Each gate's color directly maps to its value (color 1=1, ..., color 9=9). This
forms a hidden 3×3 grid of numbers. The gate chain follows the sequence
1→2→3→4→5→6→7→8→9→1, creating a loop. The lava path connects consecutive gates
in this sequence using the shortest possible background-path (only moving
through background cells, not gates), forming a continuous loop. The path is
drawn as a single-cell-wide line (color 7), and the interior of the loop is
filled with a lava color (color 8). The lava source remains visible in the
output but does not affect the loop path. All output elements occupy only
background cells, never overwriting gates or other features. The task requires
inferring the hidden grid from gate positions and colors, then constructing the
loop path through geometrically consistent connections.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid
from collections import deque

def bfs(grid, start, end, width, height):
    visited = [[False] * width for _ in range(height)]
    parent = {}
    queue = deque()
    queue.append(start)
    visited[start[0]][start[1]] = True
    while queue:
        r, c = queue.popleft()
        if (r, c) == end:
            break
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == 0:
                visited[nr][nc] = True
                parent[(nr, nc)] = (r, c)
                queue.append((nr, nc))
    path = []
    current = end
    while current != start:
        path.append(current)
        current = parent.get(current, None)
        if current is None:
            break
    path.append(start)
    return path[::-1]

def flood_fill(grid, start, width, height, color):
    queue = deque()
    queue.append(start)
    visited = [[False] * width for _ in range(height)]
    visited[start[0]][start[1]] = True
    while queue:
        r, c = queue.popleft()
        grid[r][c] = color
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == 0:
                visited[nr][nc] = True
                queue.append((nr, nc))

def generate():
    width = random.randint(15, 30)
    height = random.randint(15, 30)
    input_grid = grid(width, height, 0)
    
    positions = []
    while len(positions) < 9:
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        if (r, c) not in positions:
            positions.append((r, c))
    
    positions.sort(key=lambda x: (x[0], x[1]))
    for i, (r, c) in enumerate(positions):
        input_grid[r][c] = i + 1
    
    output_grid = [row[:] for row in input_grid]
    
    for i in range(9):
        start = positions[i]
        end = positions[(i + 1) % 9]
        path = bfs(output_grid, start, end, width, height)
        for r, c in path:
            output_grid[r][c] = 7
    
    path_cells = []
    for i in range(9):
        start = positions[i]
        end = positions[(i + 1) % 9]
        path_cells.extend(bfs(output_grid, start, end, width, height))
    
    if path_cells:
        avg_r = sum(r for r, c in path_cells) // len(path_cells)
        avg_c = sum(c for r, c in path_cells) // len(path_cells)
        interior_point = (avg_r, avg_c)
        r, c = interior_point
        found = False
        for dr in range(-2, 3):
            for dc in range(-2, 3):
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and output_grid[nr][nc] == 0:
                    interior_point = (nr, nc)
                    found = True
                    break
            if found:
                break
        flood_fill(output_grid, interior_point, width, height, 8)
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def bfs(grid, start, end, width, height):
    visited = [[False] * width for _ in range(height)]
    parent = {}
    queue = deque()
    queue.append(start)
    visited[start[0]][start[1]] = True
    while queue:
        r, c = queue.popleft()
        if (r, c) == end:
            break
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == 0:
                visited[nr][nc] = True
                parent[(nr, nc)] = (r, c)
                queue.append((nr, nc))
    path = []
    current = end
    while current != start:
        path.append(current)
        current = parent.get(current, None)
        if current is None:
            break
    path.append(start)
    return path[::-1]

def flood_fill(grid, start, width, height, color):
    queue = deque()
    queue.append(start)
    visited = [[False] * width for _ in range(height)]
    visited[start[0]][start[1]] = True
    while queue:
        r, c = queue.popleft()
        grid[r][c] = color
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == 0:
                visited[nr][nc] = True
                queue.append((nr, nc))

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    
    gates = []
    for r in range(height):
        for c in range(width):
            if 1 <= input_grid[r][c] <= 9:
                gates.append((r, c))
    
    gates.sort(key=lambda x: (x[0], x[1]))
    
    output_grid = [row[:] for row in input_grid]
    
    for i in range(9):
        start = gates[i]
        end = gates[(i + 1) % 9]
        path = bfs(output_grid, start, end, width, height)
        for r, c in path:
            output_grid[r][c] = 7
    
    path_cells = []
    for i in range(9):
        start = gates[i]
        end = gates[(i + 1) % 9]
        path_cells.extend(bfs(output_grid, start, end, width, height))
    
    if path_cells:
        avg_r = sum(r for r, c in path_cells) // len(path_cells)
        avg_c = sum(c for r, c in path_cells) // len(path_cells)
        r, c = avg_r, avg_c
        found = False
        for dr in range(-2, 3):
            for dc in range(-2, 3):
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and output_grid[nr][nc] == 0:
                    interior_point = (nr, nc)
                    found = True
                    break
            if found:
                break
        flood_fill(output_grid, interior_point, width, height, 8)
    
    return tuple(tuple(row) for row in output_grid)
