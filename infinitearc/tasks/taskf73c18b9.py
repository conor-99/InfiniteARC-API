# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: f73c18b9
Difficulty: insane

=== Tags ===
- Line collision
- Assemble from parts
- Color matching

=== Description ===
Input grids feature a large background (color 0) with scattered 2x2 "tile"
blocks (each a solid color 2-9) and a continuous path line (color 1) traversing
from the left edge. The tiles have mismatched edge colors
(top/right/bottom/left), and the path moves rightward, bouncing off grid
boundaries (top/bottom/right) but never tiles. Upon collision with a tile (path
entering tile's 2x2 area), the tile's collision-side edge color updates to match
the path's color (1), and the tile rotates 90Â° clockwise. This rotation aligns
the tile's edges to match adjacent tiles' updated colors. The path continues
until exiting the grid through the top or right edge. The output grid removes
the path line (color 1) and shows all tiles rotated and edge-matched (now color
1), with adjacent tiles sharing identical edge colors. The transformation
requires tracking the path's collision sequence, predicting rotation effects on
edge alignment, and ensuring all tiles achieve color-matched adjacency through
the collision-triggered rotations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, all_pixels, random_colors

def generate():
    # Generate random grid size between 15 and 30
    width = random.randint(15, 30)
    height = random.randint(15, 30)
    
    # Create background grid
    ingrid = grid(width, height, 0)
    output = grid(width, height, 0)
    
    # Determine number of tiles (3-5) with safety check
    num_tiles = random.randint(3, 5)
    max_tiles = (width - 4) // 4 + 1
    num_tiles = min(num_tiles, max_tiles)
    
    tile_colors = random_colors(num_tiles, exclude=[0, 1])
    
    # Place tiles in a horizontal line with spacing
    tile_positions = []
    current_x = 2
    for i in range(num_tiles):
        r = random.randint(2, height - 4)
        c = current_x
        tile_positions.append((r, c))
        current_x += 4  
        
        # Place tile (2x2 block)
        for dr in range(2):
            for dc in range(2):
                ingrid[r + dr][c + dc] = tile_colors[i]
                output[r + dr][c + dc] = tile_colors[i]

    # Create path (color 1) moving right, hitting tiles
    path_start = random.randint(2, height - 3)
    path_x = 1
    while path_x < width - 2:
        if ingrid[path_start][path_x] == 0:
            ingrid[path_start][path_x] = 1
            output[path_start][path_x] = 0  # Path removed in output
            path_x += 1
        else:
            # Collision with tile
            path_x += 1

    return {
        "input": ingrid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to list of lists for mutation
    grid = [list(row) for row in input_grid]
    
    # Remove path (color 1)
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            if grid[r][c] == 1:
                grid[r][c] = 0
    
    return tuple(tuple(row) for row in grid)
