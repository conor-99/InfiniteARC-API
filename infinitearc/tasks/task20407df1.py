# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 20407df1
Difficulty: hard

=== Tags ===
- Divide by n
- Graph coloring on grid

=== Description ===
The input grid displays a complex arrangement of connected regions, where each
region consists of contiguous cells sharing the same color (4-connected). The
task requires transforming the input into an output grid where each region is
assigned a color such that no two adjacent regions (sharing an edge) share the
same color. This graph coloring must use the minimal number of colors possible,
determined by the adjacency structure of the regions. The coloring follows a
deterministic rule: regions are processed in row-major order, and each region is
assigned the smallest available color not used by its already-colored neighbors.
The challenge arises from intricate region configurations—such as cycles of
three or more regions requiring three or more colors—making it difficult to
infer the transformation from a limited number of examples. The visual
arrangement of regions, not their input colors, dictates the output, demanding
abstract reasoning about spatial relationships and adjacency patterns.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random
from common import grid

def find_regions(input_grid):
    visited = set()
    regions = []
    region_id = 0
    rows = len(input_grid)
    cols = len(input_grid[0])
    for r in range(rows):
        for c in range(cols):
            if (r, c) not in visited:
                color = input_grid[r][c]
                cells = []
                queue = [(r, c)]
                visited.add((r, c))
                while queue:
                    cr, cc = queue.pop(0)
                    cells.append((cr, cc))
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and input_grid[nr][nc] == color:
                            visited.add((nr, nc))
                            queue.append((nr, nc))
                top, left = min(cells, key=lambda x: (x[0], x[1]))
                regions.append({
                    'id': region_id,
                    'top': top,
                    'left': left,
                    'cells': cells,
                    'color': color
                })
                region_id += 1
    return regions

def get_region_map(regions):
    region_map = {}
    for reg in regions:
        for cell in reg['cells']:
            region_map[cell] = reg['id']
    return region_map

def get_neighbors(region_id, region_map, regions):
    neighbors = set()
    for (r, c) in regions[region_id]['cells']:
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if (nr, nc) in region_map:
                neighbor_id = region_map[(nr, nc)]
                if neighbor_id != region_id:
                    neighbors.add(neighbor_id)
    return neighbors

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = grid(width, height, 0)
    
    # Random colors for cycle regions
    cycle_colors = random.sample(range(1, 10), 3)
    # Fill cycle pattern in top-left 3x3
    for r in range(3):
        for c in range(3):
            if (r, c) in [(0,0), (0,1), (1,0)]:
                input_grid[r][c] = cycle_colors[0]
            elif (r, c) in [(0,2), (1,2), (2,2)]:
                input_grid[r][c] = cycle_colors[1]
            elif (r, c) in [(2,0), (2,1), (1,1)]:
                input_grid[r][c] = cycle_colors[2]
    
    # Random checkerboard for rest
    color1, color2 = random.sample([x for x in range(1, 10) if x not in cycle_colors], 2)
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                input_grid[r][c] = color1 if (r + c) % 2 == 0 else color2
    
    regions = find_regions(input_grid)
    region_map = get_region_map(regions)
    regions_sorted = sorted(regions, key=lambda x: (x['top'], x['left']))
    region_color = {}
    for reg in regions_sorted:
        neighbors = get_neighbors(reg['id'], region_map, regions)
        used_colors = {region_color[n] for n in neighbors if n in region_color}
        color = 0
        while color in used_colors:
            color += 1
        region_color[reg['id']] = color
    
    output_grid = grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            cell = (r, c)
            region_id = None
            for reg in regions:
                if cell in reg['cells']:
                    region_id = reg['id']
                    break
            output_grid[r][c] = region_color[region_id]
    
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
from common import grid

def find_regions(input_grid):
    visited = set()
    regions = []
    region_id = 0
    rows = len(input_grid)
    cols = len(input_grid[0])
    for r in range(rows):
        for c in range(cols):
            if (r, c) not in visited:
                color = input_grid[r][c]
                cells = []
                queue = [(r, c)]
                visited.add((r, c))
                while queue:
                    cr, cc = queue.pop(0)
                    cells.append((cr, cc))
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and input_grid[nr][nc] == color:
                            visited.add((nr, nc))
                            queue.append((nr, nc))
                top, left = min(cells, key=lambda x: (x[0], x[1]))
                regions.append({
                    'id': region_id,
                    'top': top,
                    'left': left,
                    'cells': cells,
                    'color': color
                })
                region_id += 1
    return regions

def get_region_map(regions):
    region_map = {}
    for reg in regions:
        for cell in reg['cells']:
            region_map[cell] = reg['id']
    return region_map

def get_neighbors(region_id, region_map, regions):
    neighbors = set()
    for (r, c) in regions[region_id]['cells']:
        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            nr, nc = r + dr, c + dc
            if (nr, nc) in region_map:
                neighbor_id = region_map[(nr, nc)]
                if neighbor_id != region_id:
                    neighbors.add(neighbor_id)
    return neighbors

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    regions = find_regions(input_grid)
    region_map = get_region_map(regions)
    regions_sorted = sorted(regions, key=lambda x: (x['top'], x['left']))
    region_color = {}
    for reg in regions_sorted:
        neighbors = get_neighbors(reg['id'], region_map, regions)
        used_colors = {region_color[n] for n in neighbors if n in region_color}
        color = 0
        while color in used_colors:
            color += 1
        region_color[reg['id']] = color
    
    output_grid = grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            cell = (r, c)
            region_id = None
            for reg in regions:
                if cell in reg['cells']:
                    region_id = reg['id']
                    break
            output_grid[r][c] = region_color[region_id]
    return output_grid
