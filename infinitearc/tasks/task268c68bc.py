# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 268c68bc
Difficulty: mediumâ€“hard

=== Tags ===
- Color stream
- Multi exit routes
- Collision marking
- Color by distance to a single point
- Adapt image to grid

=== Description ===
Task Name: Distance Streams with Collision Marking  Description: Input grids
feature a single source cell (color 5) on a background (color 0), surrounded by
multiple non-background color streams flowing outward. Each stream is a
connected path of cells (using colors 1-4,6-9) extending from the source to the
grid's boundary, with some streams crossing at specific cells (collisions). The
streams do not overlap in the input, but their paths intersect at collision
points.  The output grid transforms the input by: 1. Coloring each cell based on
its Manhattan distance from the source, using a repeating sequence: distance 0 =
5, 1 = 1, 2 = 2, 3 = 3, 4 = 4, 5 = 6, 6 = 7, 7 = 8, 8 = 9, then repeating (e.g.,
distance 9 = 1). 2. Marking any cell that is part of two or more input streams
(a collision) with color 9, overriding the distance-based color.  The
transformation requires identifying the source, computing distances, detecting
collision points from intersecting stream paths, and applying the color rules.
"Multi exit routes" are the streams leading to different grid edges, visible in
the output's distance patterns.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def manhattan_path(a,b):
    ar,ac = a; br,bc = b
    path = [(ar,ac)]
    r,c = ar,ac
    while (r,c) != (br,bc):
        choices = []
        if r < br: choices.append((r+1,c))
        if r > br: choices.append((r-1,c))
        if c < bc: choices.append((r,c+1))
        if c > bc: choices.append((r,c-1))
        random.shuffle(choices)
        nr,nc = choices[0]
        path.append((nr,nc))
        r,c = nr,nc
    return path

def generate():
    width = random.randint(15,25)
    height = random.randint(15,25)
    sr = random.randint(1,height-2)
    sc = random.randint(1,width-2)
    colors = [1,2,3,4,6,7,8]  # exclude 9 for streams; 9 reserved for collision markers
    num_streams = random.randint(3,5)
    stream_colors = random.sample(colors, num_streams)
    # choose distinct edge targets for streams
    edges = ['top','bottom','left','right']
    # pick edges for streams ensuring diversity
    chosen_edges = []
    avail_edges = edges.copy()
    for i in range(num_streams):
        if avail_edges:
            e = random.choice(avail_edges)
            avail_edges.remove(e)
        else:
            e = random.choice(edges)
        chosen_edges.append(e)
    targets = []
    for e in chosen_edges:
        if e == 'top':
            tr, tc = 0, random.randint(0,width-1)
        elif e == 'bottom':
            tr, tc = height-1, random.randint(0,width-1)
        elif e == 'left':
            tr, tc = random.randint(0,height-1), 0
        else:
            tr, tc = random.randint(0,height-1), width-1
        targets.append((tr,tc))
    # collisions: ensure at least one collision between two streams
    # choose number of collision points 1..min(2, num_streams//2)
    max_collisions = min(2, max(1,num_streams//2))
    num_collisions = random.randint(1,max_collisions)
    collision_points = []
    assignments = {i:[] for i in range(num_streams)}  # stream->collisions to pass
    for _ in range(num_collisions):
        # pick collision coord near the source but not equal to source and within interior
        pr = random.randint(max(1, sr-3), min(height-2, sr+3))
        pc = random.randint(max(1, sc-3), min(width-2, sc+3))
        if (pr,pc) == (sr,sc): pr = min(height-2,pr+1)
        collision_points.append((pr,pc))
        # pick at least two distinct streams to pass through it
        k = random.randint(2, min(3, num_streams))
        streams = random.sample(range(num_streams), k)
        for s in streams:
            assignments[s].append((pr,pc))
    # Build stream paths
    stream_paths = []
    for i in range(num_streams):
        color = stream_colors[i]
        target = targets[i]
        points = [(sr,sc)] + assignments[i] + [target]
        # build path by connecting successive points
        path = []
        for j in range(len(points)-1):
            seg = manhattan_path(points[j], points[j+1])
            if j > 0:
                # avoid duplicating the joint point
                seg = seg[1:]
            path.extend(seg)
        stream_paths.append(path)
    # create input grid
    input_grid = grid(width, height, 0)
    input_grid[sr][sc] = 5
    collision_map = {}
    for i,path in enumerate(stream_paths):
        color = stream_colors[i]
        for (r,c) in path:
            if (r,c) == (sr,sc): continue
            prev = input_grid[r][c]
            if prev == 0:
                input_grid[r][c] = color
                collision_map[(r,c)] = collision_map.get((r,c), 0) + 1
            elif prev == color or prev == 5:
                # same color or source - continue counting
                collision_map[(r,c)] = collision_map.get((r,c), 0) + 1
                # leave cell as is
            elif prev == 9:
                # already marked collision
                collision_map[(r,c)] = collision_map.get((r,c), 0) + 1
            else:
                # collision: mark as 9
                input_grid[r][c] = 9
                collision_map[(r,c)] = collision_map.get((r,c), 0) + 1
    # ensure at least one collision cell (count >=2)
    # If no actual collision, force a collision between first two streams by making them pass through a shared point
    if max(collision_map.values(), default=0) < 2:
        # pick a point near source
        pr = random.randint(max(1, sr-3), min(height-2, sr+3))
        pc = random.randint(max(1, sc-3), min(width-2, sc+3))
        if (pr,pc) == (sr,sc):
            pr = min(height-2, pr+1)
        input_grid[pr][pc] = 9
    # generate output grid based on distances
    output_grid = grid(width, height, 0)
    seq = [1,2,3,4,6,7,8,9]
    for r in range(height):
        for c in range(width):
            d = abs(r - sr) + abs(c - sc)
            if d == 0:
                output_grid[r][c] = 5
            else:
                output_grid[r][c] = seq[(d-1) % len(seq)]
    # override collisions from input (cells with color 9) in output
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 9:
                output_grid[r][c] = 9
    # ensure input != output
    if input_grid == output_grid:
        return generate()
    return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])
    sr, sc = -1, -1
    for r in range(height):
        for c in range(width):
            if grid_in[r][c] == 5:
                sr, sc = r, c
                break
        if sr != -1:
            break
    if sr == -1:
        sr, sc = height//2, width//2
    seq = [1,2,3,4,6,7,8,9]
    out = [[0]*width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            d = abs(r - sr) + abs(c - sc)
            if d == 0:
                out[r][c] = 5
            else:
                out[r][c] = seq[(d-1) % len(seq)]
    # override collisions: any input cell with color 9 is a collision marker
    for r in range(height):
        for c in range(width):
            if grid_in[r][c] == 9:
                out[r][c] = 9
    return tuple(tuple(row) for row in out)

