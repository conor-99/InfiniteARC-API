# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: c67421a9
Difficulty: hard

=== Tags ===
- Line decay
- Deterministic reflection
- Competitive agents
- Pattern reflection

=== Description ===
Input grids feature two distinct colored lines (each line is a contiguous
horizontal or vertical sequence of cells in a single color) positioned such that
they are moving toward each other along the same axis (e.g., one line extending
rightward, the other leftward on the same row). The lines are separated by at
least one background cell, with the background being a neutral color not used by
the lines. All other elements in the grid (e.g., static shapes, other color
patterns) remain unchanged and serve as context.  The transformation rule
applies only to the two lines moving toward each other. The lines advance one
cell toward their collision point. Upon collision, both lines reverse direction
(reflect), and each line decays by one cell at the end corresponding to their
original movement direction (e.g., a right-moving line loses its rightmost cell,
now moving left; a left-moving line loses its leftmost cell, now moving right).
The output grid displays the lines after this reflection and decay, now oriented
away from each other with reduced length. The background and all other grid
elements remain identical to the input.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    bg = 0
    
    color1 = random.randint(1, 9)
    color2 = random.randint(1, 9)
    while color2 == color1:
        color2 = random.randint(1, 9)
    
    row = random.randint(0, height - 1)
    
    max_combined = width - 1
    len_a = random.randint(2, min(5, max_combined - 2))
    len_b = random.randint(2, min(5, max_combined - len_a))
    
    start_a = random.randint(0, width - len_a - len_b - 1)
    start_b = start_a + len_a + 1
    
    input_grid = grid(width, height, bg)
    
    for c in range(start_a, start_a + len_a):
        input_grid[row][c] = color1
    
    for c in range(start_b, start_b + len_b):
        input_grid[row][c] = color2
    
    output_grid = [list(row) for row in input_grid]
    output_grid[row][start_a + len_a - 1] = bg
    output_grid[row][start_b] = bg
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    bg = 0
    
    for row in range(height):
        segments = []
        c = 0
        while c < width:
            if input_grid[row][c] != bg:
                color = input_grid[row][c]
                start = c
                while c < width and input_grid[row][c] == color:
                    c += 1
                end = c - 1
                segments.append((color, start, end))
            else:
                c += 1
        
        if len(segments) == 2:
            (color1, start1, end1), (color2, start2, end2) = segments
            if end1 + 2 == start2:
                output = [list(row) for row in input_grid]
                output[row][end1] = bg
                output[row][start2] = bg
                return output
    
    return input_grid
