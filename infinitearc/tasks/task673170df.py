# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 673170df
Difficulty: medium–hard

=== Tags ===
- Hierarchical agent routing
- Fractal growth
- Inverse rule reconstruction
- Pattern imitation
- Trace perimeter
- Align to corner

=== Description ===
Input grids are medium-sized (15×15 to 25×25) with a single background color
(e.g., black) and a central fractal pattern composed of a single non-background
color (e.g., blue). The fractal is a recursive structure (e.g., a Sierpiński
triangle variant) grown from a seed, with each iterative level adding smaller,
self-similar components. The pattern is irregularly positioned within the grid
and does not align with any grid edges.  The transformation to the output grid
involves three sequential steps: 1. **Fractal Perimeter Tracing**: Identify the
outermost boundary of the fractal by tracing the edges between adjacent fractal
and background cells. The perimeter is drawn as a continuous single-pixel-wide
line (using the fractal's color) along the background, moving clockwise around
the entire structure starting from the topmost cell. 2. **Hierarchical Agent
Routing**: For each "branch point" in the fractal (where the pattern splits into
multiple paths), place a small color-coded marker (e.g., red for primary
branches, green for secondary) at the bottom-right corner of the grid. The
markers are ordered by fractal depth (deepest branches first) and spaced evenly.
3. **Perimeter Alignment**: Translate the traced perimeter so that its starting
point (topmost cell) aligns with the grid's top-left corner (0,0), while
preserving the relative shape of the perimeter. The background and fractal
interior remain unchanged, and the markers are positioned independently in the
bottom-right.  The key challenge is reconstructing the inverse rule: the input's
fractal structure must be analyzed to deduce the correct perimeter path (not
merely the filled area), followed by precise alignment. The hierarchical markers
require identifying recursive levels without explicit depth indicators, and the
perimeter tracing must avoid overwriting the fractal's interior while
maintaining visual continuity.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = random.randint(15, 25)
    height = random.randint(15, 25)
    fractal_color = 1
    size = random.randint(10, 20)
    pixels = common.continuous_creature(size, width=width, height=height)
    rows = [p[0] for p in pixels]
    cols = [p[1] for p in pixels]
    input_grid = common.grid(width, height, 0)
    for r, c in zip(rows, cols):
        input_grid[r][c] = fractal_color
    
    min_row = min(rows)
    min_col = min(c for r, c in zip(rows, cols) if r == min_row)
    start = (min_row, min_col)
    
    perimeter_points = set()
    for r, c in zip(rows, cols):
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 0:
                perimeter_points.add((nr, nc))
    
    perimeter_path = sorted(perimeter_points, key=lambda x: (x[0], x[1]))
    start_r, start_c = start
    shifted_path = [(r - start_r, c - start_c) for r, c in perimeter_path]
    
    output_grid = [row[:] for row in input_grid]
    for r, c in shifted_path:
        if 0 <= r < height and 0 <= c < width:
            output_grid[r][c] = fractal_color
    
    marker_colors = [2, 3, 4]
    for i, color in enumerate(marker_colors):
        r = height - 2 - i//2
        c = width - 2 - i%2
        if 0 <= r < height and 0 <= c < width:
            output_grid[r][c] = color
    
    return {
        'input': input_grid,
        'output': output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    fractal_cells = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 1:
                fractal_cells.append((r, c))
    
    if not fractal_cells:
        return grid
    
    min_row = min(r for r, c in fractal_cells)
    min_col = min(c for r, c in fractal_cells if r == min_row)
    start = (min_row, min_col)
    
    perimeter_points = set()
    for r, c in fractal_cells:
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0:
                perimeter_points.add((nr, nc))
    
    perimeter_path = sorted(perimeter_points, key=lambda x: (x[0], x[1]))
    start_r, start_c = start
    shifted_path = [(r - start_r, c - start_c) for r, c in perimeter_path]
    
    for r, c in shifted_path:
        if 0 <= r < height and 0 <= c < width:
            grid[r][c] = 1
    
    marker_colors = [2, 3, 4]
    for i, color in enumerate(marker_colors):
        r = height - 2 - i//2
        c = width - 2 - i%2
        if 0 <= r < height and 0 <= c < width:
            grid[r][c] = color
    
    return grid
