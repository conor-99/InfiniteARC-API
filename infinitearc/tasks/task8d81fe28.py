# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 8d81fe28
Difficulty: hard

=== Tags ===
- Multi stage rule chain
- X marks the spot
- Propagate color until boundary

=== Description ===
The task involves transforming an input grid into an output grid through a
multi-stage rule chain that requires identifying specific markers ("X marks the
spot") and propagating associated colors until they reach grid boundaries. Input
grids feature a background color (typically 0) with several distinct "X" markers
(represented by color 9) positioned at non-boundary locations. Each X marker
must be associated with a source color determined by the first non-background
cell encountered in the clockwise order: north, east, south, west from the X. If
all adjacent cells are background, a default color (e.g., 1) is used.   The
propagation rule is applied sequentially: for each X, the source color
propagates in the direction toward its source cell (e.g., if the source is
north, the color spreads upward until the top boundary). Propagation occurs in a
fixed order—processing Xs from top to bottom, then left to right—to resolve
overlapping fills, ensuring later Xs overwrite earlier propagations. The output
grid replaces all cells along the propagation paths with the source color, while
retaining the original background and non-propagating elements. Crucially, the X
markers themselves are removed from the output, as the propagation originates
from their positions. The transformation requires recognizing the X positions,
determining source colors through directional checks, and executing sequential
propagation to boundary conditions, all while respecting the grid's spatial
constraints and priority rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid


def generate():
    """
    Generator for the ARC task.

    Creates a grid with background 0, several interior X markers (color 9),
    and for many Xs an adjacent source cell (one of N/E/S/W) with a non-zero color.
    Some Xs are left with all-adjacent-background to force the default color case.

    The output is produced by, for each X (processed top-to-bottom then left-to-right),
    finding the first non-background neighbor in clockwise order N, E, S, W (if any),
    taking its color as the source color (or default 1 if none), and propagating that
    color from the X position toward the source direction until the grid boundary.

    Returns:
      {"input": input_grid, "output": output_grid}
    Both grids are lists-of-lists of integers.
    """
    # Choose size reasonably large to allow many variants but keep generation fast
    w = random.randint(3, 20)
    h = random.randint(3, 20)

    input_grid = grid(w, h, 0)

    # All interior coordinates (Xs are placed only off the border)
    interior = [(r, c) for r in range(1, h - 1) for c in range(1, w - 1)]
    if not interior:
        # Fallback (shouldn't happen given w,h >= 3)
        interior = [(1, 1)]

    # Number of X markers
    max_x = min(len(interior), 8)
    num_x = random.randint(1, max_x)

    x_positions = random.sample(interior, num_x)

    # Keep track of reserved cells we must not place other colors into
    reserved = set(x_positions)
    neighbor_cells_used = set()

    # For each X decide whether to give it a direct adjacent source (with prob) or leave it default
    x_has_explicit_source = {}

    directions = ["N", "E", "S", "W"]

    for (r, c) in x_positions:
        placed = False
        # with some probability place an explicit adjacent source cell
        if random.random() < 0.8:
            dirs = directions[:]
            random.shuffle(dirs)
            for d in dirs:
                if d == "N":
                    sr, sc = r - 1, c
                elif d == "E":
                    sr, sc = r, c + 1
                elif d == "S":
                    sr, sc = r + 1, c
                else:
                    sr, sc = r, c - 1

                # Ensure neighbor is within grid and not itself an X and not already used as a neighbor
                if not (0 <= sr < h and 0 <= sc < w):
                    continue
                if (sr, sc) in reserved:
                    continue
                if (sr, sc) in neighbor_cells_used:
                    continue

                # Place a source color here (not 0 and not 9)
                src_color = random.choice([c for c in range(1, 10) if c != 9])
                input_grid[sr][sc] = src_color
                neighbor_cells_used.add((sr, sc))
                reserved.add((sr, sc))
                x_has_explicit_source[(r, c)] = True
                placed = True
                break
        if not placed:
            # Mark that this X deliberately has no adjacent non-background so solver must use default
            x_has_explicit_source[(r, c)] = False
            # Reserve its four cardinal neighbors so later random patches won't accidentally add colors there
            for dr, dc in [( -1, 0), (0, 1), (1, 0), (0, -1)]:
                rr, cc = r + dr, c + dc
                if 0 <= rr < h and 0 <= cc < w:
                    reserved.add((rr, cc))

    # Finally place the X markers (color 9)
    for (r, c) in x_positions:
        input_grid[r][c] = 9

    # Add some extra random colored cells that are not allowed to touch default-X neighborhoods
    all_coords = [(r, c) for r in range(h) for c in range(w) if (r, c) not in reserved]
    num_extra = random.randint(0, max(0, min(10, len(all_coords))))
    if num_extra > 0 and all_coords:
        extra_cells = random.sample(all_coords, num_extra)
        for (er, ec) in extra_cells:
            input_grid[er][ec] = random.choice([c for c in range(1, 10) if c != 9])

    # Build the output by applying the propagation rule sequentially (sorted top-to-bottom, left-to-right)
    output_grid = [row[:] for row in input_grid]
    # We'll use the original input_grid (unaltered) to determine directions and source colors
    orig = [row[:] for row in input_grid]

    x_positions_sorted = sorted(x_positions, key=lambda pos: (pos[0], pos[1]))

    for (r, c) in x_positions_sorted:
        # Determine source color and direction by checking original neighbors in clockwise order N, E, S, W
        if r - 1 >= 0 and orig[r - 1][c] != 0:
            direction = 'N'
            src_color = orig[r - 1][c]
        elif c + 1 < w and orig[r][c + 1] != 0:
            direction = 'E'
            src_color = orig[r][c + 1]
        elif r + 1 < h and orig[r + 1][c] != 0:
            direction = 'S'
            src_color = orig[r + 1][c]
        elif c - 1 >= 0 and orig[r][c - 1] != 0:
            direction = 'W'
            src_color = orig[r][c - 1]
        else:
            # Default if no adjacent non-background cell
            direction = 'N'
            src_color = 1

        # Propagate from the X position toward the boundary in the chosen direction (inclusive)
        if direction == 'N':
            for rr in range(r, -1, -1):
                output_grid[rr][c] = src_color
        elif direction == 'S':
            for rr in range(r, h):
                output_grid[rr][c] = src_color
        elif direction == 'E':
            for cc in range(c, w):
                output_grid[r][cc] = src_color
        else:  # 'W'
            for cc in range(c, -1, -1):
                output_grid[r][cc] = src_color

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input (tuple of tuples) to a mutable list-of-lists and keep an immutable original for decisions
    orig = [list(row) for row in input_grid]
    h = len(orig)
    w = len(orig[0]) if h > 0 else 0

    # Find all X markers (color 9) anywhere in the grid
    x_positions = []
    for r in range(h):
        for c in range(w):
            if orig[r][c] == 9:
                x_positions.append((r, c))

    # Sort top-to-bottom then left-to-right
    x_positions.sort(key=lambda pos: (pos[0], pos[1]))

    # Start output as a copy of the original input grid
    out = [row[:] for row in orig]

    # For each X, determine its source color and direction from the original grid,
    # then propagate that color from the X toward the boundary. We always consult
    # the original grid when deciding the direction/color so earlier propagations
    # do not affect later decisions; however, when writing we allow later writes
    # to overwrite previous ones (sequential priority).
    for (r, c) in x_positions:
        if r - 1 >= 0 and orig[r - 1][c] != 0:
            direction = 'N'
            src_color = orig[r - 1][c]
        elif c + 1 < w and orig[r][c + 1] != 0:
            direction = 'E'
            src_color = orig[r][c + 1]
        elif r + 1 < h and orig[r + 1][c] != 0:
            direction = 'S'
            src_color = orig[r + 1][c]
        elif c - 1 >= 0 and orig[r][c - 1] != 0:
            direction = 'W'
            src_color = orig[r][c - 1]
        else:
            # Default color and direction when all neighbors are background
            direction = 'N'
            src_color = 1

        if direction == 'N':
            for rr in range(r, -1, -1):
                out[rr][c] = src_color
        elif direction == 'S':
            for rr in range(r, h):
                out[rr][c] = src_color
        elif direction == 'E':
            for cc in range(c, w):
                out[r][cc] = src_color
        else:  # 'W'
            for cc in range(c, -1, -1):
                out[r][cc] = src_color

    # Return as a tuple of tuples
    return tuple(tuple(row) for row in out)

