# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 948217a5
Difficulty: insane

=== Tags ===
- Motif extraction
- Local rule cascade

=== Description ===
Cascading Motif Reconfiguration  Input grids display a dense, non-overlapping
arrangement of 4-6 distinct colored motifs (each a connected region of single
color) against a uniform background. Motifs vary significantly in shape: some
contain central symmetry (e.g., star-shaped clusters with 5+ arms), others
feature concave edges or branching structures. All motifs are separated by at
least one background cell from other motifs and grid boundaries.  The output
grid is generated through a two-stage local rule cascade:  1. **Motif
Classification:** Each motif is classified into one of three visual types based
on its structural properties:    - *Type A:* Contains a central cell with four
diagonal arms extending outward (e.g., a cross with equal-length arms)    -
*Type B:* Features a single concave indentation on one side (e.g., a "C" shape
with consistent curvature)    - *Type C:* All other shapes (e.g., jagged
clusters, asymmetric lines, or nested loops)  2. **Rule Cascade Application:**
Each motif's transformation depends on its classification and local context:
- *Type A:* Replace the motif's color with the color of the nearest motif in the
left horizontal direction (if exists; otherwise retain original color)    -
*Type B:* Shift the entire motif's position downward by one cell if space is
available; otherwise shift right by one cell    - *Type C:* Merge with the
nearest Type A motif (by Manhattan distance), replacing the Type C's color with
the Type A's color and removing the Type C from the grid  The output grid
reconstructs all motifs with transformed colors and positions, maintaining their
relative spatial relationships. Overlaps between transformed motifs are resolved
by prioritizing downward shifts over right shifts during position updates. The
background remains unchanged, and no new motifs are introduced. This requires
simultaneous visual pattern recognition of shape types, spatial analysis of
motif relationships, and application of cascading positional and color rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, continuous_creature

# Helper to compute bounding box and related metrics

def bbox(coords):
    rs = [r for r, c in coords]
    cs = [c for r, c in coords]
    return min(rs), max(rs), min(cs), max(cs)


def int_center(coords):
    # integer center based on bounding box center
    min_r, max_r, min_c, max_c = bbox(coords)
    return ((min_r + max_r) // 2, (min_c + max_c) // 2)


def make_shape_A(arm_len):
    # plus shape (cardinal arms) centered in a box of size 2*arm_len+1
    size = 2 * arm_len + 1
    center = arm_len
    coords = set()
    coords.add((center, center))
    for k in range(1, arm_len + 1):
        coords.add((center - k, center))
        coords.add((center + k, center))
        coords.add((center, center - k))
        coords.add((center, center + k))
    return sorted(coords)


def make_shape_B(h, w, opening):
    # "C"-like shape of size h x w with opening on one side
    coords = set()
    # left vertical column
    for r in range(h):
        coords.add((r, 0))
    # top row
    for c in range(0, w):
        coords.add((0, c))
    # bottom row
    for c in range(0, w):
        coords.add((h - 1, c))
    # rotate/flip depending on opening
    if opening == 'right':
        return sorted(coords)
    if opening == 'left':
        # reflect horizontally
        return sorted([(r, w - 1 - c) for (r, c) in coords])
    if opening == 'top':
        # transpose with opening on top
        return sorted([(c, r) for (r, c) in coords])
    # opening == 'bottom'
    return sorted([(h - 1 - c, r) for (r, c) in coords])


def make_shape_C(size):
    # Use common.continuous_creature to make a 4-connected shape inside a small box
    box = max(3, min(6, size))
    coords = continuous_creature(size, width=box, height=box)
    return sorted(coords)


def place_shape(input_grid, reserved, shape_coords, color, width, height):
    # shape_coords are relative to (0,0) within a bounding box; place with at least one-cell margin
    min_r, max_r, min_c, max_c = bbox(shape_coords)
    shape_h = max_r - min_r + 1
    shape_w = max_c - min_c + 1
    # allowable start positions to maintain 1-cell margin from boundaries
    r0_min = 1
    r0_max = height - shape_h - 1
    c0_min = 1
    c0_max = width - shape_w - 1
    if r0_min > r0_max or c0_min > c0_max:
        return None
    tries = 200
    for _ in range(tries):
        r0 = random.randint(r0_min, r0_max)
        c0 = random.randint(c0_min, c0_max)
        abs_cells = [(r0 + (r - min_r), c0 + (c - min_c)) for (r, c) in shape_coords]
        conflict = False
        for (ar, ac) in abs_cells:
            # check reserved area within one-cell border
            for dr in (-1, 0, 1):
                for dc in (-1, 0, 1):
                    nr, nc = ar + dr, ac + dc
                    if nr < 0 or nr >= height or nc < 0 or nc >= width:
                        conflict = True
                        break
                    if (nr, nc) in reserved:
                        conflict = True
                        break
                if conflict:
                    break
            if conflict:
                break
        if conflict:
            continue
        # place shape
        for (ar, ac) in abs_cells:
            input_grid[ar][ac] = color
        # mark reserved cells (shape plus 1-cell border)
        for (ar, ac) in abs_cells:
            for dr in (-1, 0, 1):
                for dc in (-1, 0, 1):
                    reserved.add((ar + dr, ac + dc))
        return abs_cells
    return None


def classify_pixels(pixels_set):
    # pixels_set is a set of (r,c) tuples
    pixels = pixels_set
    # Type A: has a center with four cardinal arms or four diagonal arms
    for (r, c) in pixels:
        if (r - 1, c) in pixels and (r + 1, c) in pixels and (r, c - 1) in pixels and (r, c + 1) in pixels:
            return 'A'
        if (r - 1, c - 1) in pixels and (r - 1, c + 1) in pixels and (r + 1, c - 1) in pixels and (r + 1, c + 1) in pixels:
            return 'A'
    # Type B: occupies three sides of its bounding box (concave / C-like)
    rs = [r for r, c in pixels]
    cs = [c for r, c in pixels]
    min_r, max_r, min_c, max_c = min(rs), max(rs), min(cs), max(cs)
    top = sum(1 for (r, c) in pixels if r == min_r)
    bottom = sum(1 for (r, c) in pixels if r == max_r)
    left = sum(1 for (r, c) in pixels if c == min_c)
    right = sum(1 for (r, c) in pixels if c == max_c)
    sides_nonempty = sum(1 for v in (top, bottom, left, right) if v > 0)
    if sides_nonempty == 3:
        return 'B'
    return 'C'


def generate():
    # Create until we produce a non-trivial transformation
    for attempt in range(500):
        width = random.randint(12, 18)
        height = random.randint(12, 18)
        input_grid = grid(width, height, 0)
        N = random.randint(4, 6)
        colors = random.sample(list(range(1, 10)), N)
        # ensure at least one of each type A,B,C
        types = ['A', 'B', 'C']
        for _ in range(N - 3):
            types.append(random.choice(['A', 'B', 'C']))
        random.shuffle(types)
        motifs = []
        reserved = set()
        success = True
        for i, t in enumerate(types):
            color = colors[i]
            if t == 'A':
                arm_len = random.randint(1, 3)
                shape = make_shape_A(arm_len)
            elif t == 'B':
                h = random.randint(3, 5)
                w = random.randint(3, 6)
                opening = random.choice(['right', 'left', 'top', 'bottom'])
                shape = make_shape_B(h, w, opening)
            else:
                size = random.randint(4, 9)
                shape = make_shape_C(size)
            placed = place_shape(input_grid, reserved, shape, color, width, height)
            if not placed:
                success = False
                break
            motifs.append({'type': t, 'color': color, 'shape': shape, 'cells': placed})
        if not success:
            continue

        # Build motif metadata (absolute cells, bbox, integer centroid)
        motif_infos = []
        for idx, m in enumerate(motifs):
            cells = set(m['cells'])
            min_r, max_r, min_c, max_c = bbox(cells)
            ctr = int_center(cells)
            motif_infos.append({
                'id': idx,
                'type': m['type'],
                'color': m['color'],
                'cells': cells,
                'min_r': min_r,
                'max_r': max_r,
                'min_c': min_c,
                'max_c': max_c,
                'ctr': ctr,
            })

        # Re-classify via geometry to be consistent
        for m in motif_infos:
            m['type'] = classify_pixels(m['cells'])

        # Compute new colors for A and C and desired moves for B
        for m in motif_infos:
            m['new_color'] = m['color']
        # Type A: recolor to nearest motif to the left
        for m in motif_infos:
            if m['type'] != 'A':
                continue
            left_candidates = []
            for o in motif_infos:
                if o['id'] == m['id']:
                    continue
                if o['max_c'] < m['min_c']:
                    horiz_gap = m['min_c'] - o['max_c']
                    vert_gap = abs(m['ctr'][0] - o['ctr'][0])
                    manhattan = horiz_gap + vert_gap
                    left_candidates.append((horiz_gap, vert_gap, manhattan, o['min_r'], o['min_c'], o['color']))
            if left_candidates:
                left_candidates.sort()
                m['new_color'] = left_candidates[0][5]
        # Type C: recolor to nearest Type A (manhattan)
        typeA_list = [o for o in motif_infos if o['type'] == 'A']
        for m in motif_infos:
            if m['type'] != 'C':
                continue
            if not typeA_list:
                continue
            dlist = []
            for a in typeA_list:
                dist = abs(m['ctr'][0] - a['ctr'][0]) + abs(m['ctr'][1] - a['ctr'][1])
                dlist.append((dist, a['min_r'], a['min_c'], a['color']))
            dlist.sort()
            m['new_color'] = dlist[0][3]

        # Type B: determine desired move based on initial emptiness
        for m in motif_infos:
            m['desired_move'] = 'none'
            m['priority'] = 0
            if m['type'] == 'B':
                can_down = True
                can_right = True
                for (r, c) in m['cells']:
                    if r + 1 >= height or input_grid[r + 1][c] != 0:
                        can_down = False
                    if c + 1 >= width or input_grid[r][c + 1] != 0:
                        can_right = False
                if can_down:
                    m['desired_move'] = 'down'
                    m['priority'] = 2
                elif can_right:
                    m['desired_move'] = 'right'
                    m['priority'] = 1

        # Resolve move conflicts by priority, then by position (min_r, min_c, max_r, max_c, color)
        claimed = set()
        order = sorted(motif_infos, key=lambda mm: (-mm['priority'], mm['min_r'], mm['min_c'], mm['max_r'], mm['max_c'], mm['color']))
        for m in order:
            if m['desired_move'] == 'down':
                target = set((r + 1, c) for (r, c) in m['cells'])
                if any((r < 0 or r >= height or c < 0 or c >= width or ((r, c) in claimed)) for (r, c) in target):
                    m['final_cells'] = set(m['cells'])
                    for cell in m['final_cells']:
                        claimed.add(cell)
                else:
                    m['final_cells'] = target
                    for cell in target:
                        claimed.add(cell)
            elif m['desired_move'] == 'right':
                target = set((r, c + 1) for (r, c) in m['cells'])
                if any((r < 0 or r >= height or c < 0 or c >= width or ((r, c) in claimed)) for (r, c) in target):
                    m['final_cells'] = set(m['cells'])
                    for cell in m['final_cells']:
                        claimed.add(cell)
                else:
                    m['final_cells'] = target
                    for cell in target:
                        claimed.add(cell)
            else:
                m['final_cells'] = set(m['cells'])
                for cell in m['final_cells']:
                    claimed.add(cell)

        # Build output grid
        output_grid = [[0 for _ in range(width)] for __ in range(height)]
        for m in motif_infos:
            for (r, c) in m['final_cells']:
                output_grid[r][c] = m['new_color']

        if input_grid == output_grid:
            continue
        return {'input': input_grid, 'output': output_grid}
    raise RuntimeError('Failed to generate sample')



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    height = len(input_list)
    width = len(input_list[0])

    # Flood fill to find motifs (4-neighbor connectivity)
    visited = [[False] * width for _ in range(height)]
    motifs = []
    for r in range(height):
        for c in range(width):
            if input_list[r][c] == 0 or visited[r][c]:
                continue
            color = input_list[r][c]
            stack = [(r, c)]
            visited[r][c] = True
            cells = []
            while stack:
                rr, cc = stack.pop()
                cells.append((rr, cc))
                for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_list[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            motifs.append({'color': color, 'cells': set(cells)})

    def bbox(coords):
        rs = [r for r, c in coords]
        cs = [c for r, c in coords]
        return min(rs), max(rs), min(cs), max(cs)

    def int_center(coords):
        min_r, max_r, min_c, max_c = bbox(coords)
        return ((min_r + max_r) // 2, (min_c + max_c) // 2)

    def classify_pixels(pixels_set):
        pixels = pixels_set
        for (r, c) in pixels:
            if (r - 1, c) in pixels and (r + 1, c) in pixels and (r, c - 1) in pixels and (r, c + 1) in pixels:
                return 'A'
            if (r - 1, c - 1) in pixels and (r - 1, c + 1) in pixels and (r + 1, c - 1) in pixels and (r + 1, c + 1) in pixels:
                return 'A'
        rs = [r for r, c in pixels]
        cs = [c for r, c in pixels]
        min_r, max_r, min_c, max_c = min(rs), max(rs), min(cs), max(cs)
        top = sum(1 for (r, c) in pixels if r == min_r)
        bottom = sum(1 for (r, c) in pixels if r == max_r)
        left = sum(1 for (r, c) in pixels if c == min_c)
        right = sum(1 for (r, c) in pixels if c == max_c)
        sides_nonempty = sum(1 for v in (top, bottom, left, right) if v > 0)
        if sides_nonempty == 3:
            return 'B'
        return 'C'

    motif_infos = []
    for idx, m in enumerate(motifs):
        cells = m['cells']
        min_r, max_r, min_c, max_c = bbox(cells)
        ctr = int_center(cells)
        motif_infos.append({
            'id': idx,
            'type': classify_pixels(cells),
            'color': m['color'],
            'cells': cells,
            'min_r': min_r,
            'max_r': max_r,
            'min_c': min_c,
            'max_c': max_c,
            'ctr': ctr,
        })

    # Compute new colors for A and C and desired moves for B
    for m in motif_infos:
        m['new_color'] = m['color']
    for m in motif_infos:
        if m['type'] != 'A':
            continue
        left_candidates = []
        for o in motif_infos:
            if o['id'] == m['id']:
                continue
            if o['max_c'] < m['min_c']:
                horiz_gap = m['min_c'] - o['max_c']
                vert_gap = abs(m['ctr'][0] - o['ctr'][0])
                manhattan = horiz_gap + vert_gap
                left_candidates.append((horiz_gap, vert_gap, manhattan, o['min_r'], o['min_c'], o['color']))
        if left_candidates:
            left_candidates.sort()
            m['new_color'] = left_candidates[0][5]

    typeA_list = [o for o in motif_infos if o['type'] == 'A']
    for m in motif_infos:
        if m['type'] != 'C':
            continue
        if not typeA_list:
            continue
        dlist = []
        for a in typeA_list:
            dist = abs(m['ctr'][0] - a['ctr'][0]) + abs(m['ctr'][1] - a['ctr'][1])
            dlist.append((dist, a['min_r'], a['min_c'], a['color']))
        dlist.sort()
        m['new_color'] = dlist[0][3]

    for m in motif_infos:
        m['desired_move'] = 'none'
        m['priority'] = 0
        if m['type'] == 'B':
            can_down = True
            can_right = True
            for (r, c) in m['cells']:
                if r + 1 >= height or input_list[r + 1][c] != 0:
                    can_down = False
                if c + 1 >= width or input_list[r][c + 1] != 0:
                    can_right = False
            if can_down:
                m['desired_move'] = 'down'
                m['priority'] = 2
            elif can_right:
                m['desired_move'] = 'right'
                m['priority'] = 1

    claimed = set()
    order = sorted(motif_infos, key=lambda mm: (-mm['priority'], mm['min_r'], mm['min_c'], mm['max_r'], mm['max_c'], mm['color']))
    for m in order:
        if m['desired_move'] == 'down':
            target = set((r + 1, c) for (r, c) in m['cells'])
            if any((r < 0 or r >= height or c < 0 or c >= width or ((r, c) in claimed)) for (r, c) in target):
                m['final_cells'] = set(m['cells'])
                for cell in m['final_cells']:
                    claimed.add(cell)
            else:
                m['final_cells'] = target
                for cell in target:
                    claimed.add(cell)
        elif m['desired_move'] == 'right':
            target = set((r, c + 1) for (r, c) in m['cells'])
            if any((r < 0 or r >= height or c < 0 or c >= width or ((r, c) in claimed)) for (r, c) in target):
                m['final_cells'] = set(m['cells'])
                for cell in m['final_cells']:
                    claimed.add(cell)
            else:
                m['final_cells'] = target
                for cell in target:
                    claimed.add(cell)
        else:
            m['final_cells'] = set(m['cells'])
            for cell in m['final_cells']:
                claimed.add(cell)

    output = [[0 for _ in range(width)] for __ in range(height)]
    for m in motif_infos:
        color = m['new_color']
        for (r, c) in m['final_cells']:
            output[r][c] = color

    return tuple(tuple(row) for row in output)

