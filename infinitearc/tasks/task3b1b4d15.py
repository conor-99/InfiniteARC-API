# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 3b1b4d15
Difficulty: hard

=== Tags ===
- Connect the dots
- Size guessing
- Create image from info
- Replace pattern

=== Description ===
The input grid consists of scattered non-zero values (dots) representing
individual points. The output grid is generated by connecting all these points
in a straight line between consecutive points (sorted first by row, then by
column) using a grid line-drawing algorithm. The color of the connecting line in
the output is determined by the number of dots (N) in the input, where N is the
count of non-zero cells. For instance, if the input contains 5 dots, the
connecting lines are drawn with the color 5. All other cells in the output grid
are set to 0 (background). This task requires recognizing the dot positions,
counting them to determine the line color, and correctly drawing the connecting
lines based on their sorted order, which constitutes a hard-level reasoning
challenge involving spatial pattern recognition and numerical size inference.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    N = random.randint(1, 9)
    points = []
    while len(points) < N:
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        if (r, c) not in points:
            points.append((r, c))
    input_grid = [[0] * width for _ in range(height)]
    for r, c in points:
        input_grid[r][c] = 1
    points.sort(key=lambda x: (x[0], x[1]))
    output_grid = [[0] * width for _ in range(height)]
    def draw_line(x0, y0, x1, y1, grid, color):
        dx = abs(x1 - x0)
        dy = abs(y1 - y0)
        sx = 1 if x0 < x1 else -1
        sy = 1 if y0 < y1 else -1
        err = dx - dy
        while True:
            grid[x0][y0] = color
            if x0 == x1 and y0 == y1:
                break
            e2 = 2 * err
            if e2 > -dy:
                err -= dy
                x0 += sx
            if e2 < dx:
                err += dx
                y0 += sy
    for i in range(len(points) - 1):
        x0, y0 = points[i]
        x1, y1 = points[i+1]
        draw_line(x0, y0, x1, y1, output_grid, N)
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    points = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                points.append((r, c))
    N = len(points)
    if N == 0:
        return [[0] * width for _ in range(height)]
    points.sort(key=lambda x: (x[0], x[1]))
    output_grid = [[0] * width for _ in range(height)]
    def draw_line(x0, y0, x1, y1, grid, color):
        dx = abs(x1 - x0)
        dy = abs(y1 - y0)
        sx = 1 if x0 < x1 else -1
        sy = 1 if y0 < y1 else -1
        err = dx - dy
        while True:
            grid[x0][y0] = color
            if x0 == x1 and y0 == y1:
                break
            e2 = 2 * err
            if e2 > -dy:
                err -= dy
                x0 += sx
            if e2 < dx:
                err += dx
                y0 += sy
    for i in range(len(points) - 1):
        x0, y0 = points[i]
        x1, y1 = points[i+1]
        draw_line(x0, y0, x1, y1, output_grid, N)
    return output_grid
