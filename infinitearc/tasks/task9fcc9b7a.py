# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 9fcc9b7a
Difficulty: medium–hard

=== Tags ===
- Rule embedding
- Pattern juxtaposition
- Count touches

=== Description ===
Input grids contain a background (color 0) and multiple non-background regions
(colors 1-9). The target color T is the color of the top-left non-background
cell. For each non-background color C (C ≠ T), count the number of cells in the
C region that are adjacent (horizontally or vertically) to any cell of color T.
In the output, replace all cells of color C with this count (0-9), while keeping
background (0) and T unchanged. Regions with no adjacency to T are replaced with
background (0), ensuring the output grid differs from the input.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    width = common.randint(2, 30)
    height = common.randint(2, 30)
    grid = [[0] * width for _ in range(height)]
    T = common.random_color(exclude=[0])
    grid[0][0] = T
    
    C1 = common.random_color(exclude=[0, T])
    if width > 1:
        grid[0][1] = C1
        if height > 1:
            grid[1][1] = C1
    
    C2 = common.random_color(exclude=[0, T, C1])
    if width > 2 and height > 2:
        grid[2][2] = C2
        if width > 3 and height > 3:
            grid[3][3] = C2
    
    colors_present = set()
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and grid[r][c] != T:
                colors_present.add(grid[r][c])
    
    counts = {}
    for C in colors_present:
        count = 0
        for r in range(height):
            for c in range(width):
                if grid[r][c] == C:
                    for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == T:
                            count += 1
                            break
        counts[C] = count
    
    output = [[0]*width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 or grid[r][c] == T:
                output[r][c] = grid[r][c]
            else:
                output[r][c] = counts[grid[r][c]]
    
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height else 0
    
    T = None
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                T = grid[r][c]
                break
        if T is not None:
            break
    if T is None:
        return input_grid
    
    colors_present = set()
    for r in range(height):
        for c in range(width):
            color = grid[r][c]
            if color != 0 and color != T:
                colors_present.add(color)
    
    counts = {}
    for C in colors_present:
        count = 0
        for r in range(height):
            for c in range(width):
                if grid[r][c] == C:
                    for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == T:
                            count += 1
                            break
        counts[C] = count
    
    output = [[0]*width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            color = grid[r][c]
            if color == 0 or color == T:
                output[r][c] = color
            else:
                output[r][c] = counts[color]
    
    return output
