# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 3264f88b
Difficulty: hard

=== Tags ===
- Field interference pattern
- Heat map draw
- Recursive path tracing

=== Description ===
Input grids feature a background color (0) and multiple heat sources (colors
1â€“8) positioned at various locations. Each heat source emits a field that
spreads outward in all four orthogonal directions (up, down, left, right), with
the field's reach determined by the source's color value (e.g., a source of
color 3 extends 3 cells in each direction). The field strength diminishes by 1
per cell away from the source, but only cells within the source's reach are
affected. When multiple fields overlap at a cell, the cell's color in the output
is the maximum of all overlapping source colors. Cells not within any source's
reach remain background (0).  Additionally, a recursive path is traced starting
from the cell with the highest color value (the maximum value in the heat map).
The path moves to the neighboring cell (up, down, left, right) with the highest
color value, breaking ties by prioritizing right > down > left > up. This
process repeats recursively until no higher-value neighbors exist. The path is
drawn on the output grid using color 9, overwriting only background (0) cells
from the heat map; non-background cells along the path retain their heat map
color. The output grid combines the heat map (with colors derived from
overlapping fields) and the recursive path (color 9), with all other cells
unchanged from the heat map representation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from typing import List, Tuple

def generate():
    while True:
        width = random.randint(5, 30)
        height = random.randint(5, 30)
        input_grid = [[0] * width for _ in range(height)]
        
        # Place 1-10 sources
        num_sources = random.randint(1, 10)
        for _ in range(num_sources):
            r = random.randint(0, height-1)
            c = random.randint(0, width-1)
            color = random.randint(1, 8)
            input_grid[r][c] = color

        # Compute heat map
        heat_map = [[0] * width for _ in range(height)]
        for sr in range(height):
            for sc in range(width):
                k = input_grid[sr][sc]
                if k == 0:
                    continue
                
                # Source cell
                if k > heat_map[sr][sc]:
                    heat_map[sr][sc] = k
                
                # Up
                for dr in range(1, k):
                    nr, nc = sr - dr, sc
                    if nr < 0:
                        break
                    val = k - dr
                    if val > heat_map[nr][nc]:
                        heat_map[nr][nc] = val
                
                # Down
                for dr in range(1, k):
                    nr, nc = sr + dr, sc
                    if nr >= height:
                        break
                    val = k - dr
                    if val > heat_map[nr][nc]:
                        heat_map[nr][nc] = val
                
                # Left
                for dc in range(1, k):
                    nr, nc = sr, sc - dc
                    if nc < 0:
                        break
                    val = k - dc
                    if val > heat_map[nr][nc]:
                        heat_map[nr][nc] = val
                
                # Right
                for dc in range(1, k):
                    nr, nc = sr, sc + dc
                    if nc >= width:
                        break
                    val = k - dc
                    if val > heat_map[nr][nc]:
                        heat_map[nr][nc] = val

        # Find unique max
        max_val = 0
        max_cells = []
        for r in range(height):
            for c in range(width):
                if heat_map[r][c] > max_val:
                    max_val = heat_map[r][c]
                    max_cells = [(r, c)]
                elif heat_map[r][c] == max_val:
                    max_cells.append((r, c))
        
        if len(max_cells) != 1:
            continue

        # Trace path (allow equal values for path movement)
        current = max_cells[0]
        path_cells = []
        
        while True:
            best_val = -1
            best_dir = None
            directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up
            for dr, dc in directions:
                nr, nc = current[0] + dr, current[1] + dc
                if 0 <= nr < height and 0 <= nc < width:
                    val = heat_map[nr][nc]
                    if val > best_val:
                        best_val = val
                        best_dir = (dr, dc)
            
            # Allow movement to equal or higher values
            if best_val < heat_map[current[0]][current[1]]:
                break
            
            current = (current[0] + best_dir[0], current[1] + best_dir[1])
            if heat_map[current[0]][current[1]] == 0:
                path_cells.append(current)

        # Create output grid
        output_grid = [row[:] for row in heat_map]
        for r, c in path_cells:
            output_grid[r][c] = 9

        return {
            "input": input_grid,
            "output": output_grid
        }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from typing import List, Tuple

def p(input_grid: Tuple[Tuple[int, ...], ...]) -> List[List[int]]:
    width = len(input_grid[0])
    height = len(input_grid)
    input_list = [list(row) for row in input_grid]

    # Compute heat map
    heat_map = [[0] * width for _ in range(height)]
    for sr in range(height):
        for sc in range(width):
            k = input_list[sr][sc]
            if k == 0:
                continue
            
            # Source cell
            if k > heat_map[sr][sc]:
                heat_map[sr][sc] = k
            
            # Up
            for dr in range(1, k):
                nr, nc = sr - dr, sc
                if nr < 0:
                    break
                val = k - dr
                if val > heat_map[nr][nc]:
                    heat_map[nr][nc] = val
            
            # Down
            for dr in range(1, k):
                nr, nc = sr + dr, sc
                if nr >= height:
                    break
                val = k - dr
                if val > heat_map[nr][nc]:
                    heat_map[nr][nc] = val
            
            # Left
            for dc in range(1, k):
                nr, nc = sr, sc - dc
                if nc < 0:
                    break
                val = k - dc
                if val > heat_map[nr][nc]:
                    heat_map[nr][nc] = val
            
            # Right
            for dc in range(1, k):
                nr, nc = sr, sc + dc
                if nc >= width:
                    break
                val = k - dc
                if val > heat_map[nr][nc]:
                    heat_map[nr][nc] = val

    # Find unique max
    max_val = 0
    max_cells = []
    for r in range(height):
        for c in range(width):
            if heat_map[r][c] > max_val:
                max_val = heat_map[r][c]
                max_cells = [(r, c)]
            elif heat_map[r][c] == max_val:
                max_cells.append((r, c))
    
    if len(max_cells) != 1:
        raise ValueError("No unique max in heat map")

    # Trace path (allow equal values for path movement)
    current = max_cells[0]
    path_cells = []
    
    while True:
        best_val = -1
        best_dir = None
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up
        for dr, dc in directions:
            nr, nc = current[0] + dr, current[1] + dc
            if 0 <= nr < height and 0 <= nc < width:
                val = heat_map[nr][nc]
                if val > best_val:
                    best_val = val
                    best_dir = (dr, dc)
        
        # Allow movement to equal or higher values
        if best_val < heat_map[current[0]][current[1]]:
            break
        
        current = (current[0] + best_dir[0], current[1] + best_dir[1])
        if heat_map[current[0]][current[1]] == 0:
            path_cells.append(current)

    # Create output grid
    output_grid = [row[:] for row in heat_map]
    for r, c in path_cells:
        output_grid[r][c] = 9

    return output_grid
