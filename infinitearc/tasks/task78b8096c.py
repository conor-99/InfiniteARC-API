# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 78b8096c
Difficulty: very hard

=== Tags ===
- Rule gate simulation
- Color particle fall
- Diagonals

=== Description ===
Task Name: Diagonal Rule Gate Cascade  Description: Input grids feature a
background color (0) with two primary elements: 1. **Color Particles**: Single
cells of colors 1-9 positioned at various locations, not aligned with gate
structures. 2. **Rule Gates**: Diagonal sequences (top-left to bottom-right or
top-right to bottom-left) of three or more consecutive cells of a single non-
background color. Each gate's color determines the new color particles adopt
upon interaction.  The transformation rule: - Each particle falls diagonally
along the direction of the nearest gate it intersects. Particles moving toward a
top-left-to-bottom-right gate fall down-right (increasing row and column), while
those toward a top-right-to-bottom-left gate fall down-left (increasing row,
decreasing column). - Upon intersecting a gate cell, a particle's color
immediately changes to the gate's color and continues falling in the same
direction. - The output grid depicts the complete path of each particle from its
starting position to grid exit, with color changes reflected at gate
intersections. Background cells remain unchanged, and paths occupy only
background cells (never overlapping gates or other paths).  The task requires
identifying gate directions, tracking color transitions along paths, and
rendering the final diagonal trajectories. The complexity arises from multiple
gate orientations, overlapping path dependencies, and precise color mapping at
interaction points.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random


def generate():
    # Create a random grid size (kept reasonable for complexity)
    width = random.randint(7, 20)
    height = random.randint(7, 20)

    # We'll retry the whole placement if we can't place a valid configuration
    for overall_try in range(50):
        grid = [[0 for _ in range(width)] for _ in range(height)]

        gate_cells = set()            # set of coordinates that are gate cells
        gate_map = {}                 # map coord -> gate color
        gates = []                    # list of gates (orientation, cells, color)

        max_gate_len = min(6, width, height)
        desired_gates = random.randint(2, min(4, 6))

        used_gate_colors = set()

        place_tries = 0
        # Place gates with constraints so they don't lie on the same full diagonal
        while len(gates) < desired_gates and place_tries < 500:
            place_tries += 1
            orientation = random.choice(['DR', 'DL'])  # DR: top-left->bottom-right (\\), DL: top-right->bottom-left (/)
            length = random.randint(3, max_gate_len)

            if orientation == 'DR':
                # Require some upstream space so particles can be placed
                if height - length < 1 or width - length < 1:
                    continue
                start_r = random.randint(1, height - length)
                start_c = random.randint(1, width - length)
                coords = [(start_r + i, start_c + i) for i in range(length)]
                diag_key = start_r - start_c
                # Reject if any existing gate sits on the same TL-BR diagonal (r-c equal)
                conflict = any((gr - gc) == diag_key for (gr, gc) in gate_cells)
                if conflict:
                    continue
            else:  # orientation == 'DL'
                if height - length < 1 or width - length < 1:
                    continue
                # start_c must be at least length-1 and allow at least one upstream column
                start_c_min = length - 1
                start_c_max = width - 2
                if start_c_min > start_c_max:
                    continue
                start_r = random.randint(1, height - length)
                start_c = random.randint(start_c_min, start_c_max)
                coords = [(start_r + i, start_c - i) for i in range(length)]
                diag_key = start_r + start_c
                # Reject if any existing gate sits on the same TR-BL diagonal (r+c equal)
                conflict = any((gr + gc) == diag_key for (gr, gc) in gate_cells)
                if conflict:
                    continue

            # Ensure all coords are free and in bounds
            ok = True
            for (r, c) in coords:
                if r < 0 or r >= height or c < 0 or c >= width or grid[r][c] != 0:
                    ok = False
                    break
            if not ok:
                continue

            # Pick a gate color (try to keep gate colors distinct)
            available_colors = [c for c in range(1, 10) if c not in used_gate_colors]
            if not available_colors:
                available_colors = list(range(1, 10))
            color = random.choice(available_colors)
            used_gate_colors.add(color)

            # Place the gate
            for (r, c) in coords:
                grid[r][c] = color
                gate_cells.add((r, c))
                gate_map[(r, c)] = color

            gates.append({'orientation': orientation, 'cells': coords, 'color': color})

        # Need at least two gates for interesting behavior
        if len(gates) < 2:
            # try new dimensions and placement
            width = random.randint(7, 20)
            height = random.randint(7, 20)
            continue

        # Place one particle per gate if possible (can be more in principle)
        path_occupied = set()  # cells that will be painted by particle paths (background cells only)
        particles = []         # list of {'pos':(r,c),'color':int,'dir':(dr,dc)}

        def first_gate_on_ray(pr, pc, dr, dc):
            k = 1
            while True:
                nr = pr + k * dr
                nc = pc + k * dc
                if nr < 0 or nr >= height or nc < 0 or nc >= width:
                    return None, None
                if (nr, nc) in gate_cells:
                    return (nr, nc), k
                k += 1

        for g in gates:
            placed = False
            # try a few candidate upstream positions (randomized)
            for _ in range(40):
                # pick a gate cell to seed upstream placement (gives more upstream options)
                gate_cell = random.choice(g['cells'])
                gr, gc = gate_cell
                if g['orientation'] == 'DR':
                    max_up = min(gr, gc)
                    if max_up < 1:
                        continue
                    d = random.randint(1, max_up)
                    pr, pc = gr - d, gc - d
                else:  # DL orientation
                    max_up = min(gr, width - 1 - gc)
                    if max_up < 1:
                        continue
                    d = random.randint(1, max_up)
                    pr, pc = gr - d, gc + d

                if grid[pr][pc] != 0:
                    continue  # must place particle on background
                if (pr, pc) in path_occupied:
                    continue  # don't put a particle where an earlier path will paint

                # Find first gate intersections in both diagonal directions
                f_dr, k_dr = first_gate_on_ray(pr, pc, 1, 1)
                f_dl, k_dl = first_gate_on_ray(pr, pc, 1, -1)

                if f_dr is None and f_dl is None:
                    # This candidate won't intersect any gate
                    continue

                # choose direction: nearest gate intersection wins; tie-break to DR
                if f_dr is None:
                    dr, dc = 1, -1
                elif f_dl is None:
                    dr, dc = 1, 1
                else:
                    if k_dr <= k_dl:
                        dr, dc = 1, 1
                    else:
                        dr, dc = 1, -1

                # Simulate the path and ensure every background cell that would be painted is free
                trail = []
                rcur, ccur = pr, pc
                safe = True
                while True:
                    rcur += dr
                    ccur += dc
                    if rcur < 0 or rcur >= height or ccur < 0 or ccur >= width:
                        break
                    if (rcur, ccur) in gate_cells:
                        # color changes at gate, but gate cells are not painted as part of path
                        continue
                    # Painted cells must be background in the input and not already reserved
                    if grid[rcur][ccur] != 0 or (rcur, ccur) in path_occupied:
                        safe = False
                        break
                    trail.append((rcur, ccur))

                if not safe:
                    continue

                # Choose a particle color distinct from gate colors when possible
                particle_color_candidates = [c for c in range(1, 10) if c not in used_gate_colors]
                if not particle_color_candidates:
                    particle_color_candidates = list(range(1, 10))
                pcolor = random.choice(particle_color_candidates)

                # Place the particle and reserve its trail
                grid[pr][pc] = pcolor
                particles.append({'pos': (pr, pc), 'color': pcolor, 'dir': (dr, dc)})
                for pcell in trail:
                    path_occupied.add(pcell)

                placed = True
                break

            # if not placed after attempts we simply skip this gate (it's allowed to have gates without particles)

        # Require at least one particle in the whole grid
        if len(particles) == 0:
            # try another whole placement
            width = random.randint(7, 20)
            height = random.randint(7, 20)
            continue

        # Build the output by simulating each particle's diagonal fall, changing color at gate intersections
        output = [row[:] for row in grid]
        for p in particles:
            pr, pc = p['pos']
            dr, dc = p['dir']
            cur_color = p['color']
            rcur, ccur = pr, pc
            while True:
                rcur += dr
                ccur += dc
                if rcur < 0 or rcur >= height or ccur < 0 or ccur >= width:
                    break
                if (rcur, ccur) in gate_cells:
                    # change color to gate color and continue without painting the gate cell
                    cur_color = gate_map[(rcur, ccur)]
                    continue
                # paint the background cell along the path only if input was background
                if grid[rcur][ccur] == 0:
                    output[rcur][ccur] = cur_color

        return {'input': grid, 'output': output}

    # If we somehow failed to produce a valid scene, return the empty grid
    return {'input': grid, 'output': [row[:] for row in grid]}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # Detect gates: contiguous diagonal runs (TL-BR or TR-BL) of the same non-zero color length >= 3
    gate_cells = set()
    gate_map = {}

    visited = set()
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0:
                continue
            if (r, c) in visited:
                continue
            color = grid[r][c]
            # Check TL-BR diagonal run (\\)
            # step back to the head of the run
            br_r, br_c = r, c
            while br_r - 1 >= 0 and br_c - 1 >= 0 and grid[br_r - 1][br_c - 1] == color:
                br_r -= 1
                br_c -= 1
            run1 = []
            tr, tc = br_r, br_c
            while tr < height and tc < width and grid[tr][tc] == color:
                run1.append((tr, tc))
                tr += 1
                tc += 1
            if len(run1) >= 3:
                for cell in run1:
                    gate_cells.add(cell)
                    gate_map[cell] = color
                    visited.add(cell)
            # Check TR-BL diagonal run (/)
            bl_r, bl_c = r, c
            while bl_r - 1 >= 0 and bl_c + 1 < width and grid[bl_r - 1][bl_c + 1] == color:
                bl_r -= 1
                bl_c += 1
            run2 = []
            tr, tc = bl_r, bl_c
            while tr < height and tc >= 0 and grid[tr][tc] == color:
                run2.append((tr, tc))
                tr += 1
                tc -= 1
            if len(run2) >= 3:
                for cell in run2:
                    gate_cells.add(cell)
                    gate_map[cell] = color
                    visited.add(cell)

    # Particles are the remaining non-zero single cells not part of gates
    particles = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and (r, c) not in gate_cells:
                particles.append((r, c, grid[r][c]))

    # Helper: find first gate cell along a ray from (r,c) in direction (dr,dc)
    def first_gate_on_ray(pr, pc, dr, dc):
        k = 1
        while True:
            nr = pr + k * dr
            nc = pc + k * dc
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                return None, None
            if (nr, nc) in gate_cells:
                return (nr, nc), k
            k += 1

    # Prepare output as a copy of the input
    output = [row[:] for row in grid]

    # For each particle simulate its fall
    for (pr, pc, pcolor) in particles:
        # Determine direction by finding nearest gate intersection among the two diagonals
        f_dr, k_dr = first_gate_on_ray(pr, pc, 1, 1)
        f_dl, k_dl = first_gate_on_ray(pr, pc, 1, -1)

        # Choose direction: nearest gate intersection. If both none, default to down-right.
        if f_dr is None and f_dl is None:
            dr, dc = 1, 1
        elif f_dr is None:
            dr, dc = 1, -1
        elif f_dl is None:
            dr, dc = 1, 1
        else:
            if k_dr <= k_dl:
                dr, dc = 1, 1
            else:
                dr, dc = 1, -1

        # Walk along the chosen diagonal, painting background cells and changing color at gate intersections
        cur_color = pcolor
        rcur, ccur = pr, pc
        while True:
            rcur += dr
            ccur += dc
            if rcur < 0 or rcur >= height or ccur < 0 or ccur >= width:
                break
            if (rcur, ccur) in gate_cells:
                # When we hit a gate cell, immediately adopt its color and continue (do not paint the gate cell)
                cur_color = gate_map[(rcur, ccur)]
                continue
            # Only paint background cells
            if grid[rcur][ccur] == 0:
                output[rcur][ccur] = cur_color
            # If we encounter a non-background cell that isn't a gate (shouldn't happen in valid inputs), stop
            else:
                break

    return output

