# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 3bc35b86
Difficulty: medium

=== Tags ===
- Reconstruct checkerboard from hint
- Pattern juxtaposition
- Adapt image to grid

=== Description ===
The input grids display a checkerboard pattern with alternating colors (e.g., 0
and 1) across the grid, where some cells are replaced by a distinct hint color
(e.g., 9). The output grids correct these cells by replacing the hint color with
the appropriate checkerboard color based on the cell's position (i.e., (row +
column) parity: even sums get color 0, odd sums get color 1). The hint color (9)
is visually distinct and appears in positions that disrupt the checkerboard
pattern, requiring the solver to recognize the underlying parity-based pattern.
The transformation involves identifying the hint color, applying the parity rule
to its positions, and preserving all other cells unchanged. This task combines
pattern recognition (checkerboard), juxtaposition of the hint within the
pattern, and adaptation of the grid to complete the visual structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    input_grid = [[0 if (i + j) % 2 == 0 else 1 for j in range(width)] for i in range(height)]
    all_positions = [(i, j) for i in range(height) for j in range(width)]
    num_hints = random.randint(1, min(len(all_positions) - 1, width * height // 2))
    hint_positions = random.sample(all_positions, num_hints)
    for i, j in hint_positions:
        input_grid[i][j] = 9
    output_grid = [[0 if (i + j) % 2 == 0 else 1 for j in range(width)] for i in range(height)]
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    n = len(input_grid)
    m = len(input_grid[0])
    output = [[0] * m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            if input_grid[i][j] == 9:
                output[i][j] = 0 if (i + j) % 2 == 0 else 1
            else:
                output[i][j] = input_grid[i][j]
    return output
