# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 20258bf4
Difficulty: very hard

=== Tags ===
- Pattern intersection
- Surface unfolding
- Multi stage dependency chain

=== Description ===
Input grids depict a folded 2D surface composed of multiple rectangular panels,
each filled with a distinct non-background color. Panels are connected along
their edges (seams), with some seams overlapping in the input grid, causing
panels to intersect. The overlapping regions contain color values that indicate
the panel's "priority" for unfolding.  The output grid must be a linear
arrangement of all panels, placed edge-to-edge without overlaps, following these
rules:   1. **Pattern Intersection Resolution**: At each seam intersection, the
panel with the higher color value (numerically) dominates the seam, determining
the direction of unfolding. If seams overlap, the dominant panel's color is used
to resolve the order.   2. **Surface Unfolding Sequence**: Panels are arranged
in the output in ascending order of their color values. For each panel, its
orientation (rotated or mirrored) is determined by the dominant seam color of
its adjacent seams in the input.   3. **Multi-stage Dependency**: The position
and orientation of each panel depend on the previous panel's unfolding. For
example, a panel adjacent to the left in the input will be placed to the right
in the output, with rotation applied based on the seam's dominant color.    The
output grid is a single row or column of panels separated by background cells
(color 0), where each panel maintains its original shape and color. The
background cells are preserved between panels, and the grid dimensions are
scaled to accommodate all panels in sequence.    This task requires identifying
all panels, resolving overlapping seams through color-based priority, and
sequentially unfolding the surface while adhering to geometric dependencies,
making it very hard due to the combinatorial complexity of seam resolution and
the need for multi-stage geometric transformations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    n = random.randint(3, 5)
    colors = random.sample(range(1, 10), n)
    height = random.randint(2, 4)
    width = n + 1
    input_grid = grid(width, height, 0)
    for r in range(height):
        for c in range(n):
            input_grid[r][c] = colors[c]
    
    width_output = 2 * n + (n - 1)
    output_grid = grid(width_output, height, 0)
    sorted_colors = sorted(colors)
    for i, color in enumerate(sorted_colors):
        start_col = 2 * i + i
        for r in range(height):
            output_grid[r][start_col] = color
            output_grid[r][start_col + 1] = color
        if i < n - 1:
            for r in range(height):
                output_grid[r][start_col + 2] = 0
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    colors = sorted(set(color for row in input_list for color in row if color != 0))
    n = len(colors)
    width_output = 2 * n + (n - 1)
    height_output = len(input_list)
    output_grid = [[0] * width_output for _ in range(height_output)]
    
    for i, color in enumerate(colors):
        start_col = 2 * i + i
        for r in range(height_output):
            output_grid[r][start_col] = color
            output_grid[r][start_col + 1] = color
        if i < n - 1:
            for r in range(height_output):
                output_grid[r][start_col + 2] = 0
    return output_grid
