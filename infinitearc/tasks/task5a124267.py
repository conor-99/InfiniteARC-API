# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 5a124267
Difficulty: hard

=== Tags ===
- Deterministic reflection
- Recursive agent following
- Source target routing
- Hollow shape detection
- Outline shapes
- Holes

=== Description ===
Input grids feature multiple outline shapes (closed loops of a single non-
background color) with hollow interiors (background cells enclosed within the
loops). Each hollow interior contains either a source marker (color S) or a
target marker (color T), both placed within the hollow regions. The outlines may
be nested, with smaller hollows contained within larger ones, forming
hierarchical structures. Additionally, some outline shapes contain internal
"holes" (smaller enclosed regions within the hollow interior) formed by
secondary outlines, creating complex multi-layered hollow structures.   The
output grid must generate a path from the source to the target that traverses
only through hollow interiors (background cells), following a deterministic
recursive rule: the agent begins at the source, moving in a fixed initial
direction (e.g., east), and at each step, if the next cell is part of an outline
(non-background), the agent turns left (relative to current direction) and
continues. The path must navigate through nested hollows and internal holes,
respecting outline boundaries while avoiding all non-hollow cells. The path is
drawn using a distinct color, connecting the source to the target while
preserving all input elements. The recursion manifests as the agent following
the left-hand rule through hierarchical hollows, with each transition between
nested hollows requiring a directional adjustment based on the outline geometry.
The output uniquely reflects the shortest valid path under this rule, with all
outline shapes and markers preserved.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

_SEEN_PAIRS = set()

def generate():
    """Generates an ARC-like grid pair with nested outline rectangles (rings).

    The generator creates concentric rectangular outlines (colored 1-4), leaves
    a single aligned gateway (a gap) in each ring so hollows are connected, and
    places a source (5) in the outer hollow and a target (6) in the innermost
    hollow. It then simulates a deterministic agent that starts facing east and
    turns left whenever the forward cell is blocked (non-background). The
    visited background cells (excluding the markers) are painted with color 7
    in the output.
    """
    global _SEEN_PAIRS

    # We'll try a bounded number of attempts to create a valid configuration.
    for attempt in range(300):
        # Random size but keep it reasonable to ensure generation & simulation are fast.
        width = random.randint(10, 20)
        height = random.randint(10, 20)

        # Create empty grid
        inp = [[0 for _ in range(width)] for __ in range(height)]

        # Choose an inner margin and number of concentric rings.
        margin = random.randint(1, 3)
        max_levels = (min(width, height) - 2 * margin) // 2
        if max_levels < 1:
            continue
        levels = random.randint(1, min(max_levels, 4))

        rings = []  # list of (top,left,bottom,right,color)
        color_choices = [1, 2, 3, 4]

        # Draw concentric rectangular outlines (rings)
        for i in range(levels):
            top = margin + i * 2
            left = margin + i * 2
            bottom = height - 1 - (margin + i * 2)
            right = width - 1 - (margin + i * 2)
            # Ensure there's space for a hollow interior
            if bottom - top < 2 or right - left < 2:
                break
            color = random.choice(color_choices)
            rings.append((top, left, bottom, right, color))
            # draw border
            for c in range(left, right + 1):
                inp[top][c] = color
                inp[bottom][c] = color
            for r in range(top + 1, bottom):
                inp[r][left] = color
                inp[r][right] = color

        if len(rings) == 0:
            continue

        # Choose a side and a coordinate (aligned for all rings) to create gateways/gaps.
        side = random.choice(["right", "left", "top", "bottom"]) 
        inn_top, inn_left, inn_bottom, inn_right, _ = rings[-1]
        if side in ("left", "right"):
            gate_r = random.randint(inn_top + 1, inn_bottom - 1)
            gate_c = None
        else:
            gate_c = random.randint(inn_left + 1, inn_right - 1)
            gate_r = None

        # Remove the border cell at the chosen side for every ring (creating an aligned gate)
        for (top, left, bottom, right, color) in rings:
            if side == "right":
                inp[gate_r][right] = 0
            elif side == "left":
                inp[gate_r][left] = 0
            elif side == "top":
                inp[top][gate_c] = 0
            else:  # bottom
                inp[bottom][gate_c] = 0

        # Optionally add a few small internal hole outlines inside some hollows (away from the main gate)
        for idx in range(len(rings)):
            if random.random() < 0.6:
                continue
            top, left, bottom, right, parent_color = rings[idx]
            h = bottom - top - 1
            w = right - left - 1
            # we need at least a 5x5 area to safely place a 3x3 small hole
            if h < 4 or w < 4:
                continue
            # pick a small 3x3 outline location inside this hollow
            hole_r0 = random.randint(top + 1, bottom - 3 - 1)
            hole_c0 = random.randint(left + 1, right - 3 - 1)
            hole_color = random.choice([c for c in color_choices if c != parent_color])
            # draw 3x3 border
            for c in range(hole_c0, hole_c0 + 3):
                inp[hole_r0][c] = hole_color
                inp[hole_r0 + 2][c] = hole_color
            for r in range(hole_r0 + 1, hole_r0 + 2):
                inp[r][hole_c0] = hole_color
                inp[r][hole_c0 + 2] = hole_color

        # Place source (5) in the outermost hollow, near the opposite side of the gate if possible.
        out_top, out_left, out_bottom, out_right, _ = rings[0]
        # Choose row or column consistent with gate side so the agent will head toward the gate.
        if side == "right":
            s_r = random.randint(out_top + 1, out_bottom - 1)
            s_c = random.randint(out_left + 1, min(out_left + 2, out_right - 1))
        elif side == "left":
            s_r = random.randint(out_top + 1, out_bottom - 1)
            s_c = random.randint(max(out_right - 2, out_left + 1), out_right - 1)
        elif side == "top":
            s_c = random.randint(out_left + 1, out_right - 1)
            s_r = random.randint(max(out_bottom - 2, out_top + 1), out_bottom - 1)
        else:  # bottom
            s_c = random.randint(out_left + 1, out_right - 1)
            s_r = random.randint(out_top + 1, min(out_top + 2, out_bottom - 1))

        if inp[s_r][s_c] != 0:
            # find any free cell in outer hollow
            free = [(r, c) for r in range(out_top + 1, out_bottom) for c in range(out_left + 1, out_right) if inp[r][c] == 0]
            if not free:
                continue
            s_r, s_c = random.choice(free)
        inp[s_r][s_c] = 5

        # Place target (6) just inside the innermost gate so the agent must traverse the chain of gates.
        if side == "right":
            t_r = gate_r
            t_c = inn_right - 1
        elif side == "left":
            t_r = gate_r
            t_c = inn_left + 1
        elif side == "top":
            t_c = gate_c
            t_r = inn_top + 1
        else:  # bottom
            t_c = gate_c
            t_r = inn_bottom - 1

        if inp[t_r][t_c] != 0:
            # find any free cell in inner hollow
            free = [(r, c) for r in range(inn_top + 1, inn_bottom) for c in range(inn_left + 1, inn_right) if inp[r][c] == 0]
            if not free:
                continue
            t_r, t_c = random.choice(free)
        inp[t_r][t_c] = 6

        # Now simulate the deterministic left-turn agent (initially facing east).
        dr = [0, 1, 0, -1]
        dc = [1, 0, -1, 0]
        direction = 0  # 0=east,1=south,2=west,3=north
        r, c = s_r, s_c
        path = [(r, c)]
        max_steps = width * height * 20
        reached = False
        for _ in range(max_steps):
            if (r, c) == (t_r, t_c):
                reached = True
                break
            nr = r + dr[direction]
            nc = c + dc[direction]
            forward_allowed = False
            if 0 <= nr < height and 0 <= nc < width:
                cell = inp[nr][nc]
                # The agent may step onto background or the target (6) or revisit the source (5).
                if cell == 0 or cell == 6 or cell == 5:
                    forward_allowed = True
            if forward_allowed:
                r, c = nr, nc
                path.append((r, c))
            else:
                # turn left (counter-clockwise)
                direction = (direction + 3) % 4

        if not reached:
            # Try another random layout
            continue

        # Build output grid by painting visited background cells with color 7 (preserve markers and outlines)
        out = [row[:] for row in inp]
        for (pr, pc) in path:
            if (pr, pc) == (s_r, s_c) or (pr, pc) == (t_r, t_c):
                continue
            if out[pr][pc] == 0:
                out[pr][pc] = 7

        # Ensure input and output are different
        key = (tuple(tuple(row) for row in inp), tuple(tuple(row) for row in out))
        if key in _SEEN_PAIRS:
            continue
        _SEEN_PAIRS.add(key)
        return {"input": inp, "output": out}

    # If we exhausted attempts, raise an error (very unlikely)
    raise RuntimeError("Failed to generate a valid example after many attempts")



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to a mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    s_pos = None
    t_pos = None
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 5:
                s_pos = (r, c)
            elif grid[r][c] == 6:
                t_pos = (r, c)
    if s_pos is None or t_pos is None:
        # Nothing to do
        return tuple(tuple(row) for row in grid)

    # Deterministic left-turn agent starting east
    dr = [0, 1, 0, -1]
    dc = [1, 0, -1, 0]
    direction = 0
    r, c = s_pos
    path = [(r, c)]
    max_steps = width * height * 20
    reached = False

    for _ in range(max_steps):
        if (r, c) == t_pos:
            reached = True
            break
        nr = r + dr[direction]
        nc = c + dc[direction]
        forward_allowed = False
        if 0 <= nr < height and 0 <= nc < width:
            cell = grid[nr][nc]
            if cell == 0 or cell == 6 or cell == 5:
                forward_allowed = True
        if forward_allowed:
            r, c = nr, nc
            path.append((r, c))
        else:
            direction = (direction + 3) % 4

    # If the agent did not reach the target (shouldn't happen for generator outputs),
    # attempt a shortest-path fallback using BFS restricted to background and target.
    if not reached:
        from collections import deque
        sr, sc = s_pos
        tr, tc = t_pos
        q = deque()
        q.append((sr, sc))
        prev = { (sr, sc): None }
        while q:
            cr, cc = q.popleft()
            if (cr, cc) == (tr, tc):
                break
            for drd, dcd in ((0,1),(1,0),(0,-1),(-1,0)):
                nr, nc = cr + drd, cc + dcd
                if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in prev:
                    if grid[nr][nc] == 0 or grid[nr][nc] == 6 or grid[nr][nc] == 5:
                        prev[(nr, nc)] = (cr, cc)
                        q.append((nr, nc))
        if (tr, tc) in prev:
            # reconstruct path
            cur = (tr, tc)
            rev = []
            while cur is not None:
                rev.append(cur)
                cur = prev[cur]
            rev.reverse()
            path = rev
            reached = True

    # Paint path in color 7 but preserve source (5) and target (6) and outlines
    out = [row[:] for row in grid]
    if reached:
        for (pr, pc) in path:
            if (pr, pc) == s_pos or (pr, pc) == t_pos:
                continue
            if out[pr][pc] == 0:
                out[pr][pc] = 7

    return tuple(tuple(row) for row in out)

