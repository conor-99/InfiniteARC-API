# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 54e2a427
Difficulty: hard

=== Tags ===
- Truth table visualization
- Remove noise
- Detect enclosure

=== Description ===
Input grids consist of a large 2D grid (typically 10×10 or larger) containing a
2×2 truth table visualization embedded within a closed enclosure. The truth
table represents a logical function (e.g., XOR or AND) with each cell displaying
a distinct color corresponding to a specific input-output combination. The
enclosure is a continuous closed loop formed by a single color (e.g., blue),
surrounding the truth table but containing noise (random color cells) inside and
outside the loop. Noise cells are non-enclosure, non-truth-table elements that
disrupt the visual clarity of the structure.  The transformation requires three
sequential steps: First, detect the enclosure by identifying the largest
continuous closed loop of a single color that fully encloses the truth table
pattern. Second, remove all noise cells—any cell not part of the enclosure loop
or the truth table’s 2×2 color pattern—both inside and outside the enclosure.
Third, ensure the enclosure loop remains continuous without gaps (repairing
minor breaks caused by noise) while preserving the truth table’s color
arrangement exactly as it appears in the input. The output grid must display
only the fully repaired enclosure and the clean, unmodified truth table
visualization, with all noise eliminated. This task demands precise spatial
reasoning to distinguish the enclosure from noise, recognize the 2×2 truth table
pattern, and apply multi-step cleanup while maintaining visual integrity.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    # Grid size
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    grid = common.grid(width, height, 0)

    # Choose an enclosure color (non-zero)
    enclosure_color = random.randint(1, 9)

    # Choose a rectangular enclosure with room for a 2x2 truth table inside
    # Ensure at least a 1-cell margin around the enclosure and room for interior 2x2
    left = random.randint(2, width - 6)
    right = random.randint(left + 3, width - 3)
    top = random.randint(2, height - 6)
    bottom = random.randint(top + 3, height - 3)

    # Draw the rectangular enclosure (1-pixel thick loop)
    for c in range(left, right + 1):
        grid[top][c] = enclosure_color
        grid[bottom][c] = enclosure_color
    for r in range(top, bottom + 1):
        grid[r][left] = enclosure_color
        grid[r][right] = enclosure_color

    # Create a few small gaps in the enclosure to simulate noise-caused breaks
    edge_cells = []
    for c in range(left + 1, right):
        edge_cells.append((top, c))
        edge_cells.append((bottom, c))
    for r in range(top + 1, bottom):
        edge_cells.append((r, left))
        edge_cells.append((r, right))
    edge_cells = list(set(edge_cells))

    gap_count = random.randint(1, max(1, min(3, len(edge_cells) // 6 + 1)))
    gap_cells = random.sample(edge_cells, gap_count)
    for (gr, gc) in gap_cells:
        grid[gr][gc] = 0

    # Place a 2x2 truth table strictly inside the enclosure
    truth_r = random.randint(top + 1, bottom - 2)
    truth_c = random.randint(left + 1, right - 2)

    # Choose four distinct colors for the truth table, none equal to the enclosure color
    available = [c for c in range(1, 10) if c != enclosure_color]
    truth_colors = random.sample(available, 4)
    truth_table = [[truth_colors[0], truth_colors[1]], [truth_colors[2], truth_colors[3]]]

    for dr in range(2):
        for dc in range(2):
            grid[truth_r + dr][truth_c + dc] = truth_table[dr][dc]

    # Build a noise color pool that excludes enclosure and truth-table colors
    noise_colors = [c for c in range(1, 10) if c != enclosure_color and c not in truth_colors]
    if not noise_colors:
        # Fallback: ensure at least one noise color exists
        noise_colors = [c for c in range(1, 10) if c != enclosure_color]

    # Helper: avoid assigning the same color adjacent (4-neighbors) to prevent large connected noise components
    def neighbor_has_color(r, c, color):
        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == color:
                return True
        return False

    # Add random noise both inside and outside the enclosure, but avoid using truth-table colors
    interior_noise_prob = 0.45
    outside_noise_prob = 0.20
    interior_noise_count = 0
    outside_noise_count = 0

    truth_positions = {(truth_r + dr, truth_c + dc) for dr in (0, 1) for dc in (0, 1)}

    for r in range(height):
        for c in range(width):
            if (r, c) in truth_positions:
                continue
            if grid[r][c] == enclosure_color:
                continue
            inside = (top < r < bottom and left < c < right)
            prob = interior_noise_prob if inside else outside_noise_prob
            if random.random() < prob:
                # try to pick a noise color that doesn't match any 4-neighbor to avoid creating big clusters
                shuffled = noise_colors[:]
                random.shuffle(shuffled)
                assigned = False
                for col in shuffled:
                    if not neighbor_has_color(r, c, col):
                        grid[r][c] = col
                        assigned = True
                        if inside:
                            interior_noise_count += 1
                        else:
                            outside_noise_count += 1
                        break
                # If none fit, leave it as background (0)

    # Guarantee at least one noise pixel inside and one outside the enclosure
    if interior_noise_count == 0:
        interior_candidates = [
            (r, c)
            for r in range(top + 1, bottom)
            for c in range(left + 1, right)
            if (r, c) not in truth_positions and grid[r][c] != enclosure_color
        ]
        if interior_candidates:
            r, c = random.choice(interior_candidates)
            for col in noise_colors:
                if not neighbor_has_color(r, c, col):
                    grid[r][c] = col
                    interior_noise_count += 1
                    break

    if outside_noise_count == 0:
        outside_candidates = [
            (r, c)
            for r in range(height)
            for c in range(width)
            if not (top <= r <= bottom and left <= c <= right) and grid[r][c] == 0
        ]
        if outside_candidates:
            r, c = random.choice(outside_candidates)
            for col in noise_colors:
                if not neighbor_has_color(r, c, col):
                    grid[r][c] = col
                    outside_noise_count += 1
                    break

    # Build the expected output: only the repaired enclosure loop and the unmodified 2x2 truth table
    output = common.grid(width, height, 0)
    for c in range(left, right + 1):
        output[top][c] = enclosure_color
        output[bottom][c] = enclosure_color
    for r in range(top, bottom + 1):
        output[r][left] = enclosure_color
        output[r][right] = enclosure_color
    for dr in range(2):
        for dc in range(2):
            output[truth_r + dr][truth_c + dc] = grid[truth_r + dr][truth_c + dc]

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Find all 4-connected components for each color and pick the largest component overall
    def components_of_color(color):
        visited = [[False] * width for _ in range(height)]
        comps = []
        for r in range(height):
            for c in range(width):
                if not visited[r][c] and grid[r][c] == color:
                    stack = [(r, c)]
                    visited[r][c] = True
                    comp = []
                    while stack:
                        cr, cc = stack.pop()
                        comp.append((cr, cc))
                        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                                visited[nr][nc] = True
                                stack.append((nr, nc))
                    comps.append(comp)
        return comps

    max_size = 0
    enclosure_color = None
    enclosure_comp = None
    for color in range(1, 10):
        comps = components_of_color(color)
        if not comps:
            continue
        largest = max(comps, key=len)
        if len(largest) > max_size:
            max_size = len(largest)
            enclosure_color = color
            enclosure_comp = largest

    # If nothing found, return an all-zero grid
    if enclosure_comp is None:
        return tuple(tuple(0 for _ in range(width)) for _ in range(height))

    # Instead of using only the largest connected component, compute the bounding box of all cells of that color
    all_cells = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == enclosure_color]
    min_r = min(r for r, c in all_cells)
    max_r = max(r for r, c in all_cells)
    min_c = min(c for r, c in all_cells)
    max_c = max(c for r, c in all_cells)

    # Start building output: repaired enclosure (fill the rectangle edges) and a clean truth table
    output = [[0] * width for _ in range(height)]
    for c in range(min_c, max_c + 1):
        output[min_r][c] = enclosure_color
        output[max_r][c] = enclosure_color
    for r in range(min_r, max_r + 1):
        output[r][min_c] = enclosure_color
        output[r][max_c] = enclosure_color

    # Count occurrences of each color to help identify the unique 2x2 truth table colors
    counts = {}
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            counts[v] = counts.get(v, 0) + 1

    # Search for a 2x2 block strictly inside the enclosure whose four colors are unique in the entire grid
    found = False
    for r in range(min_r + 1, max_r - 1):
        for c in range(min_c + 1, max_c - 1):
            a = grid[r][c]
            b = grid[r][c + 1]
            d = grid[r + 1][c]
            e = grid[r + 1][c + 1]
            if 0 in (a, b, d, e):
                continue
            if enclosure_color in (a, b, d, e):
                continue
            # all four colors must be distinct
            if len({a, b, d, e}) != 4:
                continue
            # and each color should be unique across the whole grid (truth-table colors are placed only once)
            if counts.get(a, 0) == 1 and counts.get(b, 0) == 1 and counts.get(d, 0) == 1 and counts.get(e, 0) == 1:
                output[r][c] = a
                output[r][c + 1] = b
                output[r + 1][c] = d
                output[r + 1][c + 1] = e
                found = True
                break
        if found:
            break

    # Fallback: if not found inside bounding box, search whole grid for any 2x2 distinct block (unlikely with the generator)
    if not found:
        for r in range(height - 1):
            for c in range(width - 1):
                a = grid[r][c]
                b = grid[r][c + 1]
                d = grid[r + 1][c]
                e = grid[r + 1][c + 1]
                if 0 in (a, b, d, e):
                    continue
                if enclosure_color in (a, b, d, e):
                    continue
                if len({a, b, d, e}) == 4:
                    output[r][c] = a
                    output[r][c + 1] = b
                    output[r + 1][c] = d
                    output[r + 1][c + 1] = e
                    found = True
                    break
            if found:
                break

    return tuple(tuple(row) for row in output)

