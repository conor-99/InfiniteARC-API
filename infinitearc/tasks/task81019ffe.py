# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 81019ffe
Difficulty: insane

=== Tags ===
- Beam splitter
- Periodic tiling

=== Description ===
Input grids feature a single, straight-line beam moving in a cardinal direction
across a grid with a uniform background color. Scattered across the grid are
beam splittersâ€”distinct colored cells arranged in a precise periodic tiling
pattern (e.g., repeating every 3 columns horizontally and every 4 rows
vertically). The beam splitters are visually distinct from the background and do
not overlap with other grid elements. The beam travels orthogonally until it
encounters a splitter cell.  Upon hitting a splitter, the beam splits into two
new beams moving in directions perpendicular to the original beam's path. For
example, a right-moving beam splits into an upward and downward beam. Each new
beam continues traveling in its direction until it either exits the grid, hits
another splitter (triggering further splits), or collides with a grid boundary.
The original beam is removed, and all new beams are drawn in unique,
distinguishable colors to visually track their origin and path history.
Splitters remain visible in the output without alteration, and no beams
overwrite background cells or other splitters. The periodic tiling ensures the
beam encounters multiple splitters along its path, creating a cascading
splitting effect that results in multiple non-intersecting paths. The output
grid must accurately depict all resulting beam paths after all splits, with no
beams remaining inside the grid boundaries. The transformation requires
recognizing the periodic splitter pattern, predicting beam trajectories through
multiple splits, and rendering each path with appropriate visual
differentiation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque

_gen_counter = 0

def generate():
    global _gen_counter
    _gen_counter += 1
    attempts = 0
    max_attempts = 1000
    while attempts < max_attempts:
        attempts += 1
        # parameters
        width = random.randint(6, 15)
        height = random.randint(6, 15)
        # choose periods to ensure not too dense
        period_x = random.randint(3, 5)
        period_y = random.randint(3, 5)
        # offsets vary with counter to ensure uniqueness
        offset_x = _gen_counter % period_x
        offset_y = (_gen_counter // period_x) % period_y
        background = 0
        splitter = 1
        beam_in = 2
        # create input grid
        grid = [[background for _ in range(width)] for _ in range(height)]
        splitter_positions = []
        for r in range(height):
            for c in range(width):
                if ((c - offset_x) % period_x == 0) and ((r - offset_y) % period_y == 0):
                    grid[r][c] = splitter
                    splitter_positions.append((r, c))
        if not splitter_positions:
            continue

        # choose direction and starting line such that beam will hit a splitter
        directions = ['east', 'west', 'south', 'north']
        random.shuffle(directions)
        selected = None
        for direction in directions:
            if direction in ('east', 'west'):
                # choose a row that has a splitter not at border relevant to direction
                candidate_rows = []
                for r in range(height):
                    cols = [c for (rr, c) in splitter_positions if rr == r]
                    if not cols:
                        continue
                    if direction == 'east' and min(cols) > 0:
                        candidate_rows.append(r)
                    if direction == 'west' and max(cols) < width - 1:
                        candidate_rows.append(r)
                if candidate_rows:
                    row = candidate_rows[(_gen_counter + attempts) % len(candidate_rows)]
                    selected = (direction, row)
                    break
            else:
                # north/south: pick a column
                candidate_cols = []
                for c in range(width):
                    rows = [r for (r, cc) in splitter_positions if cc == c]
                    if not rows:
                        continue
                    if direction == 'south' and min(rows) > 0:
                        candidate_cols.append(c)
                    if direction == 'north' and max(rows) < height - 1:
                        candidate_cols.append(c)
                if candidate_cols:
                    col = candidate_cols[(_gen_counter + attempts) % len(candidate_cols)]
                    selected = (direction, col)
                    break
        if selected is None:
            continue

        direction, idx = selected

        # determine first splitter encountered and set input beam cells
        if direction == 'east':
            r = idx
            cols = sorted([c for (rr, c) in splitter_positions if rr == r])
            if not cols or cols[0] == 0:
                continue
            splitter_c = cols[0]
            # beam from col 0 to splitter_c - 1
            for c in range(0, splitter_c):
                grid[r][c] = beam_in
            first_split = (r, splitter_c)
        elif direction == 'west':
            r = idx
            cols = sorted([c for (rr, c) in splitter_positions if rr == r])
            if not cols or cols[-1] == width - 1:
                continue
            splitter_c = cols[-1]
            for c in range(splitter_c+1, width):
                grid[r][c] = beam_in
            first_split = (r, splitter_c)
        elif direction == 'south':
            c = idx
            rows = sorted([r for (r, cc) in splitter_positions if cc == c])
            if not rows or rows[0] == 0:
                continue
            splitter_r = rows[0]
            for r in range(0, splitter_r):
                grid[r][c] = beam_in
            first_split = (splitter_r, c)
        else: # north
            c = idx
            rows = sorted([r for (r, cc) in splitter_positions if cc == c])
            if not rows or rows[-1] == height - 1:
                continue
            splitter_r = rows[-1]
            for r in range(splitter_r+1, height):
                grid[r][c] = beam_in
            first_split = (splitter_r, c)

        # prepare output grid and simulate splits
        output = [[background for _ in range(width)] for _ in range(height)]
        for (sr, sc) in splitter_positions:
            output[sr][sc] = splitter

        avail_colors = list(range(3, 10))  # colors 3..9 for new beams
        from collections import deque
        q = deque()
        # helper deltas
        deltas = {'north': (-1, 0), 'south': (1, 0), 'east': (0, 1), 'west': (0, -1)}
        # spawn initial beams from first_split
        fr, fc = first_split
        if direction in ('east', 'west'):
            spawn_dirs = ['north', 'south']
        else:
            spawn_dirs = ['west', 'east']
        # create beams
        valid_spawn = False
        for d in spawn_dirs:
            dr, dc = deltas[d]
            sr, sc = fr + dr, fc + dc
            if 0 <= sr < height and 0 <= sc < width and grid[sr][sc] != splitter and output[sr][sc] == 0:
                if not avail_colors:
                    valid_spawn = False
                    break
                col = avail_colors.pop(0)
                output[sr][sc] = col
                q.append((sr, sc, d, col))
                valid_spawn = True
        if not valid_spawn:
            continue

        # BFS simulate beams
        collision = False
        while q and not collision:
            r, c, dirc, col = q.popleft()
            dr, dc = deltas[dirc]
            nr, nc = r + dr, c + dc
            if not (0 <= nr < height and 0 <= nc < width):
                continue
            if grid[nr][nc] == splitter:
                # split at (nr,nc)
                if dirc in ('north', 'south'):
                    new_dirs = ['east', 'west']
                else:
                    new_dirs = ['north', 'south']
                for nd in new_dirs:
                    ddr, ddc = deltas[nd]
                    sr2, sc2 = nr + ddr, nc + ddc
                    if 0 <= sr2 < height and 0 <= sc2 < width and grid[sr2][sc2] != splitter and output[sr2][sc2] == 0:
                        if not avail_colors:
                            collision = True
                            break
                        col2 = avail_colors.pop(0)
                        output[sr2][sc2] = col2
                        q.append((sr2, sc2, nd, col2))
                continue
            # otherwise advance beam
            if output[nr][nc] != 0:
                # would intersect another beam or splitter area -> invalid candidate
                collision = True
                break
            output[nr][nc] = col
            q.append((nr, nc, dirc, col))

        if collision:
            continue

        # ensure output is different from input
        if output == grid:
            continue

        return {'input': grid, 'output': output}

    # fallback deterministic simple example (should not happen)
    width, height = 7, 7
    grid = [[0]*width for _ in range(height)]
    for r in range(0, height, 3):
        for c in range(0, width, 3):
            grid[r][c] = 1
    for c in range(0, 3):
        grid[3][c] = 2
    output = [[0]*width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 1:
                output[r][c] = 1
    # spawn two beams result
    output[2][3] = 3
    output[4][3] = 4
    return {'input': grid, 'output': output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque
def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    # compute background color as mode
    counts = {}
    for r in range(height):
        for c in range(width):
            val = grid[r][c]
            counts[val] = counts.get(val, 0) + 1
    background = max(counts, key=counts.get)
    # collect positions by color
    positions_by_color = {}
    for r in range(height):
        for c in range(width):
            val = grid[r][c]
            if val == background: continue
            positions_by_color.setdefault(val, []).append((r,c))
    if not positions_by_color:
        return [list(row) for row in grid]
    # attempt to identify beam color as color whose pixels form a straight contiguous line
    beam_color = None
    for color, positions in positions_by_color.items():
        rows = [p[0] for p in positions]
        cols = [p[1] for p in positions]
        # all same row and consecutive cols
        if min(rows) == max(rows):
            rs = rows[0]
            sorted_cols = sorted(cols)
            if sorted_cols[-1] - sorted_cols[0] + 1 == len(sorted_cols):
                beam_color = color
                break
        # all same col and consecutive rows
        if min(cols) == max(cols):
            cs = cols[0]
            sorted_rows = sorted(rows)
            if sorted_rows[-1] - sorted_rows[0] + 1 == len(sorted_rows):
                beam_color = color
                break
    # fallback: adjacency detection
    if beam_color is None:
        for color, positions in positions_by_color.items():
            posset = set(positions)
            found_adj = False
            for (r,c) in positions:
                for dr,dc in ((0,1),(0,-1),(1,0),(-1,0)):
                    if (r+dr, c+dc) in posset:
                        found_adj = True
                        break
                if found_adj:
                    break
            if found_adj:
                beam_color = color
                break
    # if still none, pick the color with max length maybe
    if beam_color is None:
        beam_color = max(positions_by_color.keys(), key=lambda k: len(positions_by_color[k]))
    # splitter color is any other non-background color (assume single splitter color)
    splitter_color = None
    for color in positions_by_color.keys():
        if color != beam_color:
            splitter_color = color
            break
    if splitter_color is None:
        # nothing to split; return input with original beam removed
        return [[grid[r][c] if grid[r][c] != beam_color else background for c in range(width)] for r in range(height)]
    # find beam cells
    beam_positions = positions_by_color.get(beam_color, [])
    # determine orientation
    orientation = None
    if all(r == beam_positions[0][0] for r,c in beam_positions):
        orientation = 'horizontal'
    elif all(c == beam_positions[0][1] for r,c in beam_positions):
        orientation = 'vertical'
    # find endpoint adjacent to splitter using orientation
    deltas = {'north': (-1,0), 'south': (1,0), 'east': (0,1), 'west': (0,-1)}
    direction = None
    first_split = None
    if orientation == 'horizontal':
        r = beam_positions[0][0]
        cols = sorted([c for (rr,c) in beam_positions])
        left, right = cols[0], cols[-1]
        if right+1 < width and grid[r][right+1] == splitter_color:
            direction = 'east'
            first_split = (r, right+1)
        elif left-1 >= 0 and grid[r][left-1] == splitter_color:
            direction = 'west'
            first_split = (r, left-1)
    elif orientation == 'vertical':
        c = beam_positions[0][1]
        rows = sorted([r for (r,c2) in beam_positions])
        top, bottom = rows[0], rows[-1]
        if bottom+1 < height and grid[bottom+1][c] == splitter_color:
            direction = 'south'
            first_split = (bottom+1, c)
        elif top-1 >= 0 and grid[top-1][c] == splitter_color:
            direction = 'north'
            first_split = (top-1, c)
    # fallback check any adjacency
    if first_split is None:
        found = False
        for (r,c) in beam_positions:
            for dir_name,(dr,dc) in deltas.items():
                nr,nc = r+dr,c+dc
                if 0<=nr<height and 0<=nc<width and grid[nr][nc] == splitter_color:
                    direction = dir_name
                    first_split = (nr,nc)
                    found = True
                    break
            if found: break
    if first_split is None:
        return [[grid[r][c] if grid[r][c] != beam_color else background for c in range(width)] for r in range(height)]
    # prepare output
    output = [[background for _ in range(width)] for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if grid[r][c] == splitter_color:
                output[r][c] = splitter_color
    # simulate beams
    avail_colors = [c for c in range(3,10) if c != splitter_color and c != beam_color]
    q = deque()
    fr, fc = first_split
    if direction in ('east', 'west'):
        spawn_dirs = ['north', 'south']
    else:
        spawn_dirs = ['west', 'east']
    for d in spawn_dirs:
        dr, dc = deltas[d]
        sr, sc = fr + dr, fc + dc
        if 0 <= sr < height and 0 <= sc < width and grid[sr][sc] != splitter_color and output[sr][sc] == background:
            if not avail_colors:
                break
            col = avail_colors.pop(0)
            output[sr][sc] = col
            q.append((sr, sc, d, col))
    # BFS
    while q:
        r, c, dirc, col = q.popleft()
        dr, dc = deltas[dirc]
        nr, nc = r + dr, c + dc
        if not (0 <= nr < height and 0 <= nc < width):
            continue
        if grid[nr][nc] == splitter_color:
            if dirc in ('north', 'south'):
                new_dirs = ['east', 'west']
            else:
                new_dirs = ['north', 'south']
            for nd in new_dirs:
                ddr, ddc = deltas[nd]
                sr2, sc2 = nr + ddr, nc + ddc
                if 0 <= sr2 < height and 0 <= sc2 < width and grid[sr2][sc2] != splitter_color and output[sr2][sc2] == background:
                    if not avail_colors:
                        continue
                    col2 = avail_colors.pop(0)
                    output[sr2][sc2] = col2
                    q.append((sr2, sc2, nd, col2))
            continue
        if output[nr][nc] != background:
            continue
        output[nr][nc] = col
        q.append((nr, nc, dirc, col))
    return output

