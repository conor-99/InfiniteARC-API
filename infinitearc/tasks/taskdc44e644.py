# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: dc44e644
Difficulty: insane

=== Tags ===
- Maze
- Dynamic rule discovery
- Meta rule composition

=== Description ===
The input grids represent maze structures where 0 denotes a traversable path and
1 denotes a wall. The output grid transforms path cells (0) based on dynamic
spatial properties: for each path cell, the number of adjacent walls (1s) in the
four cardinal directions determines its replacement color (0 walls → color 2, 1
wall → color 3, 2 walls → color 4, 3 walls → color 5, 4 walls → color 6).
Additionally, wall cells (1) forming any 2×2 contiguous block are replaced with
color 7, while isolated walls remain as 1. The transformation requires meta-
composition of two distinct rules: (1) local neighbor-based path cell
replacement and (2) global block detection for wall cells. Solvers must discover
these interdependent rules through example analysis, as the color mappings and
block criteria are not explicitly stated, demanding dynamic abstraction over
spatial patterns and hierarchical rule application. This task exemplifies
"insane" difficulty through the necessity of simultaneously identifying multiple
layered spatial relationships without direct guidance.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    input_grid = [[random.choice([0, 1]) for _ in range(width)] for _ in range(height)]
    has_zero = any(0 in row for row in input_grid)
    has_one = any(1 in row for row in input_grid)
    if not (has_zero and has_one):
        return generate()
    output_grid = [[0] * width for _ in range(height)]
    in_2x2 = [[False] * width for _ in range(height)]
    for r in range(height - 1):
        for c in range(width - 1):
            if all(input_grid[r + dr][c + dc] == 1 for dr, dc in [(0,0), (0,1), (1,0), (1,1)]):
                for dr, dc in [(0,0), (0,1), (1,0), (1,1)]:
                    in_2x2[r + dr][c + dc] = True
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                count = sum(1 for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)] if 0 <= r+dr < height and 0 <= c+dc < width and input_grid[r+dr][c+dc] == 1)
                output_grid[r][c] = 2 + count
            else:
                output_grid[r][c] = 7 if in_2x2[r][c] else 1
    if input_grid == output_grid:
        return generate()
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input):
    width = len(input[0])
    height = len(input)
    output = [[0] * width for _ in range(height)]
    in_2x2 = [[False] * width for _ in range(height)]
    for r in range(height - 1):
        for c in range(width - 1):
            if all(input[r + dr][c + dc] == 1 for dr, dc in [(0,0), (0,1), (1,0), (1,1)]):
                for dr, dc in [(0,0), (0,1), (1,0), (1,1)]:
                    in_2x2[r + dr][c + dc] = True
    for r in range(height):
        for c in range(width):
            if input[r][c] == 0:
                count = sum(1 for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)] if 0 <= r+dr < height and 0 <= c+dc < width and input[r+dr][c+dc] == 1)
                output[r][c] = 2 + count
            else:
                output[r][c] = 7 if in_2x2[r][c] else 1
    return output
