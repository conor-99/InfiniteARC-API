# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 67858581
Difficulty: medium–hard

=== Tags ===
- Recursive agent following
- Reflect across detected axis
- Count ver lines

=== Description ===
Input grids contain a background color (0), multiple vertical line segments
(each a contiguous vertical sequence of a single non-background color, e.g.,
color 1 spanning rows 2–5 in a column), and a single agent marker (a distinct
color, e.g., color 2, positioned at the top of one vertical line segment). The
number of vertical line segments (N) is counted by identifying all columns
containing at least one contiguous vertical sequence of a non-background color
(ignoring background cells). The reflection axis is determined as the vertical
position corresponding to the (N-1)//2-th segment from the left (0-based
indexing). The grid is reflected across this axis such that all elements
(including vertical segments, background, and the agent marker) are mirrored
relative to the axis. Vertical segments may span partial columns but are treated
as discrete segments; their count remains N after reflection. The output grid is
the reflected version with all elements mirrored across the detected axis,
preserving all colors and structures while adjusting positions relative to the
axis.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

SEEN = set()

def generate():
    """Generate an input/output pair where the output is the horizontal reflection
    of the input across the axis corresponding to the (N-1)//2-th vertical segment
    (0-based). To keep the reflection inside the grid we choose an odd width and
    make the detected axis equal to the central column of the grid.
    """
    attempts = 0
    while attempts < 1000:
        attempts += 1
        # Choose an odd width so that central column serves as a valid in-bounds axis
        W = random.choice([3,5,7,9,11,13,15,17,19,21,23,25])
        H = random.randint(3, 18)

        # Choose number of vertical segments N (at least 2 and at most W)
        N = random.randint(2, W)

        # Choose an agent color first to ensure segment colors exclude it
        agent_color = random.randint(1, 9)
        avail_colors = [c for c in range(1, 10) if c != agent_color]

        # Choose segment colors (with replacement) from avail_colors
        segment_colors = [random.choice(avail_colors) for _ in range(N)]

        # Center column (axis) — ensure the (N-1)//2-th segment will be placed here
        center = (W - 1) // 2
        mid = (N - 1) // 2
        left_count = mid
        right_count = N - mid - 1

        # Available columns left and right of center
        left_cols = list(range(0, center))
        right_cols = list(range(center + 1, W))
        if left_count > len(left_cols) or right_count > len(right_cols):
            # cannot place N segments around center for this W; try again
            continue

        left_sample = random.sample(left_cols, left_count) if left_count > 0 else []
        right_sample = random.sample(right_cols, right_count) if right_count > 0 else []

        columns = sorted(left_sample + [center] + right_sample)
        if len(columns) != N:
            continue

        # Build input grid and create contiguous vertical segment in each chosen column
        input_grid = [[0 for _ in range(W)] for _ in range(H)]
        start_rows = []
        for idx, col in enumerate(columns):
            start = random.randint(0, H - 1)
            end = random.randint(start, H - 1)
            start_rows.append(start)
            color = segment_colors[idx]
            for r in range(start, end + 1):
                input_grid[r][col] = color

        # Place the agent marker at the top of one of the segments
        seg_idx = random.randrange(N)
        agent_col = columns[seg_idx]
        agent_row = start_rows[seg_idx]
        # Ensure agent color differs from the segment color (we picked colors accordingly)
        input_grid[agent_row][agent_col] = agent_color

        # Reflect the entire grid across central column `center` (safe for odd W)
        output_grid = [row[::-1] for row in input_grid]

        # Avoid producing identical in/out and duplicates across calls
        if input_grid == output_grid:
            continue

        key = (tuple(tuple(row) for row in input_grid), tuple(tuple(row) for row in output_grid))
        if key in SEEN:
            continue
        SEEN.add(key)

        return {"input": input_grid, "output": output_grid}

    raise RuntimeError("Failed to generate a valid unique example after many attempts")



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0]) if H > 0 else 0

    # Identify columns that contain any non-zero cell (columns with a vertical segment)
    cols = []
    for c in range(W):
        for r in range(H):
            if grid[r][c] != 0:
                cols.append(c)
                break

    if not cols:
        return tuple(tuple(row) for row in grid)

    mid = (len(cols) - 1) // 2
    axis = cols[mid]

    # Reflect across the detected axis: map column c -> 2*axis - c
    out = [[0] * W for _ in range(H)]
    for r in range(H):
        for c in range(W):
            newc = 2 * axis - c
            # newc must be in bounds; if not, fallback to horizontal flip around center
            if 0 <= newc < W:
                out[r][newc] = grid[r][c]
            else:
                # This case should not occur for generator outputs, but handle robustly
                # by performing a global horizontal flip instead
                out[r][W - 1 - c] = grid[r][c]

    return tuple(tuple(row) for row in out)

