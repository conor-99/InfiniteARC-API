# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: b396f3c7
Difficulty: hard

=== Tags ===
- Color by distance to edge
- Alternating agents
- Reflective maze
- Constraint satisfaction coloring
- Two color checkerboard

=== Description ===
The input grids depict a reflective maze structure where traversable paths
reflect off grid edges and internal walls, creating symmetrical route networks.
The maze contains two distinct agent types (colored 1 and 2) positioned at path
intersections, with their movement constrained by the reflective geometry. The
output grid must transform the input into a two-color checkerboard pattern where
each cell's color alternates based on the parity of its minimum distance to the
nearest grid edge (top, bottom, left, right). Crucially, the reflective maze
imposes global symmetry constraints: for any cell, its reflection across the
maze's primary axis (determined by the reflective path structure) must have the
opposite color. This requires the checkerboard pattern to maintain consistent
alternation across all reflected segments, even around complex maze
configurations. The agents' positions must align with the checkerboard pattern
(agent color matching the cell's color), and the transformation must resolve all
edge cases where distance parity conflicts with reflection symmetry by enforcing
the symmetry constraint as the primary rule. The task demands simultaneous
computation of edge distances, checkerboard alternation, and reflection symmetry
validation, making it challenging due to the interplay between geometric
distance, parity-based coloring, and structural symmetry constraints.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    H = random.randint(3, 30)
    W = random.randint(4, 30)
    if W % 2 != 0:
        W += 1
    input_grid = grid(W, H, 3)
    
    # Place agent 1 at position with (r + c) even
    r1, c1 = 0, 0
    while (r1 + c1) % 2 != 0:
        r1 = random.randint(0, H-1)
        c1 = random.randint(0, W-1)
    input_grid[r1][c1] = 1
    
    # Place agent 2 at position with (r + c) odd
    r2, c2 = 0, 0
    while (r2 + c2) % 2 != 1:
        r2 = random.randint(0, H-1)
        c2 = random.randint(0, W-1)
    input_grid[r2][c2] = 2
    
    output_grid = grid(W, H, 0)
    for r in range(H):
        for c in range(W):
            output_grid[r][c] = 1 if (r + c) % 2 == 0 else 2
    
    return {
        'input': input_grid,
        'output': output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    H = len(input_grid)
    W = len(input_grid[0])
    output = [[0] * W for _ in range(H)]
    for r in range(H):
        for c in range(W):
            output[r][c] = 1 if (r + c) % 2 == 0 else 2
    return output
