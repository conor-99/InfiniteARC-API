# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: fcd1c57a
Difficulty: medium

=== Tags ===
- Follow color path to destination

=== Description ===
The input grid contains a connected path of a single color (e.g., red) that
leads to a destination cell of a different color (e.g., blue). The destination
cell is adjacent to the endpoint of the path and is visually distinct. The
output grid transforms the path by replacing all cells in the path with the
destination color, creating a continuous path of the destination color that
leads directly to the destination cell. The transformation requires identifying
the connected path (via edge-adjacent cells of identical color) and recognizing
the destination cell as the endpoint's adjacent cell with a different color.
This task tests visual pattern recognition of path connectivity and color-based
transformation without relying on numerical properties or pixel-level analysis.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    from common import random_color
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = [[0] * width for _ in range(height)]
    C = random_color(exclude=[0])
    D = random_color(exclude=[0, C])
    path_length = random.randint(3, 10)
    max_start = width - path_length - 1
    if max_start < 0:
        path_length = width - 1
        start_col = 0
    else:
        start_col = random.randint(0, max_start)
    for col in range(start_col, start_col + path_length):
        grid[0][col] = C
    dest_col = start_col + path_length
    if dest_col < width:
        grid[0][dest_col] = D
    else:
        grid[0][width - 1] = D
    output = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if output[r][c] == C:
                output[r][c] = D
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    visited = [[False] * width for _ in range(height)]
    path_component = []
    path_color = None
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                stack = [(r, c)]
                visited[r][c] = True
                color = input_grid[r][c]
                component = []
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                if len(component) > 1:
                    path_component = component
                    path_color = color
                    break
    if path_color is None:
        return input_grid
    dest_color = None
    for (r, c) in path_component:
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width:
                neighbor_color = input_grid[nr][nc]
                if neighbor_color != 0 and neighbor_color != path_color:
                    dest_color = neighbor_color
                    break
        if dest_color is not None:
            break
    if dest_color is None:
        dest_color = path_color
    output = [list(row) for row in input_grid]
    for r in range(height):
        for c in range(width):
            if output[r][c] == path_color:
                output[r][c] = dest_color
    return output
