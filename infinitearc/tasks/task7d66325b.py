# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 7d66325b
Difficulty: hard

=== Tags ===
- Draw pattern from point
- Pattern rotation
- Direction guesingcrop
- Create image from info

=== Description ===
The task involves transforming an input grid into an output grid by drawing a
pattern starting from a unique "point" cell, with the direction of the pattern
determined by the nearest cell of a different color. The input grid contains a
single cell (the "point") with a unique color value (appearing exactly once),
surrounded by other cells with varying colors. The direction to draw the pattern
is inferred by calculating the Manhattan distance from the point to the nearest
cell with a different color. The output grid extends a line of three cells
starting from the point, moving in the direction of the nearest different-color
cell. For diagonal directions (e.g., northeast), the line follows the diagonal
path. The pattern is always drawn in the direction of the nearest non-matching
cell, regardless of the grid's orientation, requiring the solver to compute
direction vectors and handle edge cases where the pattern must remain within
grid bounds. This combines abstract reasoning about spatial relationships
(direction guessing), pattern construction (draw from point), and dynamic
orientation (pattern rotation), making it a hard task that demands precise
spatial analysis without relying on fixed color mappings.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    import common
    w = random.randint(5, 30)
    h = random.randint(5, 30)
    grid = common.grid(w, h, 0)
    point_color = random.randint(1, 9)
    r = random.randint(2, h-3)
    c = random.randint(2, w-3)
    grid[r][c] = point_color
    for i in range(h):
        for j in range(w):
            if i == r and j == c:
                continue
            color = random.choice([0] + [x for x in range(1, 10) if x != point_color])
            grid[i][j] = color
    output = [row[:] for row in grid]
    for i in range(3):
        col = c + i
        if col < w:
            output[r][col] = point_color
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    from collections import defaultdict
    color_count = defaultdict(int)
    for row in input_grid:
        for color in row:
            color_count[color] += 1
    point_color = None
    for color, count in color_count.items():
        if count == 1:
            point_color = color
            break
    if point_color is None:
        return input_grid
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] == point_color:
                point_r, point_c = r, c
                break
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    chosen_direction = (0, 1)
    for dr, dc in directions:
        nr, nc = point_r + dr, point_c + dc
        if 0 <= nr < len(input_grid) and 0 <= nc < len(input_grid[0]):
            if input_grid[nr][nc] != point_color:
                chosen_direction = (dr, dc)
                break
    output = [list(row) for row in input_grid]
    dr, dc = chosen_direction
    for i in range(3):
        r, c = point_r + dr * i, point_c + dc * i
        if 0 <= r < len(input_grid) and 0 <= c < len(input_grid[0]):
            output[r][c] = point_color
    return output
