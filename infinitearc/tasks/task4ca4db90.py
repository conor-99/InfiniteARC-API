# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 4ca4db90
Difficulty: medium–hard

=== Tags ===
- Maze wave
- Trail memory
- Context sensitive recolor
- Chain reaction

=== Description ===
Input grids feature a maze-like structure composed of walls (colors 1–8)
surrounding a single continuous path of background cells (color 0), with no
loops or dead-ends except at the exit. The path begins at a source cell (color
9) positioned on the left edge, winding through the maze with directional turns
(left, right, up, down) while maintaining a clear, unambiguous route to the
right or bottom edge. Walls are contiguous and enclose the path, ensuring the
path remains accessible without branching.  In the output grid, the path is
transformed via a "wave" that propagates from the source. Each cell along the
path is recolored based on a context-sensitive chain reaction: the new color
depends on both the color of the prior cell in the path and the direction of
travel between those cells. For example, moving east might shift the color
toward a higher value while moving south shifts it toward a lower value, but the
exact relationship must be deduced from the input-output examples. This creates
a visible trail where the sequence of colors encodes the path's directional
changes, forming a memory of the wave's progression. Walls remain unchanged, and
the wave exits the maze at the designated edge without overlapping or altering
non-path elements. The task requires identifying the directional color mapping
through multiple examples, making it medium-hard due to the need to track both
path geometry and color progression simultaneously.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    input_grid = grid(width, height, 0)
    
    r_source = random.randint(1, height-2)
    input_grid[r_source][0] = 9
    
    path = []
    r, c = r_source, 1
    path.append((r, c))
    for _ in range(random.randint(2, 5)):
        c += 1
        if c >= width - 1:
            break
        path.append((r, c))
    while r < height - 2:
        r += 1
        path.append((r, c))
        if r >= height - 1:
            break
    
    for r in range(height):
        for c in range(width):
            if (r, c) not in path and (r, c) != (r_source, 0):
                input_grid[r][c] = random.randint(1, 8)
    
    output_grid = [row[:] for row in input_grid]
    prev_r, prev_c = r_source, 0
    current_color = 9
    for (r, c) in path:
        dr = r - prev_r
        dc = c - prev_c
        if dr == 0 and dc == 1:
            delta = 1
        elif dr == 0 and dc == -1:
            delta = -1
        elif dr == 1 and dc == 0:
            delta = 2
        elif dr == -1 and dc == 0:
            delta = -2
        else:
            delta = 0
        current_color = (current_color + delta) % 10
        output_grid[r][c] = current_color
        prev_r, prev_c = r, c
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque
def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    source_pos = None
    for r in range(height):
        if grid[r][0] == 9:
            source_pos = (r, 0)
            break
    if source_pos is None:
        for r in range(height):
            if grid[r][0] == 9:
                source_pos = (r, 0)
                break
    if source_pos is None:
        return input_grid
    
    start = (source_pos[0], 1)
    if grid[start[0]][start[1]] != 0:
        return input_grid
    
    visited = set()
    queue = deque([start])
    visited.add(start)
    path = []
    while queue:
        r, c = queue.popleft()
        path.append((r, c))
        for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in visited and grid[nr][nc] == 0:
                visited.add((nr, nc))
                queue.append((nr, nc))
    
    output_grid = [row[:] for row in grid]
    prev_r, prev_c = source_pos
    current_color = 9
    for (r, c) in path:
        dr = r - prev_r
        dc = c - prev_c
        if dr == 0 and dc == 1:
            delta = 1
        elif dr == 0 and dc == -1:
            delta = -1
        elif dr == 1 and dc == 0:
            delta = 2
        elif dr == -1 and dc == 0:
            delta = -2
        else:
            delta = 0
        current_color = (current_color + delta) % 10
        output_grid[r][c] = current_color
        prev_r, prev_c = r, c
    
    return tuple(tuple(row) for row in output_grid)
