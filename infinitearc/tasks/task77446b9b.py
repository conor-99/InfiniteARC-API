# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 77446b9b
Difficulty: insane

=== Tags ===
- Rule transfer between regions
- Rule based tiling
- Detect symmetry

=== Description ===
Symmetry Rule Propagation  Input grids are 30×30 with a background color (0).
The top-left 5×5 subgrid (the "rule block") contains a pattern of colors 1–9
that is strictly horizontally, vertically, or rotationally symmetric (180°). The
rule block's symmetry type (horizontal, vertical, or rotational) is the
transformation rule to apply. All other regions in the grid (contiguous color
areas not part of the rule block) must be transformed to match the rule block's
symmetry. For horizontal symmetry: each region's left and right halves mirror
(e.g., cell (r,c) becomes (r, w-1-c) within the region's bounding box). For
vertical symmetry: top and bottom halves mirror (cell (r,c) becomes (h-1-r, c)).
For rotational 180°: each cell (r,c) maps to the diagonally opposite position
within the region's bounding box. The transformation is applied per region: if a
region is already symmetric under the rule, it remains unchanged; otherwise, it
is mirrored to match the rule. All regions retain their original colors, and
transformations do not overlap other regions (existing colors override
transformed positions). The output grid contains the same rule block unchanged,
with all other regions transformed according to the rule block's symmetry. The
rule block will always exhibit exactly one of the three symmetry types,
requiring precise visual detection of the pattern's mirroring behavior.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid


def check_symmetries(block):
    # Returns tuple (h, v, r) booleans for horizontal(left-right), vertical(top-bottom), rotational(180)
    h = all(block[i][j] == block[i][4-j] for i in range(5) for j in range(3))
    v = all(block[i][j] == block[4-i][j] for j in range(5) for i in range(3))
    r = all(block[i][j] == block[4-i][4-j] for i in range(3) for j in range(3))
    return h, v, r


def generate_rule_block(symmetry_type):
    # symmetry_type: 0 horizontal (left-right), 1 vertical (top-bottom), 2 rotational 180
    # We will try a few times until we get a block that has exactly the requested symmetry and not any other.
    for _ in range(1000):
        block = [[0]*5 for _ in range(5)]
        if symmetry_type == 0:  # horizontal (left-right mirror)
            for r in range(5):
                for c in range(3):
                    color = random.randint(1, 9)
                    block[r][c] = color
                    block[r][4-c] = color
        elif symmetry_type == 1:  # vertical (top-bottom mirror)
            for c in range(5):
                for r in range(3):
                    color = random.randint(1, 9)
                    block[r][c] = color
                    block[4-r][c] = color
        else:  # rotational 180
            for r in range(3):
                for c in range(3):
                    color = random.randint(1, 9)
                    block[r][c] = color
                    block[4-r][4-c] = color
        h, v, r = check_symmetries(block)
        # Ensure exactly one symmetry holds and it's the requested one
        if symmetry_type == 0 and h and not v and not r:
            return block
        if symmetry_type == 1 and v and not h and not r:
            return block
        if symmetry_type == 2 and r and not h and not v:
            return block
    # Fallback (shouldn't happen often): return a simple forced block
    if symmetry_type == 0:
        block = [[(i+1) for _ in range(5)] for i in range(5)]
        for r in range(5):
            for c in range(3):
                block[r][4-c] = block[r][c]
        return block
    if symmetry_type == 1:
        block = [[(j+1) for j in range(5)] for _ in range(5)]
        for c in range(5):
            for r in range(3):
                block[4-r][c] = block[r][c]
        return block
    block = [[1]*5 for _ in range(5)]
    for r in range(3):
        for c in range(3):
            block[4-r][4-c] = block[r][c]
    return block


def generate_connected_shape_in_box(h, w, size):
    # generate a contiguous shape inside a local h x w box (coordinates relative to box top-left)
    # using a simple randomized expansion algorithm
    if size <= 0:
        return set()
    cells = set()
    sr = random.randint(0, h-1)
    sc = random.randint(0, w-1)
    cells.add((sr, sc))
    tries = 0
    while len(cells) < size and tries < size * 10:
        tries += 1
        neighbors = set()
        for (r, c) in list(cells):
            for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < h and 0 <= nc < w and (nr, nc) not in cells:
                    neighbors.add((nr, nc))
        if not neighbors:
            break
        cells.add(random.choice(list(neighbors)))
    return cells


def is_region_symmetric(region_pixels, symmetry_type):
    if not region_pixels:
        return True
    min_r = min(r for r,c in region_pixels)
    max_r = max(r for r,c in region_pixels)
    min_c = min(c for r,c in region_pixels)
    max_c = max(c for r,c in region_pixels)
    s = set(region_pixels)
    for (r,c) in region_pixels:
        if symmetry_type == 0:  # horizontal (left-right within bbox)
            c_m = min_c + max_c - c
            if (r, c_m) not in s:
                return False
        elif symmetry_type == 1:  # vertical (top-bottom within bbox)
            r_m = min_r + max_r - r
            if (r_m, c) not in s:
                return False
        else:  # rotational 180
            r_m = min_r + max_r - r
            c_m = min_c + max_c - c
            if (r_m, c_m) not in s:
                return False
    return True


def find_regions_from_grid(grid_in):
    # returns list of regions where each region is list of (r,c) pixels and color
    H = len(grid_in)
    W = len(grid_in[0])
    visited = [[False]*W for _ in range(H)]
    # mark rule block (top-left 5x5) as visited so it's not considered a region
    for r in range(min(5,H)):
        for c in range(min(5,W)):
            visited[r][c] = True
    regions = []
    for r in range(H):
        for c in range(W):
            if visited[r][c] or grid_in[r][c] == 0:
                continue
            color = grid_in[r][c]
            queue = [(r,c)]
            visited[r][c] = True
            comp = []
            while queue:
                cr, cc = queue.pop(0)
                comp.append((cr, cc))
                for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc] and grid_in[nr][nc] == color:
                        visited[nr][nc] = True
                        queue.append((nr,nc))
            regions.append((comp, color))
    return regions


def generate():
    # Try to generate an instance that follows the rules and ensures input != output
    for attempt in range(50):
        symmetry_type = random.randint(0,2)
        rule_block = generate_rule_block(symmetry_type)
        H = 30
        W = 30
        inp = grid(W, H, 0)
        # place rule block
        for r in range(5):
            for c in range(5):
                inp[r][c] = rule_block[r][c]

        # Place several non-overlapping connected regions (single-color blobs)
        placed = 0
        target_regions = random.randint(6, 12)
        max_attempts = 2000
        attempts2 = 0
        while placed < target_regions and attempts2 < max_attempts:
            attempts2 += 1
            box_h = random.randint(2, 8)
            box_w = random.randint(2, 8)
            size = random.randint(4, min(20, box_h * box_w))
            r0 = random.randint(0, H - box_h)
            c0 = random.randint(0, W - box_w)
            # avoid intersecting the top-left rule block
            if r0 <= 4 and c0 <= 4:
                continue
            # ensure bounding box is empty
            conflict = False
            for rr in range(r0, r0 + box_h):
                for cc in range(c0, c0 + box_w):
                    if inp[rr][cc] != 0:
                        conflict = True
                        break
                if conflict:
                    break
            if conflict:
                continue
            # generate a connected shape inside box
            shape = generate_connected_shape_in_box(box_h, box_w, size)
            if len(shape) < 3:
                continue
            # convert to global coords
            global_shape = [(r0 + rr, c0 + cc) for (rr, cc) in shape]
            # ensure the shape doesn't touch rule block (it shouldn't because bounding box avoided it)
            # ensure shape doesn't overlap any nonzero (we already checked bounding box empty)
            # ensure shape is not symmetric under the chosen rule (we want to force transformations)
            if is_region_symmetric(global_shape, symmetry_type):
                continue
            # choose a color
            color = random.randint(1, 9)
            # paint shape
            for (rr, cc) in global_shape:
                inp[rr][cc] = color
            placed += 1

        # Now derive regions via the same algorithm the solver will use
        regions = find_regions_from_grid(inp)
        # Prepare output by applying symmetry per region, but only writing into originally empty cells
        orig = [row[:] for row in inp]
        out = [row[:] for row in inp]
        changed = False
        for comp, color in regions:
            if is_region_symmetric(comp, symmetry_type):
                continue
            min_r = min(r for r,c in comp)
            max_r = max(r for r,c in comp)
            min_c = min(c for r,c in comp)
            max_c = max(c for r,c in comp)
            s = set(comp)
            for (r,c) in comp:
                if symmetry_type == 0:
                    cm = min_c + max_c - c
                    rm = r
                elif symmetry_type == 1:
                    rm = min_r + max_r - r
                    cm = c
                else:
                    rm = min_r + max_r - r
                    cm = min_c + max_c - c
                # Only write transformed color into cells that were background in the original input
                if 0 <= rm < H and 0 <= cm < W and orig[rm][cm] == 0:
                    out[rm][cm] = color
                    changed = True
        if not changed:
            # try again to ensure output != input
            continue
        return {'input': inp, 'output': out}
    # As a fallback, return a trivial modified grid (should not normally be reached)
    inp = grid(30, 30, 0)
    block = generate_rule_block(0)
    for r in range(5):
        for c in range(5):
            inp[r][c] = block[r][c]
    inp[10][10] = 1
    out = [row[:] for row in inp]
    out[10][19] = 1
    return {'input': inp, 'output': out}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def determine_symmetry(block):
    # block is 5x5 list of lists
    # Return 0 horizontal (left-right), 1 vertical (top-bottom), 2 rotational 180
    if all(block[i][j] == block[i][4-j] for i in range(5) for j in range(3)):
        # ensure it's not also another symmetry; we'll prefer the first that matches (generator guarantees uniqueness)
        return 0
    if all(block[i][j] == block[4-i][j] for j in range(5) for i in range(3)):
        return 1
    if all(block[i][j] == block[4-i][4-j] for i in range(3) for j in range(3)):
        return 2
    # Fallback
    return 0


def is_region_symmetric(region_pixels, symmetry_type):
    if not region_pixels:
        return True
    min_r = min(r for r,c in region_pixels)
    max_r = max(r for r,c in region_pixels)
    min_c = min(c for r,c in region_pixels)
    max_c = max(c for r,c in region_pixels)
    s = set(region_pixels)
    for (r,c) in region_pixels:
        if symmetry_type == 0:
            c_m = min_c + max_c - c
            if (r, c_m) not in s:
                return False
        elif symmetry_type == 1:
            r_m = min_r + max_r - r
            if (r_m, c) not in s:
                return False
        else:
            r_m = min_r + max_r - r
            c_m = min_c + max_c - c
            if (r_m, c_m) not in s:
                return False
    return True


def p(input_grid):
    H = len(input_grid)
    W = len(input_grid[0])
    inp = [list(row) for row in input_grid]
    # extract rule block
    block = [row[:5] for row in inp[:5]]
    symmetry_type = determine_symmetry(block)
    # make copies
    orig = [row[:] for row in inp]
    out = [row[:] for row in inp]
    # visited map
    visited = [[False]*W for _ in range(H)]
    for r in range(min(5,H)):
        for c in range(min(5,W)):
            visited[r][c] = True
    # find regions in scanning order (top-left to bottom-right)
    for r in range(H):
        for c in range(W):
            if visited[r][c] or inp[r][c] == 0:
                continue
            color = inp[r][c]
            # BFS
            queue = deque()
            queue.append((r,c))
            visited[r][c] = True
            comp = []
            while queue:
                cr, cc = queue.popleft()
                comp.append((cr, cc))
                for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc] and inp[nr][nc] == color:
                        visited[nr][nc] = True
                        queue.append((nr, nc))
            # apply transformation for this region if not symmetric
            if is_region_symmetric(comp, symmetry_type):
                continue
            min_r = min(rr for rr,cc in comp)
            max_r = max(rr for rr,cc in comp)
            min_c = min(cc for rr,cc in comp)
            max_c = max(cc for rr,cc in comp)
            for (rr, cc) in comp:
                if symmetry_type == 0:
                    rm, cm = rr, min_c + max_c - cc
                elif symmetry_type == 1:
                    rm, cm = min_r + max_r - rr, cc
                else:
                    rm, cm = min_r + max_r - rr, min_c + max_c - cc
                if 0 <= rm < H and 0 <= cm < W and orig[rm][cm] == 0:
                    out[rm][cm] = color
    return tuple(tuple(row) for row in out)
