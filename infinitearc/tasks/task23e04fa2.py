# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 23e04fa2
Difficulty: very hard

=== Tags ===
- Reflective maze
- Mapping by size relation
- Friction path
- Recolor object based on neighbor count
- Draw parallel line

=== Description ===
The input grid consists of a complex maze-like structure on a background (color
0) containing multiple colored objects (1-9), reflective tiles (color 1), and a
defined starting point. The maze includes walls, open paths, and reflective
tiles that alter the direction of a moving path. The path begins at the top-left
corner moving rightward. Upon encountering a reflective tile (color 1), the path
direction changes by 90 degrees (e.g., right → up, up → left, left → down, down
→ right). The path continues until it exits the grid, navigating around
obstacles and reflecting at tiles without overlapping or crossing itself.  Each
cell along the path is recolored based on the count of adjacent non-background
cells (orthogonally adjacent, including the path itself). Specifically: 1
neighbor → color 2, 2 neighbors → color 3, 3 neighbors → color 4, 4 neighbors →
color 5. This recoloring occurs before any new elements are added.  For every
contiguous colored object (a connected group of non-background cells) in the
input, the output grid draws a set of parallel lines in the background. The
number of lines drawn equals the object's width (horizontal span), and each line
has a thickness equal to the object's height (vertical span). The lines are
oriented parallel to the direction of the path segment that last intersected the
object's bounding box. The color of all lines matches the object's original
color. Lines are drawn only on background cells (color 0) and do not overwrite
existing objects, reflective tiles, or the recolored path.  The output grid
retains all original objects, reflective tiles, and the recolored path, while
adding the parallel lines as described. The transformation requires simultaneous
tracking of path dynamics, neighbor-based recoloring, and size-dependent line
drawing across multiple objects.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import continuous_creature

def generate():
    # Grid size
    width = random.randint(15, 25)
    height = random.randint(15, 25)
    grid_in = [[0 for _ in range(width)] for _ in range(height)]

    # Place several colored objects (colors 2-9). Prefer lower half so a snake path can run
    num_objects = random.randint(3, 6)
    colors = random.sample(list(range(2, 10)), num_objects)
    for color in colors:
        placed = False
        for attempt in range(60):
            bbw = random.randint(2, min(6, width))
            bbh = random.randint(2, min(6, height))
            max_size = bbw * bbh
            size = random.randint(3, min(max_size, 8))
            pixels = continuous_creature(size, width=bbw, height=bbh)
            # prefer placing in the lower half to leave top area free for the path
            min_shift_r = max(0, height // 2)
            max_shift_r = height - bbh
            if min_shift_r > max_shift_r:
                min_shift_r = 0
                max_shift_r = height - bbh
            shift_r = random.randint(min_shift_r, max_shift_r)
            shift_c = random.randint(0, width - bbw)
            conflict = False
            for pr, pc in pixels:
                rr = shift_r + pr
                cc = shift_c + pc
                if grid_in[rr][cc] != 0:
                    conflict = True
                    break
            if conflict:
                continue
            # place object
            for pr, pc in pixels:
                rr = shift_r + pr
                cc = shift_c + pc
                grid_in[rr][cc] = color
            placed = True
            break
        if not placed:
            # fallback: place a single pixel somewhere in lower area
            placed_flag = False
            for _ in range(200):
                rr = random.randint(height // 2, height - 1)
                cc = random.randint(0, width - 1)
                if grid_in[rr][cc] == 0:
                    grid_in[rr][cc] = color
                    placed_flag = True
                    break
            if not placed_flag:
                # worst-case place anywhere free
                for rr in range(height):
                    for cc in range(width):
                        if grid_in[rr][cc] == 0:
                            grid_in[rr][cc] = color
                            placed_flag = True
                            break
                    if placed_flag:
                        break

    # Build a deterministic snake-like planned path that stays in the upper area
    top_rows = random.randint(4, max(4, height // 2))
    planned = []
    for r in range(top_rows):
        if r % 2 == 0:
            cols = range(0, width)
        else:
            cols = range(width - 1, -1, -1)
        for c in cols:
            planned.append((r, c))
        if r != top_rows - 1:
            last_c = width - 1 if r % 2 == 0 else 0
            planned.append((r + 1, last_c))

    # Truncate planned path where it would intersect existing objects (we don't step onto objects)
    final_path = []
    visited = set()
    for (r, c) in planned:
        if grid_in[r][c] >= 2:
            break
        if (r, c) in visited:
            break
        final_path.append((r, c))
        visited.add((r, c))

    # Place reflective tiles (color 1) at planned turning positions (where direction changes)
    for i in range(1, len(final_path) - 1):
        r0, c0 = final_path[i - 1]
        r1, c1 = final_path[i]
        r2, c2 = final_path[i + 1]
        d1 = (r1 - r0, c1 - c0)
        d2 = (r2 - r1, c2 - c1)
        if d1 != d2:
            # only place reflect if the cell is background (do not overwrite objects)
            if grid_in[r1][c1] == 0:
                grid_in[r1][c1] = 1

    # Add a few extra reflective tiles off the path (do not place on objects or on the final path)
    extra = random.randint(2, 7)
    tries = 0
    while extra > 0 and tries < 500:
        tries += 1
        rr = random.randint(0, height - 1)
        cc = random.randint(0, width - 1)
        if grid_in[rr][cc] == 0 and (rr, cc) not in visited:
            grid_in[rr][cc] = 1
            extra -= 1

    # Simulate the actual path starting at top-left moving right. Reflection rotates clockwise: right->down->left->up
    sim_path = []
    r, c = 0, 0
    direction = (0, 1)
    seen = set()
    while 0 <= r < height and 0 <= c < width:
        if (r, c) in seen:
            break
        seen.add((r, c))
        sim_path.append((r, c))
        nr, nc = r + direction[0], c + direction[1]
        if not (0 <= nr < height and 0 <= nc < width):
            break
        # cannot step onto colored objects (>=2)
        if grid_in[nr][nc] >= 2:
            break
        # if next cell is a reflective tile, it will change direction for the subsequent step
        if grid_in[nr][nc] == 1:
            dr, dc = direction
            # rotate clockwise
            direction = (dc, -dr)
        r, c = nr, nc

    # Build output as a copy of the input
    output = [row[:] for row in grid_in]

    path_set = set(sim_path)
    initial_non_bg = set((rr, cc) for rr in range(height) for cc in range(width) if grid_in[rr][cc] != 0)

    # Recolor path cells based on count of orthogonal adjacent non-background cells (including adjacent path cells)
    for (pr, pc) in sim_path:
        count = 0
        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
            nr, nc = pr + dr, pc + dc
            if 0 <= nr < height and 0 <= nc < width:
                if (nr, nc) in initial_non_bg or (nr, nc) in path_set:
                    count += 1
        color = min(5, 2 + count)
        output[pr][pc] = color

    # Draw parallel lines for every contiguous colored object present in the input
    for color in range(2, 10):
        cells = [(rr, cc) for rr in range(height) for cc in range(width) if grid_in[rr][cc] == color]
        if not cells:
            continue
        min_r = min(rr for rr, cc in cells)
        max_r = max(rr for rr, cc in cells)
        min_c = min(cc for rr, cc in cells)
        max_c = max(cc for rr, cc in cells)
        width_obj = max_c - min_c + 1
        height_obj = max_r - min_r + 1

        # Find the last path cell that lies inside the object's bounding box (if any)
        last_direction = None
        for i in range(len(sim_path) - 1, -1, -1):
            rr, cc = sim_path[i]
            if min_r <= rr <= max_r and min_c <= cc <= max_c:
                if i == 0:
                    last_direction = (0, 1)
                else:
                    last_direction = (sim_path[i][0] - sim_path[i - 1][0], sim_path[i][1] - sim_path[i - 1][1])
                break
        # If the path never intersected the bounding box, default to horizontal orientation
        if last_direction is None:
            last_direction = (0, 1)

        # Draw lines: number = width_obj, thickness = height_obj
        if last_direction[0] == 0:
            # horizontal stripes, start from top and stack downward
            for line_num in range(width_obj):
                start_row = line_num * height_obj
                for dr in range(height_obj):
                    rr = start_row + dr
                    if rr >= height:
                        break
                    for cc in range(width):
                        if output[rr][cc] == 0:
                            output[rr][cc] = color
        else:
            # vertical stripes, start from left and stack rightward
            for line_num in range(width_obj):
                start_col = line_num * height_obj
                for dc in range(height_obj):
                    cc = start_col + dc
                    if cc >= width:
                        break
                    for rr in range(height):
                        if output[rr][cc] == 0:
                            output[rr][cc] = color

    return {'input': grid_in, 'output': output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
from typing import List, Tuple

def p(input_grid: Tuple[Tuple[int, ...], ...]) -> List[List[int]]:
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])

    # Simulate the path starting at top-left moving right. Reflection rotates clockwise: right->down->left->up
    sim_path = []
    r, c = 0, 0
    direction = (0, 1)
    seen = set()
    while 0 <= r < height and 0 <= c < width:
        if (r, c) in seen:
            break
        seen.add((r, c))
        sim_path.append((r, c))
        nr, nc = r + direction[0], c + direction[1]
        if not (0 <= nr < height and 0 <= nc < width):
            break
        # cannot step onto colored objects (>=2)
        if grid_in[nr][nc] >= 2:
            break
        # if next cell is a reflective tile (1), it will change direction for the subsequent step
        if grid_in[nr][nc] == 1:
            dr, dc = direction
            direction = (dc, -dr)
        r, c = nr, nc

    # Prepare output starting as a copy of input
    output = [row[:] for row in grid_in]

    path_set = set(sim_path)
    initial_non_bg = set((rr, cc) for rr in range(height) for cc in range(width) if grid_in[rr][cc] != 0)

    # Recolor path cells based on adjacent non-background cells (count includes adjacent path cells)
    for (pr, pc) in sim_path:
        count = 0
        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
            nr, nc = pr + dr, pc + dc
            if 0 <= nr < height and 0 <= nc < width:
                if (nr, nc) in initial_non_bg or (nr, nc) in path_set:
                    count += 1
        color = min(5, 2 + count)
        output[pr][pc] = color

    # Draw parallel lines for each contiguous colored object (2-9)
    for color in range(2, 10):
        cells = [(rr, cc) for rr in range(height) for cc in range(width) if grid_in[rr][cc] == color]
        if not cells:
            continue
        min_r = min(rr for rr, cc in cells)
        max_r = max(rr for rr, cc in cells)
        min_c = min(cc for rr, cc in cells)
        max_c = max(cc for rr, cc in cells)
        width_obj = max_c - min_c + 1
        height_obj = max_r - min_r + 1

        # Find last path cell inside bounding box (if any)
        last_direction = None
        for i in range(len(sim_path) - 1, -1, -1):
            rr, cc = sim_path[i]
            if min_r <= rr <= max_r and min_c <= cc <= max_c:
                if i == 0:
                    last_direction = (0, 1)
                else:
                    last_direction = (sim_path[i][0] - sim_path[i - 1][0], sim_path[i][1] - sim_path[i - 1][1])
                break
        if last_direction is None:
            last_direction = (0, 1)

        if last_direction[0] == 0:
            # horizontal stripes
            for line_num in range(width_obj):
                start_row = line_num * height_obj
                for dr in range(height_obj):
                    rr = start_row + dr
                    if rr >= height:
                        break
                    for cc in range(width):
                        if output[rr][cc] == 0:
                            output[rr][cc] = color
        else:
            # vertical stripes
            for line_num in range(width_obj):
                start_col = line_num * height_obj
                for dc in range(height_obj):
                    cc = start_col + dc
                    if cc >= width:
                        break
                    for rr in range(height):
                        if output[rr][cc] == 0:
                            output[rr][cc] = color

    return output

