# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: a25572b3
Difficulty: hard

=== Tags ===
- Color carving
- Color clock
- Emergent behavior
- Draw path through ordered checkpoints

=== Description ===
Input grids feature a uniform background color (0) overlaid with a sequence of
checkpoints marked by consecutive colors (1, 2, 3, ...), each occupying distinct
positions. The checkpoints must be connected in numerical order. Between
consecutive checkpoints, a path is drawn using a cyclic "color clock" (e.g.,
colors 4 → 5 → 6 → 4 → ...), where the segment color for checkpoint n to n+1 is
determined by (n mod 3) + 4. The path must navigate the shortest possible route
through background cells (0), avoiding all non-background elements (including
other checkpoints and obstacles), resulting in a unique path shape that emerges
from the grid's obstacle layout. The output grid preserves all input elements
(checkpoints, obstacles) while replacing the background along the path with the
current segment's clock color. This creates a visually distinct path that
sequentially changes color, with each segment's color determined by its position
in the sequence, requiring the solver to simultaneously track checkpoint order,
obstacle navigation, and cyclic color application.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

from collections import deque
import random

def generate():
    # Try up to some attempts to build a valid grid
    for _ in range(200):
        w = random.randint(10, 20)
        h = random.randint(10, 20)
        grid = [[0 for _ in range(w)] for _ in range(h)]
        # number of checkpoints
        k = random.randint(3, 5)
        checkpoints = []
        # place checkpoints ensuring they are not adjacent (Manhattan distance >=2)
        placed = True
        for color in range(1, k+1):
            ok = False
            for _ in range(200):
                r = random.randint(0, h-1)
                c = random.randint(0, w-1)
                if grid[r][c] != 0:
                    continue
                # avoid adjacency with any existing checkpoint
                too_close = False
                for (pr,pc) in checkpoints:
                    if abs(pr - r) + abs(pc - c) < 2:
                        too_close = True
                        break
                if too_close:
                    continue
                grid[r][c] = color
                checkpoints.append((r,c))
                ok = True
                break
            if not ok:
                placed = False
                break
        if not placed:
            continue

        # place obstacles randomly, then check connectivity; if blocked, retry
        obstacle_colors = [7,8,9]
        max_obstacles = max(5, (w * h) // 12)
        min_obstacles = max(3, (w * h) // 30)
        n_obstacles = random.randint(min_obstacles, max_obstacles)
        # ensure we don't place too many obstacles; clear obstacles start fresh
        for _ in range(n_obstacles):
            for _ in range(40):
                r = random.randint(0, h-1)
                c = random.randint(0, w-1)
                if grid[r][c] == 0:
                    grid[r][c] = random.choice(obstacle_colors)
                    break

        def find_shortest_path(g, start, end):
            H = len(g); W = len(g[0])
            visited = [[False]*W for _ in range(H)]
            parent = {}
            q = deque()
            visited[start[0]][start[1]] = True
            q.append(start)
            while q:
                r,c = q.popleft()
                if (r,c) == end:
                    # reconstruct path
                    path = []
                    cur = (r,c)
                    while cur != start:
                        path.append(cur)
                        cur = parent[cur]
                    path.append(start)
                    path.reverse()
                    return path
                for dr,dc in ((1,0),(-1,0),(0,1),(0,-1)):
                    nr, nc = r+dr, c+dc
                    if nr < 0 or nr >= H or nc < 0 or nc >= W:
                        continue
                    if visited[nr][nc]:
                        continue
                    # can move into a cell if it's background (0) or it is the end
                    if (nr, nc) == end or g[nr][nc] == 0:
                        visited[nr][nc] = True
                        parent[(nr, nc)] = (r,c)
                        q.append((nr,nc))
            return None

        # verify there is a valid path between each consecutive checkpoint
        ok_all = True
        for idx in range(len(checkpoints) - 1):
            s = checkpoints[idx]
            e = checkpoints[idx+1]
            # ensure not adjacent (so at least one background cell will be colored)
            if abs(s[0]-e[0]) + abs(s[1]-e[1]) < 2:
                ok_all = False
                break
            path = find_shortest_path(grid, s, e)
            if path is None:
                ok_all = False
                break
            # ensure path contains at least one background cell (excluding endpoints)
            has_bg = any(grid[r][c] == 0 for (r,c) in path if (r,c) != s and (r,c) != e)
            if not has_bg:
                ok_all = False
                break
        if not ok_all:
            continue

        # build output by coloring background cells along each shortest path
        output = [row[:] for row in grid]
        for idx in range(len(checkpoints) - 1):
            n = idx + 1  # checkpoint color number
            s = checkpoints[idx]
            e = checkpoints[idx+1]
            path = find_shortest_path(grid, s, e)
            color = (n % 3) + 4
            for (r,c) in path:
                if grid[r][c] == 0:
                    output[r][c] = color

        return { "input": grid, "output": output }

    # fallback: unlikely, but produce a minimal valid example
    grid = [[0]*10 for _ in range(10)]
    grid[1][1] = 1
    grid[1][4] = 2
    grid[1][7] = 3
    output = [row[:] for row in grid]
    output[1][2] = 5
    output[1][3] = 5
    return { "input": grid, "output": output }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    grid = [list(row) for row in input_grid]
    H = len(grid); W = len(grid[0])

    # detect checkpoints: consecutive colors starting at 1
    present = set()
    for r in range(H):
        for c in range(W):
            v = grid[r][c]
            if v > 0:
                present.add(v)
    k = 0
    i = 1
    while i in present:
        k += 1
        i += 1
    checkpoints = []
    for color in range(1, k+1):
        found = False
        for r in range(H):
            for c in range(W):
                if grid[r][c] == color:
                    checkpoints.append((r,c))
                    found = True
                    break
            if found:
                break

    def find_shortest_path(g, start, end):
        H = len(g); W = len(g[0])
        visited = [[False]*W for _ in range(H)]
        parent = {}
        q = deque()
        visited[start[0]][start[1]] = True
        q.append(start)
        while q:
            r,c = q.popleft()
            if (r,c) == end:
                path = []
                cur = (r,c)
                while cur != start:
                    path.append(cur)
                    cur = parent[cur]
                path.append(start)
                path.reverse()
                return path
            for dr,dc in ((1,0),(-1,0),(0,1),(0,-1)):
                nr, nc = r+dr, c+dc
                if nr < 0 or nr >= H or nc < 0 or nc >= W:
                    continue
                if visited[nr][nc]:
                    continue
                # allow movement through background cells and into the end cell
                if (nr, nc) == end or g[nr][nc] == 0:
                    visited[nr][nc] = True
                    parent[(nr,nc)] = (r,c)
                    q.append((nr,nc))
        return None

    output = [row[:] for row in grid]
    for idx in range(len(checkpoints) - 1):
        n = idx + 1
        s = checkpoints[idx]
        e = checkpoints[idx+1]
        path = find_shortest_path(grid, s, e)
        if path is None:
            continue
        color = (n % 3) + 4
        for (r,c) in path:
            if grid[r][c] == 0:
                output[r][c] = color

    return tuple(tuple(row) for row in output)
