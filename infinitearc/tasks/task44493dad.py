# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 44493dad
Difficulty: very hard

=== Tags ===
- Rule propagation
- Dependency topological sort
- Draw path through ordered checkpoints
- Separate image
- Color matching

=== Description ===
Topological Checkpoint Path  Input grids feature a single background color (0)
with multiple isolated checkpoints, each represented by a single cell containing
a unique color from 1 to 9. These checkpoints are positioned such that no two
are adjacent to prevent overlap. Each checkpoint is accompanied by a dependency
indicator cell immediately adjacent (up, down, left, or right) containing a
color value that corresponds to the color of another checkpoint. This indicator
establishes a directed dependency: the checkpoint with the indicator color must
be visited before the current checkpoint in the path sequence. The dependency
graph formed by these indicators is guaranteed to be a directed acyclic graph
(DAG), ensuring a valid topological order exists.  Output grids transform the
input by adding a continuous path that sequentially connects all checkpoints in
topological order. The dependency relationships are resolved to determine the
precise sequence: for any dependency indicator pointing to color X, the
checkpoint with color X must precede the current checkpoint. The path is drawn
exclusively over background cells (0), using the color of the starting
checkpoint for each segment between consecutive checkpoints. Path segments
between two checkpoints must follow the shortest Manhattan path (moving
horizontally or vertically only) without passing through any non-background
cells (other checkpoints, dependency indicators, or previously drawn path
segments). Each segment starts at the center of the source checkpoint and
proceeds toward the center of the destination checkpoint, with the path color
matching the source checkpoint's color. The dependency indicators remain visible
in the output but are not part of the path. The output grid retains all input
elements (checkpoints, dependency indicators, background) while adding the path
as the only new visual element.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    import common
    width = random.randint(15, 30)
    height = random.randint(15, 30)
    grid = common.grid(width, height, 0)
    N = random.randint(3, 8)
    r = random.randint(0, height - 2)
    while 2*(N-1) >= width:
        N = random.randint(3, 8)
    for i in range(N):
        grid[r][2*i] = i + 1
    for i in range(1, N):
        grid[r+1][2*i] = i
    output = [row[:] for row in grid]
    for i in range(N - 1):
        output[r][2*i + 1] = i + 1
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    checkpoints = []
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            if grid[r][c] > 0:
                checkpoints.append((r, c, grid[r][c]))
    checkpoints.sort(key=lambda x: x[2])
    for i in range(len(checkpoints) - 1):
        r1, c1, color1 = checkpoints[i]
        r2, c2, _ = checkpoints[i+1]
        for c in range(min(c1, c2), max(c1, c2) + 1):
            if grid[r1][c] == 0:
                grid[r1][c] = color1
        for r in range(min(r1, r2), max(r1, r2) + 1):
            if grid[r][c2] == 0:
                grid[r][c2] = color1
    return tuple(map(tuple, grid))
