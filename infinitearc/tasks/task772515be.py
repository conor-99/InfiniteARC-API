# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 772515be
Difficulty: very hard

=== Tags ===
- Relational projection
- Direction guesingcrop
- Contouring

=== Description ===
The input grid features a complex arrangement of multiple non-overlapping,
contiguous regions, each defined by a distinct color on a uniform background.
Regions vary in shape, size, and orientation, with no two regions touching or
overlapping. Each region's "direction" must be inferred through relational
analysis: the direction is determined by the vector from the region's centroid
to the centroid of its nearest neighboring region. If multiple regions are
equidistant, the direction defaults to the horizontal axis (east or west) over
vertical (north or south). The output grid requires generating a contour—defined
as a single-pixel-wide border around each region—where the edge of the contour
facing the inferred direction is highlighted with a specific, consistent accent
color (e.g., color 9). Crucially, the direction must be deduced solely from
spatial relationships (e.g., "the nearest region lies to the east"), not from
explicit markers, color values, or numerical properties. This necessitates
multi-step reasoning: identifying connected components, calculating centroids,
resolving proximity ties, and applying directional logic to contour rendering.
The task avoids reliance on color-based rules, instead demanding visual pattern
recognition of spatial relationships and precise contour adaptation, making it
exceptionally challenging due to the combinatorial complexity of relational
projections across diverse region configurations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import math
from common import continuous_creature, grid, random_colors


def generate():
    """
    Generates a grid containing several non-touching contiguous colored regions on a
    black background. For each region we compute the centroid and find the nearest
    neighbor's centroid. We then draw an external single-pixel contour (on the
    background cells directly adjacent to the region) and highlight the edge of
    that contour that faces the inferred direction with color 9. The base contour
    color is 8. Region colors are chosen from 1..7 (excluding 8 and 9).
    """
    # Try until we can place all regions; restart if placement fails.
    attempts = 0
    while True:
        attempts += 1
        grid_size = random.randint(15, 25)
        pad = 2  # keep a margin so contours fit inside the grid
        if grid_size - 2 * pad < 3:
            continue

        input_grid = grid(grid_size, grid_size, 0)
        max_inner = grid_size - 2 * pad
        # choose number of regions and colors (avoid 8 and 9)
        num_regions = random.randint(3, 5)
        colors = random_colors(num_regions, exclude=[8, 9])

        placed = []  # list of tuples (color, list_of_pixels)
        failed = False

        for color in colors:
            placed_ok = False

            # Try to construct and place a contiguous sprite for this color.
            for place_try in range(200):
                # pick a reasonable sprite size relative to the inner area
                max_area = max_inner * max_inner
                size = random.randint(4, min(24, max(4, max_area // 6)))
                size = min(size, max_area)

                # choose local width then force height so w*h >= size
                w_limit = min(8, max_inner)
                if w_limit < 3:
                    continue
                w = random.randint(3, w_limit)
                h = (size + w - 1) // w
                if h > max_inner:
                    # try a couple different widths to satisfy h <= max_inner
                    success_wh = False
                    for _ in range(8):
                        w = random.randint(3, w_limit)
                        h = (size + w - 1) // w
                        if h <= max_inner:
                            success_wh = True
                            break
                    if not success_wh:
                        continue

                # generate contiguous creature
                try:
                    sprite = continuous_creature(size, w, h)
                except Exception:
                    continue

                # normalize sprite to top-left origin
                minr = min(r for r, c in sprite)
                minc = min(c for r, c in sprite)
                norm = [(r - minr, c - minc) for r, c in sprite]
                sp_h = max(r for r, c in norm) + 1
                sp_w = max(c for r, c in norm) + 1

                if grid_size - pad - sp_h < pad or grid_size - pad - sp_w < pad:
                    continue

                r0 = random.randint(pad, grid_size - pad - sp_h)
                c0 = random.randint(pad, grid_size - pad - sp_w)

                # Enforce spacing: require no existing cell inside a Chebyshev radius of 2
                conflict = False
                for sr, sc in norm:
                    rr = r0 + sr
                    cc = c0 + sc
                    for dr_check in range(-2, 3):
                        for dc_check in range(-2, 3):
                            nr = rr + dr_check
                            nc = cc + dc_check
                            if 0 <= nr < grid_size and 0 <= nc < grid_size:
                                if input_grid[nr][nc] != 0:
                                    conflict = True
                                    break
                        if conflict:
                            break
                    if conflict:
                        break

                if conflict:
                    continue

                # place sprite
                placed_pixels = []
                for sr, sc in norm:
                    rr = r0 + sr
                    cc = c0 + sc
                    input_grid[rr][cc] = color
                    placed_pixels.append((rr, cc))

                placed.append((color, placed_pixels))
                placed_ok = True
                break

            if not placed_ok:
                failed = True
                break

        if failed:
            if attempts > 40:
                # give up after many attempts (should be rare)
                raise RuntimeError("Could not place regions after many attempts")
            continue

        # Build the output grid by drawing contours in the background.
        output_grid = [row[:] for row in input_grid]

        for color, pixels in placed:
            # centroid of this region
            centroid_r = sum(r for r, c in pixels) / len(pixels)
            centroid_c = sum(c for r, c in pixels) / len(pixels)

            # find nearest neighbor centroids (Euclidean). Allow ties.
            min_d2 = None
            nearest = []
            for other_color, other_pixels in placed:
                if other_color == color:
                    continue
                oc_r = sum(r for r, c in other_pixels) / len(other_pixels)
                oc_c = sum(c for r, c in other_pixels) / len(other_pixels)
                d2 = (centroid_r - oc_r) ** 2 + (centroid_c - oc_c) ** 2
                if min_d2 is None or d2 < min_d2 - 1e-9:
                    min_d2 = d2
                    nearest = [(oc_r, oc_c)]
                elif abs(d2 - min_d2) < 1e-9:
                    nearest.append((oc_r, oc_c))

            if not nearest:
                # isolated region (shouldn't happen with num_regions>1) -- skip
                continue

            # Tie-break among equidistant neighbors: prefer the neighbor with largest
            # horizontal offset (absolute dc). If multiple, prefer the positive dc (east).
            best = None
            best_key = None
            for oc_r, oc_c in nearest:
                dc = oc_c - centroid_c
                dr = oc_r - centroid_r
                # key: prefer larger abs(dc), prefer east (dc>0), then larger abs(dr), then
                # stable fallbacks using oc_r/oc_c. This is deterministic and matches the
                # solver logic.
                key = (abs(dc), 1 if dc > 0 else 0, -abs(dr), -oc_r, -oc_c)
                if best is None or key > best_key:
                    best = (oc_r, oc_c)
                    best_key = key

            oc_r, oc_c = best
            dr = oc_r - centroid_r
            dc = oc_c - centroid_c

            if abs(dc) >= abs(dr):
                direction = 'east' if dc > 0 else 'west'
            else:
                direction = 'south' if dr > 0 else 'north'

            # compute external contour cells (background cells adjacent to region)
            contour = set()
            facing = set()
            for r, c in pixels:
                for dd_r, dd_c, name in ((0, 1, 'east'), (0, -1, 'west'), (1, 0, 'south'), (-1, 0, 'north')):
                    nr = r + dd_r
                    nc = c + dd_c
                    if 0 <= nr < grid_size and 0 <= nc < grid_size and input_grid[nr][nc] == 0:
                        contour.add((nr, nc))
                        if name == direction:
                            facing.add((nr, nc))

            # draw base contour color and then the accent color on facing cells
            for (nr, nc) in contour:
                output_grid[nr][nc] = 8
            for (nr, nc) in facing:
                output_grid[nr][nc] = 9

        return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0]) if h else 0

    # Find connected components for all region colors (exclude 0, 8, 9)
    visited = [[False] * w for _ in range(h)]
    components = []  # list of (color, pixels)

    for r in range(h):
        for c in range(w):
            val = grid[r][c]
            if val == 0 or val == 8 or val == 9:
                continue
            if visited[r][c]:
                continue
            color = val
            # BFS/DFS to gather this component (4-connected)
            stack = [(r, c)]
            visited[r][c] = True
            pixels = []
            while stack:
                rr, cc = stack.pop()
                pixels.append((rr, cc))
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            components.append((color, pixels))

    # Build output starting from the input
    output = [row[:] for row in grid]

    # For each region compute centroid and nearest neighbor (with tie-break rules)
    for color, pixels in components:
        centroid_r = sum(r for r, c in pixels) / len(pixels)
        centroid_c = sum(c for r, c in pixels) / len(pixels)

        # compute nearest neighbor(s) by squared distance
        min_d2 = None
        nearest = []
        for other_color, other_pixels in components:
            if other_color == color:
                continue
            oc_r = sum(r for r, c in other_pixels) / len(other_pixels)
            oc_c = sum(c for r, c in other_pixels) / len(other_pixels)
            d2 = (centroid_r - oc_r) ** 2 + (centroid_c - oc_c) ** 2
            if min_d2 is None or d2 < min_d2 - 1e-9:
                min_d2 = d2
                nearest = [(oc_r, oc_c)]
            elif abs(d2 - min_d2) < 1e-9:
                nearest.append((oc_r, oc_c))

        if not nearest:
            continue

        # Tie-break among nearest: prefer neighbor with largest abs(dc) (horizontal axis), and
        # if tied prefer east (positive dc). Use the same deterministic key as the generator.
        best = None
        best_key = None
        for oc_r, oc_c in nearest:
            dc = oc_c - centroid_c
            dr = oc_r - centroid_r
            key = (abs(dc), 1 if dc > 0 else 0, -abs(dr), -oc_r, -oc_c)
            if best is None or key > best_key:
                best = (oc_r, oc_c)
                best_key = key

        oc_r, oc_c = best
        dr = oc_r - centroid_r
        dc = oc_c - centroid_c
        if abs(dc) >= abs(dr):
            direction = 'east' if dc > 0 else 'west'
        else:
            direction = 'south' if dr > 0 else 'north'

        # collect external contour cells (background cells adjacent to region pixels)
        contour = set()
        facing = set()
        for r, c in pixels:
            for dd_r, dd_c, name in ((0, 1, 'east'), (0, -1, 'west'), (1, 0, 'south'), (-1, 0, 'north')):
                nr = r + dd_r
                nc = c + dd_c
                if 0 <= nr < h and 0 <= nc < w and grid[nr][nc] == 0:
                    contour.add((nr, nc))
                    if name == direction:
                        facing.add((nr, nc))

        for (nr, nc) in contour:
            output[nr][nc] = 8
        for (nr, nc) in facing:
            output[nr][nc] = 9

    return tuple(tuple(row) for row in output)

