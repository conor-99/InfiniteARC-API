# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: af4917ee
Difficulty: insane

=== Tags ===
- Line decay
- Temporal wave step
- Gravity with barriers
- Teleporter network routing
- Only one
- Expand repeating unit

=== Description ===
Input grids feature a single particle (represented by a distinct color),
barriers (a solid wall color), teleporter entrances (a unique color), and
teleporter exits (another unique color), all set against a uniform background.
The barriers form an obstacle course that forces the particle to follow a
specific path, while teleporter pairs create non-physical connections between
distant grid locations. The particle moves downward under gravity until blocked
by a barrier or entering a teleporter entrance, which instantly transports it to
the corresponding exit.   The output grid displays the particle's final position
and a decaying path tracing its movement. Each cell along the path progressively
fades toward the background color with each movement step, creating a visible
temporal wave effect. The path must follow a repeating directional pattern
(down-right-down-right) that expands incrementally with each cycle—initially
moving one cell down then one cell right, followed by two cells down then two
cells right, and so on—resulting in a visually expanding spiral. This expansion
is strictly determined by the barrier layout and teleporter placement, ensuring
exactly one valid path exists ("Only one").   The teleporters enable the path to
"jump" to new sections of the grid, allowing the expanding spiral to continue
beyond physical barrier constraints. The decaying path visually demonstrates the
temporal progression, with the earliest cells in the path showing the particle's
original color, intermediate cells displaying intermediate hues, and the latest
cells approaching the background color. The output grid must precisely reflect
this sequence of decay, expansion, and teleportation routing to satisfy all
constraints.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Grid size (square) chosen randomly so many unique grids are possible
    size = random.randint(8, 16)

    # Choose maximum K (number of expansion cycles) so the purely-adjacent spiral fits
    # We require the triangular sum S = K*(K+1)/2 to be <= size-1 so the spiral stays inside
    maxK = 1
    while (maxK * (maxK + 1) // 2) <= (size - 1):
        maxK += 1
    maxK -= 1
    if maxK < 2:
        K = 2
    else:
        K = random.randint(2, maxK)

    S = K * (K + 1) // 2

    # Pick a start position with enough room to the bottom and right so the ideal spiral fits
    start_r = random.randint(0, size - 1 - S)
    start_c = random.randint(0, size - 1 - S)

    # Build the ideal adjacency path following the expanding down-right pattern
    path = [(start_r, start_c)]
    cur_r, cur_c = start_r, start_c
    dirs = [(1, 0), (0, 1)]  # down, right
    # Construct the ideal (adjacent) spiral for K cycles
    for k in range(1, K + 1):
        # move k steps down
        for _ in range(k):
            dr, dc = dirs[0]
            cur_r += dr
            cur_c += dc
            path.append((cur_r, cur_c))
        # move k steps right
        for _ in range(k):
            dr, dc = dirs[1]
            cur_r += dr
            cur_c += dc
            path.append((cur_r, cur_c))

    # Place exactly one teleporter pair to create a non-physical jump in the path.
    # Choose an entrance index and a later exit index so the teleporter will be used.
    tele_map = {}
    if len(path) >= 5:
        entrance_idx = random.randint(1, len(path) - 3)
        exit_idx = random.randint(entrance_idx + 2, len(path) - 1)
        tele_enter = path[entrance_idx]
        tele_exit = path[exit_idx]
        tele_map[tele_enter] = tele_exit

    # Create set for quick barrier checks (cells in 'path' are open)
    path_set = set(path)

    # Simulate the particle's movement (this determines the visited sequence)
    visited = [path[0]]
    cur = path[0]
    # We simulate the same expanding pattern used to build `path`.
    stop = False
    for k in range(1, K + 1):
        # down k steps
        for _ in range(k):
            nr = cur[0] + dirs[0][0]
            nc = cur[1] + dirs[0][1]
            # stop if the next cell is not part of the carved corridor (i.e., it's a barrier or out of bounds)
            if not (0 <= nr < size and 0 <= nc < size):
                stop = True
                break
            if (nr, nc) not in path_set:
                stop = True
                break
            visited.append((nr, nc))
            if (nr, nc) in tele_map:
                exit_cell = tele_map[(nr, nc)]
                visited.append(exit_cell)
                cur = exit_cell
            else:
                cur = (nr, nc)
        if stop:
            break
        # right k steps
        for _ in range(k):
            nr = cur[0] + dirs[1][0]
            nc = cur[1] + dirs[1][1]
            if not (0 <= nr < size and 0 <= nc < size):
                stop = True
                break
            if (nr, nc) not in path_set:
                stop = True
                break
            visited.append((nr, nc))
            if (nr, nc) in tele_map:
                exit_cell = tele_map[(nr, nc)]
                visited.append(exit_cell)
                cur = exit_cell
            else:
                cur = (nr, nc)
        if stop:
            break

    # Build the input grid. We will use the following fixed palette so the solver can detect colors:
    # 0 - background, 1 - particle start, 2 - barrier, 3 - teleporter entrance, 4 - teleporter exit
    BACK = 0
    START = 1
    BARRIER = 2
    T_ENTER = 3
    T_EXIT = 4

    # Start with all cells set to BARRIER so the barriers form a solid obstacle course
    grid = [[BARRIER for _ in range(size)] for _ in range(size)]

    # Make the ideal path cells open (background). This carves a unique corridor through the barriers.
    for (r, c) in path:
        grid[r][c] = BACK

    # Place the particle start
    sr, sc = path[0]
    grid[sr][sc] = START

    # Place teleporter entrance/exit colors
    for ent, ex in tele_map.items():
        er, ec = ent
        xr, xc = ex
        grid[er][ec] = T_ENTER
        grid[xr][xc] = T_EXIT

    # Build the output grid by overlaying a temporal decay along the visited sequence
    # The decay palette avoids the reserved colors (2,3,4). We keep 1 as the earliest color (original particle hue)
    DECAY = [1, 5, 6, 7, 8, 9, 0]
    output = [row[:] for row in grid]
    for idx, (r, c) in enumerate(visited):
        col = DECAY[idx] if idx < len(DECAY) else DECAY[-1]
        output[r][c] = col

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0]) if h > 0 else 0

    # Palette used by the generator (we rely on these fixed values)
    START = 1
    BARRIER = 2
    T_ENTER = 3
    T_EXIT = 4

    # Locate the start particle
    start = None
    for r in range(h):
        for c in range(w):
            if grid[r][c] == START:
                start = (r, c)
                break
        if start:
            break
    if start is None:
        return grid

    # Locate a single teleporter pair if present
    tele_enter = None
    tele_exit = None
    for r in range(h):
        for c in range(w):
            if grid[r][c] == T_ENTER:
                tele_enter = (r, c)
            elif grid[r][c] == T_EXIT:
                tele_exit = (r, c)
    tele_map = {}
    if tele_enter is not None and tele_exit is not None:
        tele_map[tele_enter] = tele_exit

    # Movement simulation: expanding down-right pattern (1 down,1 right,2 down,2 right,...)
    dirs = [(1, 0), (0, 1)]  # down, right
    visited = [start]
    cur = start

    steps = 1
    # Safety cap to avoid infinite loops in malformed inputs
    cap = h * w + 10
    total = 0

    while total < cap:
        # down for `steps` cells
        blocked = False
        for _ in range(steps):
            nr = cur[0] + dirs[0][0]
            nc = cur[1] + dirs[0][1]
            if not (0 <= nr < h and 0 <= nc < w):
                blocked = True
                break
            if grid[nr][nc] == BARRIER:
                blocked = True
                break
            visited.append((nr, nc))
            total += 1
            if (nr, nc) in tele_map:
                cur = tele_map[(nr, nc)]
                visited.append(cur)
                total += 1
            else:
                cur = (nr, nc)
            if total >= cap:
                break
        if blocked or total >= cap:
            break

        # right for `steps` cells
        blocked = False
        for _ in range(steps):
            nr = cur[0] + dirs[1][0]
            nc = cur[1] + dirs[1][1]
            if not (0 <= nr < h and 0 <= nc < w):
                blocked = True
                break
            if grid[nr][nc] == BARRIER:
                blocked = True
                break
            visited.append((nr, nc))
            total += 1
            if (nr, nc) in tele_map:
                cur = tele_map[(nr, nc)]
                visited.append(cur)
                total += 1
            else:
                cur = (nr, nc)
            if total >= cap:
                break
        if blocked or total >= cap:
            break

        steps += 1

    # Overlay the decaying path onto the input grid to produce the expected output
    output = [row[:] for row in grid]
    DECAY = [1, 5, 6, 7, 8, 9, 0]
    for idx, (r, c) in enumerate(visited):
        col = DECAY[idx] if idx < len(DECAY) else DECAY[-1]
        output[r][c] = col

    return output

