# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 4aa2949a
Difficulty: hard

=== Tags ===
- Teleporter network routing
- Take complement

=== Description ===
The input grid is a 2D array of integers ranging from 0 to 9. The task involves
identifying a single connected region (4-directionally) of cells that form a
"teleporter network," defined by a specific non-zero value (e.g., 5) that
appears in a contiguous block. The output grid is generated by applying a
complement operation to all cells within this network: each cell's value is
replaced with 9 minus its original value. All cells outside the network remain
unchanged. The complement operation is deterministic and relies on correctly
identifying the connected teleporter network before transformation. This
requires the solver to detect the network's boundaries through connectivity
analysis, making the task challenging due to the need for precise region
identification before applying the arithmetic transformation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    w = random.randint(1, 30)
    h = random.randint(1, 30)
    teleporter_color = random.randint(1, 9)
    max_size = min(20, w * h)
    s = max_size if max_size < 3 else random.randint(3, max_size)
    region = common.continuous_creature(s, w, h)
    input_grid = [[0] * w for _ in range(h)]
    for r, c in region:
        input_grid[r][c] = teleporter_color
    output_grid = [row[:] for row in input_grid]
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] == teleporter_color:
                output_grid[r][c] = 9 - teleporter_color
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    h = len(input_grid)
    w = len(input_grid[0])
    colors_seen = set()
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] != 0:
                colors_seen.add(input_grid[r][c])
    
    def is_connected(color, grid):
        h = len(grid)
        w = len(grid[0])
        visited = [[False] * w for _ in range(h)]
        cells = []
        for r in range(h):
            for c in range(w):
                if grid[r][c] == color:
                    cells.append((r, c))
        if not cells:
            return True
        queue = [cells[0]]
        visited[cells[0][0]][cells[0][1]] = True
        while queue:
            r, c = queue.pop(0)
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] == color:
                    visited[nr][nc] = True
                    queue.append((nr, nc))
        for (r, c) in cells:
            if not visited[r][c]:
                return False
        return True
    
    valid_colors = []
    for color in colors_seen:
        if is_connected(color, input_grid):
            valid_colors.append(color)
    
    if len(valid_colors) != 1:
        teleporter_color = valid_colors[0]
    else:
        teleporter_color = valid_colors[0]
    
    output_grid = [list(row) for row in input_grid]
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] == teleporter_color:
                output_grid[r][c] = 9 - teleporter_color
    return output_grid
