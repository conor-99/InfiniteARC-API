# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 0caaead5
Difficulty: hard

=== Tags ===
- Detect wall
- Hypothesis selection from ambiguity

=== Description ===
The input grids consist of 2D arrays of integers (0-9) representing colored
pixels, containing multiple distinct solid square regions (perfect geometric
squares formed by contiguous pixels of identical color, with equal width and
height). The task requires identifying the largest square region (by side
length) among all such squares in the grid. If multiple squares share the same
maximum size, the topmost and leftmost square in row-major order is selected.
The output grid retains only the pixels of the selected square (preserving its
original color), while all other pixels are set to 0 (background). Ambiguity
arises from the presence of multiple squares of varying sizes and positions,
requiring the solver to apply a visual size-based selection rule rather than
numerical or color-dependent criteria.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = [[0] * width for _ in range(height)]
    squares = []
    num_squares = random.randint(2, 4)
    
    for _ in range(num_squares):
        color = random.randint(1, 9)
        max_s = min(width, height) // 2
        s = random.randint(2, max_s)
        placed = False
        retry = 0
        while not placed and retry < 1000:
            r = random.randint(0, height - s)
            c = random.randint(0, width - s)
            valid = True
            for i in range(s):
                for j in range(s):
                    if grid[r + i][c + j] != 0:
                        valid = False
                        break
                if not valid:
                    break
            if valid:
                for i in range(s):
                    for j in range(s):
                        grid[r + i][c + j] = color
                squares.append((r, c, s, color))
                placed = True
            retry += 1
        if not placed:
            # Fallback to top-left position
            r, c = 0, 0
            for i in range(s):
                for j in range(s):
                    if r + i < height and c + j < width:
                        grid[r + i][c + j] = color
            squares.append((r, c, s, color))
    squares.sort(key=lambda x: (-x[2], x[0], x[1]))
    selected_r, selected_c, selected_s, selected_color = squares[0]
    
    output = [[0] * width for _ in range(height)]
    for i in range(selected_s):
        for j in range(selected_s):
            output[selected_r + i][selected_c + j] = selected_color
    
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    best_square = None
    
    for r in range(height):
        for c in range(width):
            max_s = min(height - r, width - c)
            for s in range(max_s, 1, -1):
                color = input_grid[r][c]
                if color == 0:
                    continue
                valid = True
                for i in range(s):
                    for j in range(s):
                        if input_grid[r + i][c + j] != color:
                            valid = False
                            break
                    if not valid:
                        break
                if valid:
                    if best_square is None:
                        best_square = (r, c, s, color)
                    else:
                        if s > best_square[2] or (s == best_square[2] and (r < best_square[0] or (r == best_square[0] and c < best_square[1]))):
                            best_square = (r, c, s, color)
                    break
    
    if best_square is None:
        return [[0] * width for _ in range(height)]
    
    r, c, s, color = best_square
    output = [[0] * width for _ in range(height)]
    for i in range(s):
        for j in range(s):
            output[r + i][c + j] = color
    return output
