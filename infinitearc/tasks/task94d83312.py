# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 94d83312
Difficulty: very hard

=== Tags ===
- Surface unfolding
- Draw line to nearest object of same color

=== Description ===
Input grids are 10×10 to 30×30 with a single background color (0). Overlaid on
this background are multiple disjoint regions (connected components) of colors
1–9, each region being a contiguous area of a single color. Some regions are
folded along a single vertical or horizontal fold line within the grid, causing
their pattern to be mirrored across this line (e.g., a vertical fold line makes
the region's right half mirror the left half, and vice versa). The fold line is
determined by the grid's mirror symmetry, where for all rows or columns, the
left/right or top/bottom halves match when reflected.  The output grid is
generated through two sequential transformations: first, unfolding all folded
regions by removing the mirroring effect (e.g., for a vertical fold line at
column x, the right half of the region is replaced with a copy of the left half,
creating a continuous region without mirroring). Second, for each cell in a
region (color C), a line is drawn to the nearest cell of color C (excluding
itself) using the shortest 4-directional path through background cells (0),
following the Manhattan distance in the unfolded grid. The line must traverse
only background cells without intersecting other regions, and is rendered using
color C. The nearest cell is determined in the unfolded grid, not the input
grid. Multiple regions may share a single fold line, and the task requires
identifying the fold line, unfolding the grid, then computing all shortest
paths. This process demands recognizing mirror symmetry, performing geometric
unfolding, and pathfinding through constrained background spaces—all while
avoiding visual ambiguities like overlapping regions or non-geometric color
patterns.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common
from collections import deque


def generate():
    # size even between 10 and 30
    size = random.randint(5,15)*2
    mid = size//2
    # create left half
    left = [[0 for _ in range(mid)] for _ in range(size)]
    # choose colors
    num_colors = random.randint(2,4)
    colors = random.sample(list(range(1,10)), num_colors)
    # place regions
    for color in colors:
        num_regions = random.randint(1,3)
        for _ in range(num_regions):
            # attempt to place region by random walk
            placed=False
            for attempt in range(200):
                r0 = random.randrange(size)
                c0 = random.randrange(mid)
                if left[r0][c0] != 0:
                    continue
                # region size
                region_size = random.randint(1,4)
                coords = {(r0,c0)}
                # expand
                tries = 0
                while len(coords) < region_size and tries < 200:
                    tries +=1
                    pr,pc = random.choice(tuple(coords))
                    # choose neighbor
                    neighs = []
                    for dr,dc in ((-1,0),(1,0),(0,-1),(0,1)):
                        nr, nc = pr+dr, pc+dc
                        if 0<=nr<size and 0<=nc<mid and left[nr][nc]==0 and (nr,nc) not in coords:
                            neighs.append((nr,nc))
                    if not neighs:
                        continue
                    coords.add(random.choice(neighs))
                # ensure not adjacent to existing other shapes (manhattan adjacency)
                ok = True
                for (pr,pc) in coords:
                    for dr,dc in ((-1,0),(1,0),(0,-1),(0,1)):
                        nr,nc = pr+dr, pc+dc
                        if 0<=nr<size and 0<=nc<mid:
                            if left[nr][nc] != 0 and (nr,nc) not in coords:
                                ok = False
                                break
                    if not ok:
                        break
                if not ok:
                    continue
                # place
                for (pr,pc) in coords:
                    left[pr][pc] = color
                placed=True
                break
            # if not placed skip
    # construct base grid by copying left half to right half same order
    base = [[0 for _ in range(size)] for _ in range(size)]
    for r in range(size):
        for c in range(mid):
            base[r][c] = left[r][c]
            base[r][mid + c] = left[r][c]
    # prepare output grid as copy of base and draw lines
    output = [row[:] for row in base]
    # map color positions in unfolded grid (base)
    positions_by_color = {}
    for r in range(size):
        for c in range(size):
            col = base[r][c]
            if col == 0:
                continue
            positions_by_color.setdefault(col, []).append((r,c))
    # BFS path finder
    def find_path(start, target, grid):
        if start == target:
            return [start]
        dq = deque([start])
        N = len(grid)
        visited = [[False]*N for _ in range(N)]
        visited[start[0]][start[1]] = True
        prev = {start: None}
        while dq:
            cur = dq.popleft()
            if cur == target:
                # rebuild path
                path=[]
                node=cur
                while node is not None:
                    path.append(node)
                    node = prev[node]
                path.reverse()
                return path
            for dr,dc in ((-1,0),(0,-1),(0,1),(1,0)):
                nr, nc = cur[0]+dr, cur[1]+dc
                if not (0<=nr<N and 0<=nc<N): continue
                if visited[nr][nc]: continue
                # allow stepping onto background or the target cell
                if grid[nr][nc] != 0 and (nr,nc) != target:
                    continue
                visited[nr][nc] = True
                prev[(nr,nc)] = cur
                dq.append((nr,nc))
        return None
    # draw lines sequentially row-major
    for r in range(size):
        for c in range(size):
            color = output[r][c]
            if color == 0:
                continue
            positions = positions_by_color.get(color, [])
            if len(positions) <= 1:
                continue
            # find nearest using Manhattan distance (tie-breaker row then col)
            best = None
            bestd = 10**9
            for (r2,c2) in positions:
                if r2==r and c2==c:
                    continue
                d = abs(r2-r) + abs(c2-c)
                if d < bestd or (d == bestd and ((r2 < best[0]) or (r2 == best[0] and c2 < best[1]))):
                    bestd = d
                    best = (r2,c2)
            if best is None:
                continue
            path = find_path((r,c), best, output)
            if path:
                for (pr,pc) in path[1:-1]:
                    if output[pr][pc] == 0:
                        output[pr][pc] = color
    # create folded input by mirroring right half as reversed left half
    input_grid = [row[:] for row in base]
    for r in range(size):
        for j in range(mid):
            input_grid[r][mid + j] = base[r][mid - 1 - j]
    return {'input': input_grid, 'output': output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    from collections import deque
    # Convert input grid to modifiable list
    grid = [list(row) for row in input_grid]
    N = len(grid)
    if N == 0:
        return grid
    # detect vertical symmetry across center or horizontal symmetry
    vert = True
    for r in range(N):
        for c in range(N):
            if grid[r][c] != grid[r][N - 1 - c]:
                vert = False
                break
        if not vert:
            break
    hor = False
    if not vert:
        hor = True
        for r in range(N):
            for c in range(N):
                if grid[r][c] != grid[N - 1 - r][c]:
                    hor = False
                    break
            if not hor:
                break
    # unfold: if vertical symmetry, copy left half to right half in same order
    if vert:
        mid = N // 2
        for r in range(N):
            for c in range(mid):
                grid[r][mid + c] = grid[r][c]
    elif hor:
        mid = N // 2
        for c in range(N):
            for r in range(mid):
                grid[mid + r][c] = grid[r][c]
    # Now draw lines same as generator
    # prepare positions by color in unfolded grid
    positions_by_color = {}
    for r in range(N):
        for c in range(N):
            col = grid[r][c]
            if col == 0: continue
            positions_by_color.setdefault(col, []).append((r,c))
    # BFS path finder identical neighbor order
    def find_path(start, target, curgrid):
        if start == target:
            return [start]
        dq = deque([start])
        visited = [[False]*N for _ in range(N)]
        visited[start[0]][start[1]] = True
        prev = {start: None}
        while dq:
            cur = dq.popleft()
            if cur == target:
                path=[]
                node = cur
                while node is not None:
                    path.append(node)
                    node = prev[node]
                path.reverse()
                return path
            for dr,dc in ((-1,0),(0,-1),(0,1),(1,0)):
                nr, nc = cur[0]+dr, cur[1]+dc
                if not (0<=nr<N and 0<=nc<N): continue
                if visited[nr][nc]: continue
                if curgrid[nr][nc] != 0 and (nr,nc) != target:
                    continue
                visited[nr][nc] = True
                prev[(nr,nc)] = cur
                dq.append((nr,nc))
        return None
    # draw lines row-major, using positions_by_color computed above (from unfolded grid before lines)
    for r in range(N):
        for c in range(N):
            color = grid[r][c]
            if color == 0:
                continue
            positions = positions_by_color.get(color, [])
            if len(positions) <= 1:
                continue
            # find nearest by Manhattan distance tie-break
            best = None
            bestd = 10**9
            for (r2,c2) in positions:
                if r2==r and c2==c:
                    continue
                d = abs(r2-r) + abs(c2-c)
                if d < bestd or (d == bestd and ((r2 < best[0]) or (r2 == best[0] and c2 < best[1]))):
                    bestd = d
                    best = (r2,c2)
            if best is None:
                continue
            path = find_path((r,c), best, grid)
            if path:
                for (pr,pc) in path[1:-1]:
                    if grid[pr][pc] == 0:
                        grid[pr][pc] = color
    return grid

