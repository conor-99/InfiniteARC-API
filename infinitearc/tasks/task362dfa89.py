# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 362dfa89
Difficulty: easy

=== Tags ===
- Associate colors to bools
- Adapt image to grid
- Remove intruder

=== Description ===
The task involves transforming an input grid into an output grid by removing a
single "intruder" cell. The input grid contains a primary color forming a
connected shape (e.g., a rectangle or blob), with exactly one cell of a
different color (the intruder) that does not belong to the shape. The output
grid retains the primary color in all positions where it appears in the input,
while replacing all other cells—including the intruder—with the background color
(0). The primary color is visually dominant and forms a contiguous region,
making the intruder easily identifiable as the sole outlier. This transformation
follows a simple rule: remove the single cell of a non-primary color without
altering the rest of the shape, adapting the input image to its clean, intruder-
free form.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random
from common import continuous_creature, grid

def generate():
    width = random.randint(2, 30)
    height = random.randint(2, 30)
    primary = random.randint(1, 9)
    intruder = random.choice([i for i in range(1, 10) if i != primary])
    total_cells = width * height
    s = random.randint(2, total_cells - 1)
    pixels = continuous_creature(s, width, height)
    input_grid = grid(width, height, 0)
    for (r, c) in pixels:
        input_grid[r][c] = primary
    zero_cells = [(r, c) for r in range(height) for c in range(width) if input_grid[r][c] == 0]
    if not zero_cells:
        zero_cells = [(r, c) for r in range(height) for c in range(width)]
    r_in, c_in = random.choice(zero_cells)
    input_grid[r_in][c_in] = intruder
    output_grid = grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == primary:
                output_grid[r][c] = primary
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
from common import connected, grid

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    colors = set()
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                colors.add(input_grid[r][c])
    if not colors:
        return grid(width, height, 0)
    color_positions = {}
    for c in colors:
        pos = []
        for r in range(height):
            for col in range(width):
                if input_grid[r][col] == c:
                    pos.append((r, col))
        color_positions[c] = pos
    primary_color = None
    max_size = 0
    for c, positions in color_positions.items():
        if common.connected(positions):
            if len(positions) > max_size:
                max_size = len(positions)
                primary_color = c
    if primary_color is None:
        primary_color = next(iter(colors))
    output = grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == primary_color:
                output[r][c] = primary_color
    return output
