# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 976e6f59
Difficulty: hard

=== Tags ===
- Pattern moving
- Mimic pattern

=== Description ===
The input grid contains multiple distinct contiguous patterns, each formed by a
single color. Each pattern is moved in the output grid based on two rules: (1)
patterns of warm colors (red, orange, yellow) are shifted right by 2 cells,
while patterns of cool colors (blue, green) are shifted left by 2 cells; (2)
patterns located in the top half of the grid are shifted down by 2 cells, and
those in the bottom half are shifted up by 2 cells. The combined movement is
applied to the pattern's top-left position, with adjustments made to ensure the
pattern remains within grid boundaries. The output grid displays all patterns
moved according to these rules, with no overlapping patterns.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    input_grid = grid(width, height, 0)
    output_grid = grid(width, height, 0)
    patterns = []
    warm_colors = [2, 4, 7]
    cool_colors = [1, 3]
    
    for _ in range(random.randint(3, 5)):
        color = random.choice(warm_colors + cool_colors)
        if random.random() < 0.5:
            r = random.randint(0, height//2 - 1)
        else:
            r = random.randint(height//2, height - 1)
        if color in warm_colors:
            c = random.randint(0, width - 3)
        else:
            c = random.randint(2, width - 1)
        if any(r == pr and c == pc for pr, pc in patterns):
            continue
        patterns.append((r, c))
        input_grid[r][c] = color
    
    for (r, c) in patterns:
        color = input_grid[r][c]
        shift_h = 2 if color in [2, 4, 7] else -2
        shift_v = 2 if r < height // 2 else -2
        new_r = max(0, min(r + shift_v, height - 1))
        new_c = max(0, min(c + shift_h, width - 1))
        output_grid[new_r][new_c] = color
    
    if input_grid == output_grid:
        return generate()
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = grid(width, height, 0)
    visited = [[False] * width for _ in range(height)]
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and input_grid[r][c] != 0:
                color = input_grid[r][c]
                component = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                min_r = min(cr for cr, cc in component)
                min_c = min(cc for cr, cc in component)
                shift_h = 2 if color in [2, 4, 7] else -2
                shift_v = 2 if min_r < height // 2 else -2
                for cr, cc in component:
                    new_r = max(0, min(cr + shift_v, height - 1))
                    new_c = max(0, min(cc + shift_h, width - 1))
                    output_grid[new_r][new_c] = color
    return output_grid
