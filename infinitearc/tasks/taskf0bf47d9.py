# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: f0bf47d9
Difficulty: easy

=== Tags ===
- Associate images to patterns
- Fit to bounding box

=== Description ===
The task involves transforming an input grid into an output grid by cropping the
grid to the minimal bounding box that contains all non-zero elements. The input
grid will always contain a connected pattern (e.g., a letter-like shape or
geometric form) made of non-zero colors, surrounded by at least one empty row
and column on all sides. The output grid is formed by removing all empty rows
and columns outside the smallest rectangle that encloses every non-zero pixel.
For example, if the input grid has a 3x3 pattern centered within a 5x5 grid, the
output will be a 3x3 grid containing only the pattern. The transformation is
visual and relies solely on spatial arrangement, avoiding numerical or color-
based computations. The input and output grids will always differ in size due to
the removal of surrounding empty space, ensuring the rule is consistently
applied and discoverable through simple observation of the input's shape.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
from common import rand_sprite, random_color, grid

def generate():
    sprite_names = ['el', 'aitch', 'you']
    sprite_name = common.random.choice(sprite_names)
    width = common.random.randint(3, 5)
    height = common.random.randint(3, 5)
    pixels = rand_sprite(sprite_name, width, height)
    if not pixels:
        pixels = [(0, 0)]
    min_r = min(p[0] for p in pixels)
    max_r = max(p[0] for p in pixels)
    min_c = min(p[1] for p in pixels)
    max_c = max(p[1] for p in pixels)
    H = max_r - min_r + 1
    W = max_c - min_c + 1
    input_rows = min(H + 2, 30)
    input_cols = min(W + 2, 30)
    input_grid = grid(input_cols, input_rows, 0)
    color = random_color()
    for (r, c) in pixels:
        input_grid[r+1][c+1] = color
    output_grid = []
    for r in range(1, input_rows - 1):
        output_grid.append(input_grid[r][1:input_cols - 1])
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    non_zero = []
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] != 0:
                non_zero.append((r, c))
    if not non_zero:
        return grid(1, 1, 0)
    min_r = min(p[0] for p in non_zero)
    max_r = max(p[0] for p in non_zero)
    min_c = min(p[1] for p in non_zero)
    max_c = max(p[1] for p in non_zero)
    output_grid = []
    for r in range(min_r, max_r + 1):
        output_grid.append(input_grid[r][min_c:max_c + 1])
    return output_grid
