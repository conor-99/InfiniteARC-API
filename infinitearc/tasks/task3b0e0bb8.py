# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 3b0e0bb8
Difficulty: easy

=== Tags ===
- Direction guessing
- Associate images to bools
- Background filling
- Take intersection

=== Description ===
The input grid contains a connected shape composed of non-zero values (the
"foreground") and a single direction indicator cell with value 2 (the "image").
The position of the indicator determines the direction of movement: if the
indicator is in the top row, the shape shifts upward; if in the bottom row,
downward; if in the leftmost column, leftward; if in the rightmost column,
rightward (direction guessing). The presence of the indicator (image) is
associated with a boolean "true" value, triggering the transformation. The
output grid is formed by shifting the entire foreground shape in the determined
direction by one cell, while filling all background cells (originally zero and
not part of the shifted shape) with the value 3 (background filling). The "take
intersection" aspect refers to the fact that the shifted shape may overlap with
its original position within the grid boundaries, and only the overlapping
region (intersection) of the original and shifted shape is retained in the
output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, rand_sprite, random_color, randint

def generate():
    width = randint(3, 5)
    height = randint(3, 5)
    grid_input = grid(width, height, 0)
    shape_name = random.choice(['el', 'aitch', 'you'])
    pixels = rand_sprite(shape_name, width, height)
    if len(pixels) < 2:
        return generate()
    edge_pixels = []
    for (r, c) in pixels:
        if r == 0 and c != 0 and c != width-1:
            edge_pixels.append((r, c))
        elif r == height-1 and c != 0 and c != width-1:
            edge_pixels.append((r, c))
        elif c == 0 and r != 0 and r != height-1:
            edge_pixels.append((r, c))
        elif c == width-1 and r != 0 and r != height-1:
            edge_pixels.append((r, c))
    if not edge_pixels:
        return generate()
    r, c = random.choice(edge_pixels)
    colors = [random_color(exclude=[2]) for _ in range(len(pixels))]
    for i, (r0, c0) in enumerate(pixels):
        if r0 == r and c0 == c:
            grid_input[r0][c0] = 2
        else:
            grid_input[r0][c0] = colors[i]
    if r == 0:
        dr, dc = -1, 0
    elif r == height-1:
        dr, dc = 1, 0
    elif c == 0:
        dr, dc = 0, -1
    else:
        dr, dc = 0, 1
    shifted_pixels = []
    for (r0, c0) in pixels:
        nr, nc = r0 + dr, c0 + dc
        if 0 <= nr < height and 0 <= nc < width:
            shifted_pixels.append((nr, nc))
    intersection = set(pixels) & set(shifted_pixels)
    if not intersection:
        return generate()
    grid_output = grid(width, height, 3)
    for (r0, c0) in intersection:
        grid_output[r0][c0] = grid_input[r0][c0]
    return {
        "input": grid_input,
        "output": grid_output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    indicator = None
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 2:
                indicator = (r, c)
    if indicator is None:
        return [[3] * width for _ in range(height)]
    r, c = indicator
    if r == 0:
        dr, dc = -1, 0
    elif r == height-1:
        dr, dc = 1, 0
    elif c == 0:
        dr, dc = 0, -1
    elif c == width-1:
        dr, dc = 0, 1
    else:
        dr, dc = 0, 0
    shape = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                shape.append((r, c))
    shifted = []
    for (r0, c0) in shape:
        nr, nc = r0 + dr, c0 + dc
        if 0 <= nr < height and 0 <= nc < width:
            shifted.append((nr, nc))
    intersection = set(shape) & set(shifted)
    output = [[3] * width for _ in range(height)]
    for (r, c) in intersection:
        output[r][c] = input_grid[r][c]
    return output
