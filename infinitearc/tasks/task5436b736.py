# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 5436b736
Difficulty: medium–hard

=== Tags ===
- Reflect by color
- Recursive partition
- Draw pattern from point
- Associate patterns to patterns
- Color by rank in row

=== Description ===
Input grids consist of 15×15 to 25×25 grids with a background color (0) and
multiple disconnected, 4-connected regions of colors 1–9. Each region is
surrounded by background and contains no internal holes. The grid includes a
reference row (topmost row, excluding background) and reference column (leftmost
column, excluding background), each containing a sequence of 3–5 colors that
match colors present in the regions.  Transformation rules: 1. **Reflect by
Color**: For each region, if its color is even (2,4,6,8), reflect the region
across the grid's vertical midline; if odd (1,3,5,7,9), reflect across the
horizontal midline. Reflections create mirrored copies, merging with existing
regions where they overlap. 2. **Recursive Partition**: Using the reference row
and column as guides, recursively partition the grid into quadrants. Starting
from the grid's center, split into four regions. For each quadrant containing a
region, repeat the partitioning until each quadrant contains exactly one region
from the original grid. 3. **Draw Pattern from Point**: For each isolated region
in its quadrant, draw a pattern centered at the region's centroid. The pattern
type (e.g., cross, circle, diagonal line) is fixed per color (e.g., color 1 =
cross, color 2 = circle). 4. **Associate Patterns to Patterns**: Replace each
drawn pattern with its predefined association (e.g., cross → circle, circle →
diagonal line) based on a fixed color-pattern mapping. 5. **Color by Rank in
Row**: For each row in the output grid, sort the colors present in the row
according to their rank in the reference row (ascending order based on the
reference sequence). Replace the row with colors in this sorted order,
preserving the pattern associations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import math
import copy
import common


def generate():
    # Grid size
    width = random.randint(15, 25)
    height = random.randint(15, 25)

    # Start with an empty background grid
    # common.grid expects (width, height, color)
    # and returns a list of `height` rows each of length `width`.
    # We'll build the input grid in two stages: reference marks, then regions.
    base = common.grid(width, height, 0)

    # Number of regions (and distinct colors) is 3..5
    n_regions = random.randint(3, 5)
    region_colors = random.sample(list(range(1, 10)), n_regions)

    # Place a reference row (topmost non-background) at row 0
    # Put the sequence of region colors there in a random order (unique)
    ref_row = region_colors[:]
    random.shuffle(ref_row)
    # choose a start column that doesn't use column 0 (we reserve column 0 for the ref column)
    start_col = random.randint(1, max(1, width - n_regions))
    for i, col in enumerate(ref_row):
        base[0][start_col + i] = col

    # Place a reference column at column 0 using a (possibly different) permutation
    ref_col = region_colors[:]
    random.shuffle(ref_col)
    start_row = random.randint(1, max(1, height - n_regions))
    for i, col in enumerate(ref_col):
        base[start_row + i][0] = col

    # Occupancy map to avoid collisions when placing regions
    occupied = [[False] * width for _ in range(height)]
    for c in range(width):
        if base[0][c] != 0:
            occupied[0][c] = True
    for r in range(height):
        if base[r][0] != 0:
            occupied[r][0] = True

    # Try to place one contiguous 4-connected region per color
    # We will use common.continuous_creature to generate contiguous shapes
    region_pixels = {}

    # We'll attempt placement; if it fails repeatedly we restart generation
    attempts_outer = 0
    while True:
        attempts_outer += 1
        region_pixels.clear()
        # copy the occupancy for this try
        occ = [row[:] for row in occupied]
        grid_local = common.grid(width, height, 0)
        # copy the reference marks into the local grid
        for c in range(width):
            if base[0][c] != 0:
                grid_local[0][c] = base[0][c]
        for r in range(height):
            if base[r][0] != 0:
                grid_local[r][0] = base[r][0]

        failed = False
        for color in region_colors:
            placed = False
            # Try a reasonable number of times to place this region
            for attempt in range(200):
                wsh = random.randint(2, 6)
                hsh = random.randint(2, 6)
                max_size = wsh * hsh
                min_size = max(3, max_size // 3)
                size = random.randint(min_size, max_size)
                pixels = common.continuous_creature(size, wsh, hsh)
                # compute local extents
                rmax = max(p[0] for p in pixels)
                cmax = max(p[1] for p in pixels)
                local_h = rmax + 1
                local_w = cmax + 1

                # choose top-left position so the sprite doesn't touch row 0 or col 0
                r0_min = 1
                r0_max = max(1, height - local_h)
                c0_min = 1
                c0_max = max(1, width - local_w)
                r0 = random.randint(r0_min, r0_max)
                c0 = random.randint(c0_min, c0_max)

                abs_pixels = [(r0 + rp, c0 + cp) for (rp, cp) in pixels]

                # Ensure no pixel collides and no 4-adjacency to previously placed pixels or refs
                ok = True
                for (rr, cc) in abs_pixels:
                    if occ[rr][cc]:
                        ok = False
                        break
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = rr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width:
                            if occ[nr][nc]:
                                ok = False
                                break
                    if not ok:
                        break
                if not ok:
                    continue

                # Place the shape
                for (rr, cc) in abs_pixels:
                    grid_local[rr][cc] = color
                    occ[rr][cc] = True
                region_pixels[color] = abs_pixels
                placed = True
                break
            if not placed:
                failed = True
                break
        if not failed:
            input_grid = grid_local
            break
        if attempts_outer > 20:
            # restart full generation
            return generate()

    # Build the output by applying the transformations described
    output_grid = [row[:] for row in input_grid]

    # 1) Reflect by Color parity using the original region pixels
    for color in sorted(region_pixels.keys()):
        for (r, c) in region_pixels[color]:
            if color % 2 == 0:
                nc = width - 1 - c
                if output_grid[r][nc] == 0:
                    output_grid[r][nc] = color
            else:
                nr = height - 1 - r
                if output_grid[nr][c] == 0:
                    output_grid[nr][c] = color

    # 2) Recursive partition: compute centroids of original regions
    centroids = {}
    for color, pixels in region_pixels.items():
        avg_r = sum(p[0] for p in pixels) / len(pixels)
        avg_c = sum(p[1] for p in pixels) / len(pixels)
        centroids[color] = (int(avg_r), int(avg_c))

    # recursive subdivision until each part contains at most one original region
    region_list = list(region_pixels.keys())
    mapping = {}

    def subdivide(r0, r1, c0, c1, colors):
        if not colors:
            return
        if len(colors) == 1:
            mapping[colors[0]] = (r0, r1, c0, c1)
            return
        rm = (r0 + r1) // 2
        cm = (c0 + c1) // 2
        quads = [
            (r0, rm, c0, cm),
            (r0, rm, cm + 1, c1),
            (rm + 1, r1, c0, cm),
            (rm + 1, r1, cm + 1, c1),
        ]
        for (qr0, qr1, qc0, qc1) in quads:
            inside = []
            for col in colors:
                cr, cc = centroids[col]
                if qr0 <= cr <= qr1 and qc0 <= cc <= qc1:
                    inside.append(col)
            if inside:
                subdivide(qr0, qr1, qc0, qc1, inside)

    subdivide(0, height - 1, 0, width - 1, region_list)

    # 3) Draw simple fixed patterns per color (small shapes)
    patterns = {
        1: [(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0)],  # cross
        2: [(0, 0), (1, 0), (-1, 0), (0, 1), (0, -1)],  # plus/circle-like
        3: [(0, 0), (1, 1), (-1, -1)],                  # diagonal
        4: [(0, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)],  # X
        5: [(0, 0), (0, 1), (1, 0), (1, 1)],            # 2x2 square
        6: [(0, 0), (0, 1), (0, -1), (-1, 0)],          # T
        7: [(0, 0), (0, 1), (0, -1)],                   # horizontal line
        8: [(0, 0), (1, 0), (-1, 0)],                   # vertical line
        9: [(0, 0), (1, 0), (0, 1), (-1, 0), (0, -1)],  # diamond
    }

    # 4) Associate patterns to patterns by rotating the reference row sequence
    assoc = {}
    for i, col in enumerate(ref_row):
        assoc[col] = ref_row[(i + 1) % len(ref_row)]

    # For each original region draw the associated pattern (overwriting cells)
    for color in region_list:
        cen_r, cen_c = centroids[color]
        if color in mapping:
            r0, r1, c0, c1 = mapping[color]
        else:
            r0, r1, c0, c1 = 0, height - 1, 0, width - 1
        target = assoc[color]
        shape = patterns[target]
        for dr, dc in shape:
            rr = cen_r + dr
            cc = cen_c + dc
            if 0 <= rr < height and 0 <= cc < width and (r0 <= rr <= r1) and (c0 <= cc <= c1):
                output_grid[rr][cc] = target

    # 5) Color by Rank in Row: for each row sort non-background cells by order in ref_row
    rank = {col: i for i, col in enumerate(ref_row)}
    for r in range(height):
        nz_pos = [c for c in range(width) if output_grid[r][c] != 0]
        if not nz_pos:
            continue
        row_colors = [output_grid[r][c] for c in nz_pos]
        sorted_colors = sorted(row_colors, key=lambda x: rank.get(x, len(ref_row)))
        for idx, cpos in enumerate(nz_pos):
            output_grid[r][cpos] = sorted_colors[idx]

    return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Find the reference row: the topmost row that contains any non-background cell
    ref_row_idx = None
    for r in range(height):
        if any(grid[r][c] != 0 for c in range(width)):
            ref_row_idx = r
            break
    if ref_row_idx is None:
        # nothing to do
        return tuple(tuple(row) for row in grid)
    ref_row = [grid[ref_row_idx][c] for c in range(width) if grid[ref_row_idx][c] != 0]

    # Find the reference column: the leftmost column that contains any non-background cell
    ref_col_idx = None
    for c in range(width):
        if any(grid[r][c] != 0 for r in range(height)):
            ref_col_idx = c
            break
    if ref_col_idx is None:
        ref_col_idx = 0

    # Identify original region pixels: colors that appear outside the reference row and column
    region_pixels = {}
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if v == 0:
                continue
            # skip the reference row/column markers
            if r == ref_row_idx or c == ref_col_idx:
                continue
            region_pixels.setdefault(v, []).append((r, c))

    # Copy grid to output and apply reflection by parity using original region pixels
    out = [row[:] for row in grid]
    for color in sorted(region_pixels.keys()):
        for (r, c) in region_pixels[color]:
            if color % 2 == 0:
                nc = width - 1 - c
                if out[r][nc] == 0:
                    out[r][nc] = color
            else:
                nr = height - 1 - r
                if out[nr][c] == 0:
                    out[nr][c] = color

    # Compute centroids for regions (use floor of average)
    centroids = {}
    for color, pixels in region_pixels.items():
        avg_r = sum(p[0] for p in pixels) / len(pixels)
        avg_c = sum(p[1] for p in pixels) / len(pixels)
        centroids[color] = (int(avg_r), int(avg_c))

    # Recursively partition the grid until each partition has at most one original region
    region_list = list(region_pixels.keys())
    mapping = {}

    def subdivide(r0, r1, c0, c1, colors):
        if not colors:
            return
        if len(colors) == 1:
            mapping[colors[0]] = (r0, r1, c0, c1)
            return
        rm = (r0 + r1) // 2
        cm = (c0 + c1) // 2
        quads = [
            (r0, rm, c0, cm),
            (r0, rm, cm + 1, c1),
            (rm + 1, r1, c0, cm),
            (rm + 1, r1, cm + 1, c1)
        ]
        for (qr0, qr1, qc0, qc1) in quads:
            inside = []
            for col in colors:
                cr, cc = centroids[col]
                if qr0 <= cr <= qr1 and qc0 <= cc <= qc1:
                    inside.append(col)
            if inside:
                subdivide(qr0, qr1, qc0, qc1, inside)

    subdivide(0, height - 1, 0, width - 1, region_list)

    # Define same small patterns as generator
    patterns = {
        1: [(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0)],
        2: [(0, 0), (1, 0), (-1, 0), (0, 1), (0, -1)],
        3: [(0, 0), (1, 1), (-1, -1)],
        4: [(0, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)],
        5: [(0, 0), (0, 1), (1, 0), (1, 1)],
        6: [(0, 0), (0, 1), (0, -1), (-1, 0)],
        7: [(0, 0), (0, 1), (0, -1)],
        8: [(0, 0), (1, 0), (-1, 0)],
        9: [(0, 0), (1, 0), (0, 1), (-1, 0), (0, -1)],
    }

    # Association map: rotate the reference row order by one
    assoc = {}
    for i, col in enumerate(ref_row):
        assoc[col] = ref_row[(i + 1) % len(ref_row)]

    # Draw associated patterns for each region (overwrite cells)
    for color in region_list:
        cen_r, cen_c = centroids[color]
        if color in mapping:
            r0, r1, c0, c1 = mapping[color]
        else:
            r0, r1, c0, c1 = 0, height - 1, 0, width - 1
        target = assoc[color]
        shape = patterns[target]
        for dr, dc in shape:
            rr = cen_r + dr
            cc = cen_c + dc
            if 0 <= rr < height and 0 <= cc < width and (r0 <= rr <= r1) and (c0 <= cc <= c1):
                out[rr][cc] = target

    # Color by Rank in Row: sort non-background cells by their index in the reference row
    rank = {col: i for i, col in enumerate(ref_row)}
    for r in range(height):
        nz_pos = [c for c in range(width) if out[r][c] != 0]
        if not nz_pos:
            continue
        row_colors = [out[r][c] for c in nz_pos]
        sorted_colors = sorted(row_colors, key=lambda x: rank.get(x, len(ref_row)))
        for idx, cpos in enumerate(nz_pos):
            out[r][cpos] = sorted_colors[idx]

    return tuple(tuple(row) for row in out)

