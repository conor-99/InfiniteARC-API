# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 748f97b5
Difficulty: hard

=== Tags ===
- Pattern concatenation
- Momentum conservation path
- Swap columns
- Direction guessing

=== Description ===
Input grids consist of a background color (0) overlaid with multiple distinct
colored paths, each forming a contiguous sequence of cells (orthogonally or
diagonally connected) of a single non-background color. Paths are separated by
background cells and do not overlap. Each path has an inferred direction (up,
down, left, right, or diagonal) determined by analyzing the path's initial
segment and surrounding grid features (e.g., a path starting with a rightward
horizontal segment implies a rightward direction). The direction must be guessed
by the solver through pattern analysis, as it is not explicitly marked.  The
output grid is generated through three sequential transformations:   1.
**Momentum Conservation Path Extension**: For each path, extend its sequence in
the inferred direction until hitting a grid boundary or non-background cell.
Upon boundary contact, reflect the direction (e.g., right → left, up → down,
diagonal → opposite diagonal) and continue extending. Each extension step uses
the path's original color and occupies only background cells.   2. **Pattern
Concatenation**: Concatenate all extended paths into a single continuous
sequence ordered by their starting positions (top-left to bottom-right).
Adjacent paths in the concatenation are placed edge-to-edge without overlapping.
3. **Direction-Based Column Swapping**: Swap a specific pair of columns in the
concatenated grid based on the direction of the first segment of the
concatenated path. For example:      - Right → swap columns 0 and 1      - Left
→ swap columns 2 and 3      - Up → swap columns 4 and 5      - Down → swap
columns 6 and 7      - Diagonal (e.g., up-right) → swap columns 8 and 9    The
output retains all background cells and path extensions, with column swaps
applied to the entire grid. No path segments overwrite existing paths or
background cells, and all transformations follow deterministic rules requiring
multi-step reasoning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_color

def generate():
    """Generates an ARC pair following the task description.

    - Creates an input grid with several non-overlapping colored paths.
    - Each path is a short straight segment oriented in one of four directions
      (right, down-right, down, down-left) so that the path start is the
      lexicographically smallest cell (top-left) of that path. This makes the
      direction inference deterministic for the solver.
    - Extends each path with momentum (reflecting on boundaries) while
      preventing overlaps, then concatenates the extended paths side-by-side
      (ordered by bounding-box top-left) and applies a column swap based on
      the first path's initial direction.
    """
    # Allowed directions chosen so that the start cell (first placed cell)
    # is lexicographically minimal among the path's cells. This keeps the
    # solver's inference simple and consistent.
    ALLOWED_DIRS = [(0, 1), (1, 1), (1, 0), (1, -1)]  # right, down-right, down, down-left

    def neighbors8(r, c, H, W):
        for dr in (-1, 0, 1):
            for dc in (-1, 0, 1):
                if dr == 0 and dc == 0:
                    continue
                nr, nc = r + dr, c + dc
                if 0 <= nr < H and 0 <= nc < W:
                    yield (nr, nc)

    # Try until we produce a configuration that respects size limits
    for attempt in range(200):
        width = random.randint(6, 12)
        height = random.randint(6, 12)
        num_paths = random.randint(2, 4)

        inp = grid(width, height, 0)
        used_colors = []
        paths = []  # each path: dict with keys 'cells'(ordered from start), 'dir', 'color'
        reserved = set()  # cells that cannot be used (to keep paths separated by at least one background cell)

        placement_ok = True
        for _ in range(num_paths):
            color = random_color(exclude=used_colors)
            placed = False
            used_colors.append(color)
            # place a short straight initial segment of length L
            L = random.randint(2, 4)
            # Try several times to place this path without touching others
            for _try in range(250):
                dr, dc = random.choice(ALLOWED_DIRS)
                # Compute allowable start ranges so the full segment fits
                min_r = 0
                max_r = height - 1 - dr * (L - 1) if dr >= 0 else height - 1
                min_c = 0 if dc >= 0 else -dc * (L - 1)
                max_c = width - 1 - dc * (L - 1) if dc >= 0 else width - 1
                if max_r < min_r or max_c < min_c:
                    continue
                r = random.randint(min_r, max_r)
                c = random.randint(min_c, max_c)
                coords = [(r + i * dr, c + i * dc) for i in range(L)]
                # Check that none of the coords or their 8-neighbors are reserved
                conflict = False
                for (rr, cc) in coords:
                    if (rr, cc) in reserved:
                        conflict = True
                        break
                    # also ensure the base grid cell is empty
                    if inp[rr][cc] != 0:
                        conflict = True
                        break
                if conflict:
                    continue
                # Accept placement: mark cells and update reserved area
                for (rr, cc) in coords:
                    inp[rr][cc] = color
                    reserved.add((rr, cc))
                    for (nr, nc) in neighbors8(rr, cc, height, width):
                        reserved.add((nr, nc))
                paths.append({
                    'cells': coords[:],
                    'dir': (dr, dc),
                    'color': color
                })
                placed = True
                break
            if not placed:
                placement_ok = False
                break

        if not placement_ok:
            continue

        # Sort paths by bounding-box top-left (min row, then min col) to define order
        def bbox_top_left(path):
            rs = [p[0] for p in path['cells']]
            cs = [p[1] for p in path['cells']]
            return (min(rs), min(cs))

        paths_sorted = sorted(paths, key=bbox_top_left)

        # Extend paths in this sorted order; update occupancy so later paths don't overlap
        occupancy = [row[:] for row in inp]
        extended_paths = []
        for p in paths_sorted:
            cells = p['cells'][:]
            color = p['color']
            dr, dc = p['dir']
            # endpoint in the direction of motion is the last cell (we generated it that way)
            r, c = cells[-1]
            cur_dr, cur_dc = dr, dc
            while True:
                nr, nc = r + cur_dr, c + cur_dc
                # reflect if hitting boundary
                if not (0 <= nr < height and 0 <= nc < width):
                    cur_dr, cur_dc = -cur_dr, -cur_dc
                    nr, nc = r + cur_dr, c + cur_dc
                    if not (0 <= nr < height and 0 <= nc < width):
                        break
                # stop if cell occupied
                if occupancy[nr][nc] != 0:
                    break
                # place extension
                occupancy[nr][nc] = color
                cells.append((nr, nc))
                r, c = nr, nc
            extended_paths.append({'cells': cells, 'dir': p['dir'], 'color': color})

        # Calculate concatenated size and ensure it's within limits
        boxes = []
        for p in extended_paths:
            rs = [x[0] for x in p['cells']]
            cs = [x[1] for x in p['cells']]
            min_r, max_r = min(rs), max(rs)
            min_c, max_c = min(cs), max(cs)
            boxes.append((min_r, max_r, min_c, max_c))
        widths = [b[3] - b[2] + 1 for b in boxes]
        heights = [b[1] - b[0] + 1 for b in boxes]
        total_width = sum(widths)
        max_height = max(heights) if heights else 0
        if total_width < 1 or total_width > 30 or max_height < 1 or max_height > 30:
            # try again
            continue

        # Build concatenated grid
        concatenated = grid(total_width, max_height, 0)
        cur_col = 0
        for p, (min_r, max_r, min_c, max_c) in zip(extended_paths, boxes):
            color = p['color']
            for (rr, cc) in p['cells']:
                new_r = rr - min_r
                new_c = cc - min_c + cur_col
                concatenated[new_r][new_c] = color
            cur_col += (max_c - min_c + 1)

        # Column swap mapping based on the first path's initial direction
        first_dir = extended_paths[0]['dir']
        direction_to_swap = {
            (0, 1): (0, 1),    # right
            (0, -1): (2, 3),   # left (not used by generator but kept for completeness)
            (-1, 0): (4, 5),   # up
            (1, 0): (6, 7),    # down
            (-1, 1): (8, 9),   # diag
            (1, 1): (8, 9),
            (-1, -1): (8, 9),
            (1, -1): (8, 9)
        }
        col1, col2 = direction_to_swap.get(first_dir, (0, 1))
        if col1 < total_width and col2 < total_width and col1 != col2:
            for rr in range(max_height):
                concatenated[rr][col1], concatenated[rr][col2] = concatenated[rr][col2], concatenated[rr][col1]

        # Ensure input != output (different shapes or content)
        if len(inp) == len(concatenated) and len(inp[0]) == len(concatenated[0]):
            same = True
            for r in range(len(inp)):
                if inp[r] != concatenated[r]:
                    same = False
                    break
            if same:
                continue

        return {"input": inp, "output": concatenated}

    # Fallback (should not normally get here)
    # Return a trivial pair if all attempts failed
    inp = grid(6, 6, 0)
    out = grid(6, 6, 0)
    out[0][0] = 1
    return {"input": inp, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    # Convert to mutable list-of-lists
    g = [list(row) for row in input_grid]
    H = len(g)
    W = len(g[0]) if H > 0 else 0

    def neighbors8(r, c):
        for dr in (-1, 0, 1):
            for dc in (-1, 0, 1):
                if dr == 0 and dc == 0:
                    continue
                nr, nc = r + dr, c + dc
                if 0 <= nr < H and 0 <= nc < W:
                    yield (nr, nc)

    # Find 8-connected components (each component is a single-colored path)
    visited = [[False] * W for _ in range(H)]
    components = []  # each is (cells_list, color)
    for r in range(H):
        for c in range(W):
            if g[r][c] == 0 or visited[r][c]:
                continue
            color = g[r][c]
            stack = [(r, c)]
            comp = []
            visited[r][c] = True
            while stack:
                cr, cc = stack.pop()
                comp.append((cr, cc))
                for (nr, nc) in neighbors8(cr, cc):
                    if not visited[nr][nc] and g[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            components.append((comp, color))

    # For each component determine a start cell (lexicographically minimal) and direction
    comps_info = []  # list of dicts: 'cells','dir','color'
    for comp, color in components:
        comp.sort(key=lambda x: (x[0], x[1]))
        # start is lexicographically minimal cell
        start = comp[0]
        # find a neighbor cell in the component to determine initial segment direction
        next_cell = None
        for (nr, nc) in neighbors8(start[0], start[1]):
            if (nr, nc) in comp:
                next_cell = (nr, nc)
                break
        if next_cell is None:
            # degenerate single-cell component; pick right as default
            dr, dc = (0, 1)
        else:
            dr = next_cell[0] - start[0]
            dc = next_cell[1] - start[1]
        comps_info.append({'cells': comp[:], 'dir': (dr, dc), 'color': color})

    # Sort by bounding-box top-left (min row, min col)
    def bbox_top_left(info):
        rs = [p[0] for p in info['cells']]
        cs = [p[1] for p in info['cells']]
        return (min(rs), min(cs))

    comps_sorted = sorted(comps_info, key=bbox_top_left)

    # Extend each path in the sorted order, updating occupancy to avoid overlaps
    occupancy = [row[:] for row in g]
    extended = []
    for info in comps_sorted:
        cells = info['cells'][:]
        color = info['color']
        dr, dc = info['dir']
        # endpoint in direction is last cell in the generated list; we can take the
        # cell with maximal projection along (dr,dc) to be safe
        if dr == 0 and dc == 0:
            r, c = cells[-1]
        else:
            # compute projection value r*dr + c*dc and select cell with largest
            # value to be endpoint in that direction
            best = None
            best_val = None
            for (rr, cc) in cells:
                val = rr * dr + cc * dc
                if best is None or val > best_val:
                    best = (rr, cc)
                    best_val = val
            r, c = best
        cur_dr, cur_dc = dr, dc
        while True:
            nr, nc = r + cur_dr, c + cur_dc
            # reflect if hitting boundary
            if not (0 <= nr < H and 0 <= nc < W):
                cur_dr, cur_dc = -cur_dr, -cur_dc
                nr, nc = r + cur_dr, c + cur_dc
                if not (0 <= nr < H and 0 <= nc < W):
                    break
            if occupancy[nr][nc] != 0:
                break
            occupancy[nr][nc] = color
            cells.append((nr, nc))
            r, c = nr, nc
        extended.append({'cells': cells, 'dir': (dr, dc), 'color': color})

    # Build concatenated grid (side-by-side) sorted by the same bounding-box rule
    boxes = []
    for p in extended:
        rs = [x[0] for x in p['cells']]
        cs = [x[1] for x in p['cells']]
        boxes.append((min(rs), max(rs), min(cs), max(cs)))
    widths = [b[3] - b[2] + 1 for b in boxes]
    heights = [b[1] - b[0] + 1 for b in boxes]
    total_width = sum(widths) if widths else 0
    max_height = max(heights) if heights else 0
    if total_width == 0 or max_height == 0:
        return [[0]]

    out = grid(total_width, max_height, 0)
    cur_col = 0
    for p, (min_r, max_r, min_c, max_c) in zip(extended, boxes):
        color = p['color']
        for (rr, cc) in p['cells']:
            new_r = rr - min_r
            new_c = cc - min_c + cur_col
            out[new_r][new_c] = color
        cur_col += (max_c - min_c + 1)

    # Column swap based on first component's direction
    first_dir = extended[0]['dir'] if extended else (0, 1)
    direction_to_swap = {
        (0, 1): (0, 1),
        (0, -1): (2, 3),
        (-1, 0): (4, 5),
        (1, 0): (6, 7),
        (-1, 1): (8, 9),
        (1, 1): (8, 9),
        (-1, -1): (8, 9),
        (1, -1): (8, 9)
    }
    col1, col2 = direction_to_swap.get(first_dir, (0, 1))
    if col1 < total_width and col2 < total_width and col1 != col2:
        for rr in range(max_height):
            out[rr][col1], out[rr][col2] = out[rr][col2], out[rr][col1]

    return out

