# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: ca585675
Difficulty: insane

=== Tags ===
- Coordinate system translation
- Lava flow
- Hole punch pattern

=== Description ===
The input grids are large (20×20 to 30×30) with a background color (0). A
vertical column of "lava" (color 1) originates at the top edge and extends
downward for 10–15 rows. Embedded within the grid is a "hole punch pattern"
(color 2), a complex, non-repeating arrangement of holes forming a fractal-like
structure (e.g., a Sierpinski triangle variant) that occupies 15–20% of the
grid. This pattern is defined by recursive hole removal from a base grid, with
hole positions determined by a hidden coordinate transformation. A "coordinate
translation marker" (color 3) appears as a small grid of arrows (e.g., three
right, two down) in the top-left corner, indicating a translation vector (dx,
dy) that shifts the hole pattern's coordinate system.  The transformation
involves two sequential operations: 1. **Coordinate system translation**: The
entire hole punch pattern is shifted by the vector (dx, dy) specified by the
marker. This transforms the fractal structure's anchor points, relocating holes
to new positions while preserving the pattern's recursive properties. 2. **Lava
flow propagation**: The lava column (color 1) flows downward from its original
position, filling all background cells (0) below it. Flow is blocked by
translated holes, causing lava to propagate diagonally (following the
translation vector's direction) around holes. The flow path dynamically adjusts
to the new hole positions, creating a branched, non-linear pattern that avoids
all translated holes while maintaining connectivity to the lava source.  The
output grid retains the background, shows the translated hole pattern, and
displays the lava flow path (color 1) as a continuous, branched structure that
navigates around the shifted holes. The coordinate translation marker remains
unchanged, and all other grid elements (e.g., unmodified background) are
preserved. The task requires identifying the fractal hole pattern's recursive
rules, applying the coordinate shift, and simulating the lava's adaptive flow
around obstacles—combining geometric reasoning, pattern translation, and dynamic
pathfinding in a single operation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque

def generate():
    """
    Generate a 20-30 sized grid with:
    - background 0
    - a vertical lava column (color 1) starting at top, length 10-15
    - a fractal-like hole pattern (color 2) generated via a Sierpinski-carpet style rule
      applied across the grid with a small random offset; holes avoid the marker area
      and the initial lava column.
    - a translation marker (color 3) in the top-left encoding (dx, dy): top row has
      dx cells = 3 and the first column (rows 1..dy) has dy cells = 3.

    The output is produced by translating every hole by (dx, dy) and then simulating
    a lava flow from the top-of-grid lava source. The lava flow is blocked by holes
    and by the marker; it propagates downward and diagonally (favoring the sign of
    dx) to navigate around translated holes.
    """
    # Grid size
    size = random.randint(20, 30)
    grid = [[0 for _ in range(size)] for _ in range(size)]

    # Translation marker (top-left): top row [0][0..dx-1] and first column [1..dy]
    dx = random.randint(1, 4)
    dy = random.randint(1, 4)
    for c in range(dx):
        grid[0][c] = 3
    for r in range(1, dy + 1):
        grid[r][0] = 3

    # Choose a lava column that avoids the marker area (keep it at least dx+1 columns in)
    # and not on the very right edge so diagonal flow can occur.
    min_col = max(1, dx + 1)
    max_col = size - 2
    if min_col > max_col:
        # Fallback if strange (shouldn't happen given sizes): pick a safe column
        lava_col = min(1, size - 2)
    else:
        lava_col = random.randint(min_col, max_col)

    # Draw initial vertical lava in the input (color 1)
    lava_len = random.randint(10, 15)
    for r in range(min(lava_len, size)):
        grid[r][lava_col] = 1

    # --- Create a Sierpinski-carpet-like hole pattern across the grid ---
    # We use "levels" iterations of the base-3 center removal rule. Using levels=2
    # gives a hole fraction near ~21%; we'll adjust to land in the 15%-20% window.
    levels = 2

    def is_sierpinski_hole(rr, cc, levels):
        # Check up to `levels` base-3 digits for the center (1,1) condition
        for _ in range(levels):
            if rr % 3 == 1 and cc % 3 == 1:
                return True
            rr //= 3
            cc //= 3
        return False

    # Random offset to change the coordinate system (this creates variety)
    off_r = random.randint(0, max(0, size - 1))
    off_c = random.randint(0, max(0, size - 1))

    holes = []
    for r in range(size):
        for c in range(size):
            # Skip marker area and existing lava (we don't want holes there)
            if grid[r][c] != 0:
                continue
            if is_sierpinski_hole(r + off_r, c + off_c, levels):
                grid[r][c] = 2
                holes.append((r, c))

    # Adjust hole count to be within target fraction of the whole grid (15% - 20%)
    total_cells = size * size
    target_frac = random.uniform(0.15, 0.20)
    target_holes = int(round(target_frac * total_cells))
    cur_holes = len(holes)

    if cur_holes > target_holes:
        # Remove some holes at random to lower density
        remove_n = cur_holes - target_holes
        if remove_n > 0:
            to_remove = random.sample(holes, min(remove_n, len(holes)))
            for (r, c) in to_remove:
                grid[r][c] = 0
                holes.remove((r, c))
    elif cur_holes < target_holes:
        # Add additional holes in empty spots (prefer positions not in marker or lava)
        need = target_holes - cur_holes
        candidates = [(r, c) for r in range(size) for c in range(size) if grid[r][c] == 0]
        if candidates:
            add = random.sample(candidates, min(need, len(candidates)))
            for (r, c) in add:
                grid[r][c] = 2
                holes.append((r, c))

    # --- Build output by translating holes and simulating lava flow ---
    output = [[0 for _ in range(size)] for _ in range(size)]

    # Copy marker unchanged
    for c in range(dx):
        output[0][c] = 3
    for r in range(1, dy + 1):
        output[r][0] = 3

    # Place translated holes (color 2)
    translated_holes = set()
    for (r, c) in holes:
        nr, nc = r + dy, c + dx
        if 0 <= nr < size and 0 <= nc < size:
            # Do not overwrite the marker
            if output[nr][nc] != 3:
                output[nr][nc] = 2
                translated_holes.add((nr, nc))

    # Simulate lava flow from the top source; lava cannot overwrite holes (2) or marker (3)
    # Directions favor downward and the horizontal sign of dx (dx>0 -> favor right)
    dsig = 1 if dx > 0 else (-1 if dx < 0 else 0)
    neighbors = [(1, 0), (1, dsig), (0, dsig), (1, -dsig), (0, -dsig)]

    visited = [[False for _ in range(size)] for _ in range(size)]
    q = deque()
    start = (0, lava_col)
    q.append(start)
    visited[start[0]][start[1]] = True

    while q:
        r, c = q.popleft()
        # Do not overwrite the marker or holes
        if output[r][c] == 0:
            output[r][c] = 1
        for dr, dc in neighbors:
            nr, nc = r + dr, c + dc
            if not (0 <= nr < size and 0 <= nc < size):
                continue
            if visited[nr][nc]:
                continue
            if output[nr][nc] == 2 or output[nr][nc] == 3:
                continue
            visited[nr][nc] = True
            q.append((nr, nc))

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    # Convert immutable tuple-of-tuples to a mutable list-of-lists
    grid = [list(row) for row in input_grid]
    size = len(grid)

    # Read marker: dx = number of consecutive 3's from top-left along row 0
    dx = 0
    for c in range(size):
        if grid[0][c] == 3:
            dx += 1
        else:
            break
    # dy = number of consecutive 3's in column 0 starting from row 1
    dy = 0
    for r in range(1, size):
        if grid[r][0] == 3:
            dy += 1
        else:
            break

    # Find lava source column: prefer a 1 at the top row; otherwise find any column with
    # some lava in the top region
    lava_col = None
    for c in range(size):
        if grid[0][c] == 1:
            lava_col = c
            break
    if lava_col is None:
        for c in range(size):
            if any(grid[r][c] == 1 for r in range(min(15, size))):
                lava_col = c
                break
    if lava_col is None:
        lava_col = 0

    # Collect original holes (color 2) from the input
    holes = [(r, c) for r in range(size) for c in range(size) if grid[r][c] == 2]

    # Prepare output; copy marker
    output = [[0 for _ in range(size)] for _ in range(size)]
    for c in range(dx):
        output[0][c] = 3
    for r in range(1, dy + 1):
        output[r][0] = 3

    # Translate holes by (dx, dy)
    for (r, c) in holes:
        nr, nc = r + dy, c + dx
        if 0 <= nr < size and 0 <= nc < size:
            # Do not overwrite the marker
            if output[nr][nc] != 3:
                output[nr][nc] = 2

    # Simulate lava flow from the top source using the same neighbor preference as generator
    dsig = 1 if dx > 0 else (-1 if dx < 0 else 0)
    neighbors = [(1, 0), (1, dsig), (0, dsig), (1, -dsig), (0, -dsig)]

    visited = [[False for _ in range(size)] for _ in range(size)]
    q = deque()
    q.append((0, lava_col))
    visited[0][lava_col] = True

    while q:
        r, c = q.popleft()
        if output[r][c] == 0:
            output[r][c] = 1
        for dr, dc in neighbors:
            nr, nc = r + dr, c + dc
            if not (0 <= nr < size and 0 <= nc < size):
                continue
            if visited[nr][nc]:
                continue
            if output[nr][nc] == 2 or output[nr][nc] == 3:
                continue
            visited[nr][nc] = True
            q.append((nr, nc))

    return output

