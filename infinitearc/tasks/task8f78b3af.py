# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 8f78b3af
Difficulty: easy

=== Tags ===
- Duplicate row pattern
- Enlarge image
- Draw x on largest object
- Pattern intersection

=== Description ===
The input grid consists of multiple connected colored objects (regions of the
same color). The largest object is identified as the connected region with the
most cells. The output grid is generated through the following steps:   1.
**Enlarge the input grid** by a factor of 2, converting each input cell into a
2Ã—2 block of the same color.   2. **Draw an 'X'** on the enlarged area
corresponding to the largest object. This is achieved by coloring the diagonal
cells of the bounding box of the largest object (in the enlarged grid) with a
distinct color (e.g., color 9).   3. **Duplicate a row pattern**: The row
containing the center of the 'X' in the enlarged grid is duplicated immediately
below it, creating a repeating visual pattern.   4. **Pattern intersection**:
The duplicated row intersects with the 'X' diagonals, forming a consistent
visual pattern where the intersection points align with the 'X' lines, ensuring
no conflicts with other objects.   All transformations are deterministic, rely
solely on visual structure (not numerical values), and maintain clarity for
easy-level reasoning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = random.randint(5, 15)
    height = random.randint(5, 15)
    grid_in = common.grid(width, height, 0)
    
    color_large = random.choice([i for i in range(1, 10) if i != 0])
    top = random.randint(0, height - 3)
    left = random.randint(0, width - 3)
    for r in range(top, top + 3):
        for c in range(left, left + 3):
            if 0 <= r < height and 0 <= c < width:
                grid_in[r][c] = color_large
    
    color_small = random.choice([i for i in range(1, 10) if i != 0 and i != color_large])
    top_small = random.randint(0, height - 2)
    left_small = random.randint(0, width - 2)
    for r in range(top_small, top_small + 2):
        for c in range(left_small, left_small + 2):
            if 0 <= r < height and 0 <= c < width:
                grid_in[r][c] = color_small
    
    color_single = random.choice([i for i in range(1, 10) if i != 0 and i != color_large and i != color_small])
    r_single = random.randint(0, height - 1)
    c_single = random.randint(0, width - 1)
    grid_in[r_single][c_single] = color_single
    
    visited = [[False] * width for _ in range(height)]
    largest_bbox = None
    largest_size = 0
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and grid_in[r][c] != 0:
                color = grid_in[r][c]
                stack = [(r, c)]
                visited[r][c] = True
                region = []
                while stack:
                    x, y = stack.pop()
                    region.append((x, y))
                    for dx, dy in [(0,1), (0,-1), (1,0), (-1,0)]:
                        nx, ny = x + dx, y + dy
                        if 0 <= nx < height and 0 <= ny < width and not visited[nx][ny] and grid_in[nx][ny] == color:
                            visited[nx][ny] = True
                            stack.append((nx, ny))
                size = len(region)
                if size > largest_size:
                    largest_size = size
                    min_row = min(x for x, y in region)
                    max_row = max(x for x, y in region)
                    min_col = min(y for x, y in region)
                    max_col = max(y for x, y in region)
                    largest_bbox = (min_row, max_row, min_col, max_col)
    
    grid_enlarged = common.grid(2 * width, 2 * height, 0)
    for r in range(height):
        for c in range(width):
            color = grid_in[r][c]
            grid_enlarged[2*r][2*c] = color
            grid_enlarged[2*r][2*c+1] = color
            grid_enlarged[2*r+1][2*c] = color
            grid_enlarged[2*r+1][2*c+1] = color
    
    r1 = 2 * largest_bbox[0]
    r2 = 2 * largest_bbox[1] + 1
    c1 = 2 * largest_bbox[2]
    c2 = 2 * largest_bbox[3] + 1
    
    for i in range(r1, r2 + 1):
        for j in range(c1, c2 + 1):
            if (i - r1) == (j - c1) or (i - r1) == (c2 - j):
                grid_enlarged[i][j] = 9
    
    m = (r1 + r2) // 2
    if m + 1 < len(grid_enlarged):
        grid_enlarged[m + 1] = grid_enlarged[m][:]
    
    return {
        'input': grid_in,
        'output': grid_enlarged
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(grid_in):
    width = len(grid_in[0])
    height = len(grid_in)
    
    visited = [[False] * width for _ in range(height)]
    largest_bbox = None
    largest_size = 0
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and grid_in[r][c] != 0:
                color = grid_in[r][c]
                stack = [(r, c)]
                visited[r][c] = True
                region = []
                while stack:
                    x, y = stack.pop()
                    region.append((x, y))
                    for dx, dy in [(0,1), (0,-1), (1,0), (-1,0)]:
                        nx, ny = x + dx, y + dy
                        if 0 <= nx < height and 0 <= ny < width and not visited[nx][ny] and grid_in[nx][ny] == color:
                            visited[nx][ny] = True
                            stack.append((nx, ny))
                size = len(region)
                if size > largest_size:
                    largest_size = size
                    min_row = min(x for x, y in region)
                    max_row = max(x for x, y in region)
                    min_col = min(y for x, y in region)
                    max_col = max(y for x, y in region)
                    largest_bbox = (min_row, max_row, min_col, max_col)
    
    grid_enlarged = common.grid(2 * width, 2 * height, 0)
    for r in range(height):
        for c in range(width):
            color = grid_in[r][c]
            grid_enlarged[2*r][2*c] = color
            grid_enlarged[2*r][2*c+1] = color
            grid_enlarged[2*r+1][2*c] = color
            grid_enlarged[2*r+1][2*c+1] = color
    
    r1 = 2 * largest_bbox[0]
    r2 = 2 * largest_bbox[1] + 1
    c1 = 2 * largest_bbox[2]
    c2 = 2 * largest_bbox[3] + 1
    
    for i in range(r1, r2 + 1):
        for j in range(c1, c2 + 1):
            if (i - r1) == (j - c1) or (i - r1) == (c2 - j):
                grid_enlarged[i][j] = 9
    
    m = (r1 + r2) // 2
    if m + 1 < len(grid_enlarged):
        grid_enlarged[m + 1] = grid_enlarged[m][:]
    
    return grid_enlarged
