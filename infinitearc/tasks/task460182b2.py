# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 460182b2
Difficulty: medium

=== Tags ===
- Create grid
- Cluster by color
- Tiled majority vote

=== Description ===
The input grid consists of connected regions (clusters) of the same color. The
output grid is generated by dividing the input into non-overlapping 2x2 tiles
starting from the top-left corner. For each tile, the output cell is determined
by the most frequent color within that tile; in cases of tied frequencies, the
smallest color value is chosen. The output grid dimensions are calculated as
(input width // 2) × (input height // 2), ensuring all grids remain within the
1×1 to 30×30 size constraints. This transformation relies solely on visual
pattern recognition through regional color clustering and majority voting within
fixed-sized tiles, without dependence on numerical sums or pixel-level
properties.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    W = random.randint(2, 30)
    H = random.randint(2, 30)
    c1 = random.randint(1, 9)
    c2 = random.randint(1, 9)
    while c2 == c1:
        c2 = random.randint(1, 9)
    k = random.randint(1, W-1)
    
    input_grid = []
    for _ in range(H):
        row = [c1] * k + [c2] * (W - k)
        input_grid.append(row)
    
    output_width = W // 2
    output_height = H // 2
    output_grid = [[0] * output_width for _ in range(output_height)]
    
    for i in range(output_height):
        for j in range(output_width):
            colors = []
            for r in range(2):
                for c in range(2):
                    colors.append(input_grid[i*2 + r][j*2 + c])
            count = {}
            for color in colors:
                count[color] = count.get(color, 0) + 1
            max_count = max(count.values())
            candidates = [color for color in count if count[color] == max_count]
            output_grid[i][j] = min(candidates)
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid or not input_grid[0]:
        return []
    W = len(input_grid[0])
    H = len(input_grid)
    output_width = W // 2
    output_height = H // 2
    output_grid = [[0] * output_width for _ in range(output_height)]
    
    for i in range(output_height):
        for j in range(output_width):
            colors = []
            for r in range(2):
                for c in range(2):
                    colors.append(input_grid[i*2 + r][j*2 + c])
            count = {}
            for color in colors:
                count[color] = count.get(color, 0) + 1
            max_count = max(count.values())
            candidates = [color for color in count if count[color] == max_count]
            output_grid[i][j] = min(candidates)
    return output_grid
