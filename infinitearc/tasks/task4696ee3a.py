# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 4696ee3a
Difficulty: insane

=== Tags ===
- Reconstruct checkerboard from hint

=== Description ===
Input grids feature a large, complex background with scattered cells of two
distinct "hint" colors (A and B) distributed non-uniformly across the grid,
alongside additional distracting colors (C, D, etc.) that do not participate in
the checkerboard pattern. The hint colors A and B are positioned such that their
arrangement follows a strict parity-based alternation: for any cell (i, j), the
color is A if (i + j) is even and B if (i + j) is odd (or vice versa), with the
specific mapping determined by the relative positions of the hint cells. The
output grid reconstructs a full checkerboard pattern by replacing all background
cells (0) with A or B according to the parity rule, while preserving the
original hint cells exactly as they appear. The input includes sufficient hint
cells to unambiguously determine the parity mapping (e.g., at least one cell of
each color at positions confirming the parity rule), and no two hint cells share
the same parity. Distracting elements (additional colors, isolated single-cell
features, or minor patterns) are present but irrelevant to the reconstruction.
The task requires recognizing the parity pattern from sparse, scattered hints
amid visual noise, applying it deterministically across the entire grid without
overwriting the hint cells, and ignoring all non-hint elements. This demands
high-level visual abstraction, pattern inference from minimal cues, and
robustness against irrelevant visual features.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Dimensions
    width = random.randint(5, 30)
    height = random.randint(5, 30)

    colors = list(range(1, 10))
    # Choose two distinct hint colors A and B
    A = random.choice(colors)
    colors.remove(A)
    B = random.choice(colors)

    # Randomly decide which color goes on even vs odd parity
    if random.choice([True, False]):
        even_color = A
        odd_color = B
    else:
        even_color = B
        odd_color = A

    # Start with a blank background (0)
    input_grid = [[0 for _ in range(width)] for _ in range(height)]

    # Helper to place a color on cells of a given parity without overwriting hints
    def place_on_parity(color, parity, count):
        placed = 0
        tries = 0
        # Guard to avoid infinite loop on tiny grids
        max_tries = max(1000, count * 200)
        while placed < count and tries < max_tries:
            r = random.randrange(height)
            c = random.randrange(width)
            if (r + c) % 2 != parity:
                tries += 1
                continue
            if input_grid[r][c] == 0:
                input_grid[r][c] = color
                placed += 1
            tries += 1
        return placed

    # Place several hint cells for each hint color (ensuring parity consistency)
    max_hint_each = max(2, (width * height) // 20)
    num_even_hints = random.randint(2, max_hint_each)
    num_odd_hints = random.randint(2, max_hint_each)
    # Place on appropriate parities
    place_on_parity(even_color, 0, num_even_hints)
    place_on_parity(odd_color, 1, num_odd_hints)

    # Add distracting colors. Ensure each distracting color appears at least once on both parities
    available = [c for c in range(1, 10) if c not in (even_color, odd_color)]
    num_distract_colors = random.randint(1, min(4, len(available)))
    distract_colors = random.sample(available, num_distract_colors)

    for dcolor in distract_colors:
        # Ensure at least one on each parity
        place_on_parity(dcolor, 0, 1)
        place_on_parity(dcolor, 1, 1)
        # Add a few extra scattered instances of this distractor
        extra = random.randint(0, max(1, (width * height) // 30))
        for _ in range(extra):
            r = random.randrange(height)
            c = random.randrange(width)
            # Don't overwrite hint colors
            if input_grid[r][c] == 0:
                input_grid[r][c] = dcolor

    # Add some additional sparse noise while keeping many zeros to be filled
    noise_attempts = random.randint(0, max(0, (width * height) // 8))
    for _ in range(noise_attempts):
        r = random.randrange(height)
        c = random.randrange(width)
        if input_grid[r][c] == 0:
            # choose a distraction color to place
            input_grid[r][c] = random.choice(distract_colors)

    # Ensure there is at least one empty cell (0) so output differs from input
    zeros = sum(1 for r in range(height) for c in range(width) if input_grid[r][c] == 0)
    if zeros == 0:
        # Find a non-hint cell to clear
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] not in (even_color, odd_color):
                    input_grid[r][c] = 0
                    zeros = 1
                    break
            if zeros:
                break

    # Build the output: fill only the background (0) cells according to parity with hint colors
    output_grid = [[0 for _ in range(width)] for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                output_grid[r][c] = even_color if (r + c) % 2 == 0 else odd_color
            else:
                # Preserve original hint and distracting cells exactly
                output_grid[r][c] = input_grid[r][c]

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height else 0

    # Count occurrences of each color on each parity
    counts = {}
    for r in range(height):
        for c in range(width):
            val = grid[r][c]
            if val == 0:
                continue
            parity = (r + c) % 2
            if val not in counts:
                counts[val] = [0, 0]
            counts[val][parity] += 1

    # Find colors that only appear on parity 0 or only on parity 1
    parity_only_0 = [col for col, (c0, c1) in counts.items() if c0 > 0 and c1 == 0]
    parity_only_1 = [col for col, (c0, c1) in counts.items() if c1 > 0 and c0 == 0]

    even_color = None
    odd_color = None

    # Prefer exact parity-only colors (these are the reliable hints)
    if parity_only_0 and parity_only_1:
        # pick the most frequent among the parity-only candidates
        even_color = max(parity_only_0, key=lambda col: counts[col][0])
        odd_color = max(parity_only_1, key=lambda col: counts[col][1])
    else:
        # Fallback: choose the color with the largest presence on each parity
        # (should recover mapping even if one of the hint colors has some occlusion)
        best_even = None
        best_even_count = -1
        best_odd = None
        best_odd_count = -1
        for col, (c0, c1) in counts.items():
            if c0 > best_even_count:
                best_even = col
                best_even_count = c0
            if c1 > best_odd_count:
                best_odd = col
                best_odd_count = c1
        even_color = best_even
        odd_color = best_odd
        # If by bad luck they are the same color, try to pick a different second-best for odd
        if even_color == odd_color:
            second_best_odd = None
            second_best_odd_count = -1
            for col, (c0, c1) in counts.items():
                if col == even_color:
                    continue
                if c1 > second_best_odd_count:
                    second_best_odd = col
                    second_best_odd_count = c1
            if second_best_odd is not None:
                odd_color = second_best_odd
            else:
                # As ultimate fallback pick any different color (should not happen with valid generator)
                for col in counts:
                    if col != even_color:
                        odd_color = col
                        break

    # If we still failed to find a pair (very small edge case), choose two arbitrary colors
    if even_color is None or odd_color is None:
        present = list(counts.keys())
        if len(present) >= 2:
            even_color, odd_color = present[0], present[1]
        elif len(present) == 1:
            # pick any different color from 1..9 as the other
            even_color = present[0]
            odd_color = 1 if even_color != 1 else 2
        else:
            # No non-zero colors present: default to 1/2
            even_color, odd_color = 1, 2

    # Build output: fill zeros according to parity, preserve non-zero cells
    output = [[0 for _ in range(width)] for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0:
                output[r][c] = even_color if (r + c) % 2 == 0 else odd_color
            else:
                output[r][c] = grid[r][c]

    return output

