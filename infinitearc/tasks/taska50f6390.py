# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: a50f6390
Difficulty: insane

=== Tags ===
- State machine grid
- Mirror twins
- Field based motion
- Periodic reflection
- Image filling
- Jigsaw

=== Description ===
Input grids feature a central vertical mirror axis, dividing the grid into left
and right mirror twins (exact color symmetries across the axis, with background
0 cells filling gaps). Each grid contains a direction field embedded as non-
background colors (e.g., color 5 = right, 6 = up, 7 = left, 8 = down), dictating
propagation direction for state transitions. The state machine operates through
a cycle: each cell with a direction field color propagates its current color
(1–9) to adjacent background cells (0) in the field direction, incrementing the
propagating cell's color to the next in the cycle (e.g., 1→2→3→1). Propagation
continues iteratively until no further changes occur. When propagation would
exit the grid, it reflects (reversing direction) and continues bouncing
periodically. Crucially, mirror symmetry must be preserved: any color change on
the left must mirror identically on the right. Background cells fill with
propagated colors, while direction field cells update their state according to
the cycle. The output grid shows the final state after all propagation,
reflection, and symmetry-preserving transitions complete. The "jigsaw" aspect
arises from the grid being composed of mirror-paired regions (jigsaw pieces)
that interact via the direction field, with complex interactions between
reflection patterns and state cycles creating non-linear filling behavior.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(3, 29)
    while width % 2 == 0:
        width = random.randint(3, 29)
    height = random.randint(1, 30)
    
    def mirror_dir(d):
        return 7 if d == 5 else 8 if d == 6 else 5 if d == 7 else 6

    def get_propagated_color(d):
        return (d - 4) % 3 + 1

    def get_direction(d):
        return {
            5: (0, 1),  # right
            6: (-1, 0), # up
            7: (0, -1), # left
            8: (1, 0)   # down
        }[d]

    # Create symmetric grid
    input_grid = grid(width, height, 0)
    
    # Place direction fields and initial colors
    for r in range(height):
        for c in range((width - 1) // 2):
            if random.random() < 0.2:
                d = random.choice([5, 6, 7, 8])
                input_grid[r][c] = d
                input_grid[r][width - 1 - c] = mirror_dir(d)
            elif random.random() < 0.3:
                color = random.randint(1, 4)
                input_grid[r][c] = color
                input_grid[r][width - 1 - c] = color

    # Ensure symmetry
    for r in range(height):
        for c in range((width - 1) // 2):
            mirror_c = width - 1 - c
            input_grid[r][mirror_c] = input_grid[r][c]

    # Simulate propagation
    output_grid = [row[:] for row in input_grid]
    changed = True
    
    while changed:
        changed = False
        current_grid = [row[:] for row in output_grid]
        for r in range(height):
            for c in range(width):
                if current_grid[r][c] in [5, 6, 7, 8]:
                    d = current_grid[r][c]
                    dr, dc = get_direction(d)
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        if current_grid[nr][nc] == 0:
                            propagated_color = get_propagated_color(d)
                            output_grid[nr][nc] = propagated_color
                            changed = True
                            if d == 8:
                                output_grid[r][c] = 5
                            else:
                                output_grid[r][c] = d + 1
    
    # Ensure output differs from input
    if input_grid == output_grid:
        return generate()
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    
    def mirror_dir(d):
        return 7 if d == 5 else 8 if d == 6 else 5 if d == 7 else 6

    def get_propagated_color(d):
        return (d - 4) % 3 + 1

    def get_direction(d):
        return {
            5: (0, 1),
            6: (-1, 0),
            7: (0, -1),
            8: (1, 0)
        }[d]

    changed = True
    while changed:
        changed = False
        current_grid = [row[:] for row in grid]
        for r in range(height):
            for c in range(width):
                if current_grid[r][c] in [5, 6, 7, 8]:
                    d = current_grid[r][c]
                    dr, dc = get_direction(d)
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        if current_grid[nr][nc] == 0:
                            propagated_color = get_propagated_color(d)
                            grid[nr][nc] = propagated_color
                            changed = True
                            if d == 8:
                                grid[r][c] = 5
                            else:
                                grid[r][c] = d + 1
    return grid
