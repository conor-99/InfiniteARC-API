# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: a01576bf
Difficulty: medium

=== Tags ===
- Separate shapes
- Bring patterns close

=== Description ===
The input grid contains two or more distinct shapes (connected regions of the
same color, not adjacent to each other). Each shape is a contiguous group of
pixels sharing the same color, with no shared edges between shapes. The output
grid is generated by moving each shape toward the nearest other shape until they
become adjacent (sharing a common edge with no empty cells between them). The
direction of movement is determined by the shortest path between shapes:
horizontal movement is prioritized if shapes are horizontally separated,
otherwise vertical movement is applied. The transformation reduces the minimal
distance between shapes to zero while preserving all original shape structures
and colors.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, continuous_creature

def generate():
    while True:
        width = random.randint(5, 15)
        height = random.randint(5, 15)
        color1 = random.randint(1, 9)
        color2 = random.randint(1, 9)
        while color2 == color1:
            color2 = random.randint(1, 9)
        grid_in = grid(width, height, 0)
        
        size1 = random.randint(3, 5)
        shape1_pixels = continuous_creature(size1, 3, 3)
        if not shape1_pixels:
            continue  # Ensure shape is non-empty
        for r, c in shape1_pixels:
            if r < height and c < width:
                grid_in[r][c] = color1

        size2 = random.randint(3, 5)
        shape2_pixels = continuous_creature(size2, 3, 3)
        if not shape2_pixels:
            continue  # Ensure shape is non-empty
        offset_x = width - 6
        offset_y = height - 6
        for r, c in shape2_pixels:
            if offset_y + r < height and offset_x + c < width:
                grid_in[offset_y + r][offset_x + c] = color2

        pixels1 = [(r, c) for r in range(height) for c in range(width) if grid_in[r][c] == color1]
        pixels2 = [(r, c) for r in range(height) for c in range(width) if grid_in[r][c] == color2]
        if not pixels1 or not pixels2:
            continue  # Ensure both shapes are placed

        left1 = min(c for r, c in pixels1)
        right1 = max(c for r, c in pixels1)
        left2 = min(c for r, c in pixels2)
        right2 = max(c for r, c in pixels2)
        min_horiz = min(abs(left2 - right1), abs(left1 - right2))
        
        top1 = min(r for r, c in pixels1)
        bottom1 = max(r for r, c in pixels1)
        top2 = min(r for r, c in pixels2)
        bottom2 = max(r for r, c in pixels2)
        min_vert = min(abs(top2 - bottom1), abs(top1 - bottom2))
        
        min_dist = min(min_horiz, min_vert)
        if min_dist >= 3:
            break

    grid_out = [row[:] for row in grid_in]
    if min_horiz <= min_vert:
        if left2 > right1:
            distance = left2 - right1
            k = (distance - 1) // 2
            for r, c in pixels1:
                if c + k < width:
                    grid_out[r][c + k] = color1
                    grid_out[r][c] = 0
            for r, c in pixels2:
                if c - k >= 0:
                    grid_out[r][c - k] = color2
                    grid_out[r][c] = 0
        elif left1 > right2:
            distance = left1 - right2
            k = (distance - 1) // 2
            for r, c in pixels1:
                if c - k >= 0:
                    grid_out[r][c - k] = color1
                    grid_out[r][c] = 0
            for r, c in pixels2:
                if c + k < width:
                    grid_out[r][c + k] = color2
                    grid_out[r][c] = 0
    else:
        if top2 > bottom1:
            distance = top2 - bottom1
            k = (distance - 1) // 2
            for r, c in pixels1:
                if r + k < height:
                    grid_out[r + k][c] = color1
                    grid_out[r][c] = 0
            for r, c in pixels2:
                if r - k >= 0:
                    grid_out[r - k][c] = color2
                    grid_out[r][c] = 0
        elif top1 > bottom2:
            distance = top1 - bottom2
            k = (distance - 1) // 2
            for r, c in pixels1:
                if r - k >= 0:
                    grid_out[r - k][c] = color1
                    grid_out[r][c] = 0
            for r, c in pixels2:
                if r + k < height:
                    grid_out[r + k][c] = color2
                    grid_out[r][c] = 0
    
    return {'input': grid_in, 'output': grid_out}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    colors = set()
    for row in input_grid:
        for cell in row:
            if cell != 0:
                colors.add(cell)
    colors = list(colors)
    color1, color2 = colors[0], colors[1]
    
    pixels1 = [(r, c) for r in range(len(input_grid)) for c in range(len(input_grid[0])) if input_grid[r][c] == color1]
    pixels2 = [(r, c) for r in range(len(input_grid)) for c in range(len(input_grid[0])) if input_grid[r][c] == color2]
    
    if not pixels1 or not pixels2:
        return input_grid

    left1 = min(c for r, c in pixels1)
    right1 = max(c for r, c in pixels1)
    left2 = min(c for r, c in pixels2)
    right2 = max(c for r, c in pixels2)
    min_horiz = min(abs(left2 - right1), abs(left1 - right2))
    
    top1 = min(r for r, c in pixels1)
    bottom1 = max(r for r, c in pixels1)
    top2 = min(r for r, c in pixels2)
    bottom2 = max(r for r, c in pixels2)
    min_vert = min(abs(top2 - bottom1), abs(top1 - bottom2))
    
    min_dist = min(min_horiz, min_vert)
    if min_dist < 3:
        return input_grid

    output_grid = [row[:] for row in input_grid]
    if min_horiz <= min_vert:
        if left2 > right1:
            distance = left2 - right1
            k = (distance - 1) // 2
            for r, c in pixels1:
                if c + k < len(output_grid[0]):
                    output_grid[r][c + k] = color1
                    output_grid[r][c] = 0
            for r, c in pixels2:
                if c - k >= 0:
                    output_grid[r][c - k] = color2
                    output_grid[r][c] = 0
        elif left1 > right2:
            distance = left1 - right2
            k = (distance - 1) // 2
            for r, c in pixels1:
                if c - k >= 0:
                    output_grid[r][c - k] = color1
                    output_grid[r][c] = 0
            for r, c in pixels2:
                if c + k < len(output_grid[0]):
                    output_grid[r][c + k] = color2
                    output_grid[r][c] = 0
    else:
        if top2 > bottom1:
            distance = top2 - bottom1
            k = (distance - 1) // 2
            for r, c in pixels1:
                if r + k < len(output_grid):
                    output_grid[r + k][c] = color1
                    output_grid[r][c] = 0
            for r, c in pixels2:
                if r - k >= 0:
                    output_grid[r - k][c] = color2
                    output_grid[r][c] = 0
        elif top1 > bottom2:
            distance = top1 - bottom2
            k = (distance - 1) // 2
            for r, c in pixels1:
                if r - k >= 0:
                    output_grid[r - k][c] = color1
                    output_grid[r][c] = 0
            for r, c in pixels2:
                if r + k < len(output_grid):
                    output_grid[r + k][c] = color2
                    output_grid[r][c] = 0
    return output_grid
