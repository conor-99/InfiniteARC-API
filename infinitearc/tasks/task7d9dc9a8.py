# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 7d9dc9a8
Difficulty: very hard

=== Tags ===
- Rule composition
- Conditional draw
- Bridge gaps

=== Description ===
**Task Name: Structural Bridges**  **Description:**  Input grids feature a
background color (0) and multiple disconnected regions, each a contiguous area
of a single non-background color (1-9). Regions are separated by background gaps
and never touch. The output grid must connect all horizontally or vertically
aligned region pairs with bridges, following these rules:  1. **Bridge
Alignment**: Bridges are drawn as straight lines (horizontal or vertical)
through background gaps between regions that share a row (horizontal bridge) or
column (vertical bridge). Non-aligned region pairs are ignored.  2. **Bridge
Color Composition**: For regions of identical color, the bridge uses that color.
For regions of differing colors, the bridge alternates between the two colors,
starting with the leftmost region for horizontal bridges or the topmost region
for vertical bridges (e.g., left region color first for horizontal bridges, top
region color first for vertical bridges).  3. **Bridge Integrity**: Bridges
replace only background cells (never existing regions, other bridges, or the
background). Inputs are generated to ensure all bridges are non-overlapping,
with no gaps between regions requiring bridges to intersect.  The output grid
contains all valid bridges, with no additional modifications to the input grid.
The task requires simultaneous application of spatial alignment checks, color-
based conditional logic, and gap-filling rules to reconstruct the bridged
structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    # Create a moderately sized grid with room for several regions and bridges
    for attempt in range(200):
        width = random.randint(12, 20)
        height = random.randint(12, 20)
        input_grid = [[0] * width for _ in range(height)]
        regions = []  # list of (color, pixels)

        # Choose whether this example will have horizontal or vertical bridges
        orientation = random.choice(["horizontal", "vertical"])  # single orientation avoids bridge intersections

        used_cols = set()
        used_rows = set()
        valid = True

        if orientation == "horizontal":
            # number of pairs (each pair produces two regions that will be bridged horizontally)
            max_pairs = max(1, min(4, (height - 4) // 2))
            pair_count = random.randint(2, max_pairs) if max_pairs >= 2 else 1

            # Choose rows for the pairs, spaced so that regions don't touch vertically
            start_row = random.randint(2, height - 2 - 2 * (pair_count - 1))
            rows = [start_row + 2 * i for i in range(pair_count)]

            for r in rows:
                # ensure chosen row doesn't collide with other used rows
                if r in used_rows:
                    valid = False
                    break
                # widths of the left and right blocks
                w1 = random.randint(1, 3)
                w2 = random.randint(1, 3)

                # place right block near the right side with a small random offset
                right_start = width - (3 + w2) - random.randint(0, 2)
                if right_start <= 1:
                    valid = False
                    break

                # left block must fit to the left of the right block with at least one-column gap
                left_start_max = right_start - w1 - 2
                if left_start_max < 1:
                    valid = False
                    break

                # choose left_start avoiding used columns
                picks = []
                for ls in range(1, left_start_max + 1):
                    left_cols = set(range(ls, ls + w1))
                    right_cols = set(range(right_start, right_start + w2))
                    if left_cols & used_cols:
                        continue
                    if right_cols & used_cols:
                        # if right overlaps used, try shifting right a bit leftwards
                        continue
                    picks.append(ls)
                if not picks:
                    valid = False
                    break
                left_start = random.choice(picks)

                left_color = random.randint(1, 9)
                right_color = random.randint(1, 9)

                # Place left block (height 1)
                left_pixels = []
                for c in range(left_start, left_start + w1):
                    if input_grid[r][c] != 0:
                        valid = False
                        break
                    input_grid[r][c] = left_color
                    left_pixels.append((r, c))
                    used_cols.add(c)
                if not valid:
                    break

                # Place right block (height 1)
                right_pixels = []
                for c in range(right_start, right_start + w2):
                    if input_grid[r][c] != 0:
                        valid = False
                        break
                    input_grid[r][c] = right_color
                    right_pixels.append((r, c))
                    used_cols.add(c)
                if not valid:
                    break

                used_rows.add(r)
                regions.append((left_color, left_pixels))
                regions.append((right_color, right_pixels))

        else:  # vertical orientation
            max_pairs = max(1, min(4, (width - 4) // 2))
            pair_count = random.randint(2, max_pairs) if max_pairs >= 2 else 1

            start_col = random.randint(2, width - 2 - 2 * (pair_count - 1))
            cols = [start_col + 2 * i for i in range(pair_count)]

            for c in cols:
                if c in used_cols:
                    valid = False
                    break

                h1 = random.randint(1, 3)
                h2 = random.randint(1, 3)

                bottom_start = height - (3 + h2) - random.randint(0, 2)
                if bottom_start <= 1:
                    valid = False
                    break

                top_start_max = bottom_start - h1 - 2
                if top_start_max < 1:
                    valid = False
                    break

                # choose top_start avoiding used rows
                picks = []
                for ts in range(1, top_start_max + 1):
                    top_rows = set(range(ts, ts + h1))
                    bottom_rows = set(range(bottom_start, bottom_start + h2))
                    if top_rows & used_rows:
                        continue
                    if bottom_rows & used_rows:
                        continue
                    picks.append(ts)
                if not picks:
                    valid = False
                    break
                top_start = random.choice(picks)

                top_color = random.randint(1, 9)
                bottom_color = random.randint(1, 9)

                top_pixels = []
                for r in range(top_start, top_start + h1):
                    if input_grid[r][c] != 0:
                        valid = False
                        break
                    input_grid[r][c] = top_color
                    top_pixels.append((r, c))
                    used_rows.add(r)
                if not valid:
                    break

                bottom_pixels = []
                for r in range(bottom_start, bottom_start + h2):
                    if input_grid[r][c] != 0:
                        valid = False
                        break
                    input_grid[r][c] = bottom_color
                    bottom_pixels.append((r, c))
                    used_rows.add(r)
                if not valid:
                    break

                used_cols.add(c)
                regions.append((top_color, top_pixels))
                regions.append((bottom_color, bottom_pixels))

        if not valid:
            continue

        # Build the output by drawing bridges only on background cells
        output_grid = [row[:] for row in input_grid]

        if orientation == "horizontal":
            # For each placed pair (left,right) in order
            for i in range(0, len(regions), 2):
                color1, pixels1 = regions[i]
                color2, pixels2 = regions[i + 1]
                # They share a single row
                r = pixels1[0][0]
                cols1 = [c for rr, c in pixels1 if rr == r]
                cols2 = [c for rr, c in pixels2 if rr == r]
                min_col1, max_col1 = min(cols1), max(cols1)
                min_col2, max_col2 = min(cols2), max(cols2)
                # identify left and right
                if max_col1 < min_col2:
                    left_color, right_color = color1, color2
                    gap_start, gap_end = max_col1 + 1, min_col2 - 1
                elif max_col2 < min_col1:
                    left_color, right_color = color2, color1
                    gap_start, gap_end = max_col2 + 1, min_col1 - 1
                else:
                    continue
                if gap_start > gap_end:
                    continue
                if left_color == right_color:
                    for c in range(gap_start, gap_end + 1):
                        if input_grid[r][c] == 0:
                            output_grid[r][c] = left_color
                else:
                    for idx, c in enumerate(range(gap_start, gap_end + 1)):
                        if input_grid[r][c] == 0:
                            output_grid[r][c] = left_color if idx % 2 == 0 else right_color

        else:  # vertical
            for i in range(0, len(regions), 2):
                color1, pixels1 = regions[i]
                color2, pixels2 = regions[i + 1]
                c = pixels1[0][1]
                rows1 = [r for r, cc in pixels1 if cc == c]
                rows2 = [r for r, cc in pixels2 if cc == c]
                min_row1, max_row1 = min(rows1), max(rows1)
                min_row2, max_row2 = min(rows2), max(rows2)
                if max_row1 < min_row2:
                    top_color, bottom_color = color1, color2
                    gap_start, gap_end = max_row1 + 1, min_row2 - 1
                elif max_row2 < min_row1:
                    top_color, bottom_color = color2, color1
                    gap_start, gap_end = max_row2 + 1, min_row1 - 1
                else:
                    continue
                if gap_start > gap_end:
                    continue
                if top_color == bottom_color:
                    for r in range(gap_start, gap_end + 1):
                        if input_grid[r][c] == 0:
                            output_grid[r][c] = top_color
                else:
                    for idx, r in enumerate(range(gap_start, gap_end + 1)):
                        if input_grid[r][c] == 0:
                            output_grid[r][c] = top_color if idx % 2 == 0 else bottom_color

        if input_grid == output_grid:
            # No bridge was drawn; try again
            continue

        return {"input": input_grid, "output": output_grid}

    # Fallback deterministic example
    input_grid = [[0]*12 for _ in range(12)]
    input_grid[2][2] = 3
    input_grid[2][8] = 5
    output_grid = [row[:] for row in input_grid]
    for c in range(3, 8):
        output_grid[2][c] = 3 if (c-3) % 2 == 0 else 5
    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # Find connected regions (4-neighborhood) of non-zero colors
    visited = [[False] * width for _ in range(height)]
    regions = []  # list of tuples (color, pixels_list)
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and not visited[r][c]:
                color = grid[r][c]
                stack = [(r, c)]
                visited[r][c] = True
                pixels = []
                while stack:
                    cr, cc = stack.pop()
                    pixels.append((cr, cc))
                    for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                regions.append((color, pixels))

    output = [row[:] for row in grid]

    # For every pair of regions, see if they share a row (horizontal bridge) or a column (vertical bridge)
    for i in range(len(regions)):
        for j in range(i+1, len(regions)):
            color1, pixels1 = regions[i]
            color2, pixels2 = regions[j]

            # Horizontal check: do they share a row?
            rows1 = set(r for r, cc in pixels1)
            rows2 = set(r for r, cc in pixels2)
            overlap_rows = rows1 & rows2
            for r in overlap_rows:
                cols1 = [c for rr, c in pixels1 if rr == r]
                cols2 = [c for rr, c in pixels2 if rr == r]
                if not cols1 or not cols2:
                    continue
                min_col1, max_col1 = min(cols1), max(cols1)
                min_col2, max_col2 = min(cols2), max(cols2)
                # determine left and right
                if max_col1 < min_col2:
                    left_color, right_color = color1, color2
                    gap_start, gap_end = max_col1 + 1, min_col2 - 1
                elif max_col2 < min_col1:
                    left_color, right_color = color2, color1
                    gap_start, gap_end = max_col2 + 1, min_col1 - 1
                else:
                    continue
                if gap_start > gap_end:
                    continue
                if left_color == right_color:
                    for c in range(gap_start, gap_end + 1):
                        if grid[r][c] == 0:
                            output[r][c] = left_color
                else:
                    for idx, c in enumerate(range(gap_start, gap_end + 1)):
                        if grid[r][c] == 0:
                            output[r][c] = left_color if idx % 2 == 0 else right_color

            # Vertical check: do they share a column?
            cols1 = set(c for r, c in pixels1)
            cols2 = set(c for r, c in pixels2)
            overlap_cols = cols1 & cols2
            for c in overlap_cols:
                rows1 = [r for r, cc in pixels1 if cc == c]
                rows2 = [r for r, cc in pixels2 if cc == c]
                if not rows1 or not rows2:
                    continue
                min_row1, max_row1 = min(rows1), max(rows1)
                min_row2, max_row2 = min(rows2), max(rows2)
                if max_row1 < min_row2:
                    top_color, bottom_color = color1, color2
                    gap_start, gap_end = max_row1 + 1, min_row2 - 1
                elif max_row2 < min_row1:
                    top_color, bottom_color = color2, color1
                    gap_start, gap_end = max_row2 + 1, min_row1 - 1
                else:
                    continue
                if gap_start > gap_end:
                    continue
                if top_color == bottom_color:
                    for r in range(gap_start, gap_end + 1):
                        if grid[r][c] == 0:
                            output[r][c] = top_color
                else:
                    for idx, r in enumerate(range(gap_start, gap_end + 1)):
                        if grid[r][c] == 0:
                            output[r][c] = top_color if idx % 2 == 0 else bottom_color

    return output

