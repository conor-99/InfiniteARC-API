# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 8ca9072a
Difficulty: hard

=== Tags ===
- Meta rule switching

=== Description ===
Input grids contain a background of color 0 with multiple non-background regions
(each region is a connected group of cells of a single non-zero color). The
presence of any region colored 8 determines the transformation rule for all
other regions: if color 8 regions exist, each non-8 region is rotated 90 degrees
clockwise; otherwise, each non-background region is reflected vertically. The
color 8 regions remain unchanged. The output grid must apply this rule
consistently, maintaining all colors and ensuring regions are correctly
transformed without overlapping. Regions must retain their original color during
transformation, and background cells remain color 0. The transformation rule
dynamically switches based on the input grid's content, requiring the solver to
first identify the presence of color 8 regions before applying the corresponding
geometric transformation to all other regions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

# Generator for ARC task 425: region-wise geometric transform switching
# - If any region of color 8 exists (color8_present True), every non-8 pixel
#   is rotated 90 degrees clockwise about the whole grid: (r,c) -> (c, H-1-r).
#   Color-8 pixels remain at their original coordinates.
# - Otherwise (no color 8), every non-background pixel is reflected vertically:
#   (r,c) -> (H-1-r, c).
# The generator ensures all non-background regions are connected and that
# transformed non-8 pixels never collide with preserved 8 pixels.


def _place_connected_shape(grid, coords, color):
    # Fill given coordinates with the color (assumed connected)
    for (r, c) in coords:
        grid[r][c] = color


def _rect_coords(r0, c0, rh, rw):
    return [(r, c) for r in range(r0, r0 + rh) for c in range(c0, c0 + rw)]


def generate():
    # Try multiple attempts in case of collision or unlucky packing
    for attempt in range(1000):
        # Decide whether an 8 region is present
        color8_present = random.choice([True, False])

        # If rotation will be used we restrict to square grids so rotation maps
        # coordinates inside the same grid (r,c) -> (c, H-1-r).
        if color8_present:
            size = random.randint(3, 12)
            width = height = size
        else:
            width = random.randint(3, 14)
            height = random.randint(3, 14)

        # Initialize input grid
        inp = common.grid(width, height, 0)
        reserved = set()  # cells already occupied in input

        # Construct an 8-region if needed (connected small shape)
        set8 = set()
        if color8_present:
            # Choose a small connected shape for the 8-region
            shape = random.choice(['single', 'line', 'rect', 'L', 'plus'])
            if shape == 'single':
                r = random.randrange(height); c = random.randrange(width)
                set8.add((r, c))
            elif shape == 'line':
                dir = random.choice(['h', 'v'])
                if dir == 'h':
                    r = random.randrange(height)
                    length = random.randint(1, max(1, min(5, width)))
                    c0 = random.randrange(width - length + 1)
                    for c in range(c0, c0 + length): set8.add((r, c))
                else:
                    c = random.randrange(width)
                    length = random.randint(1, max(1, min(5, height)))
                    r0 = random.randrange(height - length + 1)
                    for r in range(r0, r0 + length): set8.add((r, c))
            elif shape == 'rect':
                rw = random.randint(1, min(4, width))
                rh = random.randint(1, min(4, height))
                r0 = random.randrange(0, height - rh + 1)
                c0 = random.randrange(0, width - rw + 1)
                for r in range(r0, r0 + rh):
                    for c in range(c0, c0 + rw): set8.add((r, c))
            elif shape == 'L':
                # 3x3 L-shape (clipped if near edges)
                if height < 3 or width < 3:
                    r = random.randrange(height); c = random.randrange(width)
                    set8.add((r, c))
                else:
                    r0 = random.randrange(0, height - 2)
                    c0 = random.randrange(0, width - 2)
                    for dr in range(3): set8.add((r0 + dr, c0))
                    for dc in range(3): set8.add((r0 + 2, c0 + dc))
            else:  # plus
                if height < 3 or width < 3:
                    r = random.randrange(height); c = random.randrange(width)
                    set8.add((r, c))
                else:
                    r = random.randrange(1, height - 1); c = random.randrange(1, width - 1)
                    set8.add((r, c))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]: set8.add((r + dr, c + dc))

            # Mark 8s on input and reserved set
            for (r, c) in set8:
                inp[r][c] = 8
                reserved.add((r, c))

        # Choose some non-8 colors (at least one)
        colors_pool = [1, 2, 3, 4, 5, 6, 7, 9]
        num_colors = random.randint(1, min(4, len(colors_pool)))
        chosen_colors = random.sample(colors_pool, num_colors)

        # Place one small connected rectangle per color ensuring no input overlap
        # and (when 8 exists) no rotated target hits an 8 cell.
        placement_ok = True
        for color in chosen_colors:
            placed = False
            for try_rect in range(200):
                rw = random.randint(1, min(5, width))
                rh = random.randint(1, min(5, height))
                r0 = random.randint(0, height - rh)
                c0 = random.randint(0, width - rw)
                coords = _rect_coords(r0, c0, rh, rw)
                # do not overlap existing input cells
                if any((r, c) in reserved for (r, c) in coords):
                    continue
                # if 8-region exists, ensure no rotated target of these coords is an 8 cell
                if color8_present:
                    conflict = False
                    for (r, c) in coords:
                        tr = c
                        tc = height - 1 - r
                        if (tr, tc) in set8:
                            conflict = True
                            break
                    if conflict:
                        continue
                # place rectangle
                _place_connected_shape(inp, coords, color)
                for (r, c) in coords: reserved.add((r, c))
                placed = True
                break
            if not placed:
                placement_ok = False
                break

        if not placement_ok:
            continue

        # Build output according to the rule and check that no collisions occur
        out = common.grid(width, height, 0)

        if color8_present:
            # copy 8s unchanged
            for (r, c) in set8:
                out[r][c] = 8
            # rotate all other non-zero (non-8) pixels 90deg clockwise
            collision = False
            for r in range(height):
                for c in range(width):
                    v = inp[r][c]
                    if v != 0 and v != 8:
                        nr = c
                        nc = height - 1 - r
                        # check bounds (should hold because grid is square) and collision
                        if not (0 <= nr < height and 0 <= nc < width):
                            collision = True
                            break
                        if out[nr][nc] != 0:
                            collision = True
                            break
                        out[nr][nc] = v
                if collision:
                    break
            if collision:
                continue
        else:
            # reflect vertically (top<->bottom) every non-background region
            for r in range(height):
                for c in range(width):
                    v = inp[r][c]
                    if v != 0:
                        nr = height - 1 - r
                        nc = c
                        out[nr][nc] = v

        # Ensure transformation actually changed the grid
        if inp == out:
            continue

        # Final sanity: all values are in 0..9 and sizes are valid (they are)
        return {"input": inp, "output": out}

    raise RuntimeError('Could not generate a valid example')



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert tuple-of-tuples to list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height else 0

    # Detect presence of any color-8 region
    color8_present = False
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 8:
                color8_present = True
                break
        if color8_present:
            break

    # Prepare empty output
    out = [[0] * width for _ in range(height)]

    if color8_present:
        # Copy 8s in place
        for r in range(height):
            for c in range(width):
                if grid[r][c] == 8:
                    out[r][c] = 8
        # Rotate every other non-zero pixel 90 degrees clockwise: (r,c) -> (c, H-1-r)
        # Generator ensures the grid is square when 8 is present, but we keep bounds checks.
        for r in range(height):
            for c in range(width):
                v = grid[r][c]
                if v != 0 and v != 8:
                    nr = c
                    nc = height - 1 - r
                    if 0 <= nr < height and 0 <= nc < width:
                        out[nr][nc] = v
        return out

    else:
        # Reflect vertically (top-bottom) every non-background pixel: (r,c) -> (H-1-r, c)
        for r in range(height):
            for c in range(width):
                v = grid[r][c]
                if v != 0:
                    nr = height - 1 - r
                    nc = c
                    out[nr][nc] = v
        return out

