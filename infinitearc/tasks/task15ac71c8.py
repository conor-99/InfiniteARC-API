# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 15ac71c8
Difficulty: mediumâ€“hard

=== Tags ===
- Deterministic reflection
- Momentum transfer
- Connect all dots of same color

=== Description ===
# Reflective Path Network  Input grids consist of a background (color 0), walls
(color 1 arranged as contiguous horizontal or vertical lines), and colored dots
(colors 2-9 with multiple dots sharing the same color). Walls are placed as
straight lines without touching each other or dots. For each color C (2-9), all
dots of color C must be connected into a single continuous path. The path begins
at the topmost-leftmost dot of color C and initially moves diagonally northeast
(up-right). As it moves, if it encounters a wall (color 1), it reflects with
perfect mirror symmetry: hitting a vertical wall reverses horizontal movement
(left/right), while hitting a horizontal wall reverses vertical movement
(up/down). The path continues reflecting until all dots of the same color are
connected in sequence. The output grid displays the path using a new distinct
color (e.g., color 4) that does not appear in the input, while preserving all
input elements. Paths are drawn without intersecting walls, other paths, or
dots, and every dot of the same color is connected in a single continuous route.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Generator for ARC task 419: Reflective Path Network

def generate():
    # Keep trying until a valid configuration is made
    for attempt in range(200):
        width = random.randint(10, 16)
        height = random.randint(10, 16)
        inp = grid(width, height, 0)

        reserved_walls = set()
        reserved_paths = set()  # all cells that will be used by any path (including dots)
        reserved_dots = set()

        # choose number of distinct dot colors (2..4)
        num_colors = random.randint(2, 4)
        dot_colors = random.sample(list(range(2, 10)), num_colors)

        # choose a path color that is NOT used by any input dot color
        path_candidates = [c for c in range(2, 10) if c not in dot_colors]
        if not path_candidates:
            continue
        # choose deterministically so solver can reproduce it
        path_color = min(path_candidates)

        placements = {}  # store for each color: {'dots': [], 'path': [], 'walls': []}

        failed = False

        def in_bounds(r, c):
            return 0 <= r < height and 0 <= c < width

        def neighbors4(r, c):
            for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                yield (r + dr, c + dc)

        # try to place non-overlapping reflective diagonal paths for each color
        for color in dot_colors:
            placed = False
            for t in range(250):
                # number of dots for this color
                k = random.randint(2, 4)
                # choose a path length L such that there's room to space dots with gaps
                min_L = max(3, 2 * k)
                max_L = min(width, height) - 1
                if max_L <= min_L:
                    L = min_L
                else:
                    L = random.randint(min_L, max_L)

                # Start point must allow a small horizontal wall above its NE cell
                # so require start_row >= 1 and start_col <= width - L - 2
                if height - L - 1 < 1 or width - L - 2 < 0:
                    continue

                s_row = random.randint(1, height - L - 1)
                s_col = random.randint(0, width - L - 2)

                # path coordinates after the initial reflection will be a SE diagonal: s, s+(1,1), ... s+(L-1,L-1)
                path_coords = [(s_row + i, s_col + i) for i in range(L)]

                # initial horizontal wall cells (two cells) placed at the NE landing spot to reflect NE -> SE
                wall_cells = [(s_row - 1, s_col + 1), (s_row - 1, s_col + 2)]

                # Ensure all planned coordinates are in bounds
                if any(not in_bounds(r, c) for (r, c) in path_coords + wall_cells):
                    continue

                # Ensure wall cells do not touch existing walls or dots (4-neighbor) and do not overlap reserved paths
                bad = False
                for (wr, wc) in wall_cells:
                    if (wr, wc) in reserved_walls or (wr, wc) in reserved_paths or (wr, wc) in reserved_dots:
                        bad = True
                        break
                    for nb in neighbors4(wr, wc):
                        if nb in reserved_walls or nb in reserved_dots:
                            bad = True
                            break
                    if bad:
                        break

                if bad:
                    continue

                # Ensure path coordinates don't collide with existing reserved path/wall/dot cells
                collision = False
                for (pr, pc) in path_coords:
                    if (pr, pc) in reserved_paths or (pr, pc) in reserved_walls:
                        collision = True
                        break
                if collision:
                    continue

                # Choose k dot indices along this path. Ensure first index is 0 (start is a dot),
                # and ensure there is at least one empty cell between consecutive dots so a visible path segment exists.
                if L < 2 * k:
                    continue
                # pick indices with spacing >=2
                possible_indices = list(range(1, L))
                # pick k-1 additional indices
                chosen_tail = sorted(random.sample(possible_indices, k - 1))
                # enforce spacing >=2 by rejecting choices that are too close
                ok_indices = True
                indices = [0] + chosen_tail
                for a, b in zip(indices, indices[1:]):
                    if b - a < 2:
                        ok_indices = False
                        break
                if not ok_indices:
                    continue

                dot_positions = [path_coords[i] for i in indices]

                # Ensure dot positions do not touch existing walls (4-neighbor) and are free
                touch_bad = False
                for (dr0, dc0) in dot_positions:
                    if (dr0, dc0) in reserved_dots or (dr0, dc0) in reserved_walls or (dr0, dc0) in reserved_paths:
                        touch_bad = True
                        break
                    for nb in neighbors4(dr0, dc0):
                        if nb in reserved_walls:
                            touch_bad = True
                            break
                    if touch_bad:
                        break
                if touch_bad:
                    continue

                # Everything looks good for this color; reserve cells
                for wc in wall_cells:
                    reserved_walls.add(wc)
                for pc in path_coords:
                    reserved_paths.add(pc)
                for dp in dot_positions:
                    reserved_dots.add(dp)

                placements[color] = {"dots": dot_positions, "path": path_coords, "walls": wall_cells}
                placed = True
                break

            if not placed:
                failed = True
                break

        if failed or len(placements) != len(dot_colors):
            # try a new grid
            continue

        # Now write walls and dots into the input grid
        for (wr, wc) in reserved_walls:
            inp[wr][wc] = 1
        for color, info in placements.items():
            for (r, c) in info["dots"]:
                inp[r][c] = color

        # Create output grid and draw paths by simulating the reflective movement between sorted dots
        out = [row[:] for row in inp]

        # helper sets for walls
        walls = set(reserved_walls)

        def in_bounds(r, c):
            return 0 <= r < height and 0 <= c < width

        def wall_orientation(r, c):
            # Determine whether the wall cell at (r,c) is part of a vertical or horizontal segment
            if (r - 1, c) in walls or (r + 1, c) in walls:
                return 'vertical'
            if (r, c - 1) in walls or (r, c + 1) in walls:
                return 'horizontal'
            return 'horizontal'

        drawn_any = False
        for color, info in placements.items():
            sorted_dots = sorted(info['dots'], key=lambda x: (x[0], x[1]))
            current = sorted_dots[0]
            dr, dc = -1, 1
            for target in sorted_dots[1:]:
                safety = 0
                while current != target and safety < 10000:
                    safety += 1
                    nr, nc = current[0] + dr, current[1] + dc
                    if not in_bounds(nr, nc):
                        break
                    if (nr, nc) in walls:
                        orient = wall_orientation(nr, nc)
                        if orient == 'vertical':
                            dc = -dc
                        else:
                            dr = -dr
                        continue
                    if inp[nr][nc] == 0:
                        out[nr][nc] = path_color
                        drawn_any = True
                    current = (nr, nc)

        if not drawn_any:
            continue

        return {"input": inp, "output": out}

    # Fallback
    width, height = 12, 12
    inp = grid(width, height, 0)
    inp[2][4] = 1
    inp[2][5] = 1
    inp[4][1] = 2
    inp[6][3] = 2
    out = [row[:] for row in inp]
    out[5][2] = 4
    return {"input": inp, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])

    # Copy for output
    out = [row[:] for row in grid_in]

    # Identify all dots (colors 2-9) and their positions
    dots = {}
    for r in range(height):
        for c in range(width):
            v = grid_in[r][c]
            if 2 <= v <= 9 and v != 1:
                dots.setdefault(v, []).append((r, c))

    # Choose a path color not present in the input (2..9)
    used = set(dots.keys())
    path_color = None
    for cand in range(2, 10):
        if cand not in used:
            path_color = cand
            break
    if path_color is None:
        path_color = 4  # fallback (unlikely)

    # Collect wall cells
    walls = set()
    for r in range(height):
        for c in range(width):
            if grid_in[r][c] == 1:
                walls.add((r, c))

    def in_bounds(r, c):
        return 0 <= r < height and 0 <= c < width

    def wall_orientation(r, c):
        # Determine whether the wall cell at (r,c) is part of a vertical or horizontal segment
        # If it has a vertical neighbor, it's vertical; if horizontal neighbor, horizontal.
        if (r - 1, c) in walls or (r + 1, c) in walls:
            return 'vertical'
        if (r, c - 1) in walls or (r, c + 1) in walls:
            return 'horizontal'
        # default to horizontal if isolated
        return 'horizontal'

    # Simulate each color's path
    for color, positions in dots.items():
        if len(positions) < 2:
            continue
        # Path begins at the topmost-leftmost dot
        sorted_dots = sorted(positions, key=lambda x: (x[0], x[1]))
        current = sorted_dots[0]
        dr, dc = -1, 1  # initial NE

        for i in range(1, len(sorted_dots)):
            target = sorted_dots[i]
            # walk until we reach the target
            steps = 0
            while current != target and steps < 10000:
                steps += 1
                nr, nc = current[0] + dr, current[1] + dc
                if not in_bounds(nr, nc):
                    # Out of bounds should not happen for valid puzzles; stop to avoid infinite loop
                    break
                if (nr, nc) in walls:
                    orient = wall_orientation(nr, nc)
                    if orient == 'vertical':
                        # hitting a vertical wall reverses horizontal movement
                        dc = -dc
                    else:
                        # hitting a horizontal wall reverses vertical movement
                        dr = -dr
                    # do not step into the wall; just change direction
                    continue
                # If it's a dot of a different color (not the current target), do not overwrite; still step
                if grid_in[nr][nc] == 0:
                    out[nr][nc] = path_color
                current = (nr, nc)
            # Move on to next dot
    return out

