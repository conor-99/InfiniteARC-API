# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 92e4c1ce
Difficulty: medium–hard

=== Tags ===
- Contextual rule switch
- Cyclic coloring
- Inside out

=== Description ===
Input grids feature concentric rectangular frames centered on the grid's origin,
each frame separated by a single background cell (value 0). The frames form a
nested hierarchy where each frame's border color (1-9) is distinct, with the
innermost frame occupying the smallest central region (e.g., 1x1, 3x3, or 5x5).
The center cell (or central 2x2 area for even-sized grids) contains a color that
determines a contextual rule switch: if the center color is even (2,4,6,8), all
frame colors cycle forward (1→2, 2→3, ..., 9→1); if odd (1,3,5,7,9), colors
cycle backward (1→9, 2→1, ..., 9→8). The transformation then reverses the frame
order (innermost becomes outermost, outermost becomes innermost) while applying
the cyclic shift to each frame's color. The background spacing between frames
remains unchanged, and no frames overlap or overwrite existing elements. The
output grid maintains the same dimensions as the input, with all frames
repositioned concentrically according to the reversed hierarchy and shifted
colors.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    size = random.randint(3, 17)
    if size % 2 == 0:
        size += 1
    k = (size + 1) // 2

    colors = random.sample(range(1, 10), k)
    input_colors = colors
    center_color = input_colors[-1]

    def shift_color(c):
        if center_color % 2 == 0:
            return (c % 9) + 1
        else:
            return (c - 2) % 9 + 1

    shifted_colors = [shift_color(c) for c in input_colors]
    output_colors = shifted_colors[::-1]

    input_grid = [[0] * size for _ in range(size)]
    for d in range(k):
        c = input_colors[d]
        for j in range(d, size - d):
            input_grid[d][j] = c
            input_grid[size - d - 1][j] = c
        for i in range(d + 1, size - d - 1):
            input_grid[i][d] = c
            input_grid[i][size - d - 1] = c

    output_grid = [[0] * size for _ in range(size)]
    for d in range(k):
        c = output_colors[d]
        for j in range(d, size - d):
            output_grid[d][j] = c
            output_grid[size - d - 1][j] = c
        for i in range(d + 1, size - d - 1):
            output_grid[i][d] = c
            output_grid[i][size - d - 1] = c

    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    N = len(grid)
    k = (N + 1) // 2

    frame_colors = [grid[d][d] for d in range(k)]
    center_color = frame_colors[-1]

    def shift_color(c):
        if center_color % 2 == 0:
            return (c % 9) + 1
        else:
            return (c - 2) % 9 + 1

    shifted_colors = [shift_color(c) for c in frame_colors]
    output_frame_colors = shifted_colors[::-1]

    output_grid = [[0] * N for _ in range(N)]
    for d in range(k):
        c = output_frame_colors[d]
        for j in range(d, N - d):
            output_grid[d][j] = c
            output_grid[N - d - 1][j] = c
        for i in range(d + 1, N - d - 1):
            output_grid[i][d] = c
            output_grid[i][N - d - 1] = c

    return output_grid
