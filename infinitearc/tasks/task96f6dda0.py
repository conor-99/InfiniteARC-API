# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 96f6dda0
Difficulty: very hard

=== Tags ===
- Dynamic environment
- Rule gate simulation

=== Description ===
Rule Gate Network  Input grids feature a complex, interconnected network of
colored "gate" cells (1–9) embedded within a uniform background (0), arranged to
form a dynamic rule-processing system. Each gate's position, adjacency to other
gates, and surrounding structural patterns encode a unique transformation rule.
The background remains unchanged throughout.   The transformation rules are
spatially derived from the grid's visual structure rather than numerical
properties. For instance, gates positioned along the grid's diagonal may rotate
adjacent patterns, while gates adjacent to three or more gates of a specific
color may invert colors within a bounded region. The rules require identifying
consistent spatial relationships (e.g., "gates forming a triangle pattern always
shift the enclosed region rightward") through visual pattern recognition.  The
output grid is generated by sequentially applying all gate rules in an order
determined by the network's hierarchy (e.g., outermost gates first, progressing
inward). Each gate's transformation modifies the grid state before subsequent
gates are processed, creating a cascade of dependencies. Conflicts where
multiple gates affect the same cell are resolved by prioritizing the gate
applied earlier in the sequence.   This task demands hierarchical reasoning to
deduce rules from visual patterns, determine the correct processing order
through structural analysis, and resolve overlapping transformations. The
dynamic nature arises from the interdependence of gate applications, where the
effect of one gate alters the input for subsequent gates. The grid size (20×20)
and high density of gates (15–20 distinct colors) create significant complexity,
requiring multi-step inference to uncover the underlying rule system.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    size = 20
    max_attempts = 500
    # Keep trying until we produce an input != output (rarely there may be collisions)
    while True:
        inp = grid(size, size, 0)
        # Pool of colors available for gates/markers (1..9)
        colors_pool = list(range(1, 10))
        random.shuffle(colors_pool)

        clusters = []
        # Number of gate clusters (3..5) to keep complexity manageable but variable
        num_clusters = random.randint(3, 5)
        attempts = 0

        # Place clusters: triangles (L-shape of 3 cells), horizontal lines, vertical lines
        while len(clusters) < num_clusters and attempts < max_attempts and colors_pool:
            attempts += 1
            shape = random.choice(['triangle', 'h', 'v'])
            color = random.choice(colors_pool)  # pick a color but only remove it after successful placement

            cells = []
            if shape == 'triangle':
                # place a 2x2 box and remove one corner to form an L (3 cells)
                r0 = random.randint(0, size - 2)
                c0 = random.randint(0, size - 2)
                corners = [(r0, c0), (r0, c0 + 1), (r0 + 1, c0), (r0 + 1, c0 + 1)]
                missing = random.randint(0, 3)
                for i, cell in enumerate(corners):
                    if i == missing:
                        continue
                    cells.append(cell)
            elif shape == 'h':
                # horizontal contiguous run of length 3..6
                length = random.randint(3, 6)
                r0 = random.randint(0, size - 1)
                c0 = random.randint(0, size - length)
                cells = [(r0, c0 + i) for i in range(length)]
            else:  # 'v'
                length = random.randint(3, 6)
                c0 = random.randint(0, size - 1)
                r0 = random.randint(0, size - length)
                cells = [(r0 + i, c0) for i in range(length)]

            # ensure placement doesn't overlap existing nonzero cells
            overlap = False
            for (r, c) in cells:
                if inp[r][c] != 0:
                    overlap = True
                    break
            if overlap:
                continue

            # place the cluster
            for (r, c) in cells:
                inp[r][c] = color

            # record cluster metadata (from the original input state)
            rs = [r for r, c in cells]
            cs = [c for r, c in cells]
            rmin, rmax, cmin, cmax = min(rs), max(rs), min(cs), max(cs)
            clusters.append({
                'shape': shape,
                'color': color,
                'rmin': rmin,
                'rmax': rmax,
                'cmin': cmin,
                'cmax': cmax,
            })
            # consume the color so two gate clusters do not share the same color (keeps detection unambiguous)
            if color in colors_pool:
                colors_pool.remove(color)

        # if we failed to place enough clusters, try again
        if len(clusters) < 3:
            continue

        # Place a small number (0..2) of single-cell markers (colors not used by gates) to increase variability.
        # Markers are size-1 and will not be treated as gates by the solver (solver ignores clusters < 3).
        num_markers = random.randint(0, 2)
        for _ in range(num_markers):
            if not colors_pool:
                break
            marker_color = random.choice(colors_pool)
            placed = False
            tries_m = 0
            while not placed and tries_m < 200:
                tries_m += 1
                rr = random.randint(0, size - 1)
                cc = random.randint(0, size - 1)
                if inp[rr][cc] == 0:
                    inp[rr][cc] = marker_color
                    # remove marker color so we don't accidentally create adjacent same-colored markers
                    if marker_color in colors_pool:
                        colors_pool.remove(marker_color)
                    placed = True

        # Build the output by applying gate rules in a hierarchical order (outermost first).
        out = [row[:] for row in inp]

        def area(cl):
            return (cl['rmax'] - cl['rmin'] + 1) * (cl['cmax'] - cl['cmin'] + 1)

        # sort clusters by bounding-box area (descending), then top-left position for determinism
        clusters_sorted = sorted(clusters, key=lambda cl: (-area(cl), cl['rmin'], cl['cmin']))

        # Apply transformations sequentially. Each gate uses its color and its spatial pattern to decide the effect.
        for cl in clusters_sorted:
            shape = cl['shape']
            color = cl['color']
            rmin, rmax, cmin, cmax = cl['rmin'], cl['rmax'], cl['cmin'], cl['cmax']

            if shape == 'triangle':
                # rotate the 2x2 bounding box clockwise (if in bounds)
                r0, c0 = rmin, cmin
                if r0 + 1 < size and c0 + 1 < size:
                    p00 = out[r0][c0]
                    p01 = out[r0][c0 + 1]
                    p10 = out[r0 + 1][c0]
                    p11 = out[r0 + 1][c0 + 1]
                    out[r0][c0] = p10
                    out[r0][c0 + 1] = p00
                    out[r0 + 1][c0 + 1] = p01
                    out[r0 + 1][c0] = p11

            elif shape == 'h':
                # horizontal gate toggles entire row: nonzero -> 0, zero -> gate color
                row = rmin
                for cc in range(size):
                    out[row][cc] = 0 if out[row][cc] != 0 else color

            elif shape == 'v':
                # vertical gate toggles entire column
                col = cmin
                for rr in range(size):
                    out[rr][col] = 0 if out[rr][col] != 0 else color

        # Ensure the grid actually changed; regenerate in the unlikely event it didn't
        if out != inp:
            return {
                'input': inp,
                'output': out
            }
        # otherwise try again



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    size = len(input_grid)
    # work on a mutable copy
    grid = [list(row) for row in input_grid]

    # Find connected components of equal nonzero color (4-neighborhood)
    visited = [[False] * size for _ in range(size)]
    clusters = []
    for r in range(size):
        for c in range(size):
            if grid[r][c] > 0 and not visited[r][c]:
                color = grid[r][c]
                stack = [(r, c)]
                visited[r][c] = True
                cells = []
                while stack:
                    cr, cc = stack.pop()
                    cells.append((cr, cc))
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < size and 0 <= nc < size and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))

                # Treat only clusters of size >= 3 as gates (others are markers/noise)
                if len(cells) >= 3:
                    rs = [p[0] for p in cells]
                    cs = [p[1] for p in cells]
                    rmin, rmax, cmin, cmax = min(rs), max(rs), min(cs), max(cs)

                    # deduce gate shape
                    shape = None
                    if rmin == rmax:
                        shape = 'h'
                    elif cmin == cmax:
                        shape = 'v'
                    elif len(cells) == 3 and (rmax - rmin == 1 and cmax - cmin == 1):
                        shape = 'triangle'
                    else:
                        # Unknown/special cluster shape - skip (generator does not create these)
                        continue

                    clusters.append({
                        'shape': shape,
                        'color': color,
                        'rmin': rmin,
                        'rmax': rmax,
                        'cmin': cmin,
                        'cmax': cmax,
                    })

    # Sort clusters in the same hierarchical order as the generator: outermost (larger area) first
    def area(cl):
        return (cl['rmax'] - cl['rmin'] + 1) * (cl['cmax'] - cl['cmin'] + 1)

    clusters_sorted = sorted(clusters, key=lambda cl: (-area(cl), cl['rmin'], cl['cmin']))

    out = [row[:] for row in grid]

    # Apply the gate transformations in sequence (using colors read from the original input)
    for cl in clusters_sorted:
        shape = cl['shape']
        color = cl['color']
        rmin, rmax, cmin, cmax = cl['rmin'], cl['rmax'], cl['cmin'], cl['cmax']

        if shape == 'triangle':
            r0, c0 = rmin, cmin
            if r0 + 1 < size and c0 + 1 < size:
                p00 = out[r0][c0]
                p01 = out[r0][c0 + 1]
                p10 = out[r0 + 1][c0]
                p11 = out[r0 + 1][c0 + 1]
                out[r0][c0] = p10
                out[r0][c0 + 1] = p00
                out[r0 + 1][c0 + 1] = p01
                out[r0 + 1][c0] = p11

        elif shape == 'h':
            row = rmin
            for cc in range(size):
                out[row][cc] = 0 if out[row][cc] != 0 else color

        elif shape == 'v':
            col = cmin
            for rr in range(size):
                out[rr][col] = 0 if out[rr][col] != 0 else color

    # return as tuple rows (ARC expected format for solver)
    return [tuple(row) for row in out]

