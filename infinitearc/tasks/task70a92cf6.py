# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 70a92cf6
Difficulty: insane

=== Tags ===
- Route switching
- Extend stem to border
- Pattern reflection

=== Description ===
Input grids are 20×20 or larger, featuring a single background color (0) with
multiple "stems" — orthogonal line segments of distinct colors (1-9) originating
from one of the four grid borders and extending inward. Each stem may intersect
"switch" markers (color S) and "reflector" markers (color R) positioned along
its path. Switch markers cause clockwise direction changes (right → up → left →
down → right), while reflector markers reverse direction along the axis of the
marker (e.g., horizontal movement reverses left/right, vertical reverses
up/down). The output grid extends each stem in its current direction (after all
applied switches/reflections) until it reaches the grid border, drawing the path
in the stem’s original color over background cells only. Switch and reflector
markers remain unchanged and visible in the output. Path extensions must avoid
overlapping existing markers or other stems, with all paths terminating at the
border without loops or intersections. This requires sequential application of
direction rules across multiple markers while maintaining path integrity to the
border.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid


def generate():
    """Generate an ARC-style input/output pair with multiple stems that start on the border,
    may encounter switch (S) and reflector (R) markers, and whose final direction is
    extended to the border in the output.

    Markers use fixed colors S_COLOR=1 and R_COLOR=2. Stem colors are chosen from 3..9.
    """
    # Grid size
    width = random.randint(20, 30)
    height = random.randint(20, 30)

    # Base grids
    inp = grid(width, height, 0)
    out = grid(width, height, 0)

    # Marker colors (fixed so the solver can recognize them)
    S_COLOR = 1
    R_COLOR = 2

    # Direction helpers (note: the order below follows the problem statement mapping)
    directions = {
        'right': (0, 1),
        'up': (-1, 0),
        'left': (0, -1),
        'down': (1, 0)
    }
    # The problem statement gave the sequence right -> up -> left -> down -> right
    clockwise = ['right', 'up', 'left', 'down']

    def apply_switch(d):
        return clockwise[(clockwise.index(d) + 1) % 4]

    def apply_reflector(d):
        return {'right': 'left', 'left': 'right', 'up': 'down', 'down': 'up'}[d]

    # Number of stems
    num_stems = random.randint(3, 5)
    # Choose distinct stem colors from 3..9
    stem_colors = random.sample(list(range(3, 10)), num_stems)

    # Occupied cells (stems and markers already placed in the input, and extensions reserved in out)
    occupied = set()

    # We ensure at least one stem successfully gets an extension so input != output
    success_any_extension = False

    # Helper to check whether a cell is on the border
    def is_border(r, c):
        return r == 0 or r == height - 1 or c == 0 or c == width - 1

    # Try to place each stem
    for s_idx, stem_color in enumerate(stem_colors):
        placed = False
        # Give the first stem more attempts to guarantee at least one extension exists
        max_attempts = 1500 if s_idx == 0 else 400
        attempts = 0
        while not placed and attempts < max_attempts:
            attempts += 1
            # Pick random border start
            side = random.choice(['top', 'bottom', 'left', 'right'])
            if side == 'top':
                sr, sc = 0, random.randint(1, width - 2)
                cur_dir = 'down'
            elif side == 'bottom':
                sr, sc = height - 1, random.randint(1, width - 2)
                cur_dir = 'up'
            elif side == 'left':
                sr, sc = random.randint(1, height - 2), 0
                cur_dir = 'right'
            else:
                sr, sc = random.randint(1, height - 2), width - 1
                cur_dir = 'left'

            # can't start on an already occupied border cell
            if (sr, sc) in occupied:
                continue

            # Build an interior path (do not step into another border cell while building)
            path = [(sr, sc)]
            markers = {}  # (r,c) -> marker color
            pr, pc = sr, sc

            # random interior path length
            steps = random.randint(3, 12)
            valid = True
            for step in range(steps):
                dr, dc = directions[cur_dir]
                nr, nc = pr + dr, pc + dc
                # must stay inside grid
                if not (0 <= nr < height and 0 <= nc < width):
                    valid = False
                    break
                # do not step into a border cell while building the path (we want an interior end)
                if is_border(nr, nc):
                    valid = False
                    break
                # avoid collisions with already placed objects or self
                if (nr, nc) in occupied or (nr, nc) in path:
                    valid = False
                    break

                # Randomly place a marker at this position (not too many)
                place_marker = (random.random() < 0.33) and (len(markers) < 3) and (len(path) > 1)
                if place_marker:
                    mtype = random.choice(['S', 'R'])
                    mcolor = S_COLOR if mtype == 'S' else R_COLOR
                    markers[(nr, nc)] = mcolor
                    path.append((nr, nc))
                    # update direction immediately when a marker is encountered
                    if mtype == 'S':
                        cur_dir = apply_switch(cur_dir)
                    else:
                        cur_dir = apply_reflector(cur_dir)
                    pr, pc = nr, nc
                    continue

                # otherwise add a stem-colored segment
                path.append((nr, nc))
                pr, pc = nr, nc

            if not valid:
                continue

            # Now ensure the straight corridor from the current end in cur_dir to the border
            # is clear (no occupied cells, not crossing this path) and non-empty.
            corridor = []
            cr, cc = pr, pc
            dr, dc = directions[cur_dir]
            nr, nc = cr + dr, cc + dc
            while 0 <= nr < height and 0 <= nc < width:
                # if corridor crosses existing occupied cells or this path, it's not valid
                if (nr, nc) in occupied or (nr, nc) in path or (nr, nc) in markers:
                    corridor = []
                    break
                corridor.append((nr, nc))
                # stop once we hit the border cell
                if is_border(nr, nc):
                    break
                nr += dr
                nc += dc

            if not corridor:
                continue
            # corridor must end at the border
            if not is_border(corridor[-1][0], corridor[-1][1]):
                continue

            # Commit the constructed stem into the input grid
            for (rpos, cpos) in path:
                if (rpos, cpos) in markers:
                    inp[rpos][cpos] = markers[(rpos, cpos)]
                else:
                    inp[rpos][cpos] = stem_color
                occupied.add((rpos, cpos))
                # ensure output starts equal to input for existing path/markers
                out[rpos][cpos] = inp[rpos][cpos]

            # Draw the corridor only in the output grid (over background cells only)
            drew = False
            for (rpos, cpos) in corridor:
                # never overwrite markers or existing non-background cells
                if inp[rpos][cpos] != 0:
                    drew = False
                    break
                if out[rpos][cpos] == 0:
                    out[rpos][cpos] = stem_color
                    occupied.add((rpos, cpos))
                    drew = True
            if not drew:
                # Unexpected collision, roll back (remove path from occupied) and retry
                for (rpos, cpos) in path:
                    if (rpos, cpos) in occupied:
                        occupied.discard((rpos, cpos))
                        # clear inp/out for those cells
                        inp[rpos][cpos] = 0
                        out[rpos][cpos] = 0
                continue

            # Keep markers visible in the output as well
            for (mpos, mcol) in markers.items():
                out[mpos[0]][mpos[1]] = mcol

            placed = True
            if drew:
                success_any_extension = True

        # end attempts for this stem

    # Ensure we actually changed the grid (very unlikely to fail, but check)
    if not success_any_extension:
        # Make a single simple extension deterministically: extend the first placed stem if any
        # (This branch is extremely unlikely due to the large search space above.)
        # Find any stem color on the border and extend one cell inwards in out (but do not modify inp)
        for r in range(height):
            for c in range(width):
                if inp[r][c] >= 3:
                    # find its initial direction from the border (if border)
                    if r == 0:
                        dr, dc = directions['down']
                    elif r == height - 1:
                        dr, dc = directions['up']
                    elif c == 0:
                        dr, dc = directions['right']
                    elif c == width - 1:
                        dr, dc = directions['left']
                    else:
                        continue
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and inp[nr][nc] == 0:
                        out[nr][nc] = inp[r][c]
                        success_any_extension = True
                        break
            if success_any_extension:
                break

    return {'input': inp, 'output': out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    """Solver that extends each stem from its border start, applying switches and reflectors
    along the way, and draws the final straight extension to the border over background cells only.

    Marker colors are expected to be S_COLOR=1 and R_COLOR=2 and stem colors are 3..9.
    """
    # Convert to mutable list of lists
    orig = [list(row) for row in input_grid]
    height = len(orig)
    width = len(orig[0])

    S_COLOR = 1
    R_COLOR = 2

    directions = {
        'right': (0, 1),
        'up': (-1, 0),
        'left': (0, -1),
        'down': (1, 0)
    }
    clockwise = ['right', 'up', 'left', 'down']

    def apply_switch(d):
        return clockwise[(clockwise.index(d) + 1) % 4]

    def apply_reflector(d):
        return {'right': 'left', 'left': 'right', 'up': 'down', 'down': 'up'}[d]

    # Work on a separate output so we don't influence traversal for other stems
    out = [list(row) for row in orig]

    def is_border(r, c):
        return r == 0 or r == height - 1 or c == 0 or c == width - 1

    # Collect stem colors present (exclude background and marker colors)
    stem_colors = sorted({val for row in orig for val in row if val not in (0, S_COLOR, R_COLOR)})

    for stem_color in stem_colors:
        # Find the border start for this stem
        start = None
        # top and bottom rows
        for cc in range(width):
            if orig[0][cc] == stem_color:
                start = (0, cc)
                break
            if orig[height - 1][cc] == stem_color:
                start = (height - 1, cc)
                break
        if start is None:
            # left and right columns
            for rr in range(height):
                if orig[rr][0] == stem_color:
                    start = (rr, 0)
                    break
                if orig[rr][width - 1] == stem_color:
                    start = (rr, width - 1)
                    break
        if start is None:
            # No border start found (shouldn't happen), skip
            continue

        r0, c0 = start
        # Determine initial direction from the border start
        if r0 == 0:
            cur_dir = 'down'
        elif r0 == height - 1:
            cur_dir = 'up'
        elif c0 == 0:
            cur_dir = 'right'
        else:
            cur_dir = 'left'

        # Traverse along the stem following stem cells and markers
        cr, cc = r0, c0
        while True:
            dr, dc = directions[cur_dir]
            nr, nc = cr + dr, cc + dc
            if not (0 <= nr < height and 0 <= nc < width):
                break
            val = orig[nr][nc]
            if val == stem_color:
                cr, cc = nr, nc
                continue
            if val == S_COLOR:
                cur_dir = apply_switch(cur_dir)
                cr, cc = nr, nc
                continue
            if val == R_COLOR:
                cur_dir = apply_reflector(cur_dir)
                cr, cc = nr, nc
                continue
            # stopped by background or other color
            break

        # Now extend straight in cur_dir from (cr,cc) until border, writing only on original background cells
        dr, dc = directions[cur_dir]
        nr, nc = cr + dr, cc + dc
        while 0 <= nr < height and 0 <= nc < width:
            # only draw over original background and not overwrite existing out cells
            if orig[nr][nc] != 0:
                break
            if out[nr][nc] != 0:
                break
            out[nr][nc] = stem_color
            if is_border(nr, nc):
                break
            nr += dr
            nc += dc

    return out

