# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 7aea3e43
Difficulty: very hard

=== Tags ===
- Exclusive or coloring
- Obstacles
- Hierarchical repetition

=== Description ===
Hierarchical XOR Obstacle Grids  Input grids feature multiple concentric
rectangular frames (hierarchical layers) centered within the grid, each
separated by a single background cell (color 0). Each frame contains a distinct
color pattern where colors are arranged in specific geometric shapes. Within
each frame, fixed obstacle regions (color 8) appear as non-interactive black
rectangles that block transformations. The transformation rule between
consecutive frames is defined by "exclusive coloring": for each cell in an inner
frame, if the cell is not an obstacle, its color must be a unique color not
present in either the corresponding cell of the outer frame or the obstacle
color (8). For example, if the outer frame cell is red (color 2) and obstacles
are present (color 8), the inner cell must use a color like green (3) or blue
(1), avoiding both 2 and 8.  The output grid must extend the hierarchy by
generating a new innermost frame. This new frame is derived by applying the
exclusive coloring rule to the innermost frame of the input. Obstacles (color 8)
remain unchanged in all frames and act as barriers that prevent color
combinations from propagating through them. All existing frames, background, and
obstacle positions are preserved exactly as in the input. The transformation
requires recognizing the hierarchical structure, identifying obstacle positions,
and applying the color exclusion rule recursively to generate the new layer. The
complexity arises from the need to simultaneously process multiple layers,
navigate around obstacles, and apply the exclusive coloring rule without
numerical operations, relying solely on visual pattern recognition and
relational reasoning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    size = random.randint(5, 30)
    if size % 2 == 0:
        size -= 1
    if size < 7:
        size = 7
    grid = [[0] * size for _ in range(size)]
    
    frame1_top, frame1_left = 1, 1
    frame1_bottom, frame1_right = size-2, size-2
    
    for r in range(frame1_top, frame1_bottom+1):
        for c in range(frame1_left, frame1_right+1):
            if random.random() < 0.3:
                grid[r][c] = 8
            else:
                color = random.choice([1,2,3,4,5,6,7,9])
                grid[r][c] = color
    
    frame2_top, frame2_left = 2, 2
    frame2_bottom, frame2_right = size-3, size-3
    
    for r in range(frame2_top, frame2_bottom+1):
        for c in range(frame2_left, frame2_right+1):
            if grid[r][c] == 8:
                grid[r][c] = 8
            else:
                colors = [1,2,3,4,5,6,7,9]
                colors.remove(grid[r][c])
                grid[r][c] = min(colors)
    
    output = [row[:] for row in grid]
    frame3_top, frame3_left = 3, 3
    frame3_bottom, frame3_right = size-4, size-4
    
    for r in range(frame3_top, frame3_bottom+1):
        for c in range(frame3_left, frame3_right+1):
            if grid[r][c] == 8:
                output[r][c] = 8
            else:
                colors = [1,2,3,4,5,6,7,9]
                colors.remove(grid[r][c])
                output[r][c] = min(colors)
    
    return {
        'input': grid,
        'output': output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    size = len(grid)
    
    non_zero_rows = []
    non_zero_cols = []
    for r in range(size):
        for c in range(size):
            if grid[r][c] != 0:
                non_zero_rows.append(r)
                non_zero_cols.append(c)
    
    if not non_zero_rows:
        return grid
    
    min_row, max_row = min(non_zero_rows), max(non_zero_rows)
    min_col, max_col = min(non_zero_cols), max(non_zero_cols)
    
    frame3_top = min_row + 2
    frame3_left = min_col + 2
    frame3_bottom = max_row - 2
    frame3_right = max_col - 2
    
    if frame3_top > frame3_bottom or frame3_left > frame3_right:
        return grid
    
    for r in range(frame3_top, frame3_bottom+1):
        for c in range(frame3_left, frame3_right+1):
            if grid[r][c] == 8:
                grid[r][c] = 8
            else:
                colors = [1,2,3,4,5,6,7,9]
                if grid[r][c] in colors:
                    colors.remove(grid[r][c])
                grid[r][c] = min(colors)
    
    return grid
