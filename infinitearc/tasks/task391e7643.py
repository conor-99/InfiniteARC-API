# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 391e7643
Difficulty: very hard

=== Tags ===
- Path scarring
- Coordinate warp
- Reflect by color
- Pressure release
- Color majority row
- Size guessing

=== Description ===
Input grids consist of a background (color 0) and multiple contiguous colored
paths (1-9), each path being a connected region (8-connected) of a single color.
Each row has a majority color (non-background), which determines the "pressure"
level for that row. The transformation process follows these steps:  1. **Path
Scarring**: The input paths serve as the initial scarred regions to be
transformed.  2. **Coordinate Warp**: Each cell (r, c) in a path of color C is
shifted horizontally by C columns (wrapping within grid boundaries). If shifting
causes overlap with a non-background cell, the direction reverses (reflection),
and the shift is recalculated with the opposite direction until a valid position
is found.  3. **Reflect by Color**: During warping, paths reflect off regions
matching the current row's majority color (before pressure release), altering
their direction of movement.  4. **Pressure Release**: After warping, each row's
majority color M (non-background) is incremented modulo 9 (e.g., 9 â†’ 1). All
cells of color M in the row are replaced with this new color, simulating
"pressure release."  5. **Color Majority Row**: The majority color of each row
after pressure release determines the final path length and color. Paths are
extended or shortened to match the length equal to the row's majority color
value.  6. **Size Guessing**: Each path's output length is determined by the
row's majority color value (e.g., a majority color of 3 requires a path length
of 3). Paths are adjusted to this length using the row's new majority color as
their color, with no overlaps or boundary violations.  The output grid preserves
the transformed paths according to these rules, ensuring all operations are
deterministic, consistent, and interdependent, requiring simultaneous
consideration of color, position, and row-level constraints.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # choose grid size
    width = random.randint(4, 12)
    height = random.randint(3, 12)
    # ensure grid not too full
    input_grid = grid(width, height, 0)
    occupied = [[False]*width for _ in range(height)]
    cells_left = width*height
    # number of paths
    max_paths = max(1, min(6, (width*height)//5))
    num_paths = random.randint(1, max_paths)
    used_colors = []
    for p in range(num_paths):
        # pick color avoid reuse too often
        c = random.randint(1,9)
        # ensure different sometimes
        # maybe ensure not used more than twice
        if used_colors.count(c) >= 2:
            # pick different
            choices = [x for x in range(1,10) if used_colors.count(x)<2]
            if choices:
                c = random.choice(choices)
        used_colors.append(c)
        max_len = max(1, (width*height)//(num_paths*2))
        L = random.randint(1, max(1, min(max_len, width*height//4)))
        # find start cell random empty
        attempts = 0
        while attempts < 100:
            sr = random.randrange(height)
            sc = random.randrange(width)
            if not occupied[sr][sc]:
                break
            attempts +=1
        else:
            # grid nearly full
            break
        path = [(sr, sc)]
        occupied[sr][sc] = True
        input_grid[sr][sc] = c
        # grow path
        for _ in range(L-1):
            last = path[-1]
            r0, c0 = last
            # neighbors 8-connected
            neigh = []
            for dr in (-1,0,1):
                for dc in (-1,0,1):
                    if dr==0 and dc==0: continue
                    nr, nc = r0+dr, c0+dc
                    if 0 <= nr < height and 0 <= nc < width and not occupied[nr][nc]:
                        neigh.append((nr,nc))
            if not neigh:
                # try neighbors of any existing path cell
                for (ar, ac) in path:
                    for dr in (-1,0,1):
                        for dc in (-1,0,1):
                            if dr==0 and dc==0: continue
                            nr, nc = ar+dr, ac+dc
                            if 0 <= nr < height and 0 <= nc < width and not occupied[nr][nc]:
                                neigh.append((nr,nc))
                if not neigh:
                    break
            nr,nc = random.choice(neigh)
            path.append((nr,nc))
            occupied[nr][nc] = True
            input_grid[nr][nc] = c
    # ensure each row has a non-zero majority (unique)
    for r in range(height):
        counts = {}
        for c in range(width):
            v = input_grid[r][c]
            if v != 0:
                counts[v] = counts.get(v, 0) + 1
        if not counts:
            # make a small block of same color
            color = random.randint(1,9)
            block_len = random.randint(1, max(1, min(3, width)))
            start = random.randint(0, width - block_len)
            # try to place without overwriting other paths
            placed = False
            for i in range(start, start+block_len):
                if input_grid[r][i] == 0:
                    input_grid[r][i] = color
                    placed = True
            if not placed:
                # find any empty cell in row
                for i in range(width):
                    if input_grid[r][i] == 0:
                        input_grid[r][i] = color
                        placed = True
                        break
            # update counts
            counts = {color: sum(1 for c in range(width) if input_grid[r][c]==color)}
        # ensure unique majority if tie
        if counts:
            max_count = max(counts.values())
            best = [col for col, cnt in counts.items() if cnt == max_count]
            if len(best) > 1:
                # break tie by adding one extra cell of the smallest color among them
                pick = min(best)
                for i in range(width):
                    if input_grid[r][i] == 0:
                        input_grid[r][i] = pick
                        break
    # now compute row_majorities from input (unique by construction)
    row_majorities = []
    for r in range(height):
        counts = {}
        for c in range(width):
            v = input_grid[r][c]
            if v != 0:
                counts[v] = counts.get(v, 0) + 1
        if not counts:
            # fallback
            M = 1
        else:
            max_count = max(counts.values())
            # select smallest color in tie to be deterministic
            M = min([col for col,cnt in counts.items() if cnt == max_count])
        row_majorities.append(M)
    # transformation
    output_grid = grid(width, height, 0)
    for r in range(height):
        M = row_majorities[r]
        for c in range(width):
            C = input_grid[r][c]
            if C == 0: continue
            direction = 1
            placed = False
            attempts = 0
            while attempts < 4:
                new_col = (c + direction * C) % width
                # reflect on majority color (in input)
                if input_grid[r][new_col] == M and new_col != c:
                    direction *= -1
                    attempts += 1
                    continue
                # reflect if target overlaps another input cell (not this source)
                if input_grid[r][new_col] != 0 and new_col != c:
                    direction *= -1
                    attempts += 1
                    continue
                # reflect if output already occupied
                if output_grid[r][new_col] != 0:
                    direction *= -1
                    attempts += 1
                    continue
                # place
                output_grid[r][new_col] = C
                placed = True
                break
            if not placed:
                # fallback: find nearest empty position in row that is not input M if possible
                found = False
                for k in range(width):
                    pos = (c + k) % width
                    if output_grid[r][pos] == 0 and input_grid[r][pos] != M:
                        output_grid[r][pos] = C
                        found = True
                        break
                if not found:
                    for pos in range(width):
                        if output_grid[r][pos] == 0:
                            output_grid[r][pos] = C
                            found = True
                            break
                # if still not found, skip placing this cell
    # pressure release: replace all M in row with (M % 9) + 1
    for r in range(height):
        M = row_majorities[r]
        new_color = (M % 9) + 1
        for c in range(width):
            if output_grid[r][c] == M:
                output_grid[r][c] = new_color
    # color majority after pressure release and adjust sizes
    for r in range(height):
        counts = [0]*10
        for c in range(width):
            v = output_grid[r][c]
            if v != 0:
                counts[v] += 1
        # find majority color (choose smallest color in tie)
        max_count = max(counts[1:]) if any(counts[1:]) else 0
        if max_count == 0:
            M_prime = 1
        else:
            M_prime = min([col for col in range(1,10) if counts[col] == max_count])
        L = M_prime
        positions = [c for c in range(width) if output_grid[r][c] == M_prime]
        if len(positions) > L:
            # remove rightmost extras
            for c in positions[L:]:
                output_grid[r][c] = 0
        elif len(positions) < L:
            need = L - len(positions)
            # try to add adjacent empties first
            cand = []
            for pos in positions:
                for delta in (-1,1):
                    nc = pos + delta
                    if 0 <= nc < width and output_grid[r][nc] == 0:
                        cand.append(nc)
            # dedupe preserve order
            seen = set()
            cand2 = []
            for x in cand:
                if x not in seen:
                    seen.add(x)
                    cand2.append(x)
            for pos in cand2:
                if need <= 0: break
                output_grid[r][pos] = M_prime
                need -= 1
            # fill left-to-right
            for pos in range(width):
                if need <= 0: break
                if output_grid[r][pos] == 0:
                    output_grid[r][pos] = M_prime
                    need -= 1
            # as last resort replace other colors (shouldn't be needed)
            for pos in range(width):
                if need <= 0: break
                if output_grid[r][pos] != M_prime:
                    output_grid[r][pos] = M_prime
                    need -= 1
    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    # convert input tuple to mutable list
    input_list = [list(row) for row in input_grid]
    height = len(input_list)
    width = len(input_list[0]) if height>0 else 0
    # compute row_majorities
    row_majorities = []
    for r in range(height):
        counts = {}
        for c in range(width):
            v = input_list[r][c]
            if v != 0:
                counts[v] = counts.get(v, 0) + 1
        if not counts:
            M = 1
        else:
            max_count = max(counts.values())
            # choose smallest color in tie to be deterministic
            M = min([col for col,cnt in counts.items() if cnt == max_count])
        row_majorities.append(M)
    # perform warping
    output_grid = grid(width, height, 0)
    for r in range(height):
        M = row_majorities[r]
        for c in range(width):
            C = input_list[r][c]
            if C == 0:
                continue
            direction = 1
            placed = False
            attempts = 0
            while attempts < 4:
                new_col = (c + direction * C) % width
                # reflect on majority color (in input)
                if input_list[r][new_col] == M and new_col != c:
                    direction *= -1
                    attempts += 1
                    continue
                # reflect if target overlaps another input cell (not this source)
                if input_list[r][new_col] != 0 and new_col != c:
                    direction *= -1
                    attempts += 1
                    continue
                # reflect if output already occupied
                if output_grid[r][new_col] != 0:
                    direction *= -1
                    attempts += 1
                    continue
                output_grid[r][new_col] = C
                placed = True
                break
            if not placed:
                found = False
                for k in range(width):
                    pos = (c + k) % width
                    if output_grid[r][pos] == 0 and input_list[r][pos] != M:
                        output_grid[r][pos] = C
                        found = True
                        break
                if not found:
                    for pos in range(width):
                        if output_grid[r][pos] == 0:
                            output_grid[r][pos] = C
                            found = True
                            break
    # pressure release
    for r in range(height):
        M = row_majorities[r]
        new_color = (M % 9) + 1
        for c in range(width):
            if output_grid[r][c] == M:
                output_grid[r][c] = new_color
    # majority after release and size guessing
    for r in range(height):
        counts = [0]*10
        for c in range(width):
            v = output_grid[r][c]
            if v != 0:
                counts[v] += 1
        max_count = max(counts[1:]) if any(counts[1:]) else 0
        if max_count == 0:
            M_prime = 1
        else:
            M_prime = min([col for col in range(1,10) if counts[col] == max_count])
        L = M_prime
        positions = [c for c in range(width) if output_grid[r][c] == M_prime]
        if len(positions) > L:
            for c in positions[L:]:
                output_grid[r][c] = 0
        elif len(positions) < L:
            need = L - len(positions)
            cand = []
            for pos in positions:
                for delta in (-1,1):
                    nc = pos + delta
                    if 0 <= nc < width and output_grid[r][nc] == 0:
                        cand.append(nc)
            seen = set()
            cand2 = []
            for x in cand:
                if x not in seen:
                    seen.add(x)
                    cand2.append(x)
            for pos in cand2:
                if need <= 0: break
                output_grid[r][pos] = M_prime
                need -= 1
            for pos in range(width):
                if need <= 0: break
                if output_grid[r][pos] == 0:
                    output_grid[r][pos] = M_prime
                    need -= 1
            for pos in range(width):
                if need <= 0: break
                if output_grid[r][pos] != M_prime:
                    output_grid[r][pos] = M_prime
                    need -= 1
    # return as tuple of tuples
    return tuple(tuple(row) for row in output_grid)

