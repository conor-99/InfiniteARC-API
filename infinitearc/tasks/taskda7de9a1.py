# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: da7de9a1
Difficulty: medium–hard

=== Tags ===
- Energy loss per bounce
- Constraint satisfaction coloring
- Pattern mirroring chain

=== Description ===
Input grids feature a single contiguous colored pattern (the "source") on a
uniform background, accompanied by a directional arrow glyph (a distinct color)
indicating the axis along which the mirroring chain extends. The output grid
constructs a sequence of mirrored patterns aligned with the arrow's direction,
where each subsequent pattern is scaled down by 1 pixel in width and height
(energy loss per bounce), and colored using a cyclic sequence (e.g.,
1→2→3→...→9) that ensures no two adjacent cells share the same color (constraint
satisfaction coloring). Mirroring continues until the next pattern would overlap
non-background cells or exceed grid boundaries. The original source pattern and
arrow glyph remain visually unchanged in the output, preserving their original
positions and colors. Each mirrored copy forms a geometric progression of
decreasing size and sequentially changing color, creating a visually coherent
chain that adheres to adjacency constraints at all points.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

SEEN = set()


def _serialize_grid(g):
    return tuple(tuple(row) for row in g)


def generate():
    """Generates one input/output pair following the mirroring-chain rules.

    The generator creates a single contiguous rectangular source (solid color),
    places a short arrow glyph (2 or 3 cells) adjacent to the source pointing in
    one of the four cardinal directions, and then constructs a chain of
    mirrored (identical for rectangles) scaled-down copies. Each copy is 1
    pixel smaller in both width and height than the previous, placed
    contiguously along the arrow's direction starting immediately after the
    arrow tip. Colors for the copies are chosen cyclically from 1..9 (relative
    to the source color) but skipping any color that would create a 4-adjacency
    conflict with already-placed non-background cells. Mirroring stops when a
    copy would overlap non-background cells or exceed bounds.

    The function retries until it can place at least one copy and produce a
    pair that hasn't been returned before (to help ensure uniqueness across
    multiple calls).
    """
    attempts = 0
    while True:
        attempts += 1
        if attempts > 2000:
            # Fallback: reduce complexity to guarantee a result
            width, height = 10, 10
        else:
            width = random.randint(6, 20)
            height = random.randint(6, 20)

        bg = 0

        # Try a few times to build a valid layout
        for _ in range(200):
            source_w = random.randint(2, min(6, max(2, width - 4)))
            source_h = random.randint(2, min(6, max(2, height - 4)))
            arrow_len = random.choice([2, 3])
            direction = random.choice(['right', 'left', 'up', 'down'])

            # Compute feasible ranges for the source top-left depending on direction
            if direction == 'right':
                c0_min, c0_max = 0, width - (source_w + arrow_len + 1)
                r0_min, r0_max = 0, height - source_h
            elif direction == 'left':
                c0_min, c0_max = arrow_len + (source_w - 1), width - source_w
                r0_min, r0_max = 0, height - source_h
            elif direction == 'down':
                r0_min, r0_max = 0, height - (source_h + arrow_len + 1)
                c0_min, c0_max = 0, width - source_w
            else:  # up
                r0_min, r0_max = arrow_len + (source_h - 1), height - source_h
                c0_min, c0_max = 0, width - source_w

            if c0_min > c0_max or r0_min > r0_max:
                continue

            c0 = random.randint(c0_min, c0_max)
            r0 = random.randint(r0_min, r0_max)

            input_grid = grid(width, height, bg)
            output_grid = [row[:] for row in input_grid]

            # Source color
            source_color = random.randint(1, 9)
            for rr in range(r0, r0 + source_h):
                for cc in range(c0, c0 + source_w):
                    input_grid[rr][cc] = source_color
                    output_grid[rr][cc] = source_color

            # Arrow color (distinct)
            arrow_color = random.choice([i for i in range(1, 10) if i != source_color])

            # Place arrow cells (arrow is a short straight segment outside the source)
            if direction == 'right':
                r_arrow = r0 + source_h // 2
                start_col = c0 + source_w
                if start_col + arrow_len - 1 >= width:
                    continue
                for i in range(arrow_len):
                    input_grid[r_arrow][start_col + i] = arrow_color
                    output_grid[r_arrow][start_col + i] = arrow_color
                arrow_bbox = (r_arrow, r_arrow, start_col, start_col + arrow_len - 1)
            elif direction == 'left':
                r_arrow = r0 + source_h // 2
                start_col = c0 - arrow_len
                if start_col < 0:
                    continue
                for i in range(arrow_len):
                    input_grid[r_arrow][start_col + i] = arrow_color
                    output_grid[r_arrow][start_col + i] = arrow_color
                arrow_bbox = (r_arrow, r_arrow, start_col, start_col + arrow_len - 1)
            elif direction == 'down':
                c_arrow = c0 + source_w // 2
                start_row = r0 + source_h
                if start_row + arrow_len - 1 >= height:
                    continue
                for i in range(arrow_len):
                    input_grid[start_row + i][c_arrow] = arrow_color
                    output_grid[start_row + i][c_arrow] = arrow_color
                arrow_bbox = (start_row, start_row + arrow_len - 1, c_arrow, c_arrow)
            else:  # up
                c_arrow = c0 + source_w // 2
                start_row = r0 - arrow_len
                if start_row < 0:
                    continue
                for i in range(arrow_len):
                    input_grid[start_row + i][c_arrow] = arrow_color
                    output_grid[start_row + i][c_arrow] = arrow_color
                arrow_bbox = (start_row, start_row + arrow_len - 1, c_arrow, c_arrow)

            # Build the mirrored chain (copies are filled rectangles, each smaller by 1 in w and h)
            prev_w, prev_h = source_w, source_h
            prev_left, prev_top = c0, r0
            first = True
            k = 1
            placed_any = False

            while True:
                new_w = prev_w - 1
                new_h = prev_h - 1
                if new_w <= 0 or new_h <= 0:
                    break

                if first:
                    if direction == 'right':
                        c_new = arrow_bbox[3] + 1
                        r_new = r0 + (source_h - new_h) // 2
                    elif direction == 'left':
                        c_new = arrow_bbox[2] - new_w
                        r_new = r0 + (source_h - new_h) // 2
                    elif direction == 'down':
                        r_new = arrow_bbox[1] + 1
                        c_new = c0 + (source_w - new_w) // 2
                    else:  # up
                        r_new = arrow_bbox[0] - new_h
                        c_new = c0 + (source_w - new_w) // 2
                else:
                    if direction == 'right':
                        c_new = prev_left + prev_w
                        r_new = r0 + (source_h - new_h) // 2
                    elif direction == 'left':
                        c_new = prev_left - new_w
                        r_new = r0 + (source_h - new_h) // 2
                    elif direction == 'down':
                        r_new = prev_top + prev_h
                        c_new = c0 + (source_w - new_w) // 2
                    else:  # up
                        r_new = prev_top - new_h
                        c_new = c0 + (source_w - new_w) // 2

                # Bounds check
                if not (0 <= r_new and r_new + new_h <= height and 0 <= c_new and c_new + new_w <= width):
                    break

                # Overlap check with existing non-background cells
                overlap = False
                for rr in range(r_new, r_new + new_h):
                    for cc in range(c_new, c_new + new_w):
                        if output_grid[rr][cc] != bg:
                            overlap = True
                            break
                    if overlap:
                        break
                if overlap:
                    break

                # Select a cyclic color based on the source color, skipping colors that cause a 4-neighbor conflict
                candidate = ((source_color + k - 1) % 9) + 1
                tried = 0
                found = False
                while tried < 9:
                    conflict = False
                    for rr in range(r_new, r_new + new_h):
                        for cc in range(c_new, c_new + new_w):
                            # check 4-neighbors for same color
                            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                                nr, nc = rr + dr, cc + dc
                                if 0 <= nr < height and 0 <= nc < width:
                                    if output_grid[nr][nc] == candidate:
                                        conflict = True
                                        break
                            if conflict:
                                break
                        if conflict:
                            break
                    if not conflict:
                        found = True
                        break
                    candidate = (candidate % 9) + 1
                    tried += 1

                if not found:
                    break

                # Paint the copy
                for rr in range(r_new, r_new + new_h):
                    for cc in range(c_new, c_new + new_w):
                        output_grid[rr][cc] = candidate

                placed_any = True
                prev_w, prev_h = new_w, new_h
                prev_left, prev_top = c_new, r_new
                first = False
                k += 1

            if not placed_any:
                # ensure we produce a different output than input; otherwise retry
                continue

            key = (_serialize_grid(input_grid), _serialize_grid(output_grid))
            if key in SEEN:
                continue
            SEEN.add(key)
            return {'input': input_grid, 'output': output_grid}

    # Should never reach here
    raise RuntimeError('Failed to generate a valid grid')


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(inp):
    # Convert immutable tuple-of-tuples to a mutable list-of-lists
    grid = [list(row) for row in inp]
    height = len(grid)
    width = len(grid[0])
    bg = 0

    # Find all non-background pixels and identify the source color as the largest connected component color
    from collections import deque

    visited = [[False] * width for _ in range(height)]
    components = []  # list of (color, pixels_list)

    for r in range(height):
        for c in range(width):
            if grid[r][c] == bg or visited[r][c]:
                continue
            color = grid[r][c]
            # BFS to collect component of this color
            q = deque([(r, c)])
            visited[r][c] = True
            pixels = []
            while q:
                cr, cc = q.popleft()
                pixels.append((cr, cc))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                        visited[nr][nc] = True
                        q.append((nr, nc))
            components.append((color, pixels))

    if not components:
        return grid

    # Choose the largest component as the source
    components.sort(key=lambda x: len(x[1]), reverse=True)
    source_color, source_pixels = components[0]

    # Arrow pixels are any non-bg pixels of colors different from source_color
    arrow_pixels = []
    for color, pixels in components[1:]:
        arrow_pixels.extend(pixels)

    # Compute source bounding box
    r_min = min(r for r, c in source_pixels)
    r_max = max(r for r, c in source_pixels)
    c_min = min(c for r, c in source_pixels)
    c_max = max(c for r, c in source_pixels)
    source_h = r_max - r_min + 1
    source_w = c_max - c_min + 1

    # Compute arrow bounding box
    if not arrow_pixels:
        # nothing to do
        return grid
    ar_min_r = min(r for r, c in arrow_pixels)
    ar_max_r = max(r for r, c in arrow_pixels)
    ar_min_c = min(c for r, c in arrow_pixels)
    ar_max_c = max(c for r, c in arrow_pixels)

    # Determine direction by comparing arrow bbox to source bbox
    if ar_min_c > c_max:
        direction = 'right'
    elif ar_max_c < c_min:
        direction = 'left'
    elif ar_min_r > r_max:
        direction = 'down'
    else:
        direction = 'up'

    # Prepare to place copies on a working output grid (start with input preserved)
    out = [row[:] for row in grid]

    prev_w, prev_h = source_w, source_h
    prev_left, prev_top = c_min, r_min
    first = True
    k = 1

    # Arrow bbox tuple (top,bottom,left,right)
    arrow_bbox = (ar_min_r, ar_max_r, ar_min_c, ar_max_c)

    while True:
        new_w = prev_w - 1
        new_h = prev_h - 1
        if new_w <= 0 or new_h <= 0:
            break

        if first:
            if direction == 'right':
                c_new = arrow_bbox[3] + 1
                r_new = r_min + (source_h - new_h) // 2
            elif direction == 'left':
                c_new = arrow_bbox[2] - new_w
                r_new = r_min + (source_h - new_h) // 2
            elif direction == 'down':
                r_new = arrow_bbox[1] + 1
                c_new = c_min + (source_w - new_w) // 2
            else:  # up
                r_new = arrow_bbox[0] - new_h
                c_new = c_min + (source_w - new_w) // 2
        else:
            if direction == 'right':
                c_new = prev_left + prev_w
                r_new = r_min + (source_h - new_h) // 2
            elif direction == 'left':
                c_new = prev_left - new_w
                r_new = r_min + (source_h - new_h) // 2
            elif direction == 'down':
                r_new = prev_top + prev_h
                c_new = c_min + (source_w - new_w) // 2
            else:  # up
                r_new = prev_top - new_h
                c_new = c_min + (source_w - new_w) // 2

        # Bounds check
        if not (0 <= r_new and r_new + new_h <= height and 0 <= c_new and c_new + new_w <= width):
            break

        # Overlap check
        overlap = False
        for rr in range(r_new, r_new + new_h):
            for cc in range(c_new, c_new + new_w):
                if out[rr][cc] != bg:
                    overlap = True
                    break
            if overlap:
                break
        if overlap:
            break

        # Choose cyclic color relative to source and skip colors that would create 4-neighbor conflicts
        candidate = ((source_color + k - 1) % 9) + 1
        tried = 0
        found = False
        while tried < 9:
            conflict = False
            for rr in range(r_new, r_new + new_h):
                for cc in range(c_new, c_new + new_w):
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = rr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width:
                            if out[nr][nc] == candidate:
                                conflict = True
                                break
                    if conflict:
                        break
                if conflict:
                    break
            if not conflict:
                found = True
                break
            candidate = (candidate % 9) + 1
            tried += 1

        if not found:
            break

        # Paint
        for rr in range(r_new, r_new + new_h):
            for cc in range(c_new, c_new + new_w):
                out[rr][cc] = candidate

        prev_w, prev_h = new_w, new_h
        prev_left, prev_top = c_new, r_new
        first = False
        k += 1

    return out

