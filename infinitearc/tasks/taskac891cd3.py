# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: ac891cd3
Difficulty: medium–hard

=== Tags ===
- Symmetry completion
- Directed cave maze
- Friction path
- Create grid
- Paint outer ring

=== Description ===
Input grids depict a maze-like cave structure where walls are represented by
color 1 and directional paths by color 2. The maze is asymmetric, with
incomplete directional paths on one side of the vertical midline and no
corresponding paths on the opposite side. Background cells (color 0) surround
the maze. The directional paths imply movement constraints: paths flow in
consistent directions (e.g., rightward on the left side), and mirroring must
reverse these directions (e.g., rightward paths become leftward on the mirrored
side). The output grid completes the maze to achieve vertical symmetry by
reflecting path segments from one side to the other with directionally adjusted
movement. Additionally, all border cells (first/last rows and columns) are
repainted with a uniform color 3, overriding any existing colors in these
positions. The completed maze must maintain continuous, non-overlapping paths
with consistent directionality, and the outer ring must form a solid, unbroken
border. No numerical calculations or pixel-level matching are required—only
visual symmetry, directional logic, and border painting.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = random.randint(9, 30)
    if width % 2 == 0:
        width -= 1
    height = random.randint(9, 30)
    if height % 2 == 0:
        height -= 1
    mid = (width - 1) // 2
    input_grid = common.grid(width, height, 0)
    output_grid = common.grid(width, height, 0)
    path_start = random.randint(1, mid - 3)
    path_end = random.randint(path_start + 1, mid - 2)
    path_row = random.randint(0, height - 1)
    for c in range(path_start, path_end):
        input_grid[path_row][c] = 2
    for r in range(1, height):
        for c in range(1, mid - 1):
            if random.random() > 0.6:
                input_grid[r][c] = 1
    for r in range(height):
        for c in range(1, mid - 1):
            if input_grid[r][c] == 2:
                output_grid[r][width - 1 - c] = 2
    for c in range(width):
        output_grid[0][c] = 3
        output_grid[height - 1][c] = 3
    for r in range(height):
        output_grid[r][0] = 3
        output_grid[r][width - 1] = 3
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    mid = (width - 1) // 2
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(mid):
            if input_grid[r][c] == 2:
                output_grid[r][width - 1 - c] = 2
    for c in range(width):
        output_grid[0][c] = 3
        output_grid[height - 1][c] = 3
    for r in range(height):
        output_grid[r][0] = 3
        output_grid[r][width - 1] = 3
    return output_grid
