# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: fa644b64
Difficulty: medium–hard

=== Tags ===
- Cave escape
- Blockwise rule application
- Truth table visualization
- Swap positions of two objects

=== Description ===
Input grids feature a cave-like maze structure composed of walls (solid blocks
of a single color) on a background color, with two distinct colored objects
positioned within the maze. A truth table visualization is embedded in the top-
left corner as a 2×2 grid, where the top row represents input A (left to right:
0, 1), the left column represents input B (top to bottom: 0, 1), and the bottom-
right cell contains a color that indicates whether the two objects should be
swapped (e.g., color 5 signifies "swap," color 0 signifies "no swap"). The
output grid swaps the positions of the two objects if the truth table's output
cell matches the "swap" color; otherwise, the objects remain unchanged. All
other elements—including the cave structure, background, and truth table
visualization—remain identical between input and output. The task requires
recognizing the truth table structure, identifying the output cell's color, and
applying the swap conditionally based on visual color cues rather than numerical
values.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = [[0] * width for _ in range(height)]
    
    # Set truth table at top-left
    grid[0][0] = 0
    grid[0][1] = 0
    grid[1][0] = 0
    grid[1][1] = 5
    
    # Place walls avoiding truth table area
    wall_color = 1
    total_cells = width * height
    num_walls = random.randint(int(total_cells * 0.2), int(total_cells * 0.5))
    exclude_cells = {(0,0), (0,1), (1,0), (1,1)}
    all_cells = [(r, c) for r in range(height) for c in range(width) if (r, c) not in exclude_cells]
    wall_positions = random.sample(all_cells, min(num_walls, len(all_cells)))
    for r, c in wall_positions:
        grid[r][c] = wall_color
    
    # Find empty cells outside truth table
    empty_cells = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == 0 and (r, c) not in exclude_cells]
    if len(empty_cells) < 2:
        empty_cells = []
        for r in range(2, height-2):
            for c in range(2, width-2):
                if grid[r][c] == 0:
                    empty_cells.append((r, c))
        if len(empty_cells) < 2:
            return generate()
    
    pos1, pos2 = random.sample(empty_cells, 2)
    obj1_color = 2
    obj2_color = 3
    grid[pos1[0]][pos1[1]] = obj1_color
    grid[pos2[0]][pos2[1]] = obj2_color
    
    output_grid = [row[:] for row in grid]
    r1, c1 = pos1
    r2, c2 = pos2
    output_grid[r1][c1], output_grid[r2][c2] = output_grid[r2][c2], output_grid[r1][c1]
    
    return {
        "input": grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    if grid[1][1] == 5:
        pos2 = None
        pos3 = None
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                if grid[r][c] == 2:
                    pos2 = (r, c)
                elif grid[r][c] == 3:
                    pos3 = (r, c)
        if pos2 is not None and pos3 is not None:
            grid[pos2[0]][pos2[1]], grid[pos3[0]][pos3[1]] = 3, 2
    return tuple(tuple(row) for row in grid)
