# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: caf261e8
Difficulty: very hard

=== Tags ===
- Portal momentum pathing
- Color modulated motion
- Repulsion and bounce

=== Description ===
Input grids feature a background color (e.g., gray) with multiple colored
objects (e.g., red, blue, green, yellow) placed at distinct positions, each
color corresponding to a fixed movement direction (red: right, blue: down,
green: left, yellow: up). Additionally, grids contain paired portal markers
(e.g., two purple cells labeled "entrance" and "exit") and static wall segments
(e.g., orange blocks). Objects move simultaneously in their direction per time
step. If an object encounters a wall or grid boundary, it reverses direction. If
an object enters a portal "entrance," it immediately teleports to the paired
"exit" portal and continues moving in the same direction. If two objects would
occupy the same cell after movement, they repel each other, reversing direction
for subsequent steps. Walls and portals do not change position. The output grid
displays the final positions of all objects after resolving all movement,
teleportation, reflection, and repulsion rules in a single step, with the
background remaining unchanged. The task requires identifying color-direction
mappings, portal pairs, wall interactions, and collision resolution
simultaneously to derive the output configuration.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, randint, choice

def generate():
    # Color codes
    BG = 5
    WALL = 7
    PORTAL = 6
    OBJECT_COLORS = [1, 2, 3, 4]

    # Random size
    width = randint(5, 20)
    height = randint(5, 20)
    ingrid = grid(width, height, BG)

    # Place a few short wall segments (horizontal or vertical)
    walls_placed = 0
    max_walls = randint(2, 5)
    attempts = 0
    while walls_placed < max_walls and attempts < 200:
        attempts += 1
        is_horizontal = randint(0, 1)
        length = randint(1, 3)
        if is_horizontal:
            row = randint(0, height - 1)
            start_col = randint(0, max(0, width - length))
            # ensure the cells are free
            ok = True
            for col in range(start_col, start_col + length):
                if ingrid[row][col] != BG:
                    ok = False
                    break
            if not ok:
                continue
            for col in range(start_col, start_col + length):
                ingrid[row][col] = WALL
            walls_placed += 1
        else:
            col = randint(0, width - 1)
            start_row = randint(0, max(0, height - length))
            ok = True
            for row in range(start_row, start_row + length):
                if ingrid[row][col] != BG:
                    ok = False
                    break
            if not ok:
                continue
            for row in range(start_row, start_row + length):
                ingrid[row][col] = WALL
            walls_placed += 1

    # Place exactly two portals (entrance/exit pair)
    portal_count = 0
    attempts = 0
    while portal_count < 2 and attempts < 500:
        attempts += 1
        r = randint(0, height - 1)
        c = randint(0, width - 1)
        if ingrid[r][c] == BG:
            ingrid[r][c] = PORTAL
            portal_count += 1

    # Place some moving objects on background cells
    num_objects = randint(3, 8)
    placed = 0
    attempts = 0
    while placed < num_objects and attempts < 1000:
        attempts += 1
        r = randint(0, height - 1)
        c = randint(0, width - 1)
        if ingrid[r][c] == BG:
            ingrid[r][c] = choice(OBJECT_COLORS)
            placed += 1

    # Collect objects and portals in row-major order to make behavior deterministic
    object_positions = []
    portal_positions = []
    for r in range(height):
        for c in range(width):
            v = ingrid[r][c]
            if v in OBJECT_COLORS:
                object_positions.append((r, c, v))
            elif v == PORTAL:
                portal_positions.append((r, c))

    # If placement failed to create required features, try again
    if len(portal_positions) != 2 or len(object_positions) == 0:
        return generate()

    # Prepare output grid
    output_grid = [row[:] for row in ingrid]

    # Mapping: color -> movement direction (row delta, col delta)
    directions = {
        1: (1, 0),   # down
        2: (0, 1),   # right
        3: (0, -1),  # left
        4: (-1, 0)   # up
    }

    # First compute tentative next positions after one simultaneous step
    next_positions = []
    for (r, c, color) in object_positions:
        dr, dc = directions[color]
        nr, nc = r + dr, c + dc
        # Bounce off walls or boundaries: reverse direction once
        if nr < 0 or nr >= height or nc < 0 or nc >= width or ingrid[nr][nc] == WALL:
            dr, dc = -dr, -dc
            nr, nc = r + dr, c + dc
            if nr < 0 or nr >= height or nc < 0 or nc >= width or ingrid[nr][nc] == WALL:
                nr, nc = r, c
        # Portal teleportation: if landing on portal, teleport to paired exit and step one cell further
        if ingrid[nr][nc] == PORTAL:
            if (nr, nc) == portal_positions[0]:
                exit_r, exit_c = portal_positions[1]
            else:
                exit_r, exit_c = portal_positions[0]
            nr, nc = exit_r + dr, exit_c + dc
            if nr < 0 or nr >= height or nc < 0 or nc >= width or ingrid[nr][nc] == WALL:
                dr, dc = -dr, -dc
                nr, nc = exit_r + dr, exit_c + dc
                if nr < 0 or nr >= height or nc < 0 or nc >= width or ingrid[nr][nc] == WALL:
                    nr, nc = exit_r, exit_c
        next_positions.append((nr, nc, color))

    # Detect collisions (multiple objects targeting same cell) and apply simple repulsion rule
    collision_positions = {}
    for (nr, nc, color) in next_positions:
        collision_positions.setdefault((nr, nc), []).append(color)

    # For each collision, find the first object of the colliding color (in scan order) and move it backwards
    for (nr, nc), colors in collision_positions.items():
        if len(colors) > 1:
            for color in colors:
                for idx, (r, c, col) in enumerate(object_positions):
                    if col == color:
                        dr, dc = directions[color]
                        dr, dc = -dr, -dc
                        nr_new, nc_new = r + dr, c + dc
                        if nr_new < 0 or nr_new >= height or nc_new < 0 or nc_new >= width or ingrid[nr_new][nc_new] == WALL:
                            dr, dc = -dr, -dc
                            nr_new, nc_new = r + dr, c + dc
                            if nr_new < 0 or nr_new >= height or nc_new < 0 or nc_new >= width or ingrid[nr_new][nc_new] == WALL:
                                nr_new, nc_new = r, c
                        next_positions[idx] = (nr_new, nc_new, color)
                        break

    # Clear original object positions and write final positions
    for (r, c, color) in object_positions:
        output_grid[r][c] = BG
    for (nr, nc, color) in next_positions:
        output_grid[nr][nc] = color

    # Ensure we actually changed something
    if ingrid == output_grid:
        return generate()

    return {"input": ingrid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])

    BG = 5
    WALL = 7
    PORTAL = 6
    OBJECT_COLORS = [1, 2, 3, 4]

    # Collect objects, portals, and walls in row-major order to match generator's ordering
    objects = []
    portals = []
    walls = []
    for r in range(height):
        for c in range(width):
            v = input_grid[r][c]
            if v in OBJECT_COLORS:
                objects.append((r, c, v))
            elif v == PORTAL:
                portals.append((r, c))
            elif v == WALL:
                walls.append((r, c))

    # Direction mapping must match the generator
    directions = {
        1: (1, 0),   # down
        2: (0, 1),   # right
        3: (0, -1),  # left
        4: (-1, 0)   # up
    }

    # Compute tentative next positions
    next_positions = []
    for (r, c, color) in objects:
        dr, dc = directions[color]
        nr, nc = r + dr, c + dc
        if nr < 0 or nr >= height or nc < 0 or nc >= width or input_grid[nr][nc] == WALL:
            dr, dc = -dr, -dc
            nr, nc = r + dr, c + dc
            if nr < 0 or nr >= height or nc < 0 or nc >= width or input_grid[nr][nc] == WALL:
                nr, nc = r, c
        if input_grid[nr][nc] == PORTAL:
            # teleport to the paired portal and step one cell further
            if (nr, nc) == portals[0]:
                exit_r, exit_c = portals[1]
            else:
                exit_r, exit_c = portals[0]
            nr, nc = exit_r + dr, exit_c + dc
            if nr < 0 or nr >= height or nc < 0 or nc >= width or input_grid[nr][nc] == WALL:
                dr, dc = -dr, -dc
                nr, nc = exit_r + dr, exit_c + dc
                if nr < 0 or nr >= height or nc < 0 or nc >= width or input_grid[nr][nc] == WALL:
                    nr, nc = exit_r, exit_c
        next_positions.append((nr, nc, color))

    # Detect collisions
    collision_positions = {}
    for (nr, nc, color) in next_positions:
        collision_positions.setdefault((nr, nc), []).append(color)

    # Resolve collisions using the same (color-based, scan-ordered) rule as the generator
    for (nr, nc), colors in collision_positions.items():
        if len(colors) > 1:
            for color in colors:
                for idx, (r, c, col) in enumerate(objects):
                    if col == color:
                        dr, dc = directions[color]
                        dr, dc = -dr, -dc
                        nr_new, nc_new = r + dr, c + dc
                        if nr_new < 0 or nr_new >= height or nc_new < 0 or nc_new >= width or input_grid[nr_new][nc_new] == WALL:
                            dr, dc = -dr, -dc
                            nr_new, nc_new = r + dr, c + dc
                            if nr_new < 0 or nr_new >= height or nc_new < 0 or nc_new >= width or input_grid[nr_new][nc_new] == WALL:
                                nr_new, nc_new = r, c
                        next_positions[idx] = (nr_new, nc_new, color)
                        break

    # Build output grid: background, then walls, portals, objects
    output_grid = [[BG for _ in range(width)] for _ in range(height)]
    for (r, c) in walls:
        output_grid[r][c] = WALL
    for (r, c) in portals:
        output_grid[r][c] = PORTAL
    for (nr, nc, color) in next_positions:
        output_grid[nr][nc] = color

    return output_grid

