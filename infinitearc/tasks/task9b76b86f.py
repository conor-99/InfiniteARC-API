# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 9b76b86f
Difficulty: insane

=== Tags ===
- Propagate label
- Recursive agent following
- Pathfinding with state
- Topological invariance

=== Description ===
**Task: Recursive Label Propagation**    **Tags:** Propagate label, Recursive
agent following, Pathfinding with state, Topological invariance
**Description:**    Input grids feature a background color (0) and a complex
arrangement of directional indicators (colors 1–4, representing right, down,
left, up) interspersed with seed markers (colors 5–9). Each seed marker color
encodes both a unique propagation label (the seed’s color) and an initial
direction (determined by seed color modulo 4: 5→right, 6→down, 7→left, 8→up,
9→right).    The output grid is generated by simulating recursive agent
traversal from each seed marker. The agent starts at the seed cell (color *S*),
moves in the initial direction, and continues traversing background cells (0) by
following the direction indicated by each visited cell (1–4). Each cell along
the path, including the seed, is marked with the seed’s label *S*. Traversal
terminates when the agent encounters non-background cells (1–9), exits the grid,
or revisits a cell.    Crucially, propagation is confined to the topological
region of the background (0 cells), defined as the maximal connected component
(via 4-adjacency) containing the seed’s starting position. Non-background cells
(direction indicators and seed markers) remain unchanged. Topological invariance
ensures the boundaries of background regions (enclosed by non-background cells)
are preserved in the output, with propagation never crossing region boundaries.
Pathfinding with state is implemented through dynamic direction updates based on
cell content, creating recursive paths that meander through regions while
adhering to direction constraints.    This task demands recognition of
topological structure, interpretation of direction-based path rules, and
sequential label propagation within constrained regions, requiring multiple
layered inductive steps to resolve.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Generator for ARC task 403 - Recursive Label Propagation (fixed)

def generate():
    # Grid size varies to encourage uniqueness across many calls
    width = random.randint(7, 20)
    height = random.randint(7, 20)
    ingrid = grid(width, height, 0)

    # Direction mapping: 1=right, 2=down, 3=left, 4=up
    dr = [0, 1, 0, -1]
    dc = [1, 0, -1, 0]

    occupied = set()  # cells already used for seeds or path arrows
    seeds = []  # list of (r, c, color)

    seed_colors_pool = [5, 6, 7, 8, 9]
    num_seeds = random.randint(2, min(5, max(2, (width * height) // 50 + 2)))
    seed_colors = random.sample(seed_colors_pool, num_seeds)

    # Helper to check bounds
    def in_bounds(r, c):
        return 0 <= r < height and 0 <= c < width

    # Try to place several seeds with small chains of direction-arrows
    for color in seed_colors:
        placed = False
        tries = 0
        while not placed and tries < 200:
            tries += 1
            # Pick a seed location not yet occupied and with some space
            r = random.randint(0, height - 1)
            c = random.randint(0, width - 1)
            if (r, c) in occupied:
                continue
            # keep seeds a bit separated to avoid collisions
            too_close = False
            for (sr, sc, _) in seeds:
                if abs(sr - r) < 3 and abs(sc - c) < 3:
                    too_close = True
                    break
            if too_close:
                continue

            # Determine initial direction from seed color
            d0 = (color - 5) % 4
            nr = r + dr[d0]
            nc = c + dc[d0]
            if not in_bounds(nr, nc):
                continue
            if (nr, nc) in occupied:
                continue

            # Attempt to grow a short random chain starting at (nr, nc)
            max_chain = random.randint(1, max(1, min(10, (width + height) // 3)))
            path = []
            cur_r, cur_c = nr, nc
            temp_occupied = set(occupied)
            temp_occupied.add((r, c))  # seed cell considered occupied
            success = True
            for step in range(max_chain):
                # if current position already used, abort
                if (cur_r, cur_c) in temp_occupied:
                    success = False
                    break
                path.append((cur_r, cur_c))
                temp_occupied.add((cur_r, cur_c))
                # build list of free neighbors for next step (avoid going back immediately)
                nbrs = []
                for nd in range(4):
                    rr = cur_r + dr[nd]
                    cc = cur_c + dc[nd]
                    if not in_bounds(rr, cc):
                        continue
                    if (rr, cc) in temp_occupied:
                        continue
                    nbrs.append((rr, cc))
                if not nbrs:
                    # chain terminates early
                    break
                # choose next cell randomly
                cur_r, cur_c = random.choice(nbrs)

            if not success or len(path) == 0:
                continue

            # For last path cell we need a direction that points to a non-arrow cell (so traversal will stop there)
            last_r, last_c = path[-1]
            possible_last_dirs = []
            for nd in range(4):
                rr = last_r + dr[nd]
                cc = last_c + dc[nd]
                # either out of bounds (agent would stop) or a free zero cell (no arrow there) is acceptable
                if not in_bounds(rr, cc):
                    possible_last_dirs.append(nd)
                else:
                    if (rr, cc) not in temp_occupied:
                        possible_last_dirs.append(nd)
            if not possible_last_dirs:
                # can't make a last direction that stops, try different seed location
                continue

            # All good: commit seed and path to the grid
            # mark seed
            ingrid[r][c] = color
            occupied.add((r, c))
            seeds.append((r, c, color))

            # set direction values for path cells
            for i in range(len(path)):
                pr, pc = path[i]
                if i < len(path) - 1:
                    # point to next path cell
                    nr2, nc2 = path[i + 1]
                    # compute direction index from (pr,pc) to (nr2,nc2)
                    for nd in range(4):
                        if pr + dr[nd] == nr2 and pc + dc[nd] == nc2:
                            ingrid[pr][pc] = nd + 1
                            break
                else:
                    # last element: pick a direction that leads outside or to a free zero cell
                    nd = random.choice(possible_last_dirs)
                    ingrid[pr][pc] = nd + 1
                occupied.add((pr, pc))

            placed = True

        # if we failed to place this seed after many tries, just skip it

    # Sort seeds by row-major order so deterministic labeling order matches solver scan order
    seeds.sort(key=lambda t: (t[0], t[1]))

    # Prepare output by simulating the label propagation from each seed (in sorted order)
    output_grid = [row[:] for row in ingrid]

    for (sr, sc, color) in seeds:
        d = (color - 5) % 4
        visited = set()
        # include the seed itself as visited and labeled
        visited.add((sr, sc))
        cur_r, cur_c = sr, sc
        while True:
            nr = cur_r + dr[d]
            nc = cur_c + dc[d]
            if not in_bounds(nr, nc):
                break
            val = ingrid[nr][nc]
            # can only continue if next cell is a direction arrow (1..4)
            if not (1 <= val <= 4):
                break
            if (nr, nc) in visited:
                break
            visited.add((nr, nc))
            cur_r, cur_c = nr, nc
            # update direction according to the arrow placed at that cell
            d = val - 1

        # label all visited cells (including the seed)
        for (r, c) in visited:
            output_grid[r][c] = color

    return {"input": ingrid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height else 0

    # Direction mapping: 1=right, 2=down, 3=left, 4=up
    dr = [0, 1, 0, -1]
    dc = [1, 0, -1, 0]

    # Prepare output as copy
    output = [row[:] for row in grid]

    def in_bounds(r, c):
        return 0 <= r < height and 0 <= c < width

    # Find seeds (colors 5..9) and simulate propagation for each
    seeds = []
    for r in range(height):
        for c in range(width):
            val = grid[r][c]
            if 5 <= val <= 9:
                seeds.append((r, c, val))

    for (sr, sc, color) in seeds:
        d = (color - 5) % 4
        visited = set()
        visited.add((sr, sc))
        cur_r, cur_c = sr, sc
        while True:
            nr = cur_r + dr[d]
            nc = cur_c + dc[d]
            if not in_bounds(nr, nc):
                break
            cell_val = grid[nr][nc]
            if not (1 <= cell_val <= 4):
                break
            if (nr, nc) in visited:
                break
            visited.add((nr, nc))
            cur_r, cur_c = nr, nc
            d = cell_val - 1

        # Label visited cells in the output
        for (r, c) in visited:
            output[r][c] = color

    return output

