# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 734a389f
Difficulty: hard

=== Tags ===
- Field interference pattern
- Obstacles
- Portals

=== Description ===
Input grids feature two distinct, contiguous field patterns (each represented by
a unique non-zero color) that intersect in complex ways across the grid, forming
an interference pattern. Obstacles (color 1) are scattered throughout, blocking
certain cells and preventing interference at those locations. The fields may
have intricate, non-linear shapes but must remain single contiguous regions
(connected orthogonally).   The transformation rule requires identifying all
cells that belong to both field patterns (i.e., overlapping regions) while
excluding any cells occupied by obstacles. These intersection points are marked
as portals (color 4) in the output grid. All other cells retain their original
colors from the input, including obstacles (color 1) and non-overlapping field
regions (colors 2 and 3).   For example, if field A (color 2) forms a jagged
horizontal wave and field B (color 3) forms a diagonal spiral, their overlapping
cells (not blocked by obstacles) become portals. The output grid visually
highlights these interference points while preserving the original structure of
the fields and obstacles. This task demands precise pattern recognition of the
fields, accurate computation of their intersection, and careful handling of
obstacle constraints, making it challenging due to the complexity of field
shapes and the need for multi-step spatial reasoning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Helper: orthogonal neighbors
def orth_neighbors(cell, width, height):
    r, c = cell
    for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):
        nr, nc = r+dr, c+dc
        if 0 <= nr < height and 0 <= nc < width:
            yield (nr, nc)


def make_region(target_size, width, height, blocked, start=None):
    """Grow a contiguous orthogonally-connected region avoiding blocked cells.

    Returns a set of coordinates. The returned size may be smaller than
    target_size if constrained by obstacles or boundaries.
    """
    free = set((r, c) for r in range(height) for c in range(width) if (r, c) not in blocked)
    if not free:
        return set()
    if start is None or start not in free:
        start = random.choice(list(free))
    region = [start]
    region_set = set(region)
    # frontier contains reachable neighbors of current region
    frontier = []
    for nb in orth_neighbors(start, width, height):
        if nb in free and nb not in region_set and nb not in frontier:
            frontier.append(nb)
    # Grow until we reach the desired size or no frontier remains
    while len(region) < target_size and frontier:
        idx = random.randrange(len(frontier))
        cell = frontier.pop(idx)
        if cell in region_set:
            continue
        region.append(cell)
        region_set.add(cell)
        for nb in orth_neighbors(cell, width, height):
            if nb in free and nb not in region_set and nb not in frontier:
                frontier.append(nb)
    return region_set


def generate():
    # Dimensions (kept moderate but variable for complexity)
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    area = width * height

    # Place obstacles first so regions must navigate around them.
    # Keep obstacle density modest so regions can still grow.
    min_obs = max(3, area // 40)
    max_obs = max(5, area // 8)
    obstacle_count = random.randint(min_obs, max_obs)
    all_cells = [(r, c) for r in range(height) for c in range(width)]
    obstacles = set(random.sample(all_cells, min(obstacle_count, len(all_cells))))

    free_count = area - len(obstacles)
    # Choose reasonable region sizes relative to free space
    min_region = max(6, int(area * 0.06))
    max_region = max(min_region, int(area * 0.22))
    # Ensure sizes do not exceed available free cells
    size_A = random.randint(min_region, min(max_region, max(1, free_count)))
    size_B = random.randint(min_region, min(max_region, max(1, free_count)))

    # Generate Field A avoiding obstacles
    S_A = make_region(size_A, width, height, obstacles)
    # If A generation failed to produce at least one cell, pick a free start cell
    if not S_A:
        # choose any non-obstacle cell
        S_A = {random.choice([c for c in all_cells if c not in obstacles])}

    # Generate Field B ensuring at least one overlapping cell with A
    # Start B from a random cell inside A so overlap is guaranteed
    start_B = random.choice(list(S_A))
    S_B = make_region(size_B, width, height, obstacles, start=start_B)
    if not S_B:
        S_B = {start_B}

    # Compose input grid:
    # 0 background, 1 obstacles, 2 field A only, 3 field B only, 5 intersection (both)
    input_grid = grid(width, height, 0)
    for r, c in obstacles:
        input_grid[r][c] = 1

    inter = S_A & S_B
    onlyA = S_A - S_B
    onlyB = S_B - S_A

    for (r, c) in onlyA:
        input_grid[r][c] = 2
    for (r, c) in onlyB:
        input_grid[r][c] = 3
    for (r, c) in inter:
        # Intersection marked specially in input so solver can detect portals
        input_grid[r][c] = 5

    # Create output: same as input but 5 -> 4 (portals) and leave everything else unchanged
    output_grid = [row[:] for row in input_grid]
    for r, c in inter:
        output_grid[r][c] = 4

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input (tuple of tuples) into mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0
    # Intersection cells are encoded as 5 in the input; mark them as portals (4)
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 5:
                grid[r][c] = 4
    return grid

