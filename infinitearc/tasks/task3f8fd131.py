# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 3f8fd131
Difficulty: hard

=== Tags ===
- Cyclic painting
- Follow color path to destination
- Pattern concatenation
- Recursive path tracing
- Reflect across detected axis

=== Description ===
Input grids feature a background color (0) with a continuous, non-background
path composed of colors 1-8. The path traverses adjacent cells (4-directionally)
from a start point to an endpoint, potentially crossing a single mirror axis—a
straight horizontal or vertical line of color 9 (the only line of this color)
spanning at least two cells. The mirror axis is not part of the path.   To
generate the output grid, first detect the mirror axis (color 9 line). At each
crossing of the mirror axis, reflect the path’s direction: for a horizontal
mirror axis (row of color 9), reverse the vertical direction (up ↔ down); for a
vertical mirror axis (column of color 9), reverse the horizontal direction (left
↔ right). The path continues in the reflected direction after each crossing,
ultimately forming a closed cyclic loop. The mirror axis remains visible in the
output, and background cells (0) stay unchanged. The output displays the path
with all reflections applied, creating a cyclic pattern where the path
concatenates original and reflected segments through recursive traversal.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

# Generator for ARC task 457 (revised again)
# This version guarantees that the reflected concatenation forms a closed loop by
# constructing a path that ends with a step into the mirror axis at a column/row
# where the mirror segment is absent. The path is built deterministically as a
# Manhattan path from a top-left-ish start to the crossing cell so that the
# solver can identify the start endpoint deterministically (lexicographically minimal).


def generate():
    for attempt in range(300):
        width = random.randint(15, 25)
        height = random.randint(15, 25)
        grid_in = [[0 for _ in range(width)] for _ in range(height)]
        grid_out = [[0 for _ in range(width)] for _ in range(height)]

        horizontal = random.choice([True, False])

        if horizontal:
            mirror_row = random.randint(4, height - 5)
            mirror_start = random.randint(2, max(2, width - 6))
            mirror_end = random.randint(mirror_start + 1, min(width - 3, mirror_start + random.randint(1, max(2, width // 3))))
            for c in range(mirror_start, mirror_end + 1):
                grid_in[mirror_row][c] = 9
                grid_out[mirror_row][c] = 9

            # Choose a crossing column that is NOT part of the mirror segment
            possible_cross = [c for c in range(1, width - 1) if not (mirror_start <= c <= mirror_end)]
            if not possible_cross:
                continue
            cross_c = random.choice(possible_cross)

            # Choose a start above the axis; pick a top-left-ish start to make it lexicographically minimal
            max_offset = min(mirror_row - 2, height - 1 - mirror_row)
            if max_offset < 1:
                continue
            start_row = max(1, mirror_row - max_offset)
            start_col = 1
            if grid_in[start_row][start_col] == 9:
                start_col = 2

            # Build a Manhattan path from (start_row,start_col) to (mirror_row-1, cross_c)
            path = []
            r, c = start_row, start_col
            path.append((r, c))

            # Move vertically down until just above the axis
            while r < mirror_row - 1:
                r += 1
                if grid_in[r][c] == 9:
                    break
                path.append((r, c))

            # Move horizontally toward cross_c
            while c != cross_c:
                if c < cross_c:
                    c += 1
                else:
                    c -= 1
                if grid_in[r][c] == 9:
                    break
                path.append((r, c))

            # Final step: into the axis row at cross_c (ensure that position isn't a mirror 9)
            if grid_in[mirror_row][cross_c] == 9:
                continue
            # Add the final crossing cell
            path.append((mirror_row, cross_c))

        else:
            mirror_col = random.randint(4, width - 5)
            mirror_start = random.randint(2, max(2, height - 6))
            mirror_end = random.randint(mirror_start + 1, min(height - 3, mirror_start + random.randint(1, max(2, height // 3))))
            for r in range(mirror_start, mirror_end + 1):
                grid_in[r][mirror_col] = 9
                grid_out[r][mirror_col] = 9

            possible_cross = [r for r in range(1, height - 1) if not (mirror_start <= r <= mirror_end)]
            if not possible_cross:
                continue
            cross_r = random.choice(possible_cross)

            max_offset = min(mirror_col - 2, width - 1 - mirror_col)
            if max_offset < 1:
                continue
            start_col = max(1, mirror_col - max_offset)
            start_row = 1
            if grid_in[start_row][start_col] == 9:
                start_row = 2

            # Build Manhattan path from (start_row, start_col) to (cross_r, mirror_col-1)
            path = []
            r, c = start_row, start_col
            path.append((r, c))

            # Move horizontally toward just-left-of-axis
            while c < mirror_col - 1:
                c += 1
                if grid_in[r][c] == 9:
                    break
                path.append((r, c))
            while c > mirror_col - 1:
                c -= 1
                if grid_in[r][c] == 9:
                    break
                path.append((r, c))

            # Move vertically toward cross_r
            while r != cross_r:
                if r < cross_r:
                    r += 1
                else:
                    r -= 1
                if grid_in[r][c] == 9:
                    break
                path.append((r, c))

            # Final step: into the axis column at cross_r (ensure not a mirror 9)
            if grid_in[cross_r][mirror_col] == 9:
                continue
            path.append((cross_r, mirror_col))

        # Basic validity checks
        if len(path) < 3:
            continue

        # Color for the whole path
        color = random.randint(1, 8)
        for r, c in path:
            grid_in[r][c] = color
            grid_out[r][c] = color

        # Compute reflection (exclude last point) and draw into output if not a mirror
        reflected = []
        if horizontal:
            for r, c in path[:-1]:
                new_r = 2 * mirror_row - r
                if 0 <= new_r < height and grid_out[new_r][c] == 0:
                    grid_out[new_r][c] = color
                    reflected.append((new_r, c))
        else:
            for r, c in path[:-1]:
                new_c = 2 * mirror_col - c
                if 0 <= new_c < width and grid_out[r][new_c] == 0:
                    grid_out[r][new_c] = color
                    reflected.append((r, new_c))

        # Ensure mirror cells remain visible
        # grid_out already has 9s set

        if grid_in != grid_out:
            return {"input": grid_in, "output": grid_out}

    return {"input": grid_in, "output": grid_out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Detect mirror cells
    mirror_cells = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == 9]
    mirror_row = None
    mirror_col = None
    if mirror_cells:
        rows = {r for r, _ in mirror_cells}
        cols = {c for _, c in mirror_cells}
        if len(rows) == 1:
            mirror_row = next(iter(rows))
        elif len(cols) == 1:
            mirror_col = next(iter(cols))
        else:
            if len(rows) <= len(cols):
                mirror_row = next(iter(rows))
            else:
                mirror_col = next(iter(cols))

    # Gather path cells
    path_cells = {(r, c) for r in range(height) for c in range(width) if 1 <= grid[r][c] <= 8}

    # Find endpoints and choose lexicographically minimal as start
    endpoints = []
    for (r, c) in path_cells:
        neighbors = 0
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            if (r + dr, c + dc) in path_cells:
                neighbors += 1
        if neighbors == 1:
            endpoints.append((r, c))
    if endpoints:
        start = min(endpoints)
    else:
        if not path_cells:
            return grid
        start = min(path_cells)

    # Trace the path
    path = []
    visited = set()
    cur = start
    while cur is not None:
        path.append(cur)
        visited.add(cur)
        r, c = cur
        nxt = None
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if (nr, nc) in path_cells and (nr, nc) not in visited:
                nxt = (nr, nc)
                break
        cur = nxt

    # Compute reflection (exclude last cell as generator does)
    reflected = []
    if mirror_row is not None:
        for r, c in path[:-1]:
            new_r = 2 * mirror_row - r
            if 0 <= new_r < height:
                # Do not overwrite the mirror
                if grid[new_r][c] != 9:
                    reflected.append((new_r, c))
    elif mirror_col is not None:
        for r, c in path[:-1]:
            new_c = 2 * mirror_col - c
            if 0 <= new_c < width:
                if grid[r][new_c] != 9:
                    reflected.append((r, new_c))

    # Build output
    output = [[0 for _ in range(width)] for _ in range(height)]
    for r, c in mirror_cells:
        output[r][c] = 9

    color = grid[start[0]][start[1]] if start is not None else 1
    for r, c in path:
        if output[r][c] != 9:
            output[r][c] = color
    for r, c in reflected:
        if output[r][c] != 9:
            output[r][c] = color

    return output

