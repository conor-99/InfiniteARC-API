# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 00b330a9
Difficulty: very hard

=== Tags ===
- Mirror bounce
- Line collision

=== Description ===
Input grids are large (20Ã—20) with a uniform background color. Overlaid are
horizontal and vertical mirror segments (each 1 cell thick) of distinct non-
background colors, positioned to form a non-intersecting, non-touching network
across the grid. A single origin cell (marked by a unique color) is placed such
that a diagonal beam traveling northeast from it will interact with the mirror
network. The beam traverses background cells diagonally until colliding with a
mirror. Upon collision, the beam reflects according to the mirror's orientation
(horizontal mirrors cause vertical reflection, vertical mirrors cause horizontal
reflection), changes color to match the mirror's hue, and continues its path.
This reflection process repeats with each subsequent mirror collision. The
output grid retains all input elements but replaces the background cells along
the beam's path with the mirror color corresponding to the collision that
initiated that segment of the trajectory. The beam's path is drawn as a
continuous sequence of colored line segments, each segment's color determined by
the mirror it last reflected off, with no overlap of the beam trajectory with
existing mirrors or the origin point. The transformation requires detecting the
beam's initial direction, tracking its reflection sequence through the mirror
network, and mapping each reflection to the appropriate color change along the
path.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    size = 20
    max_global_attempts = 200
    for attempt in range(max_global_attempts):
        # Initialize empty background grid
        grid = [[0 for _ in range(size)] for _ in range(size)]
        used = set()  # occupied mirror cells

        # Number of mirror segments
        n_mirrors = random.randint(3, 6)
        # Pick distinct colors for origin + mirrors
        colors = random.sample(list(range(1, 10)), n_mirrors + 1)
        origin_color = colors[0]
        mirror_colors = colors[1:]

        mirrors = []  # store placed mirror metadata
        placement_failed = False

        # Helper to test proximity (no-touching including diagonals)
        def is_conflict(cells):
            for (r, c) in cells:
                if (r, c) in used:
                    return True
                for dr in (-1, 0, 1):
                    for dc in (-1, 0, 1):
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < size and 0 <= nc < size:
                            if (nr, nc) in used:
                                return True
            return False

        # Place each mirror
        for mi in range(n_mirrors):
            placed = False
            for _ in range(600):
                orientation = random.choice(["H", "V"])
                length = random.randint(2, 6)  # length >=2 to make orientation detectable
                if orientation == "H":
                    # choose a row that is not the extreme edges to give some buffer
                    r = random.randint(1, size - 2)
                    c = random.randint(0, size - length)
                    cells = [(r, c + i) for i in range(length)]
                else:
                    r = random.randint(0, size - length)
                    c = random.randint(1, size - 2)
                    cells = [(r + i, c) for i in range(length)]

                # ensure in bounds and not touching other mirrors
                if is_conflict(cells):
                    continue

                # Place the mirror cells
                color = mirror_colors[mi]
                for (rr, cc) in cells:
                    grid[rr][cc] = color
                    used.add((rr, cc))
                mirrors.append({"cells": cells, "orientation": orientation, "color": color})
                placed = True
                break
            if not placed:
                placement_failed = True
                break

        if placement_failed:
            continue

        # Now choose an origin cell such that a NE beam (dr=-1,dc=1) will encounter a mirror
        # at distance >=2 and the immediate NE neighbor is background (so at least one background cell is colored)
        candidates = [(r, c) for r in range(size) for c in range(size) if grid[r][c] == 0]
        random.shuffle(candidates)
        dr0, dc0 = -1, 1
        origin_pos = None
        for (r0, c0) in candidates:
            max_steps = min(r0, size - 1 - c0)
            if max_steps < 2:
                continue
            # immediate NE must be background
            if grid[r0 + dr0][c0 + dc0] != 0:
                continue
            # find first non-background along NE diagonal
            first_collision_step = None
            for step in range(1, max_steps + 1):
                rr = r0 + dr0 * step
                cc = c0 + dc0 * step
                if grid[rr][cc] != 0:
                    first_collision_step = step
                    break
            if first_collision_step is None:
                continue
            if first_collision_step >= 2:
                origin_pos = (r0, c0)
                break

        if origin_pos is None:
            # couldn't find an origin for this mirror layout; retry entire layout
            continue

        orr, orc = origin_pos
        grid[orr][orc] = origin_color

        # Simulate the beam to produce the output grid
        output = [row[:] for row in grid]
        cur_r, cur_c = orr, orc
        dr, dc = -1, 1
        current_color = origin_color
        visited_states = set()
        steps = 0
        while True:
            cur_r += dr
            cur_c += dc
            steps += 1
            if cur_r < 0 or cur_r >= size or cur_c < 0 or cur_c >= size:
                break
            state = (cur_r, cur_c, dr, dc, current_color)
            if state in visited_states:
                # loop detected; stop
                break
            visited_states.add(state)

            val = grid[cur_r][cur_c]
            if val == 0:
                # color background cell with the beam's current color
                output[cur_r][cur_c] = current_color
                # continue traveling
                if steps > 1000:
                    break
                continue

            # If we hit the origin again, stop (we don't overwrite origin)
            if val == origin_color:
                break

            # Hit a mirror: change beam color and reflect
            mirror_color = val
            current_color = mirror_color
            # determine mirror orientation by checking same-color neighbors
            is_horizontal = False
            if cur_c - 1 >= 0 and grid[cur_r][cur_c - 1] == mirror_color:
                is_horizontal = True
            if cur_c + 1 < size and grid[cur_r][cur_c + 1] == mirror_color:
                is_horizontal = True
            if is_horizontal:
                # horizontal mirror: reflect vertical component
                dr = -dr
            else:
                # vertical mirror: reflect horizontal component
                dc = -dc

            if steps > 2000:
                break

        # Ensure the output differs from the input (we must color at least one cell)
        if output != grid:
            return {"input": grid, "output": output}

    # If we exhaust attempts, raise an informative error
    raise RuntimeError("Failed to generate a valid grid after many attempts")



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    size = len(grid)

    # Find the origin color: the unique non-zero color that appears exactly once
    counts = {}
    for r in range(size):
        for c in range(size):
            v = grid[r][c]
            if v != 0:
                counts[v] = counts.get(v, 0) + 1
    origin_color = None
    for color, cnt in counts.items():
        if cnt == 1:
            origin_color = color
            break
    if origin_color is None:
        # Fallback: if no unique color (shouldn't happen), pick the first non-zero cell as origin
        found = False
        for r in range(size):
            for c in range(size):
                if grid[r][c] != 0:
                    origin_color = grid[r][c]
                    found = True
                    break
            if found:
                break

    # Locate origin coordinates
    origin = None
    for r in range(size):
        for c in range(size):
            if grid[r][c] == origin_color:
                origin = (r, c)
                break
        if origin is not None:
            break
    if origin is None:
        # no origin found, just return input as normalized
        return tuple(tuple(row) for row in grid)

    r0, c0 = origin

    # Simulate the beam
    output = [row[:] for row in grid]
    dr, dc = -1, 1
    cur_r, cur_c = r0, c0
    current_color = origin_color
    visited = set()
    steps = 0
    while True:
        cur_r += dr
        cur_c += dc
        steps += 1
        if cur_r < 0 or cur_r >= size or cur_c < 0 or cur_c >= size:
            break
        state = (cur_r, cur_c, dr, dc, current_color)
        if state in visited:
            break
        visited.add(state)

        val = grid[cur_r][cur_c]
        if val == 0:
            # paint the beam path
            output[cur_r][cur_c] = current_color
            if steps > 10000:
                break
            continue

        # If we hit the origin cell, stop (do not overwrite origin)
        if val == origin_color:
            break

        # Hit a mirror: change color and reflect
        mirror_color = val
        current_color = mirror_color
        # detect orientation by checking same-colored neighbors (we ensured length>=2)
        is_horizontal = False
        if cur_c - 1 >= 0 and grid[cur_r][cur_c - 1] == mirror_color:
            is_horizontal = True
        if cur_c + 1 < size and grid[cur_r][cur_c + 1] == mirror_color:
            is_horizontal = True
        if is_horizontal:
            # horizontal mirror reflects vertical component
            dr = -dr
        else:
            # vertical mirror reflects horizontal component
            dc = -dc

        if steps > 20000:
            break

    return tuple(tuple(row) for row in output)

