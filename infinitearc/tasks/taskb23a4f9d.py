# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: b23a4f9d
Difficulty: hard

=== Tags ===
- Folded grid reasoning
- If then color switch

=== Description ===
**Task Description**    Input grids are 2D arrays of integer values (0–9)
representing colors, with dimensions ranging from 1×1 to 30×30. The
transformation involves two sequential, deterministic operations applied to the
input grid in a fixed order:    1. **Vertical Folding Step**: For each row,
mirror the left half of the grid across the vertical midline (e.g., column *c*
is compared to column *width - 1 - c*). If the two mirrored cells have
*different* colors, both cells are replaced with the fixed color **5**.   2.
**Horizontal Folding Step**: For each column, mirror the top half of the grid
across the horizontal midline (e.g., row *r* is compared to row *height - 1 -
r*). If the two mirrored cells have *different* colors, both cells are replaced
with the fixed color **6**.    The vertical folding step modifies the grid, and
the horizontal folding step uses the updated grid (not the original input) for
its comparisons. The output grid is the final result after both steps.    This
task requires recognizing the two-step dependency (horizontal step relies on
vertical step’s modifications) and discovering the fixed color switches (5 for
vertical, 6 for horizontal) through inductive reasoning. The complexity arises
from the interplay between the folding directions and the conditional color
replacements, which must be applied sequentially. Grids may contain arbitrary
color patterns, but the rules remain invariant regardless of input content.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def vertical_fold(grid):
    height = len(grid)
    width = len(grid[0])
    new_grid = [row[:] for row in grid]
    for r in range(height):
        for c in range(width // 2):
            c2 = width - 1 - c
            if new_grid[r][c] != new_grid[r][c2]:
                new_grid[r][c] = 5
                new_grid[r][c2] = 5
    return new_grid

def horizontal_fold(grid):
    height = len(grid)
    width = len(grid[0])
    new_grid = [row[:] for row in grid]
    for c in range(width):
        for r in range(height // 2):
            r2 = height - 1 - r
            if new_grid[r][c] != new_grid[r2][c]:
                new_grid[r][c] = 6
                new_grid[r2][c] = 6
    return new_grid

def generate():
    while True:
        width = random.randint(2, 30)
        height = random.randint(2, 30)
        input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
        inter = vertical_fold(input_grid)
        output = horizontal_fold(inter)
        if input_grid != output:
            return {"input": input_grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random

def vertical_fold(grid):
    height = len(grid)
    width = len(grid[0])
    new_grid = [row[:] for row in grid]
    for r in range(height):
        for c in range(width // 2):
            c2 = width - 1 - c
            if new_grid[r][c] != new_grid[r][c2]:
                new_grid[r][c] = 5
                new_grid[r][c2] = 5
    return new_grid

def horizontal_fold(grid):
    height = len(grid)
    width = len(grid[0])
    new_grid = [row[:] for row in grid]
    for c in range(width):
        for r in range(height // 2):
            r2 = height - 1 - r
            if new_grid[r][c] != new_grid[r2][c]:
                new_grid[r][c] = 6
                new_grid[r2][c] = 6
    return new_grid

def p(input_grid):
    grid = [list(row) for row in input_grid]
    grid = vertical_fold(grid)
    grid = horizontal_fold(grid)
    return tuple(tuple(row) for row in grid)
