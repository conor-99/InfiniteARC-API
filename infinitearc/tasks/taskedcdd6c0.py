# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: edcdd6c0
Difficulty: insane

=== Tags ===
- Projection unto rectangle
- Apply transform from paired example
- Maze

=== Description ===
The task involves input grids that depict mazes with a single continuous path
(non-zero color values) winding through walls (0s). The output grids are
rectangles formed by projecting the path's trajectory onto a grid that aligns
the path's start and end points along the diagonal of the rectangle.
Specifically, the output rectangle's dimensions are determined by the horizontal
and vertical extents of the path's bounding box, but the path is "straightened"
such that all horizontal movements correspond to the rectangle's width and
vertical movements to its height. The path's original color is preserved in the
output, with the rectangle centered to match the path's orientation. This
requires identifying the path's bounding box, determining the path's direction
(e.g., start-to-end vector), aligning the path to the rectangle's axes, and
mapping each path cell to its new position within the projected rectangle. The
transformation must account for the path's directionality and spatial
arrangement, making it challenging for "insane" difficulty due to the need to
infer the projection axis from the path's geometry rather than fixed grid
properties.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    w_in = common.randint(5, 30)
    h_in = common.randint(5, 30)
    w_box = common.randint(2, min(w_in, h_in) - 1)
    h_box = common.randint(2, min(w_in, h_in) - 1)
    r_start = common.randint(0, h_in - h_box - 1)
    c_start = common.randint(0, w_in - w_box - 1)
    input_grid = common.grid(w_in, h_in)
    size = common.randint(w_box + h_box - 1, w_box * h_box)
    path_pixels = common.continuous_creature(size, w_box, h_box)
    for (r, c) in path_pixels:
        input_grid[r_start + r][c_start + c] = common.random_color()
    non_zero = []
    for r in range(h_in):
        for c in range(w_in):
            if input_grid[r][c] != 0:
                non_zero.append((r, c))
    min_r = min(r for r, c in non_zero)
    max_r = max(r for r, c in non_zero)
    min_c = min(c for r, c in non_zero)
    max_c = max(c for r, c in non_zero)
    output_grid = []
    for r in range(min_r, max_r + 1):
        output_row = []
        for c in range(min_c, max_c + 1):
            output_row.append(input_grid[r][c])
        output_grid.append(output_row)
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    h = len(input_grid)
    w = len(input_grid[0])
    non_zero = []
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] != 0:
                non_zero.append((r, c))
    if not non_zero:
        return input_grid
    min_r = min(r for r, c in non_zero)
    max_r = max(r for r, c in non_zero)
    min_c = min(c for r, c in non_zero)
    max_c = max(c for r, c in non_zero)
    output_grid = []
    for r in range(min_r, max_r + 1):
        output_row = []
        for c in range(min_c, max_c + 1):
            output_row.append(input_grid[r][c])
        output_grid.append(output_row)
    return output_grid
