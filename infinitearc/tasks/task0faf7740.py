# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 0faf7740
Difficulty: hard

=== Tags ===
- Competitive agents
- Split and merge
- Binary rule overlay
- Copy object and apply one change

=== Description ===
Input grids contain two or more distinct, contiguous colored agents (each a
connected group of non-background cells) positioned in a grid. Agents are
separated by background cells (color 0) and exhibit simple geometric shapes
(e.g., squares, L-shapes, or T-shapes). Each agent has a unique color and is
oriented in a way that suggests competitive positioning (e.g., mirrored or
facing each other).  To generate the output grid, the following sequence of
operations is applied:  1. **Copy and Apply Single Change**: For each agent,
create an exact copy of its shape. Then apply one consistent transformation:
rotate the copy 90 degrees clockwise if the agent's bounding box is square;
otherwise, flip the copy horizontally.  2. **Split**: Split each original agent
into two smaller connected components by removing a single cell that divides the
agent into two equal-area parts while maintaining connectivity (e.g., splitting
a 2x2 square into two 1x2 rectangles).  3. **Merge with Transformed Copy**:
Merge each split part of the original agent with the corresponding part of its
transformed copy. The merge uses a binary rule: if the split part and copy part
share the same color, they are replaced by a new color (e.g., red + red →
yellow); otherwise, they are replaced by a third color (e.g., red + blue →
green).  4. **Final Composition**: The output grid replaces the original agents
with the merged results. All background cells, non-transformed areas, and other
grid elements remain unchanged. The rotated/flipped copies are no longer visible
as they are fully merged into the new agent structures.  This task requires
recognizing agent shapes, identifying the correct split cell, applying
orientation-based transformations, and resolving color merges according to a
binary rule—all while maintaining visual consistency across diverse agent
configurations. The difficulty arises from the need to discover the split axis,
transformation rule, and color merge logic simultaneously through abstract
reasoning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, all_pixels

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = grid(width, height, 0)
    
    # Create two agents
    colors = [1, 2]
    agent1_color = colors[0]
    agent2_color = colors[1]
    
    # Agent 1: 2x2 square (even area)
    r1, c1 = random.randint(1, height-3), random.randint(1, width-3)
    for r in range(r1, r1+2):
        for c in range(c1, c1+2):
            input_grid[r][c] = agent1_color

    # Agent 2: 2x4 rectangle (even area)
    r2, c2 = random.randint(1, height-3), random.randint(1, width-4)
    for r in range(r2, r2+2):
        for c in range(c2, c2+4):
            input_grid[r][c] = agent2_color

    output_grid = [row[:] for row in input_grid]

    # Process agent 1
    bbox1 = (r1, c1, r1+1, c1+1)
    if (bbox1[3] - bbox1[1]) == (bbox1[2] - bbox1[0]):  # square
        # Rotate copy 90°
        transformed_copy = [[agent1_color if (i == 0 and j == 1) or (i == 1 and j == 0) else 0 for j in range(2)] for i in range(2)]
    else:
        # Flip horizontally
        transformed_copy = [[agent1_color for _ in range(2)] for _ in range(2)]

    # Split agent 1 into left/right
    left1 = [(r1, c1), (r1+1, c1)]
    right1 = [(r1, c1+1), (r1+1, c1+1)]
    
    # Merge left parts
    new_color = agent1_color + 2
    for r, c in left1:
        output_grid[r][c] = new_color
    for r, c in right1:
        output_grid[r][c] = new_color

    # Process agent 2
    bbox2 = (r2, c2, r2+1, c2+3)
    if (bbox2[3] - bbox2[1]) == (bbox2[2] - bbox2[0]):  # square
        transformed_copy = [[agent2_color if (i == 0 and j == 3) or (i == 1 and j == 2) else 0 for j in range(4)] for i in range(2)]
    else:
        # Flip horizontally
        transformed_copy = [[agent2_color for _ in range(4)] for _ in range(2)]

    # Split agent 2 into left/right
    left2 = [(r2, c2), (r2, c2+1), (r2+1, c2), (r2+1, c2+1)]
    right2 = [(r2, c2+2), (r2, c2+3), (r2+1, c2+2), (r2+1, c2+3)]
    
    # Merge left parts
    new_color = agent2_color + 2
    for r, c in left2:
        output_grid[r][c] = new_color
    for r, c in right2:
        output_grid[r][c] = new_color

    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Identify agents (connected components with color > 0)
    seen = [[False] * width for _ in range(height)]
    agents = []

    def dfs(r, c, color):
        stack = [(r, c)]
        component = []
        while stack:
            r, c = stack.pop()
            if not (0 <= r < height and 0 <= c < width):
                continue
            if grid[r][c] != color or seen[r][c]:
                continue
            seen[r][c] = True
            component.append((r, c))
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and not seen[nr][nc] and grid[nr][nc] == color:
                    stack.append((nr, nc))
        return component

    for r in range(height):
        for c in range(width):
            if grid[r][c] > 0 and not seen[r][c]:
                color = grid[r][c]
                component = dfs(r, c, color)
                agents.append((component, color))

    # Process each agent
    for component, color in agents:
        # Find bounding box
        rows = [r for r, c in component]
        cols = [c for r, c in component]
        min_r, max_r = min(rows), max(rows)
        min_c, max_c = min(cols), max(cols)
        
        # Check if square
        is_square = (max_r - min_r + 1) == (max_c - min_c + 1)
        
        # Split into two equal parts
        area = (max_r - min_r + 1) * (max_c - min_c + 1)
        if area % 2 != 0:
            continue  # Skip odd area
        
        # Split vertically
        mid_c = min_c + (max_c - min_c + 1) // 2
        left_part = [(r, c) for r, c in component if c < mid_c]
        right_part = [(r, c) for r, c in component if c >= mid_c]
        
        # Merge rule: same color → color + 2
        new_color = color + 2
        
        # Apply new color to split parts
        for r, c in left_part:
            grid[r][c] = new_color
        for r, c in right_part:
            grid[r][c] = new_color

    return grid
