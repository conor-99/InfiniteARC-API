# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 111cde4e
Difficulty: insane

=== Tags ===
- Rule based tiling
- Layered path system
- Refraction simulation
- Associate colors to ranks

=== Description ===
Input grids are large (20×20 or larger) with background color 0. Scattered
across the grid are colored refractors (colors 1–9), each corresponding to a
unique rank where color value equals rank (e.g., color 3 = rank 3). Path sources
(cells of color C > 0) are positioned on grid edges: left edge paths start
moving right, right edge paths move left, top edge paths move down, and bottom
edge paths move up. Each path maintains its initial color until entering a
refractor cell, at which point its color updates to the refractor's color. Upon
entering a refractor of rank R, the path's direction changes by +1 (clockwise)
for odd R and -1 (counterclockwise) in an 8-direction compass (0=E, 1=NE, 2=N,
3=NW, 4=W, 5=SW, 6=S, 7=SE), modulo 8. Paths continue moving until exiting the
grid boundary.   The output grid renders all path trajectories: each cell along
a path is colored by the path's current color (updated at refractors), with
intersecting paths resolved by selecting the highest rank (color value) at
overlapping cells. Refractors remain visible in their original positions but do
not block path movement. Paths never overlap with refractors or other path
sources, and all paths exit the grid within finite steps. The transformation
requires simultaneous simulation of multiple paths, deterministic direction
changes based on color-rank associations, and layered rendering via rank-based
prioritization.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    H = random.randint(20, 30)
    W = random.randint(20, 30)
    grid = [[0] * W for _ in range(H)]
    
    num_refractors = random.randint(3, 5)
    colors = random.sample(range(1, 10), num_refractors)
    for color in colors:
        r = random.randint(1, H-2)
        c = random.randint(1, W-2)
        grid[r][c] = color
    
    path_sources = []
    for r in range(1, H-1):
        if grid[r][0] == 0 and random.random() > 0.5:
            color = random.randint(1, 9)
            grid[r][0] = color
            path_sources.append((r, 0, 0, color))
    for r in range(1, H-1):
        if grid[r][W-1] == 0 and random.random() > 0.5:
            color = random.randint(1, 9)
            grid[r][W-1] = color
            path_sources.append((r, W-1, 4, color))
    for c in range(1, W-1):
        if grid[0][c] == 0 and random.random() > 0.5:
            color = random.randint(1, 9)
            grid[0][c] = color
            path_sources.append((0, c, 6, color))
    for c in range(1, W-1):
        if grid[H-1][c] == 0 and random.random() > 0.5:
            color = random.randint(1, 9)
            grid[H-1][c] = color
            path_sources.append((H-1, c, 2, color))
    
    directions = [
        (0, 1),    # 0: E
        (-1, 1),   # 1: NE
        (-1, 0),   # 2: N
        (-1, -1),  # 3: NW
        (0, -1),   # 4: W
        (1, -1),   # 5: SW
        (1, 0),    # 6: S
        (1, 1)     # 7: SE
    ]
    
    path_grid = [[0] * W for _ in range(H)]
    for (r, c, init_dir, color) in path_sources:
        current_r, current_c = r, c
        current_color = color
        current_dir = init_dir
        while 0 <= current_r < H and 0 <= current_c < W:
            if grid[current_r][current_c] != 0:
                refractor_color = grid[current_r][current_c]
                if refractor_color != current_color:
                    current_color = refractor_color
                    if refractor_color % 2 == 1:
                        current_dir = (current_dir + 1) % 8
                    else:
                        current_dir = (current_dir - 1) % 8
            if current_color > path_grid[current_r][current_c]:
                path_grid[current_r][current_c] = current_color
            dr, dc = directions[current_dir]
            current_r += dr
            current_c += dc
            if not (0 <= current_r < H and 0 <= current_c < W):
                break
    
    return {
        "input": grid,
        "output": path_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0])
    
    directions = [
        (0, 1),    # 0: E
        (-1, 1),   # 1: NE
        (-1, 0),   # 2: N
        (-1, -1),  # 3: NW
        (0, -1),   # 4: W
        (1, -1),   # 5: SW
        (1, 0),    # 6: S
        (1, 1)     # 7: SE
    ]
    
    path_sources = []
    for r in range(1, H-1):
        if grid[r][0] != 0:
            path_sources.append((r, 0, 0, grid[r][0]))
    for r in range(1, H-1):
        if grid[r][W-1] != 0:
            path_sources.append((r, W-1, 4, grid[r][W-1]))
    for c in range(1, W-1):
        if grid[0][c] != 0:
            path_sources.append((0, c, 6, grid[0][c]))
    for c in range(1, W-1):
        if grid[H-1][c] != 0:
            path_sources.append((H-1, c, 2, grid[H-1][c]))
    
    max_color = [[0] * W for _ in range(H)]
    
    for (r, c, init_dir, color) in path_sources:
        current_r, current_c = r, c
        current_color = color
        current_dir = init_dir
        while 0 <= current_r < H and 0 <= current_c < W:
            if grid[current_r][current_c] != 0:
                refractor_color = grid[current_r][current_c]
                if refractor_color != current_color:
                    current_color = refractor_color
                    if refractor_color % 2 == 1:
                        current_dir = (current_dir + 1) % 8
                    else:
                        current_dir = (current_dir - 1) % 8
            if current_color > max_color[current_r][current_c]:
                max_color[current_r][current_c] = current_color
            dr, dc = directions[current_dir]
            current_r += dr
            current_c += dc
            if not (0 <= current_r < H and 0 <= current_c < W):
                break
    
    return max_color
