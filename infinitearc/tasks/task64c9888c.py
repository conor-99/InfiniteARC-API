# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 64c9888c
Difficulty: very hard

=== Tags ===
- Loopless feedback
- Sand simulation
- Measure area
- Summarize

=== Description ===
Sand Area Summarizer  Input grids are 15×15 to 30×30 in size, containing three
distinct colors: 0 (background), 1 (sand), and 2 (solid obstacles). Sand cells
(color 1) are positioned above obstacles or background, never directly on
obstacles. Obstacles (color 2) appear as 1-cell-thick horizontal or vertical
segments of varying lengths, never touching each other.  The transformation
process begins with a deterministic sand fall simulation: each sand cell moves
downward (south) exactly once until it either encounters a solid obstacle (color
2), the bottom grid boundary, or another sand cell. This is a single-pass,
loopless process with no subsequent movement or interaction.  Next, the task
measures the area of each connected sand region (after falling) through visual
analysis rather than numerical calculation. For each contiguous sand region, its
aspect ratio is determined by comparing its width and height in grid units: - If
the region appears taller than wide (height > width), it is categorized as
"tall" - If the region appears wider than tall (width > height), it is
categorized as "wide" - If the region appears approximately square (width ≈
height), it is categorized as "square"  The output grid summarizes these visual
area measurements by replacing all sand cells in each region with a category-
specific color: - "Tall" regions become color 3 - "Wide" regions become color 4
- "Square" regions become color 5  Solid obstacles (color 2) and background
(color 0) remain completely unchanged. The transformation produces a visually
consistent output where sand regions are replaced by category colors based
solely on their apparent shape, with no numerical sums, counts, or pixel-wise
calculations. The output grid maintains the same dimensions as the input, with
all non-sand elements preserved exactly as in the input.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def simulate_sand_fall(grid):
    height = len(grid)
    width = len(grid[0])
    fallen = [row[:] for row in grid]
    for col in range(width):
        obstacle_row = height
        for r in range(height-1, -1, -1):
            if fallen[r][col] == 2:
                obstacle_row = r
                break
        available_rows = obstacle_row
        sand_count = sum(1 for r in range(height) if fallen[r][col] == 1)
        for r in range(height):
            if fallen[r][col] == 1:
                fallen[r][col] = 0
        start_row = max(0, available_rows - sand_count)
        for r in range(start_row, start_row + sand_count):
            if r < available_rows:
                fallen[r][col] = 1
    return fallen

def generate():
    width = random.randint(15, 30)
    height = random.randint(15, 30)
    input_grid = grid(width, height, 0)
    num_obstacles = 5
    for _ in range(num_obstacles):
        if random.choice([True, False]):
            row = random.randint(0, height-1)
            start_col = random.randint(0, width-3)
            length = random.randint(1, 3)
            for col in range(start_col, start_col+length):
                input_grid[row][col] = 2
        else:
            col = random.randint(0, width-1)
            start_row = random.randint(0, height-3)
            length = random.randint(1, 3)
            for row in range(start_row, start_row+length):
                input_grid[row][col] = 2
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0 and random.random() < 0.2:
                input_grid[r][c] = 1
    fallen_grid = simulate_sand_fall(input_grid)
    output_grid = [row[:] for row in fallen_grid]
    visited = [[False] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and fallen_grid[r][c] == 1:
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and fallen_grid[nr][nc] == 1:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                min_r = min(cr for cr, cc in component)
                max_r = max(cr for cr, cc in component)
                min_c = min(cc for cr, cc in component)
                max_c = max(cc for cr, cc in component)
                width_comp = max_c - min_c + 1
                height_comp = max_r - min_r + 1
                if height_comp > width_comp:
                    color = 3
                elif width_comp > height_comp:
                    color = 4
                else:
                    color = 5
                for cr, cc in component:
                    output_grid[cr][cc] = color
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    fallen_grid = simulate_sand_fall(input_grid)
    output_grid = [row[:] for row in fallen_grid]
    visited = [[False] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and fallen_grid[r][c] == 1:
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and fallen_grid[nr][nc] == 1:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                min_r = min(cr for cr, cc in component)
                max_r = max(cr for cr, cc in component)
                min_c = min(cc for cr, cc in component)
                max_c = max(cc for cr, cc in component)
                width_comp = max_c - min_c + 1
                height_comp = max_r - min_r + 1
                if height_comp > width_comp:
                    color = 3
                elif width_comp > height_comp:
                    color = 4
                else:
                    color = 5
                for cr, cc in component:
                    output_grid[cr][cc] = color
    return output_grid

def simulate_sand_fall(grid):
    height = len(grid)
    width = len(grid[0])
    fallen = [row[:] for row in grid]
    for col in range(width):
        obstacle_row = height
        for r in range(height-1, -1, -1):
            if fallen[r][col] == 2:
                obstacle_row = r
                break
        available_rows = obstacle_row
        sand_count = sum(1 for r in range(height) if fallen[r][col] == 1)
        for r in range(height):
            if fallen[r][col] == 1:
                fallen[r][col] = 0
        start_row = max(0, available_rows - sand_count)
        for r in range(start_row, start_row + sand_count):
            if r < available_rows:
                fallen[r][col] = 1
    return fallen
