# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 062ed1eb
Difficulty: medium–hard

=== Tags ===
- Deterministic update
- Area based reconstruction
- Shape to color encoding
- Connect components by property

=== Description ===
# Shape-Encoded Area Connectivity  Input grids feature multiple disconnected,
contiguous regions (connected components) of non-zero color values on a
background of color 0. Each region is surrounded by background cells and
exhibits a distinct bounding box shape. The transformation process involves two
primary phases:  First, each region's bounding box (defined by its minimum and
maximum row and column coordinates) is analyzed. If the bounding box forms a
perfect square (where height equals width), the region is encoded to color 5
(blue) in the output. If the bounding box is a rectangle (where height differs
from width), the region is encoded to color 6 (green).  Second, after all
regions are encoded, the output grid is modified to connect regions that share
the same encoded color. For any two regions with identical encoded color (either
both 5 or both 6), a single straight line of color 7 (yellow) is drawn through
background cells between them. The line is drawn horizontally if the regions are
aligned horizontally, vertically if aligned vertically, or along the shortest
path if neither condition applies. This connection must traverse only background
cells (color 0) and may not overlap with any encoded regions. The background
remains color 0 except where modified by the connection lines.  The
transformation requires identifying connected components, analyzing their
bounding box dimensions to determine color encoding, and then applying
directional connections between similarly encoded regions—all while preserving
the background structure where no changes are applied.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = common.grid(width, height, 0)
    regions = []
    
    num_regions = random.randint(2, 4)
    for _ in range(num_regions):
        shape_type = random.choice(['el', 'you', 'aitch'])
        size = random.randint(2, 5)
        pixels = common.rand_sprite(shape_type, size, size)
        if not pixels:
            continue
        shift_r = random.randint(0, height - size)
        shift_c = random.randint(0, width - size)
        shifted_pixels = [(r + shift_r, c + shift_c) for r, c in pixels]
        overlap = any(input_grid[r][c] != 0 for r, c in shifted_pixels)
        if overlap:
            continue
        color = random.randint(1, 9)
        for r, c in shifted_pixels:
            if 0 <= r < height and 0 <= c < width:
                input_grid[r][c] = color
        regions.append(shifted_pixels)
    
    def find_components(grid):
        visited = set()
        components = []
        rows = len(grid)
        cols = len(grid[0])
        for r in range(rows):
            for c in range(cols):
                if grid[r][c] != 0 and (r, c) not in visited:
                    queue = [(r, c)]
                    comp = []
                    visited.add((r, c))
                    while queue:
                        cr, cc = queue.pop(0)
                        comp.append((cr, cc))
                        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] != 0 and (nr, nc) not in visited:
                                visited.add((nr, nc))
                                queue.append((nr, nc))
                    components.append(comp)
        return components
    
    components = find_components(input_grid)
    output_grid = common.grid(width, height, 0)
    
    comp_info = []
    for comp in components:
        rows = [r for r, c in comp]
        cols = [c for r, c in comp]
        min_r, max_r = min(rows), max(rows)
        min_c, max_c = min(cols), max(cols)
        box_h = max_r - min_r + 1
        box_w = max_c - min_c + 1
        color_out = 5 if box_h == box_w else 6
        comp_info.append((comp, color_out))
    
    for comp, color_out in comp_info:
        for r, c in comp:
            output_grid[r][c] = color_out
    
    color_groups = {}
    for comp, color_out in comp_info:
        if color_out not in color_groups:
            color_groups[color_out] = []
        color_groups[color_out].append(comp)
    
    for color_out, comps in color_groups.items():
        if len(comps) < 2:
            continue
        for i in range(len(comps)):
            for j in range(i+1, len(comps)):
                comp1, comp2 = comps[i], comps[j]
                rows1 = [r for r, c in comp1]
                cols1 = [c for r, c in comp1]
                min_r1, max_r1 = min(rows1), max(rows1)
                min_c1, max_c1 = min(cols1), max(cols1)
                center1 = ((min_r1 + max_r1) // 2, (min_c1 + max_c1) // 2)
                
                rows2 = [r for r, c in comp2]
                cols2 = [c for r, c in comp2]
                min_r2, max_r2 = min(rows2), max(rows2)
                min_c2, max_c2 = min(cols2), max(cols2)
                center2 = ((min_r2 + max_r2) // 2, (min_c2 + max_c2) // 2)
                
                dr = center2[0] - center1[0]
                dc = center2[1] - center1[1]
                if dr == 0:
                    start_c = min(center1[1], center2[1])
                    end_c = max(center1[1], center2[1])
                    for c in range(start_c, end_c + 1):
                        if output_grid[center1[0]][c] == 0:
                            output_grid[center1[0]][c] = 7
                elif dc == 0:
                    start_r = min(center1[0], center2[0])
                    end_r = max(center1[0], center2[0])
                    for r in range(start_r, end_r + 1):
                        if output_grid[r][center1[1]] == 0:
                            output_grid[r][center1[1]] = 7
                else:
                    steps = abs(dr)
                    for step in range(steps + 1):
                        r = center1[0] + step * (1 if dr > 0 else -1)
                        c = center1[1] + step * (1 if dc > 0 else -1)
                        if 0 <= r < height and 0 <= c < width and output_grid[r][c] == 0:
                            output_grid[r][c] = 7
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    
    def find_components(grid):
        visited = set()
        components = []
        rows = len(grid)
        cols = len(grid[0])
        for r in range(rows):
            for c in range(cols):
                if grid[r][c] != 0 and (r, c) not in visited:
                    queue = [(r, c)]
                    comp = []
                    visited.add((r, c))
                    while queue:
                        cr, cc = queue.pop(0)
                        comp.append((cr, cc))
                        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] != 0 and (nr, nc) not in visited:
                                visited.add((nr, nc))
                                queue.append((nr, nc))
                    components.append(comp)
        return components
    
    components = find_components(input_grid)
    output_grid = [[0] * width for _ in range(height)]
    
    comp_info = []
    for comp in components:
        rows = [r for r, c in comp]
        cols = [c for r, c in comp]
        min_r, max_r = min(rows), max(rows)
        min_c, max_c = min(cols), max(cols)
        box_h = max_r - min_r + 1
        box_w = max_c - min_c + 1
        color_out = 5 if box_h == box_w else 6
        comp_info.append((comp, color_out))
    
    for comp, color_out in comp_info:
        for r, c in comp:
            output_grid[r][c] = color_out
    
    color_groups = {}
    for comp, color_out in comp_info:
        if color_out not in color_groups:
            color_groups[color_out] = []
        color_groups[color_out].append(comp)
    
    for color_out, comps in color_groups.items():
        if len(comps) < 2:
            continue
        for i in range(len(comps)):
            for j in range(i+1, len(comps)):
                comp1, comp2 = comps[i], comps[j]
                rows1 = [r for r, c in comp1]
                cols1 = [c for r, c in comp1]
                min_r1, max_r1 = min(rows1), max(rows1)
                min_c1, max_c1 = min(cols1), max(cols1)
                center1 = ((min_r1 + max_r1) // 2, (min_c1 + max_c1) // 2)
                
                rows2 = [r for r, c in comp2]
                cols2 = [c for r, c in comp2]
                min_r2, max_r2 = min(rows2), max(rows2)
                min_c2, max_c2 = min(cols2), max(cols2)
                center2 = ((min_r2 + max_r2) // 2, (min_c2 + max_c2) // 2)
                
                dr = center2[0] - center1[0]
                dc = center2[1] - center1[1]
                if dr == 0:
                    start_c = min(center1[1], center2[1])
                    end_c = max(center1[1], center2[1])
                    for c in range(start_c, end_c + 1):
                        if output_grid[center1[0]][c] == 0:
                            output_grid[center1[0]][c] = 7
                elif dc == 0:
                    start_r = min(center1[0], center2[0])
                    end_r = max(center1[0], center2[0])
                    for r in range(start_r, end_r + 1):
                        if output_grid[r][center1[1]] == 0:
                            output_grid[r][center1[1]] = 7
                else:
                    steps = abs(dr)
                    for step in range(steps + 1):
                        r = center1[0] + step * (1 if dr > 0 else -1)
                        c = center1[1] + step * (1 if dc > 0 else -1)
                        if 0 <= r < height and 0 <= c < width and output_grid[r][c] == 0:
                            output_grid[r][c] = 7
    return [tuple(row) for row in output_grid]
