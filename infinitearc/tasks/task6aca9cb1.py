# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 6aca9cb1
Difficulty: mediumâ€“hard

=== Tags ===
- Pathfinding with state
- Associate images to bools

=== Description ===
Input grids feature a start symbol (a unique pattern), a target symbol (another
distinct pattern), and a grid of cells containing various small symbols. Each
symbol is associated with a boolean value (e.g., a circle symbol corresponds to
true, a square symbol corresponds to false). The path begins at the start
symbol, moving east by default. At each cell along the path, the direction turns
left if the cell's symbol is associated with true, and right if associated with
false. The path continues until it reaches the target symbol, avoiding obstacles
(if present), self-overlap, and grid boundaries. The output grid retains all
input elements but highlights the path from start to target in a new color,
following the direction changes dictated by the symbol-associated booleans. The
task requires identifying symbol-to-boolean mappings through pattern recognition
and applying sequential state-dependent pathfinding logic to reconstruct the
path.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

# Generator for ARC task 457
# Produces a grid with a unique start cell (color 1), a unique target cell (color 2),
# two turn-symbol colors (odd -> left, even -> right), and a non-self-intersecting path
# that starts at the start cell, moves east initially, and follows turn symbols until it
# reaches the target. The output is the same grid but with the whole path (including
# start and target) painted with color 9.


def generate():
    # Small helper turn functions (used only in generation)
    def turn_left(d):
        return (-d[1], d[0])  # (dr,dc) -> left turn

    def turn_right(d):
        return (d[1], -d[0])  # (dr,dc) -> right turn

    # Grid size (keep enough room to allow paths)
    size = random.randint(7, 15)

    # Colors reserved:
    # 1 -> start (unique)
    # 2 -> target (unique)
    # 9 -> path highlight in output (reserved and NOT used in input)

    # Choose symbol colors (odd => left, even => right). Use a reduced pool to
    # avoid accidental overlap with reserved colors and keep parity mapping clear.
    odd_choices = [3, 5, 7]
    even_choices = [4, 6, 8]
    left_color = random.choice(odd_choices)
    right_color = random.choice(even_choices)

    # Background/filler colors (do not include 1,2,9,left_color,right_color)
    filler_pool = [c for c in range(0, 10)
                   if c not in (1, 2, 9, left_color, right_color)]

    # Initialize grid with a filler color 0 (or random filler later)
    grid = [[0 for _ in range(size)] for _ in range(size)]

    # Place start. Keep it away from the very top/bottom rows to increase chances
    # the generated path can turn up/down without immediate failure.
    start_r = random.randint(1, size - 2)
    # Ensure there's at least one column to the right for the initial east step
    start_c = random.randint(0, max(0, size - 3))
    grid[start_r][start_c] = 1

    # Try to build a non-self-intersecting path that obeys turns determined by
    # the symbol-parity mapping. We'll attempt several times if we hit a blockage.
    max_attempts = 200
    attempt = 0

    while attempt < max_attempts:
        attempt += 1
        # Randomize target path length (number of nodes including start and target)
        node_count = random.randint(4, size + 3)

        # Keep a transient symbol map for this attempt so we can roll back easily
        symbol_map = {}  # (r,c) -> color for intermediate turning cells

        path = [(start_r, start_c)]
        visited = set(path)
        direction = (0, 1)  # initially east
        r, c = start_r, start_c

        failed = False
        for i in range(1, node_count):
            nr = r + direction[0]
            nc = c + direction[1]
            # If the next step goes out of bounds or would self-overlap -> fail
            if not (0 <= nr < size and 0 <= nc < size) or (nr, nc) in visited:
                failed = True
                break
            path.append((nr, nc))
            visited.add((nr, nc))

            # If this is the final node, it will be the target; do not place a turn symbol here
            if i == node_count - 1:
                # leave as target location
                r, c = nr, nc
                break

            # Otherwise, choose a turn (left/right) for this cell and record its symbol
            turn_choice = random.choice(("L", "R"))
            if turn_choice == "L":
                symbol_map[(nr, nc)] = left_color
                direction = turn_left(direction)
            else:
                symbol_map[(nr, nc)] = right_color
                direction = turn_right(direction)

            # Advance
            r, c = nr, nc

        if failed:
            continue

        # If we succeeded building the path, place the target and the symbols.
        target_r, target_c = path[-1]
        # Ensure target isn't the same as start
        if (target_r, target_c) == (start_r, start_c):
            continue

        # Place symbols onto the grid for all intermediate turning cells
        # Ensure we don't accidentally overwrite start or (later) target
        grid = [[random.choice(filler_pool) for _ in range(size)] for _ in range(size)]
        # Make sure filler doesn't accidentally use 9
        # Place start and target and symbols
        grid[start_r][start_c] = 1
        grid[target_r][target_c] = 2
        for (pr, pc), col in symbol_map.items():
            grid[pr][pc] = col

        # Ensure that start and target are unique colors in the grid (no other 1 or 2)
        # We already avoided that by construction because filler_pool excludes 1 and 2.

        # Done with a valid path
        break

    else:
        # If we exhausted attempts (very unlikely), fall back to a simple straight path
        grid = [[random.choice(filler_pool) for _ in range(size)] for _ in range(size)]
        start_r, start_c = 1, 0
        grid[start_r][start_c] = 1
        path = [(start_r, start_c)]
        direction = (0, 1)
        for k in range(1, min(size - start_c, 4)):
            path.append((start_r, start_c + k))
            grid[start_r][start_c + k] = left_color if (k % 2 == 1) else right_color
        target_r, target_c = path[-1]
        grid[target_r][target_c] = 2

    # Fill remaining cells with random filler colors (they were initially set that way)
    # Guarantee we never use color 9 in the input

    # Compose the output by painting the path (including start and target) with 9
    output = [row[:] for row in grid]
    for (pr, pc) in path:
        output[pr][pc] = 9

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input (tuple of tuples) to a mutable list of lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0]) if h > 0 else 0

    # Helper to turn left/right
    def turn_left(d):
        return (-d[1], d[0])

    def turn_right(d):
        return (d[1], -d[0])

    # Find unique start (color 1) and unique target (color 2)
    start = None
    target = None
    for r in range(h):
        for c in range(w):
            v = grid[r][c]
            if v == 1:
                start = (r, c)
            elif v == 2:
                target = (r, c)
    # If either missing, return the grid unchanged
    if start is None or target is None:
        return grid

    # Simulate the path. The rule used by generator: odd-valued symbol => left, even-valued symbol => right.
    cur = start
    direction = (0, 1)  # initially east
    path = [cur]

    max_steps = h * w + 10
    steps = 0
    while cur != target and steps < max_steps:
        steps += 1
        nr = cur[0] + direction[0]
        nc = cur[1] + direction[1]
        # If the next step is out of bounds, abort
        if not (0 <= nr < h and 0 <= nc < w):
            break
        # If next cell is the target, move there and stop
        if (nr, nc) == target:
            path.append((nr, nc))
            cur = (nr, nc)
            break
        val = grid[nr][nc]
        # Based on generator construction, every intermediate path cell has a symbol
        # whose parity determines the turn. If it's missing or equals start/target,
        # the simulation cannot proceed.
        if val == 1 or val == 2:
            # Unexpected symbol; abort to avoid infinite loop
            break
        # Parity rule: odd => left, even => right
        if val % 2 == 1:
            direction = turn_left(direction)
        else:
            direction = turn_right(direction)
        # Step into the cell and continue
        cur = (nr, nc)
        path.append(cur)

    # Produce output by painting the path with color 9 while leaving other cells intact
    out = [row[:] for row in grid]
    for (r, c) in path:
        out[r][c] = 9
    return out
