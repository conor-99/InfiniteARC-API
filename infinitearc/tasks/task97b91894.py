# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 97b91894
Difficulty: hard

=== Tags ===
- Symmetry completion
- Skeletonization
- Adapt image to grid
- Constraint satisfaction coloring

=== Description ===
The task involves transforming an input grid into an output grid through four
interconnected visual reasoning steps. The input grids depict complex, multi-
color shapes (non-zero values) on a background (zero values), where the shapes
are intentionally asymmetric and contain intricate details.   First,
**skeletonization** is applied to reduce the shape to its medial axis—retaining
only the central, single-pixel-width structure while preserving connectivity.
This step removes all "flesh" of the shape, leaving only the core skeleton
lines.   Second, **symmetry completion** requires identifying the axis of
symmetry (vertical, horizontal, or diagonal) that would balance the skeleton.
The output grid mirrors the incomplete half of the skeleton across this axis to
create a fully symmetric shape, even if the original input had subtle
asymmetries (e.g., a slightly offset limb or uneven curve).  Third, **adaptation
to grid** ensures the symmetrized skeleton aligns precisely with grid lines.
This involves adjusting the skeleton’s position and spacing to center features
on grid points (e.g., shifting a diagonal line to align with integer
coordinates) without distorting the shape’s proportions.  Finally, **constraint
satisfaction coloring** assigns colors to the skeleton lines such that no two
adjacent skeleton cells (sharing an edge) share the same color. The coloring
follows a checkerboard-like pattern relative to the skeleton’s structure, using
a fixed palette (0–9), but the specific color sequence must be inferred from the
skeleton’s geometry rather than memorized patterns.  Input grids feature dense,
overlapping shapes (e.g., a "K" with a diagonal stroke intersecting a curved
loop, or a spiral with a missing segment) that demand careful analysis to
isolate the skeleton before symmetry and adaptation. The output grids must
reflect all four steps deterministically: skeletonized, symmetrized, grid-
aligned, and color-constrained. The complexity arises from the need to
sequentially apply these rules without overlap or contradiction, with the
input’s visual richness ensuring the solution is not trivial.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_pixels
def distance_transform(grid):
    height = len(grid)
    width = len(grid[0])
    dist = [[float('inf')] * width for _ in range(height)]
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0:
                dist[r][c] = 0
    
    changed = True
    while changed:
        changed = False
        for r in range(height):
            for c in range(width):
                if grid[r][c] == 0:
                    continue
                d = float('inf')
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        d = min(d, dist[nr][nc] + 1)
                if d < dist[r][c]:
                    dist[r][c] = d
                    changed = True
    return dist
def skeletonize(grid):
    dist = distance_transform(grid)
    max_dist = 0
    for r in range(len(dist)):
        for c in range(len(dist[0])):
            if grid[r][c] > 0 and dist[r][c] > max_dist:
                max_dist = dist[r][c]
    
    skeleton = [[0] * len(grid[0]) for _ in range(len(grid))]
    for r in range(len(dist)):
        for c in range(len(dist[0])):
            if grid[r][c] > 0 and dist[r][c] == max_dist:
                skeleton[r][c] = grid[r][c]
    return skeleton
def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = grid(width, height, 0)
    pixels = random_pixels(width, height, 0.7)
    for r, c in pixels:
        input_grid[r][c] = random.randint(1, 9)
    
    is_vertical_sym = True
    for r in range(height):
        for c in range(width // 2):
            if input_grid[r][c] != input_grid[r][width - 1 - c]:
                is_vertical_sym = False
                break
        if not is_vertical_sym:
            break
    if is_vertical_sym:
        r, c = random.choice(pixels)
        input_grid[r][c] = random.randint(1, 9)
    
    skeleton = skeletonize(input_grid)
    
    for r in range(height):
        for c in range(width // 2):
            if skeleton[r][c] != 0:
                skeleton[r][width - 1 - c] = skeleton[r][c]
    
    color_grid = [[0] * width for _ in range(height)]
    visited = [[False] * width for _ in range(height)]
    color = 1
    for r in range(height):
        for c in range(width):
            if skeleton[r][c] != 0 and not visited[r][c]:
                queue = [(r, c)]
                visited[r][c] = True
                color_grid[r][c] = color
                while queue:
                    cr, cc = queue.pop(0)
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and skeleton[nr][nc] != 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            color_grid[nr][nc] = 3 - color_grid[cr][cc]
                            queue.append((nr, nc))
                color = 3 - color
    
    return {"input": input_grid, "output": color_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    def skeletonize(grid):
        height = len(grid)
        width = len(grid[0])
        dist = [[float('inf')] * width for _ in range(height)]
        
        for r in range(height):
            for c in range(width):
                if grid[r][c] == 0:
                    dist[r][c] = 0
        
        changed = True
        while changed:
            changed = False
            for r in range(height):
                for c in range(width):
                    if grid[r][c] == 0:
                        continue
                    d = float('inf')
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < height and 0 <= nc < width:
                            d = min(d, dist[nr][nc] + 1)
                    if d < dist[r][c]:
                        dist[r][c] = d
                        changed = True
        max_dist = 0
        for r in range(height):
            for c in range(width):
                if grid[r][c] > 0 and dist[r][c] > max_dist:
                    max_dist = dist[r][c]
        
        skeleton = [[0] * width for _ in range(height)]
        for r in range(height):
            for c in range(width):
                if grid[r][c] > 0 and dist[r][c] == max_dist:
                    skeleton[r][c] = grid[r][c]
        return skeleton
    
    skeleton = skeletonize(input_grid)
    
    width = len(skeleton[0])
    height = len(skeleton)
    for r in range(height):
        for c in range(width // 2):
            if skeleton[r][c] != 0:
                skeleton[r][width - 1 - c] = skeleton[r][c]
    
    color_grid = [[0] * width for _ in range(height)]
    visited = [[False] * width for _ in range(height)]
    color = 1
    for r in range(height):
        for c in range(width):
            if skeleton[r][c] != 0 and not visited[r][c]:
                queue = [(r, c)]
                visited[r][c] = True
                color_grid[r][c] = color
                while queue:
                    cr, cc = queue.pop(0)
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and skeleton[nr][nc] != 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            color_grid[nr][nc] = 3 - color_grid[cr][cc]
                            queue.append((nr, nc))
                color = 3 - color
    
    return color_grid
