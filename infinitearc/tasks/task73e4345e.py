# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 73e4345e
Difficulty: very hard

=== Tags ===
- Exclusive or coloring
- Alternating agents
- Pattern modification
- Collapse duplicates
- Associate patterns to colors

=== Description ===
Input grids consist of a complex arrangement of non-overlapping, distinct
patterns (e.g., horizontal/vertical lines, L-shapes, squares) each associated
with a unique color via a fixed mapping (e.g., horizontal lines = color 1,
vertical lines = color 2, squares = color 3). Patterns are arranged such that
adjacent patterns (sharing an edge) alternate between two primary types (e.g.,
horizontal followed by vertical), creating a checkerboard-like alternation in
regions of the grid, while isolated patterns of other types exist elsewhere. The
grid contains no two identical patterns sharing the same color and position.
The transformation applies three sequential rules: 1. **Collapse duplicates**:
Any two orthogonally adjacent patterns of identical type and color are merged
into a single pattern with combined dimensions (e.g., two horizontal lines of
length 3 merge into a line of length 6), preserving the original color. 2.
**Exclusive or coloring**: For every cell adjacent (orthogonally) to a pattern
of a different type, the cell’s color is replaced by the "exclusive or" color
derived from the fixed mapping (e.g., horizontal + vertical → color 4,
horizontal + square → color 5). This mapping is consistent across all inputs and
does not rely on numerical values. 3. **Pattern modification**: After collapse
and coloring, any pattern reduced to a single cell (due to adjacency) is
transformed into a square pattern of its new color, while all other patterns
retain their shape.  The output grid reflects all transformations applied in
sequence, with no pattern overlapping, all colors strictly within 0-9, and no
input-output grid identity. The task requires recognizing pattern types, their
color associations, applying sequential rules to adjacent patterns, and
resolving complex interactions between collapse and coloring operations. The
difficulty stems from the necessity to simultaneously track multiple pattern
types, their spatial relationships, and the non-intuitive exclusive or color
mapping, all while avoiding overwriting valid pattern structures.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, all_pixels

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    bg = 0
    input_grid = grid(width, height, bg)
    
    # Place checkerboard pattern of H (1) and V (2)
    for r in range(0, height - 2, 4):
        for c in range(0, width - 2, 4):
            if (r // 4 + c // 4) % 2 == 0:
                # Place horizontal line (H)
                for i in range(3):
                    if c + i < width:
                        input_grid[r][c + i] = 1
            else:
                # Place vertical line (V)
                for i in range(3):
                    if r + i < height:
                        input_grid[r + i][c] = 2

    # Place clustered S (3) patterns
    s_start_r = height - 6
    s_start_c = width - 6
    for r in range(s_start_r, s_start_r + 4):
        for c in range(s_start_c, s_start_c + 4):
            if (r - s_start_r) < 2 and (c - s_start_c) < 2:
                input_grid[r][c] = 3
    
    # Create output by applying rules
    output_grid = [row[:] for row in input_grid]
    
    # 1. Collapse duplicates (merge adjacent same-type)
    # For S (3) patterns - merge adjacent clusters
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 3:
                # Check down and right for adjacent S
                if r + 1 < height and input_grid[r + 1][c] == 3:
                    output_grid[r + 1][c] = 3
                if c + 1 < width and input_grid[r][c + 1] == 3:
                    output_grid[r][c + 1] = 3

    # 2. Apply XOR coloring
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] == 0:
                types = set()
                for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        color = output_grid[nr][nc]
                        if color != 0:
                            types.add(color)
                if len(types) == 2:
                    a, b = sorted(types)
                    if a == 1 and b == 2:
                        output_grid[r][c] = 4
                    elif a == 1 and b == 3:
                        output_grid[r][c] = 5
                    elif a == 2 and b == 3:
                        output_grid[r][c] = 6

    # 3. Pattern modification (single-cell → square)
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] != 0:
                # Check if single cell
                if (r == 0 or output_grid[r-1][c] == 0) and \
                   (r == height-1 or output_grid[r+1][c] == 0) and \
                   (c == 0 or output_grid[r][c-1] == 0) and \
                   (c == width-1 or output_grid[r][c+1] == 0):
                    # Convert to square
                    for dr in range(2):
                        for dc in range(2):
                            nr, nc = r + dr, c + dc
                            if 0 <= nr < height and 0 <= nc < width:
                                output_grid[nr][nc] = output_grid[r][c]

    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid
from typing import Tuple, List

def p(input_grid: Tuple[Tuple[int, ...], ...]) -> Tuple[Tuple[int, ...], ...]:
    width = len(input_grid[0])
    height = len(input_grid)
    input_list = [list(row) for row in input_grid]
    output_list = [row[:] for row in input_list]
    
    # 1. Collapse duplicates (merge adjacent same-type)
    for r in range(height):
        for c in range(width):
            if input_list[r][c] != 0:
                # Check right and down for adjacent same-type
                if c + 1 < width and input_list[r][c] == input_list[r][c+1]:
                    output_list[r][c+1] = input_list[r][c]
                if r + 1 < height and input_list[r][c] == input_list[r+1][c]:
                    output_list[r+1][c] = input_list[r][c]

    # 2. Apply XOR coloring
    for r in range(height):
        for c in range(width):
            if output_list[r][c] == 0:
                types = set()
                for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        color = output_list[nr][nc]
                        if color != 0:
                            types.add(color)
                if len(types) == 2:
                    a, b = sorted(types)
                    if a == 1 and b == 2:
                        output_list[r][c] = 4
                    elif a == 1 and b == 3:
                        output_list[r][c] = 5
                    elif a == 2 and b == 3:
                        output_list[r][c] = 6

    # 3. Pattern modification (single-cell → square)
    for r in range(height):
        for c in range(width):
            if output_list[r][c] != 0:
                # Check if single cell
                if (r == 0 or output_list[r-1][c] == 0) and \
                   (r == height-1 or output_list[r+1][c] == 0) and \
                   (c == 0 or output_list[r][c-1] == 0) and \
                   (c == width-1 or output_list[r][c+1] == 0):
                    # Convert to square
                    for dr in range(2):
                        for dc in range(2):
                            nr, nc = r + dr, c + dc
                            if 0 <= nr < height and 0 <= nc < width:
                                output_list[nr][nc] = output_list[r][c]

    return tuple(tuple(row) for row in output_list)
