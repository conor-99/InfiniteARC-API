# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: c25643f8
Difficulty: hard

=== Tags ===
- Local symmetry matching
- Flow with decay
- Procedural painting
- Detect symmetry
- Associate images to bools

=== Description ===
Input grids consist of 2D color grids (0-9) with a background of color 0. Non-
background regions form distinct connected shapes (4-connected components) of
uniform color, each occupying a minimal bounding box. Shapes may partially
overlap with the grid boundary but never touch other shapes.  The transformation
requires three sequential steps:  1. **Symmetry Detection**: For each shape,
determine if it exhibits local symmetry within its bounding box. A shape is
vertically symmetric if, for every row in its bounding box, the left and right
halves mirror each other. Similarly, horizontal symmetry requires top-bottom
mirroring. Shapes may exhibit neither, one, or both symmetries (though the
output uses only one detected symmetry type per shape).  2. **Flow Generation**:
For shapes with detected symmetry, initiate a flow from their symmetry axis. The
flow spreads outward in all four orthogonal directions (up/down/left/right)
along background cells (0), decaying in intensity with each step. The color
value at each cell equals the shape's original color minus the orthogonal
distance from the symmetry axis. Values below 0 are clamped to 0.  3.
**Procedural Painting**: Overwrite background cells with the computed decayed
colors. Shapes themselves remain unchanged, and asymmetric shapes generate no
flow. Flow from multiple shapes may overlap; in such cases, the highest computed
color value takes precedence.  The output grid preserves all original shapes
while painting decayed flow patterns on background cells adjacent to symmetric
shapes' axes. The task requires precise symmetry detection followed by spatially
varying color propagation, with no numerical thresholds or external
referencesâ€”only visual pattern recognition and spatial reasoning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from copy import deepcopy


def generate():
    """
    Generate an input/output pair according to the task description.
    - Multiple disjoint uniform-color shapes on a 0 background
    - Some shapes are vertically symmetric, some horizontally symmetric, some asymmetric
    - For symmetric shapes produce a decaying flow from the symmetry axis
    """
    # Grid size
    W = random.randint(7, 15)
    H = random.randint(7, 15)
    grid = [[0 for _ in range(W)] for _ in range(H)]

    # Keep placed bounding boxes to avoid touching other shapes (leave at least one-cell gap)
    placed = []  # list of (r0, r1, c0, c1)
    shapes = []  # (r0, r1, c0, c1, color, type)

    colors = list(range(1, 10))
    random.shuffle(colors)
    color_idx = 0

    num_shapes = random.randint(2, 4)

    # Ensure at least one symmetric shape exists
    first_type = random.choice(['V', 'H', 'BOTH'])
    types = [first_type]
    for _ in range(1, num_shapes):
        types.append(random.choice(['V', 'H', 'BOTH', 'A']))

    # Helper to check margin separation of 1 cell between boxes
    def box_ok(r0, r1, c0, c1):
        for (er0, er1, ec0, ec1) in placed:
            # require at least one-cell gap between boxes
            if not (r1 + 1 < er0 or er1 + 1 < r0 or c1 + 1 < ec0 or ec1 + 1 < c0):
                return False
        return True

    # Place each requested shape
    for stype in types:
        placed_ok = False
        for attempt in range(300):
            # choose box size according to type
            if stype == 'V':
                # vertical-symmetric: prefer odd widths so there's a central column axis
                max_w = min(9, W)
                ws = [w for w in range(3, max_w + 1) if w % 2 == 1]
                if not ws:
                    w = 3
                else:
                    w = random.choice(ws)
                h = random.randint(3, min(9, H))
            elif stype == 'H':
                # horizontal-symmetric: prefer odd heights so there's a central row axis
                max_h = min(9, H)
                hs = [h for h in range(3, max_h + 1) if h % 2 == 1]
                if not hs:
                    h = 3
                else:
                    h = random.choice(hs)
                w = random.randint(3, min(9, W))
            elif stype == 'BOTH':
                w = random.randint(2, min(6, W))
                h = random.randint(2, min(6, H))
            else:  # 'A' asymmetric
                w = random.randint(2, min(6, W))
                h = random.randint(2, min(6, H))

            if w > W or h > H:
                continue

            r0 = random.randint(0, H - h)
            c0 = random.randint(0, W - w)
            r1 = r0 + h - 1
            c1 = c0 + w - 1

            if not box_ok(r0, r1, c0, c1):
                continue

            # choose color
            if color_idx >= len(colors):
                # shouldn't happen with 2..4 shapes, but guard
                break
            color = colors[color_idx]
            color_idx += 1

            # Paint shape according to type
            if stype == 'BOTH':
                for rr in range(r0, r1 + 1):
                    for cc in range(c0, c1 + 1):
                        grid[rr][cc] = color
            elif stype == 'V':
                axis = c0 + (c1 - c0) // 2  # central column (integer)
                max_bulge = axis - c0
                # ensure center column exists for connectivity
                bulge_prev = random.randint(0, max_bulge)
                for rr in range(r0, r1 + 1):
                    # vary bulge slowly so rows are different (break horizontal symmetry) but connected
                    bulge = bulge_prev + random.choice([-1, 0, 1])
                    bulge = max(0, min(max_bulge, bulge))
                    bulge_prev = bulge
                    grid[rr][axis] = color
                    for j in range(1, bulge + 1):
                        lc = axis - j
                        rc = axis + j
                        if lc >= c0:
                            grid[rr][lc] = color
                        if rc <= c1:
                            grid[rr][rc] = color
            elif stype == 'H':
                axis = r0 + (r1 - r0) // 2  # central row
                max_bulge = axis - r0
                bulge_prev = random.randint(0, max_bulge)
                for cc in range(c0, c1 + 1):
                    bulge = bulge_prev + random.choice([-1, 0, 1])
                    bulge = max(0, min(max_bulge, bulge))
                    bulge_prev = bulge
                    grid[axis][cc] = color
                    for j in range(1, bulge + 1):
                        ur = axis - j
                        dr = axis + j
                        if ur >= r0:
                            grid[ur][cc] = color
                        if dr <= r1:
                            grid[dr][cc] = color
            else:  # asymmetric 'A'
                # L-shape: top row + left column inside the box
                for cc in range(c0, c1 + 1):
                    grid[r0][cc] = color
                for rr in range(r0, r1 + 1):
                    grid[rr][c0] = color

            # record placement
            placed.append((r0, r1, c0, c1))
            shapes.append((r0, r1, c0, c1, color, stype))
            placed_ok = True
            break

        if not placed_ok:
            # if any shape cannot be placed, restart generation to avoid degenerate layouts
            return generate()

    # We have an input grid. Now compute the output by detecting components and applying flow rules
    def components_from_grid(g):
        H = len(g)
        W = len(g[0])
        vis = [[False] * W for _ in range(H)]
        comps = []
        for rr in range(H):
            for cc in range(W):
                if g[rr][cc] != 0 and not vis[rr][cc]:
                    color = g[rr][cc]
                    stack = [(rr, cc)]
                    vis[rr][cc] = True
                    comp = []
                    while stack:
                        r, c = stack.pop()
                        comp.append((r, c))
                        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                            nr, nc = r + dr, c + dc
                            if 0 <= nr < H and 0 <= nc < W and not vis[nr][nc] and g[nr][nc] == color:
                                vis[nr][nc] = True
                                stack.append((nr, nc))
                    comps.append((comp, color))
        return comps

    comps = components_from_grid(grid)

    output = deepcopy(grid)

    # For each component detect symmetry and paint flow
    for comp, color in comps:
        cells = comp
        min_r = min(r for r, c in cells)
        max_r = max(r for r, c in cells)
        min_c = min(c for r, c in cells)
        max_c = max(c for r, c in cells)

        # Check vertical symmetry within bounding box
        vertical = True
        for r in range(min_r, max_r + 1):
            for c in range(min_c, max_c + 1):
                val = grid[r][c]
                mir_c = min_c + max_c - c
                if grid[r][mir_c] != val:
                    vertical = False
                    break
            if not vertical:
                break

        # Check horizontal symmetry within bounding box
        horizontal = True
        for r in range(min_r, max_r + 1):
            for c in range(min_c, max_c + 1):
                val = grid[r][c]
                mir_r = min_r + max_r - r
                if grid[mir_r][c] != val:
                    horizontal = False
                    break
            if not horizontal:
                break

        # prefer vertical when both true
        if vertical:
            axis_c = (min_c + max_c) // 2
            for r in range(H):
                for c in range(W):
                    if grid[r][c] == 0:
                        dist = abs(c - axis_c)
                        new_color = color - dist
                        if new_color > output[r][c]:
                            output[r][c] = new_color
        elif horizontal:
            axis_r = (min_r + max_r) // 2
            for r in range(H):
                for c in range(W):
                    if grid[r][c] == 0:
                        dist = abs(r - axis_r)
                        new_color = color - dist
                        if new_color > output[r][c]:
                            output[r][c] = new_color

    # Ensure the output differs from input (there is some painted background); otherwise regenerate
    if output == grid:
        return generate()

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0])

    # Find connected components of nonzero cells (4-connected)
    visited = [[False] * W for _ in range(H)]
    components = []  # list of (cells, color)
    for r in range(H):
        for c in range(W):
            if grid[r][c] != 0 and not visited[r][c]:
                color = grid[r][c]
                stack = [(r, c)]
                visited[r][c] = True
                comp = []
                while stack:
                    cr, cc = stack.pop()
                    comp.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append((comp, color))

    # Start with a copy of the original grid for output
    output = [row[:] for row in grid]

    # For each component detect symmetry and apply flows
    for comp, color in components:
        cells = comp
        min_r = min(r for r, c in cells)
        max_r = max(r for r, c in cells)
        min_c = min(c for r, c in cells)
        max_c = max(c for r, c in cells)

        # Check vertical symmetry within bounding box
        vertical = True
        for r in range(min_r, max_r + 1):
            for c in range(min_c, max_c + 1):
                mir_c = min_c + max_c - c
                if grid[r][c] != grid[r][mir_c]:
                    vertical = False
                    break
            if not vertical:
                break

        # Check horizontal symmetry within bounding box
        horizontal = True
        for r in range(min_r, max_r + 1):
            for c in range(min_c, max_c + 1):
                mir_r = min_r + max_r - r
                if grid[r][c] != grid[mir_r][c]:
                    horizontal = False
                    break
            if not horizontal:
                break

        # Prefer vertical when both
        if vertical:
            axis_c = (min_c + max_c) // 2
            for r in range(H):
                for c in range(W):
                    if grid[r][c] == 0:
                        dist = abs(c - axis_c)
                        new_color = color - dist
                        if new_color > output[r][c]:
                            output[r][c] = new_color
        elif horizontal:
            axis_r = (min_r + max_r) // 2
            for r in range(H):
                for c in range(W):
                    if grid[r][c] == 0:
                        dist = abs(r - axis_r)
                        new_color = color - dist
                        if new_color > output[r][c]:
                            output[r][c] = new_color

    return output

