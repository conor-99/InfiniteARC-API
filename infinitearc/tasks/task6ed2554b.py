# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 6ed2554b
Difficulty: hard

=== Tags ===
- Pattern alignment
- Wavefront timing
- Mirror twins
- Sequential path painting
- Take intersection
- Associate images to numbers

=== Description ===
Input grids are 20×20 or larger, featuring a uniform background color (0)
overlaid with multiple "mirror twin" pairs—each pair consists of two identical
geometric shapes (e.g., 2×2 squares or L-shapes) positioned symmetrically across
a vertical or horizontal axis. Each pair is painted a distinct color from 1 to
9, with no overlapping or touching between pairs. A single wavefront source
(color 0) is placed adjacent to a mirror twin, indicating the initial movement
direction (right). The output grid shows the wavefront’s complete path, painted
sequentially as it propagates. The wavefront moves one cell per step in its
current direction, painting the path with the current color. Upon encountering a
mirror twin cell (color matching the twin’s color), the wavefront reflects
(direction changes 90° clockwise or counterclockwise based on axis alignment),
and the path color updates to the mirror twin’s color. If the path intersects an
existing segment (at a cell where two path segments cross), the intersection
cell is colored with the nearest mirror twin’s color (measured by Manhattan
distance from the intersection to the closest mirror twin cell). Reflections
continue until the wavefront exits the grid, resulting in a complex, multi-
colored path that encodes reflection sequences and intersection handling through
spatial relationships and visual proximity.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(20, 30)
    height = random.randint(20, 30)
    grid = [[0] * width for _ in range(height)]
    
    colors_used = []
    for _ in range(random.randint(2, 5)):
        color = random.choice([c for c in range(1, 10) if c not in colors_used])
        colors_used.append(color)
        axis = random.choice(['vertical', 'horizontal'])
        
        if axis == 'vertical':
            r = random.randint(0, height - 2)
            c = random.randint(0, width // 2 - 2)
            mirror_c = width - 1 - (c + 1)
            for dr in range(2):
                for dc in range(2):
                    if r + dr < height and c + dc < width:
                        grid[r + dr][c + dc] = color
                    if r + dr < height and mirror_c + dc < width:
                        grid[r + dr][mirror_c + dc] = color
        else:
            c = random.randint(0, width - 2)
            r = random.randint(0, height // 2 - 2)
            mirror_r = height - 1 - (r + 1)
            for dr in range(2):
                for dc in range(2):
                    if r + dr < height and c + dc < width:
                        grid[r + dr][c + dc] = color
                    if mirror_r + dr < height and c + dc < width:
                        grid[mirror_r + dr][c + dc] = color
    
    source_pos = None
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0:
                for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] > 0:
                        source_pos = (r, c)
                        break
                if source_pos:
                    break
        if source_pos:
            break
    
    output_grid = [row[:] for row in grid]
    r, c = source_pos
    for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
        nr, nc = r + dr, c + dc
        if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] > 0:
            current_dir = (dr, dc)
            break
    else:
        current_dir = (0, 1)
    
    current_color = 0
    cur_r, cur_c = source_pos
    while True:
        dr, dc = current_dir
        nr, nc = cur_r + dr, cur_c + dc
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        if grid[nr][nc] > 0:
            is_vertical = False
            if 0 <= width - 1 - nc < width and grid[nr][width - 1 - nc] == grid[nr][nc]:
                is_vertical = True
            if is_vertical:
                current_dir = (dc, -dr)
            else:
                current_dir = (-dc, dr)
            current_color = grid[nr][nc]
        else:
            output_grid[nr][nc] = current_color
            cur_r, cur_c = nr, nc
    
    return {'input': grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    
    source_pos = None
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0:
                for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] > 0:
                        source_pos = (r, c)
                        break
                if source_pos:
                    break
        if source_pos:
            break
    
    r, c = source_pos
    for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
        nr, nc = r + dr, c + dc
        if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] > 0:
            current_dir = (dr, dc)
            break
    else:
        current_dir = (0, 1)
    
    current_color = 0
    output_grid = [row[:] for row in grid]
    cur_r, cur_c = source_pos
    
    while True:
        dr, dc = current_dir
        nr, nc = cur_r + dr, cur_c + dc
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        if grid[nr][nc] > 0:
            is_vertical = False
            if 0 <= width - 1 - nc < width and grid[nr][width - 1 - nc] == grid[nr][nc]:
                is_vertical = True
            if is_vertical:
                current_dir = (dc, -dr)
            else:
                current_dir = (-dc, dr)
            current_color = grid[nr][nc]
        else:
            output_grid[nr][nc] = current_color
            cur_r, cur_c = nr, nc
    
    return output_grid
