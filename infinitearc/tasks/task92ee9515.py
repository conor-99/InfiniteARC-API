# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 92ee9515
Difficulty: hard

=== Tags ===
- Remove intruder

=== Description ===
The task involves input grids containing a complex, large connected region
(4-directionally) of cells forming a cohesive shape, surrounded by background
pixels (color 0). Within the grid, there exists exactly one isolated pixel that
does not belong to the largest connected componentâ€”this is the "intruder." The
output grid is generated by removing this single intruder pixel, setting it to
background color (0), while retaining all other pixels of the largest connected
component. The transformation requires identifying the largest contiguous region
through visual pattern analysis (not mathematical operations), recognizing that
the intruder is the sole pixel not connected to the main shape via edge-sharing.
The challenge lies in distinguishing the main structure from the isolated
intruder within a visually complex grid, where the largest component may have
intricate, non-rectangular forms, and the intruder is positioned in a way that
requires careful spatial reasoning to isolate.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    main_size = random.randint(5, 20)
    main_pixels = common.continuous_creature(main_size, width, height)
    input_grid = common.grid(width, height, 0)
    for (r, c) in main_pixels:
        input_grid[r][c] = 1
    intruder_pos = None
    for r in range(height):
        for c in range(width):
            if (r, c) in main_pixels:
                continue
            neighbors = [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]
            if all(n not in main_pixels for n in neighbors):
                intruder_pos = (r, c)
                break
        if intruder_pos:
            break
    if intruder_pos is None:
        for r in range(height):
            for c in range(width):
                if (r, c) not in main_pixels:
                    intruder_pos = (r, c)
                    break
            if intruder_pos:
                break
    r, c = intruder_pos
    input_grid[r][c] = 1
    output_grid = [row[:] for row in input_grid]
    output_grid[r][c] = 0
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    visited = [[False] * width for _ in range(height)]
    components = []
    
    def dfs(r, c, comp):
        if r < 0 or r >= height or c < 0 or c >= width or visited[r][c] or input_grid[r][c] == 0:
            return
        visited[r][c] = True
        comp.append((r, c))
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            dfs(r + dr, c + dc, comp)
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and input_grid[r][c] != 0:
                comp = []
                dfs(r, c, comp)
                components.append(comp)
    
    largest = max(components, key=len)
    intruder = None
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and (r, c) not in largest:
                intruder = (r, c)
                break
        if intruder:
            break
    output = [[input_grid[r][c] for c in range(width)] for r in range(height)]
    if intruder:
        r, c = intruder
        output[r][c] = 0
    return output
