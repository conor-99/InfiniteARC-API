# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: b447eef0
Difficulty: hard

=== Tags ===
- Occlusion reasoning
- Obstacles

=== Description ===
The input grids consist of a 2D array where each cell contains a color value
between 0 and 9. Color 5 represents obstacles that occlude underlying colored
elements. All other colors (0-4, 6-9) represent object elements. The output grid
is generated by replacing each obstacle cell (color 5) with the most frequently
occurring color among its four orthogonally adjacent cells (up, down, left,
right). If multiple colors tie for frequency, the highest numerical value among
the tied colors is selected. For example, if neighbors are colors 2, 3, 3, and
1, the obstacle is replaced with 3. If neighbors are colors 2, 2, 3, and 3, the
obstacle is replaced with 3 (higher value). This rule requires the solver to
infer obscured information through contextual neighbor analysis, making it a
challenging occlusion reasoning task. Input grids feature complex arrangements
of obstacles and object elements at a 15Ã—15 scale, with obstacles positioned to
create ambiguous neighbor configurations that demand careful analysis.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width, height = 15, 15
    input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
    
    for r in range(1, height - 1):
        for c in range(1, width - 1):
            if random.random() < 0.2:
                input_grid[r][c] = 5
    
    output_grid = [row[:] for row in input_grid]
    for r in range(1, height - 1):
        for c in range(1, width - 1):
            if input_grid[r][c] == 5:
                neighbors = [
                    input_grid[r-1][c],
                    input_grid[r+1][c],
                    input_grid[r][c-1],
                    input_grid[r][c+1]
                ]
                counts = {}
                for color in neighbors:
                    counts[color] = counts.get(color, 0) + 1
                max_count = max(counts.values())
                candidates = [color for color, count in counts.items() if count == max_count]
                replacement = max(candidates)
                output_grid[r][c] = replacement
    
    if input_grid == output_grid:
        return generate()
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    output = [row[:] for row in input_grid]
    for r in range(1, height - 1):
        for c in range(1, width - 1):
            if output[r][c] == 5:
                neighbors = [
                    input_grid[r-1][c],
                    input_grid[r+1][c],
                    input_grid[r][c-1],
                    input_grid[r][c+1]
                ]
                counts = {}
                for color in neighbors:
                    counts[color] = counts.get(color, 0) + 1
                max_count = max(counts.values())
                candidates = [color for color, count in counts.items() if count == max_count]
                replacement = max(candidates)
                output[r][c] = replacement
    return output
