# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: d78a7399
Difficulty: hard

=== Tags ===
- Count tiles
- Context sensitive recolor
- Count ver lines

=== Description ===
The task involves transforming input grids where certain columns form vertical
lines (color 5) and remaining regions form connected tiles (non-5 color
regions). For each tile, count the number of adjacent vertical lines (columns of
color 5) to its left and right. If a tile is adjacent to exactly one vertical
line (e.g., at the grid edge or between two lines), recolor the entire tile to
color 2 (red). If a tile is flanked by two vertical lines (between two columns
of color 5), recolor it to color 1 (blue). Vertical lines (color 5) remain
unchanged. The output grid preserves all grid dimensions, with tiles recolored
based on adjacency to vertical lines, while non-tile regions (color 5) stay
constant. This requires identifying connected regions, analyzing column-based
vertical line adjacency, and applying context-sensitive recoloring rulesâ€”making
it challenging due to irregular tile shapes, edge cases, and the need to
distinguish between vertical line adjacency patterns.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = random.randint(3, 30)
    height = random.randint(1, 30)
    num_vertical = min(random.randint(2, 4), width-1)
    vertical_columns = sorted(random.sample(range(width), num_vertical))
    input_grid = [[0]*width for _ in range(height)]
    for col in vertical_columns:
        for row in range(height):
            input_grid[row][col] = 5
    gaps = []
    start = 0
    for col in vertical_columns:
        if start < col:
            gaps.append((start, col-1))
        start = col + 1
    if start < width:
        gaps.append((start, width-1))
    colors = common.random_colors(len(gaps), exclude=[1,2,5])
    for i, (start, end) in enumerate(gaps):
        color = colors[i]
        for col in range(start, end+1):
            for row in range(height):
                input_grid[row][col] = color
    output_grid = [row[:] for row in input_grid]
    for (start, end) in gaps:
        left_adj = (start > 0) and (start-1 in vertical_columns)
        right_adj = (end < width-1) and (end+1 in vertical_columns)
        new_color = 1 if (left_adj and right_adj) else 2
        for col in range(start, end+1):
            for row in range(height):
                output_grid[row][col] = new_color
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    vertical_columns = []
    for col in range(width):
        if all(input_grid[row][col] == 5 for row in range(height)):
            vertical_columns.append(col)
    visited = [[False]*width for _ in range(height)]
    components = []
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and input_grid[r][c] != 5:
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] != 5:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                components.append(component)
    output_grid = [[0]*width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 5:
                output_grid[r][c] = 5
    for comp in components:
        cols = [c for r, c in comp]
        min_col = min(cols)
        max_col = max(cols)
        left_adj = False
        if min_col > 0:
            left_col = min_col - 1
            if all(input_grid[r][left_col] == 5 for r in range(height)):
                left_adj = True
        right_adj = False
        if max_col < width - 1:
            right_col = max_col + 1
            if all(input_grid[r][right_col] == 5 for r in range(height)):
                right_adj = True
        new_color = 1 if (left_adj and right_adj) else 2
        for r, c in comp:
            output_grid[r][c] = new_color
    return output_grid
