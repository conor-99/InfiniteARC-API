# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 487523ab
Difficulty: very hard

=== Tags ===
- Inference from demonstration
- Loop filling
- Remove singletons

=== Description ===
Input grids feature a uniform background color and multiple colored regions.
Some regions form closed loops—connected boundaries that enclose a background
area—and others are singletons (isolated colored cells not adjacent to any other
colored cells). The output grid is created by filling the enclosed background
area within each closed loop with the loop's color and removing all singletons
(changing them to the background color). Closed loops must form a continuous
cycle without branches, and their enclosed areas must be entirely background
before filling. Singletons are defined as any colored cell with no orthogonally
adjacent colored cells. The transformation requires identifying all closed loops
(regardless of shape or size, as long as they enclose an area) and filling their
interiors, while eliminating all isolated cells that do not contribute to a loop
structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    bg_color = random.randint(0, 9)
    loop_color = random.randint(0, 9)
    while loop_color == bg_color:
        loop_color = random.randint(0, 9)
    
    input_grid = grid(width, height, bg_color)
    
    r1 = random.randint(1, height - 3)
    c1 = random.randint(1, width - 3)
    r2 = r1 + 2
    c2 = c1 + 2
    
    for c in range(c1, c2 + 1):
        input_grid[r1][c] = loop_color
    for c in range(c1, c2 + 1):
        input_grid[r2][c] = loop_color
    for r in range(r1 + 1, r2):
        input_grid[r][c1] = loop_color
    for r in range(r1 + 1, r2):
        input_grid[r][c2] = loop_color
    
    num_singletons = random.randint(1, 5)
    for _ in range(num_singletons):
        while True:
            r = random.randint(0, height - 1)
            c = random.randint(0, width - 1)
            if (r == r1 or r == r2 or c == c1 or c == c2) and r1 <= r <= r2 and c1 <= c <= c2:
                continue
            has_neighbor = False
            for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != bg_color:
                    has_neighbor = True
                    break
            if not has_neighbor:
                break
        singleton_color = random.randint(0, 9)
        while singleton_color == bg_color or singleton_color == loop_color:
            singleton_color = random.randint(0, 9)
        input_grid[r][c] = singleton_color
    
    output_grid = [row[:] for row in input_grid]
    
    for r in range(r1 + 1, r2):
        for c in range(c1 + 1, c2):
            output_grid[r][c] = loop_color
    
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] != bg_color and output_grid[r][c] != loop_color:
                has_neighbor = False
                for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and output_grid[nr][nc] != bg_color:
                        has_neighbor = True
                        break
                if not has_neighbor:
                    output_grid[r][c] = bg_color
    
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    all_cells = [cell for row in input_grid for cell in row]
    bg_color = max(set(all_cells), key=all_cells.count)
    
    height, width = len(input_grid), len(input_grid[0])
    visited = [[False] * width for _ in range(height)]
    queue = deque()
    
    for r in range(height):
        for c in [0, width-1]:
            if input_grid[r][c] == bg_color and not visited[r][c]:
                visited[r][c] = True
                queue.append((r, c))
    for c in range(width):
        for r in [0, height-1]:
            if input_grid[r][c] == bg_color and not visited[r][c]:
                visited[r][c] = True
                queue.append((r, c))
    
    while queue:
        r, c = queue.popleft()
        for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == bg_color:
                visited[nr][nc] = True
                queue.append((nr, nc))
    
    inner_background = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == bg_color and not visited[r][c]:
                inner_background.append((r, c))
    
    visited_inner = [[False] * width for _ in range(height)]
    inner_components = []
    for (r, c) in inner_background:
        if not visited_inner[r][c]:
            comp = []
            stack = [(r, c)]
            visited_inner[r][c] = True
            while stack:
                cr, cc = stack.pop()
                comp.append((cr, cc))
                for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited_inner[nr][nc] and (nr, nc) in inner_background:
                        visited_inner[nr][nc] = True
                        stack.append((nr, nc))
            inner_components.append(comp)
    
    # Fix: Convert input_grid to list of lists explicitly
    output_grid = [list(row) for row in input_grid]
    for comp in inner_components:
        fill_color = None
        for (r, c) in comp:
            for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != bg_color:
                    fill_color = input_grid[nr][nc]
                    break
            if fill_color is not None:
                break
        if fill_color is not None:
            for (r, c) in comp:
                output_grid[r][c] = fill_color
    
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] != bg_color:
                has_neighbor = False
                for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and output_grid[nr][nc] != bg_color:
                        has_neighbor = True
                        break
                if not has_neighbor:
                    output_grid[r][c] = bg_color
    
    return output_grid
