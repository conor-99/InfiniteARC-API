# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 7d064570
Difficulty: very hard

=== Tags ===
- Multi source interaction
- Obstacles
- Cooperative beams
- Shape extrusion
- Remove intruder

=== Description ===
# Cooperative Beam Extrusion  Input grids feature a background color with
multiple rectangular obstacle blocks of distinct colors (not the background),
scattered beam sources (single cells with unique colors indicating their
emission direction), and one "intruder" cell—a single cell with a beam color
that does not originate from a valid source or align with any beam path. Beam
sources are positioned such that they emit orthogonally in their natural
direction (e.g., left-edge sources emit rightward, top-edge sources emit
downward). Obstacles are axis-aligned rectangles of solid color, never touching
other obstacles or beam sources.  The output grid transforms the input by:   1.
Tracing all beam paths from valid sources orthogonally in their initial
direction until hitting an obstacle. Upon collision with an obstacle, beams
reflect perpendicularly (e.g., right-moving beams reflect upward/downward off
horizontal obstacles).   2. Identifying cooperative beam intersections: when
beams of the same color meet at a cell, they merge into a single beam that
extrudes a new orthogonal path (e.g., horizontal and vertical beams merge into a
diagonal path, creating a thicker "extruded" shape).   3. Removing the
"intruder" cell (set to background), which is the only beam cell not part of a
connected path originating from a valid source.   4. Preserving all obstacles
and beam sources while ensuring beams never overlap except at cooperative merge
points, and all paths exit the grid without looping.    The transformation
requires simultaneous tracking of beam direction, reflection rules, cooperative
merging logic, and intruder identification—demanding multi-step spatial
reasoning across the entire grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def get_direction(r, c, width, height):
    # Consistent ordering: left edge -> right, right edge -> left, top -> down, bottom -> up
    if c == 0:
        return (0, 1)
    if c == width - 1:
        return (0, -1)
    if r == 0:
        return (1, 0)
    if r == height - 1:
        return (-1, 0)
    return (0, 1)


def trace_beam_on_grid(grid, start_r, start_c, direction):
    height = len(grid)
    width = len(grid[0])
    dr, dc = direction
    path = []
    # We'll treat any non-zero cell as blocking during tracing (obstacles and sources)
    r, c = start_r, start_c
    path.append((r, c))
    visited = set()
    # record direction of entry for each cell (H or V)
    dirs = {}
    # assign starting cell the emission direction
    dirs[(r, c)] = 'H' if dr == 0 else 'V'

    while True:
        state = (r, c, dr, dc)
        if state in visited:
            break
        visited.add(state)
        nr, nc = r + dr, c + dc
        # exit grid
        if not (0 <= nr < height and 0 <= nc < width):
            break
        val = grid[nr][nc]
        if val != 0:
            # reflect: horizontal -> try up then down; vertical -> try left then right
            if dr == 0:
                reflected = False
                for ndr, ndc in [(-1, 0), (1, 0)]:
                    cr, cc = r + ndr, c + ndc
                    if 0 <= cr < height and 0 <= cc < width and grid[cr][cc] == 0:
                        dr, dc = ndr, ndc
                        r, c = cr, cc
                        path.append((r, c))
                        dirs[(r, c)] = 'H' if dr == 0 else 'V'
                        reflected = True
                        break
                if not reflected:
                    break
            else:
                reflected = False
                for ndr, ndc in [(0, -1), (0, 1)]:
                    cr, cc = r + ndr, c + ndc
                    if 0 <= cr < height and 0 <= cc < width and grid[cr][cc] == 0:
                        dr, dc = ndr, ndc
                        r, c = cr, cc
                        path.append((r, c))
                        dirs[(r, c)] = 'H' if dr == 0 else 'V'
                        reflected = True
                        break
                if not reflected:
                    break
        else:
            r, c = nr, nc
            path.append((r, c))
            dirs[(r, c)] = 'H' if dr == 0 else 'V'
    return path, dirs


def generate():
    # grid size chosen to allow space for obstacles and sources
    width = random.randint(12, 20)
    height = random.randint(12, 20)
    grid = [[0 for _ in range(width)] for _ in range(height)]

    # Place obstacles: rectangles with distinct colors 2..9
    obstacle_colors = list(range(2, 10))
    random.shuffle(obstacle_colors)
    obstacles = []  # list of (top,left,w,h,color)

    num_obstacles = random.randint(3, 5)
    tries = 0
    for i in range(num_obstacles):
        placed = False
        color = obstacle_colors[i % len(obstacle_colors)]
        max_attempts = 200
        attempt = 0
        while attempt < max_attempts and not placed:
            attempt += 1
            tries += 1
            # ensure at least one empty cell between obstacle and the border (so obstacles do not touch sources)
            w = random.randint(2, min(4, width - 6))
            h = random.randint(2, min(4, height - 6))
            top = random.randint(2, height - h - 3)
            left = random.randint(2, width - w - 3)
            # check not overlapping or adjacent to existing obstacles
            ok = True
            for (ot, ol, ow, oh, _) in obstacles:
                # require 1-cell gap between rectangles
                if not (top + h + 1 < ot or ot + oh + 1 < top or left + w + 1 < ol or ol + ow + 1 < left):
                    ok = False
                    break
            if not ok:
                continue
            # place
            for r in range(top, top + h):
                for c in range(left, left + w):
                    grid[r][c] = color
            obstacles.append((top, left, w, h, color))
            placed = True
        # if we couldn't place, just stop adding obstacles
        if not placed:
            break

    # Place sources on edges (color 1), avoid corners to keep deterministic directions
    sources = []
    # ensure at least 2 sources
    desired_sources = random.randint(3, 6)
    attempts = 0
    while len(sources) < desired_sources and attempts < desired_sources * 50:
        attempts += 1
        side = random.choice(['left', 'right', 'top', 'bottom'])
        if side == 'left':
            r = random.randint(1, height - 2)
            c = 0
        elif side == 'right':
            r = random.randint(1, height - 2)
            c = width - 1
        elif side == 'top':
            c = random.randint(1, width - 2)
            r = 0
        else:
            c = random.randint(1, width - 2)
            r = height - 1
        if grid[r][c] != 0:
            continue
        # ensure not adjacent to an obstacle (obstacles were placed away from border so this is usually OK)
        adjacent_to_obstacle = False
        for dr in (-1, 0, 1):
            for dc in (-1, 0, 1):
                rr, cc = r + dr, c + dc
                if 0 <= rr < height and 0 <= cc < width and grid[rr][cc] >= 2:
                    adjacent_to_obstacle = True
                    break
            if adjacent_to_obstacle:
                break
        if adjacent_to_obstacle:
            continue
        grid[r][c] = 1
        sources.append((r, c))

    if len(sources) < 2:
        # fallback: ensure at least two border sources at fixed positions
        if grid[1][0] == 0:
            grid[1][0] = 1
            sources.append((1, 0))
        if grid[height - 2][width - 1] == 0:
            grid[height - 2][width - 1] = 1
            sources.append((height - 2, width - 1))

    # Compute beam paths (without intruder) on a working grid copy
    working = [row[:] for row in grid]
    all_path = set()
    dir_map = {}  # cell -> set of 'H'/'V'
    for (sr, sc) in sources:
        direction = get_direction(sr, sc, width, height)
        path, dirs = trace_beam_on_grid(working, sr, sc, direction)
        for cell in path:
            all_path.add(cell)
        for k, v in dirs.items():
            dir_map.setdefault(k, set()).add(v)

    # Choose an intruder cell: it must be empty and NOT part of any beam path and not on border
    candidates = []
    for r in range(2, height - 2):
        for c in range(2, width - 2):
            if working[r][c] == 0 and (r, c) not in all_path:
                candidates.append((r, c))
    if not candidates:
        # broaden if none
        for r in range(1, height - 1):
            for c in range(1, width - 1):
                if working[r][c] == 0 and (r, c) not in all_path:
                    candidates.append((r, c))
    if not candidates:
        # as absolute fallback, pick any empty interior cell
        for r in range(height):
            for c in range(width):
                if working[r][c] == 0:
                    candidates.append((r, c))
    intruder = random.choice(candidates)
    grid[intruder[0]][intruder[1]] = 1

    # Build output: include all beam path cells and cooperative extrusions
    output = [row[:] for row in grid]
    # First clear any interior 1 (intruder) in output will be removed after marking beams
    # Mark path cells
    for (r, c) in all_path:
        if output[r][c] == 0:
            output[r][c] = 1
    # Handle cooperative intersections: where a cell has both H and V
    extruded = set()
    for (r, c), s in dir_map.items():
        if 'H' in s and 'V' in s:
            # try to extrude four-neighborhood into empty cells that are not already on a path
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    if output[nr][nc] == 0 and (nr, nc) not in all_path:
                        extruded.add((nr, nc))
    for (r, c) in extruded:
        output[r][c] = 1

    # Remove intruder from output
    output[intruder[0]][intruder[1]] = 0

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    def get_direction(r, c):
        if c == 0:
            return (0, 1)
        if c == width - 1:
            return (0, -1)
        if r == 0:
            return (1, 0)
        if r == height - 1:
            return (-1, 0)
        return (0, 1)

    def trace_beam_on_grid(grid_ref, start_r, start_c, direction):
        dr, dc = direction
        r, c = start_r, start_c
        path = []
        dirs = {}
        visited = set()
        path.append((r, c))
        dirs[(r, c)] = 'H' if dr == 0 else 'V'
        while True:
            state = (r, c, dr, dc)
            if state in visited:
                break
            visited.add(state)
            nr, nc = r + dr, c + dc
            if not (0 <= nr < height and 0 <= nc < width):
                break
            val = grid_ref[nr][nc]
            if val != 0:
                # reflect
                if dr == 0:
                    reflected = False
                    for ndr, ndc in [(-1, 0), (1, 0)]:
                        cr, cc = r + ndr, c + ndc
                        if 0 <= cr < height and 0 <= cc < width and grid_ref[cr][cc] == 0:
                            dr, dc = ndr, ndc
                            r, c = cr, cc
                            path.append((r, c))
                            dirs[(r, c)] = 'H' if dr == 0 else 'V'
                            reflected = True
                            break
                    if not reflected:
                        break
                else:
                    reflected = False
                    for ndr, ndc in [(0, -1), (0, 1)]:
                        cr, cc = r + ndr, c + ndc
                        if 0 <= cr < height and 0 <= cc < width and grid_ref[cr][cc] == 0:
                            dr, dc = ndr, ndc
                            r, c = cr, cc
                            path.append((r, c))
                            dirs[(r, c)] = 'H' if dr == 0 else 'V'
                            reflected = True
                            break
                    if not reflected:
                        break
            else:
                r, c = nr, nc
                path.append((r, c))
                dirs[(r, c)] = 'H' if dr == 0 else 'V'
        return path, dirs

    # Prepare a working grid for tracing where interior 1s (intruder) are treated as empty
    working = [[0 for _ in range(width)] for _ in range(height)]
    sources = []
    for r in range(height):
        for c in range(width):
            val = grid[r][c]
            if val >= 2:
                working[r][c] = val
            elif val == 1:
                # treat border 1s as sources, interior 1s as empty (intruder)
                if r == 0 or c == 0 or r == height - 1 or c == width - 1:
                    working[r][c] = 1
                    sources.append((r, c))
                else:
                    working[r][c] = 0
            else:
                working[r][c] = 0

    all_path = set()
    dir_map = {}
    for (sr, sc) in sources:
        direction = get_direction(sr, sc)
        path, dirs = trace_beam_on_grid(working, sr, sc, direction)
        for cell in path:
            all_path.add(cell)
        for k, v in dirs.items():
            dir_map.setdefault(k, set()).add(v)

    # Build output from original grid: preserve obstacles and sources
    output = [row[:] for row in grid]
    # mark beam path cells (including sources)
    for (r, c) in all_path:
        output[r][c] = 1
    # cooperative extrusions
    extruded = set()
    for (r, c), s in dir_map.items():
        if 'H' in s and 'V' in s:
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    if output[nr][nc] == 0 and (nr, nc) not in all_path:
                        extruded.add((nr, nc))
    for (r, c) in extruded:
        output[r][c] = 1

    # remove intruder(s): any interior 1 not part of path should be cleared
    for r in range(1, height - 1):
        for c in range(1, width - 1):
            if grid[r][c] == 1 and (r, c) not in all_path:
                output[r][c] = 0

    return tuple(tuple(row) for row in output)

