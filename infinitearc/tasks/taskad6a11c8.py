# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: ad6a11c8
Difficulty: hard

=== Tags ===
- Reflect by color
- Split and merge
- Tile mutation rule
- Field based motion
- Draw x on largest object

=== Description ===
**Task Name**: Reflective Split Merge Field  **Description**:  Input grids
contain a background (color 0) and multiple connected regions (tiles) of colors
1–9. Tiles of colors 5–9 are **reflective** and act as mirrors, while tiles of
colors 1–4 are **moving** and follow a field: color 1 moves right, 2 moves down,
3 moves left, 4 moves up. The grid may contain multiple moving tiles, each with
a single color, and reflective tiles of varying colors.  **Transformation
Rules**:  1. **Field Motion**: Each moving tile (colors 1–4) shifts one cell in
its direction (right, down, left, up) per iteration. Tiles move until they hit a
boundary or a reflective tile.  2. **Reflection**: Upon collision with a
reflective tile (colors 5–9), the moving tile’s direction is reflected based on
the reflective tile’s color:    - Color 5: horizontal reflection (reverses
left/right movement)    - Color 6: vertical reflection (reverses up/down
movement)    - Color 7: diagonal reflection (swaps horizontal and vertical
movement)    - Color 8: no direction change (tile stops moving)    - Color 9:
**split** – the moving tile divides into two equal parts (e.g., top/bottom for
vertical splits), each moving in the reflected direction.  3. **Tile Mutation**:
After each reflection or movement, any tile adjacent (4-directionally) to a
reflective tile (colors 5–9) changes its color to match the reflective tile’s
color.  4. **Split and Merge**: Split tiles (from color 9 reflections) move in
their new directions and merge with adjacent tiles of the same color after
moving. Merging combines tiles into a single connected region.  5. **Draw X**:
After all transformations, identify the **largest connected component** (by cell
count) in the grid. If multiple components have the same size, choose the one
with the highest color value. Place an 'X' (two diagonal lines crossing the
center cell) using color 9 in this component.  **Output Grid**:  The output grid
is identical to the input after applying all transformation rules. The 'X' is
drawn only in the largest component, leaving all other elements unchanged. No
tiles overlap, and all transformations are deterministic and consistent with the
rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid


def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = grid(width, height, 0)
    output_grid = grid(width, height, 0)

    # Place reflective tiles (5-9)
    reflective_colors = [5, 6, 7, 8, 9]
    for _ in range(random.randint(2, 5)):
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        input_grid[r][c] = random.choice(reflective_colors)

    # Place moving tiles (1-4)
    directions = {1: (0, 1), 2: (1, 0), 3: (0, -1), 4: (-1, 0)}
    moving_tiles = {}
    for _ in range(random.randint(2, 5)):
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        color = random.randint(1, 4)
        input_grid[r][c] = color
        moving_tiles[(r, c)] = color

    # Move tiles and handle collisions
    new_grid = [row[:] for row in input_grid]
    for (r, c), color in moving_tiles.items():
        dr, dc = directions[color]
        nr, nc = r + dr, c + dc
        if 0 <= nr < height and 0 <= nc < width:
            if input_grid[nr][nc] >= 5:  # Reflective tile
                reflective_color = input_grid[nr][nc]
                if reflective_color == 5:  # Horizontal
                    dr, dc = -dr, dc
                elif reflective_color == 6:  # Vertical
                    dr, dc = dr, -dc
                elif reflective_color == 7:  # Diagonal
                    dr, dc = dc, dr
                elif reflective_color == 8:  # Stop
                    continue
                elif reflective_color == 9:  # Split
                    new_grid[r][c] = 0  # Remove original tile
                    if dr == 0:  # Horizontal movement
                        if r-1 >= 0:
                            new_grid[r-1][c] = color
                        if r+1 < height:
                            new_grid[r+1][c] = color
                    else:  # Vertical movement
                        if c-1 >= 0:
                            new_grid[r][c-1] = color
                        if c+1 < width:
                            new_grid[r][c+1] = color
                    continue
                # Update direction
                directions[color] = (dr, dc)
                # Stay in place
                new_grid[r][c] = color
            else:
                new_grid[nr][nc] = color
                new_grid[r][c] = 0
        else:
            new_grid[r][c] = color  # Boundary, stay

    # Apply mutation: tiles adjacent to reflective tiles change color
    for r in range(height):
        for c in range(width):
            if new_grid[r][c] >= 5:  # Reflective tile
                for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and new_grid[nr][nc] != 0:
                        new_grid[nr][nc] = new_grid[r][c]

    # Draw X on largest component
    def get_largest_component(grid):
        visited = [[False]*len(grid[0]) for _ in range(len(grid))]
        max_size = 0
        max_component = []
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                if not visited[r][c] and grid[r][c] != 0:
                    stack = [(r, c)]
                    component = []
                    visited[r][c] = True
                    while stack:
                        cr, cc = stack.pop()
                        component.append((cr, cc))
                        for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and not visited[nr][nc] and grid[nr][nc] == grid[r][c]:
                                visited[nr][nc] = True
                                stack.append((nr, nc))
                    if len(component) > max_size:
                        max_size = len(component)
                        max_component = component
        return max_component

    largest_comp = get_largest_component(new_grid)
    if largest_comp:
        r_sum, c_sum = 0, 0
        for r, c in largest_comp:
            r_sum += r
            c_sum += c
        r_center = r_sum // len(largest_comp)
        c_center = c_sum // len(largest_comp)
        # Draw X (9) at center
        new_grid[r_center][c_center] = 9
        for dr, dc in [(-1,-1), (-1,1), (1,-1), (1,1)]:
            nr, nc = r_center + dr, c_center + dc
            if 0 <= nr < height and 0 <= nc < width:
                new_grid[nr][nc] = 9

    # Ensure input != output
    if input_grid == new_grid:
        return generate()

    return {
        "input": input_grid,
        "output": new_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert tuple to list of lists
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)

    # Directions for moving tiles
    directions = {1: (0, 1), 2: (1, 0), 3: (0, -1), 4: (-1, 0)}
    moving_tiles = {}

    # Identify moving tiles (1-4)
    for r in range(height):
        for c in range(width):
            if 1 <= grid[r][c] <= 4:
                moving_tiles[(r, c)] = grid[r][c]

    # Move tiles and handle collisions
    new_grid = [row[:] for row in grid]
    for (r, c), color in moving_tiles.items():
        dr, dc = directions[color]
        nr, nc = r + dr, c + dc
        if 0 <= nr < height and 0 <= nc < width:
            if grid[nr][nc] >= 5:  # Reflective tile
                reflective_color = grid[nr][nc]
                if reflective_color == 5:  # Horizontal
                    dr, dc = -dr, dc
                elif reflective_color == 6:  # Vertical
                    dr, dc = dr, -dc
                elif reflective_color == 7:  # Diagonal
                    dr, dc = dc, dr
                elif reflective_color == 8:  # Stop
                    continue
                elif reflective_color == 9:  # Split
                    new_grid[r][c] = 0  # Remove original tile
                    if dr == 0:  # Horizontal movement
                        if r-1 >= 0:
                            new_grid[r-1][c] = color
                        if r+1 < height:
                            new_grid[r+1][c] = color
                    else:  # Vertical movement
                        if c-1 >= 0:
                            new_grid[r][c-1] = color
                        if c+1 < width:
                            new_grid[r][c+1] = color
                    continue
                # Update direction
                directions[color] = (dr, dc)
                # Stay in place
                new_grid[r][c] = color
            else:
                new_grid[nr][nc] = color
                new_grid[r][c] = 0
        else:
            new_grid[r][c] = color  # Boundary, stay

    # Apply mutation: tiles adjacent to reflective tiles change color
    for r in range(height):
        for c in range(width):
            if new_grid[r][c] >= 5:  # Reflective tile
                for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and new_grid[nr][nc] != 0:
                        new_grid[nr][nc] = new_grid[r][c]

    # Draw X on largest component
    def get_largest_component(grid):
        visited = [[False]*len(grid[0]) for _ in range(len(grid))]
        max_size = 0
        max_component = []
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                if not visited[r][c] and grid[r][c] != 0:
                    stack = [(r, c)]
                    component = []
                    visited[r][c] = True
                    while stack:
                        cr, cc = stack.pop()
                        component.append((cr, cc))
                        for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and not visited[nr][nc] and grid[nr][nc] == grid[r][c]:
                                visited[nr][nc] = True
                                stack.append((nr, nc))
                    if len(component) > max_size:
                        max_size = len(component)
                        max_component = component
        return max_component

    largest_comp = get_largest_component(new_grid)
    if largest_comp:
        r_sum, c_sum = 0, 0
        for r, c in largest_comp:
            r_sum += r
            c_sum += c
        r_center = r_sum // len(largest_comp)
        c_center = c_sum // len(largest_comp)
        # Draw X (9) at center
        new_grid[r_center][c_center] = 9
        for dr, dc in [(-1,-1), (-1,1), (1,-1), (1,1)]:
            nr, nc = r_center + dr, c_center + dc
            if 0 <= nr < height and 0 <= nc < width:
                new_grid[nr][nc] = 9

    return [tuple(row) for row in new_grid]
