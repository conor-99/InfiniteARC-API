# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 1254c9c9
Difficulty: medium

=== Tags ===
- Pattern differences
- Bring patterns close
- Reorder blocks by size

=== Description ===
The input grid contains multiple distinct colored blocks (connected regions of
non-zero values) separated by background (value 0). Each block represents a
unique visual pattern. The task requires identifying all connected blocks (using
4-directional connectivity), sorting them by size (number of cells) in ascending
order, and rearranging them in the output grid such that they form a single
contiguous sequence along the top row from left to right. The smallest block
appears first, followed by progressively larger blocks. Each block is positioned
without rotation or resizing, maintaining its original shape and orientation.
The remaining cells in the grid are filled with the background color (0). This
transformation "brings patterns close" by clustering them together in the top
row while "reordering blocks by size" to create a visually ordered sequence.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, continuous_creature, random_colors

def generate():
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    input_grid = grid(width, height, 0)
    
    num_blocks = random.randint(3, 5)
    colors = random_colors(num_blocks, exclude=[0])
    blocks = []
    
    for i in range(num_blocks):
        size = random.randint(2, 5)
        pixels = continuous_creature(size, width=3, height=3)
        
        # Try to find valid placement
        placed = False
        while not placed:
            start_r = random.randint(0, height - 3)
            start_c = random.randint(0, width - 3)
            block_positions = [(r + start_r, c + start_c) for (r, c) in pixels]
            
            # Check if all positions are unoccupied and within bounds
            valid = True
            for r, c in block_positions:
                if r >= height or c >= width or input_grid[r][c] != 0:
                    valid = False
                    break
            
            if valid:
                for r, c in block_positions:
                    input_grid[r][c] = colors[i]
                blocks.append((colors[i], block_positions))
                placed = True
    
    # Sort by size, then by top-left coordinates
    blocks.sort(key=lambda x: (len(x[1]), min(r for r, c in x[1]), min(c for r, c in x[1])))
    
    total_width = 0
    max_height = 0
    for color, positions in blocks:
        rows = [r for r, c in positions]
        cols = [c for r, c in positions]
        min_row = min(rows)
        max_row = max(rows)
        min_col = min(cols)
        max_col = max(cols)
        width_block = max_col - min_col + 1
        height_block = max_row - min_row + 1
        total_width += width_block
        if height_block > max_height:
            max_height = height_block
    
    output_grid = grid(total_width, max_height, 0)
    
    current_x = 0
    for color, positions in blocks:
        rows = [r for r, c in positions]
        cols = [c for r, c in positions]
        min_row = min(rows)
        max_row = max(rows)
        min_col = min(cols)
        max_col = max(cols)
        for r, c in positions:
            new_r = r - min_row
            new_c = current_x + (c - min_col)
            output_grid[new_r][new_c] = color
        current_x += (max_col - min_col + 1)
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    visited = set()
    components = []
    rows = len(input_grid)
    cols = len(input_grid[0])
    
    for r in range(rows):
        for c in range(cols):
            if input_grid[r][c] != 0 and (r, c) not in visited:
                color = input_grid[r][c]
                queue = [(r, c)]
                visited.add((r, c))
                comp = []
                while queue:
                    cr, cc = queue.pop(0)
                    comp.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < rows and 0 <= nc < cols and input_grid[nr][nc] == color and (nr, nc) not in visited:
                            visited.add((nr, nc))
                            queue.append((nr, nc))
                components.append((color, comp))
    
    # Sort by size, then by top-left coordinates
    components.sort(key=lambda x: (len(x[1]), min(r for r, c in x[1]), min(c for r, c in x[1])))
    
    total_width = 0
    max_height = 0
    for color, comp in components:
        rows_list = [r for r, c in comp]
        cols_list = [c for r, c in comp]
        min_row = min(rows_list)
        max_row = max(rows_list)
        min_col = min(cols_list)
        max_col = max(cols_list)
        width_block = max_col - min_col + 1
        height_block = max_row - min_row + 1
        total_width += width_block
        if height_block > max_height:
            max_height = height_block
    
    output_grid = grid(total_width, max_height, 0)
    
    current_x = 0
    for color, comp in components:
        rows_list = [r for r, c in comp]
        cols_list = [c for r, c in comp]
        min_row = min(rows_list)
        max_row = max(rows_list)
        min_col = min(cols_list)
        max_col = max(cols_list)
        for r, c in comp:
            new_r = r - min_row
            new_c = current_x + (c - min_col)
            output_grid[new_r][new_c] = color
        current_x += (max_col - min_col + 1)
    
    return output_grid
