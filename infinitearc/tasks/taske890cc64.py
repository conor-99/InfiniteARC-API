# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: e890cc64
Difficulty: hard

=== Tags ===
- Color wavefront
- Loopless path

=== Description ===
Input grids contain a background color (0), solid walls (color 5), and wavefront
emitters (colors 1-4). Each emitter color corresponds to a fixed cardinal
direction: color 1 propagates upward, color 2 to the right, color 3 to the left,
and color 4 downward. Propagation continues in the emitter's direction for all
contiguous background cells (0) until encountering a wall (color 5) or grid
boundary. The output grid retains all original elements except for the
propagation paths, which are drawn using the emitter's color. Walls block
propagation but remain unchanged. Emitters themselves remain visible in the
output. All propagation paths are straight-line, non-overlapping, and terminate
at walls or edges without looping. The task requires identifying the color-
direction mapping through input-output examples and applying the propagation
rule to all emitters simultaneously.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid
def generate():
    width = random.randint(5, 20)
    height = random.randint(5, 20)
    grid_in = grid(width, height, 0)
    
    num_walls = random.randint(3, 5)
    for _ in range(num_walls):
        if random.choice([True, False]):
            row = random.randint(0, height-1)
            length = random.randint(1, 3)
            start_col = random.randint(0, width - length)
            for c in range(start_col, start_col + length):
                grid_in[row][c] = 5
        else:
            col = random.randint(0, width-1)
            length = random.randint(1, 3)
            start_row = random.randint(0, height - length)
            for r in range(start_row, start_row + length):
                grid_in[r][col] = 5
    
    directions = [1, 2, 3, 4]
    for d in directions:
        valid_positions = []
        for r in range(height):
            for c in range(width):
                if grid_in[r][c] != 0:
                    continue
                dr, dc = 0, 0
                if d == 1: dr, dc = -1, 0
                elif d == 2: dr, dc = 0, 1
                elif d == 3: dr, dc = 0, -1
                elif d == 4: dr, dc = 1, 0
                nr, nc = r + dr, c + dc
                if nr < 0 or nr >= height or nc < 0 or nc >= width:
                    continue
                if grid_in[nr][nc] != 0:
                    continue
                cr, cc = nr, nc
                while 0 <= cr < height and 0 <= cc < width:
                    if grid_in[cr][cc] == 5:
                        break
                    cr += dr
                    cc += dc
                else:
                    pass
                valid_positions.append((r, c))
        if valid_positions:
            r, c = random.choice(valid_positions)
            grid_in[r][c] = d
    
    grid_out = [row[:] for row in grid_in]
    for r in range(height):
        for c in range(width):
            d = grid_in[r][c]
            if d < 1 or d > 4:
                continue
            dr, dc = 0, 0
            if d == 1: dr, dc = -1, 0
            elif d == 2: dr, dc = 0, 1
            elif d == 3: dr, dc = 0, -1
            elif d == 4: dr, dc = 1, 0
            cr, cc = r + dr, c + dc
            while 0 <= cr < height and 0 <= cc < width:
                if grid_in[cr][cc] == 5:
                    break
                if grid_in[cr][cc] == 0:
                    grid_out[cr][cc] = d
                cr += dr
                cc += dc
    return {"input": grid_in, "output": grid_out}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])
    grid_out = [row[:] for row in grid_in]
    
    for r in range(height):
        for c in range(width):
            d = grid_in[r][c]
            if d < 1 or d > 4:
                continue
            dr, dc = 0, 0
            if d == 1:
                dr, dc = -1, 0
            elif d == 2:
                dr, dc = 0, 1
            elif d == 3:
                dr, dc = 0, -1
            elif d == 4:
                dr, dc = 1, 0
            cr, cc = r + dr, c + dc
            while 0 <= cr < height and 0 <= cc < width:
                if grid_in[cr][cc] == 5:
                    break
                if grid_in[cr][cc] == 0:
                    grid_out[cr][cc] = d
                cr += dr
                cc += dc
    return tuple(tuple(row) for row in grid_out)
