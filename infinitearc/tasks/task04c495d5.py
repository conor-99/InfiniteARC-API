# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 04c495d5
Difficulty: hard

=== Tags ===
- Assemble from parts
- Count hor lines
- Pattern alignment

=== Description ===
The input grid consists of non-zero color segments arranged horizontally within
rows. Each contiguous horizontal segment (a sequence of adjacent cells in the
same row with identical non-zero color, ignoring zeros) is treated as an
individual "part." The output grid is constructed by assembling these parts into
rows of uniform length, where the length equals the maximum segment length found
in the input. Each segment is centered within its row (padded with zeros on both
sides to maintain alignment), and the segments are ordered from longest to
shortest. This requires identifying horizontal segments across rows, counting
their lengths, and applying a precise centering pattern to align the parts into
the output grid. The transformation is non-trivial due to the need to
distinguish between contiguous segments (not entire rows) and the requirement to
center each segment within a fixed row length.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid
def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    input_grid = grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            if random.random() > 0.5:
                input_grid[r][c] = random.randint(1, 9)
    if all(input_grid[r][c] == 0 for r in range(height) for c in range(width)):
        return generate()
    segments = []
    for r in range(height):
        c = 0
        while c < width:
            if input_grid[r][c] == 0:
                c += 1
                continue
            color = input_grid[r][c]
            start = c
            while c < width and input_grid[r][c] == color:
                c += 1
            length = c - start
            segments.append((color, length))
    if not segments:
        return generate()
    if len(segments) > 30:
        return generate()
    max_len = max(length for _, length in segments)
    segments.sort(key=lambda x: x[1], reverse=True)
    output_grid = []
    for color, length in segments:
        left_pad = (max_len - length) // 2
        right_pad = max_len - length - left_pad
        row = [0] * left_pad + [color] * length + [0] * right_pad
        output_grid.append(row)
    if input_grid == output_grid:
        return generate()
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    segments = []
    for r in range(height):
        c = 0
        while c < width:
            if input_grid[r][c] == 0:
                c += 1
                continue
            color = input_grid[r][c]
            start = c
            while c < width and input_grid[r][c] == color:
                c += 1
            length = c - start
            segments.append((color, length))
    if not segments:
        return []
    max_len = max(length for _, length in segments)
    segments.sort(key=lambda x: x[1], reverse=True)
    output_grid = []
    for color, length in segments:
        left_pad = (max_len - length) // 2
        right_pad = max_len - length - left_pad
        row = [0] * left_pad + [color] * length + [0] * right_pad
        output_grid.append(row)
    return output_grid
