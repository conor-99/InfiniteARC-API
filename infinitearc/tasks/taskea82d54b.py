# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: ea82d54b
Difficulty: very hard

=== Tags ===
- Energy absorption
- Path scarring
- Color by distance to edge
- Exclusive or coloring

=== Description ===
Input grids consist of a uniform background color (0) and a single, continuous,
unbranched path formed by a distinct non-background color (2-9), traversing from
one grid edge to another. The path is 4-connected, surrounded by background, and
may encounter obstacles (a fixed non-background color, e.g., 3) that do not
intersect the path. The path length varies, and grid dimensions range from 15×15
to 25×25.  In the output grid, each cell along the path undergoes a dual
transformation:   1. **Distance-to-edge mapping**: For each path cell, compute
the minimum distance to any grid edge (top, bottom, left, or right). This
distance is mapped to a secondary color via a consistent, non-linear palette:
distance 1 → color 1, distance 2 → color 2, ..., distance 5 → color 5, distance
≥6 → color 5.   2. **Exclusive-or coloring**: The output color for the cell is
derived from the path's original color and the distance-mapped color using a
fixed, visual XOR-like rule. Specific color pairs (e.g., path color 2 + distance
color 1 → output color 3, path color 2 + distance color 2 → output color 4)
consistently produce unique third colors, forming a pattern discoverable only
through inductive reasoning across multiple examples.    Non-path cells
(background and obstacles) remain unchanged. The transformation manifests as a
"path scarring" effect: the path now displays a dynamic sequence of colors along
its length, where each color reflects the cell's edge proximity and the path's
inherent color. The complexity arises from requiring simultaneous calculation of
edge distances and application of the non-obvious color combination rule, with
no numerical dependencies—only visual pattern recognition through edge-distance
mapping and color interaction.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(15, 25)
    height = random.randint(15, 25)
    input_grid = grid(width, height, 0)
    path_color = random.choice([2,4,5,6,7,8,9])
    obstacle_color = 3
    
    start_col = random.randint(0, width-1)
    end_col = random.randint(0, width-1)
    path = []
    r, c = 0, start_col
    path.append((r, c))
    while r < height - 1:
        if random.random() < 0.6:
            r += 1
        else:
            c += random.choice([-1, 1])
            c = max(0, min(c, width-1))
        path.append((r, c))
    while r < height - 1:
        r += 1
        path.append((r, c))
    
    path = list(dict.fromkeys(path))
    
    for (r, c) in path:
        input_grid[r][c] = path_color
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0 and random.random() < 0.2:
                input_grid[r][c] = obstacle_color
    
    output_grid = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == path_color:
                dist_top = r
                dist_bottom = height - 1 - r
                dist_left = c
                dist_right = width - 1 - c
                min_dist = min(dist_top, dist_bottom, dist_left, dist_right)
                distance = min_dist + 1
                dist_color = min(distance, 5)
                new_color = (path_color + dist_color) % 10
                output_grid[r][c] = new_color
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid_list = [list(row) for row in input_grid]
    height = len(grid_list)
    width = len(grid_list[0])
    
    path_color = None
    for r in range(height):
        for c in range(width):
            if grid_list[r][c] not in [0, 3]:
                path_color = grid_list[r][c]
                break
        if path_color is not None:
            break
    
    if path_color is None:
        return input_grid
    
    for r in range(height):
        for c in range(width):
            if grid_list[r][c] == path_color:
                dist_top = r
                dist_bottom = height - 1 - r
                dist_left = c
                dist_right = width - 1 - c
                min_dist = min(dist_top, dist_bottom, dist_left, dist_right)
                distance = min_dist + 1
                dist_color = min(distance, 5)
                new_color = (path_color + dist_color) % 10
                grid_list[r][c] = new_color
    
    return tuple(tuple(row) for row in grid_list)
