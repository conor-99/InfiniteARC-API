# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 835da086
Difficulty: insane

=== Tags ===
- Guided flow
- Tile mutation rule
- Pattern concatenation
- Replace pattern
- Apply rule from a 2x2 hint grid

=== Description ===
The task features an input grid containing a main canvas of 2x2 colored tile
patterns (e.g., uniform color blocks) and a 2x2 hint grid embedded in the
bottom-right corner. The hint grid defines a cyclic color mutation rule where
each cell's color maps to the next color in a clockwise cycle (e.g., red → blue
→ green → yellow → red). The main grid undergoes this mutation, transforming all
colors according to the hint cycle.  Next, contiguous regions of identical
colors are identified. Each region is decomposed into its constituent 2x2
blocks, which are then concatenated along a guided flow path. The flow path is a
diagonal line of a distinct color (e.g., orange) traversing from the top-left to
bottom-right, with its orientation dictating the concatenation direction (e.g.,
blocks align sequentially along the diagonal). The concatenation replaces the
original region with a linear sequence of 2x2 blocks ordered along the flow
path, preserving their mutated colors.  The output grid displays the mutated
colors across the entire canvas, with contiguous regions replaced by their
concatenated block sequences along the flow path. All other grid elements (non-
contiguous regions, hint grid, and flow path) remain unchanged. The
transformation requires recognizing the cyclic rule from the hint grid, applying
the mutation, identifying contiguous regions, and spatially aligning blocks
along the flow path—combining multiple layered rules into a single deterministic
process.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from copy import deepcopy
from common import grid

def generate():
    # choose main size even between 4 and 18 inclusive
    main_size = random.choice(list(range(4, 20, 2)))
    grid_size = main_size + 2
    # choose cycle colors (distinct)
    colors = list(range(1, 10))
    cycle = random.sample(colors, 4)
    # choose flow color not in cycle
    remaining = [c for c in colors if c not in cycle]
    flow_color = random.choice(remaining)
    # generate main grid filled with 2x2 blocks
    main_grid = grid(main_size, main_size, 0)
    block_positions = [(r, c) for r in range(0, main_size, 2) for c in range(0, main_size, 2)]
    random.shuffle(block_positions)
    # create pool of colors including cycle colors and some extras but excluding flow_color
    pool = [c for c in colors if c != flow_color]
    # ensure each cycle color appears at least once
    assigned_colors = {}
    for i, pos in enumerate(block_positions):
        if i < len(cycle):
            assigned_colors[pos] = cycle[i]
        else:
            assigned_colors[pos] = random.choice(pool)
    # fill 2x2 blocks
    for (br, bc), color in assigned_colors.items():
        for dr in (0,1):
            for dc in (0,1):
                rr = br + dr
                cc = bc + dc
                if rr < main_size and cc < main_size:
                    main_grid[rr][cc] = color
    # set diagonal flow path color
    for i in range(main_size):
        main_grid[i][i] = flow_color
    # build full grid and place main grid and hint
    full_grid = grid(grid_size, grid_size, 0)
    for r in range(main_size):
        for c in range(main_size):
            full_grid[r][c] = main_grid[r][c]
    # place hint (clockwise order: tl, tr, br, bl -> cycle[0..3])
    full_grid[main_size][main_size] = cycle[0]
    full_grid[main_size][main_size+1] = cycle[1]
    full_grid[main_size+1][main_size+1] = cycle[2]
    full_grid[main_size+1][main_size] = cycle[3]
    # input is the original full grid
    input_grid = deepcopy(full_grid)
    # create mutated main grid
    mutated = deepcopy(main_grid)
    for r in range(main_size):
        for c in range(main_size):
            val = main_grid[r][c]
            if val in cycle:
                idx = cycle.index(val)
                mutated[r][c] = cycle[(idx + 1) % len(cycle)]
            else:
                mutated[r][c] = val
    # build output grid starting from input and overwrite main area with mutated
    output_grid = deepcopy(full_grid)
    for r in range(main_size):
        for c in range(main_size):
            output_grid[r][c] = mutated[r][c]
    # now find contiguous regions in mutated grid excluding flow_color and zeros
    visited = [[False]*main_size for _ in range(main_size)]
    for r in range(main_size):
        for c in range(main_size):
            if visited[r][c]: continue
            if mutated[r][c] == flow_color or mutated[r][c] == 0: 
                visited[r][c] = True
                continue
            color = mutated[r][c]
            # BFS
            queue = [(r, c)]
            region = []
            visited[r][c] = True
            while queue:
                cr, cc = queue.pop(0)
                region.append((cr, cc))
                for dr, dc in [(0,1),(1,0),(0,-1),(-1,0)]:
                    nr, nc = cr+dr, cc+dc
                    if 0 <= nr < main_size and 0 <= nc < main_size and not visited[nr][nc] and mutated[nr][nc] == color:
                        visited[nr][nc] = True
                        queue.append((nr, nc))
            # decompose into unique 2x2 block top-left coords
            blocks = []
            seen = set()
            for (rr, cc) in region:
                br = (rr // 2) * 2
                bc = (cc // 2) * 2
                if (br, bc) not in seen:
                    seen.add((br, bc))
                    blocks.append((br, bc))
            # sort blocks deterministically
            blocks.sort()
            # place blocks along the diagonal flow path positions pos = idx*2
            for idx, (br, bc) in enumerate(blocks):
                pos = idx * 2
                if pos >= main_size:
                    break
                for dr in (0,1):
                    for dc in (0,1):
                        dst_r = pos + dr
                        dst_c = pos + dc
                        if 0 <= dst_r < main_size and 0 <= dst_c < main_size:
                            # do not overwrite the flow path
                            if output_grid[dst_r][dst_c] == flow_color:
                                continue
                            # copy mutated block cell to destination
                            val = mutated[br + dr][bc + dc]
                            output_grid[dst_r][dst_c] = val
            # clear original region cells (but keep flow path and hint cells intact)
            for (rr, cc) in region:
                if output_grid[rr][cc] != flow_color:
                    output_grid[rr][cc] = 0
    return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(g):
    from copy import deepcopy
    grid = [list(row) for row in g]
    size = len(grid)
    main_size = size - 2
    if main_size <= 0:
        return grid
    # extract hint clockwise tl,tr,br,bl
    cycle = [grid[main_size][main_size], grid[main_size][main_size+1],
             grid[main_size+1][main_size+1], grid[main_size+1][main_size]]
    # detect flow color as diagonal color of main area (assumed consistent)
    diag = [grid[i][i] for i in range(main_size)]
    if len(set(diag)) == 1:
        flow_color = diag[0]
    else:
        # fallback: choose most common on diagonal
        flow_color = max(set(diag), key=diag.count)
    # create mutated main
    mutated = [[0]*main_size for _ in range(main_size)]
    for r in range(main_size):
        for c in range(main_size):
            val = grid[r][c]
            if val in cycle:
                idx = cycle.index(val)
                mutated[r][c] = cycle[(idx + 1) % len(cycle)]
            else:
                mutated[r][c] = val
    # start output as copy of original grid
    out = deepcopy(grid)
    # write mutated main into output
    for r in range(main_size):
        for c in range(main_size):
            out[r][c] = mutated[r][c]
    # find contiguous regions in mutated excluding flow_color and zero
    visited = [[False]*main_size for _ in range(main_size)]
    for r in range(main_size):
        for c in range(main_size):
            if visited[r][c]:
                continue
            if mutated[r][c] == flow_color or mutated[r][c] == 0:
                visited[r][c] = True
                continue
            color = mutated[r][c]
            # BFS
            queue = [(r,c)]
            region = []
            visited[r][c] = True
            while queue:
                cr, cc = queue.pop(0)
                region.append((cr, cc))
                for dr, dc in [(0,1),(1,0),(0,-1),(-1,0)]:
                    nr, nc = cr+dr, cc+dc
                    if 0 <= nr < main_size and 0 <= nc < main_size and not visited[nr][nc] and mutated[nr][nc] == color:
                        visited[nr][nc] = True
                        queue.append((nr, nc))
            # decompose into 2x2 blocks
            blocks = []
            seen = set()
            for (rr, cc) in region:
                br = (rr // 2) * 2
                bc = (cc // 2) * 2
                if (br, bc) not in seen:
                    seen.add((br, bc))
                    blocks.append((br, bc))
            blocks.sort()
            # place along diagonal positions
            for idx, (br, bc) in enumerate(blocks):
                pos = idx * 2
                if pos >= main_size:
                    break
                for dr in (0,1):
                    for dc in (0,1):
                        dst_r = pos + dr
                        dst_c = pos + dc
                        if 0 <= dst_r < main_size and 0 <= dst_c < main_size:
                            if out[dst_r][dst_c] == flow_color:
                                continue
                            out[dst_r][dst_c] = mutated[br+dr][bc+dc]
            # clear original region cells
            for (rr, cc) in region:
                if out[rr][cc] != flow_color:
                    out[rr][cc] = 0
    return out

