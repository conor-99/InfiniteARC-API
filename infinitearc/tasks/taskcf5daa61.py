# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: cf5daa61
Difficulty: very hard

=== Tags ===
- Inference from demonstration

=== Description ===
Task Name: Contextual Morphology with Adaptive Symmetry  Description: Input
grids feature a complex arrangement of geometric shapes (triangles, squares,
circles) each rendered in a distinct color, positioned asymmetrically across the
grid. The output grid is generated through the following layered
transformations:  1. **Symmetry Axis Determination:** The primary symmetry axis
is dynamically calculated as the vertical line passing through the centroid of
all shapes of the color appearing most frequently in the grid. If multiple
colors share the same frequency, the axis is determined by the color with the
highest numerical value.  2. **Adaptive Shape Reflection:** Each shape is
reflected across the determined axis. For shapes whose reflection would overlap
with another shape, the overlapping region adopts the color of the reflected
shape while maintaining the geometric form of the original shape.  3.
**Contextual Color Morphing:** The color of each shape shifts in a cyclic
sequence (e.g., red → green → blue → red) based on the number of adjacent shapes
sharing the same color. Shapes with an odd number of adjacent same-color
neighbors advance one step in the cycle; those with even numbers revert one
step.  4. **Boundary Alignment:** After reflection and color morphing, all
shapes are aligned to the nearest grid boundary (top, bottom, left, right) based
on their new position, with shapes shifting toward the closest boundary while
maintaining their orientation.  The output grid must precisely reflect all these
transformations, requiring the solver to infer the dynamic axis calculation, the
cyclic color shift logic, and the boundary alignment rules simultaneously from a
minimal set of input-output examples. The complexity arises from the
interdependence of these rules, where the axis determination depends on color
frequency, which affects shape reflection, which in turn influences color
morphing and boundary alignment.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def make_sprite(shape, size):
    pixels = set()
    if shape == 'square':
        for r in range(size):
            for c in range(size):
                pixels.add((r, c))
    elif shape == 'hollow_square':
        for r in range(size):
            for c in range(size):
                if r in (0, size - 1) or c in (0, size - 1):
                    pixels.add((r, c))
    elif shape == 'triangle':
        # right triangle
        for r in range(size):
            for c in range(r + 1):
                pixels.add((r, c))
    elif shape == 'L':
        for r in range(size):
            pixels.add((r, 0))
        for c in range(size):
            pixels.add((size - 1, c))
    elif shape == 'plus':
        center = size // 2
        for i in range(size):
            pixels.add((center, i))
            pixels.add((i, center))
    elif shape == 'line':
        r = size // 2
        for c in range(size):
            pixels.add((r, c))
    else:
        pixels.add((0, 0))
    return list(pixels)


def place_sprite(grid, sprite_pixels, top, left, color):
    for r, c in sprite_pixels:
        grid[top + r][left + c] = color


def get_components(grid):
    height = len(grid)
    width = len(grid[0])
    visited = [[False] * width for _ in range(height)]
    components = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and not visited[r][c]:
                color = grid[r][c]
                stack = [(r, c)]
                visited[r][c] = True
                comp = []
                while stack:
                    cr, cc = stack.pop()
                    comp.append((cr, cc))
                    for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append((color, comp))
    return components


def generate():
    # Grid size
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    input_grid = [[0 for _ in range(width)] for _ in range(height)]

    shape_types = ['square', 'hollow_square', 'triangle', 'L', 'plus', 'line']
    num_shapes = random.randint(3, 5)

    # choose distinct colors for shapes
    colors = random.sample(list(range(1, 10)), num_shapes)

    shapes = []  # list of tuples (color, pixels)

    attempts_limit = 200
    placed = 0
    tries = 0
    while placed < num_shapes and tries < attempts_limit:
        tries += 1
        shape_type = random.choice(shape_types)
        size = random.randint(2, 5)
        sprite = make_sprite(shape_type, size)
        # try to place sprite without overlapping existing shapes
        placed_ok = False
        for _ in range(30):
            top = random.randint(0, max(0, height - size))
            left = random.randint(0, max(0, width - size))
            # compute absolute pixels
            abs_pixels = [(top + r, left + c) for (r, c) in sprite]
            # ensure within bounds and not overlapping
            conflict = False
            for (r, c) in abs_pixels:
                if r < 0 or r >= height or c < 0 or c >= width:
                    conflict = True
                    break
                if input_grid[r][c] != 0:
                    conflict = True
                    break
            if not conflict:
                color = colors[placed]
                for (r, c) in abs_pixels:
                    input_grid[r][c] = color
                shapes.append((color, abs_pixels))
                placed += 1
                placed_ok = True
                break
        if not placed_ok:
            # if couldn't place this sprite, try a different size/type
            continue

    # If for some reason we failed to place enough shapes, retry generation recursively
    if len(shapes) < 3:
        return generate()

    # Determine the most frequent non-zero color (tie-breaker: highest numeric)
    color_count = [0] * 10
    for r in range(height):
        for c in range(width):
            v = input_grid[r][c]
            if v != 0:
                color_count[v] += 1
    max_count = max(color_count[1:])
    candidate_colors = [i for i in range(1, 10) if color_count[i] == max_count]
    target_color = max(candidate_colors) if candidate_colors else 1

    # centroid (column) of target_color pixels
    total_c = 0
    cnt = 0
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == target_color:
                total_c += c
                cnt += 1
    axis = (total_c / cnt) if cnt > 0 else (width - 1) / 2.0

    # Reflection across vertical axis at x = axis
    output_grid = [[0 for _ in range(width)] for _ in range(height)]

    # reflect shapes in a deterministic order (by ascending color)
    for color, pixels in sorted(shapes, key=lambda x: x[0]):
        for r, c in pixels:
            # reflect column across axis; use round for mapping to integer column
            new_c = int(round(2 * axis - c))
            # clip to bounds
            if new_c < 0:
                new_c = 0
            if new_c >= width:
                new_c = width - 1
            # write reflected pixel (reflected color overwrites in case of overlap)
            output_grid[r][new_c] = color

    # Contextual color morphing: cycle through 1..9
    cycle = list(range(1, 10))
    comps = get_components(output_grid)
    # Build a mapping from pixel to component index for adjacency checks
    comp_map = {}
    for idx, (col, pixels) in enumerate(comps):
        for (r, c) in pixels:
            comp_map[(r, c)] = idx

    morphed_grid = [[0 for _ in range(width)] for _ in range(height)]
    for idx, (col, pixels) in enumerate(comps):
        # count unique adjacent components that have the same color as this component
        neighbors = set()
        for r, c in pixels:
            for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and (nr, nc) in comp_map:
                    nidx = comp_map[(nr, nc)]
                    if nidx != idx:
                        ncolor = comps[nidx][0]
                        if ncolor == col:
                            neighbors.add(nidx)
        adj_count = len(neighbors)
        # find color index in cycle
        ci = cycle.index(col)
        if adj_count % 2 == 1:
            new_color = cycle[(ci + 1) % len(cycle)]
        else:
            new_color = cycle[(ci - 1) % len(cycle)]
        for r, c in pixels:
            morphed_grid[r][c] = new_color

    # Boundary alignment: shift each component toward nearest boundary
    comps2 = get_components(morphed_grid)
    final_grid = [[0 for _ in range(width)] for _ in range(height)]
    # place in deterministic order (by ascending color)
    for color, pixels in sorted(comps2, key=lambda x: x[0]):
        rs = [p[0] for p in pixels]
        cs = [p[1] for p in pixels]
        min_r, max_r = min(rs), max(rs)
        min_c, max_c = min(cs), max(cs)
        dists = {'top': min_r, 'bottom': height - 1 - max_r, 'left': min_c, 'right': width - 1 - max_c}
        # choose closest boundary (ties resolved by insertion order top, bottom, left, right)
        closest = min(dists, key=dists.get)
        shift_r = 0
        shift_c = 0
        if closest == 'top':
            shift_r = -min_r
        elif closest == 'bottom':
            shift_r = (height - 1 - max_r)
        elif closest == 'left':
            shift_c = -min_c
        elif closest == 'right':
            shift_c = (width - 1 - max_c)
        # compute shifted pixels and write to final grid (overwriting earlier if necessary)
        for r, c in pixels:
            nr, nc = r + shift_r, c + shift_c
            if 0 <= nr < height and 0 <= nc < width:
                final_grid[nr][nc] = color

    return {'input': input_grid, 'output': final_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def get_components(grid):
    height = len(grid)
    width = len(grid[0])
    visited = [[False] * width for _ in range(height)]
    components = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and not visited[r][c]:
                color = grid[r][c]
                stack = [(r, c)]
                visited[r][c] = True
                comp = []
                while stack:
                    cr, cc = stack.pop()
                    comp.append((cr, cc))
                    for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append((color, comp))
    return components


def p(input_grid):
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])

    # determine most frequent non-zero color (tie-breaker highest numeric)
    color_count = [0] * 10
    for r in range(height):
        for c in range(width):
            v = grid_in[r][c]
            if v != 0:
                color_count[v] += 1
    max_count = max(color_count[1:])
    candidate_colors = [i for i in range(1, 10) if color_count[i] == max_count]
    target_color = max(candidate_colors) if candidate_colors else 1

    total_c = 0
    cnt = 0
    for r in range(height):
        for c in range(width):
            if grid_in[r][c] == target_color:
                total_c += c
                cnt += 1
    axis = (total_c / cnt) if cnt > 0 else (width - 1) / 2.0

    # find original shape components from input
    comps_in = get_components(grid_in)

    # reflect components across axis; use deterministic order by ascending color
    output = [[0 for _ in range(width)] for _ in range(height)]
    for color, pixels in sorted(comps_in, key=lambda x: x[0]):
        for r, c in pixels:
            new_c = int(round(2 * axis - c))
            if new_c < 0:
                new_c = 0
            if new_c >= width:
                new_c = width - 1
            output[r][new_c] = color

    # contextual color morphing using cycle 1..9
    cycle = list(range(1, 10))
    comps = get_components(output)
    comp_map = {}
    for idx, (col, pixels) in enumerate(comps):
        for (r, c) in pixels:
            comp_map[(r, c)] = idx

    morphed = [[0 for _ in range(width)] for _ in range(height)]
    for idx, (col, pixels) in enumerate(comps):
        neighbors = set()
        for r, c in pixels:
            for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and (nr, nc) in comp_map:
                    nidx = comp_map[(nr, nc)]
                    if nidx != idx:
                        ncolor = comps[nidx][0]
                        if ncolor == col:
                            neighbors.add(nidx)
        adj_count = len(neighbors)
        ci = cycle.index(col)
        if adj_count % 2 == 1:
            new_color = cycle[(ci + 1) % len(cycle)]
        else:
            new_color = cycle[(ci - 1) % len(cycle)]
        for r, c in pixels:
            morphed[r][c] = new_color

    # boundary alignment
    comps2 = get_components(morphed)
    final = [[0 for _ in range(width)] for _ in range(height)]
    for color, pixels in sorted(comps2, key=lambda x: x[0]):
        rs = [p[0] for p in pixels]
        cs = [p[1] for p in pixels]
        min_r, max_r = min(rs), max(rs)
        min_c, max_c = min(cs), max(cs)
        dists = {'top': min_r, 'bottom': height - 1 - max_r, 'left': min_c, 'right': width - 1 - max_c}
        closest = min(dists, key=dists.get)
        shift_r = 0
        shift_c = 0
        if closest == 'top':
            shift_r = -min_r
        elif closest == 'bottom':
            shift_r = (height - 1 - max_r)
        elif closest == 'left':
            shift_c = -min_c
        elif closest == 'right':
            shift_c = (width - 1 - max_c)
        for r, c in pixels:
            nr, nc = r + shift_r, c + shift_c
            if 0 <= nr < height and 0 <= nc < width:
                final[nr][nc] = color

    return final

