# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 9d748eb1
Difficulty: very hard

=== Tags ===
- Ripple spread
- Example condition induction
- Periodic reflection
- Dynamic channel painting
- Permute rows by length

=== Description ===
Input grids consist of a background color (0), walls (also 0), and multiple
colored sources (non-zero values). Each source initiates a ripple spreading
outward in all four cardinal directions (up, down, left, right), reflecting off
grid boundaries and walls without stopping. The ripple propagation follows a
breadth-first pattern, with each cell colored by the first ripple to reach it.
Overlapping ripples retain the color of the earliest arriving ripple. After full
propagation, the grid rows are reordered such that rows containing the highest
count of non-background cells (painted by ripples) appear first, followed by
rows with progressively fewer painted cells. The output grid reflects both the
ripple propagation dynamics and the row permutation based on painted cell
density.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = [[0] * width for _ in range(height)]
    
    wall_count = random.randint(1, (width * height) // 10)
    for _ in range(wall_count):
        r, c = random.randint(0, height-1), random.randint(0, width-1)
        grid[r][c] = 1

    source_colors = random.sample([2,3,4,5,6,7,8,9], random.randint(3,5))
    for color in source_colors:
        while True:
            r, c = random.randint(0, height-1), random.randint(0, width-1)
            if grid[r][c] == 0:
                grid[r][c] = color
                break

    dist = [[float('inf')] * width for _ in range(height)]
    color = [[0] * width for _ in range(height)]
    q = deque()
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] > 1:
                dist[r][c] = 0
                color[r][c] = grid[r][c]
                q.append((r, c))

    while q:
        r, c = q.popleft()
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 1:
                new_dist = dist[r][c] + 1
                if new_dist < dist[nr][nc]:
                    dist[nr][nc] = new_dist
                    color[nr][nc] = color[r][c]
                    q.append((nr, nc))
                elif new_dist == dist[nr][nc]:
                    if color[r][c] < color[nr][nc]:
                        color[nr][nc] = color[r][c]

    output_grid = [[color[r][c] for c in range(width)] for r in range(height)]
    row_counts = [sum(1 for c in row if c != 0) for row in output_grid]
    sorted_rows = [row for _, row in sorted(zip(row_counts, output_grid), key=lambda x: -x[0])]
    output_grid = sorted_rows

    return {
        "input": grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    dist = [[float('inf')] * width for _ in range(height)]
    color = [[0] * width for _ in range(height)]
    q = deque()
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] > 1:
                dist[r][c] = 0
                color[r][c] = input_grid[r][c]
                q.append((r, c))

    while q:
        r, c = q.popleft()
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 1:
                new_dist = dist[r][c] + 1
                if new_dist < dist[nr][nc]:
                    dist[nr][nc] = new_dist
                    color[nr][nc] = color[r][c]
                    q.append((nr, nc))
                elif new_dist == dist[nr][nc]:
                    if color[r][c] < color[nr][nc]:
                        color[nr][nc] = color[r][c]

    output_grid = [[color[r][c] for c in range(width)] for r in range(height)]
    row_counts = [sum(1 for c in row if c != 0) for row in output_grid]
    sorted_rows = [row for _, row in sorted(zip(row_counts, output_grid), key=lambda x: -x[0])]
    return sorted_rows
