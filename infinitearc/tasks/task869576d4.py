# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 869576d4
Difficulty: mediumâ€“hard

=== Tags ===
- Connect all dots of same color
- Collision marking
- Close line gaps
- Follow color path to destination

=== Description ===
Task: Color Path Connectivity with Collision Marking  Input grids feature
multiple distinct colored cells (1-9) arranged in horizontal or vertical lines,
each line representing a "path" of a single color. Background cells (0) separate
these paths. The goal is to complete each color path by filling all background
cells between its constituent dots with the same color (closing line gaps),
while marking any cell where paths of different colors intersect with a
collision marker (color 9).   For each color: 1. Identify all dots (cells of
that color) 2. Determine the minimal straight-line path (horizontal or vertical)
connecting all dots 3. Fill all background cells (0) along this path with the
color 4. If a cell is filled by two different colors during this process, mark
it as 9 (collision)  The output grid must: - Complete all same-color paths by
closing gaps between dots - Preserve all original dots - Mark collision points
where different color paths cross - Maintain background (0) in areas not part of
any path or collision  The transformation requires simultaneous application of
path completion (for each color) and collision detection (across colors), with
no path overlaps except at marked collision points. The task demands
hierarchical reasoning: first identifying color-specific paths, then resolving
conflicts between paths. Grids contain 3-5 colors with 2-4 dots per color,
arranged such that paths cross at multiple points, requiring careful conflict
resolution.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(8, 15)
    height = random.randint(8, 15)
    colors = random.sample(range(1, 6), random.randint(3, 5))
    grid_in = [[0] * width for _ in range(height)]
    
    max_attempts = 100
    for _ in range(max_attempts):
        grid_in = [[0] * width for _ in range(height)]
        for color in colors:
            direction = random.choice(['horizontal', 'vertical'])
            if direction == 'horizontal':
                r = random.randint(0, height-1)
                cols = [random.randint(0, width-1)]
                for _ in range(random.randint(1, 2)):
                    next_c = cols[-1] + random.randint(2, 4)
                    if next_c >= width:
                        break
                    cols.append(next_c)
                cols = sorted(cols)
                for c in cols:
                    grid_in[r][c] = color
            else:
                c = random.randint(0, width-1)
                rows = [random.randint(0, height-1)]
                for _ in range(random.randint(1, 2)):
                    next_r = rows[-1] + random.randint(2, 4)
                    if next_r >= height:
                        break
                    rows.append(next_r)
                rows = sorted(rows)
                for r in rows:
                    grid_in[r][c] = color
        
        horizontal_paths = []
        vertical_paths = []
        for color in colors:
            positions = []
            for r in range(height):
                for c in range(width):
                    if grid_in[r][c] == color:
                        positions.append((r, c))
            if positions:
                if all(p[0] == positions[0][0] for p in positions):
                    horizontal_paths.append((positions[0][0], [p[1] for p in positions]))
                else:
                    vertical_paths.append((positions[0][1], [p[0] for p in positions]))
        
        crossing_found = False
        for h_row, h_cols in horizontal_paths:
            for v_col, v_rows in vertical_paths:
                if h_row in v_rows and v_col in h_cols:
                    if grid_in[h_row][v_col] == 0:
                        crossing_found = True
                        break
            if crossing_found:
                break
        
        if crossing_found:
            break
    
    grid_out = [row[:] for row in grid_in]
    colors_filled = [[[] for _ in range(width)] for _ in range(height)]
    
    for color in colors:
        positions = []
        for r in range(height):
            for c in range(width):
                if grid_in[r][c] == color:
                    positions.append((r, c))
        if not positions:
            continue
        if all(p[0] == positions[0][0] for p in positions):
            r = positions[0][0]
            cols = sorted([p[1] for p in positions])
            min_c, max_c = cols[0], cols[-1]
            for c in range(min_c, max_c + 1):
                if grid_in[r][c] == 0:
                    colors_filled[r][c].append(color)
        else:
            c = positions[0][1]
            rows = sorted([p[0] for p in positions])
            min_r, max_r = rows[0], rows[-1]
            for r in range(min_r, max_r + 1):
                if grid_in[r][c] == 0:
                    colors_filled[r][c].append(color)
    
    for r in range(height):
        for c in range(width):
            if grid_in[r][c] == 0:
                if len(colors_filled[r][c]) == 1:
                    grid_out[r][c] = colors_filled[r][c][0]
                elif len(colors_filled[r][c]) > 1:
                    grid_out[r][c] = 9
    return {'input': grid_in, 'output': grid_out}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    height = len(input_list)
    width = len(input_list[0])
    output_list = [row[:] for row in input_list]
    colors_filled = [[[] for _ in range(width)] for _ in range(height)]
    
    for color in range(1, 10):
        positions = []
        for r in range(height):
            for c in range(width):
                if input_list[r][c] == color:
                    positions.append((r, c))
        if not positions:
            continue
        if all(r == positions[0][0] for r, c in positions):
            r = positions[0][0]
            cols = sorted([c for r, c in positions])
            min_c, max_c = cols[0], cols[-1]
            for c in range(min_c, max_c + 1):
                if input_list[r][c] == 0:
                    colors_filled[r][c].append(color)
        elif all(c == positions[0][1] for r, c in positions):
            c = positions[0][1]
            rows = sorted([r for r, c in positions])
            min_r, max_r = rows[0], rows[-1]
            for r in range(min_r, max_r + 1):
                if input_list[r][c] == 0:
                    colors_filled[r][c].append(color)
    
    for r in range(height):
        for c in range(width):
            if input_list[r][c] == 0:
                if len(colors_filled[r][c]) == 1:
                    output_list[r][c] = colors_filled[r][c][0]
                elif len(colors_filled[r][c]) > 1:
                    output_list[r][c] = 9
    return tuple(tuple(row) for row in output_list)
