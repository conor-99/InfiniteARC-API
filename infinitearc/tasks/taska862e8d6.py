# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: a862e8d6
Difficulty: easy

=== Tags ===
- Encircle all pixels of one color

=== Description ===
The task involves transforming an input grid by encircling all pixels of a
single non-background color. The input grid contains a single connected region
of one non-zero color (e.g., color 1) surrounded by background pixels (color 0).
The output grid is generated by replacing all background pixels adjacent
(horizontally or vertically) to the non-background color with a new fixed color
(e.g., color 2), while preserving the original color region. The transformation
is deterministic and visually intuitive: the output displays the original shape
with a border of the new color forming a contiguous outline around it. This rule
requires no numerical computation or complex pattern recognition, relying solely
on spatial adjacency to identify the border positions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    import common
    grid_w = random.randint(3, 30)
    grid_h = random.randint(3, 30)
    size = 5
    pixels = common.continuous_creature(size, width=grid_w, height=grid_h)
    input_grid = common.grid(grid_w, grid_h, 0)
    for (r, c) in pixels:
        input_grid[r][c] = 1
    output_grid = [row[:] for row in input_grid]
    for r in range(grid_h):
        for c in range(grid_w):
            if input_grid[r][c] == 0:
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < grid_h and 0 <= nc < grid_w and input_grid[nr][nc] == 1:
                        output_grid[r][c] = 2
                        break
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Ensure input_grid is list of lists
    input_grid = [list(row) for row in input_grid]
    h = len(input_grid)
    w = len(input_grid[0])
    non_zero_color = None
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] != 0:
                non_zero_color = input_grid[r][c]
                break
        if non_zero_color is not None:
            break
    if non_zero_color is None:
        non_zero_color = 1
    output = [row[:] for row in input_grid]
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] == 0:
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr = r + dr
                    nc = c + dc
                    if 0 <= nr < h and 0 <= nc < w and input_grid[nr][nc] == non_zero_color:
                        output[r][c] = 2
                        break
    return output
