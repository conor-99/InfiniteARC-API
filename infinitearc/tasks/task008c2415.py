# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 008c2415
Difficulty: hard

=== Tags ===
- Sequential path painting
- Elastic reflection
- Draw line to nearest object of same color
- Associate patterns to colors

=== Description ===
Input grids are large (20×20) with a uniform background color (0). Overlaid are
multiple distinct colored regions (1–9), each region being a connected group of
cells sharing the same color, separated by background cells. Regions vary in
size (1×1 to 5×5) and exhibit consistent visual patterns: for example, all 2×2
square regions are always color 3, all horizontal lines of three cells are color
5, and all T-shaped patterns are color 7. These pattern-color associations are
consistent across all inputs and serve as visual cues to identify regions.  For
each color present in two or more regions, the output grid draws a single
straight line connecting the two nearest regions of that color. The line uses
the color of the regions and must traverse only background cells. If the direct
path between regions is blocked by another colored region, the line "elastic
reflects" around the obstacle—bending orthogonally at the boundary of the
obstacle to continue on a background-only path while maintaining the shortest
possible route. Lines are never drawn over existing regions or their interiors,
and their thickness is exactly one cell.   The output grid retains all original
regions and background, with lines added between the nearest same-color region
pairs. Pattern-color associations (e.g., 2×2 = color 3) are implicitly used to
verify the correct color for line drawing, though the input explicitly defines
the color. No lines are drawn for colors with only one region, and all outputs
strictly avoid overlapping with non-background elements.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    size = 20
    input_grid = grid(size, size, 0)
    
    # Define shape-color associations
    shape_to_color = {
        '2x2': 3,
        'horizontal_3': 5,
        'T': 7
    }
    
    # Create regions with random positions
    regions = []
    # Two 2x2 regions (color 3)
    for _ in range(2):
        r = random.randint(0, 18)
        c = random.randint(0, 18)
        regions.append(('2x2', 3, r, c))
    
    # Horizontal line (color 5)
    r = random.randint(0, 19)
    c = random.randint(0, 17)
    regions.append(('horizontal_3', 5, r, c))
    
    # T-shape (color 7)
    r = random.randint(0, 17)
    c = random.randint(0, 17)
    regions.append(('T', 7, r, c))
    
    # Place regions without overlap
    for shape, color, r, c in regions:
        if shape == '2x2':
            for dr in range(2):
                for dc in range(2):
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < size and 0 <= nc < size:
                        input_grid[nr][nc] = color
        elif shape == 'horizontal_3':
            for dc in range(3):
                nr, nc = r, c + dc
                if 0 <= nr < size and 0 <= nc < size:
                    input_grid[nr][nc] = color
        elif shape == 'T':
            # T-shape: horizontal bar with vertical stem
            points = [(r, c+1), (r+1, c), (r+1, c+1), (r+1, c+2)]
            for nr, nc in points:
                if 0 <= nr < size and 0 <= nc < size:
                    input_grid[nr][nc] = color
    
    output_grid = [row[:] for row in input_grid]
    
    # Find all regions of color 3
    color3_regions = []
    visited = [[False] * size for _ in range(size)]
    for r in range(size):
        for c in range(size):
            if not visited[r][c] and input_grid[r][c] == 3:
                region = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    region.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < size and 0 <= nc < size and not visited[nr][nc] and input_grid[nr][nc] == 3:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                color3_regions.append(region)
                
    # Draw line between two closest color 3 regions
    if len(color3_regions) >= 2:
        region1, region2 = color3_regions[0], color3_regions[1]
        
        # Find closest boundary points
        boundary1 = []
        for r, c in region1:
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < size and 0 <= nc < size and input_grid[nr][nc] == 0:
                    boundary1.append((nr, nc))
        boundary2 = []
        for r, c in region2:
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < size and 0 <= nc < size and input_grid[nr][nc] == 0:
                    boundary2.append((nr, nc))
        
        # Find closest pair
        min_dist = float('inf')
        closest_pair = None
        for p1 in boundary1:
            for p2 in boundary2:
                dist = abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])
                if dist < min_dist:
                    min_dist = dist
                    closest_pair = (p1, p2)
        
        if closest_pair:
            start, end = closest_pair
            # BFS for shortest path
            visited = [[False] * size for _ in range(size)]
            parent = {}
            queue = [start]
            visited[start[0]][start[1]] = True
            while queue:
                r, c = queue.pop(0)
                if (r, c) == end:
                    break
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < size and 0 <= nc < size and not visited[nr][nc] and input_grid[nr][nc] == 0:
                        visited[nr][nc] = True
                        parent[(nr, nc)] = (r, c)
                        queue.append((nr, nc))
            
            # Reconstruct path
            path = []
            current = end
            while current != start:
                path.append(current)
                current = parent.get(current, start)
            path.append(start)
            path = path[::-1]
            
            # Draw path
            for r, c in path:
                output_grid[r][c] = 3
    
    return {
        'input': input_grid,
        'output': output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    # Convert input to mutable grid
    grid = [list(row) for row in input_grid]
    size = len(grid)
    
    def bfs(start, end):
        visited = [[False] * size for _ in range(size)]
        parent = {}
        queue = deque([start])
        visited[start[0]][start[1]] = True
        
        while queue:
            r, c = queue.popleft()
            if (r, c) == end:
                break
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < size and 0 <= nc < size and not visited[nr][nc] and grid[nr][nc] == 0:
                    visited[nr][nc] = True
                    parent[(nr, nc)] = (r, c)
                    queue.append((nr, nc))
        
        # Reconstruct path
        path = []
        current = end
        while current != start:
            path.append(current)
            current = parent.get(current, start)
        path.append(start)
        return path[::-1]

    # Identify all regions
    visited = [[False] * size for _ in range(size)]
    regions_by_color = {}
    
    for r in range(size):
        for c in range(size):
            if not visited[r][c] and grid[r][c] > 0:
                color = grid[r][c]
                region = []
                queue = deque([(r, c)])
                visited[r][c] = True
                while queue:
                    cr, cc = queue.popleft()
                    region.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < size and 0 <= nc < size and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                if color not in regions_by_color:
                    regions_by_color[color] = []
                regions_by_color[color].append(region)

    # Draw lines between nearest regions of same color
    for color, regions in regions_by_color.items():
        if len(regions) < 2:
            continue
        
        # Find closest region pair
        min_dist = float('inf')
        closest_pair = None
        for i in range(len(regions)):
            for j in range(i+1, len(regions)):
                # Find closest boundary points
                min_pair_dist = float('inf')
                best_points = None
                for r1, c1 in regions[i]:
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr1, nc1 = r1 + dr, c1 + dc
                        if 0 <= nr1 < size and 0 <= nc1 < size and grid[nr1][nc1] == 0:
                            for r2, c2 in regions[j]:
                                for dr2, dc2 in [(1,0), (-1,0), (0,1), (0,-1)]:
                                    nr2, nc2 = r2 + dr2, c2 + dc2
                                    if 0 <= nr2 < size and 0 <= nc2 < size and grid[nr2][nc2] == 0:
                                        dist = abs(nr1 - nr2) + abs(nc1 - nc2)
                                        if dist < min_pair_dist:
                                            min_pair_dist = dist
                                            best_points = ((nr1, nc1), (nr2, nc2))
                if min_pair_dist < min_dist:
                    min_dist = min_pair_dist
                    closest_pair = best_points
        
        if closest_pair:
            start, end = closest_pair
            path = bfs(start, end)
            for r, c in path:
                grid[r][c] = color
    
    return grid
