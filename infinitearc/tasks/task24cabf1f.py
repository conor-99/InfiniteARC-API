# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 24cabf1f
Difficulty: very hard

=== Tags ===
- Rotational pattern mapping
- Pattern concatenation
- Inference from demonstration
- Symbolic circuit

=== Description ===
Input grids are 15×15 grids with a background color (0). Overlaid are 3–5
distinct, closed-loop patterns (each a contiguous region of a single non-
background color, e.g., 1–9), each containing a unique "key" cell (a single cell
of a different color within the loop, e.g., color 5 inside a loop of color 3).
The key cell's color (1–9) maps to a rotation angle: key color 1 = 90°
clockwise, 2 = 180°, 3 = 270° clockwise, 4 = 0° (no rotation), and higher colors
cycle through this mapping. Each key color is unique to a pattern. The patterns
are non-overlapping, fully enclosed by background, and the key cells are
positioned such that they remain inside the loop after rotation.   The output
grid is formed by: (1) rotating each pattern by its key's rotation angle, (2)
ordering the rotated patterns by ascending key color, and (3) concatenating them
horizontally (left to right). The output grid's width is the sum of the widths
of all rotated patterns, and its height is the maximum height of any rotated
pattern. Rotation must preserve the pattern's internal structure (e.g., a 3×2
rectangle rotated 90° becomes 2×3). Patterns with identical key colors are
ordered by their original top-left position in the input. The transformation
requires identifying patterns, locating key cells, inferring the rotation
mapping from examples, applying rotations, and concatenating in key-sorted
order. The task is "very hard" due to the need to: (1) distinguish patterns from
background and key cells, (2) deduce the key-to-rotation mapping from minimal
examples, (3) handle variable pattern sizes and rotations, and (4) manage
concatenation order while ensuring no spatial overlaps in the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# small helper to rotate a matrix clockwise 90 degrees
def _rot90(mat):
    return [list(row) for row in zip(*mat[::-1])]

def _rotate(mat, times):
    times = times % 4
    if times == 0:
        return [row[:] for row in mat]
    res = [row[:] for row in mat]
    for _ in range(times):
        res = _rot90(res)
    return res

# keep a record of generated examples in this process so we return unique pairs
_seen_signatures = set()

def generate():
    """Generate a 15x15 input grid and the corresponding output.

    Each generated input contains 3-5 rectangular closed-loop patterns (frames)
    with a single interior key cell of a different color. Key colors are unique
    (within a generated example). The key color determines the rotation:
    rotation = (key_color % 4) * 90 degrees (so 1->90,2->180,3->270,4->0,5->90,...).

    The output concatenates the rotated patterns left-to-right sorted by ascending
    key color.
    """
    global _seen_signatures
    WIDTH = HEIGHT = 15

    # Try a number of times to produce a valid, unique example
    for attempt_outer in range(200):
        input_grid = grid(WIDTH, HEIGHT, 0)
        num_patterns = random.randint(3, 5)
        used_key_colors = set()
        patterns = []  # store tuples: (border_color, key_color, size, r, c, pat_grid)

        ok_all = True
        # Create each pattern and place it with a one-cell background margin
        for _ in range(num_patterns):
            # pick a unique key color
            choices = [c for c in range(1, 10) if c not in used_key_colors]
            if not choices:
                ok_all = False
                break
            key_color = random.choice(choices)
            used_key_colors.add(key_color)

            # pick a border color (can be reused across patterns but must differ from this key)
            border_color = random.choice([c for c in range(1, 10) if c != key_color])

            # choose a small size so placement is likely to succeed
            size = random.choice([3, 4, 5, 6])

            # build the frame pattern
            pat = grid(size, size, 0)
            for i in range(size):
                for j in range(size):
                    if i == 0 or i == size - 1 or j == 0 or j == size - 1:
                        pat[i][j] = border_color
            # choose an interior position for the key
            interior = [(i, j) for i in range(1, size - 1) for j in range(1, size - 1)]
            if not interior:
                ok_all = False
                break
            kr, kc = random.choice(interior)
            pat[kr][kc] = key_color

            # try to place the pattern with a one-cell margin on all sides
            placed = False
            tries = 0
            # allowed top-left start positions so that margin of 1 exists around the pattern
            r_min = 1
            r_max = HEIGHT - size - 1
            c_min = 1
            c_max = WIDTH - size - 1
            if r_max < r_min or c_max < c_min:
                ok_all = False
                break
            while not placed and tries < 400:
                tries += 1
                r = random.randint(r_min, r_max)
                c = random.randint(c_min, c_max)
                # check extended area (one cell margin) for collisions
                collision = False
                for rr in range(r - 1, r + size + 1):
                    for cc in range(c - 1, c + size + 1):
                        if input_grid[rr][cc] != 0:
                            collision = True
                            break
                    if collision:
                        break
                if collision:
                    continue
                # place pattern
                for i in range(size):
                    for j in range(size):
                        input_grid[r + i][c + j] = pat[i][j]
                patterns.append((border_color, key_color, size, r, c, pat))
                placed = True
            if not placed:
                ok_all = False
                break

        if not ok_all:
            continue

        # Build the output by rotating each stored pattern and concatenating
        rotated_list = []  # tuples (key_color, rotated_grid, orig_r, orig_c)
        for border_color, key_color, size, r, c, pat in patterns:
            times = key_color % 4  # 1->1 (90deg), 2->2 (180), 3->3 (270), 4->0 (0deg)
            rotated = _rotate(pat, times)
            rotated_list.append((key_color, rotated, r, c))

        # sort by ascending key color
        rotated_list.sort(key=lambda x: x[0])
        rotated_grids = [t[1] for t in rotated_list]

        if not rotated_grids:
            output_grid = grid(1, 1, 0)
        else:
            widths = [len(g[0]) for g in rotated_grids]
            heights = [len(g) for g in rotated_grids]
            total_w = sum(widths)
            max_h = max(heights)
            output_grid = [[0] * total_w for _ in range(max_h)]
            col = 0
            for g in rotated_grids:
                h = len(g)
                w = len(g[0])
                for i in range(h):
                    for j in range(w):
                        output_grid[i][col + j] = g[i][j]
                col += w

        sig = (tuple(tuple(row) for row in input_grid), tuple(tuple(row) for row in output_grid))
        if sig in _seen_signatures:
            # try again to ensure 100 unique examples in a session
            continue
        _seen_signatures.add(sig)
        return {"input": input_grid, "output": output_grid}

    # If generation repeatedly failed, return a simple fallback (should not happen normally)
    return {"input": grid(15, 15, 0), "output": grid(1, 1, 0)}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # convert input (tuple of tuples) to mutable list of lists
    grid_in = [list(row) for row in input_grid]
    H = len(grid_in)
    W = len(grid_in[0]) if H > 0 else 0

    visited = [[False] * W for _ in range(H)]
    components = []  # list of (color, cells)

    for r in range(H):
        for c in range(W):
            if grid_in[r][c] == 0 or visited[r][c]:
                continue
            color = grid_in[r][c]
            stack = [(r, c)]
            visited[r][c] = True
            cells = []
            while stack:
                cr, cc = stack.pop()
                cells.append((cr, cc))
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc] and grid_in[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            components.append((color, cells))

    # rotation helpers
    def rot90(mat):
        return [list(row) for row in zip(*mat[::-1])]

    def rotate(mat, times):
        times = times % 4
        res = [row[:] for row in mat]
        for _ in range(times):
            res = rot90(res)
        return res

    # Identify border components (those with more than one cell) and find the key inside their bbox
    patterns = []  # (key_color, bbox_top, bbox_left, subgrid)
    for color, cells in components:
        if len(cells) <= 1:
            # very small components are likely key pixels, skip them here
            continue
        rows = [r for r, c in cells]
        cols = [c for r, c in cells]
        min_r, max_r = min(rows), max(rows)
        min_c, max_c = min(cols), max(cols)
        # search inside bounding box for a nonzero color that's not the border color
        key_color = None
        for rr in range(min_r, max_r + 1):
            for cc in range(min_c, max_c + 1):
                v = grid_in[rr][cc]
                if v != 0 and v != color:
                    key_color = v
                    break
            if key_color is not None:
                break
        if key_color is None:
            # not a pattern border (no distinct key inside)
            continue
        # extract subgrid
        sub = []
        for rr in range(min_r, max_r + 1):
            row = []
            for cc in range(min_c, max_c + 1):
                row.append(grid_in[rr][cc])
            sub.append(row)
        patterns.append((key_color, min_r, min_c, sub))

    # sort patterns by ascending key color
    patterns.sort(key=lambda x: x[0])

    rotated = []
    for key_color, tr, tc, sub in patterns:
        times = key_color % 4  # mapping: 1->1(90deg),2->2(180),3->3(270),4->0
        rsub = rotate(sub, times)
        rotated.append(rsub)

    if not rotated:
        return [[0]]

    widths = [len(p[0]) for p in rotated]
    heights = [len(p) for p in rotated]
    total_w = sum(widths)
    max_h = max(heights)

    out = [[0] * total_w for _ in range(max_h)]
    col = 0
    for p in rotated:
        h = len(p)
        w = len(p[0])
        for i in range(h):
            for j in range(w):
                out[i][col + j] = p[i][j]
        col += w

    return out

