# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: aa073e46
Difficulty: insane

=== Tags ===
- Paint on collision

=== Description ===
"Paint on Collision" is an "insane" difficulty task where input grids consist of
multiple contiguous colored regions (each region is a set of connected cells
with the same non-zero color) separated by background (color 0). For every pair
of adjacent regions sharing a vertical or horizontal edge, the boundary cells
between them are replaced with a new color determined by the specific color pair
and the direction of adjacency (e.g., Region A (color X) above Region B (color
Y) produces color Z, while Region A to the left of Region B produces color W).
The collision rules are consistent across the grid, with each unique color pair-
direction combination mapping to a distinct output color. The output grid
preserves all original regions except at collision boundaries, which are updated
to reflect the direction-dependent collision result. Solvers must identify all
adjacent region pairs, determine adjacency direction (top/bottom/left/right),
apply the collision mapping, and replace boundary cells accordingly. The
complexity arises from the combinatorial nature of collision rules (10 colors Ã—
4 directions = 40 possible mappings), the need to handle multiple overlapping
boundary regions simultaneously, and the requirement to deduce direction-
dependent color mappings from limited examples while avoiding visual
misinterpretation of color relationships. Input grids contain 5-10 distinct
regions with intricate shapes and varied adjacency patterns, requiring multi-
step reasoning to resolve all collision interactions without overwriting or
missing boundary cells.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_pixels
def generate():
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    input_grid = grid(width, height, 0)
    colors = random.sample(range(1, 6), 5)
    for color in colors:
        pixels = random_pixels(width, height, 0.2)
        for (r, c) in pixels:
            if 0 <= r < height and 0 <= c < width:
                input_grid[r][c] = color
    output_grid = [row[:] for row in input_grid]
    directions = [(-1, 0, 'above'), (1, 0, 'below'), (0, -1, 'left'), (0, 1, 'right')]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                continue
            for dr, dc, direction in directions:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != input_grid[r][c] and input_grid[nr][nc] != 0:
                    dir_index = 0 if direction == 'above' else 1 if direction == 'below' else 2 if direction == 'left' else 3
                    X = input_grid[r][c]
                    Y = input_grid[nr][nc]
                    collision_color = (X + Y + dir_index) % 9 + 1
                    output_grid[r][c] = collision_color
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    width = len(input_list[0])
    height = len(input_list)
    output_grid = [row[:] for row in input_list]
    directions = [(-1, 0, 'above'), (1, 0, 'below'), (0, -1, 'left'), (0, 1, 'right')]
    for r in range(height):
        for c in range(width):
            if input_list[r][c] == 0:
                continue
            for dr, dc, direction in directions:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and input_list[nr][nc] != input_list[r][c] and input_list[nr][nc] != 0:
                    dir_index = 0 if direction == 'above' else 1 if direction == 'below' else 2 if direction == 'left' else 3
                    X = input_list[r][c]
                    Y = input_list[nr][nc]
                    collision_color = (X + Y + dir_index) % 9 + 1
                    output_grid[r][c] = collision_color
    return output_grid
