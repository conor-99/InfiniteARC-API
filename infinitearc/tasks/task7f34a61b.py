# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 7f34a61b
Difficulty: insane

=== Tags ===
- Chain reaction
- Multi exit routes
- Pattern guided construction
- Count touches
- Two color checkerboard

=== Description ===
Input grids feature a dynamic two-color checkerboard pattern (using distinct
colors like 0 and 1) that alternates between adjacent cells. Embedded within
this pattern are "reactor" cells (color 2) positioned on checkerboard cells that
would normally be color 0 or 1. Each reactor cell is evaluated based on its
orthogonal neighbors: the number of adjacent cells matching the checkerboard
color expected at its position (e.g., if the reactor sits on a cell that should
be color 0 due to checkerboard parity, neighbors with color 0 are counted). If
this count is ≥2, the reactor is "active," triggering a chain reaction.  The
chain reaction propagates outward from all active reactors in all four
directions, replacing adjacent checkerboard cells (of the expected color) with a
new "reaction" color (3), but only if those cells also meet the ≥2 neighbor
count condition relative to the original checkerboard. Propagation continues
recursively until no further cells meet the condition. The reaction path must
form "multi exit routes" where branches diverge based on directional neighbor
counts, avoiding dead ends by requiring sufficient supporting checkerboard cells
at each step.  "Pattern guided construction" ensures the reaction follows a
structured path dictated by the underlying checkerboard, with the output grid
displaying the reaction color (3) forming interconnected routes that respect the
original pattern's geometry. "Count touches" strictly enforces that only cells
with ≥2 neighbors matching the checkerboard color can be activated, creating a
complex, non-linear pattern that avoids random or arbitrary propagation. Reactor
cells (color 2) remain visible as inactive markers if their neighbor count is
<2, while all original checkerboard cells outside reaction paths retain their
colors. The final grid exhibits a visually intricate design where reaction
routes are guided solely by the checkerboard's inherent structure and neighbor
counts.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    input_grid = grid(width, height, 0)
    
    # Create row-based checkerboard (i % 2)
    for i in range(height):
        for j in range(width):
            input_grid[i][j] = i % 2

    # Place reactors (color 2) in non-edge columns (j=1 to width-2)
    reactor_positions = []
    for i in range(height):
        for j in range(1, width - 1):
            if random.random() < 0.3:  # 30% chance to place reactor
                input_grid[i][j] = 2
                reactor_positions.append((i, j))

    # Ensure at least one reactor
    if not reactor_positions:
        i, j = random.randint(0, height-1), random.randint(1, width-2)
        input_grid[i][j] = 2

    # Create output grid
    output_grid = [[0]*width for _ in range(height)]
    for i in range(height):
        for j in range(width):
            if j == 0 or j == width - 1:
                output_grid[i][j] = input_grid[i][j]
            else:
                if input_grid[i][j] == 2:
                    output_grid[i][j] = 2
                else:
                    output_grid[i][j] = 3

    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = [[0]*width for _ in range(height)]
    
    for i in range(height):
        for j in range(width):
            if j == 0 or j == width - 1:
                output_grid[i][j] = input_grid[i][j]
            else:
                if input_grid[i][j] == 2:
                    output_grid[i][j] = 2
                else:
                    output_grid[i][j] = 3
    
    return output_grid
