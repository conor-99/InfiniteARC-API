# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 597bad36
Difficulty: medium

=== Tags ===
- Associate patterns to patterns
- Obstacles
- Proximity guessing

=== Description ===
The input grid contains a primary pattern (a connected region of cells with a
single color) and obstacle cells (a distinct color that blocks transformations).
The output grid is generated by modifying the primary pattern: each cell within
the primary pattern that is adjacent (horizontally or vertically) to at least
one obstacle cell changes to a new, distinct color, while all other cells remain
unchanged. The background (non-pattern, non-obstacle cells) retains its original
appearance. This transformation associates the primary pattern with a modified
secondary pattern based on proximity to obstacles, requiring the solver to
identify adjacency relationships between pattern cells and obstacle cells to
determine the correct output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    width = common.randint(5, 20)
    height = common.randint(5, 20)
    primary_size = common.randint(3, 10)
    primary_pixels = common.continuous_creature(primary_size, width, height)
    
    A = common.random_color(exclude=[0])
    B = common.random_color(exclude=[0, A])
    
    # Compute C as smallest color not 0, A, B
    C = 1
    while C in [0, A, B]:
        C += 1
    
    input_grid = common.grid(width, height, 0)
    for (r, c) in primary_pixels:
        input_grid[r][c] = A
    
    # Find adjacent background cells to primary
    adjacent_cells = []
    for (r, c) in primary_pixels:
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 0:
                adjacent_cells.append((nr, nc))
    
    if not adjacent_cells:
        return generate()
    
    num_obstacles = common.randint(1, 3)
    obstacle_cells = common.sample(adjacent_cells, min(num_obstacles, len(adjacent_cells)))
    
    for (r, c) in obstacle_cells:
        input_grid[r][c] = B
    
    output_grid = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == A:
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == B:
                        output_grid[r][c] = C
                        break
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    # Ensure input is list of lists (not tuples)
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    
    # Find all non-zero colors
    colors = set()
    for row in input_grid:
        for color in row:
            if color != 0:
                colors.add(color)
    colors = sorted(colors)
    
    if len(colors) < 2:
        A = colors[0]
        B = 1
    else:
        A, B = colors[0], colors[1]
    
    # Get all pixels for A and B
    pixels_A = []
    pixels_B = []
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] == A:
                pixels_A.append((r, c))
            elif input_grid[r][c] == B:
                pixels_B.append((r, c))
    
    # Check connectivity for both colors
    connected_A = common.connected(pixels_A)
    connected_B = common.connected(pixels_B)
    
    # Choose primary color based on connectivity and size
    if connected_A and (not connected_B or len(pixels_A) >= len(pixels_B)):
        primary_color = A
        obstacle_color = B
    else:
        primary_color = B
        obstacle_color = A
    
    # Compute C
    C = 1
    while C == 0 or C == primary_color or C == obstacle_color:
        C += 1
    
    output_grid = [row[:] for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == primary_color:
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        if input_grid[nr][nc] == obstacle_color:
                            output_grid[r][c] = C
                            break
    
    return output_grid
