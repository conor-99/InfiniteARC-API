# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: dac4a737
Difficulty: easy

=== Tags ===
- Pattern completion
- Remove noise

=== Description ===
The input grid displays a nearly solid rectangular pattern of a single color,
with one or two pixels missing from its boundary, creating an incomplete shape.
Additionally, the grid contains scattered isolated pixels (noise) of a different
color that do not connect to the main rectangle. The output grid is generated by
first removing all isolated noise pixels (those not part of the main connected
rectangle), then filling in the missing boundary pixels to complete the
rectangle into a solid, unbroken shape. This process ensures the output contains
only the fully formed rectangle with no extraneous elements.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    import common
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = common.grid(width, height, 0)
    A = random.randint(1, 9)
    B = random.choice([x for x in range(1, 10) if x != A])
    W = random.randint(3, 10)
    H = random.randint(3, 10)
    W = min(W, width - 1)
    H = min(H, height - 1)
    r = random.randint(0, height - H)
    c = random.randint(0, width - W)
    for i in range(r, r + H):
        for j in range(c, c + W):
            grid[i][j] = A
    corners = [(r, c), (r, c + W - 1), (r + H - 1, c), (r + H - 1, c + W - 1)]
    corner = random.choice(corners)
    grid[corner[0]][corner[1]] = 0
    for _ in range(random.randint(2, 5)):
        while True:
            i = random.randint(0, height - 1)
            j = random.randint(0, width - 1)
            if grid[i][j] != 0:
                continue
            adjacent_to_rect = False
            for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                ni, nj = i + di, j + dj
                if 0 <= ni < height and 0 <= nj < width and grid[ni][nj] == A:
                    adjacent_to_rect = True
                    break
            if not adjacent_to_rect:
                grid[i][j] = B
                break
    output = common.grid(width, height, 0)
    a_pixels = [(i, j) for i in range(height) for j in range(width) if grid[i][j] == A]
    if a_pixels:
        min_i = min(p[0] for p in a_pixels)
        max_i = max(p[0] for p in a_pixels)
        min_j = min(p[1] for p in a_pixels)
        max_j = max(p[1] for p in a_pixels)
        for i in range(min_i, max_i + 1):
            for j in range(min_j, max_j + 1):
                output[i][j] = A
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    import common
    height = len(input_grid)
    width = len(input_grid[0])
    visited = [[False] * width for _ in range(height)]
    components = []
    def dfs(i, j, color, comp):
        if i < 0 or i >= height or j < 0 or j >= width or visited[i][j] or input_grid[i][j] != color:
            return
        visited[i][j] = True
        comp.append((i, j))
        for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            dfs(i + di, j + dj, color, comp)
    for i in range(height):
        for j in range(width):
            if not visited[i][j] and input_grid[i][j] != 0:
                color = input_grid[i][j]
                comp = []
                dfs(i, j, color, comp)
                components.append((color, comp))
    if not components:
        return input_grid
    main_color, main_pixels = max(components, key=lambda x: len(x[1]))
    min_i = min(p[0] for p in main_pixels)
    max_i = max(p[0] for p in main_pixels)
    min_j = min(p[1] for p in main_pixels)
    max_j = max(p[1] for p in main_pixels)
    output = common.grid(width, height, 0)
    for i in range(min_i, max_i + 1):
        for j in range(min_j, max_j + 1):
            output[i][j] = main_color
    return output
