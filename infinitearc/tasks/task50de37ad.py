# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 50de37ad
Difficulty: medium–hard

=== Tags ===
- Bidirectional mapping
- Relay chain
- Threshold by touch count

=== Description ===
Input grids feature a linear sequence of distinct colored regions connected
edge-to-edge in a single path, forming a chain where each internal region has
exactly two adjacent neighbors (touch count = 2) and end regions have one
neighbor (touch count = 1). The background is a single neutral color distinct
from all region colors. Each region's color belongs to a fixed bidirectional
color pair (e.g., red ↔ blue, green ↔ yellow), where the transformation rule
swaps colors within each pair. The output grid applies a threshold-based
transformation: regions with touch count ≥ 2 (internal regions) swap colors via
their bidirectional mapping, while regions with touch count = 1 (endpoints)
retain their original colors. This creates a relay effect along the chain, where
the transformation of each internal region depends solely on its position in the
path (via touch count) and the fixed bidirectional color mapping, producing a
visible chain of color changes that propagates through the linear structure
without altering endpoints. The output reflects this sequence as a continuous
relay of color swaps along the path, with all transformations determined by the
initial input configuration's structure and color relationships.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    N = random.randint(3, 30)
    H = 5
    W = N
    input_grid = [[0] * W for _ in range(H)]
    output_grid = [[0] * W for _ in range(H)]
    
    colors = [random.randint(1, 9) for _ in range(N)]
    
    for col in range(N):
        c = colors[col]
        for row in range(1, 4):
            input_grid[row][col] = c
            if col == 0 or col == N-1:
                output_grid[row][col] = c
            else:
                output_grid[row][col] = c ^ 1
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    output_list = [list(row) for row in input_list]
    
    background = 0
    non_zero_cols = []
    for col in range(len(input_list[0])):
        for row in range(len(input_list)):
            if input_list[row][col] != background:
                non_zero_cols.append(col)
                break
    
    if not non_zero_cols:
        return output_list
    
    min_col = min(non_zero_cols)
    max_col = max(non_zero_cols)
    
    for col in range(len(input_list[0])):
        if col < min_col or col > max_col:
            continue
        for row in range(len(input_list)):
            if input_list[row][col] != background:
                if col == min_col or col == max_col:
                    output_list[row][col] = input_list[row][col]
                else:
                    output_list[row][col] = input_list[row][col] ^ 1
    
    return output_list
