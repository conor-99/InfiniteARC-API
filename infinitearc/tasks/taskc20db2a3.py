# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: c20db2a3
Difficulty: mediumâ€“hard

=== Tags ===
- Deterministic update
- Rule propagation

=== Description ===
# Task Description  Input grids feature a background color (0) and a collection
of non-background cells arranged in a scattered, non-overlapping pattern. These
non-background cells are distributed such that no two are adjacent horizontally,
vertically, or diagonally. The output grid applies a deterministic rule where
every background cell that has a non-background cell directly to its left and a
non-background cell directly above it is transformed into a distinct new color
(different from all background and input non-background colors). This rule
systematically identifies cells that are "supported" by non-background elements
in both horizontal and vertical directions, creating a new visual pattern that
propagates the input structure diagonally toward the bottom-right. The
transformation creates a continuous diagonal band of the new color that emerges
where input elements form a "corner" configuration, while all other cells remain
unchanged. The output grid's new color is consistently applied across all such
positions without overlap or interaction with existing non-background elements.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import remove_neighbors, random_pixels

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    grid = [[0] * width for _ in range(height)]
    
    pixels = random_pixels(width, height, prob=0.3)
    pixels = remove_neighbors(pixels)
    
    if not pixels:
        return generate()
    
    color_list = list(range(1, 10))
    num_colors = random.randint(1, 8)
    colors_used = random.sample(color_list, num_colors)
    
    for r, c in pixels:
        grid[r][c] = random.choice(colors_used)
    
    # Calculate actual colors present in grid
    actual_colors = set()
    for row in grid:
        for color in row:
            if color != 0:
                actual_colors.add(color)
    
    all_colors = set(range(1, 10))
    available_colors = sorted(all_colors - actual_colors)
    new_color = available_colors[0]
    
    output = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0:
                if c > 0 and grid[r][c-1] != 0 and r > 0 and grid[r-1][c] != 0:
                    output[r][c] = new_color
    
    if grid == output:
        return generate()
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    used_colors = set()
    for row in grid:
        for color in row:
            if color != 0:
                used_colors.add(color)
    
    available_colors = sorted(set(range(1, 10)) - used_colors)
    new_color = available_colors[0] if available_colors else 1
    
    output = [row[:] for row in grid]
    height = len(grid)
    width = len(grid[0])
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0:
                if c > 0 and grid[r][c-1] != 0 and r > 0 and grid[r-1][c] != 0:
                    output[r][c] = new_color
    return output
