# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 17c2cae3
Difficulty: insane

=== Tags ===
- Color carving
- Non rectangular tiling

=== Description ===
Input grids are two-dimensional arrays with a background color (0) and multiple
foreground colors (1-9). Each foreground color corresponds to a unique carving
direction (left, right, up, or down), consistent across all grids. For each cell
of a foreground color, all cells in the specified direction from that cell are
carved (set to background) until the grid boundary or a cell of a different
color is encountered. Carving operations are applied simultaneously to all
cells. The output grid is the input grid after all carving operations, where
carved cells are set to background. The remaining non-background cells form a
non-rectangular tiling, meaning their arrangement does not form a rectangular
shape but instead exhibits a complex, irregular pattern that requires multi-step
reasoning to deduce from the input grid. The task demands recognizing color-
direction mappings, resolving overlapping carving effects, and identifying the
emergent non-rectangular structure from the interaction of multiple directional
carving rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(5, 20)
    height = random.randint(5, 20)
    input_grid = grid(width, height, 0)
    directions = {1: (0, -1), 2: (0, 1), 3: (-1, 0), 4: (1, 0)}
    for r in range(height):
        for c in range(width):
            if random.random() < 0.3:
                color = random.choice([1, 2, 3, 4])
                input_grid[r][c] = color
    output_grid = apply_carving(input_grid, directions)
    if is_rectangular(output_grid):
        return generate()
    if input_grid == output_grid:
        return generate()
    return {
        "input": input_grid,
        "output": output_grid
    }

def apply_carving(grid, directions):
    width = len(grid[0])
    height = len(grid)
    to_zero = set()
    for r in range(height):
        for c in range(width):
            color = grid[r][c]
            if color in directions:
                dr, dc = directions[color]
                nr, nc = r + dr, c + dc
                while 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == color:
                    to_zero.add((nr, nc))
                    nr += dr
                    nc += dc
    output = [row[:] for row in grid]
    for (r, c) in to_zero:
        output[r][c] = 0
    return output

def is_rectangular(grid):
    non_zero = [(r, c) for r in range(len(grid)) for c in range(len(grid[0])) if grid[r][c] != 0]
    if not non_zero:
        return True
    min_r = min(r for r, c in non_zero)
    max_r = max(r for r, c in non_zero)
    min_c = min(c for r, c in non_zero)
    max_c = max(c for r, c in non_zero)
    for r in range(min_r, max_r + 1):
        for c in range(min_c, max_c + 1):
            if grid[r][c] == 0:
                return False
    return True


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    width = len(input_list[0])
    height = len(input_list)
    directions = {1: (0, -1), 2: (0, 1), 3: (-1, 0), 4: (1, 0)}
    to_zero = set()
    for r in range(height):
        for c in range(width):
            color = input_list[r][c]
            if color in directions:
                dr, dc = directions[color]
                nr, nc = r + dr, c + dc
                while 0 <= nr < height and 0 <= nc < width and input_list[nr][nc] == color:
                    to_zero.add((nr, nc))
                    nr += dr
                    nc += dc
    output = [row[:] for row in input_list]
    for (r, c) in to_zero:
        output[r][c] = 0
    return output
