# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: a8f0f215
Difficulty: hard

=== Tags ===
- Shape attribute projection
- Intersecting currents
- Directed field

=== Description ===
Intersecting Currents: Attribute Projection  Input grids feature multiple
straight-line currents of distinct colors, each oriented horizontally or
vertically and extending across the grid. Each current maintains a consistent
direction (left/right for horizontal, up/down for vertical) and color, with no
two currents overlapping except at right-angle intersections. Background cells
are uniformly color 0 (black). Currents are represented by contiguous sequences
of cells in their color, with no gaps or branches.  The transformation requires
projecting each current's color along its direction until encountering a grid
boundary or another current. At right-angle intersections (where horizontal and
vertical currents cross), the intersection cell is replaced by the standard
color mixture of the two currents (e.g., red + blue = purple, green + yellow =
orange). Crucially, after the intersection, both currents continue projecting
their new combined color along their original directions. This process
propagates through all intersections in the grid, with subsequent intersections
using the updated color from the prior intersection.  For example, a red (2)
current moving right intersecting a blue (1) current moving up results in a
purple (6) intersection cell. The red current continues right as purple, and the
blue current continues up as purple. If the purple current later intersects a
green (3) current moving left, their intersection becomes orange (4), and both
currents continue as orange. The output grid must reflect all such interactions,
with colors propagating through the entire path of each current while
maintaining directional continuity. No cells are overwritten except at
intersections, and background cells remain unchanged unless part of a projected
path. This task demands multi-step reasoning about path propagation, color
interaction rules, and handling nested intersectionsâ€”requiring users to track
color evolution across the grid while respecting directional constraints.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def mix_colors(a, b):
    mix_map = {
        (1, 2): 6,
        (2, 1): 6,
        (3, 4): 7,
        (4, 3): 7,
        (1, 3): 8,
        (3, 1): 8,
        (2, 4): 9,
        (4, 2): 9,
        (1, 4): 5,
        (4, 1): 5,
        (2, 3): 5,
        (3, 2): 5,
    }
    return mix_map.get((a, b), (a + b) % 10)

def generate():
    grid_size = random.randint(10, 20)
    num_horizontal = random.randint(1, 3)
    num_vertical = random.randint(1, 3)
    
    horizontal_rows = random.sample(range(grid_size), num_horizontal)
    horizontal_colors = [random.randint(1, 9) for _ in range(num_horizontal)]
    
    vertical_cols = random.sample(range(grid_size), num_vertical)
    vertical_colors = [random.randint(1, 9) for _ in range(num_vertical)]
    
    input_grid = [[0]*grid_size for _ in range(grid_size)]
    for r, h_color in zip(horizontal_rows, horizontal_colors):
        for c in range(grid_size):
            input_grid[r][c] = h_color
    for c, v_color in zip(vertical_cols, vertical_colors):
        for r in range(grid_size):
            if input_grid[r][c] == 0:
                input_grid[r][c] = v_color
    
    output_grid = [[0]*grid_size for _ in range(grid_size)]
    
    horizontal_rows_out = []
    horizontal_colors_out = []
    for r in range(grid_size):
        colors = set(input_grid[r])
        if 0 not in colors and len(colors) == 1:
            horizontal_rows_out.append(r)
            horizontal_colors_out.append(input_grid[r][0])
    
    vertical_cols_out = []
    vertical_colors_out = []
    for c in range(grid_size):
        colors = set(input_grid[r][c] for r in range(grid_size))
        if 0 not in colors and len(colors) == 1:
            vertical_cols_out.append(c)
            vertical_colors_out.append(input_grid[0][c])
    
    for idx, r in enumerate(horizontal_rows_out):
        h_color = horizontal_colors_out[idx]
        current_color = h_color
        intersections = sorted([c for c in vertical_cols_out if input_grid[r][c] == h_color])
        for c in intersections:
            v_idx = vertical_cols_out.index(c)
            v_color = vertical_colors_out[v_idx]
            mixed = mix_colors(current_color, v_color)
            output_grid[r][c] = mixed
            for col in range(c+1, grid_size):
                output_grid[r][col] = mixed
            current_color = mixed
        if intersections:
            first_c = intersections[0]
            for col in range(0, first_c):
                output_grid[r][col] = h_color
        else:
            for col in range(grid_size):
                output_grid[r][col] = h_color
    
    for idx, c in enumerate(vertical_cols_out):
        v_color = vertical_colors_out[idx]
        current_color = v_color
        intersections = sorted([r for r in horizontal_rows_out if input_grid[r][c] == v_color])
        for r in intersections:
            h_idx = horizontal_rows_out.index(r)
            h_color = horizontal_colors_out[h_idx]
            mixed = mix_colors(h_color, current_color)
            output_grid[r][c] = mixed
            for row in range(r+1, grid_size):
                output_grid[row][c] = mixed
            current_color = mixed
        if intersections:
            first_r = intersections[0]
            for row in range(0, first_r):
                output_grid[row][c] = v_color
        else:
            for row in range(grid_size):
                output_grid[row][c] = v_color
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    
    def mix_colors(a, b):
        mix_map = {
            (1, 2): 6,
            (2, 1): 6,
            (3, 4): 7,
            (4, 3): 7,
            (1, 3): 8,
            (3, 1): 8,
            (2, 4): 9,
            (4, 2): 9,
            (1, 4): 5,
            (4, 1): 5,
            (2, 3): 5,
            (3, 2): 5,
        }
        return mix_map.get((a, b), (a + b) % 10)
    
    output_grid = [[0]*width for _ in range(height)]
    
    horizontal_rows = []
    horizontal_colors = []
    for r in range(height):
        colors = set(input_grid[r])
        if 0 not in colors and len(colors) == 1:
            horizontal_rows.append(r)
            horizontal_colors.append(input_grid[r][0])
    
    vertical_cols = []
    vertical_colors = []
    for c in range(width):
        colors = set(input_grid[r][c] for r in range(height))
        if 0 not in colors and len(colors) == 1:
            vertical_cols.append(c)
            vertical_colors.append(input_grid[0][c])
    
    for idx, r in enumerate(horizontal_rows):
        h_color = horizontal_colors[idx]
        current_color = h_color
        intersections = sorted([c for c in vertical_cols if input_grid[r][c] == h_color])
        for c in intersections:
            v_idx = vertical_cols.index(c)
            v_color = vertical_colors[v_idx]
            mixed = mix_colors(current_color, v_color)
            output_grid[r][c] = mixed
            for col in range(c+1, width):
                output_grid[r][col] = mixed
            current_color = mixed
        if intersections:
            first_c = intersections[0]
            for col in range(0, first_c):
                output_grid[r][col] = h_color
        else:
            for col in range(width):
                output_grid[r][col] = h_color
    
    for idx, c in enumerate(vertical_cols):
        v_color = vertical_colors[idx]
        current_color = v_color
        intersections = sorted([r for r in horizontal_rows if input_grid[r][c] == v_color])
        for r in intersections:
            h_idx = horizontal_rows.index(r)
            h_color = horizontal_colors[h_idx]
            mixed = mix_colors(h_color, current_color)
            output_grid[r][c] = mixed
            for row in range(r+1, height):
                output_grid[row][c] = mixed
            current_color = mixed
        if intersections:
            first_r = intersections[0]
            for row in range(0, first_r):
                output_grid[row][c] = v_color
        else:
            for row in range(height):
                output_grid[row][c] = v_color
    
    return output_grid
