# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 10a7e682
Difficulty: medium–hard

=== Tags ===
- Symmetry axis completion
- Compositional reflection
- Ex nihilo

=== Description ===
Input grids are 15×15 to 30×30 grids with a uniform background color (0). A
single, contiguous non-background object (colors 1–9) occupies only the left
side of an inferred vertical symmetry axis, with no elements present on the
right side. The symmetry axis is dynamically determined by the leftmost (L) and
rightmost (R) columns containing non-background elements: the axis lies at
column X = (L + R) / 2, which may be a half-integer. For each non-background
cell at (row, column), the output grid places an identical color at (row, 2X -
column) if that position is background (0), creating a complete symmetric
object. This "ex nihilo" placement ensures no overwriting of existing elements
while maintaining compositional reflection across the axis. The process requires
identifying the axis from the object's spatial extent, reflecting all elements
relative to it, and adding new elements only in background cells to achieve
perfect vertical symmetry. The output grid preserves all input elements and
completes the object's symmetry without altering any original non-background
cells or background color.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def is_symmetric(pixels, L, R):
    for (r, c) in pixels:
        c_mirror = L + R - c
        if (r, c_mirror) not in pixels:
            return False
    return True

def generate():
    width = random.randint(15, 30)
    height = random.randint(15, 30)
    grid_in = [[0] * width for _ in range(height)]
    size = random.randint(5, 20)
    pixels = common.continuous_creature(size, width, height)
    L = min(c for r, c in pixels)
    R = max(c for r, c in pixels)
    if is_symmetric(pixels, L, R):
        return generate()
    color = common.random_color()
    for (r, c) in pixels:
        grid_in[r][c] = color
    grid_out = [row[:] for row in grid_in]
    for (r, c) in pixels:
        c_mirror = L + R - c
        if 0 <= c_mirror < width and grid_in[r][c_mirror] == 0:
            grid_out[r][c_mirror] = color
    return {"input": grid_in, "output": grid_out}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    non_zero = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                non_zero.append((r, c))
    if not non_zero:
        return input_grid
    L = min(c for r, c in non_zero)
    R = max(c for r, c in non_zero)
    for (r, c) in non_zero:
        c_mirror = L + R - c
        if 0 <= c_mirror < width and grid[r][c_mirror] == 0:
            grid[r][c_mirror] = grid[r][c]
    return tuple(tuple(row) for row in grid)
