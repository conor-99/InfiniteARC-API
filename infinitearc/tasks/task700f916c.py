# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 700f916c
Difficulty: hard

=== Tags ===
- Maze wave
- Recursive path tracing
- Divide by n
- Image juxtaposition

=== Description ===
Input grids feature a continuous wave-like path (single non-background color)
traversing a maze of walls and background, with the path exhibiting clear
vertical oscillations (peaks and troughs). The output grid is created by
segmenting the path at each peak (vertical maximum), yielding n segments where n
is the number of peaks plus one. Each segment undergoes recursive transformation
to form a smaller-scale wave (reduced vertical amplitude and horizontal
wavelength), and these transformed segments are arranged in sequence within the
output grid, maintaining their original order. Walls and background remain
unchanged, and the path color is preserved throughout the transformation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import math

def generate():
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    grid = [[0] * width for _ in range(height)]
    
    start_y = random.randint(3, height - 4)
    path = []
    for x in range(0, 10):
        y = start_y + int(2 * random.choice([1, -1]) * math.sin(x * math.pi / 4))
        path.append((x, y))
    
    path = [(x, max(0, min(height-1, y))) for (x, y) in path]
    for (x, y) in path:
        if 0 <= x < width and 0 <= y < height:
            grid[y][x] = 1
    
    for (x, y) in path:
        if y - 1 >= 0:
            grid[y-1][x] = 2
        if y + 1 < height:
            grid[y+1][x] = 2
    
    peaks = []
    for i in range(1, len(path) - 1):
        if path[i][1] > path[i-1][1] and path[i][1] > path[i+1][1]:
            peaks.append(path[i])
    
    segments = []
    start_idx = 0
    for peak in peaks:
        idx = path.index(peak)
        segments.append(path[start_idx:idx+1])
        start_idx = idx
    segments.append(path[start_idx:])
    
    transformed_segments = []
    for seg in segments:
        ys = [y for (x, y) in seg]
        min_y, max_y = min(ys), max(ys)
        if max_y == min_y:
            new_amplitude = 0
        else:
            new_amplitude = (max_y - min_y) // 2
        new_seg = []
        for (x, y) in seg:
            new_y = min_y + (y - min_y) * new_amplitude // (max_y - min_y) if max_y != min_y else y
            new_seg.append((x, new_y))
        transformed_segments.append(new_seg)
    
    new_path = [p for seg in transformed_segments for p in seg]
    
    output_grid = [[0] * width for _ in range(height)]
    for y in range(height):
        for x in range(width):
            if grid[y][x] == 2:
                output_grid[y][x] = 2
    for (x, y) in new_path:
        if 0 <= x < width and 0 <= y < height:
            output_grid[y][x] = 1
    
    return {"input": grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    path = []
    for y in range(height):
        for x in range(width):
            if grid[y][x] == 1:
                path.append((x, y))
    
    path.sort(key=lambda pos: pos[0])
    
    peaks = []
    for i in range(1, len(path) - 1):
        x_prev, y_prev = path[i-1]
        x_curr, y_curr = path[i]
        x_next, y_next = path[i+1]
        if y_curr > y_prev and y_curr > y_next:
            peaks.append((x_curr, y_curr))
    
    segments = []
    start_idx = 0
    for peak in peaks:
        idx = None
        for i, (x, y) in enumerate(path):
            if (x, y) == peak:
                idx = i
                break
        if idx is not None:
            segments.append(path[start_idx:idx+1])
            start_idx = idx
    segments.append(path[start_idx:])
    
    transformed_segments = []
    for seg in segments:
        ys = [y for (x, y) in seg]
        min_y, max_y = min(ys), max(ys)
        if max_y == min_y:
            new_amplitude = 0
        else:
            new_amplitude = (max_y - min_y) // 2
        new_seg = []
        for (x, y) in seg:
            new_y = min_y + (y - min_y) * new_amplitude // (max_y - min_y) if max_y != min_y else y
            new_seg.append((x, new_y))
        transformed_segments.append(new_seg)
    
    new_path = [p for seg in transformed_segments for p in seg]
    
    output_grid = [[0] * width for _ in range(height)]
    for y in range(height):
        for x in range(width):
            if grid[y][x] == 2:
                output_grid[y][x] = 2
    for (x, y) in new_path:
        if 0 <= x < width and 0 <= y < height:
            output_grid[y][x] = 1
    
    return output_grid
