# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 66755344
Difficulty: very hard

=== Tags ===
- Shape extrusion
- Hierarchical agent routing
- Agent memory trace
- Portals

=== Description ===
Input grids are large (width and height both exceeding 15) with a single
background color (0). Over this background, the grid contains:  - **Walls**:
1-cell-thick horizontal or vertical lines of color 1, not touching each other or
other elements, forming a maze-like structure with open corridors. -
**Portals**: Paired cells of color 5, each pair separated by at least 2
background cells, with no overlap with walls or other elements. Portals are
bidirectional: stepping on one teleports the agent to its paired cell. -
**Agents**: Three distinct agents represented by colors 2, 3, and 4, each
positioned on background cells in the top-left quadrant. Agent 4 has the highest
priority, followed by 3, then 2. - **Base shape**: A connected rectangular
region of color 6 (e.g., 2x3), not adjacent to walls or portals.  The output
grid transforms the input by applying these rules in sequence:  1. **Shape
extrusion**: The base shape (color 6) is expanded outward by one cell in all
directions (up, down, left, right) where adjacent cells are background (0). The
extruded cells become color 7, forming a larger contiguous shape that maintains
connectivity and does not overlap with walls, portals, or other elements.  2.
**Hierarchical agent routing**: Each agent follows a path determined by
priority:    - **Agent 4** moves east (right) from its start until hitting a
wall, portal, or grid edge. Upon portal entry, it teleports to the paired portal
and continues east. The path is recorded as a memory trace of color 4 on
traversed background cells.    - **Agent 3** follows Agent 4’s path with a
1-step delay (starts moving after Agent 4 advances one cell), leaving color 3
traces.    - **Agent 2** follows Agent 3’s path with a 2-step delay, leaving
color 2 traces.  3. **Portal effects**: Portal pairs remain visible as color 5.
Teleportation continues the memory trace uninterrupted from the paired portal’s
position. Traces never overwrite walls, portals, the extruded shape, or other
traces.  All rules interact: extrusion may alter corridor availability, portals
redirect paths, and hierarchical delays prevent trace overlap. Agents exit the
grid after finite steps without cycles. The output preserves walls, portals, and
base shape (now extruded), while adding color-coded memory traces that reflect
the agents’ hierarchical, portal-aided movement through the maze.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    from common import grid

    # Helper functions
    def in_bounds(r, c, H, W):
        return 0 <= r < H and 0 <= c < W

    def neighbor_cells_8(r, c, H, W):
        for dr in (-1, 0, 1):
            for dc in (-1, 0, 1):
                if dr == 0 and dc == 0:
                    continue
                nr, nc = r + dr, c + dc
                if in_bounds(nr, nc, H, W):
                    yield nr, nc

    def neighbor_cells_4(r, c, H, W):
        for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
            nr, nc = r + dr, c + dc
            if in_bounds(nr, nc, H, W):
                yield nr, nc

    # Choose grid size (both > 15)
    W = random.randint(16, 24)
    H = random.randint(16, 24)
    ingrid = grid(W, H, 0)

    # Place wall segments (1) - ensure they do not touch each other or other elements
    wall_segments = random.randint(8, 14)
    placed = 0
    attempts = 0
    while placed < wall_segments and attempts < wall_segments * 30:
        attempts += 1
        horiz = random.choice([True, False])
        length = random.randint(3, max(3, min(8, max(W, H)//3)))
        if horiz:
            r = random.randint(0, H - 1)
            c0 = random.randint(0, max(0, W - length))
            coords = [(r, c) for c in range(c0, c0 + length)]
        else:
            c = random.randint(0, W - 1)
            r0 = random.randint(0, max(0, H - length))
            coords = [(r, c) for r in range(r0, r0 + length)]

        # Check validity: all cells and their 8-neighbors must be background (0)
        ok = True
        for (r, c) in coords:
            if ingrid[r][c] != 0:
                ok = False
                break
            for nr, nc in neighbor_cells_8(r, c, H, W):
                if ingrid[nr][nc] != 0:
                    ok = False
                    break
            if not ok:
                break
        if not ok:
            continue
        # Place wall
        for (r, c) in coords:
            ingrid[r][c] = 1
        placed += 1

    # Place base rectangular shape (6), choose a spot not adjacent to walls
    base_h = random.choice([2, 3])
    base_w = random.choice([2, 3])
    base_r = None
    base_c = None
    tries = 0
    while tries < 200 and base_r is None:
        tries += 1
        r0 = random.randint(H // 3, max(H // 3, H - base_h - 1))
        c0 = random.randint(W // 3, max(W // 3, W - base_w - 1))
        ok = True
        for r in range(r0, r0 + base_h):
            for c in range(c0, c0 + base_w):
                if ingrid[r][c] != 0:
                    ok = False
                    break
                # Ensure no wall adjacent (4-neighbors)
                for nr, nc in neighbor_cells_4(r, c, H, W):
                    if ingrid[nr][nc] == 1:
                        ok = False
                        break
            if not ok:
                break
        if ok:
            base_r, base_c = r0, c0
    if base_r is None:
        # fallback: scan for any 2x2 empty area
        found = False
        for r0 in range(H - base_h):
            for c0 in range(W - base_w):
                ok = True
                for r in range(r0, r0 + base_h):
                    for c in range(c0, c0 + base_w):
                        if ingrid[r][c] != 0:
                            ok = False
                            break
                    if not ok:
                        break
                if ok:
                    base_r, base_c = r0, c0
                    found = True
                    break
            if found:
                break
    # Fill base shape
    for r in range(base_r, base_r + base_h):
        for c in range(base_c, base_c + base_w):
            ingrid[r][c] = 6

    # Place exactly one portal pair (5). Ensure pair is isolated so solver can pair by nearest neighbor.
    portal_pairs = []
    portal_cells = set()
    num_pairs = 1
    tries = 0
    while len(portal_pairs) < num_pairs and tries < 1000:
        tries += 1
        # choose first portal somewhere not adjacent to base or walls and not in top-left quadrant
        r1 = random.randint(max(0, H // 3), H - 1)
        c1 = random.randint(max(0, W // 3), W - 1)
        if ingrid[r1][c1] != 0:
            continue
        bad = False
        for nr, nc in neighbor_cells_4(r1, c1, H, W):
            if ingrid[nr][nc] == 1 or ingrid[nr][nc] == 6:
                bad = True
                break
        if bad:
            continue
        # pick a partner at a decent distance but still unambiguous
        cands = []
        for r2 in range(0, H):
            for c2 in range(0, W):
                if r2 == r1 and c2 == c1:
                    continue
                if ingrid[r2][c2] != 0:
                    continue
                if abs(r1 - r2) + abs(c1 - c2) < 3:
                    continue
                # not adjacent to walls or base
                bad2 = False
                for nr, nc in neighbor_cells_4(r2, c2, H, W):
                    if ingrid[nr][nc] == 1 or ingrid[nr][nc] == 6:
                        bad2 = True
                        break
                if bad2:
                    continue
                # ensure not in top-left quadrant
                if r2 < H // 3 and c2 < W // 3:
                    continue
                cands.append((r2, c2))
        if not cands:
            continue
        # choose a partner relatively close to the first portal to make their pairing the nearest neighbor pairing
        cands.sort(key=lambda p: abs(p[0]-r1) + abs(p[1]-c1))
        r2, c2 = cands[0]
        portal_pairs.append((r1, c1, r2, c2))
        portal_cells.add((r1, c1))
        portal_cells.add((r2, c2))
        ingrid[r1][c1] = 5
        ingrid[r2][c2] = 5

    # Place agents in top-left quadrant, in a short contiguous run so they can follow eastwards
    agent_row = random.randint(0, max(0, H // 3 - 1))
    # choose a start column so that there is room to the right
    start_c = random.randint(0, max(0, min(W // 4, W - 6)))

    # ensure three contiguous free cells at (agent_row, start_c .. start_c+2)
    attempt = 0
    while attempt < 200:
        attempt += 1
        if start_c + 2 >= W:
            start_c = random.randint(0, max(0, W - 4))
            continue
        ok = True
        for c in range(start_c, start_c + 3):
            if ingrid[agent_row][c] != 0:
                ok = False
                break
            for nr, nc in neighbor_cells_4(agent_row, c, H, W):
                if ingrid[nr][nc] == 1 or ingrid[nr][nc] == 5 or ingrid[nr][nc] == 6:
                    ok = False
                    break
            if not ok:
                break
        if ok:
            break
        start_c = random.randint(0, max(0, W - 4))

    # Place agents 2,3,4 left to right
    agents_pos = {}
    ingrid[agent_row][start_c] = 2
    agents_pos[2] = (agent_row, start_c)
    ingrid[agent_row][start_c + 1] = 3
    agents_pos[3] = (agent_row, start_c + 1)
    ingrid[agent_row][start_c + 2] = 4
    agents_pos[4] = (agent_row, start_c + 2)

    # Now compute the output by extruding base (6->7) and then simulating agent paths
    out = [row[:] for row in ingrid]

    # Extrude: any orthogonal neighbor of a 6 that is background becomes 7
    for r in range(H):
        for c in range(W):
            if ingrid[r][c] == 6:
                for nr, nc in neighbor_cells_4(r, c, H, W):
                    if out[nr][nc] == 0:
                        out[nr][nc] = 7

    # Build portal mapping (exact mapping as we stored while placing)
    portal_map = {}
    for (r1, c1, r2, c2) in portal_pairs:
        portal_map[(r1, c1)] = (r2, c2)
        portal_map[(r2, c2)] = (r1, c1)

    # Simulate agent 4 path (eastward movement, teleport on portals). Use the extruded/out grid as obstacles.
    def simulate_east_path(start):
        path = []
        cur = start
        steps = 0
        max_steps = W * H + 10
        while steps < max_steps:
            steps += 1
            nr, nc = cur[0], cur[1] + 1
            if not in_bounds(nr, nc, H, W):
                break
            val = out[nr][nc]
            # obstacles: walls(1), base(6), extruded(7)
            if val == 1 or val == 6 or val == 7:
                break
            if val == 5:
                # teleport to pair
                pair = portal_map.get((nr, nc))
                if pair is None:
                    break
                # arrive at pair cell (we do not mark portals). After teleport, continue east from pair.
                cur = pair
                # compute cell east of arrival
                nr, nc = cur[0], cur[1] + 1
                if not in_bounds(nr, nc, H, W):
                    break
                val2 = out[nr][nc]
                if val2 == 1 or val2 == 6 or val2 == 7:
                    break
                if val2 == 5:
                    # stepping into another portal - handle in next loop iteration
                    cur = (nr, nc)
                    continue
                if val2 == 0:
                    path.append((nr, nc))
                    cur = (nr, nc)
                    continue
                # if val2 is nonzero non-portal (agents or traces), stop
                break
            if val == 0:
                path.append((nr, nc))
                cur = (nr, nc)
                continue
            # if val is a non-background and non-portal (e.g., another agent), stop
            break
        return path

    path4 = simulate_east_path(agents_pos[4])
    # Agent 3 follows with 1-step delay -> positions are path4 shifted by 1
    path3 = path4[:-1] if len(path4) >= 1 else []
    # Agent 2 follows with 2-step delay -> positions are path4 shifted by 2
    path2 = path4[:-2] if len(path4) >= 2 else []

    # Priority-based overlay: lower priority first, higher priority can overwrite lower priority
    # Priority order: 2 < 3 < 4
    def priority_of(v):
        if v == 0:
            return 0
        if v == 2:
            return 1
        if v == 3:
            return 2
        if v == 4:
            return 3
        return 100

    # record original agent positions so we don't overwrite them
    original_agent_cells = set(agents_pos.values())

    # apply path2
    for (r, c) in path2:
        if ingrid[r][c] != 0:
            continue
        # don't overwrite walls/portals/base/extruded
        if out[r][c] in (1, 5, 6, 7):
            continue
        # don't overwrite original agent cells
        if (r, c) in original_agent_cells:
            continue
        if priority_of(out[r][c]) < priority_of(2):
            out[r][c] = 2

    # apply path3
    for (r, c) in path3:
        if ingrid[r][c] != 0:
            continue
        if out[r][c] in (1, 5, 6, 7):
            continue
        if (r, c) in original_agent_cells:
            continue
        if priority_of(out[r][c]) < priority_of(3):
            out[r][c] = 3

    # apply path4
    for (r, c) in path4:
        if ingrid[r][c] != 0:
            continue
        if out[r][c] in (1, 5, 6, 7):
            continue
        if (r, c) in original_agent_cells:
            continue
        if priority_of(out[r][c]) < priority_of(4):
            out[r][c] = 4

    return {"input": ingrid, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert grid tuple-of-tuples to list-of-lists
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0])

    def in_bounds(r, c):
        return 0 <= r < H and 0 <= c < W

    def neighbor_cells_4(r, c):
        for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
            nr, nc = r + dr, c + dc
            if in_bounds(nr, nc):
                yield nr, nc

    # Find base shape (6) bounding box
    six_cells = [(r, c) for r in range(H) for c in range(W) if grid[r][c] == 6]
    if not six_cells:
        # nothing to do
        return grid
    min_r = min(r for r, c in six_cells)
    max_r = max(r for r, c in six_cells)
    min_c = min(c for r, c in six_cells)
    max_c = max(c for r, c in six_cells)

    # Build output grid and extrude base (6 -> 7 into background cells)
    out = [row[:] for row in grid]
    for (r, c) in six_cells:
        for nr, nc in neighbor_cells_4(r, c):
            if out[nr][nc] == 0:
                out[nr][nc] = 7

    # Find portals and pair them by nearest-neighbor greedy pairing
    portals = [(r, c) for r in range(H) for c in range(W) if grid[r][c] == 5]
    pairs = []
    used = set()
    for i, p in enumerate(portals):
        if p in used:
            continue
        # find nearest portal not used
        best = None
        bestd = None
        for q in portals:
            if q == p or q in used:
                continue
            d = abs(p[0] - q[0]) + abs(p[1] - q[1])
            if best is None or d < bestd:
                best = q
                bestd = d
        if best is None:
            continue
        pairs.append((p[0], p[1], best[0], best[1]))
        used.add(p)
        used.add(best)
    portal_map = {}
    for (r1, c1, r2, c2) in pairs:
        portal_map[(r1, c1)] = (r2, c2)
        portal_map[(r2, c2)] = (r1, c1)

    # find agent starting positions
    agents = {}
    for r in range(H):
        for c in range(W):
            if grid[r][c] in (2,3,4):
                agents[grid[r][c]] = (r, c)
    # If any agent missing, just return the extruded grid
    if 4 not in agents:
        return out

    # Simulate eastward path for agent 4 (using out as obstacle map, which includes extrusion)
    def simulate_east(start):
        path = []
        cur = start
        steps = 0
        max_steps = W * H + 10
        while steps < max_steps:
            steps += 1
            nr, nc = cur[0], cur[1] + 1
            if not in_bounds(nr, nc):
                break
            val = out[nr][nc]
            # obstacles: walls(1), base(6), extruded(7)
            if val == 1 or val == 6 or val == 7:
                break
            if val == 5:
                # teleport to pair
                pair = portal_map.get((nr, nc))
                if pair is None:
                    break
                cur = pair
                nr, nc = cur[0], cur[1] + 1
                if not in_bounds(nr, nc):
                    break
                val2 = out[nr][nc]
                if val2 == 1 or val2 == 6 or val2 == 7:
                    break
                if val2 == 5:
                    cur = (nr, nc)
                    continue
                if val2 == 0:
                    path.append((nr, nc))
                    cur = (nr, nc)
                    continue
                break
            if val == 0:
                path.append((nr, nc))
                cur = (nr, nc)
                continue
            break
        return path

    path4 = simulate_east(agents[4])
    path3 = path4[:-1] if len(path4) >= 1 else []
    path2 = path4[:-2] if len(path4) >= 2 else []

    # Overlay traces with hierarchical priority, lower first so higher can overwrite
    def priority_of(v):
        if v == 0:
            return 0
        if v == 2:
            return 1
        if v == 3:
            return 2
        if v == 4:
            return 3
        return 100

    original_agent_cells = set(agents.values())

    for (r, c) in path2:
        if grid[r][c] != 0:
            continue
        if out[r][c] in (1, 5, 6, 7):
            continue
        if (r, c) in original_agent_cells:
            continue
        if priority_of(out[r][c]) < priority_of(2):
            out[r][c] = 2

    for (r, c) in path3:
        if grid[r][c] != 0:
            continue
        if out[r][c] in (1, 5, 6, 7):
            continue
        if (r, c) in original_agent_cells:
            continue
        if priority_of(out[r][c]) < priority_of(3):
            out[r][c] = 3

    for (r, c) in path4:
        if grid[r][c] != 0:
            continue
        if out[r][c] in (1, 5, 6, 7):
            continue
        if (r, c) in original_agent_cells:
            continue
        if priority_of(out[r][c]) < priority_of(4):
            out[r][c] = 4

    return out

