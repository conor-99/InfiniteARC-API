# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 296306d8
Difficulty: hard

=== Tags ===
- Fractal repetition
- Measure distance from side
- Color matching

=== Description ===
Each cell in the output grid is determined by the value at position (d, d) in
the input grid, where d represents the minimum distance from the current cell's
position to any of the grid's four edges. The distance d is calculated as the
smallest value among the row index, the distance to the bottom edge (height - 1
- row index), the column index, and the distance to the right edge (width - 1 -
column index). This transformation creates a concentric pattern where each layer
of the grid is colored using a diagonal element from the input, resulting in a
self-similar repetition of color patterns at progressively smaller scalesâ€”this
is the fractal repetition aspect. The color matching occurs because the output's
layer colors are directly derived from specific input positions based on the
distance metric, requiring the solver to map distance values to diagonal
coordinates.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    while True:
        H = random.randint(1, 30)
        W = random.randint(1, 30)
        if H == 1 and W == 1:
            continue
        input_grid = grid(W, H, 0)
        for r in range(H):
            for c in range(W):
                input_grid[r][c] = random.randint(0, 9)
        output_grid = grid(W, H, 0)
        for r in range(H):
            for c in range(W):
                d = min(r, H-1 - r, c, W-1 - c)
                output_grid[r][c] = input_grid[d][d]
        if input_grid != output_grid:
            break
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    H = len(input_grid)
    W = len(input_grid[0])
    output_grid = grid(W, H, 0)
    for r in range(H):
        for c in range(W):
            d = min(r, H-1 - r, c, W-1 - c)
            output_grid[r][c] = input_grid[d][d]
    return output_grid
