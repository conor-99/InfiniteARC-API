# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 0246a602
Difficulty: hard

=== Tags ===
- Shape guessing

=== Description ===
The input grid contains a single connected shape composed of a single non-zero
color on a zero background. The output grid represents the perimeter of this
shape, where a cell is included in the perimeter if it is part of the shape and
has at least one adjacent cell (up, down, left, right) that is part of the
background (zero). All other cells in the output grid are set to zero. This
requires identifying the boundary of the shape by checking for cells with
background neighbors, distinguishing it from the internal cells of the shape.
The transformation is consistent across all valid inputs, as the perimeter is
determined solely by the shape's connectivity and adjacency relationships, not
by specific color values or geometric properties.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    color = random.randint(1, 9)
    rect_h = min(random.randint(3, 5), height - 2)
    rect_w = min(random.randint(3, 5), width - 2)
    r_start = random.randint(1, height - rect_h - 1)
    c_start = random.randint(1, width - rect_w - 1)
    input_grid = [[0] * width for _ in range(height)]
    for r in range(r_start, r_start + rect_h):
        for c in range(c_start, c_start + rect_w):
            input_grid[r][c] = color
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == color:
                for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
                    nr, nc = r + dr, c + dc
                    if nr < 0 or nr >= height or nc < 0 or nc >= width:
                        output_grid[r][c] = color
                        break
                    if input_grid[nr][nc] == 0:
                        output_grid[r][c] = color
                        break
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                    nr, nc = r + dr, c + dc
                    if nr < 0 or nr >= height or nc < 0 or nc >= width:
                        output[r][c] = input_grid[r][c]
                        break
                    if input_grid[nr][nc] == 0:
                        output[r][c] = input_grid[r][c]
                        break
    return output
