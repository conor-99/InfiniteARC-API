# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 82553b02
Difficulty: insane

=== Tags ===
- Circuit reflection
- Multi object alignment
- Cylindrical
- Mark centroid

=== Description ===
Input grids are cylindrical (left and right edges connected), containing
multiple distinct, non-overlapping, and connected colored objects (each object
is a single non-background color, with background being a uniform color). Each
object must be analyzed for its centroid, calculated as the average of all its
pixel coordinates (rounded to the nearest integer). The output grid transforms
the input by horizontally shifting each object by the minimal number of cells
(considering cylindrical wrap-around) to align its centroid with the grid's
vertical midline (x = floor(width/2) or ceil(width/2)). After alignment, each
centroid is marked with a fixed color (e.g., yellow). Background cells remain
unchanged, object shapes and colors are preserved, and shifts are computed
independently for each object to avoid overlaps (ensured by input design). The
task demands precise centroid calculation, understanding of cylindrical grid
topology, and simultaneous multi-object alignment, with transformations
requiring non-intuitive minimal shifts due to wrap-around, making it
exceptionally challenging.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
from common import grid, randint, random_color, continuous_creature

def generate():
    # Try until a valid configuration is produced
    max_global_attempts = 200
    for global_attempt in range(max_global_attempts):
        W = randint(5, 20)
        H = randint(5, 20)
        bg = 0
        marker = 4
        used_colors = [bg, marker]
        input_grid = grid(W, H, bg)
        occupied_targets = set()  # positions (r,c) that will be occupied after shifting
        objects = []
        # number of objects: 2..min(5, W*H//10 + 2)
        max_objs = min(5, max(2, (W*H)//30 + 2))
        n_objects = randint(2, max_objs)
        success = True
        midline = W // 2
        for _ in range(n_objects):
            color = random_color(exclude=used_colors)
            placed = False
            # try many placements for this object
            for attempt in range(400):
                # sprite size for local creature generation
                sprite_w = randint(1, min(6, W))
                sprite_h = randint(1, min(6, H))
                max_pixels = sprite_w * sprite_h
                size = randint(1, min(max_pixels, 12))
                shape = continuous_creature(size, sprite_w, sprite_h)
                # choose top-left placement such that sprite fits
                r0 = randint(0, H - sprite_h)
                c0 = randint(0, W - sprite_w)
                pixels = [(r0 + dr, c0 + dc) for (dr, dc) in shape]
                # ensure no overlap in the input
                conflict = False
                for (r, c) in pixels:
                    if input_grid[r][c] != bg:
                        conflict = True
                        break
                if conflict:
                    continue
                # compute centroid (simple average of coordinates)
                xs = [c for (r, c) in pixels]
                ys = [r for (r, c) in pixels]
                centroid_x = round(sum(xs) / len(xs))
                centroid_y = round(sum(ys) / len(ys))
                # enforce that object is not already aligned
                if centroid_x == midline:
                    continue
                # compute minimal horizontal shift considering cylinder
                shift = (midline - centroid_x) % W
                if shift > W // 2:
                    shift -= W
                # compute target positions after shift
                targets = [(r, (c + shift) % W) for (r, c) in pixels]
                # ensure targets do not collide with previously reserved targets
                overlap = False
                for t in targets:
                    if t in occupied_targets:
                        overlap = True
                        break
                if overlap:
                    continue
                # place object
                for (r, c) in pixels:
                    input_grid[r][c] = color
                objects.append({
                    'color': color,
                    'pixels': pixels,
                    'centroid_x': centroid_x,
                    'centroid_y': centroid_y,
                    'shift': shift,
                    'targets': targets
                })
                # reserve targets
                for t in targets:
                    occupied_targets.add(t)
                used_colors.append(color)
                placed = True
                break
            if not placed:
                success = False
                break
        if not success or len(objects) < 2:
            # retry entire generation
            continue
        # build output grid by shifting each object horizontally
        output_grid = grid(W, H, bg)
        for obj in objects:
            color = obj['color']
            for (r, c) in obj['targets']:
                output_grid[r][c] = color
        # mark centroids on the midline with the marker color
        for obj in objects:
            cy = int(obj['centroid_y'])
            if cy < 0: cy = 0
            if cy >= H: cy = H - 1
            output_grid[cy][midline] = marker
        return {'input': input_grid, 'output': output_grid}
    # If we failed after many attempts, raise an error (should not happen)
    raise Exception("Failed to generate a valid grid")



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
from common import grid

def p(input_grid):
    # convert to mutable list-of-lists
    grid_in = [list(row) for row in input_grid]
    H = len(grid_in)
    W = len(grid_in[0])
    # detect background as most common color
    counts = {}
    for r in range(H):
        for c in range(W):
            val = grid_in[r][c]
            counts[val] = counts.get(val, 0) + 1
    background = max(counts, key=lambda k: counts[k])
    visited = [[False] * W for _ in range(H)]
    objects = []
    for r in range(H):
        for c in range(W):
            if visited[r][c] or grid_in[r][c] == background:
                continue
            color = grid_in[r][c]
            # BFS to collect connected component (horizontally cylindrical)
            queue = [(r, c)]
            visited[r][c] = True
            comp = []
            while queue:
                cr, cc = queue.pop(0)
                comp.append((cr, cc))
                # neighbors: up/down without wrapping, left/right with wrapping
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    if dc == 0:
                        nr = cr + dr
                        nc = cc
                        if nr < 0 or nr >= H:
                            continue
                    else:
                        nr = cr
                        nc = (cc + dc) % W
                    if not visited[nr][nc] and grid_in[nr][nc] == color:
                        visited[nr][nc] = True
                        queue.append((nr, nc))
            # compute centroid (average of coordinates, rounded)
            xs = [c for (r, c) in comp]
            ys = [r for (r, c) in comp]
            centroid_x = round(sum(xs) / len(xs))
            centroid_y = round(sum(ys) / len(ys))
            objects.append({
                'color': color,
                'pixels': comp,
                'centroid_x': centroid_x,
                'centroid_y': centroid_y
            })
    midline = W // 2
    marker = 4
    # build output filled with background color
    output = grid(W, H, background)
    # shift each object horizontally by minimal shift to align centroid_x to midline
    for obj in objects:
        color = obj['color']
        centroid_x = obj['centroid_x']
        shift = (midline - centroid_x) % W
        if shift > W // 2:
            shift -= W
        for (r, c) in obj['pixels']:
            new_c = (c + shift) % W
            output[r][new_c] = color
    # mark centroids on the midline
    for obj in objects:
        cy = int(obj['centroid_y'])
        if cy < 0: cy = 0
        if cy >= H: cy = H - 1
        output[cy][midline] = marker
    return output

