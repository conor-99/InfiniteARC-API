# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 72d00e1d
Difficulty: medium–hard

=== Tags ===
- Pattern cycle
- Cluster by shape

=== Description ===
Input grids consist of multiple connected clusters of colored cells (each
cluster is a single, contiguous region of uniform color, with background color
0), where each cluster exhibits a distinct geometric shape. Shapes are
considered identical if they can be rotated to match (e.g., a 3-cell L-shape
rotated 90° is the same shape as the original L-shape). Clusters of the same
shape must be grouped together in the output.  The transformation applies three
sequential operations: 1. **Shape Identification**: Each cluster's shape is
determined by its underlying geometric pattern (ignoring rotation), treating
rotated versions as equivalent. 2. **Grouping and Sorting**: Clusters are
grouped by shape and sorted within each group by their original top-left
coordinate position (from top to bottom, left to right). 3. **Cyclic Group
Shifting**: The sequence of shape groups is cyclically shifted (e.g., the first
group moves to the end of the list), while maintaining the sorted order within
each group.  The output grid rearranges all clusters into the new order (shape
groups in shifted sequence, clusters within groups sorted by original position),
placing each cluster at a new position without overlapping or altering its shape
or color. Background cells remain color 0, and all clusters from the input are
preserved in the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Helper: rotate 90 degrees about origin
def _rotate(coords):
    return [(c, -r) for r, c in coords]

# Canonicalize a set/list of coordinates up to rotation (0/90/180/270)
def canonicalize(coords):
    # coords: iterable of (r,c) pairs (can be absolute or relative)
    coords = list(coords)
    forms = []
    for k in range(4):
        rot = coords
        for _ in range(k):
            rot = [(c, -r) for r, c in rot]
        min_r = min(r for r, c in rot)
        min_c = min(c for r, c in rot)
        norm = tuple(sorted(((r - min_r, c - min_c) for r, c in rot)))
        forms.append(norm)
    return min(forms)

# Find connected components (4-neighbor) of non-zero cells; returns list of lists of (r,c)
def find_clusters(mat):
    height = len(mat)
    width = len(mat[0]) if height > 0 else 0
    visited = [[False] * width for _ in range(height)]
    clusters = []
    for r in range(height):
        for c in range(width):
            if mat[r][c] == 0 or visited[r][c]:
                continue
            color = mat[r][c]
            stack = [(r, c)]
            visited[r][c] = True
            comp = []
            while stack:
                cr, cc = stack.pop()
                comp.append((cr, cc))
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and mat[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            clusters.append(comp)
    return clusters


def generate():
    # Grid size chosen to be comfortably larger than shapes so packing succeeds easily
    width = random.randint(12, 20)
    height = random.randint(12, 20)
    # Some small shape templates (relative coordinates)
    SHAPES = [
        [(0, 0), (1, 0), (1, 1)],              # small L (3)
        [(0, 0), (1, 0), (2, 0)],              # I3 (3)
        [(0, 1), (1, 0), (1, 1), (1, 2)],      # T (4)
        [(0, 0), (0, 1), (1, 0), (1, 1)],      # O (2x2)
        [(0, 1), (0, 2), (1, 0), (1, 1)],      # S-like (4)
        [(0, 0), (1, 0), (2, 0), (2, 1)],      # longer L (4)
        [(0, 1), (1, 0), (1, 1), (1, 2), (2, 1)]  # plus-ish (5)
    ]

    # Try to place a reasonable number of clusters and ensure at least two distinct shapes
    num_clusters = random.randint(4, 7)
    # pick base shapes (can repeat)
    base_choices = [random.choice(SHAPES) for _ in range(num_clusters)]
    # ensure at least two different shapes chosen
    if len({tuple(sorted(s)) for s in base_choices}) < 2:
        while True:
            base_choices = [random.choice(SHAPES) for _ in range(num_clusters)]
            if len({tuple(sorted(s)) for s in base_choices}) >= 2:
                break

    # Empty input grid
    input_grid = grid(width, height, 0)
    placed = []  # list of placed clusters with metadata
    used_colors = set()

    for base in base_choices:
        # Random rotation
        k = random.randint(0, 3)
        coords = base
        for _ in range(k):
            coords = _rotate(coords)
        # normalize so rel coords start at 0,0
        min_r = min(r for r, c in coords)
        min_c = min(c for r, c in coords)
        rel = [(r - min_r, c - min_c) for r, c in coords]
        # compute dimensions
        ch = max(r for r, c in rel) + 1
        cw = max(c for r, c in rel) + 1
        # choose a color (try to avoid duplicates to make puzzles clearer)
        avail = [col for col in range(1, 10) if col not in used_colors]
        color = random.choice(avail) if avail else random.randint(1, 9)
        used_colors.add(color)

        # Find a placement that does not overlap or touch orthogonally existing clusters
        positions = [(r0, c0) for r0 in range(0, height - ch + 1) for c0 in range(0, width - cw + 1)]
        random.shuffle(positions)
        placed_ok = False
        for r0, c0 in positions:
            ok = True
            for dr, dc in rel:
                rr, cc = r0 + dr, c0 + dc
                if input_grid[rr][cc] != 0:
                    ok = False
                    break
                # ensure no orthogonal adjacency to existing non-zero
                for adr, adc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = rr + adr, cc + adc
                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0:
                        ok = False
                        break
                if not ok:
                    break
            if not ok:
                continue
            # place it
            abs_coords = []
            for dr, dc in rel:
                rr, cc = r0 + dr, c0 + dc
                input_grid[rr][cc] = color
                abs_coords.append((rr, cc))
            placed.append({'abs': abs_coords, 'rel': rel, 'color': color, 'min_r': r0, 'min_c': c0, 'w': cw, 'h': ch})
            placed_ok = True
            break
        if not placed_ok:
            # placement failed for this configuration; restart generation
            return generate()

    # Now build groups by scanning order (so solver and generator agree on group ordering)
    clusters = find_clusters(input_grid)
    groups = {}
    for comp in clusters:
        key = canonicalize(comp)
        if key not in groups:
            groups[key] = []
        col = input_grid[comp[0][0]][comp[0][1]]
        min_r = min(r for r, c in comp)
        min_c = min(c for r, c in comp)
        rel_comp = sorted(((r - min_r, c - min_c) for r, c in comp))
        w = max(c for r, c in rel_comp) + 1
        h = max(r for r, c in rel_comp) + 1
        groups[key].append({'color': col, 'rel': rel_comp, 'min_r': min_r, 'min_c': min_c, 'w': w, 'h': h})

    # sort clusters within each group by original top-left coordinate (top-to-bottom, left-to-right)
    for k in groups:
        groups[k].sort(key=lambda x: (x['min_r'], x['min_c']))

    # cyclic shift groups (first group moves to the end)
    group_list = list(groups.values())
    if len(group_list) > 1:
        group_list = group_list[1:] + group_list[:1]

    # pack groups (and their clusters in sorted order) into the output grid without overlap
    output_grid = grid(width, height, 0)
    cur_x = 0
    cur_y = 0
    row_h = 0
    for group in group_list:
        for cluster in group:
            cw = cluster['w']
            ch = cluster['h']
            if cur_x + cw > width:
                cur_x = 0
                cur_y += row_h
                row_h = 0
            if cur_y + ch > height:
                # packing failed for this grid; restart
                return generate()
            for r, c in cluster['rel']:
                output_grid[cur_y + r][cur_x + c] = cluster['color']
            cur_x += cw
            row_h = max(row_h, ch)

    # Ensure input != output (extremely unlikely to be equal, but if so restart)
    if input_grid == output_grid:
        return generate()

    return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input (tuple of tuples) to mutable list of lists
    mat = [list(row) for row in input_grid]
    height = len(mat)
    width = len(mat[0]) if height > 0 else 0

    # rotate 90deg about origin
    def _rotate(coords):
        return [(c, -r) for r, c in coords]

    def canonicalize(coords):
        coords = list(coords)
        forms = []
        for k in range(4):
            rot = coords
            for _ in range(k):
                rot = [(c, -r) for r, c in rot]
            min_r = min(r for r, c in rot)
            min_c = min(c for r, c in rot)
            norm = tuple(sorted(((r - min_r, c - min_c) for r, c in rot)))
            forms.append(norm)
        return min(forms)

    def find_clusters(mat):
        visited = [[False] * width for _ in range(height)]
        clusters = []
        for r in range(height):
            for c in range(width):
                if mat[r][c] == 0 or visited[r][c]:
                    continue
                color = mat[r][c]
                stack = [(r, c)]
                visited[r][c] = True
                comp = []
                while stack:
                    cr, cc = stack.pop()
                    comp.append((cr, cc))
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and mat[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                clusters.append(comp)
        return clusters

    clusters = find_clusters(mat)
    groups = {}
    for comp in clusters:
        key = canonicalize(comp)
        if key not in groups:
            groups[key] = []
        color = mat[comp[0][0]][comp[0][1]]
        min_r = min(r for r, c in comp)
        min_c = min(c for r, c in comp)
        rel = sorted(((r - min_r, c - min_c) for r, c in comp))
        w = max(c for r, c in rel) + 1
        h = max(r for r, c in rel) + 1
        groups[key].append({'color': color, 'rel': rel, 'min_r': min_r, 'min_c': min_c, 'w': w, 'h': h})

    # sort within groups by their original top-left coordinate
    for k in groups:
        groups[k].sort(key=lambda x: (x['min_r'], x['min_c']))

    # cyclic shift the sequence of groups
    group_list = list(groups.values())
    if len(group_list) > 1:
        group_list = group_list[1:] + group_list[:1]

    # pack into output grid
    output = [[0] * width for _ in range(height)]
    cur_x = 0
    cur_y = 0
    row_h = 0
    for group in group_list:
        for cluster in group:
            cw = cluster['w']
            ch = cluster['h']
            if cur_x + cw > width:
                cur_x = 0
                cur_y += row_h
                row_h = 0
            if cur_y + ch > height:
                # can't fit, skip this cluster (shouldn't occur given generator)
                continue
            for r, c in cluster['rel']:
                output[cur_y + r][cur_x + c] = cluster['color']
            cur_x += cw
            row_h = max(row_h, ch)

    return tuple(tuple(row) for row in output)

