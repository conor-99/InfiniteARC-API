# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 1485d0c8
Difficulty: easy

=== Tags ===
- Isolate largest component
- Simple tile repeat
- Associate images to patterns

=== Description ===
The task involves transforming an input grid into an output grid by identifying
the largest connected region (by area) of a single color and filling the entire
output grid with that color. The input grid contains multiple disconnected
regions of various colors, where a connected region consists of adjacent cells
(horizontally or vertically) sharing the same color. The largest region is
determined by counting the number of cells in each connected region; if multiple
regions have the same area, the one with the highest color value (0â€“9) is
chosen. The output grid is then filled entirely with the color of this largest
region, regardless of the input grid's original dimensions or structure. This
transformation relies on visual recognition of component size and color
association, without requiring numerical calculations or complex pattern
analysis.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    from common import grid
    w = random.randint(3, 8)
    h = random.randint(3, 8)
    input_grid = grid(w, h, 0)
    main_color = random.randint(1, 9)
    main_height = 3 if w >= 5 or h >= 5 else 2
    main_width = 3 if w >= 5 or h >= 5 else 2
    r0 = random.randint(0, h - main_height)
    c0 = random.randint(0, w - main_width)
    for r in range(r0, r0 + main_height):
        for c in range(c0, c0 + main_width):
            input_grid[r][c] = main_color
    colors = [c for c in range(1, 10) if c != main_color]
    color1 = color2 = colors[0]
    if len(colors) > 1:
        color1, color2 = random.sample(colors, 2)
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] == 0:
                input_grid[r][c] = color1 if (r + c) % 2 == 0 else color2
    output_grid = grid(w, h, main_color)
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid
def p(input_grid):
    h = len(input_grid)
    w = len(input_grid[0])
    visited = [[False] * w for _ in range(h)]
    largest_size = 0
    largest_color = -1
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    
    for r in range(h):
        for c in range(w):
            if not visited[r][c] and input_grid[r][c] != 0:
                color = input_grid[r][c]
                queue = [(r, c)]
                visited[r][c] = True
                size = 0
                while queue:
                    cr, cc = queue.pop(0)
                    size += 1
                    for dr, dc in directions:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                if size > largest_size or (size == largest_size and color > largest_color):
                    largest_size = size
                    largest_color = color
    if largest_color == -1:
        largest_color = 0
    return grid(w, h, largest_color)
