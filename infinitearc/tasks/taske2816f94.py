# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: e2816f94
Difficulty: hard

=== Tags ===
- Layered path system
- Boolean color logic
- Directed cave maze
- Energy field diffusion
- Bounce

=== Description ===
Input grids are large, complex mazes (20×20 or larger) with a single background
color (e.g., 0). The maze consists of interconnected path cells (background
color) and non-path wall cells (distinct non-background color). Scattered
throughout the maze are "bounce markers" — cells of colors 2, 3, and 4 — each
encoding a specific directional change when traversed: color 2 rotates the path
90° clockwise, color 3 rotates 90° counterclockwise, and color 4 reverses
direction (180°). A single energy source (color 5) is positioned at the bottom-
left corner, emitting a directed wave moving rightward along the path. The wave
propagates orthogonally through background path cells until encountering a
bounce marker, which alters its direction per the marker's color. Walls block
the wave, forcing it to follow marker-guided paths. The output grid depicts the
wave's trajectory as a continuous line using the source color (5), drawn
exclusively through path cells without overlapping itself or walls. Bounce
markers remain visible but are not overwritten. The path exits the grid through
any boundary, with no loops or self-intersections. "Boolean color logic" is
embedded in the markers' color-to-direction mappings, requiring solvers to infer
rules from visual patterns rather than numerical values. "Layered path system"
refers to the wave's path navigating multiple directional changes through the
maze structure, while "Directed cave maze" emphasizes the single-source, single-
path flow through the maze's geometry. "Energy field diffusion" describes the
wave's propagation through path cells, with "bounce" dictating directional
shifts at marker locations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque


def generate():
    # Try several attempts to build a satisfying maze
    for attempt in range(100):
        w = random.randint(20, 30)
        h = random.randint(20, 30)
        # Start with all walls (1)
        ingrid = [[1 for _ in range(w)] for _ in range(h)]
        start = (h - 1, 0)
        # Carve the start cell and force the first step to the right
        ingrid[start[0]][start[1]] = 0
        if w < 2:
            continue
        ingrid[h - 1][1] = 0
        path_cells = set()
        path_cells.add(start)
        path_cells.add((h - 1, 1))

        # Carve a connected region by repeatedly expanding from existing path cells
        min_area = max(int(0.25 * w * h), 40)
        max_area = max(int(0.5 * w * h), min_area + 5)
        target_cells = random.randint(min_area, max_area)
        tries = 0
        while len(path_cells) < target_cells and tries < target_cells * 10:
            tries += 1
            base = random.choice(tuple(path_cells))
            r0, c0 = base
            dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]
            random.shuffle(dirs)
            for dr, dc in dirs:
                nr, nc = r0 + dr, c0 + dc
                if 0 <= nr < h and 0 <= nc < w and (nr, nc) not in path_cells:
                    ingrid[nr][nc] = 0
                    path_cells.add((nr, nc))
                    break

        # Ensure there is at least one boundary cell (other than start) in the carved region
        boundary_candidates = [p for p in path_cells if (p[0] == 0 or p[0] == h - 1 or p[1] == 0 or p[1] == w - 1) and p != start]
        if not boundary_candidates:
            base = random.choice(tuple(path_cells))
            r0, c0 = base
            sides = []
            if r0 > 0:
                sides.append((-1, 0))
            if r0 < h - 1:
                sides.append((1, 0))
            if c0 > 0:
                sides.append((0, -1))
            if c0 < w - 1:
                sides.append((0, 1))
            if not sides:
                continue
            dr, dc = random.choice(sides)
            nr, nc = r0 + dr, c0 + dc
            while 0 <= nr < h and 0 <= nc < w:
                if (nr, nc) not in path_cells:
                    ingrid[nr][nc] = 0
                    path_cells.add((nr, nc))
                if nr == 0 or nr == h - 1 or nc == 0 or nc == w - 1:
                    break
                nr += dr
                nc += dc

            boundary_candidates = [p for p in path_cells if (p[0] == 0 or p[0] == h - 1 or p[1] == 0 or p[1] == w - 1) and p != start]
            if not boundary_candidates:
                continue

        exit_cell = random.choice(boundary_candidates)

        # Force first movement to the right by computing a path from the right neighbor
        start_neighbor = (h - 1, 1)
        if start_neighbor not in path_cells:
            continue

        parent = {start_neighbor: None}
        dq = deque([start_neighbor])
        found = False
        while dq:
            u = dq.popleft()
            if u == exit_cell:
                found = True
                break
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                v = (u[0] + dr, u[1] + dc)
                if v in path_cells and v not in parent:
                    parent[v] = u
                    dq.append(v)
        if not found:
            continue

        # Reconstruct the main path from start to exit (start + path from start_neighbor to exit)
        rev = []
        cur = exit_cell
        while cur is not None:
            rev.append(cur)
            cur = parent.get(cur)
        rev.reverse()  # sequence from start_neighbor to exit
        main_path = [start] + rev

        # If it's too short, do a bit more carving and retry this attempt
        if len(main_path) < 4:
            extra = 30
            for _ in range(extra):
                base = random.choice(tuple(path_cells))
                r0, c0 = base
                dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]
                random.shuffle(dirs)
                for dr, dc in dirs:
                    nr, nc = r0 + dr, c0 + dc
                    if 0 <= nr < h and 0 <= nc < w and (nr, nc) not in path_cells:
                        ingrid[nr][nc] = 0
                        path_cells.add((nr, nc))
                        break
            # recompute BFS
            parent = {start_neighbor: None}
            dq = deque([start_neighbor])
            found = False
            while dq:
                u = dq.popleft()
                if u == exit_cell:
                    found = True
                    break
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    v = (u[0] + dr, u[1] + dc)
                    if v in path_cells and v not in parent:
                        parent[v] = u
                        dq.append(v)
            if not found:
                continue
            rev = []
            cur = exit_cell
            while cur is not None:
                rev.append(cur)
                cur = parent.get(cur)
            rev.reverse()
            main_path = [start] + rev

        # Compute directions and count turns; we require at least one turn
        def delta(a, b):
            return (b[0] - a[0], b[1] - a[1])

        dirs_along = [delta(main_path[i], main_path[i + 1]) for i in range(len(main_path) - 1)]
        turns = sum(1 for i in range(1, len(dirs_along)) if dirs_along[i] != dirs_along[i - 1])
        if turns < 1:
            continue

        # Place bounce markers (2=clockwise, 3=counterclockwise, 4=reverse) at turning positions
        marker_positions = set()
        for i in range(1, len(main_path) - 1):
            db = dirs_along[i - 1]
            da = dirs_along[i]
            if db != da:
                r, c = main_path[i]
                # Determine which rotation maps db -> da
                if (db[1], -db[0]) == da:
                    color = 2
                elif (-db[1], db[0]) == da:
                    color = 3
                elif (-db[0], -db[1]) == da:
                    color = 4
                else:
                    # Fallback (shouldn't happen in orthogonal walk)
                    if (db[1], -db[0]) == da:
                        color = 2
                    elif (-db[1], db[0]) == da:
                        color = 3
                    else:
                        color = 4
                ingrid[r][c] = color
                marker_positions.add((r, c))

        # Add a few extra markers on other path cells (these won't affect the main path)
        other_path = list(path_cells - set(main_path))
        random.shuffle(other_path)
        extra_markers = random.randint(1, 4)
        for j in range(min(extra_markers, len(other_path))):
            r, c = other_path[j]
            ingrid[r][c] = random.choice([2, 3, 4])

        # Put the energy source at the start
        ingrid[start[0]][start[1]] = 5

        # Build the output: draw the wave (5) along main_path but do not overwrite markers
        outgrid = [row[:] for row in ingrid]
        for (r, c) in main_path:
            if outgrid[r][c] == 0:
                outgrid[r][c] = 5

        # Ensure the input and output differ
        if outgrid == ingrid:
            continue

        return {
            "input": ingrid,
            "output": outgrid
        }

    raise RuntimeError("Failed to generate a valid grid")



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert tuple-of-tuples to mutable list-of-lists
    grid_list = [list(row) for row in input_grid]
    h = len(grid_list)
    w = len(grid_list[0])

    # Find the source (prefer the bottom-left cell, otherwise any 5)
    start = None
    if grid_list[h - 1][0] == 5:
        start = (h - 1, 0)
    else:
        for r in range(h):
            for c in range(w):
                if grid_list[r][c] == 5:
                    start = (r, c)
                    break
            if start:
                break
    if start is None:
        return [row[:] for row in grid_list]

    r, c = start
    out = [row[:] for row in grid_list]

    # Initial direction is rightwards
    dr, dc = 0, 1
    out[r][c] = 5

    steps = 0
    max_steps = h * w * 10
    while True:
        cell_val = grid_list[r][c]
        # Apply bounce logic if we are on a marker
        if cell_val in (2, 3, 4):
            if cell_val == 2:
                dr, dc = dc, -dr
            elif cell_val == 3:
                dr, dc = -dc, dr
            else:  # cell_val == 4
                dr, dc = -dr, -dc

        nr, nc = r + dr, c + dc
        # Exit if we leave the grid
        if not (0 <= nr < h and 0 <= nc < w):
            break
        next_val = grid_list[nr][nc]
        # Stop if the next cell is a wall
        if next_val == 1:
            break
        # Mark the wave on ordinary path cells but do not overwrite markers
        if next_val == 0:
            out[nr][nc] = 5
        # Move forward
        r, c = nr, nc
        steps += 1
        if steps > max_steps:
            break

    return out

