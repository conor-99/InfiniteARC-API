# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 2e175220
Difficulty: medium–hard

=== Tags ===
- Area based reconstruction
- Energy loss per bounce
- Color modulated logic

=== Description ===
**Task Name: Dynamic Bounce Reconstruction**    **Description:**   Input grids
depict a cave-like environment with irregular wall structures (color 1) on a
uniform background (color 0). The grid contains one or more "energy sources" —
single cells of color 2 positioned along the left edge (never adjacent to walls)
and a horizontal "pattern strip" at the top-left corner, composed of repeating
2×2 color blocks (e.g., [3, 4, 5, 3, 4, 5...]). A "bounce indicator" (a 2×2
block of color 6) is embedded within a wall near the bottom-right.    The output
grid transforms the input by simulating energy-based path reconstruction:   1.
From each energy source, a path begins moving *rightward* through background
cells.   2. Upon hitting a wall (color 1), the path **bounces**, altering
direction (right → up → right → up, etc.) and **advancing to the next color in
the pattern strip** (e.g., 3 → 4 → 5 → 3).   3. Each segment of the path is
drawn in the current pattern color, **only on background cells** (never over
walls, pattern strips, or the bounce indicator).   4. The path continues until
it exits the grid (top or right edge), with the color cycling *per bounce*
(energy loss).   5. Energy sources are removed from the output (no longer
visible as single cells).    **Key Constraints:**   - Direction alternates
strictly after each bounce (e.g., first bounce: right → up; second: up → right).
- Path colors cycle through the pattern strip *in order*, repeating
indefinitely.   - Paths do not overlap, interact, or overwrite walls/patterns.
- The bounce indicator and pattern strip remain unchanged in the output.   -
Grids are large enough to ensure paths exit within a finite number of bounces
(no infinite loops).    **Visual Complexity:**   - Input grids feature
interconnected cave walls requiring careful path navigation.   - The pattern
strip’s color sequence must be interpreted to determine segment colors.   -
Energy loss (color progression) and direction alternation require sequential
reasoning.   - Multiple sources may exist, demanding parallel path
reconstruction.    This task demands **area-based spatial reasoning**
(navigating cave paths), **energy loss tracking** (color progression per
bounce), and **color-modulated logic** (pattern strip dictating path
appearance), aligning with the assigned difficulty and tags.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    # Try multiple times to produce a valid scene
    for attempt in range(200):
        width = random.randint(20, 30)
        height = random.randint(20, 30)
        grid = common.grid(width, height, 0)

        # Create a base repeating pattern (2x2 blocks) in the top-left corner.
        available = [c for c in range(3, 10) if c != 6]
        base_len = random.randint(2, min(4, len(available)))
        base_colors = random.sample(available, base_len)
        max_blocks = max(1, width // 2)
        num_blocks = random.randint(base_len, min(6, max_blocks))
        pattern = [base_colors[i % base_len] for i in range(num_blocks)]

        # Fill the 2x2 repeating blocks across the top two rows
        for i, colcol in enumerate(pattern):
            c0 = 2 * i
            if c0 + 1 >= width:
                break
            for r in (0, 1):
                for c in (c0, c0 + 1):
                    grid[r][c] = colcol

        # Generate cave-like walls using many short random walks; avoid the top two rows
        strokes = random.randint(40, 80)
        for _ in range(strokes):
            r = random.randint(2, height - 2)
            c = random.randint(1, width - 2)
            length = random.randint(6, max(6, (width + height) // 2))
            for _ in range(length):
                # place a wall pixel if we're not overwriting the pattern area
                if 2 <= r < height and 1 <= c < width and grid[r][c] == 0:
                    grid[r][c] = 1
                    # sometimes thicken the wall
                    if random.random() < 0.25:
                        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                            rr, cc = r + dr, c + dc
                            if 2 <= rr < height and 1 <= cc < width and grid[rr][cc] == 0 and random.random() < 0.35:
                                grid[rr][cc] = 1
                # walk step (stay inside the interior, avoid top two rows)
                dr, dc = random.choice([(1, 0), (-1, 0), (0, 1), (0, -1)])
                r = max(2, min(height - 1, r + dr))
                c = max(1, min(width - 1, c + dc))

        # Ensure there is a dense patch of walls near the bottom-right so we can embed the bounce indicator
        br_r0 = max(2, height - 6)
        br_c0 = max(1, width - 6)
        for rr in range(br_r0, height - 1):
            for cc in range(br_c0, width - 1):
                if random.random() < 0.6:
                    grid[rr][cc] = 1

        # Place a 2x2 bounce indicator of color 6 inside a wall region near bottom-right
        candidates = []
        for rr in range(height - 4, height - 1):
            for cc in range(width - 4, width - 1):
                if rr >= 2 and cc >= 1:
                    if grid[rr][cc] == 1 and grid[rr][cc + 1] == 1 and grid[rr + 1][cc] == 1 and grid[rr + 1][cc + 1] == 1:
                        candidates.append((rr, cc))
        if not candidates:
            # Force a 2x2 wall block if none was naturally created
            rr = height - 3
            cc = width - 3
            grid[rr][cc] = grid[rr][cc + 1] = grid[rr + 1][cc] = grid[rr + 1][cc + 1] = 1
            candidates.append((rr, cc))
        br_r, br_c = random.choice(candidates)
        grid[br_r][br_c] = grid[br_r][br_c + 1] = grid[br_r + 1][br_c] = grid[br_r + 1][br_c + 1] = 6

        # Helper: simulate a single source path using the rules. Returns (ok, path_list)
        def simulate_path(start_row, reserved):
            h = height
            w = width
            x, y = start_row, 0
            dr, dc = 0, 1  # start moving right
            color_idx = 0
            path = []
            steps = 0
            max_steps = w * h * 3
            while True:
                nx = x + dr
                ny = y + dc
                # Exits the grid through top or right
                if ny >= w or nx < 0:
                    return True, path
                # If next cell is a wall -> bounce
                if grid[nx][ny] == 1:
                    # flip direction: right <-> up
                    if (dr, dc) == (0, 1):
                        dr, dc = -1, 0
                    else:
                        dr, dc = 0, 1
                    # advance pattern color
                    color_idx = (color_idx + 1) % len(pattern)
                    nx = x + dr
                    ny = y + dc
                    if ny >= w or nx < 0:
                        return True, path
                    # after bounce the target cell must be background and not reserved
                    if not (0 <= nx < h and 0 <= ny < w):
                        return False, None
                    if grid[nx][ny] != 0:
                        return False, None
                    if (nx, ny) in reserved:
                        return False, None
                    path.append((nx, ny, pattern[color_idx]))
                    x, y = nx, ny
                elif grid[nx][ny] == 0:
                    # normal advance
                    if (nx, ny) in reserved:
                        return False, None
                    path.append((nx, ny, pattern[color_idx]))
                    x, y = nx, ny
                else:
                    # encountered something unexpected (pattern, bounce indicator, source) -- invalid
                    return False, None
                steps += 1
                if steps > max_steps:
                    return False, None

        # Choose candidate rows for sources (left edge), avoid top two rows where the pattern lives
        candidate_rows = [r for r in range(2, height) if grid[r][0] == 0 and grid[r][1] == 0 and (r == 0 or grid[r - 1][0] != 1) and (r == height - 1 or grid[r + 1][0] != 1)]
        random.shuffle(candidate_rows)

        desired_sources = random.randint(1, 3)
        sources = []
        reserved = set()
        source_paths = []

        for r in candidate_rows:
            if len(sources) >= desired_sources:
                break
            # Temporarily place a source marker to reflect input state
            grid[r][0] = 2
            ok, path = simulate_path(r, reserved)
            if ok and path is not None and len(path) > 0:
                # add this source and reserve its path cells (but do not overwrite grid yet)
                conflict = False
                for (x, y, _) in path:
                    if (x, y) in reserved:
                        conflict = True
                        break
                if not conflict:
                    sources.append(r)
                    source_paths.append((r, path))
                    for (x, y, _) in path:
                        reserved.add((x, y))
                else:
                    # remove the temporary source marker
                    grid[r][0] = 0
            else:
                grid[r][0] = 0

        # Ensure we found at least one valid source and path
        if not sources:
            # clean up any changed pattern or walls and try again
            continue

        # Build final output by drawing the paths but leaving pattern and bounce indicator intact
        output = [row[:] for row in grid]
        for r in sources:
            output[r][0] = 0  # sources are removed in output
        for (_r, path) in source_paths:
            for (x, y, col) in path:
                # safety check (never overwrite walls, pattern, or bounce indicator)
                if output[x][y] == 0:
                    output[x][y] = col
        # Sanity: ensure input and output are different
        if output != grid:
            return {"input": grid, "output": output}
    # If we exhaust attempts raise an error (shouldn't happen)
    raise RuntimeError('Could not generate a valid grid after many attempts')



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Detect the repeating 2x2 pattern along the top-left corner.
    pattern = []
    c = 0
    while c + 1 < width and grid[0][c] != 0 and grid[1][c] == grid[0][c] and grid[0][c + 1] == grid[0][c] and grid[1][c + 1] == grid[0][c]:
        pattern.append(grid[0][c])
        c += 2
    if not pattern:
        # Fallback: collect any non-zero colors on top row (defensive)
        c = 0
        while c < width and grid[0][c] != 0:
            pattern.append(grid[0][c])
            c += 1
    # Identify energy sources (color 2) on the left edge
    sources = [r for r in range(height) if grid[r][0] == 2]

    # Prepare output starting from the input; sources will be removed
    output = [row[:] for row in grid]
    for r in sources:
        output[r][0] = 0

    reserved = set()
    assignments = {}

    # Helper to simulate one source's path using the same rules as the generator
    def simulate(start_row):
        x, y = start_row, 0
        dr, dc = 0, 1
        color_idx = 0
        path = []
        steps = 0
        max_steps = width * height * 3
        while True:
            nx = x + dr
            ny = y + dc
            # Exit if moving out of the grid upwards or rightwards
            if ny >= width or nx < 0:
                return True, path
            # Bounce on walls (color 1)
            if grid[nx][ny] == 1:
                if (dr, dc) == (0, 1):
                    dr, dc = -1, 0
                else:
                    dr, dc = 0, 1
                color_idx = (color_idx + 1) % len(pattern)
                nx = x + dr
                ny = y + dc
                if ny >= width or nx < 0:
                    return True, path
                if not (0 <= nx < height and 0 <= ny < width):
                    return False, None
                if grid[nx][ny] != 0:
                    return False, None
                if (nx, ny) in reserved:
                    return False, None
                path.append((nx, ny, pattern[color_idx]))
                x, y = nx, ny
            elif grid[nx][ny] == 0:
                if (nx, ny) in reserved:
                    return False, None
                path.append((nx, ny, pattern[color_idx]))
                x, y = nx, ny
            else:
                # ran into pattern, bounce indicator, or another non-background unexpected cell
                return False, None
            steps += 1
            if steps > max_steps:
                return False, None

    # Simulate each source independently; order of simulation is the top-to-bottom order of sources
    for r in sources:
        ok, path = simulate(r)
        if not ok or path is None:
            # If a path cannot be simulated, leave grid unchanged for that source (defensive)
            continue
        for (x, y, col) in path:
            # Do not overwrite walls, pattern, or the bounce indicator
            if output[x][y] == 0:
                output[x][y] = col
            reserved.add((x, y))

    return output

