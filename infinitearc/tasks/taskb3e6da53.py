# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: b3e6da53
Difficulty: hard

=== Tags ===
- Maze

=== Description ===
The task involves transforming a maze grid where 0 represents traversable path
and non-zero values represent walls (using a consistent single wall color, such
as 1). The output grid removes all dead-end path segments by converting each
dead-end path cell (a path cell with exactly one adjacent path cell in the four
cardinal directions) into a wall using the same wall color. The input maze is
designed with complex, multi-layered dead ends branching off a primary path,
requiring the solver to comprehensively identify and eliminate all such
endpoints while preserving the structural integrity of the main path. The
transformation relies purely on spatial connectivity rules rather than numerical
values, ensuring the solution is discoverable through visual pattern recognition
of path topology.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    grid = common.grid(width, height, 1)
    for r in range(height):
        for c in range(width):
            if r == 0 or r == height-1 or c == 0 or c == width-1:
                grid[r][c] = 0
    num_dead_ends = random.randint(5, 10)
    for _ in range(num_dead_ends):
        r, c = random.randint(0, height-1), random.randint(0, width-1)
        while not (r == 0 or r == height-1 or c == 0 or c == width-1):
            r, c = random.randint(0, height-1), random.randint(0, width-1)
        if r == 0:
            r_new, c_new = 1, c
        elif r == height-1:
            r_new, c_new = height-2, c
        elif c == 0:
            r_new, c_new = r, 1
        else:
            r_new, c_new = r, width-2
        if 0 <= r_new < height and 0 <= c_new < width and grid[r_new][c_new] == 1:
            grid[r_new][c_new] = 0
    output = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if output[r][c] == 0:
                neighbors = 0
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and output[nr][nc] == 0:
                        neighbors += 1
                if neighbors == 1:
                    output[r][c] = 1
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    output = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width):
            if output[r][c] == 0:
                neighbors = 0
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and output[nr][nc] == 0:
                        neighbors += 1
                if neighbors == 1:
                    output[r][c] = 1
    return output
