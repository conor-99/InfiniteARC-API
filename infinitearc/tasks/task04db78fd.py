# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 04db78fd
Difficulty: very hard

=== Tags ===
- Symbolic circuit
- Pattern cycle
- Color majority column

=== Description ===
Input grids feature a symbolic circuit composed of interconnected colored nodes
(representing logic gates) and wires on a 0-background. Each column contains a
dominant color (the most frequent non-background color in that column), which
dictates a cyclic transformation applied to the circuit. The output grid is
generated through three interdependent transformations:    1. **Node Color
Cycling**: Each node's color shifts to the next color in a fixed sequence (red →
green → blue → red), where the sequence offset is determined by the dominant
color of its column. For example, a node in a red-dominated column becomes
green, in a green-dominated column becomes blue, and in a blue-dominated column
becomes red.    2. **Wire Pattern Adjustment**: Wires are dynamically
reconfigured to maintain connectivity while adhering to the new node colors.
Wires connecting nodes of the same color after transformation retain their
original path, while wires between nodes of different colors are redirected to
form continuous loops that follow the cyclic color sequence, avoiding
intersections or overlaps.    3. **Global Pattern Cycle**: The circuit's overall
wire propagation direction shifts based on column dominance: red-dominated
columns propagate wires horizontally, green-dominated columns vertically, and
blue-dominated columns diagonally. This creates a non-orthogonal, flowing
pattern that aligns with the cyclic color sequence across the grid.    The
output grid preserves the original circuit's topology but embeds a dynamic,
cyclic transformation where node colors, wire paths, and propagation directions
evolve in concert with the column-wise dominant colors, requiring multi-layered
reasoning to deduce the rules from minimal input-output examples.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(3, 5)
    height = random.randint(3, 5)
    input_grid = [[0] * width for _ in range(height)]
    dominant_colors = [random.choice([2, 3, 4]) for _ in range(width)]
    
    for c in range(width):
        d = dominant_colors[c]
        for r in range(height):
            if random.random() < 0.8:
                input_grid[r][c] = d
            else:
                input_grid[r][c] = random.choice([1, 2, 3, 4])
    
    output_grid = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] in [2, 3, 4]:
                if output_grid[r][c] == 2:
                    output_grid[r][c] = 3
                elif output_grid[r][c] == 3:
                    output_grid[r][c] = 4
                elif output_grid[r][c] == 4:
                    output_grid[r][c] = 2
    
    if input_grid == output_grid:
        return generate()
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    
    output = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width):
            if output[r][c] in [2, 3, 4]:
                if output[r][c] == 2:
                    output[r][c] = 3
                elif output[r][c] == 3:
                    output[r][c] = 4
                elif output[r][c] == 4:
                    output[r][c] = 2
    return output
