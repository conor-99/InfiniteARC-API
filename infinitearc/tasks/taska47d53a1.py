# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: a47d53a1
Difficulty: hard

=== Tags ===
- Adaptive behavior switch
- Rule priority resolution
- Multi agent path weaving

=== Description ===
Input grids are 20×20 with a uniform background color (0). Overlaid are multiple
agents represented as single cells of distinct colors (1–9), each occupying a
unique cell. Agents move according to color-encoded direction rules: color 1 =
right, 2 = down, 3 = left, 4 = up. However, if an agent is horizontally or
vertically adjacent to a cell of a higher color, it switches to the direction
associated with that higher color (e.g., adjacent to color 7, which maps to
down, agent moves down), resolving conflicts via priority (higher color
overrides lower). When two agents' intended movement paths intersect (i.e.,
would occupy the same cell), they "weave" by having the higher-priority agent
continue straight while the lower-priority agent turns 90 degrees perpendicular
to its original direction (e.g., if moving right, turns up or down based on
spatial context). The output grid displays agents in their new positions after
one step, with all other cells remaining background. Background cells never
change, and all collisions are resolved through adaptive priority-based weaving,
requiring the solver to identify direction rules, resolve adjacency conflicts,
and apply multi-agent path adjustments simultaneously. Grids include 6–10 agents
with complex collision patterns, overlapping priority zones, and non-trivial
weaving sequences to ensure difficulty.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width, height = 20, 20
    grid_input = grid(width, height, 0)
    num_agents = random.randint(6, 9)
    colors = random.sample(range(1, 10), num_agents)
    positions = []
    while len(positions) < num_agents:
        r, c = random.randint(0, height-1), random.randint(0, width-1)
        if (r, c) not in positions:
            positions.append((r, c))
            grid_input[r][c] = colors[len(positions)-1]
    
    directions_map = {
        1: (0, 1),
        2: (1, 0),
        3: (0, -1),
        4: (-1, 0)
    }
    agents = []
    for (r, c), color in zip(positions, colors):
        max_neighbor = 0
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r+dr, c+dc
            if 0 <= nr < height and 0 <= nc < width:
                neighbor_color = grid_input[nr][nc]
                if neighbor_color > color and neighbor_color > max_neighbor:
                    max_neighbor = neighbor_color
        if max_neighbor > 0:
            dir_val = ((max_neighbor - 1) % 4) + 1
        else:
            dir_val = ((color - 1) % 4) + 1
        dr, dc = directions_map[dir_val]
        nr, nc = r + dr, c + dc
        agents.append((r, c, color, dir_val, nr, nc))
    
    target_groups = {}
    for (r, c, color, dir_val, nr, nc) in agents:
        target = (nr, nc)
        if target not in target_groups:
            target_groups[target] = []
        target_groups[target].append((color, dir_val, r, c))
    
    new_positions = {}
    for target, agents_list in target_groups.items():
        if len(agents_list) == 1:
            color, _, _, _ = agents_list[0]
            new_positions[target] = color
        else:
            agents_list.sort(key=lambda x: x[0], reverse=True)
            new_positions[target] = agents_list[0][0]
            for i in range(1, len(agents_list)):
                color, dir_val, r, c = agents_list[i]
                new_dir_val = ((dir_val - 2) % 4) + 1
                dr, dc = directions_map[new_dir_val]
                nr_new = r + dr
                nc_new = c + dc
                new_target = (nr_new, nc_new)
                new_positions[new_target] = color
    
    grid_output = grid(width, height, 0)
    for (r, c), color in new_positions.items():
        if 0 <= r < height and 0 <= c < width:
            grid_output[r][c] = color
    
    return {
        "input": grid_input,
        "output": grid_output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    current_grid = [list(row) for row in input_grid]
    height = len(current_grid)
    width = len(current_grid[0])
    
    directions_map = {
        1: (0, 1),
        2: (1, 0),
        3: (0, -1),
        4: (-1, 0)
    }
    agents = []
    for r in range(height):
        for c in range(width):
            if current_grid[r][c] > 0:
                agents.append((r, c, current_grid[r][c]))
    
    if not agents:
        return current_grid
    
    agents_with_dir = []
    for (r, c, color) in agents:
        max_neighbor = 0
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r+dr, c+dc
            if 0 <= nr < height and 0 <= nc < width:
                neighbor_color = current_grid[nr][nc]
                if neighbor_color > color and neighbor_color > max_neighbor:
                    max_neighbor = neighbor_color
        if max_neighbor > 0:
            dir_val = ((max_neighbor - 1) % 4) + 1
        else:
            dir_val = ((color - 1) % 4) + 1
        dr, dc = directions_map[dir_val]
        nr, nc = r + dr, c + dc
        agents_with_dir.append((r, c, color, dir_val, nr, nc))
    
    target_groups = {}
    for (r, c, color, dir_val, nr, nc) in agents_with_dir:
        target = (nr, nc)
        if target not in target_groups:
            target_groups[target] = []
        target_groups[target].append((color, dir_val, r, c))
    
    new_positions = {}
    for target, agents_list in target_groups.items():
        if len(agents_list) == 1:
            color, _, _, _ = agents_list[0]
            new_positions[target] = color
        else:
            agents_list.sort(key=lambda x: x[0], reverse=True)
            new_positions[target] = agents_list[0][0]
            for i in range(1, len(agents_list)):
                color, dir_val, r, c = agents_list[i]
                new_dir_val = ((dir_val - 2) % 4) + 1
                dr, dc = directions_map[new_dir_val]
                nr_new = r + dr
                nc_new = c + dc
                new_target = (nr_new, nc_new)
                new_positions[new_target] = color
    
    output_grid = grid(width, height, 0)
    for (r, c), color in new_positions.items():
        if 0 <= r < height and 0 <= c < width:
            output_grid[r][c] = color
    
    return output_grid
