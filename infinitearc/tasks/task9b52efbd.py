# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 9b52efbd
Difficulty: medium–hard

=== Tags ===
- Interleaved streams
- Coordinate warp
- Hollow core detection
- Impact highlight

=== Description ===
Input grids feature multiple hollow core structures—closed loops of a single
non-background color (e.g., color 3) surrounding entirely empty inner regions
(background color 0)—alongside two interleaved streams: horizontal streams
(color 1) moving left-right and vertical streams (color 2) moving top-bottom.
The streams are never overlapping and traverse the grid without intersecting the
hollow core loops.    The transformation applies a coordinate warp to the
streams: horizontal streams (color 1) shift vertically by their row index (i.e.,
a cell at (r, c) moves to (r, c + r)), while vertical streams (color 2) shift
horizontally by their column index (i.e., a cell at (r, c) moves to (r + c, c)).
After warping, the streams are extended along their new paths. The output grid
retains the original hollow core loops and stream paths but highlights any
hollow core whose inner region (previously background) is intersected by the
warped stream by changing its inner cells to color 4. Hollow cores must be fully
enclosed (surrounded by a single-color loop with no gaps) to qualify for
detection. The transformation requires sequential application of core detection,
warp rule application, and intersection checking.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Grid size
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    input_grid = grid(width, height, 0)

    # Helper: check if two rectangles (top,left,h,w) touch or overlap with a margin
    def rects_touch(a, b, margin=1):
        at, al, ah, aw = a
        bt, bl, bh, bw = b
        a_top, a_bottom = at, at + ah - 1
        a_left, a_right = al, al + aw - 1
        b_top, b_bottom = bt, bt + bh - 1
        b_left, b_right = bl, bl + bw - 1
        # No touch if one is strictly to one side of the other with margin
        if a_right + margin < b_left: return False
        if b_right + margin < a_left: return False
        if a_bottom + margin < b_top: return False
        if b_bottom + margin < a_top: return False
        return True

    # Place several non-overlapping rectangular hollow cores (borders only)
    hollow_cores = []
    num_hollow = random.randint(2, 4)
    tries = 0
    while len(hollow_cores) < num_hollow and tries < 500:
        tries += 1
        # dimensions at least 3x3 so there is an interior
        max_h = min(8, height - 3)
        max_w = min(8, width - 3)
        if max_h < 3 or max_w < 3:
            break
        h = random.randint(3, max_h)
        w = random.randint(3, max_w)
        top = random.randint(1, height - h - 1)
        left = random.randint(1, width - w - 1)
        candidate = (top, left, h, w)
        # ensure it doesn't touch or overlap existing cores
        conflict = False
        for other in hollow_cores:
            if rects_touch(candidate, other, margin=1):
                conflict = True
                break
        if conflict:
            continue
        # Draw border
        for r in range(top, top + h):
            for c in range(left, left + w):
                if r == top or r == top + h - 1 or c == left or c == left + w - 1:
                    input_grid[r][c] = 3
        hollow_cores.append(candidate)

    # Ensure we placed at least two hollow cores; if not, relax and try again with looser constraints
    if len(hollow_cores) < 2:
        # Clear and place a minimal guaranteed configuration
        input_grid = grid(width, height, 0)
        hollow_cores = []
        # place two small non-touching cores deterministically
        possible_positions = []
        for top in range(1, height - 2):
            for left in range(1, width - 2):
                possible_positions.append((top, left))
        random.shuffle(possible_positions)
        for (top, left) in possible_positions[:2]:
            h, w = 3, 3
            # make sure they don't overlap with existing
            candidate = (top, left, h, w)
            ok = True
            for other in hollow_cores:
                if rects_touch(candidate, other, margin=1):
                    ok = False
                    break
            if not ok:
                continue
            for r in range(top, top + h):
                for c in range(left, left + w):
                    if r == top or r == top + h - 1 or c == left or c == left + w - 1:
                        input_grid[r][c] = 3
            hollow_cores.append(candidate)
            if len(hollow_cores) >= 2:
                break

    # Record rows and cols that are occupied by any hollow core (including border rows/cols)
    occupied_rows = set()
    occupied_cols = set()
    for (top, left, h, w) in hollow_cores:
        for r in range(top, top + h):
            occupied_rows.add(r)
        for c in range(left, left + w):
            occupied_cols.add(c)

    # Place horizontal streams (color 1) as contiguous segments on rows not touching cores
    horizontal_rows = []
    horizontal_cells = set()
    candidate_rows = [r for r in range(1, height) if r not in occupied_rows]
    random.shuffle(candidate_rows)
    num_hstreams = random.randint(1, min(3, max(1, len(candidate_rows))))
    for r in candidate_rows[:num_hstreams]:
        max_len = min(7, width - 1)
        length = random.randint(2, max_len)
        start = random.randint(0, width - length)
        # place contiguous segment, guaranteed to not touch cores because row not in occupied_rows
        for c in range(start, start + length):
            input_grid[r][c] = 1
            horizontal_cells.add((r, c))
        horizontal_rows.append((r, start, length))

    # Place vertical streams (color 2) as contiguous segments on columns not touching cores
    vertical_cols = []
    vertical_cells = set()
    # avoid columns that are part of horizontal cells to prevent initial overlap
    used_cols = set(c for (_, c) in horizontal_cells)
    candidate_cols = [c for c in range(1, width) if c not in occupied_cols and c not in used_cols]
    random.shuffle(candidate_cols)
    if candidate_cols:
        num_vstreams = random.randint(1, min(3, len(candidate_cols)))
        for c in candidate_cols[:num_vstreams]:
            max_len = min(7, height - 1)
            length = random.randint(2, max_len)
            start = random.randint(0, height - length)
            # ensure no overlap with existing horizontal cells
            conflict = False
            for r in range(start, start + length):
                if (r, c) in horizontal_cells:
                    conflict = True
                    break
            if conflict:
                # try to shift start to avoid overlap
                placed = False
                for try_start in range(0, height - length + 1):
                    conflict = False
                    for r in range(try_start, try_start + length):
                        if (r, c) in horizontal_cells:
                            conflict = True
                            break
                    if not conflict:
                        start = try_start
                        placed = True
                        break
                if not placed:
                    continue
            for r in range(start, start + length):
                input_grid[r][c] = 2
                vertical_cells.add((r, c))
            vertical_cols.append((c, start, length))

    # Ensure at least one stream exists (should be true, but double-check)
    if not horizontal_rows and not vertical_cols:
        # place a short horizontal stream on row 1
        r = 1
        start = 0
        length = 2
        for c in range(start, start + length):
            input_grid[r][c] = 1
            horizontal_cells.add((r, c))
        horizontal_rows.append((r, start, length))

    # Now compute warped (extended) stream paths
    warped_h = set()
    # For each horizontal stream, map each original cell (r,c) to (r, c + r), collect valid mapped columns,
    # then extend to a continuous segment between min and max mapped columns.
    rows_with_h = {}
    for (r, start, length) in horizontal_rows:
        cols = [c for c in range(start, start + length)]
        mapped = [c + r for c in cols if 0 <= c + r < width]
        if not mapped:
            continue
        mn, mx = min(mapped), max(mapped)
        for c2 in range(mn, mx + 1):
            warped_h.add((r, c2))
        rows_with_h[r] = (mn, mx)

    warped_v = set()
    cols_with_v = {}
    for (c, start, length) in vertical_cols:
        rows = [r for r in range(start, start + length)]
        mapped = [r + c for r in rows if 0 <= r + c < height]
        if not mapped:
            continue
        mn, mx = min(mapped), max(mapped)
        for r2 in range(mn, mx + 1):
            warped_v.add((r2, c))
        cols_with_v[c] = (mn, mx)

    # Build output grid: copy borders, then draw warped streams (vertical overrides horizontal),
    # then highlight inner regions intersected by any warped stream point.
    output_grid = grid(width, height, 0)
    for (top, left, h, w) in hollow_cores:
        for r in range(top, top + h):
            for c in range(left, left + w):
                if r == top or r == top + h - 1 or c == left or c == left + w - 1:
                    output_grid[r][c] = 3

    # draw horizontal warped paths first, but never overwrite border (3)
    for (r, c) in warped_h:
        if output_grid[r][c] == 0:
            output_grid[r][c] = 1
    # draw vertical warped paths, overwrite horizontal but not border
    for (r, c) in warped_v:
        if output_grid[r][c] != 3:
            output_grid[r][c] = 2

    # Highlight hollow core inner regions if intersected by any warped stream point
    for (top, left, h, w) in hollow_cores:
        inner_top = top + 1
        inner_left = left + 1
        inner_bottom = top + h - 1
        inner_right = left + w - 1
        intersected = False
        for (r, c) in list(warped_h) + list(warped_v):
            if inner_top <= r < inner_bottom and inner_left <= c < inner_right:
                intersected = True
                break
        if intersected:
            for r in range(inner_top, inner_bottom):
                for c in range(inner_left, inner_right):
                    output_grid[r][c] = 4

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0]) if height > 0 else 0

    # Find all connected components of color 3 (4-connected)
    visited = [[False] * width for _ in range(height)]
    comps = []
    for r in range(height):
        for c in range(width):
            if grid_in[r][c] != 3 or visited[r][c]:
                continue
            # BFS/DFS to collect component
            stack = [(r, c)]
            comp = []
            while stack:
                rr, cc = stack.pop()
                if visited[rr][cc]:
                    continue
                if grid_in[rr][cc] != 3:
                    continue
                visited[rr][cc] = True
                comp.append((rr, cc))
                for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid_in[nr][nc] == 3:
                        stack.append((nr, nc))
            if comp:
                comps.append(comp)

    # From components, infer rectangular hollow cores: bounding box border must be exactly the component
    hollow_cores = []
    for comp in comps:
        rs = [p[0] for p in comp]
        cs = [p[1] for p in comp]
        top, bottom = min(rs), max(rs)
        left, right = min(cs), max(cs)
        h = bottom - top + 1
        w = right - left + 1
        # size of a perfect rectangular border
        expected_border_size = 2 * (h + w) - 4
        if len(comp) != expected_border_size:
            continue
        # check that every border cell is 3
        ok = True
        for rr in range(top, top + h):
            for cc in range(left, left + w):
                if rr == top or rr == top + h - 1 or cc == left or cc == left + w - 1:
                    if grid_in[rr][cc] != 3:
                        ok = False
                        break
                else:
                    # interior should be background (0) for a hollow core
                    if grid_in[rr][cc] != 0:
                        ok = False
                        break
            if not ok:
                break
        if ok and h >= 3 and w >= 3:
            hollow_cores.append((top, left, h, w))

    # Identify original horizontal and vertical stream segments
    horizontal_rows = []  # list of (r, start_col, length)
    for r in range(height):
        cols = [c for c in range(width) if grid_in[r][c] == 1]
        if not cols:
            continue
        # find contiguous runs
        cols.sort()
        run_start = cols[0]
        run_prev = cols[0]
        for c in cols[1:]:
            if c == run_prev + 1:
                run_prev = c
                continue
            horizontal_rows.append((r, run_start, run_prev - run_start + 1))
            run_start = c
            run_prev = c
        horizontal_rows.append((r, run_start, run_prev - run_start + 1))

    vertical_cols = []  # list of (c, start_row, length)
    for c in range(width):
        rows = [r for r in range(height) if grid_in[r][c] == 2]
        if not rows:
            continue
        rows.sort()
        run_start = rows[0]
        run_prev = rows[0]
        for r in rows[1:]:
            if r == run_prev + 1:
                run_prev = r
                continue
            vertical_cols.append((c, run_start, run_prev - run_start + 1))
            run_start = r
            run_prev = r
        vertical_cols.append((c, run_start, run_prev - run_start + 1))

    # Compute warped (extended) paths using same logic as generator
    warped_h = set()
    for (r, start, length) in horizontal_rows:
        cols = [c for c in range(start, start + length)]
        mapped = [c + r for c in cols if 0 <= c + r < width]
        if not mapped:
            continue
        mn, mx = min(mapped), max(mapped)
        for c2 in range(mn, mx + 1):
            warped_h.add((r, c2))

    warped_v = set()
    for (c, start, length) in vertical_cols:
        rows = [r for r in range(start, start + length)]
        mapped = [r + c for r in rows if 0 <= r + c < height]
        if not mapped:
            continue
        mn, mx = min(mapped), max(mapped)
        for r2 in range(mn, mx + 1):
            warped_v.add((r2, c))

    # Build output: copy borders, then horizontals (if not border), then verticals (overwrite horizontals but not border)
    output = [[0] * width for _ in range(height)]
    for (top, left, h, w) in hollow_cores:
        for rr in range(top, top + h):
            for cc in range(left, left + w):
                if rr == top or rr == top + h - 1 or cc == left or cc == left + w - 1:
                    output[rr][cc] = 3

    for (r, c) in warped_h:
        if output[r][c] == 0:
            output[r][c] = 1
    for (r, c) in warped_v:
        if output[r][c] != 3:
            output[r][c] = 2

    # Highlight inner regions intersected by any warped stream point
    for (top, left, h, w) in hollow_cores:
        inner_top = top + 1
        inner_left = left + 1
        inner_bottom = top + h - 1
        inner_right = left + w - 1
        intersected = False
        for (r, c) in list(warped_h) + list(warped_v):
            if inner_top <= r < inner_bottom and inner_left <= c < inner_right:
                intersected = True
                break
        if intersected:
            for rr in range(inner_top, inner_bottom):
                for cc in range(inner_left, inner_right):
                    output[rr][cc] = 4

    return output

