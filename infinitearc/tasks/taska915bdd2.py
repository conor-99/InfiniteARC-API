# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: a915bdd2
Difficulty: insane

=== Tags ===
- Pattern repetition
- Associate images to images

=== Description ===
The input grid contains a repeating pattern that tiles the entire grid (e.g., a
2×2 block that repeats without overlap). The output grid is constructed by
replicating this primary pattern in a square grid of size N×N, where N is the
count of a designated color (e.g., color 5) in the input. Each copy of the
pattern in the output is rotated 90 degrees counterclockwise if the count of a
secondary designated color (e.g., color 7) in the input is odd, otherwise
rotated 90 degrees clockwise. The primary pattern is defined as the smallest
contiguous block that can tile the input grid without gaps or overlaps,
requiring recognition of the underlying periodic structure before applying the
replication and rotation rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    pattern_w = random.randint(2, 5)
    pattern_h = random.randint(2, 5)
    while True:
        pattern = [[random.randint(1, 9) for _ in range(pattern_w)] for _ in range(pattern_h)]
        if 5 in [x for row in pattern for x in row] and 7 in [x for row in pattern for x in row]:
            break
    pattern_5_count = sum(row.count(5) for row in pattern)
    N_max = min(30 // pattern_w, 30 // pattern_h)
    max_k_m = N_max // pattern_5_count
    if max_k_m < 1:
        max_k_m = 1
    k = random.randint(1, max_k_m)
    m = random.randint(1, max_k_m // k)
    input_grid = []
    for _ in range(m):
        for row in pattern:
            input_grid.append(row * k)
    count_5 = sum(row.count(5) for row in input_grid)
    N = count_5
    count_7 = sum(row.count(7) for row in input_grid)
    rotation_ccw = (count_7 % 2 == 1)
    def rotate_90_ccw(grid):
        return [list(x) for x in zip(*grid)][::-1]
    def rotate_90_cw(grid):
        return [list(x)[::-1] for x in zip(*grid)]
    if rotation_ccw:
        rotated_pattern = rotate_90_ccw(pattern)
    else:
        rotated_pattern = rotate_90_cw(pattern)
    output_grid = []
    for _ in range(N):
        for row in rotated_pattern:
            output_grid.append(row * N)
    if input_grid == output_grid:
        return generate()
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    W = len(input_grid[0])
    H = len(input_grid)
    min_area = W * H
    min_pattern = None
    for d in range(1, W + 1):
        if W % d != 0:
            continue
        for e in range(1, H + 1):
            if H % e != 0:
                continue
            block = [input_grid[r][:d] for r in range(e)]
            valid = True
            for i in range(0, W, d):
                for j in range(0, H, e):
                    for r in range(e):
                        for c in range(d):
                            if input_grid[j + r][i + c] != block[r][c]:
                                valid = False
                                break
                        if not valid:
                            break
                    if not valid:
                        break
                if not valid:
                    break
            if valid:
                if d * e < min_area:
                    min_area = d * e
                    min_pattern = block
    if min_pattern is None:
        min_pattern = input_grid
    count_5 = sum(row.count(5) for row in input_grid)
    N = count_5
    count_7 = sum(row.count(7) for row in input_grid)
    rotation_ccw = (count_7 % 2 == 1)
    def rotate_90_ccw(grid):
        return [list(x) for x in zip(*grid)][::-1]
    def rotate_90_cw(grid):
        return [list(x)[::-1] for x in zip(*grid)]
    if rotation_ccw:
        rotated_pattern = rotate_90_ccw(min_pattern)
    else:
        rotated_pattern = rotate_90_cw(min_pattern)
    output_grid = []
    for _ in range(N):
        for row in rotated_pattern:
            output_grid.append(row * N)
    return output_grid
