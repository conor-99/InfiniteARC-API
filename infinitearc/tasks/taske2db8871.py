# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: e2db8871
Difficulty: mediumâ€“hard

=== Tags ===
- Rule priority resolution
- Diagonals
- Multi stage dependency chain
- Color guessing
- Reconstruct checkerboard from hint

=== Description ===
Input grids consist of a background color (0) with scattered colored cells (1-9)
placed along various diagonal lines, including the main diagonal (row = column)
and anti-diagonal (row + column = grid size - 1), as well as other diagonals.
Each diagonal line maintains a consistent color across its hints. The main
diagonal has the highest priority for determining color A, followed by the anti-
diagonal, then other diagonals ordered by their proximity to the main diagonal
(closer diagonals take precedence). When multiple hints exist on a prioritized
diagonal, the first non-background cell encountered (top-left to bottom-right)
determines the color. Color B is derived from the next highest priority
diagonal's first non-background cell. Output grids reconstruct a checkerboard
pattern where cells with (row + column) even are color A and cells with (row +
column) odd are color B. This requires resolving conflicting diagonal hints
through priority rules, sequentially determining color A then color B, and
applying the checkerboard pattern across the entire grid. The complexity arises
from multiple conflicting diagonal hints requiring priority resolution before
pattern application, with the solver needing to infer both color values from
sparse visual hints rather than direct numerical properties.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

from common import grid
import random

def generate():
    N = random.randint(2, 30)
    A = random.randint(1, 9)
    B = random.randint(1, 9)
    input_grid = grid(N, N, 0)
    input_grid[0][0] = A
    input_grid[0][N-1] = B
    num_hints = random.randint(1, 3)
    for _ in range(num_hints):
        r = random.randint(0, N-1)
        c = random.randint(0, N-1)
        if r == c or r + c == N-1:
            continue
        color = random.randint(1, 9)
        input_grid[r][c] = color
    output_grid = grid(N, N, 0)
    for r in range(N):
        for c in range(N):
            if (r + c) % 2 == 0:
                output_grid[r][c] = A
            else:
                output_grid[r][c] = B
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    N = len(grid)
    A = None
    for r in range(N):
        if grid[r][r] > 0:
            A = grid[r][r]
            break
    if A is None:
        A = 1
    B = None
    for r in range(N):
        c = N - 1 - r
        if grid[r][c] > 0:
            B = grid[r][c]
            break
    if B is None:
        B = 1
    output = []
    for r in range(N):
        row = []
        for c in range(N):
            if (r + c) % 2 == 0:
                row.append(A)
            else:
                row.append(B)
        output.append(row)
    return output
