# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 34ef5ce2
Difficulty: insane

=== Tags ===
- State transition by contact
- Staircase construction
- Draw line from point
- Detect vertical symmetry

=== Description ===
The input grid features a background color (0) with multiple disjoint colored
regions (1-9) arranged asymmetrically. Adjacent regions of different colors
undergo deterministic state transitions upon contact (e.g., color 2 + color 3 â†’
color 5), continuing iteratively until no adjacent regions of differing colors
remain. This process constructs a staircase structure where each step is a
contiguous region of uniform color, aligned to form a leftward or rightward
staircase pattern. From the top-left corner of each staircase step, a horizontal
line is drawn in the step's color extending rightward until it encounters a non-
background cell. The output grid must exhibit vertical symmetry: the left half
of the grid (from the left edge to the central column) is mirrored to the right
half. Existing lines and regions on the left are reflected to the right, but
mirroring does not overwrite non-background cells. The final output is a
vertically symmetric grid where the staircase structure and drawn lines align
precisely with the symmetry axis, with all transitions, lines, and symmetry
constraints applied deterministically.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid


def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid_in = grid(width, height, 0)
    
    # Create staircase structure
    steps = random.randint(2, 5)
    steps_info = []
    for i in range(steps):
        color = i + 1
        r_start = i
        c_start = i
        step_w = random.randint(2, 4)
        step_h = random.randint(2, 4)
        r_end = min(r_start + step_h, height)
        c_end = min(c_start + step_w, width)
        
        for r in range(r_start, r_end):
            for c in range(c_start, c_end):
                grid_in[r][c] = color
        steps_info.append((r_start, c_start, color))

    # Draw lines from top-left of each step
    grid_out = [row[:] for row in grid_in]
    for (r, c, color) in steps_info:
        c_current = c
        while c_current + 1 < width and grid_out[r][c_current + 1] == 0:
            grid_out[r][c_current + 1] = color
            c_current += 1

    # Mirror left half to right
    mid = width // 2
    for r in range(height):
        for c in range(mid):
            grid_out[r][width - 1 - c] = grid_out[r][c]

    return {
        'input': grid_in,
        'output': grid_out
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    # Identify connected regions
    visited = [[False] * width for _ in range(height)]
    regions = []
    
    def dfs(r, c, color):
        stack = [(r, c)]
        region = []
        while stack:
            r, c = stack.pop()
            if visited[r][c] or grid[r][c] != color:
                continue
            visited[r][c] = True
            region.append((r, c))
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                    stack.append((nr, nc))
        return region

    # Find all regions
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and grid[r][c] != 0:
                color = grid[r][c]
                region = dfs(r, c, color)
                regions.append(region)

    # Draw lines from top-left of each region
    for region in regions:
        min_r = min(r for r, c in region)
        min_c = min(c for r, c in region)
        color = grid[min_r][min_c]
        c_current = min_c
        while c_current + 1 < width and grid[min_r][c_current + 1] == 0:
            grid[min_r][c_current + 1] = color
            c_current += 1

    # Mirror left half to right
    mid = width // 2
    for r in range(height):
        for c in range(mid):
            grid[r][width - 1 - c] = grid[r][c]

    return grid
