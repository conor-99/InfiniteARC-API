# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 29861545
Difficulty: very hard

=== Tags ===
- Interleaved streams

=== Description ===
The input grid features two distinct color streams (e.g., color A and color B)
arranged along continuous, non-overlapping paths that alternate colors at each
step (e.g., A-B-A-B along a diagonal path). These paths may traverse the grid in
any direction (diagonal, horizontal, or vertical) but maintain consistent
movement without branching. The streams are visually distinguishable by their
color and path continuity, with no overlap between the two.  The output grid
applies three sequential transformations:   1. **Color reversal**: The
interleaving order of the streams is inverted (e.g., A-B-A-B becomes B-A-B-A).
2. **Path reorientation**: Each stream is realigned to move strictly along a
fixed grid axisâ€”stream A aligns horizontally (left/right), and stream B aligns
vertically (up/down), regardless of their original direction.   3. **Position
preservation**: The relative spacing between consecutive elements of each stream
is maintained during reorientation, ensuring the interleaved pattern remains
consistent with the new alignment.    The transformation requires identifying
the original paths, reversing the color sequence, and projecting the streams
onto orthogonal axes while preserving the interleaving structure. The complexity
arises from the need to simultaneously track path direction, reverse color
order, and adjust alignment without distorting the sequence. Overlapping or
intersecting paths in the input (e.g., diagonal streams crossing) must be
resolved by prioritizing the stream with the higher color value, ensuring no
conflicts in the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_color

def generate():
    colors = list(range(1, 10))
    color_A = random.choice(colors)
    color_B = random.choice([c for c in colors if c != color_A])
    
    path_length = random.choice([2, 4, 6, 8, 10])
    grid_size = max(5, path_length + 1)
    grid_size = min(30, grid_size)
    
    input_grid = grid(grid_size, grid_size, 0)
    for i in range(path_length):
        if i % 2 == 0:
            input_grid[i][i] = color_A
        else:
            input_grid[i][i] = color_B
            
    output_grid = grid(grid_size, grid_size, 0)
    center = grid_size // 2
    center_vertical = center + 1
    spacing = 2
    
    for i in range(path_length // 2):
        output_grid[center][i * spacing] = color_A
    for i in range(path_length // 2):
        output_grid[i * spacing][center_vertical] = color_B
        
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    width = len(input_list[0])
    height = len(input_list)
    
    path = []
    for r in range(height):
        for c in range(width):
            if input_list[r][c] != 0:
                path.append((r, c))
    path.sort(key=lambda x: (x[0], x[1]))
    
    if not path:
        return input_list
    
    reversed_path = path[::-1]
    color_A = input_list[path[0][0]][path[0][1]]
    color_B = input_list[path[1][0]][path[1][1]] if len(path) > 1 else color_A
    
    color_A_positions = []
    color_B_positions = []
    for (r, c) in reversed_path:
        if input_list[r][c] == color_A:
            color_A_positions.append((r, c))
        else:
            color_B_positions.append((r, c))
    
    spacing_A = 2
    spacing_B = 2
    
    output = grid(width, height, 0)
    center = width // 2
    center_vertical = center + 1
    
    for i, (r, c) in enumerate(color_A_positions):
        output[center][i * spacing_A] = color_A
    for i, (r, c) in enumerate(color_B_positions):
        output[i * spacing_B][center_vertical] = color_B
        
    return output
