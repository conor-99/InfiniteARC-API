# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 19ea4465
Difficulty: medium–hard

=== Tags ===
- Adaptive behavior switch
- Local convolution rule
- Competitive agents
- Implicit topology

=== Description ===
Input grids consist of a background color (0) and multiple colored agents (1–9),
each occupying a single cell. Agents are placed such that no two agents of the
same color are orthogonally adjacent, and each agent has at least one background
neighbor. The output grid is generated by applying a local convolution rule
where each agent’s color updates to the highest-priority color among its
orthogonal neighbors. Priority follows a fixed, hidden hierarchy (e.g., red >
yellow > green > blue), with agents retaining their color if no neighbors exist.
All color changes occur simultaneously, preserving background cells and agent
positions. The transformation requires inferring the priority hierarchy from
input-output examples, leveraging competitive interactions between adjacent
agents and implicit topological relationships defined by orthogonal adjacency.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

priority_order = [5, 3, 7, 1, 2, 4, 6, 8, 9]

def generate():
    width = random.randint(5, 20)
    height = random.randint(5, 20)
    input_grid = grid(width, height, 0)
    
    positions = []
    for r in range(height):
        for c in range(width):
            if random.random() > 0.7:
                positions.append((r, c))
    
    for r, c in positions:
        neighbors = []
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0:
                neighbors.append(input_grid[nr][nc])
        available = [c for c in range(1,10) if c not in neighbors]
        if available:
            input_grid[r][c] = random.choice(available)
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                has_bg = False
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 0:
                        has_bg = True
                        break
                if not has_bg:
                    input_grid[r][c] = 0
    
    output_grid = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                neighbors = []
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0:
                        neighbors.append(input_grid[nr][nc])
                if neighbors:
                    best_color = input_grid[r][c]
                    min_idx = float('inf')
                    for color in neighbors:
                        idx = priority_order.index(color)
                        if idx < min_idx:
                            min_idx = idx
                            best_color = color
                    output_grid[r][c] = best_color
    
    if all(input_grid[r][c] == output_grid[r][c] for r in range(height) for c in range(width)):
        return generate()
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    priority_order = [5, 3, 7, 1, 2, 4, 6, 8, 9]
    height = len(grid)
    width = len(grid[0])
    output = [row[:] for row in grid]
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                neighbors = []
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                        neighbors.append(grid[nr][nc])
                if neighbors:
                    best_color = grid[r][c]
                    min_idx = float('inf')
                    for color in neighbors:
                        idx = priority_order.index(color)
                        if idx < min_idx:
                            min_idx = idx
                            best_color = color
                    output[r][c] = best_color
    return output
