# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 09a8fce5
Difficulty: medium

=== Tags ===
- Periodic tiling
- Projection unto rectangle
- Direction guessing
- Pattern differences

=== Description ===
The input grid consists of a periodic tiling pattern where the entire grid is
formed by repeating a smaller base rectangle. The output grid is the smallest
such base rectangle that, when tiled, reconstructs the input grid. To determine
the base rectangle, the solver must identify the minimal row period (m) and
column period (n) such that every m rows and n columns form an identical block.
This requires analyzing the grid for repeating patterns along both axes and
selecting the smallest repeating unit. The direction guessing aspect involves
determining whether the periodicity is primarily horizontal (column-based),
vertical (row-based), or a combination, by checking for consistent repetitions
in rows and columns. The output is the top-left m x n block of the input grid,
representing the fundamental pattern that generates the input through tiling.
The pattern differences are evident as the input is a scaled-up version of the
output pattern, with the output capturing the core repeating structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    m = random.randint(1, 5)
    n = random.randint(1, 5)
    base = []
    while True:
        base = [[random.randint(0, 9) for _ in range(n)] for _ in range(m)]
        if len(set(tuple(row) for row in base)) == m:
            cols = [tuple(base[i][j] for i in range(m)) for j in range(n)]
            if len(set(cols)) == n:
                break
    input_grid = []
    for i in range(2 * m):
        row = []
        for j in range(2 * n):
            row.append(base[i % m][j % n])
        input_grid.append(row)
    return {"input": input_grid, "output": base}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    R = len(input_grid)
    C = len(input_grid[0])
    
    row_period = R
    for m in range(1, R + 1):
        if R % m != 0:
            continue
        valid = True
        for i in range(R):
            if input_grid[i] != input_grid[i % m]:
                valid = False
                break
        if valid:
            row_period = m
            break
    
    col_period = C
    for n in range(1, C + 1):
        if C % n != 0:
            continue
        valid = True
        for j in range(C):
            col = [input_grid[i][j] for i in range(R)]
            col_ref = [input_grid[i][j % n] for i in range(R)]
            if col != col_ref:
                valid = False
                break
        if valid:
            col_period = n
            break
    
    output = [row[:col_period] for row in input_grid[:row_period]]
    return output
