# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: afcad7cc
Difficulty: hard

=== Tags ===
- Guided flow
- Rule based tiling
- Pressure release
- Copy object and apply one change

=== Description ===
# Pressure-Activated Tiling  Input grids feature a background color (0),
multiple distinct tile shapes (each composed of a contiguous 2Ã—2 block of a
single non-background color), and pressure indicators (color 2) positioned
orthogonally adjacent to exactly one tile per indicator. Each tile is surrounded
by background cells except for one side where a pressure indicator resides. The
pressure indicators form a "guided flow" that dictates the direction of tile
replication.  The transformation applies the following rules sequentially:
First, each tile is copied to a new position determined by the direction of its
adjacent pressure indicator (e.g., a right-facing indicator copies the tile one
cell to the right). Second, in every copied tile, the cell that occupies the
"top-right" position relative to the original tile's orientation is changed to a
new color (color 3). Third, all pressure indicators are removed from the grid.
The original tiles remain in their positions, while the copies are placed in the
direction indicated by the pressure markers. The output grid contains all
original tiles, the modified copies, and no pressure indicators. This process
constitutes "pressure release" through directional replication with a single-
cell modification, creating a rule-based tiling pattern where each copy must
follow the guided flow direction from its source pressure indicator.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid as make_grid

def generate():
    """
    Generates an input/output pair for the Pressure-Activated Tiling task.

    Grid contains:
    - background 0
    - several 2x2 tiles of a single non-background color (colors exclude 2 and 3)
    - one pressure indicator (color 2) placed in one canonical adjacent cell per tile
      at positions chosen from: (top of top-left), (left of top-left), (right of top-right), (below bottom-left)
    The output is produced by scanning the input grid row-major for pressure indicators
    and for each one placing a copy of the adjacent 2x2 tile with its top-left at the marker
    (so the marker cell becomes the top-left of the copy). In the copy, the top-right cell is
    changed to color 3. All pressure indicators are removed in the output.
    """
    # Try until we succeed in placing at least one tile
    for attempt in range(200):
        width = random.randint(5, 20)
        height = random.randint(5, 20)
        ingrid = [[0 for _ in range(width)] for _ in range(height)]
        tiles = []  # list of tuples (rt, ct, color, dir, (mr, mc))

        # Choose how many tiles to attempt to place
        max_tiles = random.randint(1, min(5, max(1, (width * height) // 60)))

        tries = 0
        while len(tiles) < max_tiles and tries < max_tiles * 80:
            tries += 1
            # pick a candidate top-left for a 2x2 tile
            rt = random.randint(0, height - 2)
            ct = random.randint(0, width - 2)
            # tile area must be empty
            area_free = True
            for dr in (0, 1):
                for dc in (0, 1):
                    if ingrid[rt + dr][ct + dc] != 0:
                        area_free = False
                        break
                if not area_free:
                    break
            if not area_free:
                continue

            # pick a color for the tile (avoid 0,2,3)
            used_colors = [t[2] for t in tiles]
            choices = [c for c in range(1, 10) if c not in (2, 3) and c not in used_colors]
            if not choices:
                choices = [c for c in range(1, 10) if c not in (2, 3)]
            color = random.choice(choices)

            feasible = []
            # left: marker at (rt, ct-1), copy top-left will be (rt, ct-1)
            if ct >= 1:
                mr, mc = rt, ct - 1
                # marker cell and copy 2x2 must fit in grid
                if mc >= 0 and mc + 1 < width and mr + 1 < height:
                    # ensure the 2x2 copy area is empty (avoid collisions)
                    copy_ok = True
                    for dr in (0, 1):
                        for dc in (0, 1):
                            if ingrid[mr + dr][mc + dc] != 0:
                                copy_ok = False
                                break
                        if not copy_ok:
                            break
                    if copy_ok:
                        feasible.append(('left', (mr, mc)))

            # right: marker at (rt, ct+2), copy top-left will be (rt, ct+2)
            # must ensure ct+3 < width so the 2x2 copy fits
            if ct + 2 < width:
                mr, mc = rt, ct + 2
                if mc + 1 < width and mr + 1 < height:
                    copy_ok = True
                    for dr in (0, 1):
                        for dc in (0, 1):
                            if ingrid[mr + dr][mc + dc] != 0:
                                copy_ok = False
                                break
                        if not copy_ok:
                            break
                    if copy_ok:
                        feasible.append(('right', (mr, mc)))

            # up: marker at (rt-1, ct), copy top-left will be (rt-1, ct)
            if rt >= 1:
                mr, mc = rt - 1, ct
                if mr >= 0 and mr + 1 < height and mc + 1 < width:
                    copy_ok = True
                    for dr in (0, 1):
                        for dc in (0, 1):
                            if ingrid[mr + dr][mc + dc] != 0:
                                copy_ok = False
                                break
                        if not copy_ok:
                            break
                    if copy_ok:
                        feasible.append(('up', (mr, mc)))

            # down: marker at (rt+2, ct), copy top-left will be (rt+2, ct)
            if rt + 2 < height:
                mr, mc = rt + 2, ct
                if mr + 1 < height and mc + 1 < width:
                    copy_ok = True
                    for dr in (0, 1):
                        for dc in (0, 1):
                            if ingrid[mr + dr][mc + dc] != 0:
                                copy_ok = False
                                break
                        if not copy_ok:
                            break
                    if copy_ok:
                        feasible.append(('down', (mr, mc)))

            if not feasible:
                continue

            direction, (mr, mc) = random.choice(feasible)
            # place the tile
            for dr in (0, 1):
                for dc in (0, 1):
                    ingrid[rt + dr][ct + dc] = color
            # place the pressure indicator (a single cell) at the canonical marker position
            ingrid[mr][mc] = 2
            tiles.append((rt, ct, color, direction, (mr, mc)))

        if not tiles:
            # try again
            continue

        # Build the output by scanning the input in row-major order for pressure indicators
        out = [row[:] for row in ingrid]
        H = height
        W = width
        for r in range(H):
            for c in range(W):
                if ingrid[r][c] != 2:
                    continue
                placed = False
                # candidate tile top-left at (r, c+1) -- corresponds to a tile immediately to the right of the marker (marker is left of tile)
                rr, cc = r, c + 1
                if cc <= W - 2 and rr <= H - 2:
                    col = ingrid[rr][cc]
                    if col not in (0, 2) and ingrid[rr][cc] == col and ingrid[rr][cc + 1] == col and ingrid[rr + 1][cc] == col and ingrid[rr + 1][cc + 1] == col:
                        out[r][c] = col
                        out[r][c + 1] = 3
                        out[r + 1][c] = col
                        out[r + 1][c + 1] = col
                        placed = True
                if placed:
                    continue

                # candidate tile top-left at (r, c-2) -- marker is right of tile
                rr, cc = r, c - 2
                if cc >= 0 and cc <= W - 2 and rr <= H - 2:
                    col = ingrid[rr][cc]
                    if col not in (0, 2) and ingrid[rr][cc] == col and ingrid[rr][cc + 1] == col and ingrid[rr + 1][cc] == col and ingrid[rr + 1][cc + 1] == col:
                        out[r][c] = col
                        out[r][c + 1] = 3
                        out[r + 1][c] = col
                        out[r + 1][c + 1] = col
                        placed = True
                if placed:
                    continue

                # candidate tile top-left at (r+1, c) -- marker is above tile
                rr, cc = r + 1, c
                if rr <= H - 2 and cc <= W - 2:
                    col = ingrid[rr][cc]
                    if col not in (0, 2) and ingrid[rr][cc] == col and ingrid[rr][cc + 1] == col and ingrid[rr + 1][cc] == col and ingrid[rr + 1][cc + 1] == col:
                        out[r][c] = col
                        out[r][c + 1] = 3
                        out[r + 1][c] = col
                        out[r + 1][c + 1] = col
                        placed = True
                if placed:
                    continue

                # candidate tile top-left at (r-2, c) -- marker is below tile
                rr, cc = r - 2, c
                if rr >= 0 and rr <= H - 2 and cc <= W - 2:
                    col = ingrid[rr][cc]
                    if col not in (0, 2) and ingrid[rr][cc] == col and ingrid[rr][cc + 1] == col and ingrid[rr + 1][cc] == col and ingrid[rr + 1][cc + 1] == col:
                        out[r][c] = col
                        out[r][c + 1] = 3
                        out[r + 1][c] = col
                        out[r + 1][c + 1] = col
                        placed = True
                if not placed:
                    # if for any reason we couldn't find the matching tile, just erase the pressure indicator
                    out[r][c] = 0

        # ensure no pressure indicators remain
        for r in range(H):
            for c in range(W):
                if out[r][c] == 2:
                    out[r][c] = 0

        # ensure input != output
        if out == ingrid:
            continue

        return {
            'input': ingrid,
            'output': out
        }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0])
    out = [row[:] for row in grid]

    # Scan row-major for pressure indicators (value 2) and apply copies in that same order
    for r in range(H):
        for c in range(W):
            if grid[r][c] != 2:
                continue
            placed = False
            # candidate tile top-left at (r, c+1) -- marker is left of tile
            rr, cc = r, c + 1
            if cc <= W - 2 and rr <= H - 2:
                col = grid[rr][cc]
                if col not in (0, 2, 3) and grid[rr][cc] == col and grid[rr][cc + 1] == col and grid[rr + 1][cc] == col and grid[rr + 1][cc + 1] == col:
                    out[r][c] = col
                    out[r][c + 1] = 3
                    out[r + 1][c] = col
                    out[r + 1][c + 1] = col
                    placed = True
            if placed:
                continue

            # candidate tile top-left at (r, c-2) -- marker is right of tile
            rr, cc = r, c - 2
            if cc >= 0 and cc <= W - 2 and rr <= H - 2:
                col = grid[rr][cc]
                if col not in (0, 2, 3) and grid[rr][cc] == col and grid[rr][cc + 1] == col and grid[rr + 1][cc] == col and grid[rr + 1][cc + 1] == col:
                    out[r][c] = col
                    out[r][c + 1] = 3
                    out[r + 1][c] = col
                    out[r + 1][c + 1] = col
                    placed = True
            if placed:
                continue

            # candidate tile top-left at (r+1, c) -- marker is above tile
            rr, cc = r + 1, c
            if rr <= H - 2 and cc <= W - 2:
                col = grid[rr][cc]
                if col not in (0, 2, 3) and grid[rr][cc] == col and grid[rr][cc + 1] == col and grid[rr + 1][cc] == col and grid[rr + 1][cc + 1] == col:
                    out[r][c] = col
                    out[r][c + 1] = 3
                    out[r + 1][c] = col
                    out[r + 1][c + 1] = col
                    placed = True
            if placed:
                continue

            # candidate tile top-left at (r-2, c) -- marker is below tile
            rr, cc = r - 2, c
            if rr >= 0 and rr <= H - 2 and cc <= W - 2:
                col = grid[rr][cc]
                if col not in (0, 2, 3) and grid[rr][cc] == col and grid[rr][cc + 1] == col and grid[rr + 1][cc] == col and grid[rr + 1][cc + 1] == col:
                    out[r][c] = col
                    out[r][c + 1] = 3
                    out[r + 1][c] = col
                    out[r + 1][c + 1] = col
                    placed = True
            if not placed:
                # remove indicator if no tile found (safety)
                out[r][c] = 0

    # Ensure no leftover 2's
    for r in range(H):
        for c in range(W):
            if out[r][c] == 2:
                out[r][c] = 0

    return out

