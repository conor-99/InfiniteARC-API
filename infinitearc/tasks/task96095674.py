# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 96095674
Difficulty: mediumâ€“hard

=== Tags ===
- Ripple spread
- Find shape in negative space

=== Description ===
Input grids feature a background color (0) with a single rectangular region of
the same background color (the negative space shape) that is the largest
connected background region. The foreground (color 1) occupies all other cells.
The output grid retains the foreground and the negative space shape, but
transforms the background by spreading a ripple pattern from the negative space
shape's perimeter: each cell adjacent to the perimeter is colored 2, the next
layer outward is colored 3, and subsequent layers cycle through colors 2, 3, 4,
5, repeating the sequence until grid boundaries are reached. The negative space
shape itself remains color 0.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    width = common.randint(3, 30)
    height = common.randint(3, 30)
    grid_in = common.grid(width, height, 1)
    r1 = common.randint(0, height - 3)
    r2 = common.randint(r1 + 1, height - 2)
    c1 = common.randint(0, width - 3)
    c2 = common.randint(c1 + 1, width - 2)
    for r in range(r1, r2 + 1):
        for c in range(c1, c2 + 1):
            grid_in[r][c] = 0
    min_r = height
    max_r = -1
    min_c = width
    max_c = -1
    for r in range(height):
        for c in range(width):
            if grid_in[r][c] == 0:
                min_r = min(min_r, r)
                max_r = max(max_r, r)
                min_c = min(min_c, c)
                max_c = max(max_c, c)
    grid_out = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if min_r <= r <= max_r and min_c <= c <= max_c:
                grid_out[r][c] = 0
            else:
                d = float('inf')
                if c > max_c:
                    d = min(d, c - max_c)
                if c < min_c:
                    d = min(d, min_c - c)
                if r > max_r:
                    d = min(d, r - max_r)
                if r < min_r:
                    d = min(d, min_r - r)
                color = 2 + ((d - 1) % 4)
                grid_out[r][c] = color
    return {'input': grid_in, 'output': grid_out}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    visited = [[False] * width for _ in range(height)]
    max_component = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0 and not visited[r][c]:
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr = cr + dr
                        nc = cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == 0:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                if len(component) > len(max_component):
                    max_component = component
    min_r = min(r for r, c in max_component)
    max_r = max(r for r, c in max_component)
    min_c = min(c for r, c in max_component)
    max_c = max(c for r, c in max_component)
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if min_r <= r <= max_r and min_c <= c <= max_c:
                output_grid[r][c] = 0
            else:
                d = float('inf')
                if c > max_c:
                    d = min(d, c - max_c)
                if c < min_c:
                    d = min(d, min_c - c)
                if r > max_r:
                    d = min(d, r - max_r)
                if r < min_r:
                    d = min(d, min_r - r)
                color = 2 + ((d - 1) % 4)
                output_grid[r][c] = color
    return output_grid
