# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 3db9bdd4
Difficulty: easy

=== Tags ===
- Center object in canvas

=== Description ===
The task involves input grids containing a single connected object (a group of
adjacent non-zero cells) on a zero background. The output grid is formed by
shifting the object so that its bounding box is centered within the grid's
dimensions, preserving all cell colors and maintaining the zero background
elsewhere.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    while True:
        width = random.randint(1, 30)
        height = random.randint(1, 30)
        if width * height < 4:
            continue
        max_size = width * height - 1
        size = random.randint(3, min(20, max_size))
        creature = common.continuous_creature(size, width, height)
        input_grid = common.grid(width, height, 0)
        color = common.random_color(exclude=[0])
        for (r, c) in creature:
            input_grid[r][c] = color
        rows = [r for (r, c) in creature]
        cols = [c for (r, c) in creature]
        min_row, max_row = min(rows), max(rows)
        min_col, max_col = min(cols), max(cols)
        bounding_width = max_col - min_col + 1
        bounding_height = max_row - min_row + 1
        shift_x = (width - bounding_width) // 2
        shift_y = (height - bounding_height) // 2
        if shift_x == 0 and shift_y == 0:
            continue
        output_grid = common.grid(width, height, 0)
        for (r, c) in creature:
            new_r = r + shift_y
            new_c = c + shift_x
            output_grid[new_r][new_c] = input_grid[r][c]
        if input_grid == output_grid:
            continue
        return {
            "input": input_grid,
            "output": output_grid
        }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    non_zero = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                non_zero.append((r, c))
    if not non_zero:
        return input_grid
    rows = [r for r, c in non_zero]
    cols = [c for r, c in non_zero]
    min_row, max_row = min(rows), max(rows)
    min_col, max_col = min(cols), max(cols)
    bounding_width = max_col - min_col + 1
    bounding_height = max_row - min_row + 1
    shift_x = (width - bounding_width) // 2
    shift_y = (height - bounding_height) // 2
    output_grid = common.grid(width, height, 0)
    for (r, c) in non_zero:
        new_r = r + shift_y
        new_c = c + shift_x
        output_grid[new_r][new_c] = input_grid[r][c]
    return output_grid
