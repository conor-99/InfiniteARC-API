# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: b3d30c6e
Difficulty: hard

=== Tags ===
- Directional routing
- Deterministic update
- Teleporter network routing

=== Description ===
Input grids feature a uniform background color (0-9) with multiple non-
background colors forming teleporter pairs. Each pair consists of exactly two
cells sharing the same non-background color, and each color is deterministically
linked to a fixed movement direction (e.g., color 1 always directs movement
upward, color 2 to the right, etc.). A path begins at a single non-background
cell located on the leftmost column (column 0), moving horizontally rightward.
The path traverses background cells until it encounters a teleporter cell (any
color), at which point it instantly teleports to the paired cell of the same
color and switches to the direction associated with that color. This process
repeats until the path exits the grid through any edge (top, bottom, right, or
left). The output grid preserves all teleporter cells and their original colors
while drawing the complete path using a distinct color (not background or
teleporter colors) across the traversed background cells. The path never
overlaps with teleporters, the starting cell, or other non-background elements,
and all teleporter pairs are positioned such that the path eventually exits the
grid after a finite number of direction changes.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(15, 30)
    height = random.randint(15, 30)
    B = random.randint(0, 9)
    teleport_colors = random.sample([c for c in range(1, 10) if c != B], 2)
    C1, C2 = teleport_colors
    grid_input = [[B] * width for _ in range(height)]
    
    start_row = random.randint(0, height-1)
    grid_input[start_row][0] = C1
    
    pair1_r = (start_row + 3) % height
    pair1_c = 5
    if pair1_r == 0 or pair1_r == height-1 or pair1_c == 0 or pair1_c == width-1:
        pair1_c = (pair1_c + 1) % (width-2) + 1
    grid_input[pair1_r][pair1_c] = C1
    
    c2_r = start_row
    c2_c = 5
    if c2_c >= width-1:
        c2_c = width-2
    grid_input[c2_r][c2_c] = C2
    pair2_r = (c2_r + 5) % height
    pair2_c = c2_c
    if pair2_r == 0 or pair2_r == height-1 or pair2_c == 0 or pair2_c == width-1:
        pair2_r = (pair2_r + 1) % (height-2) + 1
    grid_input[pair2_r][pair2_c] = C2
    
    # Choose path color deterministically (smallest available)
    path_color = 0
    for c in range(10):
        if c != B and c != C1 and c != C2:
            path_color = c
            break
    grid_output = [row[:] for row in grid_input]
    
    r, c = start_row, 1
    direction = (1, 0)
    path_cells = []
    while 0 <= r < height and 0 <= c < width:
        if grid_input[r][c] == B:
            path_cells.append((r, c))
            r += direction[0]
            c += direction[1]
        else:
            color = grid_input[r][c]
            for i in range(height):
                for j in range(width):
                    if grid_input[i][j] == color and (i != r or j != c):
                        r, c = i, j
                        break
                else:
                    continue
                break
            if color in [1,5,9]:
                direction = (0, -1)
            elif color in [2,6]:
                direction = (1, 0)
            elif color in [3,7]:
                direction = (0, 1)
            elif color in [4,8]:
                direction = (-1, 0)
            r += direction[0]
            c += direction[1]
    
    for (r, c) in path_cells:
        grid_output[r][c] = path_color
    
    return {"input": grid_input, "output": grid_output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import Counter
def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    bg_count = Counter()
    for row in grid:
        for cell in row:
            bg_count[cell] += 1
    B = bg_count.most_common(1)[0][0]
    
    teleport_colors = []
    for color, count in bg_count.items():
        if color != B and count == 2:
            teleport_colors.append(color)
    
    start_row = None
    for r in range(height):
        if grid[r][0] != B:
            start_row = r
            break
    if start_row is None:
        return input_grid
    
    def get_dir(color):
        if color in (1,5,9):
            return (0, -1)
        elif color in (2,6):
            return (1, 0)
        elif color in (3,7):
            return (0, 1)
        elif color in (4,8):
            return (-1, 0)
        else:
            return (0, 1)
    
    pairs = {}
    for color in teleport_colors:
        positions = []
        for r in range(height):
            for c in range(width):
                if grid[r][c] == color:
                    positions.append((r, c))
        if len(positions) == 2:
            pairs[color] = positions
    
    r, c = start_row, 1
    direction = (1, 0)
    path_cells = []
    while 0 <= r < height and 0 <= c < width:
        if grid[r][c] == B:
            path_cells.append((r, c))
            r += direction[0]
            c += direction[1]
        else:
            color = grid[r][c]
            if color not in pairs:
                break
            (r1, c1), (r2, c2) = pairs[color]
            if (r, c) == (r1, c1):
                r, c = r2, c2
            else:
                r, c = r1, c1
            direction = get_dir(color)
            r += direction[0]
            c += direction[1]
    
    # Choose path color deterministically (smallest available)
    path_color = 0
    for color in range(10):
        if color != B and color not in teleport_colors:
            path_color = color
            break
    
    for (r, c) in path_cells:
        grid[r][c] = path_color
    
    return tuple(tuple(row) for row in grid)
