# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: a2236340
Difficulty: very hard

=== Tags ===
- Pattern modification
- Color carving
- Area based reconstruction
- Recursive pattern copy

=== Description ===
Task: Recursive Carving and Pattern Reconstruction  Input grids feature a
central pattern composed of multiple colors, surrounded by a continuous frame of
a single color (e.g., color 3). Within the central pattern, regions of a
distinct carving color (e.g., color 5) are completely enclosed by the frame
color, meaning no path exists from any carving color cell to the grid edge
without passing through the frame color. The background is color 0.  The output
grid is generated through the following multi-step transformation: 1.
**Carving**: All carving color cells within enclosed regions (surrounded by
frame color) are removed (set to background color 0), creating voids or "holes"
within the central pattern. 2. **Main Pattern Identification**: The largest
contiguous region of non-background, non-frame colors (excluding frame color and
background) is identified as the main pattern. 3. **Recursive Reconstruction**:
For each hole created by carving, a recursive sequence of pattern copies is
placed within the hole's bounding box:    - The first copy is the main pattern
at full size.    - Each subsequent copy is scaled down by 50% (rounded to
integer dimensions), rotated 90° clockwise from the previous copy, and
positioned to fit within the hole.    - This process repeats until the copy size
is smaller than 2×2, at which point the remaining area is filled with the
smallest copy.  The frame color, carving color, and main pattern vary per
instance but remain consistent within a single task. The output requires
recognizing enclosed regions (using frame color as boundary), identifying the
main pattern (as the largest coherent structure within the frame), and applying
recursive scaling and rotation transformations. The complexity arises from the
need to detect enclosed regions through frame color constraints, identify the
main pattern amidst overlapping colors, and apply geometric transformations
recursively to reconstruct each hole with progressively smaller, rotated copies.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid


def _resize_bitmap(bitmap, new_h, new_w):
    """Nearest-neighbor resize of a 2D bitmap (list of lists).
    Preserves zeros and color values."""
    if new_h <= 0: new_h = 1
    if new_w <= 0: new_w = 1
    src_h = len(bitmap)
    src_w = len(bitmap[0]) if src_h > 0 else 0
    if src_h == 0 or src_w == 0:
        return [[0 for _ in range(new_w)] for _ in range(new_h)]
    out = [[0 for _ in range(new_w)] for _ in range(new_h)]
    for r in range(new_h):
        # map r -> src_r
        src_r = int(r * src_h / new_h)
        if src_r >= src_h:
            src_r = src_h - 1
        for c in range(new_w):
            src_c = int(c * src_w / new_w)
            if src_c >= src_w:
                src_c = src_w - 1
            out[r][c] = bitmap[src_r][src_c]
    return out


def _rotate_cw(bitmap):
    if not bitmap: return []
    h = len(bitmap)
    w = len(bitmap[0])
    return [[bitmap[h - 1 - r][c] for r in range(h)] for c in range(w)]


def _paste_over(output, top, left, bitmap, bbox_minr, bbox_minc, bbox_maxr, bbox_maxc):
    """Paste bitmap into output at (top,left) but only inside the bounding rectangle bbox.
    Overwrites whatever is there (this is the intended overlay behaviour)."""
    h = len(output)
    w = len(output[0])
    bh = len(bitmap)
    bw = len(bitmap[0]) if bh>0 else 0
    for r in range(bh):
        for c in range(bw):
            tr = top + r
            tc = left + c
            if tr < bbox_minr or tr > bbox_maxr or tc < bbox_minc or tc > bbox_maxc:
                continue
            if 0 <= tr < h and 0 <= tc < w:
                output[tr][tc] = bitmap[r][c]


def generate():
    # Grid size chosen to leave enough interior space for recursive copies
    width = random.randint(8, 18)
    height = random.randint(8, 18)

    # Choose distinct colors for frame and carving
    colors = list(range(1, 10))
    frame_color = random.choice(colors)
    remaining = [c for c in colors if c != frame_color]
    carving_color = random.choice(remaining)

    remaining = [c for c in remaining if c != carving_color]
    # Choose two main colors for the central pattern (guarantees they are more frequent than carving)
    main_colors = random.sample(remaining, k=2)

    # Create grid and draw continuous frame as outer border
    ingrid = grid(width, height, 0)
    for c in range(width):
        ingrid[0][c] = frame_color
        ingrid[height - 1][c] = frame_color
    for r in range(height):
        ingrid[r][0] = frame_color
        ingrid[r][width - 1] = frame_color

    # Fill the interior completely with alternating main colors to ensure a single contiguous main region
    inner_min_r, inner_max_r = 1, height - 2
    inner_min_c, inner_max_c = 1, width - 2
    inner_h = inner_max_r - inner_min_r + 1
    inner_w = inner_max_c - inner_min_c + 1
    inner_area = inner_h * inner_w
    for r in range(inner_min_r, inner_max_r + 1):
        for c in range(inner_min_c, inner_max_c + 1):
            # simple checkerboard-like distribution to balance counts
            ingrid[r][c] = main_colors[((r - inner_min_r) + (c - inner_min_c)) % len(main_colors)]

    # Choose a rectangular carving region fully inside the interior (guaranteed enclosed by the frame)
    max_carve_w = max(2, min(inner_w - 1, max(2, inner_w // 2)))
    max_carve_h = max(2, min(inner_h - 1, max(2, inner_h // 2)))
    carve_w = random.randint(2, max(2, max_carve_w))
    carve_h = random.randint(2, max(2, max_carve_h))
    carve_top = random.randint(inner_min_r, inner_max_r - carve_h + 1)
    carve_left = random.randint(inner_min_c, inner_max_c - carve_w + 1)

    carving_pixels = []
    for r in range(carve_top, carve_top + carve_h):
        for c in range(carve_left, carve_left + carve_w):
            ingrid[r][c] = carving_color
            carving_pixels.append((r, c))

    # Build output by performing the carving and then recursive reconstruction
    output = [row[:] for row in ingrid]
    # Step 1: Carving - set carving color to background 0
    for r, c in carving_pixels:
        output[r][c] = 0

    # Step 2: Identify main pattern as largest contiguous region of non-background, non-frame
    h = height
    w = width
    visited = [[False] * w for _ in range(h)]
    def neighbors(r, c):
        for dr, dc in ((0,1),(0,-1),(1,0),(-1,0)):
            nr, nc = r+dr, c+dc
            if 0 <= nr < h and 0 <= nc < w:
                yield nr, nc

    largest = []
    for r in range(inner_min_r, inner_max_r + 1):
        for c in range(inner_min_c, inner_max_c + 1):
            if visited[r][c]:
                continue
            if output[r][c] == 0 or output[r][c] == frame_color:
                continue
            # BFS
            stack = [(r, c)]
            comp = []
            visited[r][c] = True
            while stack:
                pr, pc = stack.pop()
                comp.append((pr, pc))
                for nr, nc in neighbors(pr, pc):
                    if nr < inner_min_r or nr > inner_max_r or nc < inner_min_c or nc > inner_max_c:
                        continue
                    if visited[nr][nc]:
                        continue
                    if output[nr][nc] == 0 or output[nr][nc] == frame_color:
                        continue
                    visited[nr][nc] = True
                    stack.append((nr, nc))
            if len(comp) > len(largest):
                largest = comp

    if not largest:
        # fallback: use any non-frame non-background pixel
        for r in range(inner_min_r, inner_max_r + 1):
            for c in range(inner_min_c, inner_max_c + 1):
                if output[r][c] != 0 and output[r][c] != frame_color:
                    largest = [(r,c)]
                    break
            if largest:
                break

    # Extract main bitmap
    minr = min(p[0] for p in largest)
    maxr = max(p[0] for p in largest)
    minc = min(p[1] for p in largest)
    maxc = max(p[1] for p in largest)
    main_h = maxr - minr + 1
    main_w = maxc - minc + 1
    main_bitmap = [[0 for _ in range(main_w)] for _ in range(main_h)]
    largest_set = set(largest)
    for rr in range(main_h):
        for cc in range(main_w):
            pr = minr + rr
            pc = minc + cc
            if (pr, pc) in largest_set:
                main_bitmap[rr][cc] = output[pr][pc]
            else:
                main_bitmap[rr][cc] = 0

    # Step 3: For each carved hole, place recursive copies
    # Find zero-regions inside the interior (these are the holes created by carving)
    visited_zero = [[False] * w for _ in range(h)]
    holes = []
    for r in range(inner_min_r, inner_max_r + 1):
        for c in range(inner_min_c, inner_max_c + 1):
            if output[r][c] == 0 and not visited_zero[r][c]:
                stack = [(r, c)]
                comp = []
                visited_zero[r][c] = True
                while stack:
                    pr, pc = stack.pop()
                    comp.append((pr, pc))
                    for nr, nc in neighbors(pr, pc):
                        if nr < inner_min_r or nr > inner_max_r or nc < inner_min_c or nc > inner_max_c:
                            continue
                        if visited_zero[nr][nc]:
                            continue
                        if output[nr][nc] != 0:
                            continue
                        visited_zero[nr][nc] = True
                        stack.append((nr, nc))
                holes.append(comp)

    # For each hole handle recursive placement
    for hole in holes:
        min_hr = min(p[0] for p in hole)
        max_hr = max(p[0] for p in hole)
        min_hc = min(p[1] for p in hole)
        max_hc = max(p[1] for p in hole)
        hole_h = max_hr - min_hr + 1
        hole_w = max_hc - min_hc + 1

        # Initial copy: scale main bitmap to fit inside the hole (nearest neighbour)
        # Choose initial size to be at most hole size while preserving aspect ratio as much as possible
        init_h = min(main_h, hole_h)
        init_w = min(main_w, hole_w)
        if init_h <= 0: init_h = 1
        if init_w <= 0: init_w = 1
        copy_bitmap = _resize_bitmap(main_bitmap, init_h, init_w)

        # Place initial bitmap centered in hole bounding box and overlay
        top = min_hr + (hole_h - init_h) // 2
        left = min_hc + (hole_w - init_w) // 2
        _paste_over(output, top, left, copy_bitmap, min_hr, min_hc, max_hr, max_hc)

        prev_bitmap = copy_bitmap
        # Iteratively scale down by 50% (floor) then rotate 90° cw and place centered
        while True:
            prev_h = len(prev_bitmap)
            prev_w = len(prev_bitmap[0]) if prev_h>0 else 0
            new_h = max(1, prev_h // 2)
            new_w = max(1, prev_w // 2)
            # If both dimensions are less than 2, stop the iterative placement and tile the smallest copy
            if new_h < 2 and new_w < 2:
                # build smallest copy (scale and rotate one last time to be consistent)
                smallest = _resize_bitmap(prev_bitmap, new_h, new_w)
                smallest = _rotate_cw(smallest)
                # Tile smallest copy across the whole hole to fill remaining area
                for rr in range(min_hr, max_hr + 1, len(smallest)):
                    for cc in range(min_hc, max_hc + 1, len(smallest[0])):
                        # determine paste top-left
                        ttop = rr
                        tleft = cc
                        _paste_over(output, ttop, tleft, smallest, min_hr, min_hc, max_hr, max_hc)
                break
            # scale prev_bitmap down then rotate
            scaled = _resize_bitmap(prev_bitmap, new_h, new_w)
            rotated = _rotate_cw(scaled)
            # place rotated centered
            rh = len(rotated)
            rw = len(rotated[0]) if rh>0 else 0
            top = min_hr + (hole_h - rh) // 2
            left = min_hc + (hole_w - rw) // 2
            _paste_over(output, top, left, rotated, min_hr, min_hc, max_hr, max_hc)
            prev_bitmap = rotated

    return {"input": ingrid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable grid (list of lists)
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height>0 else 0

    # Helpers
    def neighbors(r, c):
        for dr, dc in ((0,1),(0,-1),(1,0),(-1,0)):
            nr, nc = r+dr, c+dc
            if 0 <= nr < height and 0 <= nc < width:
                yield nr, nc

    def _resize_bitmap(bitmap, new_h, new_w):
        if new_h <= 0: new_h = 1
        if new_w <= 0: new_w = 1
        src_h = len(bitmap)
        src_w = len(bitmap[0]) if src_h > 0 else 0
        if src_h == 0 or src_w == 0:
            return [[0 for _ in range(new_w)] for _ in range(new_h)]
        out = [[0 for _ in range(new_w)] for _ in range(new_h)]
        for r in range(new_h):
            src_r = int(r * src_h / new_h)
            if src_r >= src_h:
                src_r = src_h - 1
            for c in range(new_w):
                src_c = int(c * src_w / new_w)
                if src_c >= src_w:
                    src_c = src_w - 1
                out[r][c] = bitmap[src_r][src_c]
        return out

    def _rotate_cw(bitmap):
        if not bitmap: return []
        h = len(bitmap)
        w = len(bitmap[0])
        return [[bitmap[h - 1 - r][c] for r in range(h)] for c in range(w)]

    def _paste_over(output, top, left, bitmap, bbox_minr, bbox_minc, bbox_maxr, bbox_maxc):
        h = len(output)
        w = len(output[0])
        bh = len(bitmap)
        bw = len(bitmap[0]) if bh>0 else 0
        for r in range(bh):
            for c in range(bw):
                tr = top + r
                tc = left + c
                if tr < bbox_minr or tr > bbox_maxr or tc < bbox_minc or tc > bbox_maxc:
                    continue
                if 0 <= tr < h and 0 <= tc < w:
                    output[tr][tc] = bitmap[r][c]

    # Detect frame color by inspecting border cells (excluding background 0)
    from collections import Counter
    border_colors = []
    for c in range(width):
        if grid[0][c] != 0:
            border_colors.append(grid[0][c])
        if grid[height-1][c] != 0:
            border_colors.append(grid[height-1][c])
    for r in range(height):
        if grid[r][0] != 0:
            border_colors.append(grid[r][0])
        if grid[r][width-1] != 0:
            border_colors.append(grid[r][width-1])
    if border_colors:
        frame_color = Counter(border_colors).most_common(1)[0][0]
    else:
        frame_color = None

    # Interior bounds
    inner_min_r = 0
    inner_max_r = height - 1
    inner_min_c = 0
    inner_max_c = width - 1
    # shrink inside borders if frame is border
    if frame_color is not None:
        # find first/last rows that are not frame color
        # assume a single continuous frame around the central area
        for r in range(height):
            row_vals = set(grid[r])
            if frame_color in row_vals:
                continue
            inner_min_r = r
            break
        for r in range(height-1, -1, -1):
            row_vals = set(grid[r])
            if frame_color in row_vals:
                continue
            inner_max_r = r
            break
        for c in range(width):
            col_vals = set(grid[r][c] for r in range(height))
            if frame_color in col_vals:
                continue
            inner_min_c = c
            break
        for c in range(width-1, -1, -1):
            col_vals = set(grid[r][c] for r in range(height))
            if frame_color in col_vals:
                continue
            inner_max_c = c
            break
    # ensure bounds are valid
    inner_min_r = max(0, inner_min_r)
    inner_min_c = max(0, inner_min_c)
    inner_max_r = min(height-1, inner_max_r)
    inner_max_c = min(width-1, inner_max_c)

    # Detect carving color: choose the interior non-zero, non-frame color with minimal frequency
    counts = Counter()
    for r in range(inner_min_r, inner_max_r+1):
        for c in range(inner_min_c, inner_max_c+1):
            v = grid[r][c]
            if v == 0 or v == frame_color:
                continue
            counts[v] += 1
    if counts:
        carving_color = min(counts.items(), key=lambda x: (x[1], x[0]))[0]
    else:
        carving_color = None

    # Make a working copy to produce output
    output = [row[:] for row in grid]

    # Step 1: Carving
    if carving_color is not None:
        for r in range(inner_min_r, inner_max_r+1):
            for c in range(inner_min_c, inner_max_c+1):
                if output[r][c] == carving_color:
                    output[r][c] = 0

    # Step 2: Find main pattern: largest contiguous non-background, non-frame region
    visited = [[False]*width for _ in range(height)]
    largest = []
    for r in range(inner_min_r, inner_max_r+1):
        for c in range(inner_min_c, inner_max_c+1):
            if visited[r][c]:
                continue
            if output[r][c] == 0 or output[r][c] == frame_color:
                continue
            # BFS
            stack = [(r,c)]
            comp = []
            visited[r][c] = True
            while stack:
                pr, pc = stack.pop()
                comp.append((pr, pc))
                for nr, nc in neighbors(pr, pc):
                    if nr < inner_min_r or nr > inner_max_r or nc < inner_min_c or nc > inner_max_c:
                        continue
                    if visited[nr][nc]:
                        continue
                    if output[nr][nc] == 0 or output[nr][nc] == frame_color:
                        continue
                    visited[nr][nc] = True
                    stack.append((nr, nc))
            if len(comp) > len(largest):
                largest = comp

    if not largest:
        return tuple(tuple(row) for row in output)

    # Extract main bitmap
    minr = min(p[0] for p in largest)
    maxr = max(p[0] for p in largest)
    minc = min(p[1] for p in largest)
    maxc = max(p[1] for p in largest)
    main_h = maxr - minr + 1
    main_w = maxc - minc + 1
    main_bitmap = [[0 for _ in range(main_w)] for _ in range(main_h)]
    largest_set = set(largest)
    for rr in range(main_h):
        for cc in range(main_w):
            pr = minr + rr
            pc = minc + cc
            if (pr, pc) in largest_set:
                main_bitmap[rr][cc] = output[pr][pc]
            else:
                main_bitmap[rr][cc] = 0

    # Step 3: Find holes (zero-regions inside the interior)
    visited_zero = [[False]*width for _ in range(height)]
    holes = []
    for r in range(inner_min_r, inner_max_r+1):
        for c in range(inner_min_c, inner_max_c+1):
            if output[r][c] == 0 and not visited_zero[r][c]:
                stack = [(r,c)]
                comp = []
                visited_zero[r][c] = True
                while stack:
                    pr, pc = stack.pop()
                    comp.append((pr, pc))
                    for nr, nc in neighbors(pr, pc):
                        if nr < inner_min_r or nr > inner_max_r or nc < inner_min_c or nc > inner_max_c:
                            continue
                        if visited_zero[nr][nc]:
                            continue
                        if output[nr][nc] != 0:
                            continue
                        visited_zero[nr][nc] = True
                        stack.append((nr, nc))
                holes.append(comp)

    # For each hole perform recursive reconstruction just like the generator
    for hole in holes:
        min_hr = min(p[0] for p in hole)
        max_hr = max(p[0] for p in hole)
        min_hc = min(p[1] for p in hole)
        max_hc = max(p[1] for p in hole)
        hole_h = max_hr - min_hr + 1
        hole_w = max_hc - min_hc + 1

        # Initial copy fit
        init_h = min(main_h, hole_h)
        init_w = min(main_w, hole_w)
        if init_h <= 0: init_h = 1
        if init_w <= 0: init_w = 1
        copy_bitmap = _resize_bitmap(main_bitmap, init_h, init_w)

        top = min_hr + (hole_h - init_h)//2
        left = min_hc + (hole_w - init_w)//2
        _paste_over(output, top, left, copy_bitmap, min_hr, min_hc, max_hr, max_hc)

        prev_bitmap = copy_bitmap
        while True:
            prev_h = len(prev_bitmap)
            prev_w = len(prev_bitmap[0]) if prev_h>0 else 0
            new_h = max(1, prev_h // 2)
            new_w = max(1, prev_w // 2)
            if new_h < 2 and new_w < 2:
                smallest = _resize_bitmap(prev_bitmap, new_h, new_w)
                smallest = _rotate_cw(smallest)
                for rr in range(min_hr, max_hr+1, len(smallest)):
                    for cc in range(min_hc, max_hc+1, len(smallest[0])):
                        ttop = rr
                        tleft = cc
                        _paste_over(output, ttop, tleft, smallest, min_hr, min_hc, max_hr, max_hc)
                break
            scaled = _resize_bitmap(prev_bitmap, new_h, new_w)
            rotated = _rotate_cw(scaled)
            rh = len(rotated)
            rw = len(rotated[0]) if rh>0 else 0
            top = min_hr + (hole_h - rh)//2
            left = min_hc + (hole_w - rw)//2
            _paste_over(output, top, left, rotated, min_hr, min_hc, max_hr, max_hc)
            prev_bitmap = rotated

    return tuple(tuple(row) for row in output)

