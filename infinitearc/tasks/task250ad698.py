# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 250ad698
Difficulty: very hard

=== Tags ===
- Elastic wave
- Feedback route
- Stepwise color transition
- Hole punch pattern

=== Description ===
The task involves input grids composed of a solid background color (0) overlaid
with a contiguous region of a single non-zero color (e.g., color 1). Within this
region, a "hole punch pattern" appears as a grid of precisely positioned
background cells (holes) arranged in a fractal-like recursive structure. Each
hole is surrounded by non-hole cells (the colored region), forming a complex
obstacle map.   The output grid transforms the input by simulating "elastic
waves" emanating from the edges of every hole. Waves propagate outward in four
cardinal directions (up, down, left, right) at one cell per step, with each step
incrementing the color value sequentially (1→2→3→...→9→1→2...). Upon
encountering a non-hole cell (obstacle), waves reflect perfectly (mirroring the
direction of travel), continuing their propagation with the next color in the
sequence. Crucially, waves interact with the grid's geometry through multiple
reflections, creating overlapping paths that must be resolved by prioritizing
the earliest step count for each cell. The "feedback route" manifests as waves
bouncing between obstacles in a consistent, non-random pattern, while the
"stepwise color transition" ensures the output visually encodes the wave's
progression through the grid. The output grid retains the input's hole positions
but replaces all other cells with the wave's color at the moment of first
arrival, forming a dynamic, recursive wave pattern that directly extends the
input's hole punch motif.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque

def place_holes(grid, r1, c1, r2, c2):
    if r2 - r1 < 2 or c2 - c1 < 2:
        return
    mid_r = (r1 + r2) // 2
    mid_c = (c1 + c2) // 2
    if random.random() < 0.5 and grid[mid_r][mid_c] == 1:
        grid[mid_r][mid_c] = 0
    place_holes(grid, r1, c1, mid_r, mid_c)
    place_holes(grid, r1, mid_c, mid_r, c2)
    place_holes(grid, mid_r, c1, r2, mid_c)
    place_holes(grid, mid_r, mid_c, r2, c2)

def simulate_waves(grid):
    n = len(grid)
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    min_step = [[10**9] * n for _ in range(n)]
    q = deque()
    
    for r in range(n):
        for c in range(n):
            if grid[r][c] == 0:
                for idx, (dr, dc) in enumerate(directions):
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < n and 0 <= nc < n and grid[nr][nc] == 1:
                        nnr, nnc = nr + dr, nc + dc
                        if 0 <= nnr < n and 0 <= nnc < n and grid[nnr][nnc] == 0:
                            if 1 < min_step[nnr][nnc]:
                                min_step[nnr][nnc] = 1
                                q.append((nnr, nnc, idx, 1))

    while q:
        r, c, direction, step = q.popleft()
        if step != min_step[r][c]:
            continue
        dr, dc = directions[direction]
        nr, nc = r + dr, c + dc
        if not (0 <= nr < n and 0 <= nc < n):
            continue
        
        if grid[nr][nc] == 1:
            new_direction = (direction + 2) % 4
            dr_new, dc_new = directions[new_direction]
            nr_new, nc_new = r + dr_new, c + dc_new
            if 0 <= nr_new < n and 0 <= nc_new < n:
                new_step = step + 1
                if new_step < min_step[nr_new][nc_new]:
                    min_step[nr_new][nc_new] = new_step
                    q.append((nr_new, nc_new, new_direction, new_step))
        else:
            new_step = step + 1
            if new_step < min_step[nr][nc]:
                min_step[nr][nc] = new_step
                q.append((nr, nc, direction, new_step))

    output = [[0]*n for _ in range(n)]
    for r in range(n):
        for c in range(n):
            if min_step[r][c] != 10**9:
                color = (min_step[r][c] - 1) % 9 + 1
                output[r][c] = color
    return output

def generate():
    n = random.randint(15, 25)
    grid = [[0]*n for _ in range(n)]
    
    for r in range(2, n-2):
        for c in range(2, n-2):
            grid[r][c] = 1
    
    place_holes(grid, 2, 2, n-3, n-3)
    
    output = simulate_waves(grid)
    
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def simulate_waves(grid):
    n = len(grid)
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    min_step = [[10**9] * n for _ in range(n)]
    q = deque()
    
    for r in range(n):
        for c in range(n):
            if grid[r][c] == 0:
                for idx, (dr, dc) in enumerate(directions):
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < n and 0 <= nc < n and grid[nr][nc] == 1:
                        nnr, nnc = nr + dr, nc + dc
                        if 0 <= nnr < n and 0 <= nnc < n and grid[nnr][nnc] == 0:
                            if 1 < min_step[nnr][nnc]:
                                min_step[nnr][nnc] = 1
                                q.append((nnr, nnc, idx, 1))

    while q:
        r, c, direction, step = q.popleft()
        if step != min_step[r][c]:
            continue
        dr, dc = directions[direction]
        nr, nc = r + dr, c + dc
        if not (0 <= nr < n and 0 <= nc < n):
            continue
        
        if grid[nr][nc] == 1:
            new_direction = (direction + 2) % 4
            dr_new, dc_new = directions[new_direction]
            nr_new, nc_new = r + dr_new, c + dc_new
            if 0 <= nr_new < n and 0 <= nc_new < n:
                new_step = step + 1
                if new_step < min_step[nr_new][nc_new]:
                    min_step[nr_new][nc_new] = new_step
                    q.append((nr_new, nc_new, new_direction, new_step))
        else:
            new_step = step + 1
            if new_step < min_step[nr][nc]:
                min_step[nr][nc] = new_step
                q.append((nr, nc, direction, new_step))

    output = [[0]*n for _ in range(n)]
    for r in range(n):
        for c in range(n):
            if min_step[r][c] != 10**9:
                color = (min_step[r][c] - 1) % 9 + 1
                output[r][c] = color
    return output

def p(input_grid):
    return simulate_waves(input_grid)
