# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 0b0e44aa
Difficulty: very hard

=== Tags ===
- Feature binding
- Magnetic path alignment
- Align to corner
- Bounce

=== Description ===
**Task Name: Magnetic Corner Alignment**  **Tags:** Feature binding, Magnetic
path alignment, Align to corner, Bounce  **Description:**  Input grids feature a
background color (0) and multiple colored paths (1-9) on the grid. Each path is
a contiguous sequence of cells (4-connected) of a single color, not overlapping
with other paths. Each color corresponds to a target corner: color 1 → top-left
(TL), color 2 → top-right (TR), color 3 → bottom-left (BL), color 4 → bottom-
right (BR). Colors 5-9 are ignored (treated as background).  The output grid
transforms each path to align with its corresponding corner through the
following rules:  1. **Path Bouncing:** Each path moves in its initial direction
(determined by the path's slope in the input grid). When a path segment hits a
grid edge (top, bottom, left, right), it bounces by reversing direction along
the axis of the edge (e.g., moving right → hits right edge → moves left).  2.
**Magnetic Alignment:** Once a path segment is within a 2-cell radius of its
target corner (e.g., for TL, cells within rows 0-1 and columns 0-1), it bends
toward the corner. Bending occurs by adjusting the path's direction to move
directly toward the corner, overriding bounce rules until alignment is achieved.
3. **Path Completion:** The transformation continues until the path's endpoint
reaches the target corner. The path does not overlap with other paths or extend
beyond grid boundaries. Background cells remain unchanged.  4. **Feature
Binding:** The path's color (feature) is bound to its target corner (binding),
requiring all transformations to respect this binding.  **Example Input:** - A
horizontal path of color 1 (TL) in the center of the grid (moving right). - A
diagonal path of color 3 (BL) moving up-left.  **Example Output:** - The color 1
path bounces off the right edge, then top edge, then bends toward TL corner,
ending at (0,0). - The color 3 path bounces off the top edge, then left edge,
then bends toward BL corner, ending at (height-1, 0).  The task requires
identifying each path's initial direction, simulating bounces off edges, and
applying magnetic bending to reach the target corner, resulting in a grid where
all paths terminate at their assigned corners.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, randint

def sign(x):
    if x == 0:
        return 0
    return 1 if x > 0 else -1


def generate():
    """
    Generate an ARC-style input/output pair for the Magnetic Corner Alignment task.
    The generator creates four short L-shaped 4-connected paths (one for each color 1-4),
    each oriented so the net direction points toward its assigned corner. Then it
    simulates the "magnetic bouncing" movement from the path endpoint until the path
    reaches its corner, drawing the visited cells into the output grid.
    """
    # Try a few times if placement collisions occur
    global_attempt = 0
    while True:
        global_attempt += 1
        # Dimensions: choose a reasonably sized grid but not too large
        width = randint(8, 22)
        height = randint(8, 22)
        # Make sure there's room for a small L-shaped path and corner areas
        if width < 6 or height < 6:
            continue

        input_grid = grid(width, height, 0)

        # Storage for placed input paths
        path_by_color = {}
        used = set()  # cells already used by input paths

        success = True

        for color in [1, 2, 3, 4]:
            # Determine the net direction signs that point toward the target corner
            if color == 1:  # top-left
                dr_sign, dc_sign = -1, -1
            elif color == 2:  # top-right
                dr_sign, dc_sign = -1, 1
            elif color == 3:  # bottom-left
                dr_sign, dc_sign = 1, -1
            else:  # color == 4 bottom-right
                dr_sign, dc_sign = 1, 1

            placed = False
            # Try to place a short L-shaped 4-connected path such that the net
            # vector from the first cell to the last has both row and column
            # components (so the movement will be able to move in both axes).
            for attempt in range(80):
                # segment lengths (at least 1 in each axis)
                max_k1 = max(1, min(4, height - 4))
                max_k2 = max(1, min(4, width - 4))
                k1 = randint(1, max_k1)
                k2 = randint(1, max_k2)

                # choose a starting cell so that both the vertical and horizontal
                # segments stay in a safe interior band (avoid being on immediate edges)
                low_r, high_r = 2, height - 3
                low_c, high_c = 2, width - 3
                if high_r < low_r or high_c < low_c:
                    break

                if dr_sign == 1:
                    r_min = low_r
                    r_max = high_r - k1
                else:
                    r_min = low_r + k1
                    r_max = high_r
                if r_min > r_max:
                    continue
                r_start = randint(r_min, r_max)

                if dc_sign == 1:
                    c_min = low_c
                    c_max = high_c - k2
                else:
                    c_min = low_c + k2
                    c_max = high_c
                if c_min > c_max:
                    continue
                c_start = randint(c_min, c_max)

                # build the L-shaped path: vertical segment then horizontal segment
                path = []
                cur_r, cur_c = r_start, c_start
                path.append((cur_r, cur_c))
                for _ in range(k1):
                    cur_r += dr_sign
                    path.append((cur_r, cur_c))
                for _ in range(k2):
                    cur_c += dc_sign
                    path.append((cur_r, cur_c))

                # validate path (bounds and no overlap with previously placed paths)
                invalid = False
                for (rr, cc) in path:
                    if rr < 0 or rr >= height or cc < 0 or cc >= width:
                        invalid = True
                        break
                    if (rr, cc) in used:
                        invalid = True
                        break
                if invalid:
                    continue

                # place the path in the input grid
                for (rr, cc) in path:
                    input_grid[rr][cc] = color
                    used.add((rr, cc))
                path_by_color[color] = path
                placed = True
                break

            if not placed:
                success = False
                break

        if not success:
            # If placement failed, try again with a new random grid
            if global_attempt > 200:
                # extremely unlikely; reset random seed bits and continue
                random.seed()
            continue

        # Now simulate each path moving from its endpoint toward its corner,
        # painting visited cells into the output grid. If any path would collide
        # with another path's output, abort and retry the whole generation.
        output_grid = [list(row) for row in input_grid]
        output_occupied = set(used)  # cells already occupied (input paths)
        collision = False

        for color in [1, 2, 3, 4]:
            path = path_by_color[color]
            first = path[0]
            last = path[-1]
            # initial direction is the sign of the vector from first to last
            direction = (sign(last[0] - first[0]), sign(last[1] - first[1]))
            dr, dc = direction

            # choose the endpoint that lies 'forward' along the direction
            val_first = first[0] * dr + first[1] * dc
            val_last = last[0] * dr + last[1] * dc
            current = last if val_last >= val_first else first

            # corner target
            if color == 1:
                target = (0, 0)
            elif color == 2:
                target = (0, width - 1)
            elif color == 3:
                target = (height - 1, 0)
            else:
                target = (height - 1, width - 1)

            own_input = set(path)
            steps = 0
            max_steps = (width + height) * 20
            # Simulate until we reach the target or we detect a collision / timeout
            while current != target and steps < max_steps:
                steps += 1
                cr, cc = current
                # Magnetic alignment: if within the 2x2 corner block (rows 0-1 / cols 0-1 etc)
                if abs(cr - target[0]) <= 1 and abs(cc - target[1]) <= 1:
                    # prefer aligning horizontally first (as in the specification example)
                    if cc != target[1]:
                        dc = -1 if cc > target[1] else 1
                        dr = 0
                    else:
                        dr = -1 if cr > target[0] else 1
                        dc = 0
                else:
                    dr, dc = direction
                    nr = cr + dr
                    nc = cc + dc
                    # bounce on edges
                    if nr < 0 or nr >= height:
                        dr = -dr
                    if nc < 0 or nc >= width:
                        dc = -dc
                direction = (dr, dc)

                nr = cr + dr
                nc = cc + dc

                # If this step would enter another path's cell (not our own input cells), that's a collision
                if (nr, nc) in output_occupied and (nr, nc) not in own_input:
                    collision = True
                    break

                # mark the step in the output
                output_grid[nr][nc] = color
                output_occupied.add((nr, nc))
                current = (nr, nc)

            if collision or current != target:
                success = False
                break

        if not success:
            # try again with a different random layout
            if global_attempt > 200:
                random.seed()
            continue

        # Finally, ensure we actually changed the grid (input != output)
        if output_grid == input_grid:
            # extremely unlikely, try again
            continue

        return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height else 0

    def sign(x):
        if x == 0:
            return 0
        return 1 if x > 0 else -1

    # Start from the input (we preserve the input paths and then draw the simulated traces)
    out = [row[:] for row in grid]

    for color in [1, 2, 3, 4]:
        # collect cells of this color
        cells = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == color]
        if not cells:
            continue

        pos_set = set(cells)
        # compute degrees (4-connected) to try to find endpoints
        degrees = {}
        for (r, c) in cells:
            deg = 0
            for drn, dcn in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                if (r + drn, c + dcn) in pos_set:
                    deg += 1
            degrees[(r, c)] = deg

        endpoints = [p for p, d in degrees.items() if d == 1]
        if len(endpoints) >= 2:
            e1, e2 = endpoints[0], endpoints[1]
        else:
            # fallback: pick two farthest cells by Manhattan distance
            e1 = cells[0]
            e2 = cells[0]
            maxd = -1
            for a in cells:
                for b in cells:
                    d = abs(a[0] - b[0]) + abs(a[1] - b[1])
                    if d > maxd:
                        maxd = d
                        e1, e2 = a, b

        # Choose the endpoint that is closer to the target corner as the starting point.
        if color == 1:
            target = (0, 0)
            dir_r, dir_c = -1, -1
        elif color == 2:
            target = (0, width - 1)
            dir_r, dir_c = -1, 1
        elif color == 3:
            target = (height - 1, 0)
            dir_r, dir_c = 1, -1
        else:
            target = (height - 1, width - 1)
            dir_r, dir_c = 1, 1

        # pick the endpoint closer (Manhattan) to the corner as the current starting cell
        d1 = abs(e1[0] - target[0]) + abs(e1[1] - target[1])
        d2 = abs(e2[0] - target[0]) + abs(e2[1] - target[1])
        current = e1 if d1 <= d2 else e2

        direction = (dir_r, dir_c)
        own_input = set(cells)
        steps = 0
        max_steps = (width + height) * 20

        # Simulate movement using the same rules as the generator
        while current != target and steps < max_steps:
            steps += 1
            cr, cc = current
            dr, dc = direction

            # magnetic alignment: when inside the 2x2 corner block
            if abs(cr - target[0]) <= 1 and abs(cc - target[1]) <= 1:
                if cc != target[1]:
                    dc = -1 if cc > target[1] else 1
                    dr = 0
                else:
                    dr = -1 if cr > target[0] else 1
                    dc = 0
                direction = (dr, dc)
                nr = cr + dr
                nc = cc + dc
            else:
                nr = cr + dr
                nc = cc + dc
                if nr < 0 or nr >= height:
                    dr = -dr
                if nc < 0 or nc >= width:
                    dc = -dc
                direction = (dr, dc)
                nr = cr + dr
                nc = cc + dc

            # paint the step onto the output
            if 0 <= nr < height and 0 <= nc < width:
                out[nr][nc] = color
            else:
                break

            current = (nr, nc)

    return out

