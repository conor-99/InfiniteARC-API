# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: b53598a6
Difficulty: medium–hard

=== Tags ===
- Mask based logic
- Diagonal weaving
- Multi stage color switch
- Pattern activation

=== Description ===
Input grids are 15×15 to 25×25 matrices with a background color (0) and a
primary diagonal pattern of consistent top-left-to-bottom-right lines (color 1)
covering the entire grid. Overlaid on this pattern are multiple disjoint mask
regions (color 2), each forming a contiguous rectangle of at least 3×3 cells
that intersect the primary pattern. These masks are spatially arranged such that
their edges align with grid lines and they never touch or overlap.  The output
grid transforms through two sequential visual operations. First, all primary
pattern cells (color 1) within any mask region are replaced with color 3, and
their diagonal direction is reversed (top-left-to-bottom-right becomes top-
right-to-bottom-left), creating an interlaced "weaving" effect where diagonals
cross over mask boundaries. Second, all primary pattern cells outside mask
regions are replaced with color 4 while maintaining their original diagonal
direction. The background remains color 0, and all mask regions (color 2) are
preserved as visual markers. This transformation creates a layered visual effect
where diagonal lines appear to weave through mask regions while maintaining
consistent color coding for different pattern stages.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    size = random.randint(15, 25)
    grid = [[0]*size for _ in range(size)]
    
    # Set primary pattern: (r - c) % 2 == 0
    for r in range(size):
        for c in range(size):
            if (r - c) % 2 == 0:
                grid[r][c] = 1
    
    masks = []
    num_masks = random.randint(2, 5)
    for _ in range(num_masks):
        while True:
            r1 = random.randint(0, size - 3)
            c1 = random.randint(0, size - 3)
            r2 = random.randint(r1 + 2, size - 1)
            c2 = random.randint(c1 + 2, size - 1)
            overlap = False
            for (mr1, mc1, mr2, mc2) in masks:
                if not (r2 < mr1 or mr2 < r1 or c2 < mc1 or mc2 < c1):
                    overlap = True
                    break
            if not overlap:
                masks.append((r1, c1, r2, c2))
                break
    
    # Apply masks
    for (r1, c1, r2, c2) in masks:
        for r in range(r1, r2 + 1):
            for c in range(c1, c2 + 1):
                grid[r][c] = 2
    
    # Generate output grid
    output = [[0]*size for _ in range(size)]
    for r in range(size):
        for c in range(size):
            if grid[r][c] == 2:
                if (r - c) % 2 == 0:
                    output[r][c] = 3
                else:
                    output[r][c] = 2
            elif grid[r][c] == 1:
                output[r][c] = 4
            else:
                output[r][c] = 0
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    n = len(grid)
    for r in range(n):
        for c in range(n):
            if grid[r][c] == 2:
                if (r - c) % 2 == 0:
                    grid[r][c] = 3
            elif grid[r][c] == 1:
                grid[r][c] = 4
    return tuple(tuple(row) for row in grid)
