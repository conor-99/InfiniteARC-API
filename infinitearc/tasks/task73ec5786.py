# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 73ec5786
Difficulty: mediumâ€“hard

=== Tags ===
- Follow color path to destination
- Fit to bounding box
- Draw line to nearest object of same color

=== Description ===
Input grids feature a background color (0) overlaid with multiple disconnected
clusters of identical colors (1-9), each cluster forming a contiguous region of
the same color. Each cluster represents a distinct "object" with no overlapping
or touching between different colors. The task requires generating an output
grid where, for each color present in the input, a straight line is drawn in
that color connecting every cluster to the nearest other cluster of the same
color. The line must traverse only background cells (0), avoiding all non-
background cells (including other clusters and the background's own color), and
must follow the shortest possible path between the two clusters (allowing
diagonal, horizontal, or vertical movement). If a cluster has no other cluster
of the same color, no line is drawn. The output grid must preserve all input
clusters intact while adding these connecting lines. The "fit to bounding box"
rule ensures that the line remains within the minimal bounding rectangle defined
by the two clusters being connected, and the "follow color path to destination"
rule implies that the line directly extends from one cluster to its nearest
same-color counterpart, forming a visual path that "leads" to the destination
cluster.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque
from common import grid

# Generator for ARC task 477: connect nearest clusters of same color with shortest 8-neighbor paths

def chebyshev(a, b):
    return max(abs(a[0] - b[0]), abs(a[1] - b[1]))


def find_clusters(g):
    height = len(g)
    width = len(g[0])
    visited = [[False] * width for _ in range(height)]
    clusters_by_color = {}
    for r in range(height):
        for c in range(width):
            v = g[r][c]
            if v == 0 or visited[r][c]:
                continue
            col = v
            stack = [(r, c)]
            visited[r][c] = True
            cluster = []
            while stack:
                cr, cc = stack.pop()
                cluster.append((cr, cc))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and g[nr][nc] == col:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            clusters_by_color.setdefault(col, []).append(cluster)
    return clusters_by_color


def cluster_bbox(cluster):
    rs = [p[0] for p in cluster]
    cs = [p[1] for p in cluster]
    return min(rs), max(rs), min(cs), max(cs)


def anchor_zeros_within_rect(g, cluster, rect):
    minr, maxr, minc, maxc = rect
    height = len(g)
    width = len(g[0])
    zeros = set()
    for (r, c) in cluster:
        for dr in (-1, 0, 1):
            for dc in (-1, 0, 1):
                nr, nc = r + dr, c + dc
                if nr < minr or nr > maxr or nc < minc or nc > maxc:
                    continue
                if not (0 <= nr < height and 0 <= nc < width):
                    continue
                if g[nr][nc] == 0:
                    zeros.add((nr, nc))
    return sorted(zeros)


def bfs_zero_path(g, start, end, rect):
    # BFS on zeros only, 8-neighbor movement, restricted to rect (inclusive)
    minr, maxr, minc, maxc = rect
    height = len(g)
    width = len(g[0])
    dirs = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
    q = deque()
    q.append(start)
    parents = {start: None}
    visited = {start}
    while q:
        cur = q.popleft()
        if cur == end:
            # reconstruct
            path = []
            node = cur
            while node is not None:
                path.append(node)
                node = parents[node]
            path.reverse()
            return path
        for dr, dc in dirs:
            nr, nc = cur[0] + dr, cur[1] + dc
            if not (minr <= nr <= maxr and minc <= nc <= maxc):
                continue
            if not (0 <= nr < height and 0 <= nc < width):
                continue
            if g[nr][nc] != 0:
                continue
            nxt = (nr, nc)
            if nxt in visited:
                continue
            visited.add(nxt)
            parents[nxt] = cur
            q.append(nxt)
    return None


def generate():
    # Try generating a configuration that allows connecting nearest same-color clusters
    tries = 0
    while True:
        tries += 1
        if tries > 300:
            # fallback: reduce constraints
            pass

        width = random.randint(9, 20)
        height = random.randint(9, 20)

        # Ensure stripe width >= 3 so there's room for clusters and margins
        max_colors = max(2, min(5, width // 3))
        num_stripes = random.randint(2, max_colors)

        # compute stripe intervals (vertical stripes)
        stripe_width = width // num_stripes
        stripes = []
        for i in range(num_stripes):
            cs = i * stripe_width
            ce = (i + 1) * stripe_width - 1 if i < num_stripes - 1 else width - 1
            stripes.append((cs, ce))

        # pick distinct colors for stripes
        colors = random.sample(range(1, 10), num_stripes)

        # create empty grid and reserved mask (to avoid touching clusters)
        ing = grid(width, height, 0)
        reserved = [[False] * width for _ in range(height)]

        # we'll avoid placing clusters on the outermost border to guarantee adjacency zeros
        rmin = 1
        rmax = height - 2

        cluster_map = {}  # color -> list of clusters
        success = True
        for stripe_idx, (cs, ce) in enumerate(stripes):
            color = colors[stripe_idx]
            # effective placement columns leave 1-column margin inside stripe
            place_cmin = cs + 1
            place_cmax = ce - 1
            if place_cmin > place_cmax:
                success = False
                break

            # choose number of clusters in this stripe
            max_clusters = 4
            # ensure there is space: approximate area
            area = (place_cmax - place_cmin + 1) * (rmax - rmin + 1)
            max_possible = max(1, min(max_clusters, area // 3))
            num_clusters = random.randint(1, max_possible)

            clusters = []
            attempts = 0
            shapes = [(1, 1), (1, 2), (2, 1), (2, 2)]
            while len(clusters) < num_clusters and attempts < 300:
                attempts += 1
                # pick a shape that fits
                h, w = random.choice(shapes)
                if (rmax - rmin + 1) < h or (place_cmax - place_cmin + 1) < w:
                    continue
                r0 = random.randint(rmin, rmax - h + 1)
                c0 = random.randint(place_cmin, place_cmax - w + 1)
                # check surrounding 1-cell ring is free (to avoid touching other clusters)
                ok = True
                for rr in range(r0 - 1, r0 + h + 1):
                    for cc in range(c0 - 1, c0 + w + 1):
                        if 0 <= rr < height and 0 <= cc < width and reserved[rr][cc]:
                            ok = False
                            break
                    if not ok:
                        break
                if not ok:
                    continue
                # place cluster
                cluster_cells = []
                for rr in range(r0, r0 + h):
                    for cc in range(c0, c0 + w):
                        ing[rr][cc] = color
                        cluster_cells.append((rr, cc))
                # mark reserved ring
                for rr in range(r0 - 1, r0 + h + 1):
                    for cc in range(c0 - 1, c0 + w + 1):
                        if 0 <= rr < height and 0 <= cc < width:
                            reserved[rr][cc] = True
                clusters.append(cluster_cells)
            if len(clusters) == 0:
                success = False
                break
            cluster_map[color] = clusters

        if not success:
            continue

        # ensure at least one color has multiple clusters so that at least one connection will be drawn
        multi = [c for c, cl in cluster_map.items() if len(cl) >= 2]
        if not multi:
            # force one stripe to have 2 clusters: pick a stripe and try to add a second cluster
            stripe_idx = random.randrange(len(stripes))
            color = colors[stripe_idx]
            cs, ce = stripes[stripe_idx]
            place_cmin = cs + 1
            place_cmax = ce - 1
            added = False
            for attempts in range(300):
                h, w = random.choice([(1, 1), (1, 2), (2, 1), (2, 2)])
                if (rmax - rmin + 1) < h or (place_cmax - place_cmin + 1) < w:
                    continue
                r0 = random.randint(rmin, rmax - h + 1)
                c0 = random.randint(place_cmin, place_cmax - w + 1)
                ok = True
                for rr in range(r0 - 1, r0 + h + 1):
                    for cc in range(c0 - 1, c0 + w + 1):
                        if 0 <= rr < height and 0 <= cc < width and reserved[rr][cc]:
                            ok = False
                            break
                    if not ok:
                        break
                if not ok:
                    continue
                cluster_cells = []
                for rr in range(r0, r0 + h):
                    for cc in range(c0, c0 + w):
                        ing[rr][cc] = color
                        cluster_cells.append((rr, cc))
                for rr in range(r0 - 1, r0 + h + 1):
                    for cc in range(c0 - 1, c0 + w + 1):
                        if 0 <= rr < height and 0 <= cc < width:
                            reserved[rr][cc] = True
                cluster_map[color].append(cluster_cells)
                added = True
                break
            if not added:
                # fail and retry overall
                continue

        # Now try to create output by connecting each cluster to its nearest same-color cluster
        out = [row[:] for row in ing]

        # We'll verify that for each cluster we can find an anchor pair and a zero path inside the bounding rectangle
        failed_connection = False
        for color, clusters in list(cluster_map.items()):
            if len(clusters) < 2:
                continue
            for i, cluster_a in enumerate(clusters):
                # compute minimal distances to all other clusters
                distances = {}
                for j, cluster_b in enumerate(clusters):
                    if i == j:
                        continue
                    # compute minimal chebyshev distance between any pixel pairs
                    dmin = None
                    for pa in cluster_a:
                        for pb in cluster_b:
                            d = chebyshev(pa, pb)
                            if dmin is None or d < dmin:
                                dmin = d
                    distances[j] = dmin
                if not distances:
                    continue
                min_dist = min(distances.values())
                # pick candidate cluster indices with min distance; tie-break by cluster bbox top-left
                candidates = [j for j, d in distances.items() if d == min_dist]
                nearest_j = min(candidates, key=lambda j: (cluster_bbox(clusters[j])[0], cluster_bbox(clusters[j])[2]))

                cluster_b = clusters[nearest_j]
                # bounding rect for the two clusters (inclusive)
                a_minr, a_maxr, a_minc, a_maxc = cluster_bbox(cluster_a)
                b_minr, b_maxr, b_minc, b_maxc = cluster_bbox(cluster_b)
                rect = (min(a_minr, b_minr), max(a_maxr, b_maxr), min(a_minc, b_minc), max(a_maxc, b_maxc))
                # find adjacent zero anchors inside rect
                anchors_a = anchor_zeros_within_rect(ing, cluster_a, rect)
                anchors_b = anchor_zeros_within_rect(ing, cluster_b, rect)
                if not anchors_a or not anchors_b:
                    failed_connection = True
                    break
                # choose anchor pair with minimal chebyshev distance; tie-break lexicographically
                best_pair = None
                best_d = None
                for sa in anchors_a:
                    for sb in anchors_b:
                        d = chebyshev(sa, sb)
                        pair = (sa, sb)
                        if best_d is None or d < best_d or (d == best_d and pair < best_pair):
                            best_d = d
                            best_pair = pair
                if best_pair is None:
                    failed_connection = True
                    break
                start, end = best_pair
                path = bfs_zero_path(ing, start, end, rect)
                if path is None:
                    failed_connection = True
                    break
                # draw path (only zeros will be overwritten)
                for (pr, pc) in path:
                    if out[pr][pc] == 0:
                        out[pr][pc] = color
            if failed_connection:
                break

        if failed_connection:
            continue

        # Guarantee output differs from input
        if out == ing:
            continue

        return {"input": ing, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque


def chebyshev(a, b):
    return max(abs(a[0] - b[0]), abs(a[1] - b[1]))


def find_clusters(g):
    height = len(g)
    width = len(g[0])
    visited = [[False] * width for _ in range(height)]
    clusters_by_color = {}
    for r in range(height):
        for c in range(width):
            v = g[r][c]
            if v == 0 or visited[r][c]:
                continue
            col = v
            stack = [(r, c)]
            visited[r][c] = True
            cluster = []
            while stack:
                cr, cc = stack.pop()
                cluster.append((cr, cc))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and g[nr][nc] == col:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            clusters_by_color.setdefault(col, []).append(cluster)
    return clusters_by_color


def cluster_bbox(cluster):
    rs = [p[0] for p in cluster]
    cs = [p[1] for p in cluster]
    return min(rs), max(rs), min(cs), max(cs)


def anchor_zeros_within_rect(g, cluster, rect):
    minr, maxr, minc, maxc = rect
    height = len(g)
    width = len(g[0])
    zeros = set()
    for (r, c) in cluster:
        for dr in (-1, 0, 1):
            for dc in (-1, 0, 1):
                nr, nc = r + dr, c + dc
                if nr < minr or nr > maxr or nc < minc or nc > maxc:
                    continue
                if not (0 <= nr < height and 0 <= nc < width):
                    continue
                if g[nr][nc] == 0:
                    zeros.add((nr, nc))
    return sorted(zeros)


def bfs_zero_path(g, start, end, rect):
    minr, maxr, minc, maxc = rect
    height = len(g)
    width = len(g[0])
    dirs = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
    q = deque()
    q.append(start)
    parents = {start: None}
    visited = {start}
    while q:
        cur = q.popleft()
        if cur == end:
            path = []
            node = cur
            while node is not None:
                path.append(node)
                node = parents[node]
            path.reverse()
            return path
        for dr, dc in dirs:
            nr, nc = cur[0] + dr, cur[1] + dc
            if not (minr <= nr <= maxr and minc <= nc <= maxc):
                continue
            if not (0 <= nr < height and 0 <= nc < width):
                continue
            if g[nr][nc] != 0:
                continue
            nxt = (nr, nc)
            if nxt in visited:
                continue
            visited.add(nxt)
            parents[nxt] = cur
            q.append(nxt)
    return None


def p(input_grid):
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])

    clusters_by_color = find_clusters(grid_in)
    out = [row[:] for row in grid_in]

    for color, clusters in list(clusters_by_color.items()):
        if len(clusters) < 2:
            continue
        for i, cluster_a in enumerate(clusters):
            # compute minimal distances to all other clusters
            distances = {}
            for j, cluster_b in enumerate(clusters):
                if i == j:
                    continue
                dmin = None
                for pa in cluster_a:
                    for pb in cluster_b:
                        d = chebyshev(pa, pb)
                        if dmin is None or d < dmin:
                            dmin = d
                distances[j] = dmin
            if not distances:
                continue
            min_dist = min(distances.values())
            candidates = [j for j, d in distances.items() if d == min_dist]
            nearest_j = min(candidates, key=lambda j: (cluster_bbox(clusters[j])[0], cluster_bbox(clusters[j])[2]))

            cluster_b = clusters[nearest_j]
            a_minr, a_maxr, a_minc, a_maxc = cluster_bbox(cluster_a)
            b_minr, b_maxr, b_minc, b_maxc = cluster_bbox(cluster_b)
            rect = (min(a_minr, b_minr), max(a_maxr, b_maxr), min(a_minc, b_minc), max(a_maxc, b_maxc))
            anchors_a = anchor_zeros_within_rect(grid_in, cluster_a, rect)
            anchors_b = anchor_zeros_within_rect(grid_in, cluster_b, rect)
            if not anchors_a or not anchors_b:
                continue
            best_pair = None
            best_d = None
            for sa in anchors_a:
                for sb in anchors_b:
                    d = chebyshev(sa, sb)
                    pair = (sa, sb)
                    if best_d is None or d < best_d or (d == best_d and pair < best_pair):
                        best_d = d
                        best_pair = pair
            if best_pair is None:
                continue
            start, end = best_pair
            path = bfs_zero_path(grid_in, start, end, rect)
            if path is None:
                continue
            for (pr, pc) in path:
                if out[pr][pc] == 0:
                    out[pr][pc] = color

    return tuple(tuple(row) for row in out)

