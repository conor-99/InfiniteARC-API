# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: ce3bc36a
Difficulty: very hard

=== Tags ===
- Heat map draw
- Indexed painting
- Color matching
- Spacing

=== Description ===
Input grids consist of a 2D grid of colors (0-9), where color 0 represents the
background. The grid contains multiple connected regions of non-zero colors
(1-9), each forming a contiguous 4-connected component. Each region is defined
by a unique color value that determines its spatial expansion.  The
transformation to the output grid involves a multi-step geometric operation
based on region properties. For each region of color `c` (processed in order
from 1 to 9), the following steps occur: 1. Compute the axis-aligned bounding
box of the region (min/max row and column indices). 2. Expand this bounding box
outward by `c` cells in all four directions (top, bottom, left, right). 3. In
the output grid, fill all cells within this expanded bounding box with color
`c`, overwriting any previously drawn regions.  Regions with lower color values
are drawn first, allowing higher color values (which expand further) to
overwrite overlapping areas. The background (color 0) remains visible only in
areas not covered by any expanded bounding box. The output grid preserves the
spatial relationships of the input regions while creating a layered "heat map"
where the spacing between the original region and its drawn boundary is
proportional to the region's color value. This requires precise connected
component analysis, bounding box calculation, and careful handling of
overlapping expansions to produce the correct visual pattern.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    grid_input = [[0] * width for _ in range(height)]
    
    num_regions = random.randint(1, 4)
    colors = random.sample(range(1, 10), num_regions)
    
    for c in colors:
        h = random.randint(2, 3)
        w = random.randint(2, 3)
        h = min(h, height)
        w = min(w, width)
        r = random.randint(0, height - h)
        c_pos = random.randint(0, width - w)
        for i in range(r, r + h):
            for j in range(c_pos, c_pos + w):
                grid_input[i][j] = c
    
    grid_output = [[0] * width for _ in range(height)]
    for c in range(1, 10):
        cells = []
        for r in range(height):
            for c_col in range(width):
                if grid_input[r][c_col] == c:
                    cells.append((r, c_col))
        if not cells:
            continue
        min_row = min(r for r, _ in cells)
        max_row = max(r for r, _ in cells)
        min_col = min(c_col for _, c_col in cells)
        max_col = max(c_col for _, c_col in cells)
        new_min_row = max(0, min_row - c)
        new_max_row = min(height - 1, max_row + c)
        new_min_col = max(0, min_col - c)
        new_max_col = min(width - 1, max_col + c)
        for r in range(new_min_row, new_max_row + 1):
            for c_col in range(new_min_col, new_max_col + 1):
                grid_output[r][c_col] = c
    
    if grid_input == grid_output:
        return generate()
    
    return {
        "input": grid_input,
        "output": grid_output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output = [[0] * width for _ in range(height)]
    for c in range(1, 10):
        cells = []
        for r in range(height):
            for c_col in range(width):
                if input_grid[r][c_col] == c:
                    cells.append((r, c_col))
        if not cells:
            continue
        min_row = min(r for r, _ in cells)
        max_row = max(r for r, _ in cells)
        min_col = min(c_col for _, c_col in cells)
        max_col = max(c_col for _, c_col in cells)
        new_min_row = max(0, min_row - c)
        new_max_row = min(height - 1, max_row + c)
        new_min_col = max(0, min_col - c)
        new_max_col = min(width - 1, max_col + c)
        for r in range(new_min_row, new_max_row + 1):
            for c_col in range(new_min_col, new_max_col + 1):
                output[r][c_col] = c
    return output
