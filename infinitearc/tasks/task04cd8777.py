# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 04cd8777
Difficulty: insane

=== Tags ===
- Rotating signal
- Hierarchical repetition
- Cave escape
- Synchronized bounce
- Encircle all pixels of one color

=== Description ===
Input grids consist of a background color (0) and multiple colored pixels (1-9)
arranged in complex, visually distinct patterns. Among these, one specific color
forms a rotating signal pattern characterized by hierarchical repetition:
concentric circular or spiral paths that expand outward from a central point,
each layer offset by a consistent angular step. This pattern must form a closed,
continuous loop with no gaps, and it is the only color exhibiting such
hierarchical structure (e.g., multiple nested spirals or circles of the same
color). Other colors appear as isolated shapes or linear motifs without
rotational symmetry.  The output grid must encircle all pixels of the rotating
signal color. This is achieved by converting every background pixel (0)
orthogonally adjacent (up, down, left, right) to any pixel of the rotating
signal color into a fixed border color (9, maroon). The border forms a
continuous frame around the entire shape of the rotating signal, excluding all
other colors and background. All other pixels (including non-adjacent background
and pixels of other colors) remain unchanged. The border must not overlap with
other colors or penetrate through them, maintaining the integrity of the
original grid's structure. The task requires identifying the unique rotating
signal color via its hierarchical spiral/circular pattern before applying the
encircling rule, making it visually complex and challenging for "insane"
difficulty.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common


def generate():
    """Generate an ARC pair where a unique 'rotating signal' color is drawn as
    multiple concentric square rings around a center and every background cell
    orthogonally adjacent to that color becomes 9 in the output. Other colors
    are placed as isolated small shapes that are never orthogonally adjacent
    to the signal color (so the border never overlaps them).
    """
    # Grid size
    width = random.randint(15, 30)
    height = random.randint(15, 30)
    grid = [[0 for _ in range(width)] for _ in range(height)]

    # Choose the signal color (1-8) and a center such that at least 2 rings fit
    signal_color = random.randint(1, 8)

    min_margin = 4
    # pick a center that allows at least 2 rings
    attempts = 0
    while True:
        cx = random.randint(min_margin, width - min_margin - 1)
        cy = random.randint(min_margin, height - min_margin - 1)
        max_d = min(cx, cy, width - cx - 1, height - cy - 1)
        if max_d >= 2:
            break
        attempts += 1
        if attempts > 50:
            # fallback to center of grid if random sampling fails
            cx = width // 2
            cy = height // 2
            max_d = min(cx, cy, width - cx - 1, height - cy - 1)
            break

    # Number of concentric square rings (hierarchical repetition)
    num_rings = random.randint(2, min(4, max_d))

    # Draw square rings (closed continuous loops)
    for d in range(1, num_rings + 1):
        top = cy - d
        bottom = cy + d
        left = cx - d
        right = cx + d
        # horizontal edges
        for c in range(left, right + 1):
            if 0 <= top < height and 0 <= c < width:
                grid[top][c] = signal_color
            if 0 <= bottom < height and 0 <= c < width:
                grid[bottom][c] = signal_color
        # vertical edges (exclude corners to avoid double-writes)
        for r in range(top + 1, bottom):
            if 0 <= r < height and 0 <= left < width:
                grid[r][left] = signal_color
            if 0 <= r < height and 0 <= right < width:
                grid[r][right] = signal_color

    # Place other colors as isolated shapes, ensuring none are orthogonally adjacent
    # to any signal_color pixel so the border will not overlap them.
    palette = [c for c in range(1, 9) if c != signal_color]
    random.shuffle(palette)
    num_shapes = random.randint(2, 6)
    shape_types = ["dot", "block", "line", "el", "plus", "snake"]

    for i in range(min(num_shapes, len(palette))):
        color = palette[i]
        shape_type = random.choice(shape_types)

        # build local shape pixel coordinates (top-left origin)
        if shape_type == "dot":
            shape_pixels = [(0, 0)]
        elif shape_type == "block":
            sh_h = random.randint(2, 4)
            sh_w = random.randint(2, 4)
            shape_pixels = [(r, c) for r in range(sh_h) for c in range(sh_w)]
        elif shape_type == "line":
            if random.choice([True, False]):
                sh_h = 1
                sh_w = random.randint(3, 7)
                shape_pixels = [(0, c) for c in range(sh_w)]
            else:
                sh_w = 1
                sh_h = random.randint(3, 7)
                shape_pixels = [(r, 0) for r in range(sh_h)]
        elif shape_type == "el":
            sh_h = random.randint(3, 6)
            sh_w = random.randint(3, 6)
            shape_pixels = [(0, c) for c in range(sh_w)] + [(r, 0) for r in range(sh_h)]
        elif shape_type == "plus":
            arm = random.randint(1, 3)
            size = arm * 2 + 1
            center = arm
            shape_pixels = [(center, c) for c in range(size)] + [(r, center) for r in range(size)]
            # deduplicate the center once
            shape_pixels = list(dict.fromkeys(shape_pixels))
        else:  # snake
            L = random.randint(4, 9)
            path = [(0, 0)]
            directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
            for step in range(L - 1):
                prev = path[-1]
                tries_local = 0
                while True:
                    dr, dc = random.choice(directions)
                    nxt = (prev[0] + dr, prev[1] + dc)
                    # keep snake in a small local bounding box to keep shape compact
                    if nxt not in path and -4 <= nxt[0] <= 4 and -4 <= nxt[1] <= 4:
                        path.append(nxt)
                        break
                    tries_local += 1
                    if tries_local > 40:
                        # fallback to any non-visited neighbor
                        for dr, dc in directions:
                            nxt = (prev[0] + dr, prev[1] + dc)
                            if nxt not in path:
                                path.append(nxt)
                                break
                        break
            minr = min(p[0] for p in path)
            minc = min(p[1] for p in path)
            shape_pixels = [(p[0] - minr, p[1] - minc) for p in path]

        # bounding box for the shape
        sh_h = max(p[0] for p in shape_pixels) + 1
        sh_w = max(p[1] for p in shape_pixels) + 1

        # attempt to place the shape without overlapping existing non-zero cells and
        # without being orthogonally adjacent to the signal color
        placed = False
        for attempt in range(60):
            off_r = random.randint(0, height - sh_h)
            off_c = random.randint(0, width - sh_w)
            conflict = False
            for pr, pc in shape_pixels:
                r = off_r + pr
                c = off_c + pc
                if grid[r][c] != 0:
                    conflict = True
                    break
                # ensure not orthogonally adjacent to signal color
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == signal_color:
                        conflict = True
                        break
                if conflict:
                    break
            if not conflict:
                for pr, pc in shape_pixels:
                    grid[off_r + pr][off_c + pc] = color
                placed = True
                break
        # if not placed after attempts, skip this shape

    # build the output: convert any background (0) orthogonally adjacent to the
    # signal color into 9 (maroon)
    output = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if grid[r][c] == signal_color:
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0:
                        output[nr][nc] = 9

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    # convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # collect candidate colors (exclude background 0 and possible border 9 if present)
    colors = set()
    for r in range(height):
        for c in range(width):
            v = grid[r][c]
            if v != 0 and v != 9:
                colors.add(v)

    # helper to find connected components for a given color
    def components_for_color(color):
        seen = set()
        comps = []
        for r in range(height):
            for c in range(width):
                if grid[r][c] == color and (r, c) not in seen:
                    comp = []
                    dq = deque()
                    dq.append((r, c))
                    seen.add((r, c))
                    while dq:
                        pr, pc = dq.popleft()
                        comp.append((pr, pc))
                        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                            nr, nc = pr + dr, pc + dc
                            if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == color and (nr, nc) not in seen:
                                seen.add((nr, nc))
                                dq.append((nr, nc))
                    comps.append(comp)
        return comps

    # identify the rotating-signal color by looking for multiple closed-loop components
    # closed loop: every pixel in the component has exactly two orthogonal neighbors
    # inside that component and the component is reasonably large (>=8 -> square perimeter minimum)
    best_color = None
    best_cycle_count = -1
    best_cycle_size = -1

    for color in colors:
        comps = components_for_color(color)
        cycle_count = 0
        cycle_size = 0
        for comp in comps:
            size = len(comp)
            if size < 8:
                continue
            comp_set = set(comp)
            ok = True
            for (r, c) in comp:
                neigh = 0
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    if (r + dr, c + dc) in comp_set:
                        neigh += 1
                if neigh != 2:
                    ok = False
                    break
            if ok:
                cycle_count += 1
                cycle_size += size
        # prefer the color with more cycle-components, then larger total cycle size
        if cycle_count > best_cycle_count or (cycle_count == best_cycle_count and cycle_size > best_cycle_size):
            best_color = color
            best_cycle_count = cycle_count
            best_cycle_size = cycle_size

    # fallback if no closed-loop color found: choose the most numerous nonzero color
    if best_color is None or best_cycle_count <= 0:
        max_pixels = -1
        for color in colors:
            cnt = 0
            for r in range(height):
                for c in range(width):
                    if grid[r][c] == color:
                        cnt += 1
            if cnt > max_pixels:
                max_pixels = cnt
                best_color = color

    # build output: mark all background cells orthogonally adjacent to best_color as 9
    out = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if grid[r][c] == best_color:
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0:
                        out[nr][nc] = 9

    return out

