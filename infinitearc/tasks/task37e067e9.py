# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 37e067e9
Difficulty: hard

=== Tags ===
- Incremental pattern growth
- Hollow shape detection
- Fractal growth

=== Description ===
Input grids feature multiple isolated hollow rectangles (each defined by a
contiguous border of a single color surrounding an empty interior filled with
the background color) positioned at varying locations without overlapping or
touching grid edges. The background color is uniform across the grid, and each
hollow rectangle's border color is distinct from both the background and other
border colors. Hollow rectangles are identified solely by their structural
properties: a closed loop border with a non-border interior, confirmed by the
absence of adjacent border pixels in the interior.  The output grid transforms
each hollow rectangle through a fractal growth process: first expanding its
border outward by one cell in all directions to form a new border layer of the
original color, then placing four smaller hollow rectangles at the corners of
this expanded border. Each smaller rectangle has a border color distinct from
both the original border color and the background, with dimensions exactly one
cell smaller than the original rectangle's width and height. The interiors of
all smaller rectangles remain background-filled, and their placement centers
them precisely at the corners of the expanded border without overlapping other
grid elements or existing borders. The transformation applies universally to all
hollow rectangles in the input, maintaining all original grid geometry while
incrementally growing the fractal structure through recursive border expansion
and corner placement.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def _choose_color(exclude):
    for c in range(1, 10):
        if c not in exclude:
            return c
    return 0


def generate():
    # Try a few times to build a valid configuration quickly
    for outer in range(50):
        width = random.randint(15, 30)
        height = random.randint(15, 30)
        bg = random.randint(0, 9)
        input_grid = [[bg for _ in range(width)] for _ in range(height)]

        num_rects = random.randint(2, 4)
        # candidate border colors (distinct from background)
        available_colors = [c for c in range(1, 10) if c != bg]
        if len(available_colors) < num_rects:
            continue
        border_colors = random.sample(available_colors, num_rects)

        rectangles = []  # (r, c, W, H, color, out_bbox)
        success = True

        for color in border_colors:
            placed = False
            # Try several size and placement attempts for this rectangle
            for _ in range(80):
                W = random.randint(3, 6)
                H = random.randint(3, 6)
                # quick feasibility checks
                if height < 2 * H or width < 2 * W:
                    continue
                r_min = 1
                r_max = height - (2 * H - 1)
                c_min = 1
                c_max = width - (2 * W - 1)
                if r_max < r_min or c_max < c_min:
                    continue

                # try a few random placements
                for _ in range(40):
                    r = random.randint(r_min, r_max)
                    c = random.randint(c_min, c_max)
                    out_r1, out_c1 = r - 1, c - 1
                    out_r2, out_c2 = r + 2 * H - 2, c + 2 * W - 2
                    # bounds check
                    if out_r1 < 0 or out_c1 < 0 or out_r2 >= height or out_c2 >= width:
                        continue
                    conflict = False
                    # ensure does not intersect any existing transformed bounding boxes or original boxes
                    for (er, ec, eW, eH, ecol, (eb_r1, eb_c1, eb_r2, eb_c2)) in rectangles:
                        if not (out_r2 < eb_r1 or out_r1 > eb_r2 or out_c2 < eb_c1 or out_c1 > eb_c2):
                            conflict = True
                            break
                        ex_orig_r1, ex_orig_c1 = er, ec
                        ex_orig_r2, ex_orig_c2 = er + eH - 1, ec + eW - 1
                        if not (r + H - 1 < ex_orig_r1 or r > ex_orig_r2 or c + W - 1 < ex_orig_c1 or c > ex_orig_c2):
                            conflict = True
                            break
                    if conflict:
                        continue
                    # place it
                    rectangles.append((r, c, W, H, color, (out_r1, out_c1, out_r2, out_c2)))
                    for cc in range(c, c + W):
                        input_grid[r][cc] = color
                        input_grid[r + H - 1][cc] = color
                    for rr in range(r, r + H):
                        input_grid[rr][c] = color
                        input_grid[rr][c + W - 1] = color
                    placed = True
                    break
                if placed:
                    break
            if not placed:
                success = False
                break

        if not success or len(rectangles) != num_rects:
            continue

        # Build output grid
        output_grid = [row[:] for row in input_grid]
        for (r, c, W, H, border_color, bbox) in rectangles:
            top = r - 1
            bottom = r + H
            left = c - 1
            right = c + W
            # expanded border
            for cc in range(left, right + 1):
                output_grid[top][cc] = border_color
                output_grid[bottom][cc] = border_color
            for rr in range(top, bottom + 1):
                output_grid[rr][left] = border_color
                output_grid[rr][right] = border_color

            new_color = _choose_color([bg, border_color])
            small_W = W - 1
            small_H = H - 1
            corners = [(top, left), (top, right), (bottom, left), (bottom, right)]
            for (cr, cc) in corners:
                top_s = cr
                left_s = cc
                bottom_s = cr + small_H - 1
                right_s = cc + small_W - 1
                if top_s < 0 or left_s < 0 or bottom_s >= height or right_s >= width:
                    continue
                for ccol in range(left_s, right_s + 1):
                    output_grid[top_s][ccol] = new_color
                    output_grid[bottom_s][ccol] = new_color
                for rrow in range(top_s, bottom_s + 1):
                    output_grid[rrow][left_s] = new_color
                    output_grid[rrow][right_s] = new_color

        if input_grid != output_grid:
            return {"input": input_grid, "output": output_grid}

    # Fallback
    return {"input": [[0]], "output": [[0]]}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def get_new_color(bg, original):
    for color in range(1, 10):
        if color != bg and color != original:
            return color
    return 0


def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # determine background as most frequent color
    counts = {}
    for r in range(height):
        for c in range(width):
            counts[grid[r][c]] = counts.get(grid[r][c], 0) + 1
    bg_color = max(counts.keys(), key=lambda k: counts[k]) if counts else 0

    visited = [[False] * width for _ in range(height)]
    hollow_rects = []

    for r in range(height):
        for c in range(width):
            if visited[r][c] or grid[r][c] == bg_color:
                continue
            color = grid[r][c]
            stack = [(r, c)]
            comp = []
            while stack:
                cr, cc = stack.pop()
                if visited[cr][cc] or grid[cr][cc] != color:
                    continue
                visited[cr][cc] = True
                comp.append((cr, cc))
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                        stack.append((nr, nc))

            min_r = min(p[0] for p in comp)
            max_r = max(p[0] for p in comp)
            min_c = min(p[1] for p in comp)
            max_c = max(p[1] for p in comp)
            W = max_c - min_c + 1
            H = max_r - min_r + 1

            if W < 3 or H < 3:
                continue

            ok = True
            for cc2 in range(min_c, max_c + 1):
                if grid[min_r][cc2] != color or grid[max_r][cc2] != color:
                    ok = False
                    break
            if not ok:
                continue
            for rr2 in range(min_r, max_r + 1):
                if grid[rr2][min_c] != color or grid[rr2][max_c] != color:
                    ok = False
                    break
            if not ok:
                continue

            for rr2 in range(min_r + 1, max_r):
                for cc2 in range(min_c + 1, max_c):
                    if grid[rr2][cc2] != bg_color:
                        ok = False
                        break
                if not ok:
                    break
            if not ok:
                continue

            expected_border_pixels = 2 * (W + H) - 4
            if len(comp) != expected_border_pixels:
                continue

            hollow_rects.append((min_r, min_c, W, H, color))

    output = [row[:] for row in grid]
    for (r, c, W, H, border_color) in hollow_rects:
        top = r - 1
        bottom = r + H
        left = c - 1
        right = c + W
        for cc2 in range(left, right + 1):
            if 0 <= top < height and 0 <= cc2 < width:
                output[top][cc2] = border_color
            if 0 <= bottom < height and 0 <= cc2 < width:
                output[bottom][cc2] = border_color
        for rr2 in range(top, bottom + 1):
            if 0 <= rr2 < height and 0 <= left < width:
                output[rr2][left] = border_color
            if 0 <= rr2 < height and 0 <= right < width:
                output[rr2][right] = border_color

        new_color = get_new_color(bg_color, border_color)
        small_W = W - 1
        small_H = H - 1
        corners = [(top, left), (top, right), (bottom, left), (bottom, right)]
        for (cr, cc) in corners:
            top_s = cr
            left_s = cc
            bottom_s = cr + small_H - 1
            right_s = cc + small_W - 1
            if top_s < 0 or left_s < 0 or bottom_s >= height or right_s >= width:
                continue
            for ccol in range(left_s, right_s + 1):
                output[top_s][ccol] = new_color
                output[bottom_s][ccol] = new_color
            for rrow in range(top_s, bottom_s + 1):
                output[rrow][left_s] = new_color
                output[rrow][right_s] = new_color

    return output

