# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 19838d2f
Difficulty: very hard

=== Tags ===
- Draw path through ordered checkpoints
- Draw pattern from point
- Move object based on arrow

=== Description ===
Input grids for this task feature a large, intricate maze-like structure (20x20
grid) with a distinct starting cell, a sequence of checkpoint markers each
uniquely colored to indicate their required visitation order (e.g., blue for
checkpoint 1, green for checkpoint 2, yellow for checkpoint 3), and directional
arrow cells (each color representing a specific movement direction: red = right,
green = up, blue = left, yellow = down). The token begins at the starting cell
and follows the directional arrows cell by cell. The path must traverse through
each checkpoint in the exact sequence of their designated colors without
deviation, navigating complex arrow networks that may include dead ends, loops,
or misleading paths that would otherwise disrupt the checkpoint order. The
output grid must draw the complete traversal path using a consistent path color
(e.g., cyan), while preserving the original checkpoint colors and start cell
color. This requires recognizing the directional color mappings, simulating the
token's movement through the grid, identifying the correct checkpoint sequence,
and drawing the path without overwriting checkpoint markers. The complexity
arises from the grid's size, the necessity to follow arrows while maintaining
checkpoint order, and the visual distinction between path, checkpoints, and
directional indicators.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    """
    Generates a 20x20 grid with a start cell on the left edge, a directed arrow-path
    that visits three checkpoints in order, and some additional arrow noise.

    Color / value conventions (must match solver):
      0 = background
      1 = arrow (right)  (arrow-only color)
      2 = arrow (up)     (arrow-only color)
      3 = arrow (left)   (arrow-only color)
      4 = arrow (down)   (arrow-only color)
      5 = checkpoint_1 (also arrow right)
      6 = checkpoint_2 (also arrow up)
      7 = checkpoint_3 (also arrow left)
      8 = path color (cyan) for output only
      9 = start cell color (preserved)

    The generator builds a non-self-intersecting path starting at column 1 next to
    the start cell at column 0. It ensures three checkpoint positions appear along
    the path (and that they encode distinct checkpoint colors), and then writes
    arrow colors to each path cell to point to the next cell. The last cell is
    left as 0 to terminate the traversal.
    """
    size = 20
    H = size; W = size

    # Color constants
    RIGHT = 1
    UP = 2
    LEFT = 3
    DOWN = 4
    CP1 = 5
    CP2 = 6
    CP3 = 7
    PATH = 8
    START = 9

    # Map direction vectors -> arrow-only color and checkpoint color (if any)
    dir_to_arrow = {
        (0, 1): RIGHT,
        (-1, 0): UP,
        (0, -1): LEFT,
        (1, 0): DOWN
    }
    # Only three checkpoint colors; they map to three directions (right, up, left)
    dir_to_cp = {
        (0, 1): CP1,   # right -> checkpoint1
        (-1, 0): CP2,  # up    -> checkpoint2
        (0, -1): CP3   # left  -> checkpoint3
        # Note: DOWN has no checkpoint color; generator will avoid placing a checkpoint
        # on a step that moves downward.
    }

    # Keep trying until a valid path with 3 distinct checkpoint directions can be made
    attempts = 0
    while True:
        attempts += 1
        if attempts > 200:
            # safety fallback: reduce constraints to avoid infinite loop
            # If we fail often (extremely unlikely), just randomize start row and continue
            pass

        # Initialize empty grid
        grid_input = grid(W, H, 0)

        # Choose start on left edge but not on corners so there's room
        start_row = random.randint(2, H - 3)
        start = (start_row, 0)
        grid_input[start_row][0] = START

        # Build a non-self-intersecting random path starting at (start_row,1)
        start_cell = (start_row, 1)
        path = [start_cell]
        visited = {start_cell}

        # target random path length
        min_len = 12
        max_len = 60
        target_len = random.randint(min_len, max_len)

        # Try to grow the path till target length or until stuck
        stuck_limit = 0
        while len(path) < target_len and stuck_limit < 2000:
            r, c = path[-1]
            neighbors = []
            for dr, dc in [(0, 1), (-1, 0), (0, -1), (1, 0)]:
                nr, nc = r + dr, c + dc
                # stay inside grid and do not step into column 0 (start column) except the start cell
                if nr < 0 or nr >= H or nc < 1 or nc >= W:  # avoid column 0 for path
                    continue
                if (nr, nc) in visited:
                    continue
                neighbors.append((nr, nc))
            if not neighbors:
                # dead end
                break
            nxt = random.choice(neighbors)
            path.append(nxt)
            visited.add(nxt)
            stuck_limit += 1

        # Must have enough room for 3 checkpoints and at least one non-checkpoint cell
        if len(path) < min_len:
            continue

        # Compute step directions for each step (from path[i] -> path[i+1])
        steps = []
        for i in range(len(path) - 1):
            r, c = path[i]
            nr, nc = path[i + 1]
            steps.append((nr - r, nc - c))

        # Choose three checkpoint indices (must be indices into steps, i.e., 0..len(path)-2)
        possible_indices = list(range(len(steps)))
        random.shuffle(possible_indices)
        cp_indices = []
        cp_dirs = set()
        for idx in possible_indices:
            d = steps[idx]
            # checkpoint can only be placed on a step whose direction has a checkpoint mapping
            if d not in dir_to_cp:
                continue
            # use distinct checkpoint directions (so colors are distinct)
            if d in cp_dirs:
                continue
            cp_indices.append(idx)
            cp_dirs.add(d)
            if len(cp_indices) == 3:
                break

        if len(cp_indices) < 3:
            # failed to find 3 distinct checkpoint-directed steps; retry path
            continue

        cp_indices.sort()

        # Now assign arrow colors to each path cell (path[i] points to path[i+1])
        for i in range(len(path) - 1):
            d = steps[i]
            r, c = path[i]
            if i in cp_indices:
                # checkpoint color for that direction
                grid_input[r][c] = dir_to_cp[d]
            else:
                # regular arrow-only color for that direction
                grid_input[r][c] = dir_to_arrow[d]

        # Last path cell: leave as 0 so traversal stops when it reaches it
        last_r, last_c = path[-1]
        grid_input[last_r][last_c] = 0

        # Place some additional arrow noise elsewhere (avoid path and start column)
        noise_count = random.randint(30, 70)
        for _ in range(noise_count):
            rr = random.randint(1, H - 2)
            cc = random.randint(1, W - 1)
            if (rr, cc) in visited or (rr, cc) == start:
                continue
            # pick an arrow-only color (do not use checkpoint colors for noise)
            grid_input[rr][cc] = random.choice([RIGHT, UP, LEFT, DOWN])

        # Add a tiny unique signature to help ensure generated pairs differ across calls
        # Choose a cell in top row far from path and start and set to a random color (not PATH)
        sig_attempts = 0
        while sig_attempts < 50:
            csr = 0
            csc = random.randint(1, W - 1)
            if (csr, csc) in visited or (csr, csc) == start:
                sig_attempts += 1
                continue
            # choose a color that doesn't clash with PATH or START
            sig_color = random.choice([1,2,3,4])
            grid_input[csr][csc] = sig_color
            break

        # Build output by drawing the path (preserve start and checkpoint colors)
        grid_output = [row[:] for row in grid_input]
        # visited path for drawing includes start cell then whole path
        visited_path = [start] + list(path)
        cp_colors = set(dir_to_cp.values())
        for (r, c) in visited_path:
            if grid_input[r][c] == START:
                continue
            if grid_input[r][c] in cp_colors:
                continue
            # color with PATH color
            grid_output[r][c] = PATH

        return {"input": grid_input, "output": grid_output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0]) if H > 0 else 0

    # Color constants must match generator
    RIGHT = 1
    UP = 2
    LEFT = 3
    DOWN = 4
    CP1 = 5
    CP2 = 6
    CP3 = 7
    PATH = 8
    START = 9

    # Map colors to directions (dr, dc)
    color_to_dir = {
        RIGHT: (0, 1),
        UP: (-1, 0),
        LEFT: (0, -1),
        DOWN: (1, 0),
        CP1: (0, 1),
        CP2: (-1, 0),
        CP3: (0, -1)
    }

    cp_colors = {CP1, CP2, CP3}

    # Find the start cell (left edge, column 0)
    start_row = None
    for r in range(H):
        if grid[r][0] == START:
            start_row = r
            break
    if start_row is None:
        # nothing to do
        return grid

    # Start traversal: token starts at (start_row, 0) and first moves right into (start_row,1)
    visited = []
    visited_set = set()

    # include the start cell in visited but do not recolor it
    cur_r, cur_c = start_row, 0
    visited.append((cur_r, cur_c))
    visited_set.add((cur_r, cur_c))

    # first step is into column 1 (the only inside neighbor of the start on the left edge)
    cur_r, cur_c = start_row, 1

    # Follow arrows until we leave the grid or encounter a non-arrow cell or loop
    steps_limit = H * W * 2
    steps = 0
    while 0 <= cur_r < H and 0 <= cur_c < W and steps < steps_limit:
        steps += 1
        if (cur_r, cur_c) in visited_set:
            # loop detected
            break
        visited.append((cur_r, cur_c))
        visited_set.add((cur_r, cur_c))

        color = grid[cur_r][cur_c]
        if color not in color_to_dir:
            # no arrow information here -> stop
            break
        dr, dc = color_to_dir[color]
        next_r, next_c = cur_r + dr, cur_c + dc
        # If next step goes out of bounds we still include that target if inbounds, otherwise stop
        if not (0 <= next_r < H and 0 <= next_c < W):
            # step would go out of grid: stop after this cell
            break
        # prepare for next iteration
        cur_r, cur_c = next_r, next_c

    # Create output and draw path color on visited cells except checkpoints and start
    output = [row[:] for row in grid]
    for (r, c) in visited:
        if output[r][c] == START:
            continue
        if output[r][c] in cp_colors:
            continue
        output[r][c] = PATH

    return output

