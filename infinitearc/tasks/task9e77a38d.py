# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 9e77a38d
Difficulty: hard

=== Tags ===
- Dynamic channel painting
- Detect wall

=== Description ===
Input grids are composed of a background (color 0), walls (color 1), and
optional decorative elements (colors 2-9). Walls form barrier structures that
divide the grid into enclosed regions of background cells. The output grid
dynamically fills each enclosed region (a connected background area completely
surrounded by walls with no connection to the grid's edges) with a color
determined by the orientation of the walls forming its boundary. Enclosed
regions bounded solely by horizontal walls (top and bottom walls forming left-
right barriers) are filled with color 2. Regions bounded solely by vertical
walls (left and right walls forming up-down barriers) are filled with color 3.
Regions bounded by both horizontal and vertical walls (surrounded on all sides)
are filled with color 4. All walls remain unchanged, decorative elements are
preserved, and non-enclosed regions (touching grid edges) retain their
background color.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(4, 30)
    height = random.randint(4, 30)
    grid = [[0] * width for _ in range(height)]
    
    num_regions = random.randint(1, 5)
    for _ in range(num_regions):
        r = random.randint(1, height - 3)
        c = random.randint(1, width - 3)
        h = random.randint(1, height - r - 2)
        w = random.randint(1, width - c - 2)
        
        for col in range(c, c + w):
            if r - 1 >= 0:
                grid[r - 1][col] = 1
        for col in range(c, c + w):
            if r + h < height:
                grid[r + h][col] = 1
        for row in range(r, r + h):
            if c - 1 >= 0:
                grid[row][c - 1] = 1
        for row in range(r, r + h):
            if c + w < width:
                grid[row][c + w] = 1
    
    for _ in range(random.randint(0, 10)):
        r = random.randint(0, height - 1)
        c = random.randint(0, width - 1)
        if grid[r][c] == 0:
            grid[r][c] = random.randint(2, 9)
    
    output = [row[:] for row in grid]
    visited = [[False] * width for _ in range(height)]
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and grid[r][c] == 0:
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == 0:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                
                is_enclosed = True
                for cr, cc in component:
                    if cr == 0 or cr == height - 1 or cc == 0 or cc == width - 1:
                        is_enclosed = False
                        break
                
                if is_enclosed:
                    min_r = min(cr for cr, cc in component)
                    max_r = max(cr for cr, cc in component)
                    min_c = min(cc for cr, cc in component)
                    max_c = max(cc for cr, cc in component)
                    h = max_r - min_r + 1
                    w = max_c - min_c + 1
                    
                    if w > h:
                        fill_color = 2
                    elif h > w:
                        fill_color = 3
                    else:
                        fill_color = 4
                    
                    for cr, cc in component:
                        output[cr][cc] = fill_color
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output = [list(row) for row in input_grid]
    visited = [[False] * width for _ in range(height)]
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and input_grid[r][c] == 0:
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == 0:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                
                is_enclosed = True
                for cr, cc in component:
                    if cr == 0 or cr == height - 1 or cc == 0 or cc == width - 1:
                        is_enclosed = False
                        break
                
                if is_enclosed:
                    min_r = min(cr for cr, cc in component)
                    max_r = max(cr for cr, cc in component)
                    min_c = min(cc for cr, cc in component)
                    max_c = max(cc for cr, cc in component)
                    h = max_r - min_r + 1
                    w = max_c - min_c + 1
                    
                    if w > h:
                        fill_color = 2
                    elif h > w:
                        fill_color = 3
                    else:
                        fill_color = 4
                    
                    for cr, cc in component:
                        output[cr][cc] = fill_color
    
    return output
