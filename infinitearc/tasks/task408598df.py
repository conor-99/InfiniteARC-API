# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 408598df
Difficulty: hard

=== Tags ===
- Cylindrical

=== Description ===
The task requires transforming an input grid by shifting each row left by its
row index (0-based), with the shift wrapping around the grid's width (i.e.,
elements shifted off the left edge reappear on the right). This cylindrical
shift creates a pattern where row i is shifted left by i positions, modulo the
grid's width. For example, in a 4Ã—4 grid, row 0 remains unchanged, row 1 shifts
left by 1 (moving the first element to the end), row 2 shifts left by 2, and row
3 shifts left by 3. The transformation relies on recognizing the row-dependent
shift pattern, which is non-trivial due to the increasing shift amount with row
index and the need to account for wrap-around behavior. This abstract reasoning
challenge, requiring consistent application of a row-specific transformation
across varying grid dimensions, defines the task as hard.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    while True:
        width = random.randint(2, 30)
        height = random.randint(2, 30)
        input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
        output_grid = []
        for i in range(height):
            shift = i % width
            output_grid.append(input_grid[i][shift:] + input_grid[i][:shift])
        if input_grid != output_grid:
            return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = []
    for i in range(height):
        shift = i % width
        output_grid.append(input_grid[i][shift:] + input_grid[i][:shift])
    return output_grid
