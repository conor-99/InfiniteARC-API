# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: b4e2455e
Difficulty: mediumâ€“hard

=== Tags ===
- Tile mutation rule
- Measure distance from side

=== Description ===
Edge Proximity Mutation  Input grids consist of a uniform background color
(e.g., 0) with multiple colored tiles (non-background) placed at various
positions. The output grid modifies each tile that lies within a distance of 1
cell from any grid edge (top, bottom, left, or right) to a fixed target color
(e.g., 5), while leaving all other tiles unchanged. The distance is calculated
as the minimum number of steps to reach any edge (e.g., a tile in the first row
has distance 0, the second row has distance 1, etc.). Tiles already matching the
target color remain unaffected. The background color remains unchanged
throughout. The transformation requires identifying tiles near grid boundaries
based on spatial position rather than color values, with the target color being
consistent across all examples.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    w = random.randint(1, 30)
    h = random.randint(1, 30)
    input_grid = [[0] * w for _ in range(h)]
    near_edge = []
    for r in range(h):
        for c in range(w):
            dist = min(r, h-1-r, c, w-1-c)
            if dist <= 1:
                near_edge.append((r, c))
    if not near_edge:
        near_edge = [(0, 0)]
    r, c = random.choice(near_edge)
    color = random.choice([1, 2, 3, 4, 6, 7, 8, 9])
    input_grid[r][c] = color
    for _ in range(random.randint(0, 5)):
        if near_edge:
            r, c = random.choice(near_edge)
            input_grid[r][c] = random.choice([5, 1, 2, 3, 4, 6, 7, 8, 9])
    output_grid = [row[:] for row in input_grid]
    for r in range(h):
        for c in range(w):
            dist = min(r, h-1-r, c, w-1-c)
            if dist <= 1 and input_grid[r][c] != 0:
                output_grid[r][c] = 5
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    h = len(input_grid)
    w = len(input_grid[0])
    output_grid = [row[:] for row in input_grid]
    for r in range(h):
        for c in range(w):
            dist = min(r, h-1-r, c, w-1-c)
            if dist <= 1 and input_grid[r][c] != 0:
                output_grid[r][c] = 5
    return output_grid
