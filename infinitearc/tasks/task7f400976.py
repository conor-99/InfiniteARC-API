# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 7f400976
Difficulty: hard

=== Tags ===
- Color transfer on contact
- Apply rule from a 2x2 hint grid

=== Description ===
# Color Transfer Grid  Input grids are 20Ã—20 or larger with a single background
color (0). The grid contains multiple contiguous regions of non-background
colors (1-9), forming distinct shapes separated by background. The top-left 2x2
subgrid of each input grid serves as the fixed "hint grid" for the task,
containing four distinct colors. The transformation rule is derived from the
hint grid's structure:  - For any horizontally adjacent pair (left-right) where
the left color matches the top-left hint color and the right color matches the
top-right hint color, replace the left color with the bottom-left hint color and
the right color with the bottom-right hint color.  - For any vertically adjacent
pair (top-bottom) where the top color matches the top-left hint color and the
bottom color matches the bottom-left hint color, replace the top color with the
top-right hint color and the bottom color with the bottom-right hint color.  All
other cells remain unchanged. The output grid applies these transformations to
every applicable horizontal and vertical adjacency in the main grid (excluding
the hint subgrid itself), resulting in a visual color transfer pattern where
touching color pairs interact according to the fixed rule defined by the hint
grid. The complexity arises from the large grid size, multiple potential
adjacency matches, and the need to correctly identify both horizontal and
vertical relationships relative to the fixed hint structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    tl, tr, bl, br = random.sample(range(1, 10), 4)
    width = random.randint(20, 30)
    height = random.randint(20, 30)
    grid = [[0] * width for _ in range(height)]
    
    grid[0][0] = tl
    grid[0][1] = tr
    grid[1][0] = bl
    grid[1][1] = br
    
    grid[0][2] = tl
    grid[0][3] = tr
    grid[2][0] = tl
    grid[3][0] = bl
    
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0:
                if random.random() > 0.5:
                    grid[r][c] = random.choice(range(1, 10))
    
    output = [row[:] for row in grid]
    
    for r in range(height):
        for c in range(width - 1):
            if grid[r][c] == tl and grid[r][c+1] == tr:
                output[r][c] = bl
                output[r][c+1] = br
    
    for r in range(height - 1):
        for c in range(width):
            if grid[r][c] == tl and grid[r+1][c] == bl:
                output[r][c] = tr
                output[r+1][c] = br
    
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    tl, tr = grid[0][0], grid[0][1]
    bl, br = grid[1][0], grid[1][1]
    output = [row[:] for row in grid]
    
    for r in range(len(grid)):
        for c in range(len(grid[0]) - 1):
            if grid[r][c] == tl and grid[r][c+1] == tr:
                output[r][c] = bl
                output[r][c+1] = br
    
    for r in range(len(grid) - 1):
        for c in range(len(grid[0])):
            if grid[r][c] == tl and grid[r+1][c] == bl:
                output[r][c] = tr
                output[r+1][c] = br
    
    return tuple(tuple(row) for row in output)
