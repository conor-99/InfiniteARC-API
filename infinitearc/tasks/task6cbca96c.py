# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 6cbca96c
Difficulty: mediumâ€“hard

=== Tags ===
- Bridges

=== Description ===
Input grids consist of a single background color (0) and multiple disconnected,
contiguous colored islands (each of a single non-zero color). Output grids must
add bridges of color 5 between every pair of islands that share the same color
and are aligned horizontally or vertically with no other islands in between
along the line of alignment. Each bridge is a straight line connecting the
closest points of the two islands, spanning the background gap. Bridges do not
overlap with islands, the background, or other bridges.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, continuous_creature


def generate():
    """
    Generate a grid pair where islands of single non-zero colors are placed
    and bridges of color 5 are added between islands of the same color that
    are aligned horizontally or vertically with only background (0) between them.
    """
    # Try multiple times until we produce a valid configuration
    for attempt in range(500):
        size = random.randint(10, 20)
        ingrid = grid(size, size, 0)
        occupied = set()  # cells occupied by islands
        islands = []  # list of {'color': int, 'pixels': [(r,c), ...]}

        # number of islands (components) to place
        n_islands = random.randint(4, 7)
        palette = list(range(1, 5))  # colors available for islands (1..4)

        # Place islands one by one
        place_failed = False
        for _ in range(n_islands):
            placed = False
            for _try in range(200):
                color = random.choice(palette)
                box_h = random.randint(1, 4)
                box_w = random.randint(1, 4)
                max_pixels = box_h * box_w
                shape_size = random.randint(1, min(5, max_pixels))

                # continuous_creature returns a contiguous set of pixels within the box
                rel_pixels = continuous_creature(shape_size, box_w, box_h)

                if box_h > size or box_w > size:
                    continue

                r0 = random.randint(0, size - box_h)
                c0 = random.randint(0, size - box_w)
                abs_pixels = [(r0 + p[0], c0 + p[1]) for p in rel_pixels]

                # Ensure no overlap and no 4-neighbor adjacency with existing islands
                conflict = False
                for (r, c) in abs_pixels:
                    if (r, c) in occupied:
                        conflict = True
                        break
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        if (r + dr, c + dc) in occupied:
                            conflict = True
                            break
                    if conflict:
                        break
                if conflict:
                    continue

                # place island
                for (r, c) in abs_pixels:
                    ingrid[r][c] = color
                    occupied.add((r, c))
                islands.append({"color": color, "pixels": abs_pixels})
                placed = True
                break
            if not placed:
                place_failed = True
                break

        if place_failed or len(islands) != n_islands:
            continue

        # Now find all pairs of islands of the same color that can be bridged
        # Candidate representation: (gap, orient, fixed, start, end)
        # orient: 0 -> horizontal (fixed is row), 1 -> vertical (fixed is col)
        candidates = []
        for i in range(len(islands)):
            for j in range(i + 1, len(islands)):
                if islands[i]["color"] != islands[j]["color"]:
                    continue
                best = None
                # examine all pixel pairs to find aligned, clear gaps
                for p in islands[i]["pixels"]:
                    for q in islands[j]["pixels"]:
                        # horizontal alignment
                        if p[0] == q[0]:
                            r = p[0]
                            cmin, cmax = min(p[1], q[1]), max(p[1], q[1])
                            gap = cmax - cmin - 1
                            if gap >= 1:
                                clear = True
                                for c in range(cmin + 1, cmax):
                                    if ingrid[r][c] != 0:
                                        clear = False
                                        break
                                if clear:
                                    cand = (gap, 0, r, cmin, cmax)
                                    if best is None or cand < best:
                                        best = cand
                        # vertical alignment
                        if p[1] == q[1]:
                            c = p[1]
                            rmin, rmax = min(p[0], q[0]), max(p[0], q[0])
                            gap = rmax - rmin - 1
                            if gap >= 1:
                                clear = True
                                for r in range(rmin + 1, rmax):
                                    if ingrid[r][c] != 0:
                                        clear = False
                                        break
                                if clear:
                                    cand = (gap, 1, c, rmin, rmax)
                                    if best is None or cand < best:
                                        best = cand
                if best is not None:
                    candidates.append(best)

        # If no bridges found, try a new layout
        if not candidates:
            continue

        # Ensure no two bridges overlap each other or islands
        bridge_cells = set()
        conflict = False
        for (gap, orient, fixed, start, end) in candidates:
            cells = []
            if orient == 0:  # horizontal
                r = fixed
                for c in range(start + 1, end):
                    cells.append((r, c))
            else:  # vertical
                c = fixed
                for r in range(start + 1, end):
                    cells.append((r, c))
            for cell in cells:
                if cell in occupied or cell in bridge_cells:
                    conflict = True
                    break
            if conflict:
                break
            for cell in cells:
                bridge_cells.add(cell)

        if conflict:
            continue

        # Build output grid by copying input and drawing bridges with color 5
        outgrid = [row[:] for row in ingrid]
        for (r, c) in bridge_cells:
            outgrid[r][c] = 5

        # Guarantee at least one bridge was added (so input != output)
        if not bridge_cells:
            continue

        return {"input": ingrid, "output": outgrid}

    # Fallback (should rarely happen): simple two-pixel example
    size = 10
    ingrid = grid(size, size, 0)
    r = 5
    c1 = 2
    c2 = 6
    ingrid[r][c1] = 1
    ingrid[r][c2] = 1
    outgrid = [row[:] for row in ingrid]
    for c in range(c1 + 1, c2):
        outgrid[r][c] = 5
    return {"input": ingrid, "output": outgrid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    orig = [list(row) for row in input_grid]
    rows = len(orig)
    cols = len(orig[0])

    # Find connected components (4-connected) of non-zero colors
    visited = set()
    components = []  # list of {'color': int, 'pixels': [(r,c), ...]}
    for r in range(rows):
        for c in range(cols):
            color = orig[r][c]
            if color == 0:
                continue
            if (r, c) in visited:
                continue
            # BFS/DFS to collect component
            stack = [(r, c)]
            visited.add((r, c))
            pixels = []
            while stack:
                pr, pc = stack.pop()
                pixels.append((pr, pc))
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = pr + dr, pc + dc
                    if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and orig[nr][nc] == color:
                        visited.add((nr, nc))
                        stack.append((nr, nc))
            components.append({"color": color, "pixels": pixels})

    # For each pair of components with the same color, determine if a bridge is required
    # Candidate representation: (gap, orient, fixed, start, end)
    # orient: 0 -> horizontal (fixed is row), 1 -> vertical (fixed is col)
    candidates = []
    for i in range(len(components)):
        for j in range(i + 1, len(components)):
            if components[i]["color"] != components[j]["color"]:
                continue
            best = None
            for p in components[i]["pixels"]:
                for q in components[j]["pixels"]:
                    # horizontal
                    if p[0] == q[0]:
                        r0 = p[0]
                        cmin, cmax = min(p[1], q[1]), max(p[1], q[1])
                        gap = cmax - cmin - 1
                        if gap >= 1:
                            clear = True
                            for c in range(cmin + 1, cmax):
                                if orig[r0][c] != 0:
                                    clear = False
                                    break
                            if clear:
                                cand = (gap, 0, r0, cmin, cmax)
                                if best is None or cand < best:
                                    best = cand
                    # vertical
                    if p[1] == q[1]:
                        c0 = p[1]
                        rmin, rmax = min(p[0], q[0]), max(p[0], q[0])
                        gap = rmax - rmin - 1
                        if gap >= 1:
                            clear = True
                            for rr in range(rmin + 1, rmax):
                                if orig[rr][c0] != 0:
                                    clear = False
                                    break
                            if clear:
                                cand = (gap, 1, c0, rmin, rmax)
                                if best is None or cand < best:
                                    best = cand
            if best is not None:
                candidates.append(best)

    # Ensure candidates do not overlap; generator ensures this, but we still check
    bridge_cells = set()
    for (gap, orient, fixed, start, end) in candidates:
        if orient == 0:
            r0 = fixed
            for c in range(start + 1, end):
                bridge_cells.add((r0, c))
        else:
            c0 = fixed
            for r in range(start + 1, end):
                bridge_cells.add((r, c0))

    # Build output by copying original and drawing bridges (color 5)
    out = [row[:] for row in orig]
    for (r, c) in bridge_cells:
        out[r][c] = 5

    return tuple(tuple(row) for row in out)

