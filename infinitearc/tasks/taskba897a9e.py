# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: ba897a9e
Difficulty: hard

=== Tags ===
- Pattern rotation
- Token following

=== Description ===
# Pattern Rotation and Token Following  The input grids feature a background
color (typically 0) with multiple scattered 3×3 pattern blocks. Each block
contains a central cell (color 2) and a rotation indicator cell (color 4)
positioned at one of the four corners of the block. The position of the color 4
indicator determines the rotation direction: top-left corner indicates clockwise
rotation, top-right indicates counterclockwise rotation, bottom-left indicates
180-degree rotation, and bottom-right indicates no rotation (though this is
rare). Additionally, the grid contains tokens (color 5) placed at various
positions across the grid.  In the output grid, each pattern block is rotated
according to its indicator's direction (clockwise, counterclockwise, or 180
degrees), with the central color 2 remaining fixed. Simultaneously, each token
moves one cell in the direction corresponding to the rotation of its nearest
pattern block. The nearest block is determined by Manhattan distance to the
block's center (the middle cell of the 3×3 block), with ties broken by
prioritizing blocks with clockwise rotation first, followed by counterclockwise,
then 180-degree. The movement direction for tokens is defined as: clockwise
rotation → right, counterclockwise → left, 180-degree → up, and no rotation →
down.  The transformation requires visual identification of pattern blocks,
their rotation indicators, token positions, and simultaneous application of
rotation and token movement rules. The output grid must maintain all background
elements while correctly rotating patterns and relocating tokens based on the
nearest pattern's rotation direction.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common


def generate():
    # Try until we build a valid instance (non-overlapping blocks, at least 2 blocks, at least one token,
    # and input != output)
    tries = 0
    while True:
        tries += 1
        width = random.randint(5, 20)
        height = random.randint(5, 20)
        # Ensure there is space for at least two 3x3 blocks
        if width < 3 or height < 3:
            continue

        ingrid = common.grid(width, height, 0)

        # All possible top-left positions for a 3x3 block
        positions = [(r, c) for r in range(0, height - 2) for c in range(0, width - 2)]
        random.shuffle(positions)

        max_blocks = min(5, len(positions))
        num_blocks = random.randint(2, max_blocks)

        blocks = []  # will hold tuples (r, c, (dr, dc))

        # Greedily pick non-overlapping positions from the shuffled list
        for pos_idx, (r, c) in enumerate(positions):
            if len(blocks) >= num_blocks:
                break
            # check overlap with existing blocks
            overlap = False
            for (br, bc, _) in blocks:
                if not (r + 2 < br or br + 2 < r or c + 2 < bc or bc + 2 < c):
                    overlap = True
                    break
            if overlap:
                continue

            # Choose a corner for the rotation indicator. Make sure that at least one block
            # is not the bottom-right 'none' indicator: if this is the last slot and we
            # haven't chosen a non-none yet, force a non-none choice.
            chosen_corner = None
            corners = [(0, 0), (0, 2), (2, 0), (2, 2)]
            non_none_corners = [(0, 0), (0, 2), (2, 0)]
            have_non_none = any(corner != (2, 2) for (_, _, corner) in blocks)
            if len(blocks) == num_blocks - 1 and not have_non_none:
                chosen_corner = random.choice(non_none_corners)
            else:
                chosen_corner = random.choice(corners)

            dr, dc = chosen_corner

            # Place indicator and center, and fill the rest of the 3x3 with non-background colors
            ingrid[r + dr][c + dc] = 4
            ingrid[r + 1][c + 1] = 2
            fill_colors = [1, 3, 6, 7, 8, 9]
            for i in range(3):
                for j in range(3):
                    if (i, j) == (1, 1) or (i, j) == (dr, dc):
                        continue
                    ingrid[r + i][c + j] = random.choice(fill_colors)

            blocks.append((r, c, (dr, dc)))

        # If we failed to place at least 2 blocks, retry (avoid very cramped grids)
        if len(blocks) < 2:
            if tries > 50:
                # Reset tries and try a new size
                tries = 0
            continue

        # Collect cells occupied by blocks so we don't place tokens there
        block_cells = set()
        for (br, bc, _) in blocks:
            for rr in range(br, br + 3):
                for cc in range(bc, bc + 3):
                    block_cells.add((rr, cc))

        # Place tokens (color 5) on some of the free background cells
        free_cells = [(r, c) for r in range(height) for c in range(width) if (r, c) not in block_cells and ingrid[r][c] == 0]
        token_positions = []
        if free_cells:
            max_tok = max(1, len(free_cells) // 8)
            tok_count = random.randint(1, max_tok)
            chosen = random.sample(free_cells, tok_count)
            for (tr, tc) in chosen:
                ingrid[tr][tc] = 5
                token_positions.append((tr, tc))

        # Ensure at least one token exists
        if not token_positions:
            available = [(r, c) for r in range(height) for c in range(width) if (r, c) not in block_cells and ingrid[r][c] == 0]
            if not available:
                # no place for token; retry
                continue
            tr, tc = random.choice(available)
            ingrid[tr][tc] = 5
            token_positions.append((tr, tc))

        # Ensure at least one block is non-'none' (bottom-right). This was attempted during placement,
        # but double-check and fix if necessary.
        if not any(corner != (2, 2) for (_, _, corner) in blocks):
            br, bc, old = blocks[0]
            # replace old indicator cell with a fill color and set a new indicator in a non-none corner
            old_r, old_c = br + old[0], bc + old[1]
            ingrid[old_r][old_c] = random.choice(fill_colors)
            new_corner = random.choice(non_none_corners)
            new_r, new_c = br + new_corner[0], bc + new_corner[1]
            ingrid[new_r][new_c] = 4
            blocks[0] = (br, bc, new_corner)

        # Sort token positions so that movement order is deterministic (row-major).
        token_positions.sort()

        # Build the output by rotating each block and then moving each token one cell according
        # to the rotation of its nearest block (Manhattan distance). Tie-break: rotation priority,
        # then topmost center, then leftmost center.
        outgrid = [row[:] for row in ingrid]

        def get_rotation(drdc):
            dr, dc = drdc
            if (dr, dc) == (0, 0):
                return 'clockwise'
            if (dr, dc) == (0, 2):
                return 'counterclockwise'
            if (dr, dc) == (2, 0):
                return '180'
            return 'none'

        for (br, bc, (dr, dc)) in blocks:
            rot = get_rotation((dr, dc))
            block = [outgrid[br + i][bc:bc + 3] for i in range(3)]
            if rot == 'clockwise':
                rotated = [
                    [block[2][0], block[1][0], block[0][0]],
                    [block[2][1], block[1][1], block[0][1]],
                    [block[2][2], block[1][2], block[0][2]]
                ]
            elif rot == 'counterclockwise':
                rotated = [
                    [block[0][2], block[1][2], block[2][2]],
                    [block[0][1], block[1][1], block[2][1]],
                    [block[0][0], block[1][0], block[2][0]]
                ]
            elif rot == '180':
                rotated = [
                    [block[2][2], block[2][1], block[2][0]],
                    [block[1][2], block[1][1], block[1][0]],
                    [block[0][2], block[0][1], block[0][0]]
                ]
            else:
                rotated = [list(rw) for rw in block]

            for i in range(3):
                for j in range(3):
                    outgrid[br + i][bc + j] = rotated[i][j]

        centers = [(br + 1, bc + 1) for (br, bc, _) in blocks]
        rotations = [get_rotation(x[2]) for x in blocks]
        priority = {'clockwise': 0, 'counterclockwise': 1, '180': 2, 'none': 3}

        for (x, y) in token_positions:
            dists = [abs(x - cx) + abs(y - cy) for (cx, cy) in centers]
            # tie-break: distance, rotation priority, center row, center col
            idx = sorted(range(len(dists)), key=lambda i: (dists[i], priority[rotations[i]], centers[i][0], centers[i][1]))[0]
            chosen_rot = rotations[idx]
            if chosen_rot == 'clockwise':
                dx, dy = 0, 1
            elif chosen_rot == 'counterclockwise':
                dx, dy = 0, -1
            elif chosen_rot == '180':
                dx, dy = -1, 0
            else:
                dx, dy = 1, 0

            nx, ny = x + dx, y + dy
            if not (0 <= nx < height and 0 <= ny < width):
                nx, ny = x, y

            outgrid[x][y] = 0
            outgrid[nx][ny] = 5

        # Ensure we produced a different grid
        if outgrid != ingrid:
            return {"input": ingrid, "output": outgrid}

        # If we failed (rare), try again
        if tries > 200:
            # start over completely
            tries = 0



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Find all 3x3 blocks by locating the center cell with value 2 and checking which corner has 4
    blocks = []  # (r, c, (dr, dc)) top-left + corner offset
    for r in range(0, height - 2):
        for c in range(0, width - 2):
            if grid[r + 1][c + 1] != 2:
                continue
            # check corners for indicator 4
            if grid[r][c] == 4:
                blocks.append((r, c, (0, 0)))
            elif grid[r][c + 2] == 4:
                blocks.append((r, c, (0, 2)))
            elif grid[r + 2][c] == 4:
                blocks.append((r, c, (2, 0)))
            elif grid[r + 2][c + 2] == 4:
                blocks.append((r, c, (2, 2)))
            else:
                # no indicator found -- skip
                continue

    # Record token positions from the original input
    tokens = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == 5]

    out = [row[:] for row in grid]

    def get_rotation(drdc):
        dr, dc = drdc
        if (dr, dc) == (0, 0):
            return 'clockwise'
        if (dr, dc) == (0, 2):
            return 'counterclockwise'
        if (dr, dc) == (2, 0):
            return '180'
        return 'none'

    # Rotate each detected block in the output grid
    for (br, bc, (dr, dc)) in blocks:
        rot = get_rotation((dr, dc))
        block = [out[br + i][bc:bc + 3] for i in range(3)]
        if rot == 'clockwise':
            rotated = [
                [block[2][0], block[1][0], block[0][0]],
                [block[2][1], block[1][1], block[0][1]],
                [block[2][2], block[1][2], block[0][2]]
            ]
        elif rot == 'counterclockwise':
            rotated = [
                [block[0][2], block[1][2], block[2][2]],
                [block[0][1], block[1][1], block[2][1]],
                [block[0][0], block[1][0], block[2][0]]
            ]
        elif rot == '180':
            rotated = [
                [block[2][2], block[2][1], block[2][0]],
                [block[1][2], block[1][1], block[1][0]],
                [block[0][2], block[0][1], block[0][0]]
            ]
        else:
            rotated = [list(rw) for rw in block]

        for i in range(3):
            for j in range(3):
                out[br + i][bc + j] = rotated[i][j]

    centers = [(br + 1, bc + 1) for (br, bc, _) in blocks]
    rotations = [get_rotation(b[2]) for b in blocks]
    priority = {'clockwise': 0, 'counterclockwise': 1, '180': 2, 'none': 3}

    # Move each token one cell according to its nearest block's rotation direction
    for (x, y) in tokens:
        if not centers:
            # no blocks found; nothing to do
            continue
        dists = [abs(x - cx) + abs(y - cy) for (cx, cy) in centers]
        idx = sorted(range(len(dists)), key=lambda i: (dists[i], priority[rotations[i]], centers[i][0], centers[i][1]))[0]
        chosen_rot = rotations[idx]
        if chosen_rot == 'clockwise':
            dx, dy = 0, 1
        elif chosen_rot == 'counterclockwise':
            dx, dy = 0, -1
        elif chosen_rot == '180':
            dx, dy = -1, 0
        else:
            dx, dy = 1, 0

        nx, ny = x + dx, y + dy
        if not (0 <= nx < height and 0 <= ny < width):
            nx, ny = x, y

        out[x][y] = 0
        out[nx][ny] = 5

    return tuple(tuple(row) for row in out)

