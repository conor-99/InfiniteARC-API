# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: aeae3ceb
Difficulty: hard

=== Tags ===
- Staircase construction
- Local convolution rule

=== Description ===
Input grids feature a background color (0) and a continuous diagonal spine of
cells forming a path from the bottom-left to the top-right corner. Each spine
cell contains a unique color (1-9) representing the step height for that
position. The output grid constructs a staircase structure where each step
extends horizontally from the spine cell for a length equal to its color value,
followed by a vertical upward segment of the same length. The local convolution
rule is applied as follows: for each cell (i,j) in the input, if it has a non-
background neighbor at (i+1, j-1) (indicating it is part of the spine), the
output fills the horizontal segment from (i, j+1) to (i, j+C) and the vertical
segment from (i-C, j+C) to (i, j+C), where C is the spine cell's color. Steps
must not overlap with existing non-background cells or grid boundaries; if a
segment would overlap, it is truncated to the nearest valid position. All non-
staircase cells remain background, and spine cells retain their original color.
The transformation requires sequential application of the local rule across the
entire grid to construct a coherent staircase structure without intersections or
boundary violations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

SEEN = set()


def generate():
    global SEEN
    attempts = 0
    while True:
        # Grid size
        h = random.randint(3, 20)
        w = random.randint(3, 20)
        # Spine length limited to available unique colors (1-9)
        max_spine = min(9, h, w)
        L = random.randint(2, max_spine)
        # Create input grid with a diagonal spine from bottom-left to top-right
        input_grid = [[0 for _ in range(w)] for _ in range(h)]
        # Assign unique colors to spine cells
        colors = random.sample(list(range(1, 10)), L)
        spine_cells = []
        for k, color in enumerate(colors):
            i = h - 1 - k
            j = k
            input_grid[i][j] = color
            spine_cells.append((i, j))
        # Start output as a copy of input and apply the local rule sequentially
        output_grid = [row[:] for row in input_grid]
        for (i, j) in spine_cells:
            # Only apply rule if the cell has a down-left neighbor in the input (part of the spine)
            if not (i + 1 < h and j - 1 >= 0 and input_grid[i + 1][j - 1] != 0):
                continue
            C = input_grid[i][j]
            # Horizontal segment: extend to the right up to C cells, truncating on boundary or collision
            last_col = None
            for col in range(j + 1, j + C + 1):
                if col >= w:
                    break
                if output_grid[i][col] != 0:
                    break
                output_grid[i][col] = C
                last_col = col
            # If nothing was placed horizontally, there's no anchor for vertical segment
            if last_col is None:
                continue
            # Vertical segment: extend upward from row i-1 to i-C+1 (the bottom cell is the horizontal anchor)
            for row in range(i - 1, i - C, -1):
                if row < 0:
                    break
                if output_grid[row][last_col] != 0:
                    break
                output_grid[row][last_col] = C
        key = (tuple(tuple(r) for r in input_grid), tuple(tuple(r) for r in output_grid))
        if key not in SEEN:
            SEEN.add(key)
            return {'input': input_grid, 'output': output_grid}
        attempts += 1
        if attempts > 1000:
            raise Exception('Could not generate a unique sample')



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable lists
    h = len(input_grid)
    w = len(input_grid[0])
    in_grid = [list(row) for row in input_grid]
    output_grid = [row[:] for row in in_grid]
    # Detect the spine starting at bottom-left and moving up-right along the diagonal
    spine_cells = []
    i = h - 1
    j = 0
    while j < w and i >= 0 and in_grid[i][j] != 0:
        spine_cells.append((i, j))
        i -= 1
        j += 1
    # Apply the same sequential rule as the generator
    for (i, j) in spine_cells:
        if not (i + 1 < h and j - 1 >= 0 and in_grid[i + 1][j - 1] != 0):
            continue
        C = in_grid[i][j]
        last_col = None
        # Horizontal extension (truncate on collision or boundary)
        for col in range(j + 1, j + C + 1):
            if col >= w:
                break
            if output_grid[i][col] != 0:
                break
            output_grid[i][col] = C
            last_col = col
        if last_col is None:
            continue
        # Vertical extension upward from the anchor (skip the anchor cell itself)
        for row in range(i - 1, i - C, -1):
            if row < 0:
                break
            if output_grid[row][last_col] != 0:
                break
            output_grid[row][last_col] = C
    return output_grid

