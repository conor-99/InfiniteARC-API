# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: d63bac09
Difficulty: hard

=== Tags ===
- Separate image
- Take minimum

=== Description ===
The input grid consists of multiple disconnected non-zero regions (separate
images) defined by 4-directional connectivity, surrounded by background cells
(value 0). The output grid is formed by replacing every cell within each
connected region with the smallest non-zero value present in that region. For
example, a region containing values 7, 2, and 5 is transformed to all 2s.
Background cells (0) remain unchanged, and the transformation ensures no input
grid matches its output grid by requiring at least one region to contain varying
non-zero values.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import *

def generate():
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    grid = [[0] * width for _ in range(height)]
    
    shapes = []
    
    for _ in range(2):
        shape_type = random.choice(['el', 'you', 'aitch'])
        shape_width = random.randint(3, 5)
        shape_height = random.randint(3, 5)
        shape_width = min(shape_width, width)
        shape_height = min(shape_height, height)
        pixels = rand_sprite(shape_type, shape_width, shape_height)
        r_offset = random.randint(0, height - shape_height)
        c_offset = random.randint(0, width - shape_width)
        placed_pixels = []
        for r, c in pixels:
            nr, nc = r + r_offset, c + c_offset
            if 0 <= nr < height and 0 <= nc < width:
                placed_pixels.append((nr, nc))
        shapes.append(placed_pixels)
    
    for shape in shapes:
        if len(shape) < 2:
            continue
        min_val = random.randint(1, 8)
        other_val = random.randint(min_val + 1, 9)
        random.shuffle(shape)
        split = len(shape) // 2
        for i, (r, c) in enumerate(shape):
            if i < split:
                grid[r][c] = min_val
            else:
                grid[r][c] = other_val
    
    input_grid = grid
    output_grid = [[0] * width for _ in range(height)]
    visited = [[False] * width for _ in range(height)]
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in directions:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                min_val = min(input_grid[cr][cc] for cr, cc in component)
                for cr, cc in component:
                    output_grid[cr][cc] = min_val
    
    assert input_grid != output_grid
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid or not input_grid[0]:
        return []
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = [[0] * width for _ in range(height)]
    visited = [[False] * width for _ in range(height)]
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in directions:
                        nr = cr + dr
                        nc = cc + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                min_val = min(input_grid[cr][cc] for cr, cc in component)
                for cr, cc in component:
                    output_grid[cr][cc] = min_val
    return output_grid
