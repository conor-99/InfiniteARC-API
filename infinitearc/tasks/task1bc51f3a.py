# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 1bc51f3a
Difficulty: hard

=== Tags ===
- If then color switch
- Image rotation

=== Description ===
Input grids are 20×20 with a uniform background color (0). A fixed 5×5 central
region (rows 8–12, columns 8–12) contains a pattern of non-background colors
(1–9). A horizontal "key strip" spans the top border (row 0, columns 3–7),
consisting of five distinct non-background colors in sequence. The
transformation applies two sequential rules:    1. **Conditional Color Switch**:
Within the central 5×5 region, each cell’s color is replaced by the next color
in a cyclic sequence (1→2, 2→3, ..., 9→1) if it is orthogonally adjacent to any
cell with a color divisible by 3 (3, 6, or 9) in the same central region.    2.
**Rotation Determination**: The first non-background color in the top key strip
determines the rotation angle: (color value − 1) × 90° clockwise (e.g., color 2
→ 90°, color 5 → 360° → 0°).    The entire grid is then rotated by the
determined angle to produce the output grid. The background remains unchanged,
and all non-background elements (central region, key strip) are transformed
according to the rules. The key strip’s color sequence is preserved in the input
but may relocate in the output due to rotation. The task requires identifying
the central region, applying adjacency-based color switching, extracting the
rotation key from the top border, and executing a global rotation—combining
pattern recognition, conditional logic, and geometric transformation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def rotate_clockwise(grid):
    return [list(reversed(col)) for col in zip(*grid)]


def generate():
    # 20x20 background
    input_grid = [[0] * 20 for _ in range(20)]

    # key strip: five distinct non-background colors in columns 3..7 on row 0
    colors = list(range(1, 10))
    key_strip = random.sample(colors, 5)
    for i, color in enumerate(key_strip):
        input_grid[0][3 + i] = color
    first_color = key_strip[0]

    # central 5x5 region (rows 8..12, cols 8..12) filled with colors 1..9
    central = [[random.randint(1, 9) for _ in range(5)] for _ in range(5)]

    # ensure at least one cell divisible by 3 exists in the central region
    if not any(cell % 3 == 0 for row in central for cell in row):
        r = random.randrange(5)
        c = random.randrange(5)
        central[r][c] = random.choice([3, 6, 9])

    # place central into input grid
    for r in range(5):
        for c in range(5):
            input_grid[8 + r][8 + c] = central[r][c]

    # build output by applying adjacency-based color switch inside the central region
    output_grid = [row[:] for row in input_grid]
    for r in range(5):
        for c in range(5):
            # check orthogonal neighbors in the original central snapshot
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < 5 and 0 <= nc < 5:
                    if central[nr][nc] % 3 == 0:
                        # replace with next color in cyclic sequence 1->2->...->9->1
                        output_grid[8 + r][8 + c] = (central[r][c] % 9) + 1
                        break

    # determine rotation from the first color of the key strip
    rotation_count = (first_color - 1) % 4
    for _ in range(rotation_count):
        output_grid = rotate_clockwise(output_grid)

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # convert to mutable list of lists
    grid = [list(row) for row in input_grid]

    # extract key strip (row 0, cols 3..7) and find first non-background color
    key_strip = grid[0][3:8]
    first_color = None
    for col in key_strip:
        if col != 0:
            first_color = col
            break
    if first_color is None:
        first_color = 1  # fallback (shouldn't happen with valid inputs)

    # snapshot the central 5x5 region (rows 8..12, cols 8..12)
    central = [[grid[r][c] for c in range(8, 13)] for r in range(8, 13)]

    # prepare output as a copy of the input
    out = [row[:] for row in grid]

    # apply adjacency rule using the snapshot (so updates don't affect other checks)
    for r in range(5):
        for c in range(5):
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < 5 and 0 <= nc < 5:
                    if central[nr][nc] % 3 == 0:
                        out[8 + r][8 + c] = (central[r][c] % 9) + 1
                        break

    # rotate clockwise (90 deg) rotation_count times
    def rotate_clockwise(g):
        return [list(reversed(col)) for col in zip(*g)]

    rotation_count = (first_color - 1) % 4
    for _ in range(rotation_count):
        out = rotate_clockwise(out)

    return out

