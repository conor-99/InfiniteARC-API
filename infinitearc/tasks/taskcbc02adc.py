# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: cbc02adc
Difficulty: hard

=== Tags ===
- Dominant color
- Topological invariance
- X marks the spot
- Color matching

=== Description ===
The task involves transforming an input grid of colors (0-9) where the dominant
color—the most frequent non-zero value—is identified. In the output grid, all
instances of this dominant color are replaced with a marker (color 9,
representing "X"). All other non-zero colors are replaced with the second most
frequent color in the input grid. The transformation strictly preserves
topological structure: connected regions of non-zero pixels maintain their shape
and connectivity, as only color values change. The "X marks the spot" refers to
the dominant color being visually replaced by the marker, while "color matching"
ensures all non-dominant colors align with the secondary color frequency. This
requires the solver to detect dominant/secondary color frequencies and apply
deterministic color replacements without altering spatial relationships.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    total_cells = width * height
    d = random.randint(1, 8)
    s = random.randint(1, 8)
    while s == d:
        s = random.randint(1, 8)
    total_nonzero = random.randint(3, total_cells)
    count_s = random.randint(1, (total_nonzero - 1) // 2)
    count_d = total_nonzero - count_s
    positions = [(r, c) for r in range(height) for c in range(width)]
    random.shuffle(positions)
    input_grid = [[0] * width for _ in range(height)]
    for i in range(count_d):
        r, c = positions[i]
        input_grid[r][c] = d
    for i in range(count_d, count_d + count_s):
        r, c = positions[i]
        input_grid[r][c] = s
    output_grid = [[9 if cell == d else cell for cell in row] for row in input_grid]
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random

def p(input_grid):
    count_map = {}
    for row in input_grid:
        for color in row:
            if color != 0:
                count_map[color] = count_map.get(color, 0) + 1
    sorted_colors = sorted(count_map.items(), key=lambda x: x[1], reverse=True)
    if len(sorted_colors) == 0:
        return input_grid
    elif len(sorted_colors) == 1:
        d_color = sorted_colors[0][0]
        s_color = d_color
    else:
        d_color, _ = sorted_colors[0]
        s_color, _ = sorted_colors[1]
    output = []
    for row in input_grid:
        new_row = []
        for color in row:
            if color == 0:
                new_row.append(0)
            elif color == d_color:
                new_row.append(9)
            else:
                new_row.append(s_color)
        output.append(new_row)
    return output
