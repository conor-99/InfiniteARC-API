# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 3fd19a60
Difficulty: hard

=== Tags ===
- Paint by distance to line

=== Description ===
The task involves transforming an input grid into an output grid based on the
geometric distance of each cell to a prominent straight line within the input.
The input grid contains a single, well-defined straight line (horizontal,
vertical, or diagonal) that spans a substantial portion of the grid, formed by
connected cells. The output grid colors each cell according to its Manhattan
distance to the nearest cell on this line, with distances mapped to colors 1
through 9 (distance 0 → color 1, distance 1 → color 2, ..., distance 8 → color
9, and distances ≥9 → color 9). The line's position must be identified through
spatial reasoning, as its color is irrelevant to the transformation. This task
requires recognizing the line's geometric orientation and offset, making it
challenging due to the need for multi-step spatial analysis and the potential
for distracting patterns in the input grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    w = random.randint(5, 30)
    h = random.randint(5, 30)
    if w > h:
        line_type = 'horizontal'
        line_positions = [(0, c) for c in range(w)]
    elif h > w:
        line_type = 'vertical'
        line_positions = [(r, 0) for r in range(h)]
    else:
        line_type = 'horizontal'
        line_positions = [(0, c) for c in range(w)]
    input_grid = grid(w, h, 0)
    for (r, c) in line_positions:
        input_grid[r][c] = 5
    for r in range(h):
        for c in range(w):
            if (r, c) not in line_positions:
                input_grid[r][c] = random.choice([x for x in range(10) if x != 5])
    output_grid = grid(w, h, 0)
    for r in range(h):
        for c in range(w):
            min_dist = float('inf')
            for (lr, lc) in line_positions:
                dist = abs(r - lr) + abs(c - lc)
                if dist < min_dist:
                    min_dist = dist
            color = min(min_dist + 1, 9)
            output_grid[r][c] = color
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    h = len(input_grid)
    w = len(input_grid[0])
    # Identify the intended line (row 0 for horizontal, column 0 for vertical)
    if w > h:
        line_positions = [(0, c) for c in range(w)]
    elif h > w:
        line_positions = [(r, 0) for r in range(h)]
    else:
        line_positions = [(0, c) for c in range(w)]
    output_grid = [[0] * w for _ in range(h)]
    for r in range(h):
        for c in range(w):
            min_dist = float('inf')
            for (lr, lc) in line_positions:
                dist = abs(r - lr) + abs(c - lc)
                if dist < min_dist:
                    min_dist = dist
            color = min(min_dist + 1, 9)
            output_grid[r][c] = color
    return output_grid
