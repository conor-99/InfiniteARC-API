# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: ce00a991
Difficulty: very hard

=== Tags ===
- Connect the dots
- Hollow core detection

=== Description ===
The task involves input grids with multiple enclosed regions formed by
contiguous colored shapes (non-background colors 1-9) against a uniform
background (color 0). Each shape may contain one or more hollow cores—background
regions completely surrounded by a single shape's color (not touching the grid
edge). These hollow cores must be detected by identifying all enclosed
background areas fully bordered by a single shape's color, ignoring edge-
touching regions.  The output grid must connect all hollow core centroids
(computed as the median row and column of all cells in each core) in a specific
sequence. First, centroids are sorted by ascending row, then ascending column. A
path is drawn between consecutive centroids using a distinct color (e.g., color
5), moving orthogonally (up/down/left/right) through background cells only. The
path follows a deterministic direction sequence: prioritize right, then up, then
left, then down, repeating until a valid move is found. If the direct path is
blocked by non-background cells, the path navigates around obstacles by cycling
through the direction sequence until a valid cell is reached. The path must not
overwrite any non-background elements, and no two hollow cores may share a
direct line of sight if blocked by a shape. The output retains all input
elements except the path, which is drawn exclusively on background cells.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Path color must be distinct from shape colors
    path_color = 5

    # Random board size (moderately large to be 'very hard')
    width = random.randint(15, 25)
    height = random.randint(15, 25)

    # Start with empty background
    grid_in = [[0 for _ in range(width)] for _ in range(height)]

    # Occupancy map to avoid overlapping frames (and keep a one-cell margin)
    occupancy = [[False for _ in range(width)] for _ in range(height)]

    # Number of framed shapes (hollow cores) to attempt
    target_shapes = random.randint(2, 4)

    # Choose distinct colors for shapes, never using the path color
    color_pool = [c for c in range(1, 10) if c != path_color]
    random.shuffle(color_pool)
    colors = color_pool[:target_shapes]

    cores = []

    for color in colors:
        placed = False
        # Try a number of times to place a non-overlapping rectangular frame
        for _ in range(200):
            # Choose frame size (ensure at least 3x3 so there's an inner hollow)
            max_w = min(9, width - 4)
            max_h = min(9, height - 4)
            if max_w < 3 or max_h < 3:
                break
            w = random.randint(3, max_w)
            h = random.randint(3, max_h)

            # Choose top-left so there's a one-cell gap to the grid border
            r = random.randint(1, height - h - 1)
            c = random.randint(1, width - w - 1)

            # Check a one-cell padding area for collisions so frames don't touch
            collision = False
            r0 = max(0, r - 1)
            r1 = min(height, r + h + 1)
            c0 = max(0, c - 1)
            c1 = min(width, c + w + 1)
            for rr in range(r0, r1):
                for cc in range(c0, c1):
                    if occupancy[rr][cc]:
                        collision = True
                        break
                if collision:
                    break
            if collision:
                continue

            # Draw the rectangular frame (border only)
            for i in range(r, r + h):
                grid_in[i][c] = color
                grid_in[i][c + w - 1] = color
                occupancy[i][c] = True
                occupancy[i][c + w - 1] = True
            for j in range(c, c + w):
                grid_in[r][j] = color
                grid_in[r + h - 1][j] = color
                occupancy[r][j] = True
                occupancy[r + h - 1][j] = True

            cores.append((r, c, h, w, color))
            placed = True
            break
        # If we couldn't place this shape after many attempts, skip it
        if not placed:
            continue

    # If we ended up with fewer than 2 cores, force two simple frames to guarantee
    # the task requirement (and to avoid input == output cases).
    if len(cores) < 2:
        cores = []
        # Place two fixed small frames in opposite corners
        small_w = min(5, width - 4)
        small_h = min(5, height - 4)
        col1, col2 = color_pool[0], color_pool[1]
        r1, c1 = 2, 2
        for i in range(r1, r1 + small_h):
            grid_in[i][c1] = col1
            grid_in[i][c1 + small_w - 1] = col1
        for j in range(c1, c1 + small_w):
            grid_in[r1][j] = col1
            grid_in[r1 + small_h - 1][j] = col1
        cores.append((r1, c1, small_h, small_w, col1))

        r2, c2 = height - small_h - 2, width - small_w - 2
        for i in range(r2, r2 + small_h):
            grid_in[i][c2] = col2
            grid_in[i][c2 + small_w - 1] = col2
        for j in range(c2, c2 + small_w):
            grid_in[r2][j] = col2
            grid_in[r2 + small_h - 1][j] = col2
        cores.append((r2, c2, small_h, small_w, col2))

    # Compute centroids as medians of the inner hollow cells
    centroids = []
    for (r, c, h, w, col) in cores:
        inner_rows = list(range(r + 1, r + h - 1))
        inner_cols = list(range(c + 1, c + w - 1))
        cells = [(ir, ic) for ir in inner_rows for ic in inner_cols]
        if not cells:
            continue
        rows_sorted = sorted([p[0] for p in cells])
        cols_sorted = sorted([p[1] for p in cells])
        median_row = rows_sorted[len(rows_sorted) // 2]
        median_col = cols_sorted[len(cols_sorted) // 2]
        centroids.append((median_row, median_col))

    # Sort centroids by row then column
    centroids.sort(key=lambda x: (x[0], x[1]))

    # Create output by copying input and then drawing the path(s)
    grid_out = [row[:] for row in grid_in]

    # Deterministic greedy local walker: right, up, left, down
    def find_path(g, start, end):
        h = len(g)
        w = len(g[0])
        directions = [(0, 1), (-1, 0), (0, -1), (1, 0)]  # right, up, left, down
        path = [start]
        current = start
        visited_local = set([start])
        while current != end:
            moved = False
            for dr, dc in directions:
                nr, nc = current[0] + dr, current[1] + dc
                if 0 <= nr < h and 0 <= nc < w and g[nr][nc] == 0 and (nr, nc) not in visited_local:
                    visited_local.add((nr, nc))
                    current = (nr, nc)
                    path.append(current)
                    moved = True
                    break
            if not moved:
                # No available orthogonal background move — stop early
                break
        return path

    # Draw path segments sequentially (so earlier segments become obstacles for later ones)
    for i in range(len(centroids) - 1):
        start = centroids[i]
        end = centroids[i + 1]
        # Defensive: ensure start/end are within bounds; they should be
        if not (0 <= start[0] < height and 0 <= start[1] < width):
            continue
        if not (0 <= end[0] < height and 0 <= end[1] < width):
            continue
        path = find_path(grid_out, start, end)
        for (pr, pc) in path:
            # Only draw on background cells
            if grid_out[pr][pc] == 0:
                grid_out[pr][pc] = path_color

    return {"input": grid_in, "output": grid_out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    visited = [[False for _ in range(width)] for _ in range(height)]
    hollow_cores = []  # list of regions (lists of (r,c)) that are hollow cores

    # Find background connected components and determine which are hollow cores
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 or visited[r][c]:
                continue
            # BFS to collect the region
            queue = [(r, c)]
            visited[r][c] = True
            region = []
            touches_edge = False
            while queue:
                cr, cc = queue.pop(0)
                region.append((cr, cc))
                if cr == 0 or cr == height - 1 or cc == 0 or cc == width - 1:
                    touches_edge = True
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == 0:
                        visited[nr][nc] = True
                        queue.append((nr, nc))
            # Skip regions that touch the edge (not enclosed)
            if touches_edge:
                continue
            # Collect the set of non-background colors surrounding this region
            surrounding_colors = set()
            for (cr, cc) in region:
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                        surrounding_colors.add(grid[nr][nc])
            # It's a hollow core only if exactly one surrounding color (single enclosing shape)
            if len(surrounding_colors) == 1:
                hollow_cores.append(region)

    # Compute centroids (median row and median column) of each hollow core
    centroids = []
    for region in hollow_cores:
        rows_sorted = sorted([p[0] for p in region])
        cols_sorted = sorted([p[1] for p in region])
        median_row = rows_sorted[len(rows_sorted) // 2]
        median_col = cols_sorted[len(cols_sorted) // 2]
        centroids.append((median_row, median_col))

    # Sort centroids by ascending row then ascending column
    centroids.sort(key=lambda x: (x[0], x[1]))

    # Copy input to output then draw the connecting path(s)
    output = [row[:] for row in grid]
    path_color = 5

    # Greedy local walker matches generator: right, up, left, down
    def find_path(g, start, end):
        h = len(g)
        w = len(g[0])
        directions = [(0, 1), (-1, 0), (0, -1), (1, 0)]
        path = [start]
        current = start
        visited_local = set([start])
        while current != end:
            moved = False
            for dr, dc in directions:
                nr, nc = current[0] + dr, current[1] + dc
                if 0 <= nr < h and 0 <= nc < w and g[nr][nc] == 0 and (nr, nc) not in visited_local:
                    visited_local.add((nr, nc))
                    current = (nr, nc)
                    path.append(current)
                    moved = True
                    break
            if not moved:
                break
        return path

    for i in range(len(centroids) - 1):
        start = centroids[i]
        end = centroids[i + 1]
        # Defensive checks
        if not (0 <= start[0] < height and 0 <= start[1] < width):
            continue
        if not (0 <= end[0] < height and 0 <= end[1] < width):
            continue
        path = find_path(output, start, end)
        for (pr, pc) in path:
            if output[pr][pc] == 0:
                output[pr][pc] = path_color

    return tuple(tuple(row) for row in output)

