# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: acca4104
Difficulty: very hard

=== Tags ===
- Area based reconstruction
- Gate chain construction
- Maze wave
- Pattern expansion
- Carve negative space

=== Description ===
The task features input grids containing a complex maze structure composed of
contiguous cells in a single non-background color (representing the path), with
additional "gate" cells placed along the path. Each gate cell has a unique color
that encodes both a directional vector (e.g., red = right, blue = up, green =
left, yellow = down) and a sequential identifier (e.g., gate 1 = orange, gate 2
= purple). The gates are arranged in a specific sequence that forms a chain from
start to finish within the maze.  The output grid reconstructs the maze by
transforming the gate chain into a wave-like propagation pattern. Starting from
the first gate in the sequence, the wave propagates outward in the direction
specified by the gate's color, expanding in a ripple-like manner that fills
adjacent cells in all directions within the maze's boundaries. Each subsequent
gate in the chain modifies the wave's direction and expansion radius, with the
propagation continuing until it encounters maze boundaries or another gate. The
"carving" of negative space refers to the output's background (original
background color) being transformed to highlight the wave pattern, while the
maze's original structure remains visible as a secondary layer. The wave pattern
must precisely follow the directional cues from each gate in sequence, with no
overlaps or gaps in the propagation, and must terminate exactly at the final
gate's position. The complexity arises from the need to simultaneously decode
the gate sequence, interpret directional vectors, manage multi-directional wave
propagation, and ensure the wave adheres to the maze's topology without
violating the constraints of the gate chain.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Create a random meandering self-avoiding path and place directional gates on it.
    # The output shows a wave propagation starting from each gate in path-order.
    for attempt in range(1000):
        width = random.randint(10, 20)
        height = random.randint(10, 20)
        grid = [[0 for _ in range(width)] for _ in range(height)]

        # target path length relative to grid size
        max_cells = width * height
        target_len = random.randint(15, min(max(15, max_cells // 8), max_cells // 2))

        # Try to build a self-avoiding random walk of roughly target_len
        path = None
        for _ in range(250):
            start = (random.randint(1, height - 2), random.randint(1, width - 2))
            candidate = [start]
            visited = set(candidate)
            # Grow the path
            for _ in range(target_len - 1):
                r, c = candidate[-1]
                neigh = []
                for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in visited:
                        neigh.append((nr, nc))
                if not neigh:
                    break
                nxt = random.choice(neigh)
                candidate.append(nxt)
                visited.add(nxt)
            # Accept if long enough
            if len(candidate) >= 10:
                path = candidate
                break
        if path is None:
            continue

        # Canonicalize path orientation so the endpoint with smaller (r,c) is first.
        if path[0] > path[-1]:
            path = list(reversed(path))

        # Paint the path color
        for (r, c) in path:
            grid[r][c] = 1

        # Choose number of gates (2..4) but not more than available room
        max_gates = min(4, max(2, len(path) // 8))
        if max_gates < 2:
            num_gates = 2
        else:
            num_gates = random.randint(2, max_gates)

        # Pick gate indices along the canonical path with spacing >= 2
        possible_indices = list(range(2, len(path) - 2))
        gate_indices = None
        for _ in range(400):
            if len(possible_indices) < num_gates:
                break
            cand = sorted(random.sample(possible_indices, num_gates))
            ok = True
            for a, b in zip(cand, cand[1:]):
                if b - a < 2:
                    ok = False
                    break
            if ok:
                gate_indices = cand
                break
        if gate_indices is None:
            continue

        # Direction mapping: color -> (dr, dc)
        dir_to_color = {(0, 1): 2, (-1, 0): 3, (0, -1): 4, (1, 0): 5}
        dirs = list(dir_to_color.keys())

        # Assign a direction (and thus a color) to each gate ensuring the immediate
        # neighbor in that direction is free (not part of the path). If any gate
        # cannot be assigned such a direction, restart the generator loop.
        gates = []  # list of tuples (path_index, r, c, color, dr, dc)
        path_set = set(path)
        failed = False
        for pidx in gate_indices:
            r, c = path[pidx]
            choices = []
            for dr, dc in dirs:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in path_set:
                    choices.append((dr, dc))
            if not choices:
                failed = True
                break
            dr, dc = random.choice(choices)
            color = dir_to_color[(dr, dc)]
            gates.append((pidx, r, c, color, dr, dc))
        if failed:
            continue

        # Place gate colors on the input grid (replacing the path color at those cells)
        for _, r, c, color, _, _ in gates:
            grid[r][c] = color

        # Build the output by propagating waves from each gate in sequence
        output = [row[:] for row in grid]
        wave_color = 9
        used = set()

        # Ensure gates are in increasing path order
        gates.sort(key=lambda x: x[0])
        for order_idx, (pidx, r, c, color, dr, dc) in enumerate(gates):
            length = order_idx + 1
            for step in range(1, length + 1):
                nr, nc = r + dr * step, c + dc * step
                if not (0 <= nr < height and 0 <= nc < width):
                    break
                # don't overwrite any non-background cell (path or gate)
                if output[nr][nc] != 0:
                    break
                if (nr, nc) in used:
                    # avoid wave overlaps
                    break
                # mark the wave cell
                output[nr][nc] = wave_color
                used.add((nr, nc))
                # carve a small ripple: mark orthogonal neighbors if they are background
                for dr2, dc2 in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                    ar, ac = nr + dr2, nc + dc2
                    if 0 <= ar < height and 0 <= ac < width and output[ar][ac] == 0 and (ar, ac) not in used:
                        output[ar][ac] = wave_color
                        used.add((ar, ac))

        # Guarantee that something changed (avoid identical input/output)
        if len(used) == 0:
            # Force-first gate's immediate neighbor (which we ensured exists) to be marked
            fr, fc = gates[0][1], gates[0][2]
            fdr, fdc = gates[0][4], gates[0][5]
            nr, nc = fr + fdr, fc + fdc
            if 0 <= nr < height and 0 <= nc < width and output[nr][nc] == 0:
                output[nr][nc] = wave_color
                used.add((nr, nc))
            else:
                # if even that fails, restart generation
                continue

        if output == grid:
            # Shouldn't happen, but be safe
            continue

        return {"input": grid, "output": output}

    # Fallback deterministic example (used only if random attempts fail many times)
    width, height = 12, 12
    grid = [[0 for _ in range(width)] for _ in range(height)]
    path = [(6, i) for i in range(2, 10)]
    for (r, c) in path:
        grid[r][c] = 1
    # Two gates with clear free direction
    grid[6][4] = 2
    grid[6][7] = 3
    output = [row[:] for row in grid]
    # Use the same wave carving logic for fallback
    wave_color = 9
    used = set()
    gates = [(3, 6, 4, 2, 0, 1), (6, 6, 7, 3, -1, 0)]
    gates.sort(key=lambda x: x[0])
    for order_idx, (pidx, r, c, color, dr, dc) in enumerate(gates):
        length = order_idx + 1
        for step in range(1, length + 1):
            nr, nc = r + dr * step, c + dc * step
            if not (0 <= nr < height and 0 <= nc < width):
                break
            if output[nr][nc] != 0:
                break
            if (nr, nc) in used:
                break
            output[nr][nc] = wave_color
            used.add((nr, nc))
            for dr2, dc2 in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                ar, ac = nr + dr2, nc + dc2
                if 0 <= ar < height and 0 <= ac < width and output[ar][ac] == 0 and (ar, ac) not in used:
                    output[ar][ac] = wave_color
                    used.add((ar, ac))
    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Path includes the base path color (1) and gate colors (2..5)
    path_values = {1, 2, 3, 4, 5}
    path_cells = [(r, c) for r in range(height) for c in range(width) if grid[r][c] in path_values]
    path_set = set(path_cells)
    if not path_cells:
        return grid

    # Find endpoints (cells with exactly one path neighbor). If none, pick an arbitrary cell.
    def neighbors(r, c):
        for dr, dc in ((0, 1), (1, 0), (0, -1), (-1, 0)):
            yield r + dr, c + dc

    endpoints = []
    for (r, c) in path_cells:
        cnt = 0
        for nr, nc in neighbors(r, c):
            if (nr, nc) in path_set:
                cnt += 1
        if cnt == 1:
            endpoints.append((r, c))

    # Start from a canonical endpoint so ordering matches the generator's canonicalization
    if endpoints:
        start = min(endpoints)
    else:
        start = min(path_cells)

    # Reconstruct the path by walking from the chosen start
    path = [start]
    visited = {start}
    current = start
    while True:
        moved = False
        for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
            nr, nc = current[0] + dr, current[1] + dc
            if (nr, nc) in path_set and (nr, nc) not in visited:
                path.append((nr, nc))
                visited.add((nr, nc))
                current = (nr, nc)
                moved = True
                break
        if not moved:
            break

    # Ensure canonical orientation: the generator chooses the endpoint with smaller (r,c)
    if path[0] > path[-1]:
        path = list(reversed(path))

    # Locate gates (colors 2..5) and sort them according to their index along the canonical path
    gates = [(r, c, grid[r][c]) for r in range(height) for c in range(width) if 2 <= grid[r][c] <= 5]
    # If a gate is not in path (shouldn't happen), give it a large index
    def path_index(pos):
        try:
            return path.index(pos)
        except ValueError:
            return 10**9

    gates_sorted = sorted(gates, key=lambda x: path_index((x[0], x[1])))

    # Direction mapping matches the generator
    direction_map = {2: (0, 1), 3: (-1, 0), 4: (0, -1), 5: (1, 0)}

    output = [row[:] for row in grid]
    wave_color = 9
    used = set()

    # Propagate waves from each gate in order
    for idx, (r, c, color) in enumerate(gates_sorted):
        if color not in direction_map:
            continue
        dr, dc = direction_map[color]
        length = idx + 1
        for step in range(1, length + 1):
            nr, nc = r + dr * step, c + dc * step
            if not (0 <= nr < height and 0 <= nc < width):
                break
            if output[nr][nc] != 0:
                break
            if (nr, nc) in used:
                break
            output[nr][nc] = wave_color
            used.add((nr, nc))
            # carve the ripple: orthogonal neighbors
            for dr2, dc2 in ((0, 1), (1, 0), (0, -1), (-1, 0)):
                ar, ac = nr + dr2, nc + dc2
                if 0 <= ar < height and 0 <= ac < width and output[ar][ac] == 0 and (ar, ac) not in used:
                    output[ar][ac] = wave_color
                    used.add((ar, ac))

    # If no wave was created (should not happen for valid inputs), try to mark the immediate neighbor
    if not used and gates_sorted:
        gr, gc, gcol = gates_sorted[0]
        if gcol in direction_map:
            dr, dc = direction_map[gcol]
            nr, nc = gr + dr, gc + dc
            if 0 <= nr < height and 0 <= nc < width and output[nr][nc] == 0:
                output[nr][nc] = wave_color

    return output

