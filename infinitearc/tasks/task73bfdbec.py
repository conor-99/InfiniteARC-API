# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 73bfdbec
Difficulty: hard

=== Tags ===
- Take negative
- Associate colors to patterns
- Proximity guessing

=== Description ===
The task involves input grids containing colors 0â€“9, with a specific trigger
color (e.g., 5) present. The output grid is generated by identifying all
connected regions (patterns) of any color that are orthogonally adjacent
(sharing a side) to the trigger color. Each cell in such regions is then
replaced with its "negative" value, defined as 9 minus the original color.
Regions not adjacent to the trigger color remain unchanged. The trigger color
itself is preserved in the output and does not undergo inversion. This requires
recognizing the trigger color, determining adjacency to connected regions, and
applying a color transformation based on proximity, combining pattern
association with spatial reasoning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    import common
    width = random.randint(2, 30)
    height = random.randint(2, 30)
    grid_input = common.grid(width, height, 0)
    grid_input[0][0] = 5
    X = common.random_color(exclude=[5])
    grid_input[0][1] = X
    grid_input[1][0] = X
    grid_input[1][1] = X
    for r in range(height):
        for c in range(width):
            if grid_input[r][c] == 0:
                grid_input[r][c] = random.randint(0, 9)
    grid_output = [row[:] for row in grid_input]
    adjacent_to_5 = []
    for r in range(height):
        for c in range(width):
            if grid_input[r][c] == 5:
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        adjacent_to_5.append((nr, nc))
    visited = [[False] * width for _ in range(height)]
    for (r, c) in adjacent_to_5:
        if not visited[r][c] and grid_input[r][c] != 5:
            stack = [(r, c)]
            visited[r][c] = True
            region = []
            color = grid_input[r][c]
            while stack:
                cr, cc = stack.pop()
                region.append((cr, cc))
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid_input[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            for (cr, cc) in region:
                if grid_input[cr][cc] != 5:
                    grid_output[cr][cc] = 9 - grid_input[cr][cc]
    return {"input": grid_input, "output": grid_output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = [row[:] for row in input_grid]
    adjacent_to_5 = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 5:
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        adjacent_to_5.append((nr, nc))
    visited = [[False] * width for _ in range(height)]
    for (r, c) in adjacent_to_5:
        if not visited[r][c] and input_grid[r][c] != 5:
            stack = [(r, c)]
            visited[r][c] = True
            region = []
            color = input_grid[r][c]
            while stack:
                cr, cc = stack.pop()
                region.append((cr, cc))
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            for (cr, cc) in region:
                if input_grid[cr][cc] != 5:
                    output_grid[cr][cc] = 9 - input_grid[cr][cc]
    return output_grid
