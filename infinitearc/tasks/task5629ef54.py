# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 5629ef54
Difficulty: mediumâ€“hard

=== Tags ===
- Deterministic update
- Stacked layer alignment
- Associate patterns to colors

=== Description ===
Input grids feature a single background color (0) with multiple distinct color
layers (1-9) each forming a simple pattern. Each color corresponds to a fixed
pattern type: odd colors (1, 3, 5, 7, 9) form vertical lines spanning the grid's
height in a single column, while even colors (2, 4, 6, 8) form horizontal lines
spanning the grid's width in a single row. A horizontal pattern strip appears in
the top row (row 0), containing a sequence of colors that defines the vertical
stacking order for the layers in the output. The output grid preserves the
background and pattern strip unchanged. Each layer's pattern is relocated such
that for horizontal patterns (even colors), the line is moved to the row
matching the color's index in the pattern strip (e.g., the first color in the
strip moves to row 0), and for vertical patterns (odd colors), the line is moved
to the column matching the color's index (e.g., the second color in the strip
moves to column 1). Patterns are drawn on the background without overlapping
existing elements, and all lines are centered within their target rows or
columns. The transformation requires identifying the pattern type per color,
determining the target position from the strip, and relocating the pattern
accordingly.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Choose dimensions
    width = random.randint(5, 12)
    height = random.randint(5, 12)

    # Choose whether this example will use only odd (vertical) or only even (horizontal) layers.
    parity = random.choice(["odd", "even"])

    # Available colors by parity
    even_colors_pool = [2, 4, 6, 8]
    odd_colors_pool = [1, 3, 5, 7, 9]

    # Determine how many colors (length of the top strip). Keep it feasible so target indices fit.
    if parity == "even":
        max_colors = min(len(even_colors_pool), width, max(1, height - 1))
        count = random.randint(1, max_colors)
        colors = random.sample(even_colors_pool, count)
    else:
        # For odd (vertical) patterns we leave at least one column free after the strip so some patterns
        # can be placed off their final columns (guaranteeing input != output).
        max_colors = min(len(odd_colors_pool), width - 1)
        if max_colors < 1:
            # Fallback (shouldn't happen because width >= 5), but keep generator robust
            max_colors = 1
        count = random.randint(1, max_colors)
        colors = random.sample(odd_colors_pool, count)

    # Build input grid with background 0 and the top strip (row 0)
    input_grid = [[0 for _ in range(width)] for __ in range(height)]
    for i, col in enumerate(colors):
        input_grid[0][i] = col

    # Place each pattern somewhere else in the grid (not necessarily at its target index)
    if parity == "even":
        # Horizontal lines: choose distinct rows from 1..height-1
        rows_pool = list(range(1, height))
        # Sample unique rows for each color
        rows = random.sample(rows_pool, count)
        # Ensure at least one pattern is not already at its target row (so input != output)
        if all(rows[i] == i for i in range(count)):
            if count == 1:
                # Try to pick a different row if possible
                for r in rows_pool:
                    if r != 0 and r != rows[0]:
                        rows[0] = r
                        break
            else:
                rows[0], rows[1] = rows[1], rows[0]
        # Paint the chosen rows with their colors
        for i, color in enumerate(colors):
            r = rows[i]
            for c in range(width):
                input_grid[r][c] = color
    else:
        # Vertical lines: we allow some patterns to be placed in columns outside the strip
        # so that at least one pattern will need to be moved in the output.
        outside_cols = list(range(len(colors), width))  # columns after the reserved strip
        # Choose how many patterns we place outside the reserved strip (at least 1 if possible)
        possible_out = min(len(outside_cols), count)
        if possible_out >= 1:
            outside_count = random.randint(1, possible_out)
            chosen_outside = random.sample(outside_cols, outside_count)
        else:
            outside_count = 0
            chosen_outside = []

        # Assign columns for each color. Some get assigned to an outside column, others remain at their
        # own target column (so they won't overwrite the strip).
        columns = [None] * count
        indices = list(range(count))
        random.shuffle(indices)
        # Assign outside columns to a subset of color indices
        for j, idx_col in enumerate(indices[:outside_count]):
            columns[idx_col] = chosen_outside[j]
        # Remaining colors keep their target column (their index)
        for i in range(count):
            if columns[i] is None:
                columns[i] = i

        # Paint the chosen columns with their colors (avoid touching the top row to preserve the strip)
        for i, color in enumerate(colors):
            cc = columns[i]
            for r in range(1, height):
                input_grid[r][cc] = color

    # Build the output by starting from the background and copying the top row (strip) unchanged,
    # then drawing layers in the left-to-right order of the strip onto background-only cells.
    output_grid = [[0 for _ in range(width)] for __ in range(height)]
    output_grid[0] = input_grid[0][:]

    for idx, color in enumerate(colors):
        if color % 2 == 0:
            # horizontal -> target row is idx (if within bounds)
            if idx < height:
                for c in range(width):
                    if output_grid[idx][c] == 0:
                        output_grid[idx][c] = color
        else:
            # vertical -> target column is idx (if within bounds)
            if idx < width:
                for r in range(height):
                    if output_grid[r][idx] == 0:
                        output_grid[r][idx] = color

    # Safety: ensure input != output (should hold because we enforced at least one outside placement)
    if input_grid == output_grid:
        # Very unlikely; regenerate a new example
        return generate()

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Identify the top-left contiguous non-zero sequence as the pattern strip
    strip_len = 0
    for c in range(width):
        if grid[0][c] == 0:
            break
        strip_len += 1
    strip = grid[0][:strip_len]

    # Start output as background with the top row copied unchanged
    output = [[0 for _ in range(width)] for __ in range(height)]
    output[0] = grid[0][:]

    # Draw each layer in left-to-right order, writing only onto background (zero) cells.
    for idx, color in enumerate(strip):
        if color == 0:
            continue
        if color % 2 == 0:
            # horizontal -> row idx
            if idx < height:
                for c in range(width):
                    if output[idx][c] == 0:
                        output[idx][c] = color
        else:
            # vertical -> column idx
            if idx < width:
                for r in range(height):
                    if output[r][idx] == 0:
                        output[r][idx] = color

    return output

