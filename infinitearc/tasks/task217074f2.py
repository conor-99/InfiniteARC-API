# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 217074f2
Difficulty: insane

=== Tags ===
- Recursive partition
- Associate colors to ranks
- Reflect by color

=== Description ===
Recursive Color Reflection  Input grids are square (20×20 to 30×30) with
background color 0. Non-zero colors represent distinct entities. The output grid
is generated by recursively partitioning the input into quadrants. At each
recursion level, the top-left cell of each quadrant determines the reflection
axis: if the color value is odd, the quadrant is reflected vertically (left-
right); if even, horizontally (top-bottom). The reflection is applied before
further partitioning. The process continues until quadrants reach 1×1 size. Each
color is associated with its value as a rank (e.g., color 4 is rank 4), and the
parity of the rank dictates the reflection direction. Background cells (0) do
not trigger reflection and are treated as empty space during partitioning. The
output grid reflects all recursive transformations, resulting in a visually
complex, mirrored structure that depends on the color hierarchy of the input.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from copy import deepcopy

def get_required_positions(N):
    positions = []
    queue = [(0, 0, N, N)]
    while queue:
        top, left, height, width = queue.pop(0)
        if height > 1 or width > 1:
            positions.append((top, left))
        if height > 1 or width > 1:
            mid_h = height // 2
            mid_w = width // 2
            queue.append((top, left, mid_h, mid_w))
            queue.append((top, left + mid_w, mid_h, width - mid_w))
            queue.append((top + mid_h, left, height - mid_h, mid_w))
            queue.append((top + mid_h, left + mid_w, height - mid_h, width - mid_w))
    return positions

def apply_reflection(grid):
    grid_copy = deepcopy(grid)
    N = len(grid_copy)
    
    def process(top, left, height, width):
        if height <= 1 or width <= 1:
            return
        color = grid_copy[top][left]
        if color != 0:
            if color % 2 == 1:
                for r in range(top, top + height):
                    grid_copy[r][left:left+width] = grid_copy[r][left:left+width][::-1]
            else:
                for c in range(left, left + width):
                    for r in range(height // 2):
                        r1 = top + r
                        r2 = top + height - 1 - r
                        grid_copy[r1][c], grid_copy[r2][c] = grid_copy[r2][c], grid_copy[r1][c]
        mid_h = height // 2
        mid_w = width // 2
        process(top, left, mid_h, mid_w)
        process(top, left + mid_w, mid_h, width - mid_w)
        process(top + mid_h, left, height - mid_h, mid_w)
        process(top + mid_h, left + mid_w, height - mid_h, width - mid_w)
    
    process(0, 0, N, N)
    return grid_copy

def generate():
    while True:
        N = random.randint(20, 30)
        grid = [[0] * N for _ in range(N)]
        required_positions = get_required_positions(N)
        for (i, j) in required_positions:
            grid[i][j] = random.randint(1, 9)
        for i in range(N):
            for j in range(N):
                if (i, j) not in required_positions and random.random() > 0.5:
                    grid[i][j] = random.randint(1, 9)
        input_grid = grid
        output_grid = apply_reflection(grid)
        if tuple(tuple(row) for row in input_grid) != tuple(tuple(row) for row in output_grid):
            return {
                "input": input_grid,
                "output": output_grid
            }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    N = len(grid)
    
    def process(top, left, height, width):
        if height <= 1 or width <= 1:
            return
        color = grid[top][left]
        if color != 0:
            if color % 2 == 1:
                for r in range(top, top + height):
                    grid[r][left:left+width] = grid[r][left:left+width][::-1]
            else:
                for c in range(left, left + width):
                    for r in range(height // 2):
                        r1 = top + r
                        r2 = top + height - 1 - r
                        grid[r1][c], grid[r2][c] = grid[r2][c], grid[r1][c]
        mid_h = height // 2
        mid_w = width // 2
        process(top, left, mid_h, mid_w)
        process(top, left + mid_w, mid_h, width - mid_w)
        process(top + mid_h, left, height - mid_h, mid_w)
        process(top + mid_h, left + mid_w, height - mid_h, width - mid_w)
    
    process(0, 0, N, N)
    return tuple(tuple(row) for row in grid)
