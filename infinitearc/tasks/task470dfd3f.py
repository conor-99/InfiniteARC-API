# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 470dfd3f
Difficulty: insane

=== Tags ===
- Iterative rule application
- Pattern repetition
- Pattern intersection
- Inverse procedural generation

=== Description ===
The input grids are complex visual compositions where multiple overlapping
patterns, each representing a distinct procedural step, have been iteratively
applied to a central base pattern. Each step expands the pattern outward using a
new color, causing intersections where patterns overlap. The base pattern—being
the smallest connected region in the input—represents the initial state before
any expansions. The output grid is generated by identifying this base pattern
(via its minimal size), preserving only its color, and setting all other cells
to background (color 0). This transformation reverses the procedural generation
process by isolating the earliest pattern, requiring the solver to recognize
that the smallest connected component corresponds to the inverse of the
iterative expansion. The task demands careful visual analysis of pattern size,
intersection resolution, and iterative layer reversal, with the base pattern
often obscured by overlapping layers of larger, more numerous patterns.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 15)
    height = random.randint(5, 15)
    grid = [[0] * width for _ in range(height)]
    
    base_color = random.randint(1, 9)
    grid[0][0] = base_color
    
    mid_row = height // 2
    pattern1_color = random.randint(1, 9)
    while pattern1_color == base_color:
        pattern1_color = random.randint(1, 9)
    for c in range(width):
        grid[mid_row][c] = pattern1_color
    
    mid_col = width // 2
    pattern2_color = random.randint(1, 9)
    while pattern2_color == base_color or pattern2_color == pattern1_color:
        pattern2_color = random.randint(1, 9)
    for r in range(height):
        grid[r][mid_col] = pattern2_color
    
    output = [[0] * width for _ in range(height)]
    output[0][0] = base_color
    
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    visited = [[False] * width for _ in range(height)]
    min_size = float('inf')
    min_region = None
    min_color = None
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and input_grid[r][c] != 0:
                color = input_grid[r][c]
                stack = [(r, c)]
                visited[r][c] = True
                region = []
                while stack:
                    cr, cc = stack.pop()
                    region.append((cr, cc))
                    for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                size = len(region)
                if size < min_size:
                    min_size = size
                    min_region = region
                    min_color = color
    
    output = [[0] * width for _ in range(height)]
    for (r, c) in min_region:
        output[r][c] = min_color
    return output
