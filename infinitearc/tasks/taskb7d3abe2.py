# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: b7d3abe2
Difficulty: easy

=== Tags ===
- Add center crosshair
- Place dot in object center
- Find the odd shape out

=== Description ===
The input grids contain one or more connected shapes (groups of adjacent non-
zero pixels) within a 2D grid. The output grid is generated by applying two
consistent visual transformations: first, adding a crosshair (a plus sign formed
by the center cell and its four orthogonally adjacent cells) at the exact center
of the grid; second, placing a single dot at the centroid (average position of
all pixels within the shape) of each connected shape. The crosshair and dots are
represented using distinct, consistent colors (e.g., crosshair in a bright
color, dots in a contrasting color), while all other grid pixels remain
unchanged from the input. The task requires identifying the grid center and
shape centroids through spatial reasoning rather than numerical computation,
with all grids having odd dimensions to ensure a well-defined center.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import continuous_creature
def generate():
    n = random.choice([3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29])
    input_grid = [[0] * n for _ in range(n)]
    shape_size = min(random.randint(3, 10), n * n)
    pixels = continuous_creature(shape_size, n, n)
    for r, c in pixels:
        input_grid[r][c] = 1
    output_grid = [row[:] for row in input_grid]
    center = n // 2
    for dr, dc in [(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0)]:
        r, c = center + dr, center + dc
        if 0 <= r < n and 0 <= c < n:
            output_grid[r][c] = 2
    total_r = sum(r for r, c in pixels)
    total_c = sum(c for r, c in pixels)
    centroid_r = round(total_r / len(pixels))
    centroid_c = round(total_c / len(pixels))
    if 0 <= centroid_r < n and 0 <= centroid_c < n:
        output_grid[centroid_r][centroid_c] = 3
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    n = len(input_grid)
    center = n // 2
    output = [row[:] for row in input_grid]
    for dr, dc in [(0, 0), (0, 1), (0, -1), (1, 0), (-1, 0)]:
        r, c = center + dr, center + dc
        if 0 <= r < n and 0 <= c < n:
            output[r][c] = 2
    visited = [[False] * n for _ in range(n)]
    components = []
    for i in range(n):
        for j in range(n):
            if input_grid[i][j] != 0 and not visited[i][j]:
                component = []
                queue = [(i, j)]
                visited[i][j] = True
                while queue:
                    r, c = queue.pop(0)
                    component.append((r, c))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < n and 0 <= nc < n and input_grid[nr][nc] != 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                components.append(component)
    for comp in components:
        total_r = sum(r for r, c in comp)
        total_c = sum(c for r, c in comp)
        centroid_r = round(total_r / len(comp))
        centroid_c = round(total_c / len(comp))
        if 0 <= centroid_r < n and 0 <= centroid_c < n:
            output[centroid_r][centroid_c] = 3
    return output
