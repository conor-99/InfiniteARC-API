# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 7371b047
Difficulty: medium

=== Tags ===
- Contouring
- Sort colors by index
- Algebra
- Contour thickening

=== Description ===
The task involves transforming an input grid containing a single connected shape
(a contiguous region of non-zero values surrounded by background 0s) into an
output grid through the following steps:  1. **Contour Identification**: The
contour is defined as the boundary pixels of the shapeâ€”those that are part of
the shape (non-zero) and adjacent to at least one background pixel (0) in any of
the four cardinal directions.  2. **Color Sorting**: The color values of all
contour pixels are collected and sorted in ascending numerical order (e.g., [7,
2, 5] becomes [2, 5, 7]).  3. **Contour Reassignment**: The sorted color values
are reassigned to the contour pixels in row-major order (top-to-bottom, left-to-
right), replacing their original colors.  4. **Contour Thickening**: The contour
is thickened by one pixel outward in all directions. For each pixel in the
original contour, the newly added adjacent background pixels (now part of the
thickened contour) are colored using the sorted color list in order. If the
sorted list is exhausted, it cycles through the list again.  This process
ensures the output grid has a uniformly thickened contour (two pixels wide) with
colors arranged in ascending order, adhering to the "Contouring," "Sort colors
by index," "Algebra" (numerical sorting), and "Contour thickening"
transformation rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

from common import continuous_creature, grid, randint, random_colors

def generate():
    while True:
        width = randint(5, 30)
        height = randint(5, 30)
        size = randint(5, 9)
        pixels = continuous_creature(size, width, height)
        input_grid = grid(width, height, 0)
        colors = random_colors(len(pixels))
        for (r, c), color in zip(pixels, colors):
            input_grid[r][c] = color
        
        contour = []
        for (r, c) in pixels:
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 0:
                    contour.append((r, c))
                    break
        
        if not contour:
            continue
        
        contour_colors = [input_grid[r][c] for (r, c) in contour]
        contour_colors.sort()
        
        output_grid = [row[:] for row in input_grid]
        
        contour_sorted = sorted(contour, key=lambda x: (x[0], x[1]))
        for idx, (r, c) in enumerate(contour_sorted):
            output_grid[r][c] = contour_colors[idx % len(contour_colors)]
        
        new_pixels = set()
        for (r, c) in contour:
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 0:
                    new_pixels.add((nr, nc))
        
        new_pixels = sorted(new_pixels, key=lambda x: (x[0], x[1]))
        for idx, (r, c) in enumerate(new_pixels):
            output_grid[r][c] = contour_colors[idx % len(contour_colors)]
        
        if input_grid == output_grid:
            continue
        else:
            return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Ensure input is list of lists (not tuple)
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    
    height = len(input_grid)
    width = len(input_grid[0])
    
    shape_pixels = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                shape_pixels.append((r, c))
    
    contour = []
    for (r, c) in shape_pixels:
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 0:
                contour.append((r, c))
                break
    
    if not contour:
        return input_grid
    
    contour_colors = [input_grid[r][c] for (r, c) in contour]
    contour_colors.sort()
    
    output_grid = [row[:] for row in input_grid]
    
    contour_sorted = sorted(contour, key=lambda x: (x[0], x[1]))
    for idx, (r, c) in enumerate(contour_sorted):
        output_grid[r][c] = contour_colors[idx % len(contour_colors)]
    
    new_pixels = set()
    for (r, c) in contour:
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 0:
                new_pixels.add((nr, nc))
    
    new_pixels = sorted(new_pixels, key=lambda x: (x[0], x[1]))
    for idx, (r, c) in enumerate(new_pixels):
        output_grid[r][c] = contour_colors[idx % len(contour_colors)]
    
    return output_grid
