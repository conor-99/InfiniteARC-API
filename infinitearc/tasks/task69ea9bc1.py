# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 69ea9bc1
Difficulty: hard

=== Tags ===
- Embedded rule repetition
- Hollow core detection
- Color transfer on contact
- Direction guessing
- Recolor

=== Description ===
Hollow Core Cascade  Input grids feature multiple disjoint closed-loop shapes on
a uniform background, each with a distinct colored boundary (1-9) enclosing a
hollow core (empty region, color 0). Scattered outside these shapes are small
colored "source" cells (non-zero colors) positioned adjacent to hollow
boundaries. The hollow cores vary in size (from 1x1 to 5x5) and may overlap in
complex arrangements.  The transformation follows these sequential rules: 1.
**Hollow Core Detection**: Identify all maximal empty regions completely
enclosed by a single color boundary. Boundaries must form a closed loop with no
gaps (orthogonally connected). 2. **Color Transfer on Contact**: For each hollow
core, evaluate all orthogonally adjacent source cells. Prioritize sources by:
- First sorting contact points clockwise starting from the topmost edge of the
hollow    - Using the first source encountered in this order    - If no sources
contact a hollow, it remains empty 3. **Direction Guessing**: Determine the
spreading direction from the contact side:    - Top contact → spread downward
through the hollow    - Right contact → spread leftward    - Bottom contact →
spread upward    - Left contact → spread rightward 4. **Embedded Rule
Repetition**: After the hollow core adopts a color, recursively check if newly
colored cells now contact other hollow cores (treating the new color as a
source), applying the same transfer rules until no more contacts occur. 5.
**Recolor**: All cells within the hollow core become the transferred color,
filled in the direction-specified order. Boundary colors remain unchanged.
Source cells retain their original color unless they were adjacent to a hollow.
The task requires simultaneously detecting multiple hollows, resolving contact
conflicts via directional sorting, applying recursive color propagation, and
maintaining visual consistency in the output. Complexity arises from nested
hollow structures, overlapping contact points, and the need to sequentially
apply rule layers without visual aids for direction.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import math
import common


def generate():
    """
    Generate an ARC-style grid pair for the "Hollow Core Cascade" task.

    Creates 2-4 rectangular hollow rings (closed-loop boundaries) with distinct
    colors on a uniform background. Interiors are zero. Sources (colors 6-9)
    are placed on background cells orthogonally adjacent to boundary cells.
    The output is computed by applying the cascade rules: for each hollow,
    choose the contacting source by clockwise order starting at the top,
    fill the hollow with that source color, and repeat until no more hollows
    can be filled.
    """
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    bg = 5
    grid = common.grid(width, height, bg)

    boundary_color_pool = [1, 2, 3, 4]
    source_colors = [6, 7, 8, 9]

    num_hollows = random.randint(2, 4)
    boundary_colors = random.sample(boundary_color_pool, num_hollows)

    boundary_set = set()
    hollows = []

    def boundary_cells_for_rect(r, c, h, w):
        cells = []
        for col in range(c, c + w):
            cells.append((r, col))
            cells.append((r + h - 1, col))
        for row in range(r + 1, r + h - 1):
            cells.append((row, c))
            cells.append((row, c + w - 1))
        return cells

    def is_boundary_placement_ok(cells):
        # Boundaries must not overlap or be orthogonally adjacent to existing boundaries
        for (br, bc) in cells:
            if (br, bc) in boundary_set:
                return False
            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                if (br + dr, bc + dc) in boundary_set:
                    return False
        return True

    # Place hollow rectangular rings, allow some nesting inside existing hollows
    for i in range(num_hollows):
        color = boundary_colors[i]
        placed = False
        for _ in range(300):
            try_nested = len(hollows) > 0 and random.random() < 0.45
            if try_nested:
                # pick a parent with enough interior space
                candidates = [h for h in hollows if h['h'] - 2 >= 3 and h['w'] - 2 >= 3]
                if not candidates:
                    try_nested = False
                else:
                    parent = random.choice(candidates)
                    inner_r0 = parent['r'] + 1
                    inner_c0 = parent['c'] + 1
                    inner_h = parent['h'] - 2
                    inner_w = parent['w'] - 2
                    h = random.randint(3, min(7, inner_h))
                    w = random.randint(3, min(7, inner_w))
                    r = random.randint(inner_r0, inner_r0 + inner_h - h)
                    c = random.randint(inner_c0, inner_c0 + inner_w - w)
                    cells = boundary_cells_for_rect(r, c, h, w)
                    if not is_boundary_placement_ok(cells):
                        continue
            if not try_nested:
                # top-level hollow: ensure margin to allow external sources
                h = random.randint(3, min(7, height - 4))
                w = random.randint(3, min(7, width - 4))
                if height - h - 2 < 1 or width - w - 2 < 1:
                    continue
                r = random.randint(1, height - h - 1)
                c = random.randint(1, width - w - 1)
                cells = boundary_cells_for_rect(r, c, h, w)
                if not is_boundary_placement_ok(cells):
                    continue

            # Place boundary
            for (br, bc) in cells:
                grid[br][bc] = color
                boundary_set.add((br, bc))
            # Fill interior with zeros
            for rr in range(r + 1, r + h - 1):
                for cc in range(c + 1, c + w - 1):
                    grid[rr][cc] = 0

            hollows.append({'r': r, 'c': c, 'h': h, 'w': w, 'color': color})
            placed = True
            break
        if not placed:
            break

    # Place sources (non-zero colors) on background cells adjacent to boundary cells
    sources = []
    for hinfo in hollows:
        if random.random() < 0.8:
            sides = ['top', 'right', 'bottom', 'left']
            random.shuffle(sides)
            done = False
            for side in sides:
                if side == 'top':
                    row = hinfo['r'] - 1
                    col = hinfo['c'] + random.randint(1, hinfo['w'] - 2)
                elif side == 'right':
                    row = hinfo['r'] + random.randint(1, hinfo['h'] - 2)
                    col = hinfo['c'] + hinfo['w']
                elif side == 'bottom':
                    row = hinfo['r'] + hinfo['h']
                    col = hinfo['c'] + random.randint(1, hinfo['w'] - 2)
                else:
                    row = hinfo['r'] + random.randint(1, hinfo['h'] - 2)
                    col = hinfo['c'] - 1
                if 0 <= row < height and 0 <= col < width and grid[row][col] == bg:
                    scol = random.choice(source_colors)
                    grid[row][col] = scol
                    sources.append((row, col, scol))
                    done = True
                    break
            # if none side fit, skip

    # Ensure at least one source exists
    if len(sources) == 0 and len(hollows) > 0:
        hinfo = random.choice(hollows)
        possible = []
        if hinfo['r'] - 1 >= 0:
            possible.append((hinfo['r'] - 1, hinfo['c'] + (hinfo['w'] - 1) // 2))
        if hinfo['c'] + hinfo['w'] < width:
            possible.append((hinfo['r'] + (hinfo['h'] - 1) // 2, hinfo['c'] + hinfo['w']))
        if hinfo['r'] + hinfo['h'] < height:
            possible.append((hinfo['r'] + hinfo['h'], hinfo['c'] + (hinfo['w'] - 1) // 2))
        if hinfo['c'] - 1 >= 0:
            possible.append((hinfo['r'] + (hinfo['h'] - 1) // 2, hinfo['c'] - 1))
        random.shuffle(possible)
        for (row, col) in possible:
            if 0 <= row < height and 0 <= col < width and grid[row][col] == bg:
                scol = random.choice(source_colors)
                grid[row][col] = scol
                sources.append((row, col, scol))
                break

    input_grid = [row[:] for row in grid]

    # Compute output using cascade rules. Reuse a similar hollow detection that also
    # returns the boundary cells for each core so we can detect sources that are
    # adjacent to the outside of the boundary.
    def find_hollows_with_boundary(g):
        visited = [[False] * W for _ in range(H)]
        cores = []
        for rr in range(H):
            for cc in range(W):
                if g[rr][cc] != 0 or visited[rr][cc]:
                    continue
                comp = []
                q = [(rr, cc)]
                visited[rr][cc] = True
                touch_border = False
                idx = 0
                while idx < len(q):
                    r0, c0 = q[idx]
                    idx += 1
                    comp.append((r0, c0))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = r0 + dr, c0 + dc
                        if not (0 <= nr < H and 0 <= nc < W):
                            touch_border = True
                            continue
                        if g[nr][nc] == 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            q.append((nr, nc))
                if touch_border:
                    continue
                # gather boundary cells (non-zero neighbors of the interior)
                boundary_cells = set()
                neigh_colors = set()
                minr = min(p[0] for p in comp)
                maxr = max(p[0] for p in comp)
                minc = min(p[1] for p in comp)
                maxc = max(p[1] for p in comp)
                for (r0, c0) in comp:
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = r0 + dr, c0 + dc
                        if 0 <= nr < H and 0 <= nc < W and g[nr][nc] != 0:
                            boundary_cells.add((nr, nc))
                            neigh_colors.add(g[nr][nc])
                if len(neigh_colors) == 1 and len(boundary_cells) > 0:
                    boundary_color = next(iter(neigh_colors))
                    cores.append({'cells': comp,
                                  'boundary_cells': list(boundary_cells),
                                  'boundary_color': boundary_color,
                                  'bbox': (minr, maxr, minc, maxc)})
        return cores

    H = height
    W = width
    out = [row[:] for row in input_grid]

    def clockwise_angle(center_r, center_c, r, c):
        dr = r - center_r
        dc = c - center_c
        ang = math.atan2(dc, -dr)
        if ang < 0:
            ang += 2 * math.pi
        return ang

    cores = find_hollows_with_boundary(out)
    colored = [False] * len(cores)

    changed = True
    while changed:
        changed = False
        for i, core in enumerate(cores):
            if colored[i]:
                continue
            comp = core['cells']
            bcol = core['boundary_color']
            minr, maxr, minc, maxc = core['bbox']
            boundary_cells = core['boundary_cells']

            # For each boundary cell, look on the outside side for a source cell.
            candidates = set()
            comp_set = set(comp)
            for (br, bc) in boundary_cells:
                # find a neighbor that is part of interior to identify orientation
                orient = None
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    ir, ic = br + dr, bc + dc
                    if (ir, ic) in comp_set:
                        orient = (dr, dc)
                        break
                if orient is None:
                    continue
                # outside cell is opposite direction
                outr = br - orient[0]
                outc = bc - orient[1]
                if 0 <= outr < H and 0 <= outc < W:
                    val = out[outr][outc]
                    if val != 0 and val != bcol:
                        candidates.add((outr, outc, val))

            if not candidates:
                continue
            center_r = (minr + maxr) / 2.0
            center_c = (minc + maxc) / 2.0
            cand_list = list(candidates)
            # Sort by angle, then tie-break by row and column to be deterministic
            cand_list.sort(key=lambda x: (clockwise_angle(center_r, center_c, x[0], x[1]), x[0], x[1]))
            chosen_color = cand_list[0][2]
            for (r0, c0) in comp:
                out[r0][c0] = chosen_color
            colored[i] = True
            changed = True

    # Guarantee input != output: if no hollow got colored, force-color one hollow with color 6
    if out == input_grid and len(cores) > 0:
        core = cores[0]
        comp = core['cells']
        fill_color = 6
        for (r0, c0) in comp:
            out[r0][c0] = fill_color

    return { 'input': input_grid, 'output': out }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import math

def p(inp):
    # Convert to mutable grid
    grid = [list(row) for row in inp]
    H = len(grid)
    W = len(grid[0])

    def find_hollows_with_boundary(g):
        visited = [[False] * W for _ in range(H)]
        cores = []
        for rr in range(H):
            for cc in range(W):
                if g[rr][cc] != 0 or visited[rr][cc]:
                    continue
                comp = []
                q = [(rr, cc)]
                visited[rr][cc] = True
                touch_border = False
                idx = 0
                while idx < len(q):
                    r0, c0 = q[idx]
                    idx += 1
                    comp.append((r0, c0))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = r0 + dr, c0 + dc
                        if not (0 <= nr < H and 0 <= nc < W):
                            touch_border = True
                            continue
                        if g[nr][nc] == 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            q.append((nr, nc))
                if touch_border:
                    continue
                boundary_cells = set()
                neigh_colors = set()
                minr = min(p[0] for p in comp)
                maxr = max(p[0] for p in comp)
                minc = min(p[1] for p in comp)
                maxc = max(p[1] for p in comp)
                for (r0, c0) in comp:
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = r0 + dr, c0 + dc
                        if 0 <= nr < H and 0 <= nc < W and g[nr][nc] != 0:
                            boundary_cells.add((nr, nc))
                            neigh_colors.add(g[nr][nc])
                if len(neigh_colors) == 1 and len(boundary_cells) > 0:
                    boundary_color = next(iter(neigh_colors))
                    cores.append({'cells': comp,
                                  'boundary_cells': list(boundary_cells),
                                  'boundary_color': boundary_color,
                                  'bbox': (minr, maxr, minc, maxc)})
        return cores

    def clockwise_angle(center_r, center_c, r, c):
        dr = r - center_r
        dc = c - center_c
        ang = math.atan2(dc, -dr)
        if ang < 0:
            ang += 2 * math.pi
        return ang

    out = [row[:] for row in grid]
    cores = find_hollows_with_boundary(out)
    colored = [False] * len(cores)

    changed = True
    while changed:
        changed = False
        for i, core in enumerate(cores):
            if colored[i]:
                continue
            comp = core['cells']
            bcol = core['boundary_color']
            minr, maxr, minc, maxc = core['bbox']
            boundary_cells = core['boundary_cells']

            candidates = set()
            comp_set = set(comp)
            for (br, bc) in boundary_cells:
                orient = None
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    ir, ic = br + dr, bc + dc
                    if (ir, ic) in comp_set:
                        orient = (dr, dc)
                        break
                if orient is None:
                    continue
                outr = br - orient[0]
                outc = bc - orient[1]
                if 0 <= outr < H and 0 <= outc < W:
                    val = out[outr][outc]
                    if val != 0 and val != bcol:
                        candidates.add((outr, outc, val))

            if not candidates:
                continue
            center_r = (minr + maxr) / 2.0
            center_c = (minc + maxc) / 2.0
            cand_list = list(candidates)
            cand_list.sort(key=lambda x: (clockwise_angle(center_r, center_c, x[0], x[1]), x[0], x[1]))
            chosen_color = cand_list[0][2]
            for (r0, c0) in comp:
                out[r0][c0] = chosen_color
            colored[i] = True
            changed = True

    if out == grid and len(cores) > 0:
        comp = cores[0]['cells']
        for (r0, c0) in comp:
            out[r0][c0] = 6

    return out

