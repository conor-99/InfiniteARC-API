# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 7fc44519
Difficulty: medium

=== Tags ===
- Associate images to numbers
- Draw rectangle
- Image juxtaposition
- Spacing

=== Description ===
The task involves transforming an input grid containing two distinct visual
shapes (e.g., a horizontal line of three cells and a vertical line of two cells)
into an output grid where these shapes are placed side by side horizontally with
a fixed one-cell gap between them. The shapes retain their original colors and
dimensions, and the transformation is based solely on their spatial arrangement.
The "Image juxtaposition" refers to the horizontal placement of the shapes,
while "Spacing" specifies the consistent one-cell buffer between them. The
"Associate images to numbers" tag reflects that each shape's visual size (e.g.,
length or width) corresponds to a numerical concept (e.g., a three-cell line
represents a "3"), though the rule does not rely on numerical valuesâ€”it only
uses the visual properties of the shapes to determine their placement in the
output. The output grid is generated by positioning the shapes adjacent to each
other with precisely one empty cell separating them, preserving all original
visual details.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    colors = list(range(1, 10))
    c1, c2 = random.sample(colors, 2)
    l1 = random.randint(2, 5)
    l2 = random.randint(2, 5)
    width = max(l1 + 3, 5)
    height = max(l2 + 2, 5)
    input_grid = grid(width, height, 0)
    for c in range(l1):
        input_grid[0][c] = c1
    for r in range(1, 1 + l2):
        if l1 + 1 < width:
            input_grid[r][l1 + 1] = c2
        else:
            input_grid[r][width - 1] = c2
    output_grid = [c1] * l1 + [0] + [c2] * l2
    return {"input": input_grid, "output": [output_grid]}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    max_h_length = 0
    h_color = None
    for r in range(len(input_grid)):
        c = 0
        while c < len(input_grid[0]):
            if input_grid[r][c] == 0:
                c += 1
                continue
            color = input_grid[r][c]
            length = 0
            while c + length < len(input_grid[0]) and input_grid[r][c + length] == color:
                length += 1
            if length > max_h_length:
                max_h_length = length
                h_color = color
            c += length
    max_v_length = 0
    v_color = None
    for c in range(len(input_grid[0])):
        r = 0
        while r < len(input_grid):
            if input_grid[r][c] == 0:
                r += 1
                continue
            color = input_grid[r][c]
            length = 0
            while r + length < len(input_grid) and input_grid[r + length][c] == color:
                length += 1
            if length > max_v_length:
                max_v_length = length
                v_color = color
            r += length
    output = [h_color] * max_h_length + [0] + [v_color] * max_v_length
    return [output]
