# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: b7bc0c6f
Difficulty: medium–hard

=== Tags ===
- Adaptive behavior switch
- Motif extraction
- Compositional reflection
- Deterministic update
- Detect background color
- Gravity

=== Description ===
**Adaptive Motif Gravity Grid**    Input grids feature a dominant background
color (typically appearing in at least 60% of cells) and multiple foreground
motifs. Each motif is a contiguous, non-background-colored shape (e.g., 2×2
squares, T-shapes, or L-shapes) arranged in a consistent pattern. The primary
motif—identified as the largest or most centrally located—determines the
transformation rules.    First, the background color is detected by identifying
the most frequent color (excluding isolated pixels). Next, the primary motif’s
orientation is analyzed: if its bounding box is wider than tall, the grid
undergoes horizontal reflection (mirroring left-right); if taller than wide,
vertical reflection (mirroring top-bottom). This reflection is applied
compositionally, meaning only the foreground motifs (not the background) are
mirrored, preserving their relative positions.    Finally, gravity is applied
deterministically: all non-background elements are shifted downward as far as
possible within their columns, stacking from the bottom upward while maintaining
their horizontal order. Background cells remain unchanged, and no elements
overwrite one another during stacking. The output grid reflects the mirrored
motifs and gravity-shifted structure, with all transformations strictly derived
from the visual properties of the input (no numerical or positional dependencies
beyond the motif’s shape and background detection).
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque
from math import sqrt

# Generator for ARC task

def generate():
    # Templates for motifs (normalized shapes will be computed)
    raw_templates = [
        # 2x2 square
        [(0,0),(0,1),(1,0),(1,1)],
        # L-shape (4 cells)
        [(0,0),(1,0),(2,0),(2,1)],
        # T-shape (4 cells)
        [(0,1),(1,0),(1,1),(1,2)],
        # horizontal line length 3
        [(0,0),(0,1),(0,2)],
        # plus shape (5 cells)
        [(1,1),(0,1),(1,0),(1,2),(2,1)]
    ]

    def normalize(shape):
        minr = min(r for r,c in shape)
        minc = min(c for r,c in shape)
        return [(r - minr, c - minc) for r,c in shape]

    templates = [normalize(s) for s in raw_templates]

    # Utility: get bounding dims of a normalized shape
    def shape_size(shape):
        h = max(r for r,c in shape) + 1
        w = max(c for r,c in shape) + 1
        return h, w

    # Neighbors for 4-connectivity
    def neighbors(r, c, H, W):
        for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):
            nr, nc = r + dr, c + dc
            if 0 <= nr < H and 0 <= nc < W:
                yield nr, nc

    # Create a grid that respects the 60% background constraint
    for _ in range(200):
        W = random.randint(6, 14)
        H = random.randint(6, 14)
        area = W * H
        max_foreground = max(1, int(area * 0.40))
        min_shape = min(len(s) for s in templates)
        max_motifs = max(2, min(5, max_foreground // min_shape))
        if max_motifs >= 2:
            break

    # background color: allow 0..9
    bg_color = random.randint(0, 9)

    # determine number of motifs (at least 2)
    num_motifs = random.randint(2, max_motifs)

    # choose distinct motif colors
    # use simple pool excluding background
    pool = [c for c in range(10) if c != bg_color]
    random.shuffle(pool)
    motif_colors = pool[:num_motifs]

    # pick primary shape and attempt to place it centrally
    primary_shape = random.choice(templates)

    # Build empty grid
    grid_in = [[bg_color for _ in range(W)] for __ in range(H)]

    placements = []  # list of (color, set_of_positions)

    # Place primary motif centered
    def place_shape_at(shape, anchor_r, anchor_c, color, grid):
        cells = []
        for dr, dc in shape:
            r = anchor_r + dr
            c = anchor_c + dc
            grid[r][c] = color
            cells.append((r, c))
        return set(cells)

    # compute center alignment for primary
    mean_r = sum(r for r,c in primary_shape) / len(primary_shape)
    mean_c = sum(c for r,c in primary_shape) / len(primary_shape)
    ctr_r = H // 2
    ctr_c = W // 2
    anchor_r = int(round(ctr_r - mean_r))
    anchor_c = int(round(ctr_c - mean_c))
    # clamp anchor to bounds
    sh_h, sh_w = shape_size(primary_shape)
    anchor_r = max(0, min(anchor_r, H - sh_h))
    anchor_c = max(0, min(anchor_c, W - sh_w))

    primary_color = motif_colors[0]
    primary_positions = place_shape_at(primary_shape, anchor_r, anchor_c, primary_color, grid_in)
    placements.append((primary_color, primary_positions, primary_shape, (anchor_r, anchor_c)))

    # Place remaining motifs at random non-overlapping positions when possible
    for idx in range(1, num_motifs):
        shape = random.choice(templates)
        sh_h, sh_w = shape_size(shape)
        color = motif_colors[idx]
        placed = False
        for _attempt in range(200):
            ar = random.randint(0, H - sh_h)
            ac = random.randint(0, W - sh_w)
            cells = [(ar + dr, ac + dc) for dr, dc in shape]
            collision = any(grid_in[r][c] != bg_color for r, c in cells)
            if collision:
                continue
            posset = place_shape_at(shape, ar, ac, color, grid_in)
            placements.append((color, posset, shape, (ar, ac)))
            placed = True
            break
        # if couldn't place without overlap, skip this motif

    # Ensure foreground cells don't exceed budget; if they do, remove last placements
    fg_cells = set()
    for _, posset, _, _ in placements:
        fg_cells |= posset
    if len(fg_cells) > max_foreground:
        # remove from the end until within budget but keep at least two motifs if possible
        while len(fg_cells) > max_foreground and len(placements) > 2:
            color, posset, _, _ = placements.pop()
            for (r, c) in posset:
                grid_in[r][c] = bg_color
            fg_cells = set()
            for _, pset, _, _ in placements:
                fg_cells |= pset

    # Helper: detect isolated pixel (no 4-neighbor with same color)
    def is_isolated(g, r, c):
        col = g[r][c]
        for nr, nc in neighbors(r, c, H, W):
            if g[nr][nc] == col:
                return False
        return True

    # Detect background color by counting non-isolated pixels only
    counts = {}
    for r in range(H):
        for c in range(W):
            if not is_isolated(grid_in, r, c):
                counts[grid_in[r][c]] = counts.get(grid_in[r][c], 0) + 1
    if counts:
        bg_detected = max(counts.keys(), key=lambda k: (counts[k], k))
    else:
        flat = [grid_in[r][c] for r in range(H) for c in range(W)]
        bg_detected = max(set(flat), key=flat.count)

    # Find all connected components of non-background colors; pick largest component (tie by proximity to center)
    visited = [[False] * W for _ in range(H)]
    best_comp = []
    best_size = 0
    best_dist = None
    center_r = (H - 1) / 2.0
    center_c = (W - 1) / 2.0

    for r in range(H):
        for c in range(W):
            if grid_in[r][c] == bg_detected or visited[r][c]:
                continue
            color = grid_in[r][c]
            # BFS to collect component
            q = deque()
            q.append((r, c))
            visited[r][c] = True
            comp = []
            while q:
                x, y = q.popleft()
                comp.append((x, y))
                for nx, ny in neighbors(x, y, H, W):
                    if not visited[nx][ny] and grid_in[nx][ny] == color:
                        visited[nx][ny] = True
                        q.append((nx, ny))
            size = len(comp)
            if size > best_size:
                best_comp = comp
                best_size = size
                mean_r = sum(rr for rr, cc in comp) / size
                mean_c = sum(cc for rr, cc in comp) / size
                best_dist = (mean_r - center_r) ** 2 + (mean_c - center_c) ** 2
            elif size == best_size and size > 0:
                mean_r = sum(rr for rr, cc in comp) / size
                mean_c = sum(cc for rr, cc in comp) / size
                dist = (mean_r - center_r) ** 2 + (mean_c - center_c) ** 2
                if best_dist is None or dist < best_dist:
                    best_comp = comp
                    best_dist = dist

    # fallback: if none found (shouldn't happen) pick the most frequent non-bg color
    if not best_comp:
        counts2 = {}
        for r in range(H):
            for c in range(W):
                if grid_in[r][c] == bg_detected:
                    continue
                counts2[grid_in[r][c]] = counts2.get(grid_in[r][c], 0) + 1
        if counts2:
            primary_color = max(counts2.keys(), key=lambda k: (counts2[k], k))
            best_comp = [(r, c) for r in range(H) for c in range(W) if grid_in[r][c] == primary_color]
        else:
            # no foreground, return trivial output equal to input (should not occur for our generator)
            return {"input": grid_in, "output": [row[:] for row in grid_in]}

    # compute bounding box of best component
    rows = [r for r, c in best_comp]
    cols = [c for r, c in best_comp]
    min_r, max_r = min(rows), max(rows)
    min_c, max_c = min(cols), max(cols)
    bb_h = max_r - min_r + 1
    bb_w = max_c - min_c + 1

    # decide reflection: horizontal (mirror left-right) if BB wider than tall, else vertical (top-bottom)
    horizontal_reflect = bb_w > bb_h

    # apply reflection only to foreground pixels
    reflected = [[bg_detected for _ in range(W)] for __ in range(H)]
    if horizontal_reflect:
        for r in range(H):
            for c in range(W):
                v = grid_in[r][c]
                if v != bg_detected:
                    rc = W - 1 - c
                    reflected[r][rc] = v
    else:
        for r in range(H):
            for c in range(W):
                v = grid_in[r][c]
                if v != bg_detected:
                    rr = H - 1 - r
                    reflected[rr][c] = v

    # gravity: drop non-bg pixels in each column preserving their order
    out = [[bg_detected for _ in range(W)] for __ in range(H)]
    for c in range(W):
        col = []
        for r in range(H):
            if reflected[r][c] != bg_detected:
                col.append(reflected[r][c])
        start = H - len(col)
        for i, val in enumerate(col):
            out[start + i][c] = val

    # ensure input != output; if equal, try nudging the primary one cell to break symmetry
    if out == grid_in:
        # try simple shifts of primary placement
        shifted = False
        deltas = [(0,1),(0,-1),(1,0),(-1,0),(1,1),(1,-1),(-1,1),(-1,-1)]
        # find primary placement in placements (first is primary)
        if placements:
            p_color, p_pos, p_shape, (pr, pc) = placements[0]
            for dr, dc in deltas:
                new_pr = pr + dr
                new_pc = pc + dc
                sh_h, sh_w = shape_size(p_shape)
                if not (0 <= new_pr <= H - sh_h and 0 <= new_pc <= W - sh_w):
                    continue
                # check collision
                cells = [(new_pr + r_off, new_pc + c_off) for r_off, c_off in p_shape]
                if any((grid_in[r][c] != bg_color) and ((r,c) not in p_pos) for r,c in cells):
                    continue
                # remove old primary
                for (r,c) in p_pos:
                    grid_in[r][c] = bg_color
                # place new primary
                new_pos = place_shape_at(p_shape, new_pr, new_pc, p_color, grid_in)
                placements[0] = (p_color, new_pos, p_shape, (new_pr, new_pc))
                # recompute transform quickly
                # recompute detected background (should be same)
                reflected = [[bg_detected for _ in range(W)] for __ in range(H)]
                if horizontal_reflect:
                    for r in range(H):
                        for c in range(W):
                            v = grid_in[r][c]
                            if v != bg_detected:
                                rc = W - 1 - c
                                reflected[r][rc] = v
                else:
                    for r in range(H):
                        for c in range(W):
                            v = grid_in[r][c]
                            if v != bg_detected:
                                rr = H - 1 - r
                                reflected[rr][c] = v
                out = [[bg_detected for _ in range(W)] for __ in range(H)]
                for c in range(W):
                    col = []
                    for r in range(H):
                        if reflected[r][c] != bg_detected:
                            col.append(reflected[r][c])
                    start = H - len(col)
                    for i, val in enumerate(col):
                        out[start + i][c] = val
                if out != grid_in:
                    shifted = True
                    break
                else:
                    # undo change
                    for (r,c) in new_pos:
                        grid_in[r][c] = bg_color
                    for (r,c) in p_pos:
                        grid_in[r][c] = p_color
        # if still equal, leave as is (extremely rare)

    return {"input": grid_in, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    # Convert to mutable list of lists
    grid_in = [list(row) for row in input_grid]
    H = len(grid_in)
    W = len(grid_in[0])

    def neighbors(r, c):
        for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):
            nr, nc = r + dr, c + dc
            if 0 <= nr < H and 0 <= nc < W:
                yield nr, nc

    def is_isolated(g, r, c):
        col = g[r][c]
        for nr, nc in neighbors(r, c):
            if g[nr][nc] == col:
                return False
        return True

    # Detect background by counting non-isolated pixels only
    counts = {}
    for r in range(H):
        for c in range(W):
            if not is_isolated(grid_in, r, c):
                counts[grid_in[r][c]] = counts.get(grid_in[r][c], 0) + 1
    if counts:
        bg = max(counts.keys(), key=lambda k: (counts[k], k))
    else:
        flat = [grid_in[r][c] for r in range(H) for c in range(W)]
        bg = max(set(flat), key=flat.count)

    # Find largest connected component of non-background pixels (4-connected), tie-break by proximity to center
    visited = [[False] * W for _ in range(H)]
    best_comp = []
    best_size = 0
    best_dist = None
    center_r = (H - 1) / 2.0
    center_c = (W - 1) / 2.0

    for r in range(H):
        for c in range(W):
            if grid_in[r][c] == bg or visited[r][c]:
                continue
            color = grid_in[r][c]
            q = deque()
            q.append((r, c))
            visited[r][c] = True
            comp = []
            while q:
                x, y = q.popleft()
                comp.append((x, y))
                for nx, ny in neighbors(x, y):
                    if not visited[nx][ny] and grid_in[nx][ny] == color:
                        visited[nx][ny] = True
                        q.append((nx, ny))
            size = len(comp)
            if size > best_size:
                best_comp = comp
                best_size = size
                mean_r = sum(rr for rr, cc in comp) / size
                mean_c = sum(cc for rr, cc in comp) / size
                best_dist = (mean_r - center_r) ** 2 + (mean_c - center_c) ** 2
            elif size == best_size and size > 0:
                mean_r = sum(rr for rr, cc in comp) / size
                mean_c = sum(cc for rr, cc in comp) / size
                dist = (mean_r - center_r) ** 2 + (mean_c - center_c) ** 2
                if best_dist is None or dist < best_dist:
                    best_comp = comp
                    best_dist = dist

    # fallback: if none found, pick most frequent non-bg color
    if not best_comp:
        counts2 = {}
        for r in range(H):
            for c in range(W):
                if grid_in[r][c] == bg:
                    continue
                counts2[grid_in[r][c]] = counts2.get(grid_in[r][c], 0) + 1
        if counts2:
            primary_color = max(counts2.keys(), key=lambda k: (counts2[k], k))
            best_comp = [(r, c) for r in range(H) for c in range(W) if grid_in[r][c] == primary_color]
        else:
            # no foreground -> return input
            return grid_in

    rows = [r for r, c in best_comp]
    cols = [c for r, c in best_comp]
    min_r, max_r = min(rows), max(rows)
    min_c, max_c = min(cols), max(cols)
    bb_h = max_r - min_r + 1
    bb_w = max_c - min_c + 1

    # decide reflection
    horizontal_reflect = bb_w > bb_h

    # reflect only foreground
    reflected = [[bg for _ in range(W)] for __ in range(H)]
    if horizontal_reflect:
        for r in range(H):
            for c in range(W):
                v = grid_in[r][c]
                if v != bg:
                    rc = W - 1 - c
                    reflected[r][rc] = v
    else:
        for r in range(H):
            for c in range(W):
                v = grid_in[r][c]
                if v != bg:
                    rr = H - 1 - r
                    reflected[rr][c] = v

    # gravity
    out = [[bg for _ in range(W)] for __ in range(H)]
    for c in range(W):
        col = []
        for r in range(H):
            if reflected[r][c] != bg:
                col.append(reflected[r][c])
        start = H - len(col)
        for i, val in enumerate(col):
            out[start + i][c] = val

    return out

