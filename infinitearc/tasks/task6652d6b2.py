# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 6652d6b2
Difficulty: medium–hard

=== Tags ===
- Boolean color logic
- Paint on collision
- Contour thickening
- Remove singletons

=== Description ===
Contour Collision Paint  Input grids feature a background of color 0 with
multiple contiguous regions of non-zero colors (1-9). Each region consists of
connected cells (vertically or horizontally) sharing the same color.   The
transformation follows three deterministic steps:  1. **Remove singletons**: Any
cell belonging to a region of exactly one cell (no adjacent cells of the same
color) is set to background (0). This eliminates isolated cells that do not form
part of a larger contiguous structure.  2. **Contour thickening**: For each
remaining region (size ≥2), expand its boundary outward by one cell in all four
cardinal directions (up, down, left, right), but only into background cells (0).
The new boundary cells adopt the region's original color.  3. **Paint on
collision**: If during thickening, two different regions' expansions would
overlap (a cell is targeted by two distinct colors), that cell is painted with a
fixed collision color (9) instead of either original color. This collision color
serves as a visual indicator of overlapping regions.  The output grid reflects
all three transformations sequentially. No other operations or modifications
occur. The process ensures regions grow outward while resolving overlaps through
a consistent collision rule, creating a new visual pattern that emphasizes the
interplay between region expansion and boundary interactions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    
    visited = [[False] * width for _ in range(height)]
    components = []
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] > 0 and not visited[r][c]:
                color = input_grid[r][c]
                component = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append((color, component))
    
    after_remove = [list(row) for row in input_grid]
    for color, comp in components:
        if len(comp) == 1:
            for (r, c) in comp:
                after_remove[r][c] = 0
    
    output_grid = [list(row) for row in after_remove]
    expansion = [[[] for _ in range(width)] for _ in range(height)]
    
    for r in range(height):
        for c in range(width):
            if after_remove[r][c] > 0:
                color = after_remove[r][c]
                for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and after_remove[nr][nc] == 0:
                        expansion[nr][nc].append(color)
    
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] == 0 and expansion[r][c]:
                if len(expansion[r][c]) > 1:
                    output_grid[r][c] = 9
                else:
                    output_grid[r][c] = expansion[r][c][0]
    
    return output_grid

def generate():
    width = random.randint(5, 20)
    height = random.randint(5, 20)
    input_grid = [[0] * width for _ in range(height)]
    
    for color in range(1, 4):
        size = random.randint(2, 4)
        pixels = common.continuous_creature(size, width, height)
        rows = [p[0] for p in pixels]
        cols = [p[1] for p in pixels]
        for r, c in zip(rows, cols):
            input_grid[r][c] = color
    
    for color in range(4, 6):
        for _ in range(random.randint(1, 3)):
            while True:
                r = random.randint(0, height - 1)
                c = random.randint(0, width - 1)
                if input_grid[r][c] != 0:
                    continue
                neighbors = [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]
                valid = True
                for nr, nc in neighbors:
                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == color:
                        valid = False
                        break
                if valid:
                    input_grid[r][c] = color
                    break
    
    output_grid = p(input_grid)
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
import random

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    
    visited = [[False] * width for _ in range(height)]
    components = []
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] > 0 and not visited[r][c]:
                color = input_grid[r][c]
                component = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    component.append((cr, cc))
                    for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append((color, component))
    
    after_remove = [list(row) for row in input_grid]
    for color, comp in components:
        if len(comp) == 1:
            for (r, c) in comp:
                after_remove[r][c] = 0
    
    output_grid = [list(row) for row in after_remove]
    expansion = [[[] for _ in range(width)] for _ in range(height)]
    
    for r in range(height):
        for c in range(width):
            if after_remove[r][c] > 0:
                color = after_remove[r][c]
                for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and after_remove[nr][nc] == 0:
                        expansion[nr][nc].append(color)
    
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] == 0 and expansion[r][c]:
                if len(expansion[r][c]) > 1:
                    output_grid[r][c] = 9
                else:
                    output_grid[r][c] = expansion[r][c][0]
    
    return output_grid
