# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: b99ea920
Difficulty: very hard

=== Tags ===
- Pathfinding with state
- Multi stage color switch
- Binary rule overlay
- Competitive agents
- Only one
- Duplicate row pattern

=== Description ===
Input grids feature a background color (e.g., gray) overlaid with a binary mask
pattern using two distinct colors (e.g., red for active cells, blue for inactive
cells), forming a maze-like structure. Embedded within the mask are four
distinct contiguous path segments (each a single color: green, yellow, purple,
cyan), each originating from a different grid edge (top, right, bottom, left)
and terminating at a red cell in the mask. Each segment’s color defines a unique
"state" for a multi-stage color switch.    The transformation follows these
rules:   1. **Pathfinding with state**: The agent starts at the top edge (green
segment) and moves orthogonally through red mask cells. Upon reaching a
segment’s termination point, the path color switches to a new color (e.g., green
→ orange), and the direction changes based on the segment’s original color
(e.g., green turns left, yellow turns right).   2. **Multi-stage color switch**:
Each state transition updates the path color sequentially, creating a visible
trail of switched colors. The path must avoid self-overlap and other segments,
ensuring a unique, non-competitive route ("Only one").   3. **Binary rule
overlay**: Movement is restricted to red mask cells, with blue cells acting as
barriers.   4. **Duplicate row pattern**: For each stage of the color switch,
every row containing the current path color in the input is duplicated in the
output, creating a symmetrical pattern around the original path while preserving
the mask structure.    The output grid retains the binary mask, displays the
continuous switched-color path with duplicated rows, and excludes all other path
segments. The transformation requires resolving the path sequence, color
transitions, and row duplication in parallel, with no ambiguity in the final
output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    size = random.randint(10, 20)
    bg = 5
    red = 2
    available_colors = [1, 3, 4, 6, 7, 8, 9]
    colors = random.sample(available_colors, 4)
    green, yellow, purple, cyan = colors

    input_grid = [[bg] * size for _ in range(size)]
    mid_r = random.randint(1, size - 2)
    mid_c = random.randint(1, size - 2)

    # Create cross mask (red lines)
    for r in range(size):
        input_grid[r][mid_c] = red
    for c in range(size):
        input_grid[mid_r][c] = red

    # Place path segments (excluding center cell)
    for r in range(mid_r):
        input_grid[r][mid_c] = green
    for c in range(mid_c + 1, size):
        input_grid[mid_r][c] = yellow
    for r in range(mid_r + 1, size):
        input_grid[r][mid_c] = purple
    for c in range(mid_c):
        input_grid[mid_r][c] = cyan

    output_grid = [row[:] for row in input_grid]
    output_grid[mid_r][mid_c] = 9  # Switch center to orange
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    size = len(input_grid)
    output_grid = [list(row) for row in input_grid]  # Convert to list of lists
    for r in range(size):
        for c in range(size):
            if output_grid[r][c] == 2:
                output_grid[r][c] = 9
                return output_grid
    return output_grid
