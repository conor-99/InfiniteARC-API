# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: a09b013c
Difficulty: insane

=== Tags ===
- Collision marking
- Incremental pattern growth
- Rotate each quadrant

=== Description ===
The input grid is a large (20×20 or larger) 2D grid containing distinct color
patterns distributed across four quadrants. Each quadrant features a unique
arrangement of colors (1–8), with no overlapping regions between quadrants. The
transformation applies three sequential rules:  1. **Rotate each quadrant 90°
clockwise**: The grid is split into four equal quadrants (top-left, top-right,
bottom-left, bottom-right). Each quadrant is rotated 90° clockwise in-place,
preserving internal patterns while reorienting their spatial relationships.  2.
**Collision marking**: After rotation, boundary cells between adjacent quadrants
(e.g., the right edge of the top-left quadrant and left edge of the top-right
quadrant) are checked. If the color of a cell in one rotated quadrant differs
from its adjacent cell in the neighboring quadrant, the cell is marked with
color 9 (collision color).  3. **Incremental pattern growth**: Each collision-
marked cell expands into a 2×2 block of color 9 in the output grid. This
expansion propagates outward along the boundary, creating a contiguous,
geometric pattern that scales with the number of collisions. The growth respects
grid boundaries and does not overwrite original quadrant colors, ensuring the
pattern remains visually distinct and structurally coherent. The output grid
retains all original rotated quadrant colors, with collision marks and their 2×2
expansions forming a new, incremental visual pattern along quadrant boundaries.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    N = random.choice([20, 22, 24, 26, 28, 30])
    Q = N // 2
    
    input_grid = [[0] * N for _ in range(N)]
    
    def make_pattern():
        pat = [[0] * Q for _ in range(Q)]
        for i in range(Q):
            for j in range(Q):
                if random.random() > 0.4:
                    pat[i][j] = random.randint(1, 8)
        return pat
    
    tl = make_pattern()
    tr = make_pattern()
    bl = make_pattern()
    br = make_pattern()
    
    for i in range(Q):
        for j in range(Q):
            input_grid[i][j] = tl[i][j]
            input_grid[i][Q+j] = tr[i][j]
            input_grid[Q+i][j] = bl[i][j]
            input_grid[Q+i][Q+j] = br[i][j]
    
    output_grid = [row[:] for row in input_grid]
    
    def rotate_quadrant(quadrant):
        return [list(x)[::-1] for x in zip(*quadrant)]
    
    tl_rot = rotate_quadrant([row[:Q] for row in output_grid[:Q]])
    for i in range(Q):
        for j in range(Q):
            output_grid[i][j] = tl_rot[i][j]
    
    tr_rot = rotate_quadrant([row[Q:] for row in output_grid[:Q]])
    for i in range(Q):
        for j in range(Q):
            output_grid[i][Q+j] = tr_rot[i][j]
    
    bl_rot = rotate_quadrant([row[:Q] for row in output_grid[Q:]])
    for i in range(Q):
        for j in range(Q):
            output_grid[Q+i][j] = bl_rot[i][j]
    
    br_rot = rotate_quadrant([row[Q:] for row in output_grid[Q:]])
    for i in range(Q):
        for j in range(Q):
            output_grid[Q+i][Q+j] = br_rot[i][j]
    
    for r in range(Q):
        if output_grid[r][Q-1] != output_grid[r][Q]:
            output_grid[r][Q-1] = 9
    
    for c in range(Q):
        if output_grid[Q-1][c] != output_grid[Q][c]:
            output_grid[Q-1][c] = 9
    
    for c in range(Q, N):
        if output_grid[Q-1][c] != output_grid[Q][c]:
            output_grid[Q-1][c] = 9
    
    for r in range(Q, N):
        if output_grid[r][Q-1] != output_grid[r][Q]:
            output_grid[r][Q-1] = 9
    
    for r in range(N):
        for c in range(N):
            if output_grid[r][c] == 9:
                for dr in range(2):
                    for dc in range(2):
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < N and 0 <= nc < N:
                            output_grid[nr][nc] = 9
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    N = len(grid)
    Q = N // 2
    
    def rotate_quadrant(quadrant):
        return [list(x)[::-1] for x in zip(*quadrant)]
    
    tl = [row[:Q] for row in grid[:Q]]
    tl_rot = rotate_quadrant(tl)
    for i in range(Q):
        for j in range(Q):
            grid[i][j] = tl_rot[i][j]
    
    tr = [row[Q:] for row in grid[:Q]]
    tr_rot = rotate_quadrant(tr)
    for i in range(Q):
        for j in range(Q):
            grid[i][Q+j] = tr_rot[i][j]
    
    bl = [row[:Q] for row in grid[Q:]]
    bl_rot = rotate_quadrant(bl)
    for i in range(Q):
        for j in range(Q):
            grid[Q+i][j] = bl_rot[i][j]
    
    br = [row[Q:] for row in grid[Q:]]
    br_rot = rotate_quadrant(br)
    for i in range(Q):
        for j in range(Q):
            grid[Q+i][Q+j] = br_rot[i][j]
    
    for r in range(Q):
        if grid[r][Q-1] != grid[r][Q]:
            grid[r][Q-1] = 9
    
    for c in range(Q):
        if grid[Q-1][c] != grid[Q][c]:
            grid[Q-1][c] = 9
    
    for c in range(Q, N):
        if grid[Q-1][c] != grid[Q][c]:
            grid[Q-1][c] = 9
    
    for r in range(Q, N):
        if grid[r][Q-1] != grid[r][Q]:
            grid[r][Q-1] = 9
    
    for r in range(N):
        for c in range(N):
            if grid[r][c] == 9:
                for dr in range(2):
                    for dc in range(2):
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < N and 0 <= nc < N:
                            grid[nr][nc] = 9
    
    return grid
