# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 0492e0da
Difficulty: insane

=== Tags ===
- Find analogous pattern property
- Take half
- Decode image from palette indices
- Remove intruder

=== Description ===
The task involves transforming an input grid into an output grid by applying a
sequence of visual pattern-based operations. The input grid contains a primary
pattern (e.g., a geometric shape or arrangement of colors) formed by a
consistent color, but with one or more "intruder" elements—cells of a different
color that disrupt the pattern. The solver must first identify and remove all
intruder cells (those not part of the dominant pattern), then halve the grid
along its dominant axis (e.g., vertically for horizontally oriented patterns,
horizontally for vertically oriented patterns). The halving step reduces the
grid size by selecting every other row and column (e.g., rows 0, 2, 4... and
columns 0, 2, 4...), producing a smaller grid that preserves the analogous
structure of the original primary pattern. The "analogous pattern property"
ensures the output maintains the shape and relative positioning of the main
pattern, while "decode image from palette indices" refers to interpreting the
grid’s numerical values as visual color representations (e.g., 1 = blue, 2 =
red) without relying on numerical properties. The "remove intruder" step
requires detecting the color that appears only in isolated, non-patterned
locations, which varies per input. For "insane" difficulty, inputs feature
complex, large-scale patterns (e.g., overlapping spirals or fractal-like
structures) with subtle intruders, demanding multi-step reasoning to distinguish
the primary pattern from noise.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    from common import grid
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    C = random.randint(1, 9)
    input_grid = grid(width, height, 0)
    start_row = height // 4
    end_row = 3 * height // 4
    start_col = width // 4
    end_col = 3 * width // 4
    for r in range(start_row, end_row):
        for c in range(start_col, end_col):
            input_grid[r][c] = C
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                color = random.randint(1, 9)
                while color == C:
                    color = random.randint(1, 9)
                input_grid[r][c] = color
    cleaned = [[C if input_grid[r][c] == C else 0 for c in range(width)] for r in range(height)]
    output_width = (width + 1) // 2
    output_height = (height + 1) // 2
    output_grid = [[0] * output_width for _ in range(output_height)]
    for r in range(output_height):
        for c in range(output_width):
            output_grid[r][c] = cleaned[2 * r][2 * c]
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    max_component_size = 0
    main_color = 1
    for color in range(1, 10):
        visited = [[False] * width for _ in range(height)]
        max_size = 0
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == color and not visited[r][c]:
                    stack = [(r, c)]
                    visited[r][c] = True
                    size = 0
                    while stack:
                        x, y = stack.pop()
                        size += 1
                        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                            nx, ny = x + dx, y + dy
                            if 0 <= nx < height and 0 <= ny < width and input_grid[nx][ny] == color and not visited[nx][ny]:
                                visited[nx][ny] = True
                                stack.append((nx, ny))
                    if size > max_size:
                        max_size = size
        if max_size > max_component_size:
            max_component_size = max_size
            main_color = color
    cleaned = [[main_color if input_grid[r][c] == main_color else 0 for c in range(width)] for r in range(height)]
    output_width = (width + 1) // 2
    output_height = (height + 1) // 2
    output_grid = [[0] * output_width for _ in range(output_height)]
    for r in range(output_height):
        for c in range(output_width):
            output_grid[r][c] = cleaned[2 * r][2 * c]
    return output_grid
