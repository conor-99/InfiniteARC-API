# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 007d0f32
Difficulty: insane

=== Tags ===
- Pattern guided construction
- Rule switch on context
- Mutual reflection
- Gas expansion

=== Description ===
Input grids feature a central gas source (color 1) surrounded by a non-
rectilinear path of directional guides (colors 2-5 representing east, south,
west, north) and optional mirror markers (color 6). The path is embedded within
a background (color 0) and may contain obstacles (other colors). The gas expands
along the path, filling background cells with color 1 while spreading outward in
the current direction like a wave, stopping at obstacles. Upon encountering a
mirror marker, the expansion direction reverses (e.g., east becomes west),
triggering a mutual reflection: an exact mirrored path is generated from the
mirror point, following the reversed sequence of directions and expanding
symmetrically. The reflection must maintain the same path length and direction
sequence as the original before the mirror, mirrored spatially. Gas expansion
fills all adjacent background cells in the current direction along both the
original and reflected paths, creating a continuous "gas cloud" that avoids
overlapping with obstacles. The output grid displays the combined filled regions
from both paths, with all expansions constrained to background cells, preserving
the original source, path, and obstacles.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid


def generate():
    """
    Generate an ARC-style input/output pair for the mirror gas expansion task.

    Conventions:
      0 background
      1 gas source
      2 east, 3 south, 4 west, 5 north
      6 mirror
      7-9 obstacles

    The generator creates a simple non-self-touching path (no adjacency between
    non-consecutive path cells) that starts adjacent to the source and ends at
    a mirror. It ensures the reflected coordinates fit inside the grid and do
    not intersect the original path or the source. Obstacles are placed away
    from these reserved locations. The output is computed by expanding rays
    from each directional guide cell and from the reflected guides.
    """

    # possible step moves for constructing the path
    STEPS = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    color_to_dir = {2: (0, 1), 3: (1, 0), 4: (0, -1), 5: (-1, 0)}
    reverse_color = {2: 4, 3: 5, 4: 2, 5: 3}

    for attempt in range(1000):
        width = random.randint(10, 20)
        height = random.randint(10, 20)
        in_grid = grid(width, height, 0)

        path_len = random.randint(3, 8)

        # place source away from border
        sx = random.randint(1, height - 2)
        sy = random.randint(1, width - 2)
        in_grid[sx][sy] = 1

        # try to build a simple (non-self-touching) path starting adjacent to the source
        for build_try in range(300):
            # initial neighbor
            dr0, dc0 = random.choice(STEPS)
            first = (sx + dr0, sy + dc0)
            if not (0 <= first[0] < height and 0 <= first[1] < width):
                continue
            if in_grid[first[0]][first[1]] != 0:
                continue

            path = [first]
            used = { (sx, sy), first }
            cur = first
            stuck = False

            for _ in range(1, path_len):
                candidates = []
                for dr, dc in STEPS:
                    nx, ny = cur[0] + dr, cur[1] + dc
                    if not (0 <= nx < height and 0 <= ny < width):
                        continue
                    if (nx, ny) in used:
                        continue
                    # do not allow this candidate to be adjacent to any used cell
                    # except the current cell (prevents non-consecutive adjacency)
                    ok = True
                    for (ux, uy) in used:
                        if (ux, uy) == cur:
                            continue
                        if abs(ux - nx) + abs(uy - ny) == 1:
                            ok = False
                            break
                    if not ok:
                        continue
                    candidates.append((nx, ny))
                if not candidates:
                    stuck = True
                    break
                nxt = random.choice(candidates)
                path.append(nxt)
                used.add(nxt)
                cur = nxt
            if stuck:
                continue

            # path built; last cell is mirror
            mirror = path[-1]
            pre_mirror = path[:-1]

            # make sure reflected coords fit and don't collide with used or source
            mx, my = mirror
            reflected_coords = []
            ok_reflect = True
            for (px, py) in pre_mirror:
                rx, ry = 2 * mx - px, 2 * my - py
                if not (0 <= rx < height and 0 <= ry < width):
                    ok_reflect = False
                    break
                if (rx, ry) in used or (rx, ry) == (sx, sy):
                    ok_reflect = False
                    break
                reflected_coords.append((rx, ry))
            if not ok_reflect:
                continue

            # assign colors to pre-mirror cells
            colors = [random.randint(2, 5) for _ in pre_mirror]

            # place them into the input grid
            for (coord, col) in zip(pre_mirror, colors):
                r, c = coord
                in_grid[r][c] = col
            in_grid[mx][my] = 6

            # place obstacles away from reserved locations
            forbidden = set(pre_mirror) | {mirror, (sx, sy)} | set(reflected_coords)
            free = [(r, c) for r in range(height) for c in range(width) if in_grid[r][c] == 0 and (r, c) not in forbidden]
            num_obs = random.randint(5, min(20, max(5, len(free)//6))) if free else 0
            random.shuffle(free)
            for (r, c) in free[:num_obs]:
                in_grid[r][c] = random.randint(7, 9)

            # compute output by performing expansions
            out_grid = [row[:] for row in in_grid]
            # original
            for (coord, col) in zip(pre_mirror, colors):
                r, c = coord
                dr, dc = color_to_dir[col]
                nx, ny = r + dr, c + dc
                while 0 <= nx < height and 0 <= ny < width and in_grid[nx][ny] == 0:
                    out_grid[nx][ny] = 1
                    nx += dr
                    ny += dc
            # reflected
            for (coord, col) in zip(pre_mirror, colors):
                pr, pc = coord
                rr, rc = 2 * mx - pr, 2 * my - pc
                rev_col = reverse_color[col]
                dr, dc = color_to_dir[rev_col]
                nx, ny = rr + dr, rc + dc
                while 0 <= nx < height and 0 <= ny < width and in_grid[nx][ny] == 0:
                    out_grid[nx][ny] = 1
                    nx += dr
                    ny += dc

            if out_grid != in_grid:
                return {"input": in_grid, "output": out_grid}
        # build_try
    # attempts exhausted - fallback
    width = 10
    height = 10
    in_grid = grid(width, height, 0)
    sx, sy = 5, 5
    in_grid[sx][sy] = 1
    in_grid[sx][sy+1] = 2
    in_grid[sx][sy+2] = 2
    in_grid[sx][sy+3] = 6
    out_grid = [row[:] for row in in_grid]
    for c in range(sy+2+1, width):
        if in_grid[sx][c] == 0:
            out_grid[sx][c] = 1
    out_grid[sx][sy-1] = 1
    return {"input": in_grid, "output": out_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # Direction/color mappings (match generator)
    color_to_dir = {2: (0, 1), 3: (1, 0), 4: (0, -1), 5: (-1, 0)}
    reverse_color = {2: 4, 3: 5, 4: 2, 5: 3}

    # Find the single source (color 1)
    sx = sy = -1
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 1:
                sx, sy = r, c
                break
        if sx != -1:
            break

    # If no source found, return input as-is
    if sx == -1:
        return [tuple(row) for row in grid]

    # Trace the contiguous non-branching path that starts adjacent to the source
    visited = set()
    path = []  # list of (r,c,color)

    # Find the first neighbor of the source that is a path cell
    found_first = False
    for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:
        nr, nc = sx + dr, sy + dc
        if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] in [2,3,4,5,6]:
            path.append((nr, nc, grid[nr][nc]))
            visited.add((nr, nc))
            found_first = True
            break
    if not found_first:
        # no path, just return original
        return [tuple(row) for row in grid]

    # Continue following the chain until it ends or a mirror is reached
    while True:
        r, c, col = path[-1]
        if col == 6:
            break
        # look for next neighbor that is a path cell and not visited
        next_found = False
        for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in visited and grid[nr][nc] in [2,3,4,5,6]:
                path.append((nr, nc, grid[nr][nc]))
                visited.add((nr, nc))
                next_found = True
                break
        if not next_found:
            break

    # Build output as a copy of input and perform expansions from the path cells up to (but not including) the mirror
    out = [row[:] for row in grid]

    # Locate mirror in the traced path (if any)
    mirror = None
    for (r, c, col) in path:
        if col == 6:
            mirror = (r, c)
            break

    # Collect pre-mirror cells (directional guides only)
    pre_mirror = []
    for (r, c, col) in path:
        if col == 6:
            break
        pre_mirror.append((r, c, col))

    # Expand original directions
    for (r, c, col) in pre_mirror:
        dr, dc = color_to_dir[col]
        nr, nc = r + dr, c + dc
        while 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0:
            out[nr][nc] = 1
            nr += dr
            nc += dc

    # If there is a mirror, perform reflected expansions by reflecting each guide cell about the mirror point
    if mirror is not None:
        mx, my = mirror
        for (pr, pc, col) in pre_mirror:
            rr, rc = 2 * mx - pr, 2 * my - pc
            # if reflected coordinate is out of bounds or overlaps a non-background cell in input, skip
            if not (0 <= rr < height and 0 <= rc < width):
                continue
            rev_col = reverse_color[col]
            dr, dc = color_to_dir[rev_col]
            nr, nc = rr + dr, rc + dc
            while 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0:
                out[nr][nc] = 1
                nr += dr
                nc += dc

    return [tuple(row) for row in out]
