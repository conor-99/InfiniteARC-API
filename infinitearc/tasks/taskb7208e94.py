# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: b7208e94
Difficulty: medium–hard

=== Tags ===
- Diagonals
- Mirror bounce
- Recursive path tracing
- Take minimum
- Color permutation

=== Description ===
**Task Description: Diagonal Mirror Path Permutation**    Input grids feature a
background color (0) and diagonal mirror lines of two types: forward slashes
(`/`) and backslashes (`\`), each spanning multiple cells with consistent colors
(1–9). These mirrors are arranged in a non-overlapping grid pattern, forming a
maze-like structure. A single starting cell (color 1) is positioned at the top-
left corner of the grid, initiating a path moving northeast.    The
transformation applies two sequential rules:   1. **Recursive Path Tracing with
Mirror Bounce**: The path moves diagonally until colliding with a mirror. Upon
collision, the direction reflects (e.g., northeast → southeast for `/` mirrors,
northeast → northwest for `\` mirrors), and the path’s current color is updated
to the *minimum* of its existing color and the mirror’s color. This process
repeats recursively—each bounce updates the color and direction—until the path
exits the grid.   2. **Global Color Permutation**: After path tracing completes,
all colors in the grid (including the path, mirrors, and background) undergo a
fixed permutation: colors 1–9 are cycled (1→2, 2→3, ..., 8→9, 9→1), while color
0 remains unchanged.    The output grid retains all input elements (mirrors,
background) but replaces the path with its updated color sequence (via min at
each bounce) and applies the global color permutation. The path must traverse
multiple bounces, and the permutation ensures no color values overlap with input
grids. The complexity arises from correctly tracking recursive bounces, applying
min at each step, and synchronizing the global permutation with path updates.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    size = random.randint(10, 30)
    grid_input = grid(size, size, 0)
    grid_input[0][0] = 1
    
    s = random.randint(1, 5)
    length = random.randint(2, 5)
    for i in range(s, s + length):
        if i < size:
            grid_input[i][i] = 1
    
    if s - 1 >= 0 and s + 1 < size:
        grid_input[s + 1][s - 1] = 2
    
    grid_output = [row[:] for row in grid_input]
    
    r, c = 0, 0
    dr, dc = 1, 1
    current_color = 1
    path_cells = []
    
    while 0 <= r < size and 0 <= c < size:
        path_cells.append((r, c))
        if grid_input[r][c] > 0:
            mirror_color = grid_input[r][c]
            current_color = min(current_color, mirror_color)
            if mirror_color == 1:
                dr, dc = dr, -dc
            elif mirror_color == 2:
                dr, dc = -dr, dc
        r += dr
        c += dc
    
    for (r, c) in path_cells:
        grid_output[r][c] = 1
    
    for r in range(size):
        for c in range(size):
            if grid_output[r][c] > 0:
                if grid_output[r][c] == 9:
                    grid_output[r][c] = 1
                else:
                    grid_output[r][c] += 1
    
    return {
        "input": grid_input,
        "output": grid_output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    size = len(input_grid)
    grid_input = [list(row) for row in input_grid]
    grid_output = [row[:] for row in grid_input]
    
    r, c = 0, 0
    dr, dc = 1, 1
    current_color = 1
    path_cells = []
    
    while 0 <= r < size and 0 <= c < size:
        path_cells.append((r, c))
        if grid_input[r][c] > 0:
            mirror_color = grid_input[r][c]
            current_color = min(current_color, mirror_color)
            if mirror_color == 1:
                dr, dc = dr, -dc
            elif mirror_color == 2:
                dr, dc = -dr, dc
        r += dr
        c += dc
    
    for i, (r, c) in enumerate(path_cells):
        grid_output[r][c] = current_color
    
    for r in range(size):
        for c in range(size):
            if grid_output[r][c] > 0:
                if grid_output[r][c] == 9:
                    grid_output[r][c] = 1
                else:
                    grid_output[r][c] += 1
    
    return tuple(tuple(row) for row in grid_output)
