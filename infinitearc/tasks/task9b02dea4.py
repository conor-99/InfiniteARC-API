# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 9b02dea4
Difficulty: easy

=== Tags ===
- Color by distance to a single point
- Holes

=== Description ===
The input grid contains a single reference point (a cell with a specific non-
zero color, typically color 1), surrounded by empty cells (color 0) which
represent "holes." The output grid retains all non-empty cells exactly as they
appear in the input. Each empty cell (0) in the input is replaced in the output
with a color determined by its Manhattan distance from the reference point. The
Manhattan distance is calculated as the sum of the absolute differences in row
and column indices between the empty cell and the reference point. The color
assigned to an empty cell is equal to (distance + 1). For example, empty cells
immediately adjacent to the reference point (distance 1) become color 2, cells
two steps away (distance 2) become color 3, and so on. This transformation
applies uniformly to all empty cells, creating concentric color rings radiating
outward from the reference point. The task is visual and requires identifying
the reference point and mapping distances to colors without relying on numerical
sums or pixel-level analysis.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(2, 8)
    max_height = 10 - width
    height = random.randint(2, max_height)
    grid_input = [[0] * width for _ in range(height)]
    r = random.randint(0, height - 1)
    c = random.randint(0, width - 1)
    grid_input[r][c] = 1
    grid_output = [[0] * width for _ in range(height)]
    for i in range(height):
        for j in range(width):
            if grid_input[i][j] == 1:
                grid_output[i][j] = 1
            else:
                dist = abs(i - r) + abs(j - c)
                grid_output[i][j] = dist + 1
    return {"input": grid_input, "output": grid_output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    for i in range(len(input_grid)):
        for j in range(len(input_grid[0])):
            if input_grid[i][j] == 1:
                r, c = i, j
                break
        else:
            continue
        break
    output = [[0] * len(input_grid[0]) for _ in range(len(input_grid))]
    for i in range(len(input_grid)):
        for j in range(len(input_grid[0])):
            if input_grid[i][j] == 1:
                output[i][j] = 1
            else:
                dist = abs(i - r) + abs(j - c)
                output[i][j] = dist + 1
    return output
