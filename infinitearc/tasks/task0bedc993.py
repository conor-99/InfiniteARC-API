# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 0bedc993
Difficulty: very hard

=== Tags ===
- Binary rule overlay
- Obstacles
- Constraint satisfaction coloring

=== Description ===
Input grids are large (20Ã—20 or larger) with a single background color (0),
obstacles (color 1), and two distinct colors (2 and 3) that form a hidden
checkerboard pattern. Obstacles are placed to obscure parts of the pattern,
requiring inference of the underlying structure. The output grid replaces all
background cells (0) with color 4 if the cell's position in the checkerboard is
"even" (inferred from color 2 markers) or color 5 if "odd" (inferred from color
3 markers). Obstacles remain color 1. The coloring inherently satisfies the
constraint that no two adjacent background cells share the same color, as the
checkerboard pattern ensures alternation. The difficulty arises from the
obscured pattern and the need to correctly infer the checkerboard's parity from
limited visible markers, with obstacles strategically placed to mask the
alternating sequence.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    N = random.randint(20, 30)
    grid = [[0] * N for _ in range(N)]
    
    for i in range(N):
        for j in range(N):
            if (i + j) % 2 == 0:
                r = random.random()
                if r < 0.3:
                    grid[i][j] = 2
                elif r < 0.5:
                    grid[i][j] = 1
                else:
                    grid[i][j] = 0
            else:
                r = random.random()
                if r < 0.3:
                    grid[i][j] = 3
                elif r < 0.5:
                    grid[i][j] = 1
                else:
                    grid[i][j] = 0
    
    has_2 = any(2 in row for row in grid)
    has_3 = any(3 in row for row in grid)
    if not (has_2 and has_3):
        return generate()
    
    # Check connectivity of background cells
    from collections import deque
    visited = [[False] * N for _ in range(N)]
    q = deque()
    for i in range(N):
        for j in range(N):
            if grid[i][j] in [2, 3]:
                visited[i][j] = True
                q.append((i, j))
    
    while q:
        i, j = q.popleft()
        for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:
            ni, nj = i + dx, j + dy
            if 0 <= ni < N and 0 <= nj < N and not visited[ni][nj] and grid[ni][nj] == 0:
                visited[ni][nj] = True
                q.append((ni, nj))
    
    # Verify all background cells are reachable
    all_reachable = True
    for i in range(N):
        for j in range(N):
            if grid[i][j] == 0 and not visited[i][j]:
                all_reachable = False
                break
        if not all_reachable:
            break
    
    if not all_reachable:
        return generate()
    
    output = [[0] * N for _ in range(N)]
    for i in range(N):
        for j in range(N):
            if grid[i][j] == 1:
                output[i][j] = 1
            elif grid[i][j] == 2 or grid[i][j] == 3:
                output[i][j] = grid[i][j]
            else:
                output[i][j] = 4 if (i + j) % 2 == 0 else 5
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    n = len(input_grid)
    m = len(input_grid[0])
    parity = [[None] * m for _ in range(n)]
    
    for i in range(n):
        for j in range(m):
            if input_grid[i][j] == 2:
                parity[i][j] = 'even'
            elif input_grid[i][j] == 3:
                parity[i][j] = 'odd'
    
    from collections import deque
    q = deque()
    for i in range(n):
        for j in range(m):
            if parity[i][j] is not None:
                q.append((i, j))
    
    directions = [(1,0), (-1,0), (0,1), (0,-1)]
    
    while q:
        i, j = q.popleft()
        for dx, dy in directions:
            ni, nj = i + dx, j + dy
            if 0 <= ni < n and 0 <= nj < m:
                if input_grid[ni][nj] == 0 and parity[ni][nj] is None:
                    parity[ni][nj] = 'odd' if parity[i][j] == 'even' else 'even'
                    q.append((ni, nj))
    
    output = [[0] * m for _ in range(n)]
    for i in range(n):
        for j in range(m):
            if input_grid[i][j] == 1:
                output[i][j] = 1
            elif input_grid[i][j] in [2, 3]:
                output[i][j] = input_grid[i][j]
            else:
                output[i][j] = 4 if parity[i][j] == 'even' else 5
    return output
