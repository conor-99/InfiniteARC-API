# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: efa8a410
Difficulty: insane

=== Tags ===
- Circuit reflection
- Spring chain
- Pattern repetition with offset

=== Description ===
# Circuit Reflection Spring Chain  Input grids are large (20×20 or larger) with
a single background color. The grid contains a continuous, non-orthogonal
circuit path composed of connected cells (color A) starting at the bottom edge
and moving rightward. Along this path, specific mirror elements (color B) cause
the path to reflect at 90-degree angles (e.g., right → up, up → left). Each
mirror element triggers a spring chain in the new direction.   The spring chain
is generated using a predefined spring template located in a designated region
(e.g., top-right corner), which is a small contiguous block of cells (e.g., 2×2)
with a distinct color pattern (colors C, D, E, F). Each repetition of the
template in the spring chain is placed along the new direction of the reflected
path, offset by a fixed vector (e.g., (0, 2) for horizontal movement, (2, 0) for
vertical). The chain extends until the next placement would overlap with non-
background elements or exceed grid boundaries.  The spring chain must be placed
exclusively on background cells, never overlapping the circuit path, mirror
elements, or the template area. Multiple reflections generate independent spring
chains in their respective directions. The output grid preserves all original
elements while adding the spring chains, with the template pattern only
appearing in the spring chains and nowhere else. Each spring chain must maintain
the exact color pattern of the template, repeated with consistent offset, and
the template must be identifiable as a distinct pattern separate from the
circuit path and mirrors.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Try multiple times to build a valid configuration that will allow at least
    # one spring-chain placement. If we fail repeatedly, we'll retry with new
    # random dimensions until successful.
    directions = [(0, 1), (-1, 0), (0, -1), (1, 0)]  # right, up, left, down
    TS = 2  # template size (2x2)

    for attempt in range(300):
        width = random.randint(20, 30)
        height = random.randint(20, 30)
        # Create empty background
        input_grid = grid(width, height, 0)

        # Pick 4 distinct template colors that are not background (0), path (1) or mirror (2)
        palette = [3, 4, 5, 6, 7, 8, 9]
        template_flat = random.sample(palette, 4)
        template = [[template_flat[0], template_flat[1]], [template_flat[2], template_flat[3]]]

        # Place the template in the top-right corner (rows 0..1, cols width-2..width-1).
        # This region is reserved and the path must not touch it.
        for tr in range(TS):
            for tc in range(TS):
                input_grid[tr][width - TS + tc] = template[tr][tc]

        # Reserved coordinates (template area)
        reserved = set((tr, width - TS + tc) for tr in range(TS) for tc in range(TS))

        # We'll restrict the path so it never enters the top 2 rows or the last 2 columns
        # (the template zone). This makes it easier to guarantee no overlap with the
        # template area in the input.
        min_row_allowed = TS
        max_col_allowed = width - TS - 1
        if max_col_allowed < 0 or min_row_allowed >= height:
            continue

        # Start the path at bottom-left, moving rightward initially
        start_r, start_c = height - 1, 0
        if not (start_r >= min_row_allowed and start_c <= max_col_allowed):
            continue

        # Working copy to build the path
        work = [row[:] for row in input_grid]
        path_cells = set()
        mirrors = []

        # Place start
        work[start_r][start_c] = 1
        path_cells.add((start_r, start_c))

        cur_r, cur_c = start_r, start_c
        dir_idx = 0  # start moving right

        num_segments = random.randint(3, 7)
        build_failed = False

        for seg in range(num_segments):
            dr, dc = directions[dir_idx]

            # Compute how many steps we can safely take in this direction
            max_steps = 0
            r, c = cur_r, cur_c
            while True:
                nr, nc = r + dr, c + dc
                if not (0 <= nr < height and 0 <= nc < width):
                    break
                # avoid template area entirely
                if nr < min_row_allowed or nc > max_col_allowed:
                    break
                if (nr, nc) in path_cells:
                    break
                max_steps += 1
                r, c = nr, nc

            if max_steps <= 0:
                build_failed = True
                break

            # Choose a segment length (at least 1 so the path progresses)
            max_choice = max(1, min(max_steps, 6))
            seg_len = random.randint(1, max_choice)

            # Step seg_len times
            for _ in range(seg_len):
                cur_r += dr
                cur_c += dc
                work[cur_r][cur_c] = 1
                path_cells.add((cur_r, cur_c))

            # If not the last segment, place a mirror at the current cell and turn left
            if seg < num_segments - 1:
                work[cur_r][cur_c] = 2
                mirrors.append((cur_r, cur_c))
                dir_idx = (dir_idx + 1) % 4  # always turn left (consistent with description)

        if build_failed:
            continue

        # Helper to test whether a 2x2 template can be placed starting (top-left) at (tr,tc)
        def can_place_at_top(tr, tc):
            if not (0 <= tr and tr + 1 < height and 0 <= tc and tc + 1 < width):
                return False
            for rr in (tr, tr + 1):
                for cc in (tc, tc + 1):
                    if work[rr][cc] != 0:
                        return False
            return True

        # Helper to compute the top-left position for the first template placement given
        # a mirror at (mr,mc) and the new direction.
        def first_topleft_for(mr, mc, new_dir_idx):
            drn, dcn = directions[new_dir_idx]
            # Place the 2x2 block adjacent to the mirror in the new direction, but
            # offset so the block does not include the mirror cell itself.
            if (drn, dcn) == (0, 1):  # right
                return (mr, mc + 1)
            if (drn, dcn) == (0, -1):  # left
                return (mr, mc - TS)
            if (drn, dcn) == (1, 0):  # down
                return (mr + 1, mc)
            if (drn, dcn) == (-1, 0):  # up
                return (mr - TS, mc)
            return (None, None)

        # Check at least one mirror can spawn at least one template placement
        chain_possible = False
        for (mr, mc) in mirrors:
            # find the previous path cell (the one that leads into the mirror)
            prev = None
            for dr, dc in directions:
                pr, pc = mr - dr, mc - dc
                if 0 <= pr < height and 0 <= pc < width and work[pr][pc] == 1:
                    prev = (pr, pc)
                    break
            if prev is None:
                continue
            dr_prev, dc_prev = mr - prev[0], mc - prev[1]
            if (dr_prev, dc_prev) not in directions:
                continue
            prev_idx = directions.index((dr_prev, dc_prev))
            new_idx = (prev_idx + 1) % 4  # left turn
            tr, tc = first_topleft_for(mr, mc, new_idx)
            if tr is None:
                continue
            if can_place_at_top(tr, tc):
                chain_possible = True
                break

        if not chain_possible:
            # rebuild another configuration
            continue

        # We have a valid input; finalize it and create the output by placing chains
        input_grid = work
        output_grid = [row[:] for row in input_grid]

        # Place chains for each mirror (do not overwrite non-background cells)
        for (mr, mc) in mirrors:
            # find previous
            prev = None
            for dr, dc in directions:
                pr, pc = mr - dr, mc - dc
                if 0 <= pr < height and 0 <= pc < width and input_grid[pr][pc] == 1:
                    prev = (pr, pc)
                    break
            if prev is None:
                continue
            dr_prev, dc_prev = mr - prev[0], mc - prev[1]
            if (dr_prev, dc_prev) not in directions:
                continue
            prev_idx = directions.index((dr_prev, dc_prev))
            new_idx = (prev_idx + 1) % 4
            drn, dcn = directions[new_idx]

            # initial top-left and step offsets based on direction
            if (drn, dcn) == (0, 1):
                tr, tc = mr, mc + 1
                row_off, col_off = 0, TS
            elif (drn, dcn) == (0, -1):
                tr, tc = mr, mc - TS
                row_off, col_off = 0, -TS
            elif (drn, dcn) == (1, 0):
                tr, tc = mr + 1, mc
                row_off, col_off = TS, 0
            elif (drn, dcn) == (-1, 0):
                tr, tc = mr - TS, mc
                row_off, col_off = -TS, 0
            else:
                continue

            # Repeat placing the template until blocked
            rtop, ctop = tr, tc
            placed_any = False
            while 0 <= rtop and rtop + 1 < height and 0 <= ctop and ctop + 1 < width:
                # must not overlap any non-background cell from the original input (not even the template area)
                blocked = False
                for rr in (rtop, rtop + 1):
                    for cc in (ctop, ctop + 1):
                        if input_grid[rr][cc] != 0:
                            blocked = True
                            break
                    if blocked:
                        break
                if blocked:
                    break
                # Place template colors in the output
                output_grid[rtop][ctop] = template[0][0]
                output_grid[rtop][ctop + 1] = template[0][1]
                output_grid[rtop + 1][ctop] = template[1][0]
                output_grid[rtop + 1][ctop + 1] = template[1][1]
                placed_any = True
                rtop += row_off
                ctop += col_off

        # Ensure output differs from input
        if output_grid == input_grid:
            # try again if nothing changed
            continue

        return {"input": input_grid, "output": output_grid}

    # If everything fails (extremely unlikely) produce a fallback simple instance
    width, height = 20, 20
    input_grid = grid(width, height, 0)
    template = [[3, 4], [5, 6]]
    for tr in range(2):
        for tc in range(2):
            input_grid[tr][width - 2 + tc] = template[tr][tc]
    # simple path along bottom with a mirror in the middle
    for c in range(0, 10):
        input_grid[height - 1][c] = 1
    input_grid[height - 1][5] = 2
    output_grid = [row[:] for row in input_grid]
    # place at least one template to ensure difference
    if height - 3 >= 0 and 6 + 1 + 1 < width:
        output_grid[height - 3][6] = template[0][0]
        output_grid[height - 3][7] = template[0][1]
        output_grid[height - 2][6] = template[1][0]
        output_grid[height - 2][7] = template[1][1]
    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    TS = 2
    directions = [(0, 1), (-1, 0), (0, -1), (1, 0)]  # right, up, left, down

    # Read template from the top-right reserved corner
    template = [[grid[0][width - 2], grid[0][width - 1]], [grid[1][width - 2], grid[1][width - 1]]]

    # Find mirrors
    mirrors = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 2:
                mirrors.append((r, c))

    # Helper to compute the first template top-left for a mirror + new direction
    def first_topleft_for(mr, mc, new_dir_idx):
        drn, dcn = directions[new_dir_idx]
        if (drn, dcn) == (0, 1):
            return (mr, mc + 1), (0, TS)
        if (drn, dcn) == (0, -1):
            return (mr, mc - TS), (0, -TS)
        if (drn, dcn) == (1, 0):
            return (mr + 1, mc), (TS, 0)
        if (drn, dcn) == (-1, 0):
            return (mr - TS, mc), (-TS, 0)
        return (None, None), (0, 0)

    out = [row[:] for row in grid]

    for (mr, mc) in mirrors:
        # find the previous path cell leading into the mirror (value 1)
        prev = None
        for dr, dc in directions:
            pr, pc = mr - dr, mc - dc
            if 0 <= pr < height and 0 <= pc < width and grid[pr][pc] == 1:
                prev = (pr, pc)
                break
        if prev is None:
            continue
        dr_prev, dc_prev = mr - prev[0], mc - prev[1]
        if (dr_prev, dc_prev) not in directions:
            continue
        prev_idx = directions.index((dr_prev, dc_prev))
        new_idx = (prev_idx + 1) % 4  # left turn, consistent with generator

        (tr_tc), (row_off, col_off) = first_topleft_for(mr, mc, new_idx)
        if tr_tc == (None, None):
            continue
        tr, tc = tr_tc

        # Place template repeatedly while the 2x2 area is background (0)
        while 0 <= tr and tr + 1 < height and 0 <= tc and tc + 1 < width:
            can_place = True
            for rr in (tr, tr + 1):
                for cc in (tc, tc + 1):
                    # must be background in the input grid to place the template
                    if grid[rr][cc] != 0:
                        can_place = False
                        break
                if not can_place:
                    break
            if not can_place:
                break
            # Place the template colors in the output
            out[tr][tc] = template[0][0]
            out[tr][tc + 1] = template[0][1]
            out[tr + 1][tc] = template[1][0]
            out[tr + 1][tc + 1] = template[1][1]
            tr += row_off
            tc += col_off

    return tuple(tuple(row) for row in out)

