# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 5d823efb
Difficulty: medium–hard

=== Tags ===
- Laser diffusion
- Signal to structure

=== Description ===
Input grids are 12×12 to 20×20 with a single background color (0). The grid
contains a single laser source (color 1), multiple diffusion points (color 2)
spaced at least two cells apart from each other and the source, and obstacles
(color 3) as isolated cells or small 2×2 clusters. The laser source emits a
rightward beam that travels through background cells until hitting a diffusion
point (color 2) or obstacle (color 3). Upon hitting a diffusion point, the beam
is absorbed, and a 3×3 diffusion structure is generated: the center remains
color 2, and the eight surrounding cells are set to color 4 if background (0),
preserving obstacles. The beam stops at the first diffusion point encountered,
and no structures are generated if an obstacle blocks the path before any
diffusion points. The output grid retains all input elements while adding
diffusion structures to all diffusion points along the beam's path, with
structures only applied to background cells and never overlapping obstacles.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(12, 20)
    height = random.randint(12, 20)
    grid = [[0] * width for _ in range(height)]
    
    source_row = random.randint(3, height - 4)
    grid[source_row][0] = 1
    
    diffusion_columns = []
    while not diffusion_columns:
        num_diffusion = random.randint(1, 3)
        for i in range(num_diffusion):
            c = 2 + 2 * i
            if c >= width:
                break
            diffusion_columns.append(c)
        if diffusion_columns:
            first_c = diffusion_columns[0]
            clear_path = True
            for col in range(1, first_c):
                if grid[source_row][col] != 0:
                    clear_path = False
                    break
            if not clear_path:
                diffusion_columns = []
    
    for c in diffusion_columns:
        grid[source_row][c] = 2
    
    num_obstacles = random.randint(3, 5)
    for _ in range(num_obstacles):
        if random.randint(0, 1):
            r = random.randint(0, height-1)
            c = random.randint(0, width-1)
            if r == source_row and 1 <= c < first_c:
                continue
            if grid[r][c] == 0:
                grid[r][c] = 3
        else:
            r = random.randint(0, height-2)
            c = random.randint(0, width-2)
            if (r == source_row and (1 <= c < first_c or 1 <= c+1 < first_c)):
                continue
            if all(grid[r + i][c + j] == 0 for i in range(2) for j in range(2)):
                for i in range(2):
                    for j in range(2):
                        grid[r + i][c + j] = 3
    
    output_grid = [row[:] for row in grid]
    first_c = diffusion_columns[0]
    for dr in (-1, 0, 1):
        for dc in (-1, 0, 1):
            if dr == 0 and dc == 0:
                continue
            r, c = source_row + dr, first_c + dc
            if 0 <= r < height and 0 <= c < width and output_grid[r][c] == 0:
                output_grid[r][c] = 4
    
    return {
        "input": grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    
    source_row = None
    for r in range(height):
        if input_grid[r][0] == 1:
            source_row = r
            break
    if source_row is None:
        return input_grid
    
    first_diffusion_col = None
    for c in range(1, width):
        if input_grid[source_row][c] == 2:
            first_diffusion_col = c
            break
        if input_grid[source_row][c] == 3:
            break
    
    if first_diffusion_col is None:
        return input_grid
    
    for col in range(1, first_diffusion_col):
        if input_grid[source_row][col] != 0:
            return input_grid
    
    for dr in (-1, 0, 1):
        for dc in (-1, 0, 1):
            if dr == 0 and dc == 0:
                continue
            r, c = source_row + dr, first_diffusion_col + dc
            if 0 <= r < height and 0 <= c < width and input_grid[r][c] == 0:
                input_grid[r][c] = 4
    
    return input_grid
