# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 4359ab01
Difficulty: hard

=== Tags ===
- Associate colors to numbers
- Color by manhattan distance
- Fill shape with tiling

=== Description ===
The input grid contains a single contiguous shape formed by non-zero cells (all
connected via orthogonal adjacency), with the background set to 0. The shape's
bounding box is defined by the minimal and maximal row and column indices of its
cells. The top-left corner of the shape is identified as the cell with the
smallest row index and, in case of ties, the smallest column index within the
shape. The output grid fills the shape with colors determined by the Manhattan
distance from this top-left corner: for each cell within the shape, the
Manhattan distance is calculated as (current_row - top_row) + (current_col -
top_col). This distance value is mapped cyclically to colors 1 through 9 (e.g.,
distance 0 → color 1, distance 1 → color 2, ..., distance 8 → color 9, distance
9 → color 1). The background remains unchanged (0), and the transformation
requires identifying the shape's top-left corner and applying the distance-based
color mapping across the entire shape. The task is challenging due to the need
to precisely locate the top-left corner in complex, non-rectangular shapes and
correctly map distances to colors while avoiding reliance on numerical values or
pixel-by-pixel matching.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    width = common.randint(1, 30)
    height = common.randint(1, 30)
    pixels = common.random_pixels(width, height, 0.3)
    attempts = 0
    while len(pixels) < 2 or not common.connected(pixels):
        pixels = common.random_pixels(width, height, 0.3)
        attempts += 1
        if attempts > 10:
            pixels = [(r, 0) for r in range(min(10, height))]
            break
    input_grid = common.grid(width, height, 0)
    for (r, c) in pixels:
        input_grid[r][c] = 1
    top_row = min(r for r, c in pixels)
    top_col = min(c for r, c in pixels if r == top_row)
    output_grid = common.grid(width, height, 0)
    for (r, c) in pixels:
        distance = (r - top_row) + (c - top_col)
        color = (distance % 9) + 1
        output_grid[r][c] = color
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    pixels = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                pixels.append((r, c))
    if not pixels:
        return input_grid
    top_row = min(r for r, c in pixels)
    top_col = min(c for r, c in pixels if r == top_row)
    output_grid = common.grid(width, height, 0)
    for (r, c) in pixels:
        distance = (r - top_row) + (c - top_col)
        color = (distance % 9) + 1
        output_grid[r][c] = color
    return output_grid
