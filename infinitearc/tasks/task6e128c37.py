# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 6e128c37
Difficulty: very hard

=== Tags ===
- Recursive partition

=== Description ===
The input grid consists of a background color (0) and one or more axis-aligned
rectangular regions defined by a single non-background color (e.g., 5), which
may be nested or adjacent. Each region must be recursively partitioned into four
equal quadrants (top-left, top-right, bottom-left, bottom-right) of the same
color, continuing until all subregions are exactly 2×2 in size. Between each
partition, a midline (vertical and horizontal) is drawn using a distinct line
color (e.g., 9) along the boundaries between quadrants, replacing the region’s
original color in those cells. The partitioning process is deterministic: for a
region spanning rows [r1, r2] and columns [c1, c2], the vertical split occurs at
column (c1 + c2) // 2 and the horizontal split at row (r1 + r2) // 2. Lines are
drawn only within the region’s bounds, preserving the background outside the
region. The output grid reflects all recursive partitions applied to every
qualifying region, resulting in a grid where the original regions are subdivided
into 2×2 blocks separated by the line color, with no overlapping or overwritten
non-background elements.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Generator for ARC task 412: recursive partition of filled square regions

def generate():
    # Choose grid dimensions that can host at least a 4x4 region
    width = random.randint(4, 30)
    height = random.randint(4, 30)

    ingrid = grid(width, height, 0)
    line_color = 9

    # Allowed square region sizes: powers of two starting at 4 (4,8,16,...)
    max_side = min(width, height)
    possible_sizes = []
    s = 4
    while s <= max_side:
        possible_sizes.append(s)
        s *= 2

    # Decide how many regions to try to place (at least one)
    max_regions = min(4, (width * height) // 16)
    if max_regions < 1:
        max_regions = 1
    region_count = random.randint(1, max_regions)

    # Choose distinct non-line non-background colors for regions
    palette = [c for c in range(1, 9)]
    random.shuffle(palette)
    colors = palette[:region_count]

    regions = []  # list of tuples (r1, r2, c1, c2, color)

    # Try to place each region as a non-overlapping square
    for color in colors:
        placed = False
        for _ in range(120):  # limited trials to avoid infinite loops
            size = random.choice(possible_sizes)
            r1 = random.randint(0, height - size)
            c1 = random.randint(0, width - size)
            r2 = r1 + size - 1
            c2 = c1 + size - 1

            # Check overlap with already placed regions (disallow any intersection)
            intersects = False
            for (pr1, pr2, pc1, pc2, _) in regions:
                if not (r2 < pr1 or r1 > pr2 or c2 < pc1 or c1 > pc2):
                    intersects = True
                    break
            if intersects:
                continue

            # Place the filled square of the chosen color
            for r in range(r1, r2 + 1):
                for c in range(c1, c2 + 1):
                    ingrid[r][c] = color

            regions.append((r1, r2, c1, c2, color))
            placed = True
            break
        # If not placed after many tries, skip this color

    # Ensure at least one region exists (fallback)
    if not regions:
        size = 4
        r1, c1 = 0, 0
        r2, c2 = r1 + size - 1, c1 + size - 1
        color = 1
        for r in range(r1, r2 + 1):
            for c in range(c1, c2 + 1):
                ingrid[r][c] = color
        regions.append((r1, r2, c1, c2, color))

    # Build the output by recursively partitioning each placed region
    outgrid = [row[:] for row in ingrid]

    def _partition_region(r1, r2, c1, c2, color):
        h = r2 - r1 + 1
        w = c2 - c1 + 1
        # Stop when region is exactly 2x2
        if h == 2 and w == 2:
            return
        mid_r = (r1 + r2) // 2
        mid_c = (c1 + c2) // 2

        # Draw horizontal midline and vertical midline but only replace cells
        # that currently match the region's color (preserves other regions/background)
        for c in range(c1, c2 + 1):
            if outgrid[mid_r][c] == color:
                outgrid[mid_r][c] = line_color
        for r in range(r1, r2 + 1):
            if outgrid[r][mid_c] == color:
                outgrid[r][mid_c] = line_color

        # Recurse into the four quadrants
        _partition_region(r1, mid_r, c1, mid_c, color)
        _partition_region(r1, mid_r, mid_c + 1, c2, color)
        _partition_region(mid_r + 1, r2, c1, mid_c, color)
        _partition_region(mid_r + 1, r2, mid_c + 1, c2, color)

    for (r1, r2, c1, c2, color) in regions:
        _partition_region(r1, r2, c1, c2, color)

    return {"input": ingrid, "output": outgrid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0
    line_color = 9

    # Flood-fill connected components of each non-background, non-line color
    visited = [[False] * width for _ in range(height)]
    regions = []  # will store (r1, r2, c1, c2, color)

    from collections import deque

    for r in range(height):
        for c in range(width):
            color = grid[r][c]
            if color == 0 or color == line_color or visited[r][c]:
                continue
            # BFS to collect component of this color
            q = deque()
            q.append((r, c))
            visited[r][c] = True
            cells = [(r, c)]
            while q:
                cr, cc = q.popleft()
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                        visited[nr][nc] = True
                        q.append((nr, nc))
                        cells.append((nr, nc))

            # Compute bounding box for this component
            rs = [p[0] for p in cells]
            cs = [p[1] for p in cells]
            r1, r2 = min(rs), max(rs)
            c1, c2 = min(cs), max(cs)

            # Verify that the bounding box is entirely filled with this color
            full = True
            for rr in range(r1, r2 + 1):
                for cc in range(c1, c2 + 1):
                    if grid[rr][cc] != color:
                        full = False
                        break
                if not full:
                    break
            if full:
                regions.append((r1, r2, c1, c2, color))
            else:
                # If not a full rectangle, skip (generator produces full rectangles)
                continue

    # Apply the same recursive partition drawing as the generator
    def _partition_region(r1, r2, c1, c2, color):
        h = r2 - r1 + 1
        w = c2 - c1 + 1
        if h == 2 and w == 2:
            return
        mid_r = (r1 + r2) // 2
        mid_c = (c1 + c2) // 2

        for cc in range(c1, c2 + 1):
            if grid[mid_r][cc] == color:
                grid[mid_r][cc] = line_color
        for rr in range(r1, r2 + 1):
            if grid[rr][mid_c] == color:
                grid[rr][mid_c] = line_color

        _partition_region(r1, mid_r, c1, mid_c, color)
        _partition_region(r1, mid_r, mid_c + 1, c2, color)
        _partition_region(mid_r + 1, r2, c1, mid_c, color)
        _partition_region(mid_r + 1, r2, mid_c + 1, c2, color)

    for (r1, r2, c1, c2, color) in regions:
        _partition_region(r1, r2, c1, c2, color)

    return grid

