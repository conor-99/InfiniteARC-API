# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: e683116d
Difficulty: medium

=== Tags ===
- Projection unto rectangle
- Hole punch pattern

=== Description ===
The input grid contains a connected shape composed of non-zero values with
internal holes (zeros). The output grid is formed by first identifying the
minimal bounding rectangle that contains all non-zero cells of the input. Within
this bounding rectangle, the output grid applies a checkerboard hole punch
pattern: each cell at position (i, j) in the cropped grid is set to zero if (i +
j) is even, and retains its input value otherwise. This transformation requires
recognizing the shape's bounding box and applying a consistent pattern of holes
based on coordinate parity.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    width = common.randint(3, 30)
    height = common.randint(3, 30)
    rows, cols = common.conway_sprite(width, height, tries=1)
    input_grid = common.grid(width, height, 0)
    for r, c in zip(rows, cols):
        input_grid[r][c] = 1
    min_row = min(rows)
    max_row = max(rows)
    min_col = min(cols)
    max_col = max(cols)
    output_width = max_col - min_col + 1
    output_height = max_row - min_row + 1
    output_grid = common.grid(output_width, output_height, 0)
    for i in range(output_height):
        for j in range(output_width):
            if (i + j) % 2 == 0:
                output_grid[i][j] = 0
            else:
                output_grid[i][j] = input_grid[min_row + i][min_col + j]
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    non_zero = []
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] != 0:
                non_zero.append((r, c))
    if not non_zero:
        return input_grid
    min_row = min(p[0] for p in non_zero)
    max_row = max(p[0] for p in non_zero)
    min_col = min(p[1] for p in non_zero)
    max_col = max(p[1] for p in non_zero)
    output_height = max_row - min_row + 1
    output_width = max_col - min_col + 1
    output_grid = common.grid(output_width, output_height, 0)
    for i in range(output_height):
        for j in range(output_width):
            if (i + j) % 2 == 0:
                output_grid[i][j] = 0
            else:
                output_grid[i][j] = input_grid[min_row + i][min_col + j]
    return output_grid
