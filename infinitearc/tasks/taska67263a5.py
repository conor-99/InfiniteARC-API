# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: a67263a5
Difficulty: insane

=== Tags ===
- Bridges
- Mirror twins
- Wave reflection
- Associate images to images

=== Description ===
Input grids feature a complex network of interconnected wave patterns, mirror
structures, and bridge connections. The wave is represented by a continuous,
color-coded path (e.g., blue) that originates from the bottom-left corner and
propagates diagonally upward-right. Vertical and horizontal mirror lines (red)
are embedded throughout the grid, positioned to reflect wave direction upon
contact. Bridge structures (green) appear as T-junctions or crossroads that
allow waves to traverse without directional change. Crucially, the grid contains
mirror twins: each mirror line has a symmetrical counterpart across the central
vertical axis, creating paired reflection points.  The transformation requires:
1. **Wave propagation**: The wave follows its initial trajectory until
encountering a mirror line, where it reflects according to mirror orientation
(vertical mirrors flip horizontal-to-vertical movement, horizontal mirrors flip
vertical-to-horizontal). 2. **Mirror twin reflection**: Each mirror's reflection
generates a twin wave on the opposite side of its paired mirror, propagating in
the reflected direction with identical path logic. 3. **Bridge traversal**:
Waves passing through bridge structures continue uninterrupted in their current
direction, with bridges preserved as green elements. 4. **Wave association**:
The output associates each wave segment with its mirror twin counterpart,
creating a symmetrical wave pattern that mirrors the input's structural
relationships. All wave paths must terminate at grid boundaries without
overlapping non-wave elements (mirrors, bridges, or background).  The output
grid displays the original wave path, all reflected twin waves, and bridges,
with wave colors cycling through a predefined sequence (e.g., blue → green →
red) at each reflection point. Background remains unchanged, and all
transformations strictly adhere to the spatial relationships defined by the
input's mirror pairs and bridge placements.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Grid size
    width = random.randint(15, 25)
    height = random.randint(15, 25)

    # Colors (stable across generator and solver)
    BACK = 0
    MIRROR = 2
    BRIDGE = 3
    WAVE_CYCLE = [1, 4, 5]  # colors used for successive reflection segments

    # Create empty input grid
    input_grid = grid(width, height, BACK)

    # Build the primary diagonal wave path starting from bottom-left
    path = []
    r, c = height - 1, 0
    while 0 <= r < height and 0 <= c < width:
        path.append((r, c))
        r -= 1
        c += 1

    # Reserve occupied cells (mirrors/bridges) so we don't overlap structures
    occupied = set()

    # Place 1..3 mirror pairs. Each mirror is a 3-cell line (vertical or horizontal) centered on a path cell.
    mirrors = []  # list of (r_center, c_center, orientation)
    max_pairs = min(3, max(1, len(path) - 2))
    pair_count = random.randint(1, max_pairs)

    attempts_global = 0
    for _ in range(pair_count):
        placed = False
        attempts = 0
        while not placed and attempts < 80:
            attempts += 1
            attempts_global += 1
            # pick an internal index along the path (avoid endpoints)
            idx = random.randint(1, max(1, len(path) - 2))
            rc, cc = path[idx]
            # avoid the central column when width is odd so the twin won't collide with itself
            if width % 2 == 1 and cc == width // 2:
                continue

            orient = random.choice(["vertical", "horizontal"])
            # compute group cells for mirror and twin
            if orient == "vertical":
                if rc - 1 < 0 or rc + 1 >= height:
                    continue
                group = [(rc - 1, cc), (rc, cc), (rc + 1, cc)]
            else:
                if cc - 1 < 0 or cc + 1 >= width:
                    continue
                group = [(rc, cc - 1), (rc, cc), (rc, cc + 1)]

            twin_cc = width - 1 - cc
            # require twin center not on edge so twin group fits
            if twin_cc <= 0 or twin_cc >= width - 1:
                continue

            if orient == "vertical":
                twin_group = [(rc - 1, twin_cc), (rc, twin_cc), (rc + 1, twin_cc)]
            else:
                twin_group = [(rc, twin_cc - 1), (rc, twin_cc), (rc, twin_cc + 1)]

            # ensure no overlap with existing special objects
            conflict = False
            for cell in group + twin_group:
                rr, cc2 = cell
                if not (0 <= rr < height and 0 <= cc2 < width):
                    conflict = True
                    break
                if cell in occupied:
                    conflict = True
                    break
            if conflict:
                continue

            # commit mirror groups
            for cell in group:
                input_grid[cell[0]][cell[1]] = MIRROR
                occupied.add(cell)
            for cell in twin_group:
                input_grid[cell[0]][cell[1]] = MIRROR
                occupied.add(cell)

            mirrors.append((rc, cc, orient))
            placed = True

        # if we failed to place after many attempts, break to avoid infinite loops
        if not placed:
            break

    # Place 1..3 bridges (T-junctions). They are 3-cell T shapes centered on a path cell.
    bridge_count = random.randint(1, 3)
    bridges = []
    bridge_attempts = 0
    placed_bridges = 0
    while placed_bridges < bridge_count and bridge_attempts < 200:
        bridge_attempts += 1
        idx = random.randint(1, max(1, len(path) - 2))
        br, bc = path[idx]
        if (br, bc) in occupied:
            continue
        orient = random.choice(["horizontal", "vertical"])
        if orient == "horizontal":
            if bc - 1 < 0 or bc + 1 >= width:
                continue
            cells = [(br, bc - 1), (br, bc), (br, bc + 1)]
        else:
            if br - 1 < 0 or br + 1 >= height:
                continue
            cells = [(br - 1, bc), (br, bc), (br + 1, bc)]
        if any(cell in occupied for cell in cells):
            continue
        for cell in cells:
            input_grid[cell[0]][cell[1]] = BRIDGE
            occupied.add(cell)
        bridges.append((br, bc, orient))
        placed_bridges += 1

    # Draw the original (input) wave path with the first color in the cycle, but don't overwrite mirrors/bridges
    for (rr, cc) in path:
        if input_grid[rr][cc] == BACK:
            input_grid[rr][cc] = WAVE_CYCLE[0]

    # Now simulate the wave propagation to build the output grid
    output_grid = [row[:] for row in input_grid]

    # Detect mirror centers and orientations (center cell of the 3-length mirror)
    mirror_centers = {}  # (r,c) -> orientation
    for rr in range(1, height - 1):
        for cc in range(1, width - 1):
            if input_grid[rr][cc] != MIRROR:
                continue
            if input_grid[rr - 1][cc] == MIRROR and input_grid[rr + 1][cc] == MIRROR:
                mirror_centers[(rr, cc)] = "vertical"
            elif input_grid[rr][cc - 1] == MIRROR and input_grid[rr][cc + 1] == MIRROR:
                mirror_centers[(rr, cc)] = "horizontal"

    # Pair mirrors into twins across the central vertical axis
    twin_map = {}
    for (rc, cc), orient in list(mirror_centers.items()):
        twin_cc = width - 1 - cc
        if (rc, twin_cc) in mirror_centers and mirror_centers[(rc, twin_cc)] == orient:
            twin_map[(rc, cc)] = (rc, twin_cc)
            twin_map[(rc, twin_cc)] = (rc, cc)

    # Wave propagation using queue. Each wave state: (r, c, dr, dc, reflection_count)
    from collections import deque
    queue = deque()
    start_r, start_c = height - 1, 0
    queue.append((start_r, start_c, -1, 1, 0))

    # visited states to prevent infinite loops: include color index (reflection_count mod len(WAVE_CYCLE))
    visited = set()
    cycle_len = len(WAVE_CYCLE)

    while queue:
        r0, c0, dr, dc, refl = queue.popleft()
        if not (0 <= r0 < height and 0 <= c0 < width):
            continue
        color_idx = refl % cycle_len
        state = (r0, c0, dr, dc, color_idx)
        if state in visited:
            continue
        visited.add(state)

        cell_val = input_grid[r0][c0]
        # Paint wave segment only if the input cell was background (do not overwrite mirrors/bridges or other preexisting colors)
        if cell_val == BACK:
            output_grid[r0][c0] = WAVE_CYCLE[color_idx]

        # Mirror handling
        if cell_val == MIRROR:
            # Find mirror center and orientation for this cluster
            center = None
            orient = None
            # quick checks
            if r0 - 1 >= 0 and r0 + 1 < height and input_grid[r0 - 1][c0] == MIRROR and input_grid[r0 + 1][c0] == MIRROR:
                center = (r0, c0)
                orient = "vertical"
            elif c0 - 1 >= 0 and c0 + 1 < width and input_grid[r0][c0 - 1] == MIRROR and input_grid[r0][c0 + 1] == MIRROR:
                center = (r0, c0)
                orient = "horizontal"
            else:
                # fallback: search nearby for a known center
                found = False
                for rr in range(max(1, r0 - 2), min(height - 1, r0 + 3)):
                    if (rr, c0) in mirror_centers:
                        center = (rr, c0)
                        orient = mirror_centers[center]
                        found = True
                        break
                if not found:
                    for cc in range(max(1, c0 - 2), min(width - 1, c0 + 3)):
                        if (r0, cc) in mirror_centers:
                            center = (r0, cc)
                            orient = mirror_centers[center]
                            found = True
                            break
                if not found:
                    # fallback to treating it as vertical
                    center = (r0, c0)
                    orient = "vertical"

            # Reflect direction
            if orient == "vertical":
                dr2, dc2 = dr, -dc
            else:
                dr2, dc2 = -dr, dc
            refl2 = refl + 1

            # spawn twin wave if there is a paired mirror
            if center in twin_map:
                twin_center = twin_map[center]
                # twin direction is the horizontal mirror of the main outgoing direction
                twin_dr, twin_dc = dr2, -dc2
                queue.append((twin_center[0], twin_center[1], twin_dr, twin_dc, refl2))

            # continue main wave from mirrored direction
            nr, nc = r0 + dr2, c0 + dc2
            queue.append((nr, nc, dr2, dc2, refl2))
            continue

        # Bridge handling: wave passes through unchanged
        if cell_val == BRIDGE:
            nr, nc = r0 + dr, c0 + dc
            queue.append((nr, nc, dr, dc, refl))
            continue

        # Normal empty or wave cell: continue in same direction
        nr, nc = r0 + dr, c0 + dc
        queue.append((nr, nc, dr, dc, refl))

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Make a mutable copy
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0])

    # Same color constants as the generator
    BACK = 0
    MIRROR = 2
    BRIDGE = 3
    WAVE_CYCLE = [1, 4, 5]

    # Prepare output as a copy of the input (we will only paint background cells)
    output = [row[:] for row in grid_in]

    # Detect mirror centers and orientations
    mirror_centers = {}
    for r in range(1, height - 1):
        for c in range(1, width - 1):
            if grid_in[r][c] != MIRROR:
                continue
            if grid_in[r - 1][c] == MIRROR and grid_in[r + 1][c] == MIRROR:
                mirror_centers[(r, c)] = "vertical"
            elif grid_in[r][c - 1] == MIRROR and grid_in[r][c + 1] == MIRROR:
                mirror_centers[(r, c)] = "horizontal"

    # Pair mirrors across central vertical axis
    twin_map = {}
    for (r, c), orient in list(mirror_centers.items()):
        twin_c = width - 1 - c
        if (r, twin_c) in mirror_centers and mirror_centers[(r, twin_c)] == orient:
            twin_map[(r, c)] = (r, twin_c)
            twin_map[(r, twin_c)] = (r, c)

    # Breadth-first propagation of waves
    from collections import deque
    q = deque()
    start_r, start_c = height - 1, 0
    q.append((start_r, start_c, -1, 1, 0))

    visited = set()
    cycle_len = len(WAVE_CYCLE)

    while q:
        r0, c0, dr, dc, refl = q.popleft()
        if not (0 <= r0 < height and 0 <= c0 < width):
            continue
        color_idx = refl % cycle_len
        state = (r0, c0, dr, dc, color_idx)
        if state in visited:
            continue
        visited.add(state)

        cell_val = grid_in[r0][c0]
        # Paint only if it was background in the input
        if cell_val == BACK:
            output[r0][c0] = WAVE_CYCLE[color_idx]

        # Mirror handling (same logic as generator)
        if cell_val == MIRROR:
            center = None
            orient = None
            if r0 - 1 >= 0 and r0 + 1 < height and grid_in[r0 - 1][c0] == MIRROR and grid_in[r0 + 1][c0] == MIRROR:
                center = (r0, c0)
                orient = "vertical"
            elif c0 - 1 >= 0 and c0 + 1 < width and grid_in[r0][c0 - 1] == MIRROR and grid_in[r0][c0 + 1] == MIRROR:
                center = (r0, c0)
                orient = "horizontal"
            else:
                found = False
                for rr in range(max(1, r0 - 2), min(height - 1, r0 + 3)):
                    if (rr, c0) in mirror_centers:
                        center = (rr, c0)
                        orient = mirror_centers[center]
                        found = True
                        break
                if not found:
                    for cc in range(max(1, c0 - 2), min(width - 1, c0 + 3)):
                        if (r0, cc) in mirror_centers:
                            center = (r0, cc)
                            orient = mirror_centers[center]
                            found = True
                            break
                if not found:
                    center = (r0, c0)
                    orient = "vertical"

            # Compute reflected direction
            if orient == "vertical":
                dr2, dc2 = dr, -dc
            else:
                dr2, dc2 = -dr, dc
            refl2 = refl + 1

            # Spawn twin if a paired mirror exists
            if center in twin_map:
                twin_center = twin_map[center]
                twin_dr, twin_dc = dr2, -dc2
                q.append((twin_center[0], twin_center[1], twin_dr, twin_dc, refl2))

            # Continue main wave after reflection
            nr, nc = r0 + dr2, c0 + dc2
            q.append((nr, nc, dr2, dc2, refl2))
            continue

        # Bridge: pass through
        if cell_val == BRIDGE:
            nr, nc = r0 + dr, c0 + dc
            q.append((nr, nc, dr, dc, refl))
            continue

        # Normal cell: continue
        nr, nc = r0 + dr, c0 + dc
        q.append((nr, nc, dr, dc, refl))

    return output

