# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: a443fe8c
Difficulty: insane

=== Tags ===
- Gas expansion
- Shape morphing

=== Description ===
The input grid features multiple disconnected, contiguous shapes of distinct
colors (1-9), each occupying a minimal bounding rectangle with no internal
background cells. The background is uniformly color 0. Each shape's color
dictates its gas expansion direction: 1=right, 2=left, 3=up, 4=down,
5=diagonally northeast, 6=diagonally northwest, 7=diagonally southeast,
8=diagonally southwest, 9=expands in all eight directions. Expansion occurs by
converting adjacent background cells (0) into the shape's color, with color 9
overriding all other directions for overlapping targets. After expansion, every
shape that underwent expansion (i.e., gained at least one cell) is rotated 90Â°
clockwise around its centroid, and its color increments by 1 (color 9 wraps to
1). Shapes that could not expand due to grid boundaries or existing shapes
retain their original color and position. The output grid displays all expanded
shapes with their new colors and rotated forms, while non-expanded shapes remain
unchanged, and background cells remain color 0 except for newly filled expansion
cells.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def get_direction(color):
    # Mapping rows (r) increase downward, cols (c) increase rightward
    if color == 1:
        return (0, 1)   # right
    if color == 2:
        return (0, -1)  # left
    if color == 3:
        return (-1, 0)  # up
    if color == 4:
        return (1, 0)   # down
    if color == 5:
        return (-1, 1)  # northeast (up-right)
    if color == 6:
        return (-1, -1) # northwest (up-left)
    if color == 7:
        return (1, 1)   # southeast (down-right)
    if color == 8:
        return (1, -1)  # southwest (down-left)
    return None        # color 9 (all directions)


def generate():
    # Create a grid with several filled-rectangle shapes of distinct colors.
    # Repeat until at least one shape can expand (so input != output) and placement succeeded.
    for _attempt in range(200):
        width = random.randint(6, 20)
        height = random.randint(6, 20)
        grid = common.grid(width, height, 0)

        # Number of shapes (distinct colors)
        max_shapes = min(5, 9)
        num_shapes = random.randint(2, max_shapes)
        colors = random.sample(list(range(1, 10)), num_shapes)

        shapes = []  # list of dicts: {color, pixels}
        failed = False
        # Place filled rectangles ensuring they don't touch each other (one-cell padding)
        for color in colors:
            placed = False
            for _ in range(200):
                # Choose rectangle size
                max_h = min(6, height)
                max_w = min(6, width)
                h = random.randint(1, max_h)
                w = random.randint(1, max_w)
                r0 = random.randint(0, height - h)
                c0 = random.randint(0, width - w)

                # check padding area (one cell around) to avoid touching other shapes
                ra = max(0, r0 - 1)
                rb = min(height - 1, r0 + h)
                ca = max(0, c0 - 1)
                cb = min(width - 1, c0 + w)
                conflict = False
                for rr in range(ra, rb + 1):
                    for cc in range(ca, cb + 1):
                        if grid[rr][cc] != 0:
                            conflict = True
                            break
                    if conflict:
                        break
                if conflict:
                    continue
                # place rectangle
                pixels = []
                for rr in range(r0, r0 + h):
                    for cc in range(c0, c0 + w):
                        grid[rr][cc] = color
                        pixels.append((rr, cc))
                shapes.append({"color": color, "pixels": pixels})
                placed = True
                break
            if not placed:
                failed = True
                break
        if failed:
            continue

        # Compute expansion proposals based on the original grid
        proposals = {s['color']: set() for s in shapes}
        initial = [row[:] for row in grid]
        for s in shapes:
            color = s['color']
            pixels = s['pixels']
            if color == 9:
                for (r, c) in pixels:
                    for dr in (-1, 0, 1):
                        for dc in (-1, 0, 1):
                            if dr == 0 and dc == 0:
                                continue
                            nr, nc = r + dr, c + dc
                            if 0 <= nr < height and 0 <= nc < width and initial[nr][nc] == 0:
                                proposals[color].add((nr, nc))
            else:
                dir = get_direction(color)
                dr, dc = dir
                for (r, c) in pixels:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and initial[nr][nc] == 0:
                        proposals[color].add((nr, nc))

        # Resolve conflicts: if any color 9 proposes a cell it wins; otherwise a unique proposer wins; contested non-9 cells remain empty
        target_proposers = {}
        for color, cells in proposals.items():
            for cell in cells:
                target_proposers.setdefault(cell, []).append(color)

        final_target = {}
        for cell, proposers in target_proposers.items():
            if 9 in proposers:
                final_target[cell] = 9
            else:
                uniq = set(proposers)
                if len(uniq) == 1:
                    final_target[cell] = proposers[0]
                else:
                    # contested by multiple non-9 shapes -> stays background (no one gains it)
                    pass

        # Assign accepted expansions per shape
        accepted = {s['color']: set() for s in shapes}
        for cell, color in final_target.items():
            accepted[color].add(cell)

        # Require at least one shape to actually expand
        any_expanded = any(len(cells) > 0 for cells in accepted.values())
        if not any_expanded:
            continue

        # Prepare output grid: start from original
        output = [row[:] for row in initial]

        # Determine non-expanded original cells to protect them from being overwritten by rotations
        non_expanded_cells = set()
        for s in shapes:
            if len(accepted[s['color']]) == 0:
                non_expanded_cells.update(s['pixels'])

        # Apply expansions (as intermediate step) and then rotate expanded shapes
        # We will rotate shapes in ascending order of their original color for determinism
        for s in sorted(shapes, key=lambda x: x['color']):
            color = s['color']
            orig_pixels = set(s['pixels'])
            exp_cells = accepted[color]
            if not exp_cells:
                # no expansion, shape stays as-is
                continue
            # Form the expanded shape (original + newly gained cells)
            all_pixels = sorted(list(orig_pixels | exp_cells))
            # Compute centroid
            cr = sum(p[0] for p in all_pixels) / len(all_pixels)
            cc = sum(p[1] for p in all_pixels) / len(all_pixels)

            # Compute rotated positions (90 degrees clockwise) around centroid
            new_positions = set()
            for (r, c) in all_pixels:
                dx = c - cc
                dy = r - cr
                new_c = cc + dy
                new_r = cr - dx
                nr = int(round(new_r))
                nc = int(round(new_c))
                if 0 <= nr < height and 0 <= nc < width:
                    new_positions.add((nr, nc))

            # Clear the original expanded area (original pixels + expansion cells)
            for (r, c) in all_pixels:
                if 0 <= r < height and 0 <= c < width:
                    output[r][c] = 0

            # Place rotated pixels with incremented color (wrap 9->1)
            new_color = (color % 9) + 1
            for (r, c) in new_positions:
                # Do not overwrite any original cell that belonged to a non-expanded shape
                if (r, c) in non_expanded_cells:
                    continue
                output[r][c] = new_color

        return {"input": initial, "output": output}

    # Fallback (should rarely happen)
    raise RuntimeError('Could not generate a valid puzzle after many attempts')



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def get_direction(color):
    if color == 1:
        return (0, 1)
    if color == 2:
        return (0, -1)
    if color == 3:
        return (-1, 0)
    if color == 4:
        return (1, 0)
    if color == 5:
        return (-1, 1)
    if color == 6:
        return (-1, -1)
    if color == 7:
        return (1, 1)
    if color == 8:
        return (1, -1)
    return None


def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Identify shapes (colors are guaranteed unique per shape by the generator)
    shapes = {}
    for r in range(height):
        for c in range(width):
            color = grid[r][c]
            if color == 0:
                continue
            shapes.setdefault(color, []).append((r, c))

    # Prepare proposals for expansion
    proposals = {color: set() for color in shapes}
    initial = [row[:] for row in grid]
    for color, pixels in shapes.items():
        if color == 9:
            for (r, c) in pixels:
                for dr in (-1, 0, 1):
                    for dc in (-1, 0, 1):
                        if dr == 0 and dc == 0:
                            continue
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < height and 0 <= nc < width and initial[nr][nc] == 0:
                            proposals[color].add((nr, nc))
        else:
            dr, dc = get_direction(color)
            for (r, c) in pixels:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and initial[nr][nc] == 0:
                    proposals[color].add((nr, nc))

    # Resolve conflicts: 9 overrides any other; unique non-9 proposer wins; contested non-9 remain empty
    target_proposers = {}
    for color, cells in proposals.items():
        for cell in cells:
            target_proposers.setdefault(cell, []).append(color)

    final_target = {}
    for cell, proposers in target_proposers.items():
        if 9 in proposers:
            final_target[cell] = 9
        else:
            uniq = set(proposers)
            if len(uniq) == 1:
                final_target[cell] = proposers[0]
            else:
                # contested, nobody wins
                pass

    # Assign accepted expansions per color
    accepted = {color: set() for color in shapes}
    for cell, color in final_target.items():
        accepted[color].add(cell)

    # Build output starting from initial
    output = [row[:] for row in initial]

    # Non-expanded original cells should be preserved
    non_expanded_cells = set()
    for color, pixels in shapes.items():
        if len(accepted[color]) == 0:
            non_expanded_cells.update(pixels)

    # Rotate each expanded shape (sorted by original color for determinism)
    for color in sorted(shapes.keys()):
        orig_pixels = set(shapes[color])
        exp_cells = accepted[color]
        if not exp_cells:
            continue
        all_pixels = sorted(list(orig_pixels | exp_cells))
        cr = sum(p[0] for p in all_pixels) / len(all_pixels)
        cc = sum(p[1] for p in all_pixels) / len(all_pixels)

        new_positions = set()
        for (r, c) in all_pixels:
            dx = c - cc
            dy = r - cr
            new_c = cc + dy
            new_r = cr - dx
            nr = int(round(new_r))
            nc = int(round(new_c))
            if 0 <= nr < height and 0 <= nc < width:
                new_positions.add((nr, nc))

        # Clear original expanded pixels
        for (r, c) in all_pixels:
            output[r][c] = 0

        # Place rotated pixels with incremented color (wrap 9->1), but don't overwrite non-expanded originals
        new_color = (color % 9) + 1
        for (r, c) in new_positions:
            if (r, c) in non_expanded_cells:
                continue
            output[r][c] = new_color

    return output

