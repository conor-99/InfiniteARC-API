# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 3ddadb61
Difficulty: very hard

=== Tags ===
- Gas expansion
- Refraction simulation
- Draw path through ordered checkpoints
- Recursive pattern copy
- Portals

=== Description ===
Recursive Gas Refraction Path  Input grids consist of a complex, multi-layered
arrangement where a gas source cell initiates movement, surrounded by distinct
colored portals (each representing a fixed refraction rule), ordered checkpoints
(each a unique color in sequential order), and background walls. Gas moves in a
default horizontal direction from the source, refracting predictably at portals:
color 2 bends 90° left relative to current direction, color 3 bends 90° right,
color 4 reflects (reverses direction), and color 5 continues straight. The path
must traverse checkpoints in strict ascending color order (e.g., color 6 → color
7 → color 8) without skipping or overlapping. Grids feature recursive nested
structures where each inner layer mirrors the outer layer's portal/checkpoint
arrangement at reduced scale, connected via portal pathways. Walls block
movement, and all elements remain visually distinct.  Output grids display the
complete, continuous gas path as a single-line trajectory through all
checkpoints in order, with refractions applied at every portal across all
recursive layers. The path is rendered using the gas source color, while input
elements (portals, checkpoints, walls) remain visible in their original
positions. The trajectory must navigate all nested layers without deviation,
maintaining the sequential checkpoint order through every level of recursion.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    # Ensure a different size pattern across repeated calls by using a persistent counter
    if not hasattr(generate, "call_idx"):
        generate.call_idx = 0
    call_idx = generate.call_idx
    generate.call_idx += 1

    # Cycle widths/heights deterministically so the generator produces many distinct grids
    width = 9 + (call_idx % 12)            # cycles 9..20
    height = 9 + ((call_idx // 12) % 12)   # cycles 9..20 as call_idx increases

    # Slight per-call randomness (walls/checkpoint count) remains, but dimensions ensure variety

    # Build a rectangular spiral path that starts at (0,0) and winds inward.
    path = []
    left, top, right, bottom = 0, 0, width - 1, height - 1
    while left <= right and top <= bottom:
        for c in range(left, right + 1):
            path.append((top, c))
        top += 1
        for r in range(top, bottom + 1):
            path.append((r, right))
        right -= 1
        if top <= bottom:
            for c in range(right, left - 1, -1):
                path.append((bottom, c))
            bottom -= 1
        if left <= right:
            for r in range(bottom, top - 1, -1):
                path.append((r, left))
            left += 1

    # Defensive: ensure path has enough length
    if len(path) < 8:
        path = [(0, c) for c in range(width)]

    path_len = len(path)

    # Helper to compute direction from a->b as 0:right,1:down,2:left,3:up
    def dir_of(a, b):
        dr = b[0] - a[0]
        dc = b[1] - a[1]
        if dr == 0 and dc == 1:
            return 0
        if dr == 1 and dc == 0:
            return 1
        if dr == 0 and dc == -1:
            return 2
        if dr == -1 and dc == 0:
            return 3
        return None

    # Compute delta (relative turn) for interior points of the path
    deltas = [0] * path_len
    turning = [False] * path_len
    for i in range(1, path_len - 1):
        D = dir_of(path[i - 1], path[i])
        ND = dir_of(path[i], path[i + 1])
        if D is None or ND is None:
            deltas[i] = 0
            turning[i] = False
        else:
            delta = (ND - D) % 4
            deltas[i] = delta
            turning[i] = (delta != 0)

    # Decide on number of checkpoints (colors 6,7,8). Keep it small so wall color (9) is free.
    checkpoints_count = random.choice([2, 3])

    # Pick checkpoint indices: we want them spaced along the path and not on turning cells if possible.
    candidates = [i for i in range(1, path_len - 1) if not turning[i]]
    if len(candidates) < (checkpoints_count - 1):
        # fallback to allow turning positions if not enough straight places
        candidates = [i for i in range(1, path_len - 1)]

    chosen = []
    # evenly spaced targets (avoid 0 and the very last until we append it)
    for j in range(checkpoints_count - 1):
        target = (j + 1) * path_len // (checkpoints_count + 1)
        # choose nearest available candidate
        cand = min(candidates, key=lambda x: abs(x - target))
        chosen.append(cand)
        candidates = [x for x in candidates if x != cand]

    # final checkpoint is the end of the path (ensures traversal stops there)
    chosen.append(path_len - 1)
    chosen = sorted(set(chosen))

    # Build input grid and place elements
    input_grid = grid(width, height, 0)

    # Source (gas) color 1 at the start of the path
    sr, sc = path[0]
    input_grid[sr][sc] = 1

    # Place portals on turning points (skip cells chosen as checkpoints)
    # Portal color mapping: 2 = left turn, 3 = right turn, 4 = reflect (reverse), 5 = straight
    for i in range(1, path_len - 1):
        if i in chosen:
            continue
        delta = deltas[i]
        if delta == 0:
            continue
        r, c = path[i]
        if delta == 1:  # right turn
            input_grid[r][c] = 3
        elif delta == 3:  # left turn
            input_grid[r][c] = 2
        elif delta == 2:  # reverse
            input_grid[r][c] = 4

    # Place checkpoints (distinct ascending colors starting at 6)
    checkpoint_positions = []
    for idx, pi in enumerate(chosen):
        color = 6 + idx
        r, c = path[pi]
        input_grid[r][c] = color
        checkpoint_positions.append((color, (r, c)))

    # Place some walls (color 9) in non-path spots to increase complexity
    path_set = set(path[: chosen[-1] + 1])  # protect the route up to final checkpoint
    for r in range(height):
        for c in range(width):
            if (r, c) in path_set:
                continue
            if input_grid[r][c] != 0:
                continue
            if random.random() < 0.25:
                input_grid[r][c] = 9

    # Build output: overlay the path (from source through final checkpoint) in gas color 1
    output_grid = [row[:] for row in input_grid]
    last_idx = chosen[-1]
    for i in range(0, last_idx + 1):
        r, c = path[i]
        output_grid[r][c] = 1

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0]) if height > 0 else 0

    # Find source (color 1)
    source = None
    for r in range(height):
        for c in range(width):
            if grid_in[r][c] == 1:
                source = (r, c)
                break
        if source:
            break

    if source is None:
        # Nothing to do
        return [list(row) for row in input_grid]

    # Identify checkpoints (colors >=6 and <=8) and sort them ascending
    checkpoint_colors = sorted({grid_in[r][c] for r in range(height) for c in range(width) if 6 <= grid_in[r][c] <= 8})

    # Prepare output grid as a copy of input; we'll draw the path by overwriting with 1s
    out = [row[:] for row in grid_in]

    # Movement state
    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up
    direction = 0  # start moving to the right
    r, c = source
    out[r][c] = 1

    # Walk until we either visit all checkpoints in order or cannot continue
    expected_idx = 0
    visited = set()
    visited.add((r, c))
    steps = 0
    max_steps = width * height * 4 + 100

    while steps < max_steps:
        steps += 1
        dr, dc = dirs[direction]
        nr, nc = r + dr, c + dc

        # Bounds or wall (9) stops the gas
        if nr < 0 or nr >= height or nc < 0 or nc >= width:
            break
        val = grid_in[nr][nc]
        if val == 9:
            break

        # Checkpoint handling: must be visited in ascending order
        if 6 <= val <= 8:
            # If encountering a checkpoint out of order, stop
            if expected_idx >= len(checkpoint_colors) or val != checkpoint_colors[expected_idx]:
                break
            # Accept the checkpoint
            expected_idx += 1
            out[nr][nc] = 1
            r, c = nr, nc
            visited.add((r, c))
            # If all checkpoints visited, stop after marking
            if expected_idx >= len(checkpoint_colors):
                break
            continue

        # Portal handling alters direction for the next step
        if val == 2:  # left turn
            direction = (direction - 1) % 4
        elif val == 3:  # right turn
            direction = (direction + 1) % 4
        elif val == 4:  # reflect
            direction = (direction + 2) % 4
        elif val == 5:
            # straight; no change
            pass

        # Mark this step on the output (path overwritten in output)
        out[nr][nc] = 1
        r, c = nr, nc
        if (r, c) in visited:
            # If we come back to a previously visited cell, stop to avoid loops
            break
        visited.add((r, c))

    return out

