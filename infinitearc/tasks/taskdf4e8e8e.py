# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: df4e8e8e
Difficulty: medium–hard

=== Tags ===
- Pathfinding with state
- Propagation by rule weight
- Find shape in negative space

=== Description ===
Input grids contain a background color (0) surrounded by walls of varying non-
zero colors (1-9), creating a closed boundary that encloses a hidden shape
within the negative space (background cells). The hidden shape is a contiguous,
recognizable pattern (e.g., a rectangle, cross, or diamond) formed entirely by
background cells, with no walls inside its region. The grid also includes a
single starting point at the top-left edge of the hidden shape (a background
cell adjacent to a wall), and the walls surrounding the hidden shape encode
direction rules via their colors.   In the output grid, the boundary of the
hidden shape is traced by a path that starts at the designated starting point,
initially moving right. At each step, the path moves forward until encountering
a wall; the wall’s color dictates the turn direction (e.g., wall color 1 = left
turn, color 2 = right turn, color 3 = continue straight). The path follows these
rules until it completes a closed loop, tracing the hidden shape’s perimeter.
The background cells along the path are replaced with a distinctive color (e.g.,
5), while the hidden shape itself remains visible as the inner region of the
traced loop. The task requires tracking the path’s current direction (state) and
applying wall-color-based turn rules to identify the hidden shape in the
negative space, combining pathfinding, state management, and pattern
recognition.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

# Generator for ARC task 445: walls (1/2/3) around a negative-space shape. The path-tracing rules are
# (1 -> turn left), (2 -> turn right), (3 -> continue straight). The generator builds a simply
# connected hidden shape (rectangle, diamond, or plus), places a one-cell-thick wall ring around it,
# then simulates the exact path the solver will take and stamps wall colors so the solver deterministically
# follows the perimeter. The generator returns a pair {"input": grid, "output": grid_with_path}.


def generate():
    # Helper rotations
    def rot_left(d):
        return (-d[1], d[0])
    def rot_right(d):
        return (d[1], -d[0])

    tries = 0
    while True:
        tries += 1
        if tries > 200:
            # fallback simple case if too many failures
            width, height = 10, 10
        else:
            width = random.randint(8, 20)
            height = random.randint(8, 20)

        grid = [[0 for _ in range(width)] for _ in range(height)]

        # pick a shape type and size, ensure there is space for a 1-cell wall around it
        shape_type = random.choice(['rectangle', 'diamond', 'plus'])

        S = set()  # set of coordinates (r,c) belonging to the hidden shape (background cells)

        if shape_type == 'rectangle':
            max_w = max(3, min(8, width - 4))
            max_h = max(3, min(8, height - 4))
            sw = random.randint(3, max_w)
            sh = random.randint(3, max_h)
            top = random.randint(1, height - sh - 1)
            left = random.randint(1, width - sw - 1)
            for r in range(top, top + sh):
                for c in range(left, left + sw):
                    S.add((r, c))

        elif shape_type == 'diamond':
            # diamond of radius rad (manhattan distance)
            max_rad = min((width - 3) // 2, (height - 3) // 2, 4)
            if max_rad < 1:
                continue
            rad = random.randint(1, max_rad)
            # bounding box size = 2*rad + 1
            box_h = 2 * rad + 1
            box_w = 2 * rad + 1
            top = random.randint(1, height - box_h - 1)
            left = random.randint(1, width - box_w - 1)
            center_r = top + rad
            center_c = left + rad
            for r in range(center_r - rad, center_r + rad + 1):
                for c in range(center_c - rad, center_c + rad + 1):
                    if abs(r - center_r) + abs(c - center_c) <= rad:
                        S.add((r, c))

        else:  # plus
            # center plus with arm length a (each arm extends a cells from center)
            max_arm = min((width - 3) // 2, (height - 3) // 2, 4)
            if max_arm < 1:
                continue
            arm = random.randint(1, max_arm)
            box_h = arm * 2 + 1
            box_w = arm * 2 + 1
            top = random.randint(1, height - box_h - 1)
            left = random.randint(1, width - box_w - 1)
            center_r = top + arm
            center_c = left + arm
            # horizontal arm
            for c in range(center_c - arm, center_c + arm + 1):
                S.add((center_r, c))
            # vertical arm
            for r in range(center_r - arm, center_r + arm + 1):
                S.add((r, center_c))

        # compute wall set W: any orthogonal neighbor of a shape cell that's not in the shape
        W = set()
        for (r, c) in S:
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in S:
                    W.add((nr, nc))

        if not W:
            # improbable, try again
            continue

        # boundary cells B: shape cells adjacent to at least one wall cell
        B = [p for p in S if any(((p[0] + dr, p[1] + dc) not in S) for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)])]
        if not B:
            continue

        # choose the starting cell: top-most then left-most boundary cell (this matches solver search order)
        start = min(B)

        # simulate the path and stamp wall colors so solver will follow the same path
        wall_colors = {}  # map from (r,c) in W -> color 1/2/3

        current = start
        direction = (0, 1)  # initially moving right
        path = []

        ok = True
        max_steps = max(1000, len(B) * 10)
        step = 0
        while True:
            step += 1
            if step > max_steps:
                ok = False
                break

            path.append(current)
            # termination: closed loop
            if len(path) > 1 and current == start:
                break

            # move forward if possible
            fr, fc = current[0] + direction[0], current[1] + direction[1]
            if 0 <= fr < height and 0 <= fc < width and (fr, fc) in S:
                current = (fr, fc)
                continue

            # otherwise we should be facing a wall cell in W
            if not (0 <= fr < height and 0 <= fc < width and (fr, fc) in W):
                ok = False
                break

            ahead = (fr, fc)

            # choose a direction among straight, right, left that keeps us inside the shape
            right = rot_right(direction)
            left = rot_left(direction)
            candidates = [ (direction, 3), (right, 2), (left, 1) ]
            chosen = None
            for nd, color in candidates:
                nr, nc = current[0] + nd[0], current[1] + nd[1]
                if (nr, nc) in S:
                    chosen = (nd, color)
                    break

            if chosen is None:
                ok = False
                break

            nd, color = chosen
            # ensure no conflicting color assigned to this wall cell
            prev = wall_colors.get(ahead)
            if prev is not None and prev != color:
                ok = False
                break
            wall_colors[ahead] = color

            # rotate and step
            direction = nd
            current = (current[0] + direction[0], current[1] + direction[1])

        if not ok:
            # try again
            if tries > 200:
                # fallback simple rectangle
                width, height = 10, 10
                grid = [[0 for _ in range(width)] for _ in range(height)]
                S = set((r, c) for r in range(3, 7) for c in range(3, 7))
                W = set()
                for (r, c) in S:
                    for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in S:
                            W.add((nr, nc))
                start = min([p for p in S if any(((p[0] + dr, p[1] + dc) not in S) for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)])])
                for w in W:
                    wall_colors[w] = 2
                # compute path again quickly
                current = start
                direction = (0,1)
                path = []
                for _ in range(200):
                    path.append(current)
                    fr, fc = current[0] + direction[0], current[1] + direction[1]
                    if 0 <= fr < height and 0 <= fc < width and (fr, fc) in S:
                        current = (fr, fc)
                        continue
                    rd = rot_right(direction)
                    ld = rot_left(direction)
                    if (current[0] + rd[0], current[1] + rd[1]) in S:
                        direction = rd
                        current = (current[0] + direction[0], current[1] + direction[1])
                        continue
                    if (current[0] + ld[0], current[1] + ld[1]) in S:
                        direction = ld
                        current = (current[0] + direction[0], current[1] + direction[1])
                        continue
                    break
                ok = True
            else:
                continue

        # paint walls into the input grid
        for (r, c), col in wall_colors.items():
            grid[r][c] = col
        # for any wall cell not assigned a specific instruction, give it color 3 (straight)
        for (r, c) in W:
            if grid[r][c] == 0:
                grid[r][c] = 3

        # prepare output grid by painting the path inside the shape with color 5
        output = [row[:] for row in grid]
        for (r, c) in path:
            output[r][c] = 5

        if grid != output:
            return {"input": grid, "output": output}
        # otherwise try again





# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # find all zero connected components (four-connected)
    visited = [[False]*width for _ in range(height)]
    components = []  # list of tuples (cells_set, touches_border)
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 or visited[r][c]:
                continue
            # BFS this component
            stack = [(r, c)]
            comp = set()
            touches_border = False
            visited[r][c] = True
            while stack:
                pr, pc = stack.pop()
                comp.add((pr, pc))
                if pr == 0 or pr == height-1 or pc == 0 or pc == width-1:
                    touches_border = True
                for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:
                    nr, nc = pr + dr, pc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == 0:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            components.append((comp, touches_border))

    # choose the enclosed component (the hidden shape): a zero component that does NOT touch the border
    enclosed = None
    for comp, touches in components:
        if not touches:
            enclosed = comp
            break
    if enclosed is None:
        # nothing enclosed; fall back to the first zero cell adjacent to a wall (original heuristic)
        start = None
        for r in range(height):
            for c in range(width):
                if grid[r][c] == 0:
                    for dr, dc in [(-1,0),(1,0),(0,-1),(0,1)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                            start = (r, c)
                            break
                    if start is not None:
                        break
            if start is not None:
                break
    else:
        # pick the top-left-most boundary cell in the enclosed component (a cell adjacent to a non-zero)
        boundary_cells = [p for p in enclosed if any(((p[0]+dr, p[1]+dc) not in enclosed) for dr,dc in [(-1,0),(1,0),(0,-1),(0,1)])]
        if boundary_cells:
            start = min(boundary_cells)
        else:
            start = min(enclosed)

    if start is None:
        return tuple(tuple(row) for row in grid)

    # directions and rotations
    def rot_left(d):
        return (-d[1], d[0])
    def rot_right(d):
        return (d[1], -d[0])

    direction = (0, 1)  # initially moving right
    current = start
    path = []
    visited_states = set()

    max_steps = width * height * 4
    steps = 0

    while True:
        steps += 1
        if steps > max_steps:
            break

        path.append(current)
        if len(path) > 1 and current == start:
            break

        fr, fc = current[0] + direction[0], current[1] + direction[1]
        # if forward is inside the hidden shape (background 0), just step
        if 0 <= fr < height and 0 <= fc < width and grid[fr][fc] == 0:
            current = (fr, fc)
            state = (current, direction)
            if state in visited_states:
                break
            visited_states.add(state)
            continue

        # facing a wall or outside; if outside bounds stop
        if not (0 <= fr < height and 0 <= fc < width):
            break
        wall_color = grid[fr][fc]
        # interpret wall color: 1 = left, 2 = right, 3 = straight (no rotation)
        if wall_color == 1:
            direction = rot_left(direction)
        elif wall_color == 2:
            direction = rot_right(direction)
        else:
            direction = direction

        # after rotating, step if possible
        nr, nc = current[0] + direction[0], current[1] + direction[1]
        if not (0 <= nr < height and 0 <= nc < width):
            break
        if grid[nr][nc] != 0:
            # if rotation didn't produce a free cell, give up
            break

        current = (nr, nc)
        state = (current, direction)
        if state in visited_states:
            break
        visited_states.add(state)

    # produce output by painting path cells with color 5
    output = [row[:] for row in grid]
    for (r, c) in path:
        output[r][c] = 5

    return tuple(tuple(row) for row in output)

