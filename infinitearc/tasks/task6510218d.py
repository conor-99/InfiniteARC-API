# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 6510218d
Difficulty: very hard

=== Tags ===
- Hierarchical agent routing
- Pattern intersection
- Color space mapping
- State transfer chain
- Associate patterns to patterns

=== Description ===
# Hierarchical Pattern Transfer Network  Input grids feature a background color
(0) with multiple embedded pattern blocks arranged throughout. Each pattern
block is a 3×3 grid where the top row contains a sequence of three distinct non-
background colors (e.g., [2,5,8]), and the remaining cells are background. These
blocks are positioned such that their top edges align with grid rows, with no
overlapping content. The grid also contains a 2×2 state transfer matrix (a
distinct region) with two color pairs (e.g., [3,7] in top-left and [9,4] in
bottom-right), defining the initial color state and mapping rules.  A single
agent source (color 9) is placed at the top-left corner. The agent begins moving
downward along the grid's leftmost column. Upon encountering a pattern block's
top edge, it enters the block and follows the sequence in the top row, moving
rightward through the block's cells. Each cell traversed changes the agent's
color to match the current sequence color. After exiting the block (to the
right), the agent continues moving downward until encountering the next pattern
block, where the sequence's starting index is determined by the agent's current
color via the state transfer matrix's mapping rules (e.g., color 2 maps to index
1 in the next block's sequence).  The pattern blocks are hierarchically
associated through the state transfer matrix: the sequence of a block determines
the color state for the next block in the chain. The associations are non-
obvious and require identifying the color mapping between the state transfer
matrix's pairs and the sequence indices. For example, the top-left color pair
[3,7] might indicate that color 3 corresponds to sequence index 0 and color 7 to
index 2 in the next block.  The output grid retains all input elements
(background, pattern blocks, state transfer matrix) unchanged, except for the
agent's path. This path is drawn through background cells only, with each
segment colored according to the sequence color at that position in the current
pattern block. The path must navigate through multiple pattern blocks while
respecting the hierarchical state transfer chain, with no intersections or
overwrites of pattern content. The sequence of colors along the path must
reflect the complete state transfer chain from the initial source through all
associated pattern blocks.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, randint

def generate():
    width = randint(15, 25)
    height = randint(15, 25)
    input_grid = grid(width, height, 0)
    
    state_colors = random.sample([c for c in range(1, 10)], 4)
    if 9 not in state_colors:
        state_colors[random.randint(0, 3)] = 9
    
    for i in range(2):
        for j in range(2):
            input_grid[height-2+i][width-2+j] = state_colors[2*i + j]

    block_positions = []
    for i in range(3):
        row = 3 + i*4
        col = 2 + i*4
        if row < height and col < width:
            block_positions.append((row, col))

    for (row, col) in block_positions:
        last_color = random.choice(state_colors)
        seq = []
        while len(seq) < 2:
            c = random.randint(1, 9)
            if c != last_color and c not in seq:
                seq.append(c)
        seq.append(last_color)
        input_grid[row][col] = seq[0]
        input_grid[row][col+1] = seq[1]
        input_grid[row][col+2] = seq[2]

    input_grid[0][0] = 9
    output_grid = [row[:] for row in input_grid]

    current_color = 9
    current_row = 0
    for (row, col) in block_positions:
        for r in range(current_row + 1, row):
            output_grid[r][0] = current_color
        current_color = input_grid[row][col+2]
        current_row = row
    
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    
    state_colors = [
        input_grid[height-2][width-2],
        input_grid[height-2][width-1],
        input_grid[height-1][width-2],
        input_grid[height-1][width-1]
    ]
    
    output_grid = [row[:] for row in input_grid]
    
    current_color = input_grid[0][0]
    current_row = 0
    
    for r in range(height):
        for c in range(width):
            if r >= 3 and c >= 2 and r < height-2 and c < width-2:
                if input_grid[r][c] != 0 and input_grid[r][c+1] != 0 and input_grid[r][c+2] != 0:
                    if input_grid[r+1][c] == 0 and input_grid[r+1][c+1] == 0 and input_grid[r+1][c+2] == 0:
                        last_color = input_grid[r][c+2]
                        for rr in range(current_row + 1, r):
                            output_grid[rr][0] = current_color
                        current_color = last_color
                        current_row = r
    
    return output_grid
