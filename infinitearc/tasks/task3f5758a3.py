# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 3f5758a3
Difficulty: medium

=== Tags ===
- Periodic tiling
- Associate patterns to colors
- Periodic run length encoding

=== Description ===
The input grid consists of 2D patterns where each row contains a repeating
sequence of color runs (consecutive cells of the same color). The output grid
transforms each cell into a color determined by the length of the horizontal run
that includes it in the input row. For instance, a run of three consecutive red
cells in the input corresponds to a single consistent output color (e.g., blue)
for all three cells in the output, while a run of two consecutive green cells
maps to a different output color (e.g., yellow). The mapping between run lengths
and output colors is fixed and consistent across the entire grid, preserving the
periodic structure of the input's run-length patterns. The task requires
identifying the run-length-to-color association through visual pattern
recognition rather than numerical computation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import random_color, grid

def generate():
    a = random.randint(1, 5)
    b = random.randint(1, 5)
    sum_run = a + b
    k = random.randint(1, 30 // sum_run)
    width = sum_run * k
    height = random.randint(1, 30)
    
    c1 = random_color(exclude=[0])
    c2 = random_color(exclude=[c1, 0])
    
    input_grid = []
    for _ in range(height):
        row = []
        for _ in range(k):
            row.extend([c1] * a)
            row.extend([c2] * b)
        input_grid.append(row)
    
    used_colors = {c1, c2}
    available_colors = sorted(set(range(10)) - used_colors)
    o1, o2 = available_colors[0], available_colors[1]
    
    run_lengths = sorted([a, b])
    min_run, max_run = run_lengths[0], run_lengths[1]
    
    # Determine color mapping based on original run lengths
    color_a = o1 if a == min_run else o2
    color_b = o1 if b == min_run else o2
    
    output_grid = []
    for _ in range(height):
        row = []
        for _ in range(k):
            row.extend([color_a] * a)
            row.extend([color_b] * b)
        output_grid.append(row)
    
    return {
        'input': input_grid,
        'output': output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Find all run lengths and their input colors
    run_lengths = {}
    for row in input_grid:
        i = 0
        while i < len(row):
            j = i
            while j < len(row) and row[j] == row[i]:
                j += 1
            run_len = j - i
            color = row[i]
            if run_len not in run_lengths:
                run_lengths[run_len] = color
            i = j
    
    # Sort run lengths
    sorted_runs = sorted(run_lengths.keys())
    
    # Determine output color mapping
    input_colors = set(run_lengths.values())
    available_colors = sorted(set(range(10)) - input_colors)
    o1, o2 = available_colors[0], available_colors[1]
    
    # Create mapping from run length to output color
    run_to_color = {}
    for i, r in enumerate(sorted_runs):
        run_to_color[r] = available_colors[i]
    
    # Generate output grid
    output_grid = []
    for row in input_grid:
        output_row = []
        i = 0
        while i < len(row):
            j = i
            while j < len(row) and row[j] == row[i]:
                j += 1
            run_len = j - i
            output_row.extend([run_to_color[run_len]] * (j - i))
            i = j
        output_grid.append(output_row)
    
    return output_grid
