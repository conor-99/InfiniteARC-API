# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: eb197e58
Difficulty: very hard

=== Tags ===
- Color signal exchange
- Draw x on largest object
- Image filling

=== Description ===
Input grids consist of a background color (0) with multiple connected regions of
non-zero colors (1â€“9), each region being a maximal edge-connected component of
identical color. The largest region is determined by the number of cells it
contains; in case of ties, the region with the highest color value is selected.
Adjacent regions (sharing an edge, not diagonally) to this largest region
undergo color signal exchange, where their color is replaced with the largest
region's color. The largest region itself remains unchanged. On the largest
region, a cross pattern ("X") is drawn using color 9, centered at the region's
centroid (computed as the average row and column of all its cells, rounded to
the nearest integer). The cross comprises all cells within the largest region
that lie in the centroid's row or column. Background cells (0) remain unchanged,
while all other non-background regions retain their original colors post-
exchange. The output grid reflects these transformations without overlapping
patterns or additional modifications.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random, math, common

def generate():
    # produce a grid with several non-zero connected regions of unique colors (1-8)
    # We try a few times to build a valid grid; if unsuccessful, fall back to a simple handcrafted example.
    for _ in range(30):  # attempts to create a valid random grid
        width = random.randint(10, 20)
        height = random.randint(10, 20)
        grid = common.grid(width, height, 0)
        regions = []
        colors = list(range(1, 9))  # reserve color 9 exclusively for the cross
        random.shuffle(colors)
        num_regions = random.randint(3, 6)
        occupied = 0
        for _r in range(num_regions):
            if not colors:
                break
            color = colors.pop()
            placed = False
            # Try to place this region several times with different sizes/boxes/shifts
            for attempt in range(120):
                remaining_cells = width * height - occupied
                if remaining_cells < 3:
                    break
                max_size = min(remaining_cells, 40)
                size = random.randint(3, max(3, max_size))
                # choose bounding box dimensions for the contiguous creature
                box_w = random.randint(1, min(size, width))
                box_h = random.randint(1, min(size, height))
                # ensure the box can contain the creature
                if box_w * box_h < size:
                    box_h = min(height, (size + box_w - 1) // box_w)
                    if box_w * box_h < size:
                        box_w = min(width, (size + box_h - 1) // box_h)
                        if box_w * box_h < size:
                            continue
                # Generate a contiguous creature (list of (r,c) within a box of size box_h x box_w)
                shape_pixels = common.continuous_creature(size, box_w, box_h)
                # compute shape dimensions
                max_r = max(p[0] for p in shape_pixels)
                max_c = max(p[1] for p in shape_pixels)
                shape_h = max_r + 1
                shape_w = max_c + 1
                if shape_h > height or shape_w > width:
                    continue
                max_shift_r = height - shape_h
                max_shift_c = width - shape_w
                # try several shifts to avoid overlaps with already placed regions
                for _shift_attempt in range(12):
                    shift_r = random.randint(0, max_shift_r)
                    shift_c = random.randint(0, max_shift_c)
                    shifted_pixels = [(r + shift_r, c + shift_c) for r, c in shape_pixels]
                    if all(grid[r][c] == 0 for r, c in shifted_pixels):
                        # place region
                        for r, c in shifted_pixels:
                            grid[r][c] = color
                        regions.append({"color": color, "pixels": shifted_pixels})
                        occupied += len(shifted_pixels)
                        placed = True
                        break
                if placed:
                    break
            # end attempts for this region
        # If we managed to place at least two regions, build the output according to rules
        if len(regions) >= 2:
            input_grid = [row[:] for row in grid]
            # find largest region by size, tiebreaker by larger color value
            largest_region = None
            largest_size = -1
            largest_color = -1
            for reg in regions:
                sz = len(reg["pixels"]) if isinstance(reg["pixels"], list) else 0
                col = reg["color"]
                if sz > largest_size or (sz == largest_size and col > largest_color):
                    largest_size = sz
                    largest_color = col
                    largest_region = reg
            # adjacency: regions that share an edge with the largest region
            color_to_idx = {reg["color"]: idx for idx, reg in enumerate(regions)}
            adjacent_indices = set()
            for r, c in largest_region["pixels"]:
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width:
                        val = grid[nr][nc]
                        if val != 0 and val != largest_color:
                            idx = color_to_idx.get(val)
                            if idx is not None:
                                adjacent_indices.add(idx)
            # construct output grid
            output_grid = [row[:] for row in input_grid]
            # recolor adjacent regions to the largest region's color
            for idx in adjacent_indices:
                for r, c in regions[idx]["pixels"]:
                    output_grid[r][c] = largest_color
            # compute centroid (average row and col) and round half-up
            r_sum = sum(r for r, c in largest_region["pixels"])
            c_sum = sum(c for r, c in largest_region["pixels"])
            n = len(largest_region["pixels"])
            centroid_r = int(r_sum / n + 0.5)
            centroid_c = int(c_sum / n + 0.5)
            # draw the cross (cells of the largest region that lie on centroid row or column) with color 9
            for r, c in largest_region["pixels"]:
                if r == centroid_r or c == centroid_c:
                    output_grid[r][c] = 9
            # ensure the input and output differ
            if input_grid != output_grid:
                return {"input": input_grid, "output": output_grid}
        # otherwise try a new random configuration
    # Fallback deterministic example if random construction failed after several tries
    width, height = 10, 10
    grid = common.grid(width, height, 0)
    regions = []
    reg1 = [(2, 2), (2, 3), (3, 2)]
    reg2 = [(2, 4), (3, 4)]
    for r, c in reg1:
        grid[r][c] = 1
    for r, c in reg2:
        grid[r][c] = 2
    input_grid = [row[:] for row in grid]
    output_grid = [row[:] for row in input_grid]
    for r, c in reg2:
        output_grid[r][c] = 1
    centroid_r, centroid_c = 2, 2
    for r, c in reg1:
        if r == centroid_r or c == centroid_c:
            output_grid[r][c] = 9
    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # convert input to a mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0
    # find all connected components of identical non-zero color (4-connected)
    visited = [[False] * width for _ in range(height)]
    components = []  # list of (color, pixels)
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and not visited[r][c]:
                color = grid[r][c]
                stack = [(r, c)]
                visited[r][c] = True
                pixels = []
                while stack:
                    cr, cc = stack.pop()
                    pixels.append((cr, cc))
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append((color, pixels))
    if not components:
        return grid
    # select the largest component (tiebreaker: higher color value)
    largest_idx = None
    largest_size = -1
    largest_color = -1
    for idx, (color, pixels) in enumerate(components):
        sz = len(pixels)
        if sz > largest_size or (sz == largest_size and color > largest_color):
            largest_size = sz
            largest_color = color
            largest_idx = idx
    # map each pixel to its component index for quick lookup
    pixel_to_idx = {}
    for idx, (_color, pixels) in enumerate(components):
        for p in pixels:
            pixel_to_idx[p] = idx
    # find components that are edge-adjacent to the largest component
    largest_pixels = components[largest_idx][1]
    largest_color = components[largest_idx][0]
    adjacent = set()
    for r, c in largest_pixels:
        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width:
                if grid[nr][nc] != 0:
                    idx = pixel_to_idx.get((nr, nc))
                    if idx is not None and idx != largest_idx:
                        adjacent.add(idx)
    # construct the output grid
    out = [row[:] for row in grid]
    # recolor adjacent components to the largest color
    for idx in adjacent:
        for r, c in components[idx][1]:
            out[r][c] = largest_color
    # compute centroid (average row and column) and round half-up
    r_sum = sum(r for r, c in largest_pixels)
    c_sum = sum(c for r, c in largest_pixels)
    n = len(largest_pixels)
    centroid_r = int(r_sum / n + 0.5)
    centroid_c = int(c_sum / n + 0.5)
    # draw X (cross) on largest region: cells within the region lying on centroid row or column set to 9
    for r, c in largest_pixels:
        if r == centroid_r or c == centroid_c:
            out[r][c] = 9
    return out

