# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 15d34170
Difficulty: insane

=== Tags ===
- Invariant feature learning

=== Description ===
Each input grid contains multiple disconnected regions (4-connected components)
of non-zero values. The output grid is formed by retaining only the largest such
region (by cell count), with all other cells set to 0. In cases where multiple
regions share the maximum size, the region with the topmost and leftmost cell is
selected. The transformation ensures the output grid differs from the input by
removing all smaller components and preserving only the dominant structural
feature, which remains invariant under translation and rotation of the component
itself.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = [[0] * width for _ in range(height)]
    
    color1 = random.randint(1, 9)
    color2 = random.randint(1, 9)
    while color2 == color1:
        color2 = random.randint(1, 9)
    
    # Ensure regions are disconnected
    while True:
        a = random.randint(2, 5)
        b = random.randint(2, 5)
        c_size = random.randint(2, 5)
        d_size = random.randint(2, 5)
        if a + c_size < height and b + d_size < width:
            break
    
    for r in range(a):
        for c in range(b):
            input_grid[r][c] = color1
    
    start_r = height - c_size
    start_c = width - d_size
    for r in range(start_r, height):
        for c in range(start_c, width):
            input_grid[r][c] = color2
    
    size1 = a * b
    size2 = c_size * d_size
    if size1 >= size2:
        output_grid = [[0] * width for _ in range(height)]
        for r in range(a):
            for c in range(b):
                output_grid[r][c] = color1
    else:
        output_grid = [[0] * width for _ in range(height)]
        for r in range(start_r, height):
            for c in range(start_c, width):
                output_grid[r][c] = color2
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    visited = [[False] * width for _ in range(height)]
    components = []  # (size, min_row, min_col, pixels)
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                queue = [(r, c)]
                visited[r][c] = True
                pixels = []
                while queue:
                    cr, cc = queue.pop(0)
                    pixels.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0 and not visited[nr][nc]:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                size = len(pixels)
                min_row = min(p[0] for p in pixels)
                min_col = min(p[1] for p in pixels)
                components.append((size, min_row, min_col, pixels))
    
    components.sort(key=lambda x: (-x[0], x[1], x[2]))
    largest_pixels = components[0][3]
    
    output_grid = [[0] * width for _ in range(height)]
    for r, c in largest_pixels:
        output_grid[r][c] = input_grid[r][c]
    
    return output_grid
