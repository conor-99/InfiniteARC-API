# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: fd26df5c
Difficulty: hard

=== Tags ===
- Rule gate simulation
- Tunnel connection

=== Description ===
Input grids feature a background color (0), with multiple disjoint tunnel
segments (color 1) and gate cells (colors 2-5). Each gate cell's color encodes a
directional rule: color 2 (red) requires horizontal connection (left-right),
color 3 (blue) requires vertical connection (top-bottom), color 4 (green)
requires horizontal connection (right-left), and color 5 (yellow) requires
vertical connection (bottom-top). Gate cells are positioned such that tunnel
segments approach from the direction specified by their color (e.g., a red gate
cell is flanked by tunnel segments to its left and right). The output grid
connects all tunnel segments through the gate cells by converting each gate cell
to color 1, creating a continuous tunnel path that follows the gate rules. The
background and non-gate, non-tunnel cells remain unchanged. No two tunnels
intersect, and all connections are valid per gate rules. The task requires
identifying each gate's rule, verifying segment alignment, and extending tunnels
through the gates to form a single connected path.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    input_grid = grid(width, height, 0)
    
    path = [(0, 0)]
    current = (0, 0)
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    current_dir = (0, 1)
    
    for _ in range(15):
        if random.random() > 0.4:
            dr, dc = current_dir
        else:
            idx = directions.index(current_dir)
            new_dir = random.choice(directions[:idx] + directions[idx+1:])
            dr, dc = new_dir
            current_dir = new_dir
        new_r = current[0] + dr
        new_c = current[1] + dc
        if 0 <= new_r < height and 0 <= new_c < width and (new_r, new_c) not in path:
            current = (new_r, new_c)
            path.append(current)
    
    for r, c in path:
        input_grid[r][c] = 1
    
    straight_segments = []
    if len(path) > 2:
        current_seg = [path[0]]
        for i in range(1, len(path)-1):
            dr1 = path[i][0] - path[i-1][0]
            dc1 = path[i][1] - path[i-1][1]
            dr2 = path[i+1][0] - path[i][0]
            dc2 = path[i+1][1] - path[i][1]
            if dr1 == dr2 and dc1 == dc2:
                current_seg.append(path[i])
            else:
                if len(current_seg) >= 3:
                    straight_segments.append(current_seg)
                current_seg = [path[i]]
        if len(current_seg) >= 3:
            straight_segments.append(current_seg)
    
    for seg in straight_segments:
        for idx in range(1, len(seg)-1):
            if random.random() > 0.5:
                r, c = seg[idx]
                dr = seg[idx+1][0] - seg[idx][0]
                dc = seg[idx+1][1] - seg[idx][1]
                if dr == 0:
                    gate_color = random.choice([2, 4])
                else:
                    gate_color = random.choice([3, 5])
                input_grid[r][c] = gate_color
    
    # Ensure at least one gate exists
    if not any(input_grid[r][c] in [2, 3, 4, 5] for r in range(height) for c in range(width)):
        if len(path) >= 3:
            idx = random.randint(1, len(path)-2)
            r, c = path[idx]
            dr = path[idx+1][0] - path[idx][0]
            dc = path[idx+1][1] - path[idx][1]
            if dr == 0:
                gate_color = random.choice([2, 4])
            else:
                gate_color = random.choice([3, 5])
            input_grid[r][c] = gate_color
    
    output_grid = [row[:] for row in input_grid]
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] in [2, 3, 4, 5]:
                output_grid[r][c] = 1
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            if grid[r][c] in [2, 3, 4, 5]:
                grid[r][c] = 1
    return tuple(tuple(row) for row in grid)
