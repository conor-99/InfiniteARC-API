# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 3d95be83
Difficulty: mediumâ€“hard

=== Tags ===
- Mirror bounce
- Surface unfolding
- Pathfinding with state

=== Description ===
Input grids depict a 2D representation of a folded paper surface with vertical
and horizontal fold lines (represented by distinct colors, e.g., color 5 for
vertical folds, color 6 for horizontal folds). The grid contains a path (a
sequence of connected cells of a single non-background color) that traverses the
folded surface, bouncing off fold lines according to geometric reflection rules
(vertical folds reverse horizontal movement, horizontal folds reverse vertical
movement). The path may cross multiple fold lines, causing directional changes
at each bounce.   The output grid is the surface in its unfolded state, where
all fold lines are removed (replaced with background color), and the path
continues straight through the former fold lines without bouncing. The path is
extended in its original direction beyond each fold line, maintaining
continuity. Non-fold-line grid elements (background, other colors) remain
unchanged. The transformation requires identifying fold line orientations,
tracking the path's direction through successive bounces, and reconstructing the
path as a continuous straight trajectory in the unfolded geometry. This task
combines mirror bounce physics with surface unfolding logic, demanding
sequential state tracking of path direction and spatial reasoning to resolve the
unfolded path.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

# Generator for ARC task: folded surface path with bounces
# Colors: 0 background, 1 path, 5 vertical fold, 6 horizontal fold, 7 intersection

def generate():
    # Try multiple times to produce a non-trivial path
    for attempt in range(100):
        width = random.randint(10, 20)
        height = random.randint(10, 20)

        # Initialize background
        input_grid = [[0 for _ in range(width)] for _ in range(height)]

        # Place vertical folds (color 5)
        max_v = max(1, min(3, width - 2))
        num_vertical_folds = random.randint(1, max_v)
        vertical_folds = random.sample(list(range(1, width - 1)), num_vertical_folds)
        for col in vertical_folds:
            for r in range(height):
                input_grid[r][col] = 5

        # Place horizontal folds (color 6); mark intersections with 7
        max_h = max(1, min(3, height - 2))
        num_horizontal_folds = random.randint(1, max_h)
        horizontal_folds = random.sample(list(range(1, height - 1)), num_horizontal_folds)
        for row in horizontal_folds:
            for c in range(width):
                if input_grid[row][c] == 5:
                    input_grid[row][c] = 7
                else:
                    input_grid[row][c] = 6

        # Collect non-fold positions as potential starts
        nonfold_positions = [(r, c) for r in range(height) for c in range(width) if input_grid[r][c] == 0]
        if not nonfold_positions:
            continue

        # Pick a random start and initial direction
        start_r, start_c = random.choice(nonfold_positions)
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        initial_dir = random.choice(directions)

        # Build a path that bounces off folds using reflection rules
        path = [(start_r, start_c)]
        current = (start_r, start_c)
        cur_dir = initial_dir
        max_steps = width * height

        for _ in range(max_steps - 1):
            nr = current[0] + cur_dir[0]
            nc = current[1] + cur_dir[1]
            # If next step goes out of bounds -> stop
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                break

            cell = input_grid[nr][nc]
            # If next cell is a fold, reflect direction according to fold orientation
            if cell == 5 or cell == 6 or cell == 7:
                # vertical fold flips horizontal component
                if cell == 5 or cell == 7:
                    cur_dir = (cur_dir[0], -cur_dir[1])
                # horizontal fold flips vertical component
                if cell == 6 or cell == 7:
                    cur_dir = (-cur_dir[0], cur_dir[1])
                nr = current[0] + cur_dir[0]
                nc = current[1] + cur_dir[1]

            # Stop if out of bounds after bounce
            if nr < 0 or nr >= height or nc < 0 or nc >= width:
                break

            # Avoid stepping onto a fold cell
            if input_grid[nr][nc] in (5, 6, 7):
                break

            # Avoid loops
            if (nr, nc) in path:
                break

            current = (nr, nc)
            path.append(current)

        # Reject too short paths to keep task interesting
        if len(path) < 3:
            continue

        # Paint the path (color 1) into the input grid
        for r, c in path:
            input_grid[r][c] = 1

        # Build output grid: remove all folds and draw the unfolded straight path
        output_grid = [row[:] for row in input_grid]
        for r in range(height):
            for c in range(width):
                if output_grid[r][c] in (5, 6, 7):
                    output_grid[r][c] = 0

        # Determine endpoints of the original path (degree 1 cells)
        endpoints = []
        path_set = set(path)
        for (r, c) in path:
            neigh = 0
            for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                rr, cc = r + dr, c + dc
                if (rr, cc) in path_set:
                    neigh += 1
            if neigh <= 1:
                endpoints.append((r, c))

        if not endpoints:
            # Fallback: use first and last
            endpoints = [path[0], path[-1]]

        # Choose the canonical start for unfolding: the top-leftmost endpoint
        start_out = min(endpoints)

        # Find the neighbor along the original path to determine the straight direction
        neighbor = None
        # If start_out coincides with one of the ends of the built path, pick the adjacent element
        if start_out == path[0] and len(path) > 1:
            neighbor = path[1]
        elif start_out == path[-1] and len(path) > 1:
            neighbor = path[-2]
        else:
            for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                rr, cc = start_out[0] + dr, start_out[1] + dc
                if (rr, cc) in path_set:
                    neighbor = (rr, cc)
                    break

        if neighbor is None:
            dir_out = (0, 1)
        else:
            dir_out = (neighbor[0] - start_out[0], neighbor[1] - start_out[1])

        # Draw the straight (unfolded) path of the same length as the original
        for i in range(len(path)):
            rr = start_out[0] + dir_out[0] * i
            cc = start_out[1] + dir_out[1] * i
            if 0 <= rr < height and 0 <= cc < width:
                output_grid[rr][cc] = 1

        return {
            "input": input_grid,
            "output": output_grid
        }

    # As a fallback (very unlikely), return a minimal trivial example
    width, height = 10, 10
    input_grid = [[0 for _ in range(width)] for _ in range(height)]
    for c in range(2, 8):
        input_grid[5][c] = 1
    output_grid = [row[:] for row in input_grid]
    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input (tuple of tuples) to a mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # Collect all path cells (color 1)
    path_cells = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == 1]

    # If there is no path, simply remove fold lines and return
    if not path_cells:
        output = [[0 for _ in range(width)] for _ in range(height)]
        for r in range(height):
            for c in range(width):
                if grid[r][c] not in (5, 6, 7):
                    output[r][c] = grid[r][c]
        return output

    path_set = set(path_cells)

    # Find endpoints (degree <= 1 in the 4-neighborhood)
    endpoints = []
    for (r, c) in path_cells:
        neigh = 0
        for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):
            rr, cc = r + dr, c + dc
            if 0 <= rr < height and 0 <= cc < width and grid[rr][cc] == 1:
                neigh += 1
        if neigh <= 1:
            endpoints.append((r, c))

    if not endpoints:
        # As a fallback, treat the first found path cell as a start
        start = path_cells[0]
    else:
        # Canonical choice: the top-leftmost endpoint (min by row, then col)
        start = min(endpoints)

    # Determine initial straight direction from the chosen start
    neighbor = None
    for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):
        rr, cc = start[0] + dr, start[1] + dc
        if 0 <= rr < height and 0 <= cc < width and grid[rr][cc] == 1:
            neighbor = (rr, cc)
            break

    if neighbor is None:
        initial_dir = (0, 1)
    else:
        initial_dir = (neighbor[0] - start[0], neighbor[1] - start[1])

    path_len = len(path_cells)

    # Build output grid: copy everything except folds (5,6,7 are removed)
    output = [[0 for _ in range(width)] for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if grid[r][c] not in (5, 6, 7):
                output[r][c] = grid[r][c]

    # Draw the straight unfolded path starting at 'start' in 'initial_dir'
    for i in range(path_len):
        rr = start[0] + initial_dir[0] * i
        cc = start[1] + initial_dir[1] * i
        if 0 <= rr < height and 0 <= cc < width:
            output[rr][cc] = 1

    return output

