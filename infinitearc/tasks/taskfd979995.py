# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: fd979995
Difficulty: medium

=== Tags ===
- Maze

=== Description ===
The input grid represents a maze where non-zero values denote path segments and
zero values denote walls. The output grid is generated by iteratively removing
all path cells that are dead ends—cells with exactly one adjacent path cell in
the four cardinal directions (up, down, left, right)—until no dead ends remain.
Each iteration processes all dead ends simultaneously before proceeding to the
next iteration, resulting in a simplified maze structure that maintains only the
main connected path(s) without any terminal branches.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import rand_sprite, grid

def generate():
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    sprite_name = random.choice(['el', 'you', 'aitch'])
    pixels = rand_sprite(sprite_name, width, height)
    input_grid = grid(width, height, 0)
    for r, c in pixels:
        input_grid[r][c] = 1
    output_grid = [row[:] for row in input_grid]
    while True:
        dead_ends = []
        for r in range(height):
            for c in range(width):
                if output_grid[r][c] != 0:
                    count = 0
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < height and 0 <= nc < width and output_grid[nr][nc] != 0:
                            count += 1
                    if count == 1:
                        dead_ends.append((r, c))
        if not dead_ends:
            break
        for r, c in dead_ends:
            output_grid[r][c] = 0
    if input_grid == output_grid:
        return generate()
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    grid = [row[:] for row in input_grid]
    while True:
        dead_ends = []
        rows = len(grid)
        cols = len(grid[0])
        for r in range(rows):
            for c in range(cols):
                if grid[r][c] != 0:
                    count = 0
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] != 0:
                            count += 1
                    if count == 1:
                        dead_ends.append((r, c))
        if not dead_ends:
            break
        for r, c in dead_ends:
            grid[r][c] = 0
    return grid
