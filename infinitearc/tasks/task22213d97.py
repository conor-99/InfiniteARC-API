# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 22213d97
Difficulty: hard

=== Tags ===
- Detect connectedness
- Count ver lines
- Connect the dots

=== Description ===
The input grid features multiple disconnected regions composed of non-zero
cells, where regions are defined by 4-connected adjacency (up, down, left,
right). The task requires detecting all such regions (detect connectedness),
then counting the number of vertical line segments within each region—defined as
consecutive cells in the same column spanning at least three rows. The output
grid is constructed by connecting all disconnected regions with vertical lines;
the number of vertical connections added between each pair of regions equals the
total count of vertical line segments identified across all regions in the
input. This transforms the input’s disconnected structure into a fully connected
grid, where the density of vertical connections precisely matches the cumulative
count of vertical segments detected in the input. The solution demands
recognizing regional boundaries, quantifying vertical features, and applying a
proportional connection rule to achieve a visually coherent output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import rand_sprite, random_color

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = [[0]*width for _ in range(height)]
    
    colors = []
    while len(colors) < 2:
        color = random_color(exclude=[0, 1] + colors)
        colors.append(color)
    
    for color in colors:
        sprite_name = random.choice(["el", "aitch", "you"])
        sprite_pixels = rand_sprite(sprite_name, width=3, height=3)
        r_offset = random.randint(0, height - 3)
        c_offset = random.randint(0, width - 3)
        for r, c in sprite_pixels:
            nr = r + r_offset
            nc = c + c_offset
            if 0 <= nr < height and 0 <= nc < width:
                input_grid[nr][nc] = color
    
    T = 0
    for color in colors:
        for c in range(width):
            r = 0
            while r < height:
                if input_grid[r][c] == color:
                    start = r
                    while r < height and input_grid[r][c] == color:
                        r += 1
                    length = r - start
                    if length >= 3:
                        T += 1
                else:
                    r += 1
    
    output_grid = [row[:] for row in input_grid]
    leftmost = width
    rightmost = -1
    for c in range(width):
        if any(input_grid[r][c] != 0 for r in range(height)):
            leftmost = min(leftmost, c)
            rightmost = max(rightmost, c)
    
    between_cols = [c for c in range(leftmost + 1, rightmost)]
    for i in range(min(T, len(between_cols))):
        col = between_cols[i]
        for r in range(height):
            output_grid[r][col] = 1
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to list of lists to handle tuple inputs
    input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    
    colors = set()
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                colors.add(input_grid[r][c])
    
    T = 0
    for color in colors:
        for c in range(width):
            r = 0
            while r < height:
                if input_grid[r][c] == color:
                    start = r
                    while r < height and input_grid[r][c] == color:
                        r += 1
                    length = r - start
                    if length >= 3:
                        T += 1
                else:
                    r += 1
    
    leftmost = width
    rightmost = -1
    for c in range(width):
        if any(input_grid[r][c] != 0 for r in range(height)):
            leftmost = min(leftmost, c)
            rightmost = max(rightmost, c)
    
    output_grid = [list(row) for row in input_grid]
    between_cols = [c for c in range(leftmost + 1, rightmost)]
    for i in range(min(T, len(between_cols))):
        col = between_cols[i]
        for r in range(height):
            output_grid[r][col] = 1
    
    return output_grid
