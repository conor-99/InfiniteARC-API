# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 60899090
Difficulty: hard

=== Tags ===
- Color stream
- Lattice completion

=== Description ===
The input grid features a background of color 0 with a continuous, spiraling
"color stream" path that starts at the top-left corner and winds inward using a
fixed spiral pattern (right, down, left, up, with decreasing step sizes). This
path consists of connected non-background cells (colors 1-9) containing a
repeating color sequence (e.g., [3,7,2,5,3,7,2,5,...]) that cycles continuously
along the path. Embedded within the grid is a lattice structure defined by the
spiral path's traversal order, where each lattice cell corresponds to a position
in the spiral. The lattice is partially filled with the color sequence along the
stream path, while other lattice cells remain as background (color 0).  The
output grid completes the lattice by filling all background lattice cells with
colors from the stream's sequence, cycling continuously through the sequence in
row-major order. The sequence begins at the first color in the stream path (top-
left), and each subsequent background cell in row-major order (left to right,
top to bottom) receives the next color in the cycle. Cells along the stream path
remain unchanged, and the sequence continues cycling without interruption as it
fills the entire lattice. The lattice structure ensures that the completion
follows a grid-based progression while respecting the spiral's sequence order.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import random_colors
def get_spiral_order_rect(w, h):
    if w == 0 or h == 0:
        return []
    matrix = [[False] * w for _ in range(h)]
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    r, c = 0, 0
    dir_idx = 0
    result = []
    for _ in range(w * h):
        result.append((r, c))
        matrix[r][c] = True
        nr, nc = r + directions[dir_idx][0], c + directions[dir_idx][1]
        if nr < 0 or nr >= h or nc < 0 or nc >= w or matrix[nr][nc]:
            dir_idx = (dir_idx + 1) % 4
            nr, nc = r + directions[dir_idx][0], c + directions[dir_idx][1]
        r, c = nr, nc
    return result
def generate():
    w = random.randint(3, 30)
    h = random.randint(3, 30)
    spiral_order = get_spiral_order_rect(w, h)
    L = random.randint(5, len(spiral_order) - 1)
    spiral_path = spiral_order[:L]
    sequence = random_colors(3, exclude=[0])
    input_grid = [[0] * w for _ in range(h)]
    for i, (r, c) in enumerate(spiral_path):
        input_grid[r][c] = sequence[i % len(sequence)]
    output_grid = [row[:] for row in input_grid]
    current_index = 0
    for r in range(h):
        for c in range(w):
            if output_grid[r][c] == 0:
                output_grid[r][c] = sequence[current_index % len(sequence)]
                current_index += 1
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import random_colors
def get_spiral_order_rect(w, h):
    if w == 0 or h == 0:
        return []
    matrix = [[False] * w for _ in range(h)]
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    r, c = 0, 0
    dir_idx = 0
    result = []
    for _ in range(w * h):
        result.append((r, c))
        matrix[r][c] = True
        nr, nc = r + directions[dir_idx][0], c + directions[dir_idx][1]
        if nr < 0 or nr >= h or nc < 0 or nc >= w or matrix[nr][nc]:
            dir_idx = (dir_idx + 1) % 4
            nr, nc = r + directions[dir_idx][0], c + directions[dir_idx][1]
        r, c = nr, nc
    return result
def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    h = len(input_grid)
    w = len(input_grid[0])
    spiral_order = get_spiral_order_rect(w, h)
    colors = []
    for (r, c) in spiral_order:
        if input_grid[r][c] != 0:
            colors.append(input_grid[r][c])
    sequence = colors[:3]
    output_grid = [row[:] for row in input_grid]
    idx = 0
    for r in range(h):
        for c in range(w):
            if output_grid[r][c] == 0:
                output_grid[r][c] = sequence[idx % len(sequence)]
                idx += 1
    return tuple(tuple(row) for row in output_grid)
