# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: be0b6481
Difficulty: very hard

=== Tags ===
- Impact highlight
- Color particle fall
- Color modulated motion
- Find shape in negative space

=== Description ===
Impact Highlight  Input grids are large (20Ã—20 or larger) with a uniform
background color (0). The top rows contain colored particles (1-9) positioned at
various columns, representing falling entities. The grid also contains obstacles
(non-background colors) that form a structured environment. Each particle falls
according to its color: even-numbered colors (2, 4, 6, 8) move diagonally
downward to the right at a rate of one cell per step, while odd-numbered colors
(1, 3, 5, 7, 9) move diagonally downward to the left at one cell per step.   As
particles fall, they traverse background cells (negative space) until colliding
with an obstacle. Upon collision, the cell of collision is marked with an impact
highlight (color 9), and the particle's path is traced backward through all
background cells it traversed to the collision point. All background cells along
each particle's path are highlighted in the output (color 9). The obstacles,
original particles, and non-background elements remain unchanged.   The hidden
shape to be identified is the contiguous region formed by the union of all
highlighted cells in the negative space (background), which creates a
recognizable geometric pattern (e.g., a circle, square, or triangle) that was
obscured by the background. The output grid must clearly display this shape as a
cohesive highlight region, with no other visual alterations to the input
structure. The transformation requires identifying particle colors, tracing
diagonal paths, determining collision points, and recognizing the emergent shape
in the negative space.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    size = 20
    grid = [[0] * size for _ in range(size)]
    
    num_obstacles = random.randint(10, 20)
    for _ in range(num_obstacles):
        r = random.randint(5, size-1)
        c = random.randint(0, size-1)
        grid[r][c] = random.randint(1, 9)
    
    num_particles = random.randint(3, 5)
    for _ in range(num_particles):
        r = random.randint(0, 4)
        c = random.randint(0, size-1)
        if grid[r][c] == 0:
            grid[r][c] = random.randint(1, 9)
    
    output = [row[:] for row in grid]
    
    for r in range(5):
        for c in range(size):
            color = grid[r][c]
            if color == 0:
                continue
            dr, dc = (1, 1) if color % 2 == 0 else (1, -1)
            nr, nc = r + dr, c + dc
            path_cells = []
            while 0 <= nr < size and 0 <= nc < size:
                if grid[nr][nc] != 0:
                    output[nr][nc] = 9
                    break
                path_cells.append((nr, nc))
                nr += dr
                nc += dc
            for (pr, pc) in path_cells:
                output[pr][pc] = 9
    
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Ensure input is list of lists
    if isinstance(input_grid[0], tuple):
        input_grid = [list(row) for row in input_grid]
    size = len(input_grid)
    output = [row[:] for row in input_grid]
    
    for r in range(5):
        for c in range(size):
            color = input_grid[r][c]
            if color == 0:
                continue
            dr, dc = (1, 1) if color % 2 == 0 else (1, -1)
            nr, nc = r + dr, c + dc
            path_cells = []
            while 0 <= nr < size and 0 <= nc < size:
                if input_grid[nr][nc] != 0:
                    output[nr][nc] = 9
                    break
                path_cells.append((nr, nc))
                nr += dr
                nc += dc
            for (pr, pc) in path_cells:
                output[pr][pc] = 9
    
    return output
