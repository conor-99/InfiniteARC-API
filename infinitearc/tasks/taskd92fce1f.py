# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: d92fce1f
Difficulty: hard

=== Tags ===
- Multi object alignment
- Associate colors to numbers
- Skeletonization
- Image segmentation by property

=== Description ===
The input grid consists of multiple connected regions (objects) each filled with
a distinct non-zero color (0 represents background). The transformation involves
two main steps: first, each region is reduced to its skeletonized form (a
single-pixel-wide medial axis line preserving the object's connectivity), and
second, these skeletons are aligned such that the skeleton corresponding to
color n is positioned in the nth row from the top (row 0 for n=1, row 1 for n=2,
etc.) and centered horizontally within the grid. The output grid retains the
original dimensions, with all other positions set to background (0). This
requires recognizing the color-number association, performing skeletonization,
and aligning based on the numerical value of the color.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(2, 30)
    height = random.randint(2, 30)
    while width * height < 8:
        width = random.randint(2, 30)
        height = random.randint(2, 30)
    n_regions = random.randint(2, min(9, width * height // 4))
    colors = list(range(1, n_regions + 1))
    input_grid = [[0] * width for _ in range(height)]
    occupied = set()
    for color in colors:
        rect_h = random.randint(2, min(5, height))
        rect_w = random.randint(2, min(5, width))
        for _ in range(1000):
            r_start = random.randint(0, height - rect_h)
            c_start = random.randint(0, width - rect_w)
            if not any((r, c) in occupied for r in range(r_start, r_start + rect_h) for c in range(c_start, c_start + rect_w)):
                break
        else:
            # Fallback: place in top-left
            r_start = 0
            c_start = 0
        for r in range(r_start, r_start + rect_h):
            for c in range(c_start, c_start + rect_w):
                input_grid[r][c] = color
                occupied.add((r, c))
    output_grid = [[0] * width for _ in range(height)]
    for color in colors:
        min_r = height
        max_r = -1
        min_c = width
        max_c = -1
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == color:
                    min_r = min(min_r, r)
                    max_r = max(max_r, r)
                    min_c = min(min_c, c)
                    max_c = max(max_c, c)
        width_skeleton = max_c - min_c + 1
        start_col = (width - width_skeleton) // 2
        if color - 1 < height:
            for c in range(start_col, start_col + width_skeleton):
                output_grid[color - 1][c] = color
    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = [[0] * width for _ in range(height)]
    colors = set()
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] > 0:
                colors.add(input_grid[r][c])
    for color in colors:
        min_r = height
        max_r = -1
        min_c = width
        max_c = -1
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == color:
                    min_r = min(min_r, r)
                    max_r = max(max_r, r)
                    min_c = min(min_c, c)
                    max_c = max(max_c, c)
        width_skeleton = max_c - min_c + 1
        start_col = (width - width_skeleton) // 2
        if color - 1 < height:
            for c in range(start_col, start_col + width_skeleton):
                output_grid[color - 1][c] = color
    return output_grid
