# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: f274a655
Difficulty: medium–hard

=== Tags ===
- Multi stage color switch
- Jigsaw

=== Description ===
Input grids consist of multiple scattered rectangular jigsaw pieces (each a
solid color 1-9), separated by background (color 0). Pieces may be rotated in
the input (e.g., a 2×3 piece appears as 3×2), creating non-axis-aligned
arrangements. The output grid assembles these pieces into a single contiguous
rectangular formation (e.g., 3×3 grid of pieces) with all pieces aligned to axis
orientation. Each piece undergoes a two-stage color transformation:    1.
**Stage 1 (Rotation-Dependent):** If a piece was rotated (dimensions swapped in
input), its color advances to the next in sequence (1→2, 2→3, ..., 9→1).
Unrotated pieces retain their original color.   2. **Stage 2 (Position-
Dependent):** After Stage 1, pieces in the top-left quadrant of the output grid
advance color again (1→2, etc.), while pieces in the bottom-right quadrant
retreat (1→9, 2→1, etc.).    The background is set to 0, and all pieces are
repositioned to form the contiguous assembly without overlap. The transformation
requires identifying rotation states, applying sequence-based color shifts, and
mapping positions to quadrant-based adjustments—combining spatial reassembly
with multi-stage color logic.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import math
from common import grid


def generate():
    """Generate a pair of input/output grids for the jigsaw-color-shift task.

    Layout:
      - Fixed assembly of 3x3 pieces (9 pieces). This keeps the factorization stable and
        avoids ties when inferring orientation.
      - Each piece is a solid rectangle of identical intended size (piece_h x piece_w),
        with piece_h != piece_w to ensure rotations are detectable.
      - In the input the pieces are scattered at random non-overlapping positions in a
        30x30 background. A controlled number of pieces (<= floor(N/2)) are rotated so
        that the majority orientation corresponds to the unrotated shape used in output.
      - The output arranges the pieces into a contiguous 3x3 block, axis-aligned.
      - Colors are adjusted in two stages described in the problem statement.
    """
    IN_W, IN_H = 30, 30

    # Fixed assembly dimensions (3x3) => 9 pieces (odd, avoids tie in orientation inference)
    ROWS = COLS = 3
    N = ROWS * COLS

    # Try repeatedly until we successfully place pieces
    tries = 0
    while True:
        tries += 1
        # choose a reasonable piece size so 3x size fits in 30x30
        piece_h = random.randint(1, 6)
        piece_w = random.randint(1, 6)
        # Avoid square pieces so rotation can be detected from bounding boxes
        if piece_h == piece_w:
            continue
        if piece_h * ROWS > IN_H or piece_w * COLS > IN_W:
            # doesn't fit, pick new sizes
            continue

        # Pre-generate colors and a controlled set of rotation flags so the unrotated
        # orientation will be the majority and therefore discoverable by the solver.
        colors = [random.randint(1, 9) for _ in range(N)]
        max_rotated = N // 2  # ensure majority are unrotated
        rotated_count = random.randint(0, max_rotated)
        rotated_flags = [True] * rotated_count + [False] * (N - rotated_count)
        random.shuffle(rotated_flags)

        input_grid = grid(IN_W, IN_H, 0)
        pieces = []  # list of dicts with placement info and original color/rotation

        success = True
        # place N pieces, trying to keep at least a 1-cell background margin between pieces
        for k in range(N):
            color = colors[k]
            rotated = rotated_flags[k]
            # dimensions in the input (swap if rotated)
            h_in = piece_w if rotated else piece_h
            w_in = piece_h if rotated else piece_w

            placed = False
            # First try with a margin of 1 (no touching, including diagonals). If that fails,
            # fall back to margin 0.
            for margin in (1, 0):
                for attempt in range(500):
                    r0 = random.randint(0, IN_H - h_in)
                    c0 = random.randint(0, IN_W - w_in)
                    r_min = max(0, r0 - margin)
                    c_min = max(0, c0 - margin)
                    r_max = min(IN_H, r0 + h_in + margin)
                    c_max = min(IN_W, c0 + w_in + margin)

                    conflict = False
                    for rr in range(r_min, r_max):
                        # early exit inner loop for speed
                        row = input_grid[rr]
                        for cc in range(c_min, c_max):
                            if row[cc] != 0:
                                conflict = True
                                break
                        if conflict:
                            break
                    if conflict:
                        continue

                    # place the piece
                    for rr in range(r0, r0 + h_in):
                        for cc in range(c0, c0 + w_in):
                            input_grid[rr][cc] = color

                    pieces.append({
                        'color': color,
                        'rotated': rotated,
                        'min_r': r0,
                        'min_c': c0,
                        'height': h_in,
                        'width': w_in,
                    })
                    placed = True
                    break
                if placed:
                    break
            if not placed:
                success = False
                break

        if not success:
            # try a different random configuration
            if tries > 50:
                # if too many failures, shrink pieces and try again (but keep non-square constraint)
                piece_h = 1
                piece_w = 2
                # restart placement
            continue

        # Build the output grid: axis-aligned assembly of ROWS x COLS pieces in row-major order.
        out_h = ROWS * piece_h
        out_w = COLS * piece_w
        output_grid = grid(out_w, out_h, 0)

        # Sort pieces by their top-left input position (this defines the mapping to output slots)
        pieces_sorted = sorted(pieces, key=lambda p: (p['min_r'], p['min_c']))

        # Quadrant boundaries (generator and solver use same rules):
        top_rows = ROWS // 2
        left_cols = COLS // 2
        bottom_start = (ROWS + 1) // 2
        right_start = (COLS + 1) // 2

        for idx, p in enumerate(pieces_sorted):
            i = idx // COLS
            j = idx % COLS
            col = p['color']

            # Stage 1: rotation-dependent advance
            if p['rotated']:
                col = (col % 9) + 1

            # Stage 2: quadrant-dependent adjustment
            if i < top_rows and j < left_cols:
                col = (col % 9) + 1
            elif i >= bottom_start and j >= right_start:
                col = (col - 2) % 9 + 1

            r0 = i * piece_h
            c0 = j * piece_w
            for rr in range(r0, r0 + piece_h):
                for cc in range(c0, c0 + piece_w):
                    output_grid[rr][cc] = col

        # Ensure input and output are not identical (very unlikely but check).
        if input_grid == output_grid:
            # Slightly perturb by regenerating
            continue

        return {
            'input': input_grid,
            'output': output_grid,
        }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import Counter
import math


def p(input_grid):
    """Solve the transformation described in the task.

    Steps performed by the solver (matching the generator):
      1. Find all non-zero connected components (4-connected) -> each is a rectangular piece.
      2. From the bounding boxes infer the intended piece size (unordered) by mode of sorted dims.
      3. Decide which of the two values is height vs width by checking which orientation occurs more
         often (ties broken deterministically).
      4. Sort pieces by their top-left input coordinate and place them row-major into a square
         assembly (sqrt(N) x sqrt(N)), axis-aligned, applying the two-stage color changes.
    """
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0]) if H > 0 else 0

    visited = [[False] * W for _ in range(H)]
    components = []

    # 4-connected flood-fill to collect components
    for r in range(H):
        for c in range(W):
            if grid[r][c] == 0 or visited[r][c]:
                continue
            color = grid[r][c]
            # BFS
            stack = [(r, c)]
            visited[r][c] = True
            pixels = []
            while stack:
                cr, cc = stack.pop()
                pixels.append((cr, cc))
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc] and grid[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))

            min_r = min(p[0] for p in pixels)
            max_r = max(p[0] for p in pixels)
            min_c = min(p[1] for p in pixels)
            max_c = max(p[1] for p in pixels)
            height = max_r - min_r + 1
            width = max_c - min_c + 1
            components.append({
                'color': color,
                'min_r': min_r,
                'min_c': min_c,
                'height': height,
                'width': width,
            })

    if not components:
        return [[0]]

    # Sort by top-left position (this defines mapping to output slots)
    components.sort(key=lambda p: (p['min_r'], p['min_c']))

    N = len(components)
    # assume square assembly (generator uses 3x3), so rows = cols = sqrt(N)
    rows = int(math.isqrt(N))
    cols = rows
    if rows * cols != N:
        # fallback: try to find factors (prefer square-like shapes)
        best = (1, N)
        for r in range(1, N + 1):
            if N % r == 0:
                c = N // r
                if abs(r - c) < abs(best[0] - best[1]):
                    best = (r, c)
        rows, cols = best

    # Infer intended (unordered) piece dims by mode over sorted dims
    sorted_dims = [tuple(sorted((p['height'], p['width']))) for p in components]
    dim_counts = Counter(sorted_dims)
    intended_sorted, _ = dim_counts.most_common(1)[0]
    small, big = intended_sorted

    # Decide orientation (which value is height) by which orientation occurs more often
    count_orientation_normal = sum(1 for p in components if (p['height'], p['width']) == (small, big))
    count_orientation_swapped = sum(1 for p in components if (p['height'], p['width']) == (big, small))
    if count_orientation_normal >= count_orientation_swapped:
        intended_h, intended_w = small, big
    else:
        intended_h, intended_w = big, small

    out_h = rows * intended_h
    out_w = cols * intended_w
    output = [[0] * out_w for _ in range(out_h)]

    top_rows = rows // 2
    left_cols = cols // 2
    bottom_start = (rows + 1) // 2
    right_start = (cols + 1) // 2

    for idx, p in enumerate(components):
        i = idx // cols
        j = idx % cols
        color = p['color']

        # Stage 1: rotation-dependent advance (rotated if bounding box != intended orientation)
        rotated = not (p['height'] == intended_h and p['width'] == intended_w)
        if rotated:
            color = (color % 9) + 1

        # Stage 2: quadrant-dependent adjustment
        if i < top_rows and j < left_cols:
            color = (color % 9) + 1
        elif i >= bottom_start and j >= right_start:
            color = (color - 2) % 9 + 1

        # Place the piece axis-aligned
        r0 = i * intended_h
        c0 = j * intended_w
        for rr in range(r0, r0 + intended_h):
            for cc in range(c0, c0 + intended_w):
                output[rr][cc] = color

    return output

