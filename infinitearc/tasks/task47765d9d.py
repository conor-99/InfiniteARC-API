# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 47765d9d
Difficulty: very hard

=== Tags ===
- Staircase construction
- Rule composition
- Refraction simulation
- Adaptive behavior switch
- Pattern repetition
- Normalize orientation

=== Description ===
Adaptive Refractive Staircase  Input grids are 20×20 with background color 0.
The grid contains multiple horizontal paths (each path is a contiguous sequence
of cells with the same color, 1–9) starting from the left edge. Scattered
throughout are refractor cells (color 5) that alter the path's direction. The
direction of refraction (left or right turn) is determined by the color of the
cell immediately above the refractor: red (color 2) causes a left turn, blue
(color 3) causes a right turn. If no cell is above, the default is a left turn.
The grid also contains orientation markers (color 8) placed near the top-left
corner, indicating the desired staircase orientation. The output grid must:  1.
Normalize the orientation by rotating the grid so that all paths align with the
orientation marker (e.g., if the marker points right, paths are horizontal; if
it points up, paths are vertical).  2. Apply refraction: Each path bends at
refractor cells according to the above rule.  3. Construct a staircase by
repeating the refraction pattern. After each refraction, the path continues for
3 cells (pattern repetition), forming a step. The staircase is built by stacking
these steps vertically, with each step's height matching the number of cells the
path travels after refraction.  4. Ensure that the staircase is continuous and
all steps align with the orientation markers.  The output grid retains all
background cells (color 0), refractor cells (color 5), and orientation markers
(color 8), while the paths are redrawn to form the staircase structure. The
staircase must maintain consistent step height and width, with no overlapping or
misaligned steps.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Generator for Adaptive Refractive Staircase (20x20)
# Produces an input grid with several horizontal paths starting at the left edge,
# refractor cells (5) that change direction based on the color above them (2 => left, 3 => right),
# and an orientation marker (8) placed near the top-left corner.
# The output grid is the normalized (rotated if necessary) grid with paths redrawn into
# staircases: each refractor causes a vertical step of height 3 (up for left, down for right),
# and horizontal segments are drawn between refractors. Refractors (5) and the orientation marker (8)
# are preserved in output; all other non-path colors are not preserved.


def rotate_cw(g):
    h = len(g)
    w = len(g[0])
    ng = [[0] * h for _ in range(w)]
    for r in range(h):
        for c in range(w):
            ng[c][h - 1 - r] = g[r][c]
    return ng


def generate():
    size = 20
    input_grid = grid(size, size, 0)

    # Orientation marker near top-left: (0,0) => horizontal, (0,1) => vertical
    orientation = random.choice(['horizontal', 'vertical'])
    if orientation == 'horizontal':
        input_grid[0][0] = 8
    else:
        input_grid[0][1] = 8

    # Choose number of horizontal paths. Ensure rows are spaced to avoid overlapping vertical steps.
    n_paths = random.randint(3, 5)
    candidate_rows = list(range(3, size - 3))  # allow at least 3 cells above/below for steps
    random.shuffle(candidate_rows)
    rows = []
    for r in candidate_rows:
        if all(abs(r - other) >= 4 for other in rows):
            rows.append(r)
            if len(rows) == n_paths:
                break
    if len(rows) < n_paths:
        n_paths = len(rows)

    # Build paths starting from left edge
    path_specs = []
    for r in rows:
        # pick a path color (avoid 5 and 8). Also avoid using 2 or 3 as path color to keep them
        # available for refractor-above indicators.
        color = random.choice([1, 4, 6, 7, 9])
        length = random.randint(8, 13)  # contiguous length from left edge
        for c in range(length):
            input_grid[r][c] = color

        # Place at least one refractor per path (so output will differ) and up to 4.
        max_refr = max(1, min(4, max(1, length - 3)))
        k = random.randint(1, max_refr)
        refr_cols = sorted(random.sample(range(2, length - 1), k))
        for fc in refr_cols:
            # Choose what is directly above the refractor: 2 (left), 3 (right), or 0 (background)
            above_choice = random.choice([2, 3, 0])
            input_grid[r - 1][fc] = above_choice
            input_grid[r][fc] = 5  # refractor

        path_specs.append({'row': r, 'color': color, 'length': length, 'refractors': refr_cols})

    # Build the output by normalizing orientation and drawing the staircase pattern
    if orientation == 'vertical':
        norm_in = rotate_cw(input_grid)
    else:
        norm_in = [row[:] for row in input_grid]

    # Create empty normalized output, copy refractors (5) and markers (8)
    norm_out = grid(size, size, 0)
    for r in range(size):
        for c in range(size):
            if norm_in[r][c] == 5 or norm_in[r][c] == 8:
                norm_out[r][c] = norm_in[r][c]

    # Draw staircases: for each path that starts at left edge (col 0), simulate refractions
    STEP = 3
    for r in range(size):
        start_val = norm_in[r][0]
        if start_val == 0 or start_val == 5 or start_val == 8:
            continue
        path_color = start_val
        # compute contiguous original path length
        L = 0
        while L < size and norm_in[r][L] != 0:
            L += 1
        # refractors on that original row
        refrs = [c for c in range(1, L) if norm_in[r][c] == 5]

        cur_r = r
        cur_c = 0
        for fr in refrs:
            # draw horizontal segment from cur_c to fr-1 at cur_r
            for c in range(cur_c, fr):
                if norm_out[cur_r][c] == 0:
                    norm_out[cur_r][c] = path_color
            # determine turn: if the cell above the refractor is color 3 => right (down), else left (up)
            if cur_r - 1 >= 0 and norm_in[cur_r - 1][fr] == 3:
                dr = 1
            else:
                dr = -1
            # draw the vertical step of height STEP (clamped to grid bounds)
            for s in range(1, STEP + 1):
                nr = cur_r + dr * s
                if nr < 0 or nr >= size:
                    break
                if norm_out[nr][fr] == 0:
                    norm_out[nr][fr] = path_color
            # move the drawing head to the end of the vertical step and to the next column
            cur_r = max(0, min(size - 1, cur_r + dr * STEP))
            cur_c = fr + 1
        # finish the final horizontal segment until the end of the original path
        for c in range(cur_c, L):
            if norm_out[cur_r][c] == 0:
                norm_out[cur_r][c] = path_color

    # Final output is the normalized output (rotated if orientation == vertical)
    output_grid = norm_out

    return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable list-of-lists
    grid_in = [list(row) for row in input_grid]
    size = len(grid_in)

    def rotate_cw(g):
        h = len(g)
        w = len(g[0])
        ng = [[0] * h for _ in range(w)]
        for r in range(h):
            for c in range(w):
                ng[c][h - 1 - r] = g[r][c]
        return ng

    # Find the orientation marker (8) near the top-left corner; generator places it at (0,0) or (0,1)
    marker_pos = None
    for r in range(min(3, size)):
        for c in range(min(3, size)):
            if grid_in[r][c] == 8:
                marker_pos = (r, c)
                break
        if marker_pos:
            break
    if marker_pos is None:
        # Fallback: search entire grid
        for r in range(size):
            for c in range(size):
                if grid_in[r][c] == 8:
                    marker_pos = (r, c)
                    break
            if marker_pos:
                break

    # Determine orientation: generator uses (0,0) => horizontal, (0,1) => vertical
    if marker_pos == (0, 1):
        orientation = 'vertical'
    else:
        orientation = 'horizontal'

    # Normalize orientation by rotating the grid if necessary
    if orientation == 'vertical':
        norm_in = rotate_cw(grid_in)
    else:
        norm_in = [row[:] for row in grid_in]

    # Build the normalized output following the same staircase construction as generator
    norm_out = [[0] * size for _ in range(size)]
    # copy refractors and markers
    for r in range(size):
        for c in range(size):
            if norm_in[r][c] == 5 or norm_in[r][c] == 8:
                norm_out[r][c] = norm_in[r][c]

    STEP = 3
    for r in range(size):
        start_val = norm_in[r][0]
        if start_val == 0 or start_val == 5 or start_val == 8:
            continue
        path_color = start_val
        # find contiguous original path length
        L = 0
        while L < size and norm_in[r][L] != 0:
            L += 1
        refrs = [c for c in range(1, L) if norm_in[r][c] == 5]

        cur_r = r
        cur_c = 0
        for fr in refrs:
            # horizontal segment
            for c in range(cur_c, fr):
                if norm_out[cur_r][c] == 0:
                    norm_out[cur_r][c] = path_color
            # determine turn direction
            if cur_r - 1 >= 0 and norm_in[cur_r - 1][fr] == 3:
                dr = 1
            else:
                dr = -1
            # draw vertical step
            for s in range(1, STEP + 1):
                nr = cur_r + dr * s
                if nr < 0 or nr >= size:
                    break
                if norm_out[nr][fr] == 0:
                    norm_out[nr][fr] = path_color
            cur_r = max(0, min(size - 1, cur_r + dr * STEP))
            cur_c = fr + 1
        # finish final horizontal
        for c in range(cur_c, L):
            if norm_out[cur_r][c] == 0:
                norm_out[cur_r][c] = path_color

    return tuple(tuple(row) for row in norm_out)

