# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: eeb67f8c
Difficulty: insane

=== Tags ===
- Elastic reflection

=== Description ===
Elastic Path Reflections  Input grids feature a maze-like structure of walls
(non-background colors) within a larger grid. A starting source cell is located
on the left edge, with a color matching the first element of a top-left pattern
strip. The pattern strip consists of a sequence of 2x2 blocks (e.g., [1,2,3,4])
that defines a cyclic color sequence for the path. The grid contains irregular
wall shapes that form enclosed corridors, with at least one clear path from the
source to the grid boundaries. Walls are colored with distinct values (1-9) that
determine reflection behavior.  The path originates from the source cell, moving
east. Each cell traversed by the path is colored according to the current
position in the cyclic pattern strip. Upon encountering a wall cell (non-zero
color), the direction changes based on the wall's color value modulo 4: - Color
mod 4 = 1: Turn 90° clockwise (east → south) - Color mod 4 = 2: Turn 90°
counterclockwise (east → north) - Color mod 4 = 3: Turn 180° (east → west) -
Color mod 4 = 0: Continue straight (east → east)  The path color cycles through
the pattern strip sequence with each new cell traversed. The path continues
until it exits the grid (reaches any edge), with all wall structures, pattern
strip, and source remaining unchanged in the output. The output grid displays
the complete path with colors following the cyclic sequence, while non-traversed
background cells remain unchanged. This requires simultaneous tracking of path
direction, color sequence, and wall-based reflection rules across multiple
reflections, with the reflection behavior dynamically determined by the wall's
color value.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_colors

def generate():
    """Generate a grid pair (input, output) following the elastic reflection rules.

    The generator builds a self-avoiding path starting at the left edge whose
    direction changes are produced by placing colored wall cells immediately
    ahead of the walker when a turn is required. Pattern (2x2 blocks) is placed
    at the top-left. Walls (the reflectors) are placed where needed. The
    output is produced by simulating the same reflection rules on the input
    grid to ensure consistency with the solver.
    """
    # Helper: simulate the path on an input grid and produce an output grid
    def simulate_reflections(ingrid):
        g = [row[:] for row in ingrid]
        h = len(g)
        w = len(g[0])
        # detect the 2x2 pattern strip in the top-left
        pattern_local = []
        for c in range(0, w, 2):
            if c + 1 < w:
                color = g[0][c]
                if color != 0 and g[0][c + 1] == color and g[1][c] == color and g[1][c + 1] == color:
                    pattern_local.append(color)
                else:
                    break
        if not pattern_local:
            # fallback (shouldn't happen because generator places the pattern)
            pattern_local = [1, 2, 3, 4]
        pat_len_local = len(pattern_local)
        # find source on left edge (prefer not in top 2 rows)
        source_row_local = None
        candidates_local = [r for r in range(h) if g[r][0] == pattern_local[0]]
        for r in candidates_local:
            if r > 1:
                source_row_local = r
                break
        if source_row_local is None:
            if candidates_local:
                source_row_local = candidates_local[0]
            else:
                for r in range(h):
                    if g[r][0] != 0:
                        source_row_local = r
                        break
                if source_row_local is None:
                    source_row_local = 0
        outg = [row[:] for row in g]
        directions_local = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # E, S, W, N
        dir_idx_local = 0
        r, c = source_row_local, 0
        color_index_local = 0
        safety = 0
        while True:
            safety += 1
            if safety > h * w * 10:
                break
            dr, dc = directions_local[dir_idx_local]
            nr, nc = r + dr, c + dc
            if not (0 <= nr < h and 0 <= nc < w):
                break
            if g[nr][nc] == 0:
                color_index_local += 1
                outg[nr][nc] = pattern_local[color_index_local % pat_len_local]
                r, c = nr, nc
            else:
                mod = g[nr][nc] % 4
                if mod == 0:
                    pass
                elif mod == 1:
                    dir_idx_local = (dir_idx_local + 1) % 4
                elif mod == 2:
                    dir_idx_local = (dir_idx_local - 1) % 4
                else:
                    dir_idx_local = (dir_idx_local + 2) % 4
        return outg

    # Try multiple times to build a valid puzzle
    for attempt in range(500):
        size = random.randint(15, 22)
        h = size
        w = size
        ingrid = grid(w, h, 0)
        # pattern of 3 or 4 2x2 blocks
        pat_len = random.choice([3, 4])
        pattern = random_colors(pat_len, exclude=[0])
        # place top-left pattern (2x2 blocks)
        for i, color in enumerate(pattern):
            for r in range(2):
                for c in range(2 * i, 2 * i + 2):
                    if c < w:
                        ingrid[r][c] = color
        if h < 5:
            continue
        # place source on left edge (not in pattern rows)
        src_row = random.randint(2, h - 3)
        ingrid[src_row][0] = pattern[0]

        # directions in clockwise order
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

        # attempt to build a self-avoiding path
        for inner in range(200):
            path = [(src_row, 0)]
            visited = set(path)
            reserved_walls = {}  # pos -> (before_idx, after_idx)
            dir_idx = 0
            steps_target = random.randint(8, max(8, (w + h) // 2))
            success = False

            for _ in range(steps_target):
                r, c = path[-1]
                candidates = []
                for move_idx, (dr, dc) in enumerate(directions):
                    nr, nc = r + dr, c + dc
                    if not (0 <= nr < h and 0 <= nc < w):
                        continue
                    if (nr, nc) in visited:
                        continue
                    # avoid stepping into pattern area
                    if nr <= 1 and nc < 2 * pat_len:
                        continue
                    if (nr, nc) in reserved_walls:
                        continue
                    if move_idx == dir_idx:
                        candidates.append((nr, nc, move_idx))
                    else:
                        ahead_r = r + directions[dir_idx][0]
                        ahead_c = c + directions[dir_idx][1]
                        if not (0 <= ahead_r < h and 0 <= ahead_c < w):
                            continue
                        if (ahead_r, ahead_c) in visited:
                            continue
                        if ahead_r <= 1 and ahead_c < 2 * pat_len:
                            continue
                        if (ahead_r, ahead_c) in reserved_walls:
                            prev_before, prev_after = reserved_walls[(ahead_r, ahead_c)]
                            if prev_before != dir_idx or prev_after != move_idx:
                                continue
                        candidates.append((nr, nc, move_idx))
                if not candidates:
                    break
                nr, nc, move_idx = random.choice(candidates)
                if move_idx != dir_idx:
                    ahead = (r + directions[dir_idx][0], c + directions[dir_idx][1])
                    reserved_walls[ahead] = (dir_idx, move_idx)
                path.append((nr, nc))
                visited.add((nr, nc))
                dir_idx = move_idx
                next_r = path[-1][0] + directions[dir_idx][0]
                next_c = path[-1][1] + directions[dir_idx][1]
                if not (0 <= next_r < h and 0 <= next_c < w):
                    success = True
                    break

            if success and len(path) >= 5:
                # place reserved walls into the input grid
                ingrid2 = [row[:] for row in ingrid]
                conflict = False
                for pos, (before_idx, after_idx) in reserved_walls.items():
                    pr, pc = pos
                    if ingrid2[pr][pc] != 0:
                        conflict = True
                        break
                    if after_idx == before_idx:
                        required_mod = 0
                    elif after_idx == (before_idx + 1) % 4:
                        required_mod = 1
                    elif after_idx == (before_idx - 1) % 4:
                        required_mod = 2
                    else:
                        required_mod = 3
                    candidates = [c for c in range(1, 10) if c % 4 == required_mod]
                    color = random.choice(candidates)
                    ingrid2[pr][pc] = color
                if conflict:
                    continue

                # produce the output by simulating reflections on this input
                out = simulate_reflections(ingrid2)
                if out != ingrid2:
                    return {'input': ingrid2, 'output': out}
                # else try again
    raise Exception('Failed to generate a valid grid')



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])
    # detect the 2x2 pattern strip in the top-left
    pattern = []
    for c in range(0, w, 2):
        if c + 1 < w:
            color = grid[0][c]
            if color != 0 and grid[0][c + 1] == color and grid[1][c] == color and grid[1][c + 1] == color:
                pattern.append(color)
            else:
                break
    if not pattern:
        pattern = [1, 2, 3, 4]
    pat_len = len(pattern)
    # find source on the left edge (prefer one not in the top pattern rows)
    source_row = None
    candidates = [r for r in range(h) if grid[r][0] == pattern[0]]
    for r in candidates:
        if r > 1:
            source_row = r
            break
    if source_row is None:
        if candidates:
            source_row = candidates[0]
        else:
            # fallback: first nonzero in left column, else row 0
            for r in range(h):
                if grid[r][0] != 0:
                    source_row = r
                    break
            if source_row is None:
                source_row = 0

    out = [row[:] for row in grid]
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # E, S, W, N
    dir_idx = 0  # start facing east
    r, c = source_row, 0
    color_index = 0  # source cell corresponds to pattern[0]
    steps = 0
    # simulate until path exits the grid
    while True:
        dr, dc = directions[dir_idx]
        nr, nc = r + dr, c + dc
        if not (0 <= nr < h and 0 <= nc < w):
            break
        val = grid[nr][nc]
        if val == 0:
            color_index += 1
            out[nr][nc] = pattern[color_index % pat_len]
            r, c = nr, nc
        else:
            # reflect based on wall color modulo 4
            mod = val % 4
            if mod == 0:
                # continue straight
                pass
            elif mod == 1:
                # turn 90 deg clockwise
                dir_idx = (dir_idx + 1) % 4
            elif mod == 2:
                # turn 90 deg counterclockwise
                dir_idx = (dir_idx - 1) % 4
            else:
                # reverse
                dir_idx = (dir_idx + 2) % 4
        steps += 1
        if steps > h * w * 10:
            # safety break to avoid infinite loops on malformed inputs
            break
    return tuple(tuple(row) for row in out)

