# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 717eee11
Difficulty: hard

=== Tags ===
- Meta rule switching
- Connect all dots of same color
- Take minimum

=== Description ===
Input grids contain multiple colors (0-9) with each color appearing in at least
two non-adjacent cells, surrounded by background color (0). The task requires
connecting all cells of each color into a single connected region using only
background cells, adhering to three key rules:  1. **Meta Rule Switching**: The
connection direction (axis-aligned or diagonal) is determined by the parity of
the total distinct colors in the input. If the count is even, connections must
use only horizontal/vertical paths; if odd, connections must use diagonal paths
(45Â°).  2. **Connect All Dots of Same Color**: For each color, all its cells
must form one connected region. Paths must traverse background cells (0) without
overlapping existing colored cells or paths of other colors.  3. **Take
Minimum**: The solution must use the absolute minimal number of background cells
to connect all instances of each color, forming a spanning tree under the
direction rule.  The output grid retains all original colored cells and
background, with connecting paths drawn in a distinct color (e.g., color 5).
Paths must not intersect, must follow the global direction rule based on color
count parity, and must minimize the number of cells used per color. The task is
hard due to the need for global meta-rule recognition, minimal path computation
under direction constraints, and precise non-overlapping path construction
across multiple colors.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    # Grid size
    width = 20
    height = 20
    grid = common.grid(width, height, 0)
    path_color = 5

    # Colors available for seeds (do not include path_color)
    colors_pool = [1, 2, 3, 4, 6, 7, 8, 9]

    # Number of distinct colors (2..6)
    n = random.randint(2, 6)
    color_list = random.sample(colors_pool, n)
    parity = n % 2

    occupied = set()  # set of cells already occupied by colored seeds

    def is_adjacent_to_occupied(r, c):
        # Check 8-neighborhood
        for dr in (-1, 0, 1):
            for dc in (-1, 0, 1):
                if dr == 0 and dc == 0:
                    continue
                if (r + dr, c + dc) in occupied:
                    return True
        return False

    if parity == 0:
        # Place each color on its own horizontal row, spaced out to avoid touching
        possible_rows = list(range(1, height - 1))
        random.shuffle(possible_rows)
        rows = []
        for r in possible_rows:
            if all(abs(r - rr) >= 3 for rr in rows):
                rows.append(r)
                if len(rows) == n:
                    break
        # If we couldn't find well-spaced rows (should be rare), just sample distinct rows
        if len(rows) < n:
            rows = random.sample(range(0, height), n)

        for color, r in zip(color_list, rows):
            # Choose between 2 and 4 seed points for this color
            k = random.randint(2, 4)
            # Candidate columns that are not adjacent to already placed seeds
            candidate_cols = [c for c in range(1, width - 1) if not is_adjacent_to_occupied(r, c)]
            random.shuffle(candidate_cols)
            cols = []
            for c in candidate_cols:
                if len(cols) >= k:
                    break
                # keep at least one empty cell between same-color seeds
                if any(abs(c - pc) <= 1 for pc in cols):
                    continue
                cols.append(c)
            # If not enough chosen, fall back to scanning the row deterministically
            if len(cols) < 2:
                cols = []
                for c in range(1, width - 1):
                    if not is_adjacent_to_occupied(r, c) and all(abs(c - pc) >= 2 for pc in cols):
                        cols.append(c)
                    if len(cols) >= 2:
                        break
            # Final fallback (very unlikely) ensure we have two positions
            if len(cols) < 2:
                # pick two positions that are guaranteed valid
                cols = [1, min( width-2, 3 )]
            for c in cols:
                grid[r][c] = color
                occupied.add((r, c))

    else:
        # Parity odd: use diagonal lines r - c = k (parallel diagonals) and space them
        ks = []
        # k ranges from -(width-1) to height-1 inclusive
        for k in range(-(width - 1), height):
            # compute diagonal length
            length = 0
            for r in range(height):
                c = r - k
                if 0 <= c < width:
                    length += 1
            if length >= 3:
                ks.append(k)
        random.shuffle(ks)
        chosen_ks = []
        for k in ks:
            # require diagonals to be separated by at least 2 to avoid adjacency across diagonals
            if all(abs(k - kk) >= 2 for kk in chosen_ks):
                chosen_ks.append(k)
                if len(chosen_ks) >= n:
                    break
        if len(chosen_ks) < n:
            chosen_ks = ks[:n]

        for color, k in zip(color_list, chosen_ks):
            # candidate r positions along this diagonal that are not adjacent to occupied cells
            candidate_rs = []
            for r in range(0, height):
                c = r - k
                if 0 <= c < width and not is_adjacent_to_occupied(r, c):
                    candidate_rs.append(r)
            random.shuffle(candidate_rs)
            m = random.randint(2, 4)
            rs = []
            for r in candidate_rs:
                if len(rs) >= m:
                    break
                if any(abs(r - rr) <= 1 for rr in rs):
                    continue
                rs.append(r)
            if len(rs) < 2:
                rs = []
                for r in range(0, height):
                    c = r - k
                    if 0 <= c < width and not is_adjacent_to_occupied(r, c) and all(abs(r - rr) >= 2 for rr in rs):
                        rs.append(r)
                    if len(rs) >= 2:
                        break
            if len(rs) < 2:
                # final fallback: pick any two positions on diagonal
                rs = []
                for r in range(0, height):
                    c = r - k
                    if 0 <= c < width:
                        rs.append(r)
                    if len(rs) >= 2:
                        break
            for r in rs:
                c = r - k
                grid[r][c] = color
                occupied.add((r, c))

    # Build the output by drawing minimal connecting paths using only background cells (0)
    output = [row[:] for row in grid]
    for color in color_list:
        cells = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == color]
        if not cells:
            continue
        if parity == 0:
            rows_set = set(r for r, c in cells)
            cols_set = set(c for r, c in cells)
            if len(rows_set) == 1:
                r = cells[0][0]
                min_c = min(c for r, c in cells)
                max_c = max(c for r, c in cells)
                for c in range(min_c + 1, max_c):
                    if output[r][c] == 0:
                        output[r][c] = path_color
            elif len(cols_set) == 1:
                c = cells[0][1]
                min_r = min(r for r, c in cells)
                max_r = max(r for r, c in cells)
                for r in range(min_r + 1, max_r):
                    if output[r][c] == 0:
                        output[r][c] = path_color
            else:
                # Fallback: connect seeds in a minimal axis-aligned manner between consecutive seeds
                cells_sorted = sorted(cells, key=lambda x: (x[1], x[0]))
                for i in range(1, len(cells_sorted)):
                    r1, c1 = cells_sorted[i - 1]
                    r2, c2 = cells_sorted[i]
                    if r1 == r2:
                        for c in range(min(c1, c2) + 1, max(c1, c2)):
                            if output[r1][c] == 0:
                                output[r1][c] = path_color
                    elif c1 == c2:
                        for r in range(min(r1, r2) + 1, max(r1, r2)):
                            if output[r][c1] == 0:
                                output[r][c1] = path_color
                    else:
                        corner = (r1, c2)
                        if 0 <= corner[0] < height and 0 <= corner[1] < width and output[corner[0]][corner[1]] == 0:
                            for c in range(min(c1, c2) + 1, max(c1, c2)):
                                if output[r1][c] == 0:
                                    output[r1][c] = path_color
                            for r in range(min(r1, r2) + 1, max(r1, r2)):
                                if output[r][c2] == 0:
                                    output[r][c2] = path_color
                        else:
                            for r in range(min(r1, r2) + 1, max(r1, r2)):
                                if output[r][c1] == 0:
                                    output[r][c1] = path_color
                            for c in range(min(c1, c2) + 1, max(c1, c2)):
                                if output[r2][c] == 0:
                                    output[r2][c] = path_color
        else:
            # Diagonal connections: prefer r - c constant; fallback to r + c
            k1 = cells[0][0] - cells[0][1]
            if all(r - c == k1 for r, c in cells):
                min_r = min(r for r, c in cells)
                max_r = max(r for r, c in cells)
                for r in range(min_r + 1, max_r):
                    c = r - k1
                    if output[r][c] == 0:
                        output[r][c] = path_color
            else:
                k2 = cells[0][0] + cells[0][1]
                if all(r + c == k2 for r, c in cells):
                    min_r = min(r for r, c in cells)
                    max_r = max(r for r, c in cells)
                    for r in range(min_r + 1, max_r):
                        c = k2 - r
                        if output[r][c] == 0:
                            output[r][c] = path_color
                else:
                    # Fallback: connect consecutive seeds by diagonal steps
                    cells_sorted = sorted(cells)
                    for i in range(1, len(cells_sorted)):
                        r1, c1 = cells_sorted[i - 1]
                        r2, c2 = cells_sorted[i]
                        dr = 1 if r2 > r1 else -1
                        dc = 1 if c2 > c1 else -1
                        r, c = r1, c1
                        while (r, c) != (r2, c2):
                            r += dr
                            c += dc
                            if output[r][c] == 0:
                                output[r][c] = path_color

    return {'input': grid, 'output': output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    colors = set()
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                colors.add(grid[r][c])
    n = len(colors)
    parity = n % 2
    output = [row[:] for row in grid]
    path_color = 5

    for color in colors:
        cells = []
        for r in range(height):
            for c in range(width):
                if grid[r][c] == color:
                    cells.append((r, c))
        if len(cells) < 2:
            continue
        if parity == 0:
            rows_set = set(r for r, c in cells)
            cols_set = set(c for r, c in cells)
            if len(rows_set) == 1:
                r = cells[0][0]
                min_c = min(c for r, c in cells)
                max_c = max(c for r, c in cells)
                for c in range(min_c + 1, max_c):
                    if output[r][c] == 0:
                        output[r][c] = path_color
            elif len(cols_set) == 1:
                c = cells[0][1]
                min_r = min(r for r, c in cells)
                max_r = max(r for r, c in cells)
                for r in range(min_r + 1, max_r):
                    if output[r][c] == 0:
                        output[r][c] = path_color
            else:
                cells_sorted = sorted(cells, key=lambda x: (x[1], x[0]))
                for i in range(1, len(cells_sorted)):
                    r1, c1 = cells_sorted[i - 1]
                    r2, c2 = cells_sorted[i]
                    if r1 == r2:
                        for c in range(min(c1, c2) + 1, max(c1, c2)):
                            if output[r1][c] == 0:
                                output[r1][c] = path_color
                    elif c1 == c2:
                        for r in range(min(r1, r2) + 1, max(r1, r2)):
                            if output[r][c1] == 0:
                                output[r][c1] = path_color
                    else:
                        corner = (r1, c2)
                        if 0 <= corner[0] < height and 0 <= corner[1] < width and output[corner[0]][corner[1]] == 0:
                            for c in range(min(c1, c2) + 1, max(c1, c2)):
                                if output[r1][c] == 0:
                                    output[r1][c] = path_color
                            for r in range(min(r1, r2) + 1, max(r1, r2)):
                                if output[r][c2] == 0:
                                    output[r][c2] = path_color
                        else:
                            for r in range(min(r1, r2) + 1, max(r1, r2)):
                                if output[r][c1] == 0:
                                    output[r][c1] = path_color
                            for c in range(min(c1, c2) + 1, max(c1, c2)):
                                if output[r2][c] == 0:
                                    output[r2][c] = path_color
        else:
            k1 = cells[0][0] - cells[0][1]
            if all(r - c == k1 for r, c in cells):
                min_r = min(r for r, c in cells)
                max_r = max(r for r, c in cells)
                for r in range(min_r + 1, max_r):
                    c = r - k1
                    if output[r][c] == 0:
                        output[r][c] = path_color
            else:
                k2 = cells[0][0] + cells[0][1]
                if all(r + c == k2 for r, c in cells):
                    min_r = min(r for r, c in cells)
                    max_r = max(r for r, c in cells)
                    for r in range(min_r + 1, max_r):
                        c = k2 - r
                        if output[r][c] == 0:
                            output[r][c] = path_color
                else:
                    cells_sorted = sorted(cells)
                    for i in range(1, len(cells_sorted)):
                        r1, c1 = cells_sorted[i - 1]
                        r2, c2 = cells_sorted[i]
                        dr = 1 if r2 > r1 else -1
                        dc = 1 if c2 > c1 else -1
                        r, c = r1, c1
                        while (r, c) != (r2, c2):
                            r += dr
                            c += dc
                            if 0 <= r < height and 0 <= c < width and output[r][c] == 0:
                                output[r][c] = path_color
    return output

