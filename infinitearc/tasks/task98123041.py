# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 98123041
Difficulty: very hard

=== Tags ===
- Local convolution rule
- Paint on collision
- Color modulated logic
- Associate colors to ranks

=== Description ===
Input grids feature diverse colors (0-9) on a background of color 0. Each cell
in the output grid is determined by the highest-ranked color among its
orthogonally adjacent non-background neighbors. The rank of each color is fixed
but hidden, requiring the solver to deduce the order through pattern recognition
across multiple examples. For cells with multiple neighbors of equal rank (which
should be avoided in examples), the output color is the first encountered in a
consistent order (e.g., top-left to bottom-right). Background cells (color 0)
are ignored in neighbor evaluation. The output grid must differ from the input,
ensuring every cell has at least one non-background neighbor to influence its
color. The transformation relies on associative color ranking inferred from
input-output pairs, where collisions between non-background colors trigger a
paint operation that propagates the dominant rank through adjacent cells.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_color

def generate():
    width = random.randint(2, 30)
    height = random.randint(2, 30)
    rank_order = [5, 3, 8, 1, 7, 2, 9, 4, 6]
    
    # Create input grid with non-zero background
    input_grid = grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            input_grid[r][c] = random_color(exclude=[0])

    # Randomly set 10% to background (0)
    num_zeros = int(width * height * 0.1)
    for _ in range(num_zeros):
        r, c = random.randint(0, height-1), random.randint(0, width-1)
        input_grid[r][c] = 0

    # Ensure all 0s have non-zero neighbors
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0:
                has_neighbor = False
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0:
                        has_neighbor = True
                        break
                if not has_neighbor:
                    input_grid[r][c] = random_color(exclude=[0])

    # Generate output
    output_grid = grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            neighbors = set()
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0:
                    neighbors.add(input_grid[nr][nc])
            if neighbors:
                for color in rank_order:
                    if color in neighbors:
                        output_grid[r][c] = color
                        break

    # Ensure output differs from input
    if input_grid == output_grid:
        return generate()
    
    return {
        'input': input_grid,
        'output': output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input tuple of tuples to list of lists
    grid = [list(row) for row in input_grid]
    width = len(grid[0])
    height = len(grid)
    rank_order = [5, 3, 8, 1, 7, 2, 9, 4, 6]
    
    output = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            neighbors = set()
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] != 0:
                    neighbors.add(grid[nr][nc])
            if neighbors:
                for color in rank_order:
                    if color in neighbors:
                        output[r][c] = color
                        break
    return output
