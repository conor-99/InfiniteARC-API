# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 17633171
Difficulty: medium–hard

=== Tags ===
- Progressive rule shift
- Diagonals
- Pattern repetition with offset
- Multi step traversal

=== Description ===
Input grids feature a background color (0) with a continuous diagonal path of
color 1 extending from the bottom-left to top-right corner, interrupted by a
single cell of color 2 (the "anchor point") at a random position along the path.
The output grid transforms this by extending the diagonal pattern beyond the
anchor point through a multi-step traversal. Each subsequent diagonal segment is
shifted by one cell horizontally relative to the previous segment (left for odd
steps, right for even steps), while the segment's color cycles through a
repeating sequence (e.g., 1 → 3 → 5 → 1 → ...) starting from the anchor point.
The transformation requires recognizing the initial diagonal direction, the
anchor point's role as a traversal starting point, the color cycle pattern, and
the progressive horizontal offset rule. Diagonal segments must not overlap with
existing elements (only background cells are modified), and the process
terminates when segments exit the grid boundaries. The output grid maintains all
original elements except for the newly generated diagonal segments, which form a
visually distinct, offset pattern with consistent color progression.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    size = common.randint(10, 30)
    input_grid = common.grid(size, size, 0)
    for c in range(size):
        r = size - 1 - c
        if r >= 0:
            input_grid[r][c] = 1
    k = common.randint(1, size-2)
    r_anchor = size - 1 - k
    c_anchor = k
    input_grid[r_anchor][c_anchor] = 2
    output_grid = [row[:] for row in input_grid]
    color_cycle = [1, 3, 5]
    step = 1
    while True:
        if step % 2 == 1:
            shift = (step + 1) // 2
            start_r = r_anchor - shift
            start_c = c_anchor
        else:
            shift = step // 2
            start_r = r_anchor
            start_c = c_anchor + shift
        if start_r < 0 or start_c >= size:
            break
        color = color_cycle[(step - 1) % 3]
        r, c = start_r, start_c
        while r >= 0 and c < size and input_grid[r][c] == 0:
            output_grid[r][c] = color
            r -= 1
            c += 1
        step += 1
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    size = len(input_grid)
    anchor = None
    for r in range(size):
        for c in range(size):
            if input_grid[r][c] == 2:
                anchor = (r, c)
                break
        if anchor:
            break
    if not anchor:
        return input_grid
    r_anchor, c_anchor = anchor
    output_grid = [list(row) for row in input_grid]
    color_cycle = [1, 3, 5]
    step = 1
    while True:
        if step % 2 == 1:
            shift = (step + 1) // 2
            start_r = r_anchor - shift
            start_c = c_anchor
        else:
            shift = step // 2
            start_r = r_anchor
            start_c = c_anchor + shift
        if start_r < 0 or start_c >= size:
            break
        color = color_cycle[(step - 1) % 3]
        r, c = start_r, start_c
        while r >= 0 and c < size and input_grid[r][c] == 0:
            output_grid[r][c] = color
            r -= 1
            c += 1
        step += 1
    return output_grid
