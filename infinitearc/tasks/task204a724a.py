# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 204a724a
Difficulty: insane

=== Tags ===
- Bidirectional reasoning

=== Description ===
The task involves transforming an input grid where each distinct color
represents a connected shape. For each shape, if it is not connected to the
grid's boundary (i.e., no pixel of the shape touches the top, bottom, left, or
right edge of the grid), the shape is rotated 180 degrees (each pixel (r, c)
moves to (H-1 - r, W-1 - c)). Shapes connected to the boundary remain unchanged.
The output grid reflects these rotations for inner shapes while preserving
boundary-connected shapes. The complexity arises from identifying connected
components and their boundary connections, requiring multi-step visual reasoning
to determine which shapes undergo rotation and how their positions transform
relative to the grid's center. This bidirectional operation—combining horizontal
and vertical reflection through 180-degree rotation—demands precise abstraction
of spatial relationships across multiple layers of visual structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    from common import grid, continuous_creature
    W = random.randint(3, 30)
    H = random.randint(3, 30)
    while (W-2) * (H-2) < 2:
        W = random.randint(3, 30)
        H = random.randint(3, 30)
    input_grid = grid(W, H, 0)
    colors = random.sample(range(1, 10), 3)
    for c in range(3):
        input_grid[0][c] = colors[0]
    inner_size = random.randint(2, 5)
    inner_pixels = continuous_creature(inner_size, W-2, H-2)
    for (r, c) in inner_pixels:
        input_grid[r+1][c+1] = colors[1]
    for r in range(3):
        input_grid[r][W-1] = colors[2]
    output_grid = [row[:] for row in input_grid]
    all_colors = set()
    for r in range(H):
        for c in range(W):
            if input_grid[r][c] != 0:
                all_colors.add(input_grid[r][c])
    for color in all_colors:
        pixels = []
        for r in range(H):
            for c in range(W):
                if input_grid[r][c] == color:
                    pixels.append((r, c))
        on_boundary = any(r == 0 or r == H-1 or c == 0 or c == W-1 for (r, c) in pixels)
        if not on_boundary:
            rotated = [(H-1 - r, W-1 - c) for (r, c) in pixels]
            for (r, c) in pixels:
                output_grid[r][c] = 0
            for (r, c) in rotated:
                output_grid[r][c] = color
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    H = len(input_grid)
    W = len(input_grid[0])
    output = [row[:] for row in input_grid]
    colors = set()
    for r in range(H):
        for c in range(W):
            if input_grid[r][c] != 0:
                colors.add(input_grid[r][c])
    for color in colors:
        pixels = [(r, c) for r in range(H) for c in range(W) if input_grid[r][c] == color]
        if any(r == 0 or r == H-1 or c == 0 or c == W-1 for (r, c) in pixels):
            continue
        rotated = [(H-1 - r, W-1 - c) for (r, c) in pixels]
        for (r, c) in pixels:
            output[r][c] = 0
        for (r, c) in rotated:
            output[r][c] = color
    return output
