# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 8084e7cd
Difficulty: medium

=== Tags ===
- Measure distance from side
- Close line gaps
- Infer step size

=== Description ===
The task involves transforming input grids containing horizontal lines
(sequences of the same color in a row) into output grids where gaps in these
lines are closed by filling cells at positions determined by the line's distance
from the top edge. For each row containing a horizontal line, the distance from
the top edge (row index) is used to calculate a step size (row index + 1). The
output grid fills the line with its color at positions 0, step size, 2Ã—step
size, and so on, while leaving other cells empty. For example, a line in row 2
(distance 2 from top) has a step size of 3, so its color appears at columns 0,
3, 6, etc. This requires measuring distance from the side (top), closing gaps
via the inferred step size, and applying the rule consistently across all lines.
The transformation is visual, relying on spatial relationships rather than
numerical values, and avoids pixel matching or memorization.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_color
def generate():
    width = random.randint(2, 30)
    height = random.randint(2, 30)
    input_grid = grid(width, height, 0)
    output_grid = grid(width, height, 0)
    lines_added = False
    for i in range(height):
        if random.random() < 0.5:
            step_size = i + 1
            step_positions = [j for j in range(width) if j % step_size == 0]
            if len(step_positions) > 1:
                color = random_color(exclude=[0])
                subset_size = random.randint(1, len(step_positions) - 1)
                subset = random.sample(step_positions, subset_size)
                for j in subset:
                    input_grid[i][j] = color
                for j in step_positions:
                    output_grid[i][j] = color
                lines_added = True
    if not lines_added:
        for i in range(height):
            step_size = i + 1
            step_positions = [j for j in range(width) if j % step_size == 0]
            if len(step_positions) > 1:
                color = random_color(exclude=[0])
                subset_size = random.randint(1, len(step_positions) - 1)
                subset = random.sample(step_positions, subset_size)
                for j in subset:
                    input_grid[i][j] = color
                for j in step_positions:
                    output_grid[i][j] = color
                break
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid
def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output = grid(width, height, 0)
    for i in range(height):
        color = 0
        for j in range(width):
            if input_grid[i][j] != 0:
                color = input_grid[i][j]
                break
        if color == 0:
            continue
        step = i + 1
        for j in range(width):
            if j % step == 0:
                output[i][j] = color
    return output
