# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 4a3c15fd
Difficulty: hard

=== Tags ===
- Example condition induction
- Refraction simulation
- Route switching
- Deterministic reflection
- Snap to grid

=== Description ===
The input grid features a continuous path starting from the left edge, moving
horizontally to the right, composed of a single distinct color. Scattered
throughout the grid are prism cells, each marked with a unique color from a
palette of eight hues (excluding the path color and background). Each prism
color encodes a deterministic direction change: upon contact, the path
instantaneously alters its movement vector according to a fixed, color-specific
rule. The path continues in its new direction until it exits the grid boundary.
Output grids depict the complete trajectory of the path after all direction
changes, with prisms remaining visually unchanged. The transformation requires
the solver to induce the prism color-to-direction mapping through example pairs,
as the rules are not directly derivable from color names or numerical values but
are consistent across all prism instances. Path segments must align strictly to
grid lines (no diagonal movement), and no cell is traversed more than once. The
path exits the grid without looping or overlapping, with the final output
reflecting all sequential direction changes triggered by prisms.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, internal_colors

def generate():
    # Choose grid size
    width = random.randint(7, 20)
    height = random.randint(7, 20)

    # Choose background and path colors, but ensure there remains at least one candidate
    # for each remainder mod 4 so we can always pick prism colors that map to each direction.
    def pick_bg_and_path():
        for _ in range(100):
            bg = random.choice(internal_colors)
            path_color = random.choice([c for c in internal_colors if c != bg])
            allowed = [c for c in internal_colors if c not in (bg, path_color)]
            # ensure there's at least one candidate for each remainder 0..3
            if all(any((c % 4) == rem for c in allowed) for rem in range(4)):
                return bg, path_color
        # Fallback (should rarely happen)
        bg = random.choice(internal_colors)
        path_color = random.choice([c for c in internal_colors if c != bg])
        return bg, path_color

    bg, path_color = pick_bg_and_path()

    # Available colors for prisms
    allowed_prism_colors = [c for c in internal_colors if c not in (bg, path_color)]

    # Maximum number of east segments (must leave space for at least one column to the right)
    max_T = min(4, max(1, width - 2), 1 + len(allowed_prism_colors) // 2)
    T = random.randint(2, max_T) if max_T >= 2 else 1

    # Choose cut points for east segments (positions where an east segment ends)
    if T > 1:
        cut_choices = list(range(1, width - 1))
        cuts = sorted(random.sample(cut_choices, T - 1))
    else:
        cuts = []
    end_cols = cuts + [width - 1]

    # Choose a safe start row (avoid extreme edges to give room for vertical moves)
    if height >= 5:
        start_row = random.randint(1, height - 2)
    else:
        start_row = 0

    # We'll build the full path (the hidden true trajectory) and also record prism positions
    full_path = []
    prism_positions = []  # list of tuples ((r,c), new_direction_after_touch)

    r = start_row
    c = 0
    full_path.append((r, c))

    for idx, target_col in enumerate(end_cols):
        # move east until target_col
        while c < target_col:
            c += 1
            full_path.append((r, c))
        # If this is the last east segment, the path will continue east out of the grid and stop
        if target_col == width - 1:
            break
        # At the end of this east segment the path will hit a prism and change to vertical
        # choose whether to go North or South
        vertical_dir = random.choice(['N', 'S'])
        prism_positions.append(((r, c), vertical_dir))

        # choose a new row to travel to (must be different from current r)
        if vertical_dir == 'N':
            # ensure there's space above
            new_r = random.randint(0, r - 1) if r - 1 >= 0 else r
            step_range = range(r - 1, new_r - 1, -1) if new_r < r else []
        else:
            # S
            new_r = random.randint(r + 1, height - 1) if r + 1 <= height - 1 else r
            step_range = range(r + 1, new_r + 1) if new_r > r else []
        for nr in step_range:
            full_path.append((nr, c))
        # at the end of vertical travel the path will hit another prism to change back to East
        r = new_r
        prism_positions.append(((r, c), 'E'))
        # continue with next east segment

    # Now we have full_path and prism_positions (ordered along the path). Place prism colors.
    input_grid = grid(width, height, bg)

    # For input, show only the initial contiguous horizontal run starting at the left edge
    # up to (but not including) the first prism encountered along the path.
    # Find first prism column along full_path (the first prism position we recorded)
    if prism_positions:
        first_prism_col = prism_positions[0][0][1]
    else:
        first_prism_col = width  # no prism

    # paint the visible input starting path (from col 0 up to col first_prism_col - 1)
    # find the start row and paint horizontally
    in_start_row = start_row
    last_visible_col = max(0, first_prism_col - 1)
    for cc in range(0, last_visible_col + 1):
        input_grid[in_start_row][cc] = path_color

    # Assign colors to prism positions. Colors are chosen so that their numeric value modulo 4
    # deterministically encodes a direction: 0->N, 1->E, 2->S, 3->W. This makes the mapping
    # recoverable by the solver from the input colors alone.
    dir_to_rem = {'N': 0, 'E': 1, 'S': 2, 'W': 3}

    # We allow reuse of prism colors if there are more prism positions than available distinct
    # candidate colors for a particular remainder.
    for pos, desired_dir in prism_positions:
        rpos, cpos = pos
        rem = dir_to_rem[desired_dir]
        candidates = [c for c in allowed_prism_colors if c % 4 == rem]
        if not candidates:
            # fallback: use any allowed color (should be rare due to pick_bg_and_path)
            candidates = list(allowed_prism_colors)
        chosen = random.choice(candidates)
        input_grid[rpos][cpos] = chosen

    # Build output grid: full path cells become path_color except prism cells remain their color
    output_grid = grid(width, height, bg)
    prism_cells = set(pos for pos, _ in prism_positions)
    for (rpos, cpos) in full_path:
        if (rpos, cpos) in prism_cells:
            # keep prism color from input
            output_grid[rpos][cpos] = input_grid[rpos][cpos]
        else:
            output_grid[rpos][cpos] = path_color

    return {
        'input': input_grid,
        'output': output_grid
    }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert tuple-of-tuples to list-of-lists if necessary
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0]) if height > 0 else 0

    from collections import Counter
    all_vals = [v for row in grid_in for v in row]
    # background is the most common value
    bg = Counter(all_vals).most_common(1)[0][0]

    # Find path start: a non-bg pixel on the left edge
    start_row = None
    path_color = None
    for r in range(height):
        if grid_in[r][0] != bg:
            start_row = r
            path_color = grid_in[r][0]
            break
    # If not found on left edge, try to find the most common non-bg color that forms a horizontal run
    if start_row is None:
        # fallback: find any color that appears in a horizontal line from left side
        for r in range(height):
            for c in range(width):
                if grid_in[r][c] != bg:
                    start_row = r
                    path_color = grid_in[r][c]
                    break
            if start_row is not None:
                break
    if start_row is None:
        # nothing to do
        return [[bg for _ in range(width)] for _ in range(height)]

    # Identify prism colors (colors that are not bg and not path_color)
    prism_colors = set()
    for r in range(height):
        for c in range(width):
            val = grid_in[r][c]
            if val != bg and val != path_color:
                prism_colors.add(val)

    # Determine mapping from prism color to direction using color modulo 4 rule (deterministic)
    rem_to_dir = {0: 'N', 1: 'E', 2: 'S', 3: 'W'}
    direction_map = {color: rem_to_dir[color % 4] for color in prism_colors}

    # Simulate the path starting at the left edge and moving east initially
    out = [[bg for _ in range(width)] for _ in range(height)]

    r, c = start_row, 0
    direction = 'E'
    visited = set()

    while 0 <= r < height and 0 <= c < width:
        val = grid_in[r][c]
        # If this is a prism cell, update direction first (the prism affects upon contact)
        if val in direction_map:
            direction = direction_map[val]
        # Paint the cell: prism cells remain their color, other path cells become path_color
        if val in prism_colors:
            out[r][c] = val
        else:
            out[r][c] = path_color
        visited.add((r, c))

        # step to next cell
        dr, dc = 0, 0
        if direction == 'N':
            dr = -1
        elif direction == 'S':
            dr = 1
        elif direction == 'E':
            dc = 1
        elif direction == 'W':
            dc = -1
        nr, nc = r + dr, c + dc
        if not (0 <= nr < height and 0 <= nc < width):
            break
        if (nr, nc) in visited:
            # guard against accidental loops
            break
        r, c = nr, nc

    return out

