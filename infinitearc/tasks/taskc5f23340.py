# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: c5f23340
Difficulty: hard

=== Tags ===
- Gravity
- Phase transition path
- Layered occlusion unfolding
- Progressive rule shift

=== Description ===
Input grids consist of a background color (0) overlaid with multiple contiguous,
non-overlapping colored regions (1-9), each representing a distinct layer. The
topmost layer's color is visible at all points where layers overlap, creating a
layered occlusion. A phase transition path begins at the top-left corner (0,0)
and proceeds through the grid. At each step, the current cell's color determines
the direction of gravity (1=down, 2=right, 3=up, 4=left), but the direction
shifts progressively: step 0 uses (color mod 4), step 1 uses ((color + 1) mod
4), step 2 uses ((color + 2) mod 4), and so on. The path moves orthogonally in
the current gravity direction to the next cell, continuing until it exits the
grid. As the path progresses, each visited cell's layer (all contiguous cells of
that color) shifts in the current gravity direction until it hits a boundary or
non-background cell. This shifting reveals underlying layers (occlusion
unfolding) without overlapping other layers. The output grid displays all
shifted layers, the path drawn in a distinct color (9), and the original
background. The progressive rule shift ensures the direction changes
incrementally with each step, creating a complex sequence of layer transitions.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, continuous_creature

def generate():
    width = random.randint(15, 25)
    height = random.randint(15, 25)
    input_grid = grid(width, height, 0)

    start_color = random.randint(1, 9)
    input_grid[0][0] = start_color
    
    size = random.randint(5, 15)
    pixels = continuous_creature(size, width, height)
    for (r, c) in pixels:
        if 0 <= r < height and 0 <= c < width:
            input_grid[r][c] = start_color

    other_colors = [c for c in range(1, 10) if c != start_color]
    random.shuffle(other_colors)
    for color in other_colors[:3]:
        r0 = random.randint(5, height-5)
        c0 = random.randint(5, width-5)
        size = random.randint(3, 8)
        pixels = continuous_creature(size, width, height)
        for (r, c) in pixels:
            nr, nc = r0 + r, c0 + c
            if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 0:
                input_grid[nr][nc] = color

    path = []
    visited = set()
    r, c = 0, 0
    step = 0
    directions = [(1,0), (0,1), (-1,0), (0,-1)]
    while 0 <= r < height and 0 <= c < width and (r, c) not in visited:
        visited.add((r, c))
        path.append((r, c))
        color_val = input_grid[r][c]
        d = (color_val + step) % 4
        dr, dc = directions[d]
        r += dr
        c += dc
        step += 1

    output_grid = [row[:] for row in input_grid]

    for i, (r, c) in enumerate(path):
        color_val = input_grid[r][c]
        d = (color_val + i) % 4
        dr, dc = directions[d]
        
        cells = []
        for r2 in range(height):
            for c2 in range(width):
                if output_grid[r2][c2] == color_val:
                    cells.append((r2, c2))
        
        while True:
            can_shift = False
            to_shift = []
            for (r2, c2) in cells:
                nr, nc = r2 + dr, c2 + dc
                if 0 <= nr < height and 0 <= nc < width and output_grid[nr][nc] == 0:
                    to_shift.append((r2, c2))
                    can_shift = True
            
            if not can_shift:
                break
            
            for (r2, c2) in to_shift:
                output_grid[r2][c2] = 0
                output_grid[r2 + dr][c2 + dc] = color_val
            
            cells = [(r2 + dr, c2 + dc) for (r2, c2) in to_shift]

    for (r, c) in path:
        output_grid[r][c] = 9

    return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to list of lists if input is a tuple
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    directions = [(1,0), (0,1), (-1,0), (0,-1)]
    
    path = []
    visited = set()
    r, c = 0, 0
    step = 0
    while 0 <= r < height and 0 <= c < width and (r, c) not in visited:
        visited.add((r, c))
        path.append((r, c))
        color_val = input_grid[r][c]
        d = (color_val + step) % 4
        dr, dc = directions[d]
        r += dr
        c += dc
        step += 1

    output_grid = [row[:] for row in input_grid]
    
    for i, (r, c) in enumerate(path):
        color_val = input_grid[r][c]
        d = (color_val + i) % 4
        dr, dc = directions[d]
        
        cells = []
        for r2 in range(height):
            for c2 in range(width):
                if output_grid[r2][c2] == color_val:
                    cells.append((r2, c2))
        
        while True:
            can_shift = False
            to_shift = []
            for (r2, c2) in cells:
                nr, nc = r2 + dr, c2 + dc
                if 0 <= nr < height and 0 <= nc < width and output_grid[nr][nc] == 0:
                    to_shift.append((r2, c2))
                    can_shift = True
            
            if not can_shift:
                break
            
            for (r2, c2) in to_shift:
                output_grid[r2][c2] = 0
                output_grid[r2 + dr][c2 + dc] = color_val
            
            cells = [(r2 + dr, c2 + dc) for (r2, c2) in to_shift]

    for (r, c) in path:
        output_grid[r][c] = 9
    
    return output_grid
