# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 9fe9bdfd
Difficulty: mediumâ€“hard

=== Tags ===
- Directed field
- Route switching
- Trace perimeter

=== Description ===
Input grids feature multiple disjoint axis-aligned rectangles on a uniform
background. Each rectangle has a single colored marker (distinct from border and
background) positioned on one of its four edges (top, right, bottom, left),
indicating the traversal direction: markers on top or bottom edges dictate
counterclockwise perimeter tracing, while markers on left or right edges dictate
clockwise tracing. Output grids display the merged perimeter of all rectangles,
where adjacent rectangles share edges. Upon encountering a shared edge between
two rectangles, the traversal direction switches to the direction specified by
the second rectangle's marker, resulting in a continuous path that alternates
direction at adjacency points. Perimeter lines are drawn as single-cell-wide
paths following the adjusted direction, with all output paths occupying only
background cells and never overlapping borders or markers.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Grid size
    width = random.randint(18, 28)
    height = random.randint(12, 20)
    grid = [[0 for _ in range(width)] for _ in range(height)]

    # Number of rectangles
    n = random.randint(2, 4)

    # Choose rectangle heights (use same height for simplicity)
    rect_h = random.randint(4, 6)

    # Choose widths that will fit; retry if not fitting
    for _ in range(100):
        widths = [random.randint(4, 6) for _ in range(n)]
        S = sum(widths)
        # We place rectangles left-to-right with a single-column gap between their borders
        # Starting column s must satisfy: s >= 2 (so outside ring fits) and s <= width - S - n
        if width - S - n >= 2:
            start_c = random.randint(2, width - S - n)
            break
    else:
        # fallback simple placement
        n = 2
        widths = [5, 5]
        rect_h = min(rect_h, height - 6)
        start_c = 2

    # Choose vertical start so outside ring fits
    r_start_min = 2
    r_start_max = height - rect_h - 2
    if r_start_max < r_start_min:
        r_start = r_start_min
    else:
        r_start = random.randint(r_start_min, r_start_max)

    rects = []
    c = start_c
    for w in widths:
        c0 = c
        c1 = c0 + w - 1
        r0 = r_start
        r1 = r0 + rect_h - 1
        rects.append((r0, c0, r1, c1))
        # next rectangle c0 = c1 + 2 (one-column gap)
        c = c1 + 2

    # Draw borders color 1 and place markers color 2
    BORDER = 1
    MARKER = 2
    for (r0, c0, r1, c1) in rects:
        for r in range(r0, r1 + 1):
            for c2 in range(c0, c1 + 1):
                if r == r0 or r == r1 or c2 == c0 or c2 == c1:
                    grid[r][c2] = BORDER
    
    # Place one marker per rectangle on a random side (center position on that side)
    marker_positions = []
    for (r0, c0, r1, c1) in rects:
        side = random.choice(['top', 'right', 'bottom', 'left'])
        if side == 'top':
            mc = (r0, (c0 + c1) // 2)
        elif side == 'bottom':
            mc = (r1, (c0 + c1) // 2)
        elif side == 'left':
            mc = ((r0 + r1) // 2, c0)
        else:
            mc = ((r0 + r1) // 2, c1)
        # Overwrite border cell with marker
        mr, mc_col = mc
        grid[mr][mc_col] = MARKER
        marker_positions.append((mr, mc_col))

    # Compute outside ring cells for each rectangle (these are background cells)
    rings = []
    for (r0, c0, r1, c1) in rects:
        ring = []
        # top (left->right)
        for c2 in range(c0, c1 + 1):
            ring.append((r0 - 1, c2))
        # right (top->bottom)
        for r2 in range(r0, r1 + 1):
            ring.append((r2, c1 + 1))
        # bottom (right->left)
        for c2 in range(c1, c0 - 1, -1):
            ring.append((r1 + 1, c2))
        # left (bottom->top)
        for r2 in range(r1, r0 - 1, -1):
            ring.append((r2, c0 - 1))
        rings.append(ring)

    # Map ring cells to rectangles (shared cells will appear in multiple lists)
    cell_to_rects = {}
    for i, ring in enumerate(rings):
        for cell in ring:
            cell_to_rects.setdefault(cell, []).append(i)

    # For each rectangle determine traversal direction from marker
    # top/bottom -> CCW (we will set direction = -1 meaning reverse of our CW list)
    # left/right -> CW (direction = +1)
    directions = []
    starts = []
    for i, ((r0, c0, r1, c1), marker) in enumerate(zip(rects, marker_positions)):
        mr, mc_col = marker
        side = ('top' if mr == r0 else 'bottom' if mr == r1 else 'left' if mc_col == c0 else 'right')
        if side in ('top', 'bottom'):
            dirn = -1
        else:
            dirn = 1
        directions.append(dirn)
        # compute starting outside ring coordinate adjacent to marker
        if side == 'top':
            start_cell = (r0 - 1, mc_col)
        elif side == 'bottom':
            start_cell = (r1 + 1, mc_col)
        elif side == 'left':
            start_cell = ((r0 + r1) // 2, c0 - 1)
        else:
            start_cell = ((r0 + r1) // 2, c1 + 1)
        # find index of start_cell in ring cw order
        ring = rings[i]
        try:
            idx = ring.index(start_cell)
        except ValueError:
            # fallback to first cell
            idx = 0
        starts.append(idx)

    # Build continuous path by simulating traversal and switching at shared cells
    total_cells = set()
    for ring in rings:
        for cell in ring:
            total_cells.add(cell)
    total_cells = set([cell for cell in total_cells if 0 <= cell[0] < height and 0 <= cell[1] < width and grid[cell[0]][cell[1]] == 0])

    # Start from leftmost rectangle for determinism
    start_rect = min(range(len(rects)), key=lambda i: rects[i][1])
    cur_rect = start_rect
    cur_ring = rings[cur_rect]
    cur_idx = starts[cur_rect]
    cur_dir = directions[cur_rect]

    visited = []
    visited_set = set()
    max_steps = len(total_cells) * 10 + 1000
    steps = 0
    while steps < max_steps:
        steps += 1
        cell = cur_ring[cur_idx]
        # Only mark and add cells that are valid background cells
        if cell not in visited_set and 0 <= cell[0] < height and 0 <= cell[1] < width and grid[cell[0]][cell[1]] == 0:
            visited.append(cell)
            visited_set.add(cell)
        # Move to next cell along current ring
        next_idx = (cur_idx + cur_dir) % len(cur_ring)
        next_cell = cur_ring[next_idx]
        # If the next cell belongs to another rectangle's ring, switch to that rectangle
        owners = cell_to_rects.get(next_cell, [])
        # Prefer switching to a different rectangle if possible
        other = None
        for o in owners:
            if o != cur_rect:
                other = o
                break
        if other is not None:
            # switch to other rectangle
            cur_rect = other
            cur_ring = rings[cur_rect]
            cur_dir = directions[cur_rect]
            # find index of next_cell in new ring
            try:
                cur_idx = cur_ring.index(next_cell)
            except ValueError:
                # shouldn't happen, but in case continue along the old ring
                cur_idx = next_idx
        else:
            cur_idx = next_idx
        # stop if we've visited all available cells and returned to start
        if len(visited_set) == len(total_cells) and cell == rings[start_rect][starts[start_rect]]:
            break
    
    # Create output grid: copy input and draw path color 3
    PATH = 3
    out = [row[:] for row in grid]
    for (r, c2) in visited:
        out[r][c2] = PATH

    return {"input": grid, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input grid (tuple of tuples) to list of lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])
    # Identify non-background colors
    counts = {}
    for r in range(h):
        for c in range(w):
            v = grid[r][c]
            if v == 0: continue
            counts[v] = counts.get(v, 0) + 1
    if not counts:
        return grid
    # Assume the most frequent non-zero color is the border
    border_color = max(counts.items(), key=lambda x: x[1])[0]
    # Find connected components of non-zero cells (these are the rectangles + markers)
    visited = [[False]*w for _ in range(h)]
    comps = []
    for r in range(h):
        for c in range(w):
            if grid[r][c] == 0 or visited[r][c]:
                continue
            # flood fill
            stack = [(r,c)]
            comp = []
            visited[r][c] = True
            while stack:
                rr, cc = stack.pop()
                comp.append((rr, cc))
                for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                    nr, nc = rr+dr, cc+dc
                    if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] != 0:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            comps.append(comp)
    rects = []
    marker_positions = []
    # For each component get bounding box and find marker
    for comp in comps:
        rs = [p[0] for p in comp]
        cs = [p[1] for p in comp]
        r0, r1 = min(rs), max(rs)
        c0, c1 = min(cs), max(cs)
        rects.append((r0, c0, r1, c1))
        # find marker (a cell in comp with color != border_color)
        marker = None
        for (rr, cc) in comp:
            if grid[rr][cc] != border_color:
                marker = (rr, cc)
                break
        if marker is None:
            # Should not happen for valid generator, but set a fallback
            marker = (r0, c0)
        marker_positions.append(marker)
    # Build outside ring cw lists for each rectangle
    rings = []
    for (r0, c0, r1, c1) in rects:
        ring = []
        for c2 in range(c0, c1+1):
            ring.append((r0-1, c2))
        for r2 in range(r0, r1+1):
            ring.append((r2, c1+1))
        for c2 in range(c1, c0-1, -1):
            ring.append((r1+1, c2))
        for r2 in range(r1, r0-1, -1):
            ring.append((r2, c0-1))
        rings.append(ring)
    # Map ring cells to rectangles
    cell_to_rects = {}
    for i, ring in enumerate(rings):
        for cell in ring:
            cell_to_rects.setdefault(cell, []).append(i)
    # Determine directions and start indices from markers
    directions = []
    starts = []
    for (r0, c0, r1, c1), marker in zip(rects, marker_positions):
        mr, mc = marker
        if mr == r0:
            side = 'top'
        elif mr == r1:
            side = 'bottom'
        elif mc == c0:
            side = 'left'
        else:
            side = 'right'
        if side in ('top', 'bottom'):
            dirn = -1
        else:
            dirn = 1
        directions.append(dirn)
        if side == 'top':
            start_cell = (r0-1, mc)
        elif side == 'bottom':
            start_cell = (r1+1, mc)
        elif side == 'left':
            start_cell = ((r0+r1)//2, c0-1)
        else:
            start_cell = ((r0+r1)//2, c1+1)
        try:
            idx = rings[len(starts)].index(start_cell)
        except Exception:
            # fallback to find in any ring
            idx = 0
            for i, ring in enumerate(rings):
                if start_cell in ring:
                    idx = ring.index(start_cell)
                    break
        starts.append(idx)
    # Union of all ring cells that are valid background
    total_cells = set()
    for ring in rings:
        for cell in ring:
            r,c = cell
            if 0 <= r < h and 0 <= c < w and grid[r][c] == 0:
                total_cells.add(cell)
    if not total_cells:
        return grid
    # Start at leftmost rectangle
    start_rect = min(range(len(rects)), key=lambda i: rects[i][1])
    cur_rect = start_rect
    cur_ring = rings[cur_rect]
    cur_idx = starts[cur_rect]
    cur_dir = directions[cur_rect]
    visited_list = []
    visited_set = set()
    max_steps = len(total_cells) * 10 + 1000
    steps = 0
    while steps < max_steps:
        steps += 1
        cell = cur_ring[cur_idx]
        if cell not in visited_set and 0 <= cell[0] < h and 0 <= cell[1] < w and grid[cell[0]][cell[1]] == 0:
            visited_list.append(cell)
            visited_set.add(cell)
        next_idx = (cur_idx + cur_dir) % len(cur_ring)
        next_cell = cur_ring[next_idx]
        owners = cell_to_rects.get(next_cell, [])
        other = None
        for o in owners:
            if o != cur_rect:
                other = o
                break
        if other is not None:
            cur_rect = other
            cur_ring = rings[cur_rect]
            cur_dir = directions[cur_rect]
            try:
                cur_idx = cur_ring.index(next_cell)
            except ValueError:
                cur_idx = next_idx
        else:
            cur_idx = next_idx
        if len(visited_set) == len(total_cells) and cell == rings[start_rect][starts[start_rect]]:
            break
    # Draw path color 3 on a copy of the input grid
    out = [row[:] for row in grid]
    for (r,c) in visited_list:
        out[r][c] = 3
    return out

