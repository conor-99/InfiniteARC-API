# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: e3455626
Difficulty: medium

=== Tags ===
- Path following
- Recoloring
- Obstacles
- Only one

=== Description ===
The input grid contains a single, continuous path of color 1 that connects the
top and bottom edges of the grid, with obstacles (color 0) positioned to block
all alternative routes. The output grid recolors every cell in this unique path
to color 5, while preserving obstacles and all other cells unchanged. The path
is guaranteed to be the sole possible route between the top and bottom edges,
making the transformation deterministic and discoverable through path
identification.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
def generate_path(width, height):
    start_col = random.randint(0, width-1)
    path = [(0, start_col)]
    current_row, current_col = 0, start_col
    while current_row < height - 1:
        moves = []
        if current_row < height - 1:
            moves.append('down')
        if current_col > 0:
            moves.append('left')
        if current_col < width - 1:
            moves.append('right')
        if not moves:
            break
        move = random.choice(moves)
        if move == 'down':
            current_row += 1
        elif move == 'left':
            current_col -= 1
        elif move == 'right':
            current_col += 1
        path.append((current_row, current_col))
    return path
def generate():
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    path = generate_path(width, height)
    input_grid = [[0] * width for _ in range(height)]
    for r, c in path:
        input_grid[r][c] = 1
    output_grid = [[5 if cell == 1 else cell for cell in row] for row in input_grid]
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    return [[5 if cell == 1 else cell for cell in row] for row in input_grid]
