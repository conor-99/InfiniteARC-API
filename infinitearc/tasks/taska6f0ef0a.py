# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: a6f0ef0a
Difficulty: easy

=== Tags ===
- Bridges
- Color the row with most dots
- Permute columns by length
- Move object to nearest corner

=== Description ===
The task involves transforming an input grid into an output grid through three
visual operations. First, the row containing the greatest number of non-zero
cells (dots) is identified and entirely recolored using a new, distinct color
(e.g., red). Second, the columns of the grid are reordered based on the count of
non-zero cells in each column, sorted from shortest (fewest dots) to longest
(most dots). Third, the largest connected group of dots (the main object) is
moved to the nearest corner of the grid (top-left, top-right, bottom-left, or
bottom-right) based on its current position. All operations are applied
sequentially to the input grid to derive the output grid, with no reliance on
numerical sums, bit patterns, or pixel-level matching. The rules are visually
intuitive and consistent across grids of varying sizes.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    grid = [[random.choice([0] + list(range(1, 10))) for _ in range(width)] for _ in range(height)]
    
    # Find row with max non-zero cells
    row_counts = [sum(1 for cell in row if cell != 0) for row in grid]
    max_count = max(row_counts)
    max_rows = [i for i, count in enumerate(row_counts) if count == max_count]
    
    # Resolve ties by modifying one cell in the first max row
    if len(max_rows) > 1:
        target_row = max_rows[0]
        for c in range(width):
            if grid[target_row][c] == 0:
                grid[target_row][c] = random.randint(1, 9)
                break
        # Recalculate to ensure unique max
        row_counts = [sum(1 for cell in row if cell != 0) for row in grid]
        max_count = max(row_counts)
        max_rows = [i for i, count in enumerate(row_counts) if count == max_count]
        
    # Choose new color
    used_colors = set()
    for row in grid:
        for cell in row:
            if cell != 0:
                used_colors.add(cell)
    new_color = 1
    while new_color in used_colors:
        new_color += 1
    if new_color > 9:
        new_color = 1
    
    # Apply transformations
    output = [row[:] for row in grid]
    max_row_idx = max_rows[0]
    for c in range(width):
        output[max_row_idx][c] = new_color
    
    col_counts = [sum(1 for r in range(height) if output[r][c] != 0) for c in range(width)]
    sorted_cols = sorted(range(width), key=lambda c: col_counts[c])
    output = [[output[r][c] for c in sorted_cols] for r in range(height)]
    
    # Find largest connected component
    visited = [[False] * width for _ in range(height)]
    components = []
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and output[r][c] != 0:
                comp = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    comp.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr+dr, cc+dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and output[nr][nc] != 0:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append(comp)
    
    if not components:
        return {'input': grid, 'output': output}
    
    largest_comp = max(components, key=len)
    centroid_r = sum(r for r, c in largest_comp) / len(largest_comp)
    centroid_c = sum(c for r, c in largest_comp) / len(largest_comp)
    corners = [(0,0), (0, width-1), (height-1, 0), (height-1, width-1)]
    dists = [abs(centroid_r - r) + abs(centroid_c - c) for r, c in corners]
    nearest_corner = corners[dists.index(min(dists))]
    
    # Save component colors and remove component
    comp_colors = {}
    for r, c in largest_comp:
        comp_colors[(r, c)] = output[r][c]
        output[r][c] = 0
    
    # Compute bounding box
    min_r = min(r for r, c in largest_comp)
    min_c = min(c for r, c in largest_comp)
    max_r = max(r for r, c in largest_comp)
    max_c = max(c for r, c in largest_comp)
    comp_w = max_c - min_c + 1
    comp_h = max_r - min_r + 1
    
    # Determine corner placement offsets
    if nearest_corner == (0, 0):
        new_r_offset, new_c_offset = 0, 0
    elif nearest_corner == (0, width-1):
        new_r_offset, new_c_offset = 0, width - 1 - (comp_w - 1)
    elif nearest_corner == (height-1, 0):
        new_r_offset, new_c_offset = height - 1 - (comp_h - 1), 0
    else:
        new_r_offset, new_c_offset = height - 1 - (comp_h - 1), width - 1 - (comp_w - 1)
    
    # Place component in corner
    for r, c in largest_comp:
        new_r = r - min_r + new_r_offset
        new_c = c - min_c + new_c_offset
        if 0 <= new_r < height and 0 <= new_c < width:
            output[new_r][new_c] = comp_colors[(r, c)]
    
    return {'input': grid, 'output': output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to list of lists if it's a tuple
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    
    width = len(input_grid[0])
    height = len(input_grid)
    
    # Find row with max non-zero cells
    row_counts = [sum(1 for cell in row if cell != 0) for row in input_grid]
    max_count = max(row_counts)
    max_rows = [i for i, count in enumerate(row_counts) if count == max_count]
    max_row_idx = max_rows[0] if max_rows else 0
    
    # Choose new color
    used_colors = set()
    for row in input_grid:
        for cell in row:
            if cell != 0:
                used_colors.add(cell)
    new_color = 1
    while new_color in used_colors:
        new_color += 1
    if new_color > 9:
        new_color = 1
    
    # Apply transformations
    output = [row[:] for row in input_grid]
    for c in range(width):
        output[max_row_idx][c] = new_color
    
    col_counts = [sum(1 for r in range(height) if output[r][c] != 0) for c in range(width)]
    sorted_cols = sorted(range(width), key=lambda c: col_counts[c])
    output = [[output[r][c] for c in sorted_cols] for r in range(height)]
    
    # Find largest connected component
    visited = [[False] * width for _ in range(height)]
    components = []
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and output[r][c] != 0:
                comp = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    comp.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr+dr, cc+dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and output[nr][nc] != 0:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append(comp)
    
    if not components:
        return output
    
    largest_comp = max(components, key=len)
    centroid_r = sum(r for r, c in largest_comp) / len(largest_comp)
    centroid_c = sum(c for r, c in largest_comp) / len(largest_comp)
    corners = [(0,0), (0, width-1), (height-1, 0), (height-1, width-1)]
    dists = [abs(centroid_r - r) + abs(centroid_c - c) for r, c in corners]
    nearest_corner = corners[dists.index(min(dists))]
    
    # Save component colors and remove component
    comp_colors = {}
    for r, c in largest_comp:
        comp_colors[(r, c)] = output[r][c]
        output[r][c] = 0
    
    # Compute bounding box
    min_r = min(r for r, c in largest_comp)
    min_c = min(c for r, c in largest_comp)
    max_r = max(r for r, c in largest_comp)
    max_c = max(c for r, c in largest_comp)
    comp_w = max_c - min_c + 1
    comp_h = max_r - min_r + 1
    
    # Determine corner placement offsets
    if nearest_corner == (0, 0):
        new_r_offset, new_c_offset = 0, 0
    elif nearest_corner == (0, width-1):
        new_r_offset, new_c_offset = 0, width - 1 - (comp_w - 1)
    elif nearest_corner == (height-1, 0):
        new_r_offset, new_c_offset = height - 1 - (comp_h - 1), 0
    else:
        new_r_offset, new_c_offset = height - 1 - (comp_h - 1), width - 1 - (comp_w - 1)
    
    # Place component in corner
    for r, c in largest_comp:
        new_r = r - min_r + new_r_offset
        new_c = c - min_c + new_c_offset
        if 0 <= new_r < height and 0 <= new_c < width:
            output[new_r][new_c] = comp_colors[(r, c)]
    
    return output
