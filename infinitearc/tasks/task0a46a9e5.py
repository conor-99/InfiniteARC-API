# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 0a46a9e5
Difficulty: medium

=== Tags ===
- Remove intruder

=== Description ===
The input grid features a background color (typically black, represented as 0)
and multiple connected regions of non-background colors. The majority non-
background color is determined by the most frequent color in the grid. The
output grid is created by identifying the smallest connected region (by area)
that uses a color different from the majority non-background color and removing
it (setting all its pixels to the background color). For example, if the
majority color is blue and a single red pixel is surrounded by blue, the output
will replace that red pixel with the background. The transformation requires
recognizing connected regions, determining the dominant color, and targeting the
smallest outlier region for removal.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    if width == 1 and height == 1:
        height = 2
    majority = random.randint(1, 9)
    small = random.randint(1, 9)
    while small == majority:
        small = random.randint(1, 9)
    
    input_grid = [[majority] * width for _ in range(height)]
    r = random.randint(0, height - 1)
    c = random.randint(0, width - 1)
    input_grid[r][c] = small
    output_grid = [row[:] for row in input_grid]
    output_grid[r][c] = 0
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import Counter
def p(input_grid):
    non_zero = [cell for row in input_grid for cell in row if cell != 0]
    if not non_zero:
        return input_grid
    majority = Counter(non_zero).most_common(1)[0][0]
    
    candidates = []
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] != 0 and input_grid[r][c] != majority:
                candidates.append((r, c))
    
    if not candidates:
        return input_grid
    
    visited = set()
    components = []
    for r, c in candidates:
        if (r, c) not in visited:
            stack = [(r, c)]
            visited.add((r, c))
            component = []
            while stack:
                cr, cc = stack.pop()
                component.append((cr, cc))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < len(input_grid) and 0 <= nc < len(input_grid[0]) and (nr, nc) not in visited and input_grid[nr][nc] != 0 and input_grid[nr][nc] != majority:
                        visited.add((nr, nc))
                        stack.append((nr, nc))
            components.append(component)
    
    smallest = min(components, key=len)
    output_grid = [list(row) for row in input_grid]
    for r, c in smallest:
        output_grid[r][c] = 0
    return output_grid
