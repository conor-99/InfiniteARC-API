# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 57479a0f
Difficulty: very hard

=== Tags ===
- Hollow core detection
- Contextual rule switch
- Friction path
- Color permutation
- Swap rows

=== Description ===
The input grid features a background (color 0) with multiple enclosed shapes
where each contains a hollow core—a background-filled region completely
surrounded by a continuous perimeter of a single non-background color. The
perimeter must form a closed loop with no gaps, and the hollow core must be
maximal (not contained within another such region). The perimeter color varies
per shape but is consistent across each shape's boundary.  The transformation
process involves five sequential steps:   1. **Hollow Core Detection**: Identify
all maximal hollow cores by finding background regions entirely enclosed by a
single-color perimeter.   2. **Contextual Rule Switch**: For each hollow core,
determine the permutation axis based on the perimeter's orientation—horizontal
perimeters (top/bottom edges dominant) trigger horizontal color permutation,
while vertical perimeters (left/right edges dominant) trigger vertical
permutation.   3. **Friction Path**: Trace a path within each hollow core
starting at its top-left cell, moving right to the edge, then down, repeating in
a snake-like pattern to cover all core cells without overlap.   4. **Color
Permutation**: Collect the colors of non-background cells immediately adjacent
to the perimeter in clockwise order (starting from the top-left perimeter cell),
then apply a cyclic left rotation to this sequence. Fill the friction path with
the permuted colors in order.   5. **Swap Rows**: After processing all hollow
cores, swap each row containing at least one cell from a hollow core with the
row directly below it (circularly, so the last row swaps with the first).    The
output grid retains all non-hollow regions unchanged, modifies hollow cores per
the above steps, and applies row swaps. Background remains color 0, and all
transformations rely solely on visual spatial relationships (perimeter
orientation, adjacency, path tracing) rather than numerical properties of
colors.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid


def generate():
    """
    Generator that creates a grid with 2-3 rectangular single-color perimeters each enclosing a hollow core (background-filled interior).
    It places a small non-background "adjacency" pixel just outside each perimeter (cardinal neighbor) to ensure there is at least one non-background neighbor for the permutation step.
    It then creates the output by applying the friction path fill (snake order) using a rotated list of adjacent colors and finally swaps rows containing core cells with the row below (descending order, circular for last row).
    """
    # Size: ensure enough room to place a few rectangles with margins
    width = random.randint(6, 20)
    height = random.randint(6, 20)
    ingrid = grid(width, height, 0)

    occupied = [[False] * width for _ in range(height)]
    cores = []

    # Number of hollow rectangles
    num_cores = random.randint(2, 3)
    attempts = 0
    while len(cores) < num_cores and attempts < 300:
        attempts += 1
        # Max rectangle side limited to about half the smallest grid dim so we can place multiple
        max_side = max(3, min(width, height) // 2)
        w = random.randint(3, max_side)
        h = random.randint(3, max_side)

        # Choose top-left with at least one-cell margin when possible (to allow outside adjacency)
        r_min = 1
        r_max = height - h - 1
        if r_max < r_min:
            r_min = 0
            r_max = height - h
        c_min = 1
        c_max = width - w - 1
        if c_max < c_min:
            c_min = 0
            c_max = width - w

        r = random.randint(r_min, r_max)
        c = random.randint(c_min, c_max)

        # Check collision with previously placed shapes (allow 1-cell margin)
        conflict = False
        for rr in range(r - 1, r + h + 1):
            for cc in range(c - 1, c + w + 1):
                if 0 <= rr < height and 0 <= cc < width and occupied[rr][cc]:
                    conflict = True
                    break
            if conflict:
                break
        if conflict:
            continue

        # Choose a perimeter color distinct from 0
        color = random.randint(1, 9)

        # Draw perimeter and mark occupied
        for i in range(r, r + h):
            for j in range(c, c + w):
                if i == r or i == r + h - 1 or j == c or j == c + w - 1:
                    ingrid[i][j] = color
                    occupied[i][j] = True
                else:
                    # interior remains background 0 but mark as occupied so other shapes don't overlap
                    occupied[i][j] = True

        cores.append((r, c, w, h, color))

    # Guarantee at least one adjacency non-zero cell outside each perimeter so permutation has something to use
    for (r, c, w, h, color) in cores:
        # cardinal neighbors (prefer these)
        cardinals = []
        for j in range(c, c + w):
            cardinals.append((r - 1, j))
        for i in range(r, r + h):
            cardinals.append((i, c + w))
        for j in range(c, c + w):
            cardinals.append((r + h, j))
        for i in range(r, r + h):
            cardinals.append((i, c - 1))

        placed = False
        random.shuffle(cardinals)
        for (ci, cj) in cardinals:
            if 0 <= ci < height and 0 <= cj < width and ingrid[ci][cj] == 0:
                adj_color = random.randint(1, 9)
                if adj_color == color:
                    adj_color = (adj_color % 9) + 1
                ingrid[ci][cj] = adj_color
                placed = True
                break

        # If no cardinal free, try diagonals as a fallback (rare). These are less preferred but keep the grid valid.
        if not placed:
            diagonals = [(r - 1, c - 1), (r - 1, c + w), (r + h, c - 1), (r + h, c + w)]
            for (ci, cj) in diagonals:
                if 0 <= ci < height and 0 <= cj < width and ingrid[ci][cj] == 0:
                    adj_color = random.randint(1, 9)
                    if adj_color == color:
                        adj_color = (adj_color % 9) + 1
                    ingrid[ci][cj] = adj_color
                    placed = True
                    break

        # As a very last resort (should be rare), overwrite a cardinal cell (prefer top) to ensure adjacency exists
        if not placed:
            ci, cj = r - 1, c
            if 0 <= ci < height and 0 <= cj < width:
                adj_color = random.randint(1, 9)
                if adj_color == color:
                    adj_color = (adj_color % 9) + 1
                ingrid[ci][cj] = adj_color
            else:
                ci, cj = r, c - 1
                if 0 <= ci < height and 0 <= cj < width:
                    adj_color = random.randint(1, 9)
                    if adj_color == color:
                        adj_color = (adj_color % 9) + 1
                    ingrid[ci][cj] = adj_color

    # Prepare output by applying the transformation rules
    out = [row[:] for row in ingrid]

    core_rows = set()

    for (r, c, w, h, color) in cores:
        core_top = r + 1
        core_left = c + 1
        core_bottom = r + h - 2
        core_right = c + w - 2
        if core_top > core_bottom or core_left > core_right:
            continue

        # friction path (snake)
        path = []
        for i in range(core_top, core_bottom + 1):
            if (i - core_top) % 2 == 0:
                for j in range(core_left, core_right + 1):
                    path.append((i, j))
            else:
                for j in range(core_right, core_left - 1, -1):
                    path.append((i, j))

        # collect perimeter cells in clockwise order starting from top-left perimeter cell (r, c)
        perimeter = []
        # top edge
        for j in range(c, c + w):
            perimeter.append((r, j))
        # right edge (excluding corners already added)
        for i in range(r + 1, r + h - 1):
            perimeter.append((i, c + w - 1))
        # bottom edge (in reverse)
        for j in range(c + w - 1, c - 1, -1):
            perimeter.append((r + h - 1, j))
        # left edge (excluding corners)
        for i in range(r + h - 2, r, -1):
            perimeter.append((i, c))

        # For each perimeter cell take the outward neighbor color (depending on which edge it's on)
        adj_colors = []
        for (i, j) in perimeter:
            if i == r:
                ni, nj = i - 1, j
            elif j == c + w - 1:
                ni, nj = i, j + 1
            elif i == r + h - 1:
                ni, nj = i + 1, j
            else:
                ni, nj = i, j - 1
            if 0 <= ni < height and 0 <= nj < width:
                val = ingrid[ni][nj]
                if val != 0:
                    adj_colors.append(val)

        # Contextual rule switch: horizontal if width >= height else vertical
        if adj_colors:
            if w >= h:
                # horizontal -> left rotate by 1
                adj_colors = adj_colors[1:] + adj_colors[:1]
            else:
                # vertical -> right rotate by 1
                adj_colors = adj_colors[-1:] + adj_colors[:-1]

        # Fill the friction path with permuted colors, cycling if necessary
        if adj_colors:
            for idx, (i, j) in enumerate(path):
                out[i][j] = adj_colors[idx % len(adj_colors)]
                core_rows.add(i)

    # Swap rows containing at least one core cell (process in descending order to match solver behavior)
    core_rows = sorted(core_rows, reverse=True)
    for i in core_rows:
        if i < height - 1:
            out[i], out[i + 1] = out[i + 1], out[i]
        else:
            out[i], out[0] = out[0], out[i]

    return {"input": ingrid, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from common import grid


def p(input_grid):
    # Convert immutable tuple grid to mutable list-of-lists
    height = len(input_grid)
    width = len(input_grid[0])
    ingrid = [list(row) for row in input_grid]
    out = [row[:] for row in ingrid]

    visited = [[False] * width for _ in range(height)]
    cores = []  # will hold tuples (r, c, w, h, perimeter_color)

    # Find zero-valued connected components and test if they are hollow cores
    for i in range(height):
        for j in range(width):
            if ingrid[i][j] != 0 or visited[i][j]:
                continue
            # BFS to collect connected zero region
            stack = [(i, j)]
            comp = []
            touches_border = False
            neigh_colors = set()
            while stack:
                ci, cj = stack.pop()
                if visited[ci][cj]:
                    continue
                if ingrid[ci][cj] != 0:
                    continue
                visited[ci][cj] = True
                comp.append((ci, cj))
                # explore neighbors
                for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    ni, nj = ci + di, cj + dj
                    if not (0 <= ni < height and 0 <= nj < width):
                        touches_border = True
                        continue
                    if ingrid[ni][nj] == 0 and not visited[ni][nj]:
                        stack.append((ni, nj))
                    elif ingrid[ni][nj] != 0:
                        neigh_colors.add(ingrid[ni][nj])

            if touches_border:
                continue
            if not neigh_colors:
                continue
            if len(neigh_colors) != 1:
                # must be enclosed by a single-color perimeter
                continue
            peri_color = next(iter(neigh_colors))

            # bounding box of the component
            min_i = min(p[0] for p in comp)
            max_i = max(p[0] for p in comp)
            min_j = min(p[1] for p in comp)
            max_j = max(p[1] for p in comp)

            # The expected perimeter rectangle top-left is one cell above-left of box
            r = min_i - 1
            c = min_j - 1
            core_h = max_i - min_i + 1
            core_w = max_j - min_j + 1
            w = core_w + 2
            h = core_h + 2

            # Validate that perimeter cells exist and are all the perimeter color
            valid = True
            # top and bottom rows
            for jj in range(c, c + w):
                if not (0 <= r < height and 0 <= jj < width and ingrid[r][jj] == peri_color):
                    valid = False
                    break
                if not (0 <= r + h - 1 < height and 0 <= jj < width and ingrid[r + h - 1][jj] == peri_color):
                    valid = False
                    break
            if not valid:
                continue
            # left and right columns
            for ii in range(r + 1, r + h - 1):
                if not (0 <= ii < height and 0 <= c < width and ingrid[ii][c] == peri_color):
                    valid = False
                    break
                if not (0 <= ii < height and 0 <= c + w - 1 < width and ingrid[ii][c + w - 1] == peri_color):
                    valid = False
                    break
            if not valid:
                continue

            cores.append((r, c, w, h, peri_color))

    core_rows = set()

    # Process each core in the same deterministic way the generator does
    for (r, c, w, h, peri_color) in cores:
        core_top = r + 1
        core_left = c + 1
        core_bottom = r + h - 2
        core_right = c + w - 2
        if core_top > core_bottom or core_left > core_right:
            continue

        # friction path (snake)
        path = []
        for ii in range(core_top, core_bottom + 1):
            if (ii - core_top) % 2 == 0:
                for jj in range(core_left, core_right + 1):
                    path.append((ii, jj))
            else:
                for jj in range(core_right, core_left - 1, -1):
                    path.append((ii, jj))

        # collect perimeter in clockwise order starting at (r, c)
        perimeter = []
        for jj in range(c, c + w):
            perimeter.append((r, jj))
        for ii in range(r + 1, r + h - 1):
            perimeter.append((ii, c + w - 1))
        for jj in range(c + w - 1, c - 1, -1):
            perimeter.append((r + h - 1, jj))
        for ii in range(r + h - 2, r, -1):
            perimeter.append((ii, c))

        adj_colors = []
        for (ii, jj) in perimeter:
            if ii == r:
                ni, nj = ii - 1, jj
            elif jj == c + w - 1:
                ni, nj = ii, jj + 1
            elif ii == r + h - 1:
                ni, nj = ii + 1, jj
            else:
                ni, nj = ii, jj - 1
            if 0 <= ni < height and 0 <= nj < width:
                val = ingrid[ni][nj]
                if val != 0:
                    adj_colors.append(val)

        if adj_colors:
            # Contextual rule switch: horizontal if width >= height else vertical
            if w >= h:
                # horizontal -> left rotate by 1
                adj_colors = adj_colors[1:] + adj_colors[:1]
            else:
                # vertical -> right rotate by 1
                adj_colors = adj_colors[-1:] + adj_colors[:-1]

            # Fill path cycling through permuted colors
            for idx, (ii, jj) in enumerate(path):
                out[ii][jj] = adj_colors[idx % len(adj_colors)]
                core_rows.add(ii)

    # Swap rows containing at least one core cell (descending order as generator)
    core_rows = sorted(core_rows, reverse=True)
    for i in core_rows:
        if i < height - 1:
            out[i], out[i + 1] = out[i + 1], out[i]
        else:
            out[i], out[0] = out[0], out[i]

    return out

