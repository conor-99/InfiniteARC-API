# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 559b2eb0
Difficulty: mediumâ€“hard

=== Tags ===
- Dual source paths
- Emergent behavior

=== Description ===
Input grids feature a background color with two distinct colored sources
positioned such that their paths move in fixed orthogonal directions (e.g., one
source emits a downward-moving path, the other a rightward-moving path). Each
path extends in its direction as a straight line until encountering an obstacle
(non-background cell), grid boundary, or the other path. The output grid
preserves all path segments but replaces the intersection point of the two paths
and its four orthogonal neighbors with a new, distinct color, forming a cross-
shaped pattern. This cross pattern represents the emergent behavior arising from
the interaction of the dual paths, where the intersection of two independent
directional flows creates a new structural feature not present in the input. The
background remains unchanged, and all path colors remain visible except at the
intersection point. The task requires recognizing the intersecting paths and
applying the cross pattern rule, which is visually distinguishable through the
formation of the '+' shape in the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    grid = [[0] * width for _ in range(height)]
    c1 = random.randint(1, width - 2)
    r2 = random.randint(1, height - 2)
    for r in range(r2 + 1):
        grid[r][c1] = 1
    for c in range(c1 + 1):
        grid[r2][c] = 2
    output = [row[:] for row in grid]
    for (r, c) in [(r2 - 1, c1), (r2 + 1, c1), (r2, c1 - 1), (r2, c1 + 1), (r2, c1)]:
        output[r][c] = 3
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    path1_cells = [(r, c) for r in range(height) for c in range(width) if input_grid[r][c] == 1]
    path2_cells = [(r, c) for r in range(height) for c in range(width) if input_grid[r][c] == 2]
    c1 = path1_cells[0][1] if path1_cells else 0
    r2 = path2_cells[0][0] if path2_cells else 0
    cells = [(r2 - 1, c1), (r2 + 1, c1), (r2, c1 - 1), (r2, c1 + 1), (r2, c1)]
    used_colors = set()
    for row in input_grid:
        for color in row:
            if color != 0:
                used_colors.add(color)
    new_color = 3
    while new_color in used_colors:
        new_color += 1
    output = [list(row) for row in input_grid]
    for (r, c) in cells:
        if 0 <= r < height and 0 <= c < width:
            output[r][c] = new_color
    return output
