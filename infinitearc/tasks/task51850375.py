# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 51850375
Difficulty: very hard

=== Tags ===
- Role dependent behavior
- Agent memory trace
- Only one

=== Description ===
Input grids are large (20×20 minimum) with a single background color. Overlaid
on this background are distinct elements with unique roles:  - A single agent
(represented by a small colored square) positioned along the left edge, moving
right initially. - Walls: thin 1-cell-thick barriers (horizontal or vertical)
that reflect the agent's direction upon contact, changing their color to
indicate interaction (memory trace). - Portals: pairs of matching-colored
squares that teleport the agent to their paired location upon entry, rotate the
agent's direction 90° clockwise, and change their color (memory trace). - Color
zones: contiguous regions of specific colors that enforce direction changes
(e.g., left turn for one zone, right turn for another) upon entry, with the
zone's color cycling through a predefined sequence (memory trace).  The output
grid preserves all original elements except for memory-traced modifications:
walls, portals, and zones display their interaction state. The agent's path is
rendered as a continuous line using a cyclic sequence of colors (starting with
the agent's original color and cycling through predefined colors with each
interaction). Path segments between interactions are drawn in the current cycle
color, reflecting off walls, teleporting through portals, and rotating within
zones. The path exits the grid after a finite sequence of interactions without
loops, overlaps, or collisions with obstacles. Memory traces and path coloring
depend on the interaction sequence, requiring the solver to track the agent's
evolving state and environmental changes.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    # Colors / conventions used by both generator and solver
    PATH_COLORS = [1, 2, 3]        # cyclic path colors (agent starts with PATH_COLORS[0])
    WALL_COLOR = 4                 # walls (untouched)
    PORTAL_COLOR_POOL = [5, 6]     # colors for portal pairs (unique per pair)
    ZONE_LEFT = 7                  # left-turn zone color
    ZONE_RIGHT = 8                 # right-turn zone color

    # Grid size (large grids as required)
    size = random.randint(20, 25)

    # Create empty input grid
    input_grid = common.grid(size, size, 0)

    # Place agent on left edge (column 0). Keep a safe margin from top/bottom.
    agent_row = random.randint(2, size - 3)
    input_grid[agent_row][0] = PATH_COLORS[0]

    # Movement vectors: 0=right, 1=down, 2=left, 3=up
    drs = [0, 1, 0, -1]
    dcs = [1, 0, -1, 0]

    # We'll attempt to build a simple non-self-intersecting path that exits the grid on the right.
    max_attempts = 40
    attempt = 0
    while attempt < max_attempts:
        attempt += 1
        # State for this attempt
        visited = set()
        visited.add((agent_row, 0))  # agent cell reserved

        # Start just to the right of the agent
        cur_r, cur_c = agent_row, 1
        visited.add((cur_r, cur_c))
        path = [(cur_r, cur_c)]  # list of visited cells in order (excluding agent cell)
        cur_dir = 0  # initially moving right

        walls = set()
        zones = {}  # position -> 'L' or 'R'
        portals = []  # list of (entry_pos, exit_pos) pairs

        # Decide number of interactions and their types (limit portal count to available colors)
        num_interactions = random.randint(3, 6)
        portal_limit = len(PORTAL_COLOR_POOL)
        portal_count = 0
        interaction_types = []
        for _ in range(num_interactions):
            choice = random.choice(['wall', 'portal', 'zone_left', 'zone_right'])
            if choice == 'portal' and portal_count >= portal_limit:
                # fallback to a non-portal interaction if we're out of portal colors
                choice = random.choice(['wall', 'zone_left', 'zone_right'])
            if choice == 'portal':
                portal_count += 1
            interaction_types.append(choice)

        ok = True
        # Build the path, inserting an interaction at the end of each mini-segment
        for itype in interaction_types:
            # Move a small random number of steps before the interaction
            steps_before = random.randint(1, 4)
            for _ in range(steps_before):
                moved = False
                # preference: forward, then perpendicular, then backward (avoid backward if possible)
                cand_dirs = [cur_dir, (cur_dir + 1) % 4, (cur_dir + 3) % 4, (cur_dir + 2) % 4]
                for nd in cand_dirs:
                    nr = cur_r + drs[nd]
                    nc = cur_c + dcs[nd]
                    if 0 <= nr < size and 0 <= nc < size and (nr, nc) not in visited:
                        cur_r, cur_c = nr, nc
                        cur_dir = nd
                        visited.add((cur_r, cur_c))
                        path.append((cur_r, cur_c))
                        moved = True
                        break
                if not moved:
                    ok = False
                    break
            if not ok:
                break

            # We are now at the location that will host an interaction
            pos = (cur_r, cur_c)
            if itype == 'wall':
                walls.add(pos)
                # wall reflects 180 degrees
                cur_dir = (cur_dir + 2) % 4
            elif itype == 'zone_left':
                zones[pos] = 'L'
                # left turn
                cur_dir = (cur_dir - 1) % 4
            elif itype == 'zone_right':
                zones[pos] = 'R'
                # right turn
                cur_dir = (cur_dir + 1) % 4
            elif itype == 'portal':
                # Find an exit cell that is free and whose immediate next cell in the rotated direction
                # will be available for continuing the path.
                new_dir = (cur_dir + 1) % 4  # rotate 90 deg clockwise on teleport
                found = False
                for _try in range(200):
                    ex_r = random.randint(1, size - 2)
                    ex_c = random.randint(1, size - 2)
                    exit_pos = (ex_r, ex_c)
                    if exit_pos in visited or exit_pos == pos:
                        continue
                    # ensure after teleport there is a forward cell to continue the path
                    after_r = ex_r + drs[new_dir]
                    after_c = ex_c + dcs[new_dir]
                    if not (0 <= after_r < size and 0 <= after_c < size):
                        # teleporting to a cell that would immediately exit is allowed,
                        # but to keep the path non-trivial prefer inside cells
                        continue
                    if (after_r, after_c) in visited:
                        continue
                    # accept
                    found = True
                    break
                if not found:
                    ok = False
                    break
                portals.append((pos, exit_pos))
                # agent will appear at exit_pos and continue from there
                cur_r, cur_c = exit_pos
                visited.add((cur_r, cur_c))
                path.append((cur_r, cur_c))
                cur_dir = new_dir
            # continue building next interaction

        if not ok:
            continue

        # After the last interaction keep moving until the agent would step out of the grid.
        steps_guard = 0
        while True:
            steps_guard += 1
            if steps_guard > size * size:
                ok = False
                break
            nr = cur_r + drs[cur_dir]
            nc = cur_c + dcs[cur_dir]
            if not (0 <= nr < size and 0 <= nc < size):
                # next move would leave the grid -> finished
                break
            if (nr, nc) in visited:
                # cannot proceed straight, try a perpendicular move to keep going toward exit
                moved = False
                for nd in [(cur_dir + 1) % 4, (cur_dir + 3) % 4]:
                    rr = cur_r + drs[nd]
                    cc = cur_c + dcs[nd]
                    if 0 <= rr < size and 0 <= cc < size and (rr, cc) not in visited:
                        cur_r, cur_c = rr, cc
                        cur_dir = nd
                        visited.add((cur_r, cur_c))
                        path.append((cur_r, cur_c))
                        moved = True
                        break
                if not moved:
                    ok = False
                    break
            else:
                cur_r, cur_c = nr, nc
                visited.add((cur_r, cur_c))
                path.append((cur_r, cur_c))
                # continue
        if not ok:
            continue

        # If we reach here, we constructed a valid path. Place objects on the input grid.
        # Place walls
        for (wr, wc) in walls:
            input_grid[wr][wc] = WALL_COLOR
        # Place zones
        for (zr, zc), zt in zones.items():
            input_grid[zr][zc] = ZONE_LEFT if zt == 'L' else ZONE_RIGHT
        # Place portals and give each pair a unique color from the pool
        for idx, (entry_pos, exit_pos) in enumerate(portals):
            color = PORTAL_COLOR_POOL[idx % len(PORTAL_COLOR_POOL)]
            er, ec = entry_pos
            xr, xc = exit_pos
            input_grid[er][ec] = color
            input_grid[xr][xc] = color

        # Now simulate to produce output grid without mutating the original input_grid
        work = [row[:] for row in input_grid]
        output = [row[:] for row in input_grid]

        # Find agent starting current_pos (to the right of agent cell)
        cur_r, cur_c = agent_row, 1
        cur_dir = 0
        cycle_idx = 0
        path_color = PATH_COLORS[cycle_idx]

        # We'll need the original input to locate portal pairs when teleporting
        orig = [row[:] for row in input_grid]

        steps_limit = size * size * 2
        steps = 0
        while True:
            steps += 1
            if steps > steps_limit:
                # something went wrong, restart
                ok = False
                break
            r, c = cur_r, cur_c
            nr = r + drs[cur_dir]
            nc = c + dcs[cur_dir]
            # If next step leaves the grid -> mark current cell and stop
            if not (0 <= nr < size and 0 <= nc < size):
                output[r][c] = path_color
                break
            next_val = work[nr][nc]

            # Wall interaction
            if next_val == WALL_COLOR:
                output[r][c] = path_color
                # memory trace: wall cell becomes the path color (indicates it was touched)
                work[nr][nc] = path_color
                # reflect
                cur_dir = (cur_dir + 2) % 4
                # advance the color cycle
                cycle_idx = (cycle_idx + 1) % len(PATH_COLORS)
                path_color = PATH_COLORS[cycle_idx]
                # move into the wall cell
                cur_r, cur_c = nr, nc
                continue

            # Portal interaction (find the paired portal in the original input)
            if next_val in PORTAL_COLOR_POOL:
                output[r][c] = path_color
                work[nr][nc] = path_color
                # locate the partner cell in the original input grid
                pair = None
                for rr in range(size):
                    for cc in range(size):
                        if (rr, cc) != (nr, nc) and orig[rr][cc] == next_val:
                            pair = (rr, cc)
                            break
                    if pair:
                        break
                if pair is None:
                    # malformed portal arrangement; restart
                    ok = False
                    break
                # teleport and rotate clockwise
                cycle_idx = (cycle_idx + 1) % len(PATH_COLORS)
                path_color = PATH_COLORS[cycle_idx]
                cur_dir = (cur_dir + 1) % 4
                # teleport to pair
                cur_r, cur_c = pair
                continue

            # Zone interaction
            if next_val == ZONE_LEFT or next_val == ZONE_RIGHT:
                output[r][c] = path_color
                # memory trace for zone: set to current path color
                work[nr][nc] = path_color
                if next_val == ZONE_LEFT:
                    cur_dir = (cur_dir - 1) % 4
                else:
                    cur_dir = (cur_dir + 1) % 4
                cycle_idx = (cycle_idx + 1) % len(PATH_COLORS)
                path_color = PATH_COLORS[cycle_idx]
                cur_r, cur_c = nr, nc
                continue

            # Empty cell: just move forward and mark the cell being left
            output[r][c] = path_color
            cur_r, cur_c = nr, nc

        if not ok:
            continue

        # Generation succeeded
        return {'input': input_grid, 'output': output}

    # If too many attempts failed, fall back to a simple straight-line path with only zones and walls
    # (This fallback is conservative so generator always returns.)
    size = random.randint(20, 25)
    input_grid = common.grid(size, size, 0)
    agent_row = random.randint(2, size - 3)
    input_grid[agent_row][0] = PATH_COLORS[0]
    cur_r, cur_c = agent_row, 1
    output = [row[:] for row in input_grid]
    work = [row[:] for row in input_grid]
    # Put a few zones/walls along the straight path
    for c in range(3, size - 2, 4):
        if random.random() < 0.5:
            input_grid[agent_row][c] = ZONE_LEFT
        else:
            input_grid[agent_row][c] = WALL_COLOR
    # Simulate the simple straight path to the right
    cur_dir = 0
    cycle_idx = 0
    path_color = PATH_COLORS[cycle_idx]
    orig = [row[:] for row in input_grid]
    while True:
        nr = cur_r + drs[cur_dir]
        nc = cur_c + dcs[cur_dir]
        if not (0 <= nr < size and 0 <= nc < size):
            output[cur_r][cur_c] = path_color
            break
        next_val = work[nr][nc]
        if next_val == WALL_COLOR:
            output[cur_r][cur_c] = path_color
            work[nr][nc] = path_color
            cur_dir = (cur_dir + 2) % 4
            cycle_idx = (cycle_idx + 1) % len(PATH_COLORS)
            path_color = PATH_COLORS[cycle_idx]
            cur_r, cur_c = nr, nc
            continue
        if next_val == ZONE_LEFT or next_val == ZONE_RIGHT:
            output[cur_r][cur_c] = path_color
            work[nr][nc] = path_color
            if next_val == ZONE_LEFT:
                cur_dir = (cur_dir - 1) % 4
            else:
                cur_dir = (cur_dir + 1) % 4
            cycle_idx = (cycle_idx + 1) % len(PATH_COLORS)
            path_color = PATH_COLORS[cycle_idx]
            cur_r, cur_c = nr, nc
            continue
        output[cur_r][cur_c] = path_color
        cur_r, cur_c = nr, nc

    return {'input': input_grid, 'output': output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable lists
    grid = [list(row) for row in input_grid]
    size = len(grid)
    if size == 0:
        return grid

    # Same color scheme as generator
    PATH_COLORS = [1, 2, 3]
    WALL_COLOR = 4
    PORTAL_COLOR_POOL = [5, 6]
    ZONE_LEFT = 7
    ZONE_RIGHT = 8

    # Movement vectors
    drs = [0, 1, 0, -1]
    dcs = [1, 0, -1, 0]

    # Find the agent on the left edge (column 0)
    agent_row = None
    for r in range(size):
        if grid[r][0] == PATH_COLORS[0]:
            agent_row = r
            break
    if agent_row is None:
        # no agent found, return the grid unchanged
        return grid

    # Working copies
    orig = [row[:] for row in grid]   # original input (do not modify)
    work = [row[:] for row in grid]   # a mutable working grid to record memory traces
    output = [row[:] for row in grid] # the grid we will return

    # Simulation start: agent stands at column 0, current_pos is to the right of agent
    cur_r, cur_c = agent_row, 1
    cur_dir = 0
    cycle_idx = 0
    path_color = PATH_COLORS[cycle_idx]

    steps_limit = size * size * 2
    steps = 0

    while True:
        steps += 1
        if steps > steps_limit:
            # Safety: if something went wrong, stop and return what we have
            break
        r, c = cur_r, cur_c
        nr = r + drs[cur_dir]
        nc = c + dcs[cur_dir]

        # If next move exits the grid, mark the current cell and finish
        if not (0 <= nr < size and 0 <= nc < size):
            output[r][c] = path_color
            break

        next_val = work[nr][nc]

        # Wall
        if next_val == WALL_COLOR:
            output[r][c] = path_color
            # mark the wall cell as touched (memory trace)
            work[nr][nc] = path_color
            # reflect
            cur_dir = (cur_dir + 2) % 4
            # advance path color cycle
            cycle_idx = (cycle_idx + 1) % len(PATH_COLORS)
            path_color = PATH_COLORS[cycle_idx]
            # move into the wall cell
            cur_r, cur_c = nr, nc
            continue

        # Portal
        if next_val in PORTAL_COLOR_POOL:
            output[r][c] = path_color
            work[nr][nc] = path_color
            # find the paired portal cell in the original input grid
            pair = None
            for rr in range(size):
                for cc in range(size):
                    if (rr, cc) != (nr, nc) and orig[rr][cc] == next_val:
                        pair = (rr, cc)
                        break
                if pair:
                    break
            if pair is None:
                # malformed portal, stop
                break
            # teleport: rotate clockwise, advance cycle, and move to the pair cell
            cycle_idx = (cycle_idx + 1) % len(PATH_COLORS)
            path_color = PATH_COLORS[cycle_idx]
            cur_dir = (cur_dir + 1) % 4
            cur_r, cur_c = pair
            continue

        # Zone
        if next_val == ZONE_LEFT or next_val == ZONE_RIGHT:
            output[r][c] = path_color
            work[nr][nc] = path_color
            if next_val == ZONE_LEFT:
                cur_dir = (cur_dir - 1) % 4
            else:
                cur_dir = (cur_dir + 1) % 4
            cycle_idx = (cycle_idx + 1) % len(PATH_COLORS)
            path_color = PATH_COLORS[cycle_idx]
            cur_r, cur_c = nr, nc
            continue

        # Empty or ordinary cell: just move forward and mark the cell being left with the current path color
        output[r][c] = path_color
        cur_r, cur_c = nr, nc

    return output

