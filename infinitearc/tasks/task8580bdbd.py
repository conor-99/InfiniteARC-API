# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 8580bdbd
Difficulty: hard

=== Tags ===
- Binary rule overlay
- Pattern translation
- Associate colors to images

=== Description ===
Task Name: Symbolic Binary Translation  Description: Input grids contain a
primary pattern composed of contiguous regions of colors 1 through 8, each color
corresponding to a unique fixed 3x3 symbol pattern (e.g., color 1 forms a
vertical line with a horizontal crossbar, color 2 forms a diagonal line, color 3
forms a square, etc.). These symbols are embedded within a background of color
0. Separately, color 9 forms a binary overlay pattern that defines translation
vectors: each color 9 cell acts as a directional marker whose position relative
to the nearest symbol centroid determines the translation direction (e.g., a 9
cell above a symbol's centroid translates the symbol upward). Symbols are
translated simultaneously based on all applicable vectors from the binary
overlay. If translations cause overlapping regions, the resulting color is the
maximum value among the overlapping symbols. After translation, all color 9
cells are replaced with background (color 0). The output grid contains the
translated symbols, merged overlaps (using maximum color value), and background,
with no residual binary overlay. The transformation requires identifying symbol-
color associations, deriving translation vectors from the overlay pattern, and
resolving overlapping symbol interactions through logical merging.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid


def generate():
    # 3x3 patterns (1 means filled pixel for that symbol)
    patterns = [
        [[0,1,0], [0,1,0], [0,1,0]],  # 1: vertical
        [[1,0,0], [1,1,0], [0,1,0]],  # 2: bent diagonal / small elbow
        [[1,1,1], [1,1,1], [1,1,1]],  # 3: filled square
        [[0,1,0], [1,1,1], [0,1,0]],  # 4: cross
        [[1,0,0], [1,0,0], [1,1,1]],  # 5: L-shape (bottom-left)
        [[1,1,1], [0,1,0], [0,1,0]],  # 6: T or upside-down L
        [[0,1,1], [1,1,0], [0,0,0]],  # 7: small S-ish shape
        [[1,0,1], [1,1,0], [0,1,0]]   # 8: asymmetric zigzag
    ]

    size = random.randint(15, 30)
    input_grid = grid(size, size, 0)
    output_grid = grid(size, size, 0)

    # Place a random number of symbols (3-5), each with a unique color to avoid ambiguity
    num_symbols = random.randint(3, 5)
    available_colors = list(range(1, 9))
    chosen_colors = random.sample(available_colors, num_symbols)

    occupied = set()  # cells occupied by symbol pixels (so markers won't overwrite them)
    symbols = []  # list of (r, c, color)

    for color in chosen_colors:
        placed = False
        # Try a bunch of random positions until one fits without overlapping existing symbol pixels
        for _ in range(200):
            r = random.randint(0, size - 3)
            c = random.randint(0, size - 3)
            collision = False
            for i in range(3):
                for j in range(3):
                    if patterns[color - 1][i][j] != 0 and (r + i, c + j) in occupied:
                        collision = True
                        break
                if collision:
                    break
            if collision:
                continue
            # Place the symbol
            for i in range(3):
                for j in range(3):
                    if patterns[color - 1][i][j] != 0:
                        input_grid[r + i][c + j] = color
                        occupied.add((r + i, c + j))
            symbols.append((r, c, color))
            placed = True
            break
        # If we failed to place a chosen color after many tries, skip it (rare for given sizes).

    # Place 9-overlay markers. Each marker contributes a vector from the marker to the nearest symbol centroid.
    marker_positions = set()
    for (sr, sc, color) in symbols:
        centroid_r = sr + 1
        centroid_c = sc + 1
        # Place 1-4 markers for this symbol at various distances and directions
        num_markers = random.randint(1, 4)
        maxd = max(1, size // 6)
        for _ in range(num_markers):
            for attempt in range(60):
                dr = random.randint(-maxd, maxd)
                dc = random.randint(-maxd, maxd)
                if dr == 0 and dc == 0:
                    continue
                r9 = centroid_r + dr
                c9 = centroid_c + dc
                if not (0 <= r9 < size and 0 <= c9 < size):
                    continue
                if (r9, c9) in occupied:
                    continue
                if (r9, c9) in marker_positions:
                    continue
                # Place marker
                input_grid[r9][c9] = 9
                marker_positions.add((r9, c9))
                break

    # Compute translation vectors by assigning each marker to the nearest symbol centroid.
    # Tie-break deterministically by (distance, centroid_row, centroid_col)
    translations = { (sr, sc, color): [0, 0] for (sr, sc, color) in symbols }

    for (r9, c9) in marker_positions:
        best_sym = None
        best_key = None
        for (sr, sc, color) in symbols:
            cr = sr + 1
            cc = sc + 1
            dist = abs(r9 - cr) + abs(c9 - cc)
            key = (dist, cr, cc)
            if best_key is None or key < best_key:
                best_key = key
                best_sym = (sr, sc, color)
        if best_sym is not None:
            sr, sc, color = best_sym
            dr = r9 - (sr + 1)
            dc = c9 - (sc + 1)
            translations[best_sym][0] += dr
            translations[best_sym][1] += dc

    # Apply translations and merge overlaps by taking the maximum color value
    for (sr, sc, color) in symbols:
        dx, dy = translations[(sr, sc, color)]
        for i in range(3):
            for j in range(3):
                if patterns[color - 1][i][j] != 0:
                    nr = sr + i + dx
                    nc = sc + j + dy
                    if 0 <= nr < size and 0 <= nc < size:
                        if color > output_grid[nr][nc]:
                            output_grid[nr][nc] = color

    # Output grid should not contain any overlay markers (9) -- markers are only in the input
    # Return both grids
    return {
        'input': input_grid,
        'output': output_grid
    }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    input_grid = [list(row) for row in input_grid]
    h = len(input_grid)
    w = len(input_grid[0]) if h > 0 else 0

    # Same 3x3 patterns used by the generator
    patterns = [
        [[0,1,0], [0,1,0], [0,1,0]],  # 1
        [[1,0,0], [1,1,0], [0,1,0]],  # 2
        [[1,1,1], [1,1,1], [1,1,1]],  # 3
        [[0,1,0], [1,1,1], [0,1,0]],  # 4
        [[1,0,0], [1,0,0], [1,1,1]],  # 5
        [[1,1,1], [0,1,0], [0,1,0]],  # 6
        [[0,1,1], [1,1,0], [0,0,0]],  # 7
        [[1,0,1], [1,1,0], [0,1,0]]   # 8
    ]

    symbols = []  # detected symbols as (r, c, color)
    # Find all symbol top-left positions by matching pattern 1-cells to corresponding color
    for r in range(0, h - 2):
        for c in range(0, w - 2):
            for color in range(1, 9):
                pat = patterns[color - 1]
                ok = True
                for i in range(3):
                    for j in range(3):
                        if pat[i][j] != 0:
                            if input_grid[r + i][c + j] != color:
                                ok = False
                                break
                    if not ok:
                        break
                if ok:
                    symbols.append((r, c, color))
                    # A correct symbol occupies a 3x3 footprint; we can break to avoid duplicate matches at same top-left
                    break

    # If no symbols found, return a background grid (should not happen for valid generator outputs)
    if not symbols:
        return [[0] * w for _ in range(h)]

    # Centroids and translations
    centroids = { (sr, sc, color): (sr + 1, sc + 1) for (sr, sc, color) in symbols }
    translations = { symbol: [0, 0] for symbol in symbols }

    # For each overlay marker (9) assign it to the nearest symbol using the same tie-breaker
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] != 9:
                continue
            best_sym = None
            best_key = None
            for symbol in symbols:
                sr, sc, color = symbol
                cr, cc = centroids[symbol]
                dist = abs(r - cr) + abs(c - cc)
                key = (dist, cr, cc)
                if best_key is None or key < best_key:
                    best_key = key
                    best_sym = symbol
            if best_sym is not None:
                cr, cc = centroids[best_sym]
                dr = r - cr
                dc = c - cc
                translations[best_sym][0] += dr
                translations[best_sym][1] += dc

    # Build output by applying translations and merging overlaps by max color
    output = [[0] * w for _ in range(h)]
    for (sr, sc, color) in symbols:
        dx, dy = translations[(sr, sc, color)]
        for i in range(3):
            for j in range(3):
                if patterns[color - 1][i][j] != 0:
                    nr = sr + i + dx
                    nc = sc + j + dy
                    if 0 <= nr < h and 0 <= nc < w:
                        if color > output[nr][nc]:
                            output[nr][nc] = color

    # Ensure output contains no overlay markers (they are instructions only)
    return output

