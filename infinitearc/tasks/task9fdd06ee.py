# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 9fdd06ee
Difficulty: medium–hard

=== Tags ===
- Directional routing
- State transfer chain

=== Description ===
Directional Transfer Path   Input grids are large (20×20) with a uniform
background color (e.g., gray). A single path is defined by a sequence of "state
transfer" markers (each a single cell of color 1–4, distinct from background and
path elements). The path begins at the top-left corner (0,0), initially moving
right. Markers are placed at intervals along the path, with each marker’s color
dictating a direction change relative to the current movement: color 1 = turn
90° clockwise, color 2 = turn 90° counterclockwise, color 3 = turn 180°, color 4
= continue straight. The token moves orthogonally until hitting a marker, then
updates its direction per the marker’s rule. After the last marker, the token
continues in its current direction until exiting the grid.    The output grid
retains all input elements (background, markers, and path structure) but
explicitly draws the full path as a continuous line. Each segment of the path
(between markers, or from start to first marker, or from last marker to exit) is
rendered with a color corresponding to the marker that triggered its direction
change. The initial segment (before any markers) uses a default color (e.g.,
red, distinct from markers). Markers remain visible in their original colors and
do not overlap with drawn path segments. Path segments occupy only background
cells, never overwriting markers or background elements. The transformation
requires sequential application of direction changes based on marker sequence,
with no loops or self-intersections. The task demands identifying the marker
sequence, tracking the state transfer chain, and correctly mapping segments to
their triggering marker colors.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    N = 20
    bg = 5
    marker_colors = [1,2,3,4]
    default_color = 6
    directions = [(0,1),(1,0),(0,-1),(-1,0)]

    def turn_dir(cdir, color):
        if color == 1:
            return (cdir + 1) % 4
        if color == 2:
            return (cdir + 3) % 4
        if color == 3:
            return (cdir + 2) % 4
        return cdir

    max_attempts = 1000
    for attempt_all in range(max_attempts):
        num_markers = random.randint(1,5)
        visited = set()
        start = (0,0)
        visited.add(start)
        current_pos = start
        current_dir = 0
        markers = []
        path_segments = []
        ok = True

        for mi in range(num_markers):
            dr,dc = directions[current_dir]
            # compute max steps we can move in current direction without hitting visited or border
            r,c = current_pos
            max_steps = 0
            while True:
                nr = r + dr
                nc = c + dc
                if not (0 <= nr < N and 0 <= nc < N):
                    break
                if (nr,nc) in visited:
                    break
                max_steps += 1
                r,c = nr,nc
            if max_steps == 0:
                ok = False
                break

            possible_steps = list(range(1, max_steps+1))
            random.shuffle(possible_steps)
            placed = False
            for L in possible_steps:
                # build candidate cells for this segment (from current_pos+1 to current_pos+L inclusive)
                seg_cells = []
                r,c = current_pos
                collision = False
                for k in range(1, L+1):
                    r += dr; c += dc
                    if (r,c) in visited:
                        collision = True
                        break
                    seg_cells.append((r,c))
                if collision:
                    continue
                marker_pos = seg_cells[-1]
                colors_try = marker_colors[:]
                random.shuffle(colors_try)
                for color in colors_try:
                    nd = turn_dir(current_dir, color)
                    # if this is not the last marker, we need at least one available cell immediately after marker in nd direction
                    if mi < num_markers - 1:
                        nr = marker_pos[0] + directions[nd][0]
                        nc = marker_pos[1] + directions[nd][1]
                        if not (0 <= nr < N and 0 <= nc < N):
                            continue
                        if (nr,nc) in visited or (nr,nc) in seg_cells:
                            continue
                    else:
                        # last marker: ensure the tail from marker in nd to the border doesn't run into visited or seg_cells
                        nr = marker_pos[0] + directions[nd][0]
                        nc = marker_pos[1] + directions[nd][1]
                        tail_ok = True
                        while 0 <= nr < N and 0 <= nc < N:
                            if (nr,nc) in visited or (nr,nc) in seg_cells:
                                tail_ok = False
                                break
                            nr += directions[nd][0]
                            nc += directions[nd][1]
                        if not tail_ok:
                            continue
                    # commit this marker
                    # segment cells to color exclude the marker cell (we will color cells strictly on background)
                    seg_cells_excl_marker = seg_cells[:-1]
                    path_segments.append(seg_cells_excl_marker)
                    markers.append((marker_pos, color))
                    # add all seg_cells including marker to visited
                    for cell in seg_cells:
                        visited.add(cell)
                    current_pos = marker_pos
                    current_dir = nd
                    placed = True
                    break
                if placed:
                    break
            if not placed:
                ok = False
                break

        if not ok:
            continue

        # build tail cells until exit; ensure they don't collide
        tail_cells = []
        dr,dc = directions[current_dir]
        r,c = current_pos
        while True:
            r += dr; c += dc
            if not (0 <= r < N and 0 <= c < N):
                break
            if (r,c) in visited:
                ok = False
                break
            tail_cells.append((r,c))
        if not ok:
            continue
        # add tail segment (may be empty if immediate exit)
        path_segments.append(tail_cells)

        # prepare grids
        input_grid = common.grid(N, N, bg)
        for (pos,color) in markers:
            input_grid[pos[0]][pos[1]] = color

        output_grid = [row[:] for row in input_grid]
        # color start cell for initial segment
        if output_grid[0][0] == bg:
            output_grid[0][0] = default_color
        # color each segment
        for si, seg in enumerate(path_segments):
            if si == 0:
                col = default_color
            else:
                col = markers[si-1][1]
            for (r,c) in seg:
                if output_grid[r][c] == bg:
                    output_grid[r][c] = col

        return {'input': input_grid, 'output': output_grid}

    # fallback simple straight line if generation failed (very unlikely)
    input_grid = common.grid(N, N, bg)
    input_grid[0][3] = random.choice(marker_colors)
    output_grid = [row[:] for row in input_grid]
    for c in range(0, N):
        if output_grid[0][c] == bg:
            output_grid[0][c] = default_color
    return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    N = len(grid)
    # identify background color as the most frequent color
    counts = {}
    for r in range(N):
        for c in range(len(grid[r])):
            counts[grid[r][c]] = counts.get(grid[r][c], 0) + 1
    bg = max(counts, key=counts.get)
    # the default segment color used by generator
    default_color = 6
    output_grid = [row[:] for row in grid]
    directions = [(0,1),(1,0),(0,-1),(-1,0)]
    def turn_dir(cdir, color):
        if color == 1:
            return (cdir + 1) % 4
        if color == 2:
            return (cdir + 3) % 4
        if color == 3:
            return (cdir + 2) % 4
        return cdir

    # follow the path from the start, collecting markers in order
    current_pos = (0,0)
    current_dir = 0
    markers = []
    while True:
        r,c = current_pos
        dr,dc = directions[current_dir]
        found = False
        while True:
            r += dr; c += dc
            if not (0 <= r < N and 0 <= c < N):
                break
            val = grid[r][c]
            if 1 <= val <= 4:
                markers.append((r,c,val))
                current_pos = (r,c)
                current_dir = turn_dir(current_dir, val)
                found = True
                break
        if not found:
            break

    # if no markers, draw straight initial segment with default color
    if not markers:
        r,c = 0,0
        dr,dc = directions[0]
        while 0 <= r < N and 0 <= c < N:
            if output_grid[r][c] == bg:
                output_grid[r][c] = default_color
            r += dr; c += dc
        return output_grid

    # draw from start to first marker (inclusive, but markers won't be overwritten)
    fr,fc,_ = markers[0]
    r,c = 0,0
    dr = 0 if fr == r else (1 if fr > r else -1)
    dc = 0 if fc == c else (1 if fc > c else -1)
    while True:
        if output_grid[r][c] == bg:
            output_grid[r][c] = default_color
        if (r,c) == (fr,fc):
            break
        r += dr; c += dc

    # draw segments between markers
    for i in range(len(markers)-1):
        sr,sc,_ = markers[i]
        er,ec,_ = markers[i+1]
        col = markers[i][2]
        r,c = sr,sc
        dr = 0 if er == r else (1 if er > r else -1)
        dc = 0 if ec == c else (1 if ec > c else -1)
        while True:
            if output_grid[r][c] == bg:
                output_grid[r][c] = col
            if (r,c) == (er,ec):
                break
            r += dr; c += dc

    # draw tail after last marker until exit
    last_r, last_c, last_col = markers[-1]
    # compute direction after last marker by re-simulating turns up to last marker
    current_dir = 0
    cur_pos = (0,0)
    for (mr, mc, mcol) in markers:
        # move until we hit the marker (we don't need to check collisions here)
        # determine direction for this movement
        dr,dc = directions[current_dir]
        # advance until marker
        r,c = cur_pos
        while (r,c) != (mr,mc):
            r += dr; c += dc
        # now at marker, update direction
        current_dir = turn_dir(current_dir, mcol)
        cur_pos = (mr,mc)

    dr,dc = directions[current_dir]
    r,c = last_r, last_c
    while True:
        r += dr; c += dc
        if not (0 <= r < N and 0 <= c < N):
            break
        if output_grid[r][c] == bg:
            output_grid[r][c] = last_col

    return output_grid

