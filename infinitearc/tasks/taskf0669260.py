# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: f0669260
Difficulty: hard

=== Tags ===
- Recolor
- Even or odd
- Divide by n

=== Description ===
The input grid consists of a 2D arrangement of colors (0-9), where each color
appears multiple times in varying patterns. The transformation to generate the
output grid follows two sequential rules:  1. **Recoloring based on color
frequency parity**: For each distinct color present in the entire input grid,
count its total occurrences. If the count is even, all cells of that color are
recolored to red (color 2). If the count is odd, all cells are recolored to blue
(color 1). This step ensures that the grid transitions from multiple colors to a
binary red/blue representation based on global frequency properties.  2.
**Division into vertical strips and strip-based recoloring**: The grid is
divided into vertical strips where the number of strips (n) equals the number of
distinct colors in the *original input grid* (not the recolored grid). Each
strip is assigned a unique color from a predefined sequence (green, yellow,
orange, purple, etc.), with the leftmost strip receiving the first color in the
sequence, the next strip the second color, and so on, cycling through the
sequence if n exceeds the available colors. This division requires identifying
the original color count before recoloring, making the rule sequence-dependent.
The output grid must differ from the input due to both the parity-based
recoloring and the strip-based transformation. The task demands recognizing
global color frequency patterns, maintaining awareness of original color counts
during transformation, and applying multi-step spatial reasoning to divide and
recolor sections. Complex input grids feature irregular arrangements of many
colors (e.g., 5+ distinct colors), requiring careful tracking of frequency
parities and strip assignments to avoid errors.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    n = random.randint(3, 7)
    width = random.randint(1, 30)
    while width % n != 0 or width < n:
        width = random.randint(1, 30)
    height = random.randint(1, 30)
    colors = random.sample(range(1, 10), n)
    input_grid = [[random.choice(colors) for _ in range(width)] for _ in range(height)]
    while not all(any(color in row for row in input_grid) for color in colors):
        input_grid = [[random.choice(colors) for _ in range(width)] for _ in range(height)]
    strip_colors = [3, 4, 7, 6, 8, 9]
    output_grid = [[0] * width for _ in range(height)]
    strip_width = width // n
    for r in range(height):
        for c in range(width):
            strip_idx = c // strip_width
            output_grid[r][c] = strip_colors[strip_idx % len(strip_colors)]
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid:
        return []
    colors = set()
    for row in input_grid:
        for color in row:
            colors.add(color)
    n = len(colors)
    width = len(input_grid[0])
    height = len(input_grid)
    strip_width = width // n
    strip_colors = [3, 4, 7, 6, 8, 9]
    output = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            strip_idx = c // strip_width
            output[r][c] = strip_colors[strip_idx % len(strip_colors)]
    return output
