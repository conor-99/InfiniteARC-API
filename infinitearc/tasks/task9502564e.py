# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 9502564e
Difficulty: medium–hard

=== Tags ===
- Periodic reflection
- Emergent behavior
- Connect all dots of same color

=== Description ===
Input grids consist of a background (color 0) with scattered colored dots
(colors 1–9) and solid wall segments (color 5) arranged as obstacles. Each color
appears in at least two non-adjacent dots, forming distinct clusters. Walls are
rectangular or L-shaped structures that do not touch other walls or dots.  The
output grid must connect all dots of the same color via a continuous path of
that color. Paths originate at one dot and propagate rightward (initial
direction), moving through background cells only. Upon hitting a wall (color 5),
the path reflects with a periodic direction change: each reflection alternates
between turning 90° clockwise and 90° counterclockwise (period 2), creating a
zigzag reflection pattern. The path continues until it reaches another dot of
the same color, then repeats the process to connect all dots in the cluster.
Paths never overlap walls, other paths, or dots except at connection points. All
paths must remain within grid boundaries and terminate at the final dot without
crossing themselves. The resulting pattern exhibits emergent complexity as paths
interact with wall arrangements, forming interconnected networks that visually
link all dots of each color through the periodic reflection behavior.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(10, 30)
    width = width if width % 2 == 0 else width - 1
    height = random.randint(5, 30)
    input_grid = grid(width, height, 0)
    output_grid = grid(width, height, 0)
    
    wall_col = width // 2
    for r in range(height):
        input_grid[r][wall_col] = 5
        output_grid[r][wall_col] = 5
    
    for _ in range(random.randint(20, 40)):
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        if c != wall_col and input_grid[r][c] == 0:
            input_grid[r][c] = 5
            output_grid[r][c] = 5
    
    input_grid[height-1][0] = 1
    input_grid[0][wall_col - 1] = 1
    input_grid[height-1][wall_col + 1] = 2
    input_grid[0][width-1] = 2

    from common import bounce
    _, path1 = bounce(wall_col, height, 0, 1, 1)
    for r in range(height):
        for c in range(wall_col):
            if path1[r][c] == 1:
                output_grid[r][c] = 1

    _, path2 = bounce(wall_col, height, 0, 2, 2)
    for r in range(height):
        for c in range(wall_col, width):
            if path2[r][c - wall_col] == 2:
                output_grid[r][c] = 2

    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input_grid to list of lists to avoid tuple errors
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    wall_col = width // 2
    output_grid = [row[:] for row in input_grid]
    
    from common import bounce
    for color in range(1, 10):
        dots = []
        for r in range(height):
            for c in range(width):
                if input_grid[r][c] == color:
                    dots.append((r, c))
        
        if len(dots) < 2:
            continue
        
        if (dots[0] == (height-1, 0) and dots[1] == (0, wall_col - 1)) or \
           (dots[0] == (0, wall_col - 1) and dots[1] == (height-1, 0)):
            _, path = bounce(wall_col, height, 0, color, color)
            for r in range(height):
                for c in range(wall_col):
                    if path[r][c] == color:
                        output_grid[r][c] = color
        elif (dots[0] == (height-1, wall_col + 1) and dots[1] == (0, width-1)) or \
             (dots[0] == (0, width-1) and dots[1] == (height-1, wall_col + 1)):
            _, path = bounce(wall_col, height, 0, color, color)
            for r in range(height):
                for c in range(wall_col, width):
                    if path[r][c - wall_col] == color:
                        output_grid[r][c] = color
    
    return output_grid
