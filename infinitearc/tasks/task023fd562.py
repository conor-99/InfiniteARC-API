# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 023fd562
Difficulty: insane

=== Tags ===
- Draw rectangle
- Count hor lines
- Pattern moving

=== Description ===
The input grid features horizontal lines, defined as rows where all cells share
the same non-zero color (e.g., solid red rows). The largest connected region of
a single color (not part of any horizontal line) is identified as the primary
pattern. The output grid is generated by first counting the horizontal lines
(C), then moving the primary pattern to the right by C columns (clamped to grid
boundaries), and finally enclosing the new position of the pattern within a
minimal bounding box rectangle with a one-cell border. The rectangle uses a
distinct color (e.g., cyan) that does not appear in the input, ensuring visual
separation. This task requires recognizing multiple visual features (horizontal
lines, pattern connectivity), applying a quantitative count to determine
movement, and synthesizing a new geometric element (rectangle) around the
transformed patternâ€”all while avoiding reliance on numerical values or pixel-
level details.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    from common import grid, all_pixels

    width = random.randint(1, 30)
    height = random.randint(1, 30)
    border_color = 8  # Cyan (will be used for rectangle border)
    
    # Create empty grid (background 0)
    input_grid = grid(width, height, 0)
    
    # Create horizontal lines (rows with uniform non-zero color)
    num_horizontal = random.randint(1, min(3, height))
    horizontal_rows = random.sample(range(height), num_horizontal)
    for r in horizontal_rows:
        color = random.randint(1, 7)
        for c in range(width):
            input_grid[r][c] = color
    
    # Create pattern (largest connected region not in horizontal lines)
    non_horizontal_rows = [r for r in range(height) if r not in horizontal_rows]
    if not non_horizontal_rows:
        return generate()  # Ensure at least one row for pattern
    
    # Choose pattern color (avoiding horizontal line colors and border)
    pattern_color = random.randint(1, 7)
    while pattern_color in [input_grid[r][0] for r in horizontal_rows if input_grid[r][0] != 0]:
        pattern_color = random.randint(1, 7)
    
    # Create large rectangle for pattern
    min_r = min(non_horizontal_rows)
    max_r = max(non_horizontal_rows)
    min_c = random.randint(0, width // 2)
    max_c = random.randint(width // 2, width - 1)
    
    # Fill rectangle with pattern_color
    for r in range(min_r, max_r + 1):
        for c in range(min_c, max_c + 1):
            input_grid[r][c] = pattern_color
    
    # Add small regions to ensure pattern is largest
    for _ in range(random.randint(1, 5)):
        color = random.randint(1, 7)
        while color == pattern_color or color in [input_grid[r][0] for r in horizontal_rows if input_grid[r][0] != 0]:
            color = random.randint(1, 7)
        r = random.choice(non_horizontal_rows)
        c = random.randint(0, width - 1)
        input_grid[r][c] = color
    
    # Ensure border_color (8) is not present
    if any(input_grid[r][c] == border_color for r in range(height) for c in range(width)):
        return generate()
    
    # Compute output grid from input
    horizontal_lines = []
    for r in range(height):
        if all(input_grid[r][c] == input_grid[r][0] and input_grid[r][0] != 0 for c in range(width)):
            horizontal_lines.append(r)
    C = len(horizontal_lines)
    
    # Find largest connected region (not in horizontal lines)
    mask = [[True] * width for _ in range(height)]
    for r in horizontal_lines:
        for c in range(width):
            mask[r][c] = False
    
    visited = [[False] * width for _ in range(height)]
    max_region = []
    for r in range(height):
        for c in range(width):
            if mask[r][c] and input_grid[r][c] != 0 and not visited[r][c]:
                region = []
                stack = [(r, c)]
                visited[r][c] = True
                color = input_grid[r][c]
                while stack:
                    sr, sc = stack.pop()
                    region.append((sr, sc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = sr + dr, sc + dc
                        if 0 <= nr < height and 0 <= nc < width and mask[nr][nc] and input_grid[nr][nc] == color and not visited[nr][nc]:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                if len(region) > len(max_region):
                    max_region = region
    
    # Ensure max_region is not empty
    if not max_region:
        return generate()
    
    # Shift pattern right by C columns
    new_region = []
    for (r, c) in max_region:
        new_c = min(c + C, width - 1)
        new_region.append((r, new_c))
    
    # Create output grid (copy input)
    output_grid = [row[:] for row in input_grid]
    
    # Remove original pattern
    for (r, c) in max_region:
        output_grid[r][c] = 0
    
    # Place new pattern
    for (r, c) in new_region:
        output_grid[r][c] = pattern_color
    
    # Draw border rectangle around new pattern
    min_row = min(r for r, c in new_region)
    max_row = max(r for r, c in new_region)
    min_col = min(c for r, c in new_region)
    max_col = max(c for r, c in new_region)
    
    border_top = max(0, min_row - 1)
    border_bottom = min(height - 1, max_row + 1)
    border_left = max(0, min_col - 1)
    border_right = min(width - 1, max_col + 1)
    
    for c in range(border_left, border_right + 1):
        output_grid[border_top][c] = border_color
        output_grid[border_bottom][c] = border_color
    for r in range(border_top + 1, border_bottom):
        output_grid[r][border_left] = border_color
        output_grid[r][border_right] = border_color
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    
    # Identify horizontal lines (uniform non-zero rows)
    horizontal_lines = []
    for r in range(height):
        if all(input_grid[r][c] == input_grid[r][0] and input_grid[r][0] != 0 for c in range(width)):
            horizontal_lines.append(r)
    C = len(horizontal_lines)
    
    # Create mask for non-horizontal-line cells
    mask = [[True] * width for _ in range(height)]
    for r in horizontal_lines:
        for c in range(width):
            mask[r][c] = False
    
    # Find largest connected region (not in horizontal lines)
    visited = [[False] * width for _ in range(height)]
    max_region = []
    pattern_color = None
    for r in range(height):
        for c in range(width):
            if mask[r][c] and input_grid[r][c] != 0 and not visited[r][c]:
                region = []
                stack = [(r, c)]
                visited[r][c] = True
                color = input_grid[r][c]
                while stack:
                    sr, sc = stack.pop()
                    region.append((sr, sc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = sr + dr, sc + dc
                        if 0 <= nr < height and 0 <= nc < width and mask[nr][nc] and input_grid[nr][nc] == color and not visited[nr][nc]:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                if len(region) > len(max_region):
                    max_region = region
                    pattern_color = color
    
    # If no valid region found, return input (shouldn't happen in valid task)
    if not max_region:
        return input_grid
    
    # Shift pattern right by C columns
    new_region = []
    for (r, c) in max_region:
        new_c = min(c + C, width - 1)
        new_region.append((r, new_c))
    
    # Compute bounding box for new pattern
    min_row = min(r for r, c in new_region)
    max_row = max(r for r, c in new_region)
    min_col = min(c for r, c in new_region)
    max_col = max(c for r, c in new_region)
    
    # Create output grid from input
    output_grid = [list(row) for row in input_grid]
    
    # Remove original pattern
    for (r, c) in max_region:
        output_grid[r][c] = 0
    
    # Place new pattern
    for (r, c) in new_region:
        output_grid[r][c] = pattern_color
    
    # Draw rectangle border using fixed color (matches generator)
    border_color = 8
    border_top = max(0, min_row - 1)
    border_bottom = min(height - 1, max_row + 1)
    border_left = max(0, min_col - 1)
    border_right = min(width - 1, max_col + 1)
    
    for c in range(border_left, border_right + 1):
        output_grid[border_top][c] = border_color
        output_grid[border_bottom][c] = border_color
    for r in range(border_top + 1, border_bottom):
        output_grid[r][border_left] = border_color
        output_grid[r][border_right] = border_color
    
    return output_grid
