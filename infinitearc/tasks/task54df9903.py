# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 54df9903
Difficulty: medium

=== Tags ===
- Wraparound copy
- Draw path through ordered checkpoints
- Recolor object based on its size

=== Description ===
The task involves transforming an input grid into an output grid through three
sequential operations. The input grid contains distinct connected regions
(objects) of various colors, along with checkpoint markers of a specific color
(e.g., color 4). The transformation proceeds as follows:    1. **Recolor objects
based on size**: Each connected object (4-connected) is recolored depending on
its size (number of pixels):      - Small objects (≤3 pixels) → red (color 2).
- Medium objects (4–6 pixels) → blue (color 1).      - Large objects (≥7 pixels)
→ green (color 3).    2. **Identify ordered checkpoints**: Checkpoint markers
(color 4) are ordered left-to-right, top-to-bottom (row-major order) to form a
sequence.    3. **Draw path with wraparound**: A continuous path connects
consecutive checkpoints in the sequence. Movement between checkpoints follows
horizontal/vertical directions, wrapping around grid edges (e.g., moving right
from the rightmost column continues at the leftmost column). The path is drawn
using a fixed color (e.g., color 7), overriding any existing grid content along
the path.    The output grid reflects the recolored objects and the path,
ensuring all rules are applied consistently. The task requires recognizing
object connectivity, size-based color mapping, checkpoint sequencing, and
wraparound path drawing—all visual, rule-based operations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = [[0] * width for _ in range(height)]
    
    num_objects = random.randint(3, 5)
    colors = [1, 2, 3, 5, 6, 8, 9]
    
    for _ in range(num_objects):
        color = random.choice(colors)
        size = random.randint(3, 10)
        pixels = common.continuous_creature(size, width, height)
        rows = [p[0] for p in pixels]
        cols = [p[1] for p in pixels]
        for r, c in zip(rows, cols):
            grid[r][c] = color
    
    num_checkpoints = random.randint(2, 5)
    checkpoints = []
    for _ in range(num_checkpoints):
        while True:
            r = random.randint(0, height - 1)
            c = random.randint(0, width - 1)
            if grid[r][c] == 0:
                grid[r][c] = 4
                checkpoints.append((r, c))
                break
    
    output = [row[:] for row in grid]
    
    visited = [[False] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and grid[r][c] != 0 and grid[r][c] != 4:
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] != 0 and grid[nr][nc] != 4:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                size = len(component)
                if size <= 3:
                    new_color = 2
                elif size <= 6:
                    new_color = 1
                else:
                    new_color = 3
                for (cr, cc) in component:
                    output[cr][cc] = new_color
    
    checkpoints.sort(key=lambda x: (x[0], x[1]))
    
    for i in range(len(checkpoints) - 1):
        r1, c1 = checkpoints[i]
        r2, c2 = checkpoints[i+1]
        current_col = c1
        while current_col != c2:
            output[r1][current_col] = 7
            if (c2 - current_col) % width <= (current_col - c2) % width:
                current_col = (current_col + 1) % width
            else:
                current_col = (current_col - 1) % width
        current_row = r1
        while current_row != r2:
            output[current_row][c2] = 7
            if (r2 - current_row) % height <= (current_row - r2) % height:
                current_row = (current_row + 1) % height
            else:
                current_row = (current_row - 1) % height
    
    return {'input': grid, 'output': output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common


def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output = [list(row) for row in input_grid]
    
    visited = [[False] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and input_grid[r][c] != 0 and input_grid[r][c] != 4:
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] != 0 and input_grid[nr][nc] != 4:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                size = len(component)
                if size <= 3:
                    new_color = 2
                elif size <= 6:
                    new_color = 1
                else:
                    new_color = 3
                for (cr, cc) in component:
                    output[cr][cc] = new_color
    
    checkpoints = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 4:
                checkpoints.append((r, c))
    
    checkpoints.sort(key=lambda x: (x[0], x[1]))
    
    for i in range(len(checkpoints) - 1):
        r1, c1 = checkpoints[i]
        r2, c2 = checkpoints[i+1]
        current_col = c1
        while current_col != c2:
            output[r1][current_col] = 7
            if (c2 - current_col) % width <= (current_col - c2) % width:
                current_col = (current_col + 1) % width
            else:
                current_col = (current_col - 1) % width
        current_row = r1
        while current_row != r2:
            output[current_row][c2] = 7
            if (r2 - current_row) % height <= (current_row - r2) % height:
                current_row = (current_row + 1) % height
            else:
                current_row = (current_row - 1) % height
    
    return output
