# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 4ee02a75
Difficulty: very hard

=== Tags ===
- Multi step traversal

=== Description ===
Task Name: Path-Triggered Transformation Cascade  Description: Input grids
contain a single, continuous path of colored cells (colors 2-9), starting from a
unique entrance cell (color 1) and extending to an exit point. The path winds
through the grid without crossing or overlapping itself. Each cell along the
path corresponds to a transformation rule that must be applied to the grid in
the order of traversal. The transformations include operations such as grid
rotation, reflection, color replacement, or shape modification. The background
color (0) remains unchanged. The output grid is the result of sequentially
applying all transformation rules along the path. The path itself is preserved
in the output, with each cell's color indicating the rule applied at that step.
Transformations interact cumulativelyâ€”the application of one rule affects
subsequent transformations. The path direction (left-to-right, top-to-bottom,
etc.) determines the sequence of rule application, and the final output requires
recognizing the color-to-rule mapping through multiple input-output examples.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(8, 20)
    height = random.randint(8, 20)
    input_grid = grid(width, height, 0)
    
    path = [(0, 0)]
    input_grid[0][0] = 1
    
    colors = [2, 3]
    for color_val in colors:
        dr, dc = random.choice([(0, 1), (1, 0)])
        r, c = path[-1]
        new_r, new_c = r + dr, c + dc
        if new_r >= height or new_c >= width:
            new_r, new_c = r - dr, c - dc
        path.append((new_r, new_c))
        input_grid[new_r][new_c] = color_val
    
    content_start = (4, 4)
    for r in range(3):
        for c in range(3):
            input_grid[content_start[0] + r][content_start[1] + c] = 5
    
    output_grid = [row[:] for row in input_grid]
    
    transformation_map = {
        2: lambda g: list(zip(*g[::-1])),
        3: lambda g: [row[::-1] for row in g]
    }
    
    for color_val in colors:
        output_grid = transformation_map[color_val](output_grid)
        output_grid = [list(row) for row in output_grid]  # Convert tuples to lists
        for (r, c), color in zip(path, [1,2,3]):
            output_grid[r][c] = color
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    
    # Find path
    path = []
    start = None
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 1:
                start = (r, c)
                break
        if start:
            break
    if not start:
        start = (0, 0)
    
    path.append(start)
    current = start
    next_color = 2
    while True:
        found = False
        for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:
            nr, nc = current[0] + dr, current[1] + dc
            if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == next_color:
                path.append((nr, nc))
                current = (nr, nc)
                next_color += 1
                found = True
                break
        if not found:
            break
    
    # Apply transformations
    transformation_map = {
        2: lambda g: list(zip(*g[::-1])),
        3: lambda g: [row[::-1] for row in g]
    }
    
    output_grid = [row[:] for row in input_grid]
    for color_val in range(2, next_color):
        if color_val in transformation_map:
            output_grid = transformation_map[color_val](output_grid)
            output_grid = [list(row) for row in output_grid]  # Convert tuples to lists
        for (r, c), color in zip(path, [1] + list(range(2, next_color))):
            output_grid[r][c] = color
    
    return output_grid
