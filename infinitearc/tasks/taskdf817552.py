# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: df817552
Difficulty: hard

=== Tags ===
- Bounce
- Bouncing
- Context sensitive recolor
- Sort columns by criteria

=== Description ===
The task involves transforming an input grid through a multi-step process based
on a bouncing path and context-sensitive recoloring. The input grid is a 2D
arrangement of colors (0-9) with a distinct pattern of color 5 cells. The
transformation begins by simulating a bouncing path that starts at the bottom-
left corner (height-1, 0) and moves diagonally upward-right (direction: row
decreases, column increases). Upon hitting a grid edge (top, bottom, left, or
right), the path reverses direction along that axis (e.g., hitting the top edge
reverses the row direction, hitting the right edge reverses the column
direction). As the path traverses the grid, any cell along its route with color
5 is recolored to color 3 (context-sensitive: only color 5 cells on the path are
affected). After recoloring, the columns of the grid are sorted in descending
order based on the count of color 3 cells in each column. The output grid
reflects both the recoloring along the bouncing path and the reordered columns.
For hard difficulty, the input grid features a complex background with color 5
cells distributed non-uniformly, a long bouncing path covering most of the grid
(requiring precise path calculation), and columns with near-identical counts of
color 3 cells to avoid trivial sorting. The solver must identify the path, apply
the context-dependent recoloring, and perform the column sortâ€”all without
relying on pixel-level patterns or numerical sums.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def compute_bouncing_path(width, height):
    path = []
    visited = set()
    r, c = height - 1, 0
    dr, dc = -1, 1
    while (r, c) not in visited:
        if 0 <= r < height and 0 <= c < width:
            visited.add((r, c))
            path.append((r, c))
        next_r = r + dr
        next_c = c + dc
        if next_r < 0 or next_r >= height or next_c < 0 or next_c >= width:
            if next_r < 0:
                dr = 1
            elif next_r >= height:
                dr = -1
            if next_c < 0:
                dc = 1
            elif next_c >= width:
                dc = -1
        r, c = r + dr, c + dc
    return path

def generate():
    width = random.randint(2, 30)
    height = random.randint(1, 30)
    path = compute_bouncing_path(width, height)
    input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
    
    if not any(input_grid[r][c] == 5 for (r, c) in path):
        r, c = random.choice(path)
        input_grid[r][c] = 5
    
    intermediate = [row[:] for row in input_grid]
    for (r, c) in path:
        if intermediate[r][c] == 5:
            intermediate[r][c] = 3
    
    col_counts = [0] * width
    for c in range(width):
        for r in range(height):
            if intermediate[r][c] == 3:
                col_counts[c] += 1
    
    while all(x == col_counts[0] for x in col_counts):
        input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
        if not any(input_grid[r][c] == 5 for (r, c) in path):
            r, c = random.choice(path)
            input_grid[r][c] = 5
        intermediate = [row[:] for row in input_grid]
        for (r, c) in path:
            if intermediate[r][c] == 5:
                intermediate[r][c] = 3
        col_counts = [0] * width
        for c in range(width):
            for r in range(height):
                if intermediate[r][c] == 3:
                    col_counts[c] += 1
    
    sorted_cols = sorted(range(width), key=lambda c: col_counts[c], reverse=True)
    output_grid = [[intermediate[r][c] for c in sorted_cols] for r in range(height)]
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random

def compute_bouncing_path(width, height):
    path = []
    visited = set()
    r, c = height - 1, 0
    dr, dc = -1, 1
    while (r, c) not in visited:
        if 0 <= r < height and 0 <= c < width:
            visited.add((r, c))
            path.append((r, c))
        next_r = r + dr
        next_c = c + dc
        if next_r < 0 or next_r >= height or next_c < 0 or next_c >= width:
            if next_r < 0:
                dr = 1
            elif next_r >= height:
                dr = -1
            if next_c < 0:
                dc = 1
            elif next_c >= width:
                dc = -1
        r, c = r + dr, c + dc
    return path

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    if not input_grid:
        return input_grid
    height = len(input_grid)
    width = len(input_grid[0])
    
    path = compute_bouncing_path(width, height)
    
    intermediate = [row[:] for row in input_grid]
    for (r, c) in path:
        if intermediate[r][c] == 5:
            intermediate[r][c] = 3
    
    col_counts = [0] * width
    for c in range(width):
        for r in range(height):
            if intermediate[r][c] == 3:
                col_counts[c] += 1
    
    sorted_cols = sorted(range(width), key=lambda c: col_counts[c], reverse=True)
    
    output_grid = [[intermediate[r][c] for c in sorted_cols] for r in range(height)]
    return output_grid
