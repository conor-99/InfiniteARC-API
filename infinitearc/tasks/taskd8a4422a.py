# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: d8a4422a
Difficulty: mediumâ€“hard

=== Tags ===
- Example condition induction

=== Description ===
Input grids consist of a background color (0) and foreground colors (1-9),
arranged in connected regions. The output grid is identical to the input unless
a single connected region (of any foreground color) spans from the top edge to
the bottom edge of the grid. A spanning region is defined as a connected
component (via edge-adjacent cells) that includes at least one cell in the top
row and at least one cell in the bottom row. If such a region exists, all cells
within that region are changed to color 5; otherwise, the output remains
unchanged. The solver must induce the condition that triggers the transformation
(presence of a vertically spanning connected region) through examination of
input-output examples.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    """
    Generate a grid where background is 0 and there is at least one connected foreground
    region that spans from the top row to the bottom row. That spanning region's color
    will never be 5 so that the output differs from the input. Additional random
    non-spanning foreground regions (rectangles and pixels) are added away from the
    spanning column to increase variety.

    Returns:
      A dict with keys "input" and "output", each a 2D list of ints.
    """
    # Size: keep within allowed bounds but avoid extremely small sizes to allow
    # creation of non-spanning components away from the spanning column.
    width = random.randint(3, 20)
    height = random.randint(2, 20)

    # Initialize background
    grid = [[0 for _ in range(width)] for _ in range(height)]

    # Choose a spanning column and a color for that spanning region (not color 5).
    span_col = random.randint(0, width - 1)
    span_color = random.choice([c for c in range(1, 10) if c != 5])

    # Create the vertically spanning connected region (fill entire column)
    for r in range(height):
        grid[r][span_col] = span_color

    # Add a few random rectangles that do NOT touch or edge-touch the spanning column.
    # This keeps those components disconnected from the spanning region.
    rect_count = random.randint(0, 4)
    for _ in range(rect_count):
        # rectangle size
        rw = random.randint(1, min(4, width))
        rh = random.randint(1, max(1, height - 1))
        if rh >= height:
            rh = height - 1
        # compute candidates for left column so that rectangle columns do not include
        # span_col-1, span_col, or span_col+1 (ensuring at least one column gap)
        blocked = {span_col - 1, span_col, span_col + 1}
        candidates = [c0 for c0 in range(0, width - rw + 1)
                      if not (set(range(c0, c0 + rw)) & blocked)]
        if not candidates:
            continue
        c0 = random.choice(candidates)
        r0 = random.randint(0, height - rh)
        color = random.randint(1, 9)
        # Fill rectangle
        for rr in range(r0, r0 + rh):
            for cc in range(c0, c0 + rw):
                grid[rr][cc] = color

    # Add some scattered single pixels away from the spanning column (to keep variety)
    pixel_count = random.randint(0, 6)
    for _ in range(pixel_count):
        # pick a column that is not span_col-1/span_col/span_col+1
        blocked = {span_col - 1, span_col, span_col + 1}
        possible = [(r, c) for r in range(height) for c in range(width)
                    if c not in blocked and grid[r][c] == 0]
        if not possible:
            break
        r, c = random.choice(possible)
        grid[r][c] = random.randint(1, 9)

    # Compute the correct output by finding connected components (4-neighbors)
    # and turning any component that touches both top and bottom rows to color 5.
    def compute_output(inp):
        h = len(inp)
        w = len(inp[0]) if h > 0 else 0
        visited = [[False] * w for _ in range(h)]
        out = [row[:] for row in inp]
        for rr in range(h):
            for cc in range(w):
                if visited[rr][cc]:
                    continue
                visited[rr][cc] = True
                col = inp[rr][cc]
                if col == 0:
                    continue
                # floodfill
                stack = [(rr, cc)]
                comp = []
                touches_top = False
                touches_bottom = False
                while stack:
                    pr, pc = stack.pop()
                    comp.append((pr, pc))
                    if pr == 0:
                        touches_top = True
                    if pr == h - 1:
                        touches_bottom = True
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = pr + dr, pc + dc
                        if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and inp[nr][nc] == col:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                if touches_top and touches_bottom:
                    for pr, pc in comp:
                        out[pr][pc] = 5
        return out

    output = compute_output(grid)

    # Ensure input != output (the spanning column color is never 5, so this is guaranteed)
    assert grid != output

    return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    """
    Solver: find any 4-connected foreground component that touches both the top and
    bottom rows, and change all cells in such components to color 5. Return the
    resulting grid as a tuple of tuples.
    """
    # Convert to mutable list of lists
    inp = [list(row) for row in input_grid]
    h = len(inp)
    if h == 0:
        return tuple(tuple(row) for row in inp)
    w = len(inp[0])

    visited = [[False] * w for _ in range(h)]
    out = [row[:] for row in inp]

    for r in range(h):
        for c in range(w):
            if visited[r][c]:
                continue
            visited[r][c] = True
            color = inp[r][c]
            if color == 0:
                continue
            # BFS / DFS to collect component
            stack = [(r, c)]
            comp = []
            touches_top = False
            touches_bottom = False
            while stack:
                pr, pc = stack.pop()
                comp.append((pr, pc))
                if pr == 0:
                    touches_top = True
                if pr == h - 1:
                    touches_bottom = True
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = pr + dr, pc + dc
                    if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and inp[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            if touches_top and touches_bottom:
                for pr, pc in comp:
                    out[pr][pc] = 5

    return tuple(tuple(row) for row in out)

