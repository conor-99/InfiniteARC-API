# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 46ab9e5e
Difficulty: hard

=== Tags ===
- Periodic reflection
- One yes one no
- Image rotation

=== Description ===
The input grid consists of a sequence of contiguous colored shapes arranged in a
horizontal line, each shape being a connected region of a single non-background
color (0). The shapes alternate between two specific colors in a strict periodic
patternâ€”color A (e.g., red) followed by color B (e.g., blue), repeating
indefinitely. The output grid reflects each shape of color A horizontally
(mirroring it along its vertical axis) while leaving shapes of color B
unchanged. The reflection is applied per shape, preserving its position and
relative placement within the sequence. The periodic alternation of color A and
color B ensures that "one yes (reflected)" and "one no (unreflected)" shape
appear consecutively, creating a visually consistent transformation. The
background remains unchanged, and the task requires identifying the alternating
color pattern and applying the reflection selectively to shapes of color A.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    colors = list(range(1, 10))
    A, B = random.sample(colors, 2)
    num_shapes = random.randint(2, 5)
    height = random.randint(3, 5)
    width = 30
    input_grid = [[0] * width for _ in range(height)]
    
    current_col = 0
    shapes = []
    
    for i in range(num_shapes):
        color = A if i % 2 == 0 else B
        size = random.randint(3, 8)
        
        if color == A:
            while True:
                pixels = common.continuous_creature(size, 5, 5)
                if not pixels:
                    continue
                max_col = max(c for _, c in pixels)
                asymmetric = False
                for r, c in pixels:
                    if (r, max_col - c) not in pixels:
                        asymmetric = True
                        break
                if asymmetric:
                    break
        else:
            pixels = common.continuous_creature(size, 5, 5)
            if not pixels:
                continue
        
        min_col = min(c for _, c in pixels)
        adjusted_pixels = []
        for r, c in pixels:
            new_col = current_col + (c - min_col)
            if 0 <= r < height and 0 <= new_col < width:
                adjusted_pixels.append((r, new_col))
                input_grid[r][new_col] = color
        shapes.append((color, adjusted_pixels))
        
        max_col_in_shape = max(c for _, c in adjusted_pixels)
        current_col = max_col_in_shape + 1
    
    output_grid = [row[:] for row in input_grid]
    for color, pixels in shapes:
        if color == A:
            min_col = min(c for _, c in pixels)
            max_col = max(c for _, c in pixels)
            for r, c in pixels:
                output_grid[r][c] = 0
            for r, c in pixels:
                new_c = min_col + (max_col - c)
                output_grid[r][new_c] = color
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    leftmost_color = None
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                leftmost_color = grid[r][c]
                break
        if leftmost_color is not None:
            break
    if leftmost_color is None:
        return input_grid
    
    colors = set()
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                colors.add(grid[r][c])
    B = next(iter(colors - {leftmost_color}))
    
    visited = [[False] * width for _ in range(height)]
    shapes = []
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and grid[r][c] != 0:
                color = grid[r][c]
                pixels = []
                stack = [(r, c)]
                visited[r][c] = True
                while stack:
                    cr, cc = stack.pop()
                    pixels.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                shapes.append((color, pixels))
    
    for color, pixels in shapes:
        if color == leftmost_color:
            min_col = min(c for _, c in pixels)
            max_col = max(c for _, c in pixels)
            for r, c in pixels:
                grid[r][c] = 0
            for r, c in pixels:
                new_c = min_col + (max_col - c)
                grid[r][new_c] = color
    
    return tuple(tuple(row) for row in grid)
