# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 5afc30e5
Difficulty: hard

=== Tags ===
- Image expansion
- Pattern coloring
- Detect repetition

=== Description ===
The task involves transforming an input grid into an output grid by detecting
the minimal repeating pattern in each row, determining its repetition count R,
and expanding the grid by replacing each element with R copies of the number R.
The input grid consists of rows where each row is composed of R repetitions of a
minimal pattern of length L (input row length = L × R). The output grid
maintains the same number of rows as the input but expands each row to length (L
× R) × R = input row length × R, filling all elements with the value R. The key
challenge lies in identifying the minimal period L of the repeating pattern in
each row to compute R, which dictates the expansion and coloring. This requires
abstract reasoning to detect repetition patterns and apply the consistent rule
across the grid, making it suitable for a hard difficulty task.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate_pattern(L):
    while True:
        pattern = [random.randint(0, 9) for _ in range(L)]
        if is_minimal_period(pattern, L):
            return pattern

def is_minimal_period(pattern, L):
    for d in range(1, L):
        if L % d == 0:
            if is_periodic(pattern, d):
                return False
    return True

def is_periodic(pattern, d):
    for i in range(len(pattern)):
        if pattern[i] != pattern[i % d]:
            return False
    return True

def generate():
    rows = random.randint(1, 30)
    cols = random.randint(1, 30)
    
    valid_L = []
    for L in range(1, cols + 1):
        if cols % L != 0:
            continue
        if cols * cols / L <= 30:
            valid_L.append(L)
    
    if not valid_L:
        cols = 1
        valid_L = [1]
    
    L = random.choice(valid_L)
    R = cols // L
    
    pattern = generate_pattern(L)
    input_grid = [pattern * R for _ in range(rows)]
    
    output_grid = [[R] * (cols * R) for _ in range(rows)]
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid:
        return []
    n = len(input_grid[0])
    L = 1
    while L <= n:
        if n % L == 0:
            valid = True
            for i in range(n):
                if input_grid[0][i] != input_grid[0][i % L]:
                    valid = False
                    break
            if valid:
                break
        L += 1
    R = n // L
    output_grid = [[R] * (n * R) for _ in range(len(input_grid))]
    return output_grid
