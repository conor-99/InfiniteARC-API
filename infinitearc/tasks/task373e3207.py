# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 373e3207
Difficulty: very hard

=== Tags ===
- Color signal exchange
- Replace pattern
- Fill smallest enclosed hole

=== Description ===
Input grids feature a background color (0) overlaid with multiple disjoint,
connected colored regions (1-9), each forming a shape with no internal holes.
These shapes may collectively enclose background regions that are completely
surrounded by colored regions, forming enclosed holes (not connected to the grid
boundary). The output grid must replace the smallest enclosed hole (by area)
with a color determined by a visual color signal exchange: the fill color is the
most frequently occurring color among all shapes directly adjacent to the hole's
perimeter. If multiple colors tie for frequency, the highest numerical value
(1-9) is selected. The replacement fills the entire hole with this single color,
preserving all other grid elements exactly as in the input. The smallest hole is
uniquely determined by area, and the color signal exchange relies solely on
visual adjacency of regions without numerical computation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    w = random.randint(5, 30)
    h = random.randint(5, 30)
    grid = [[0] * w for _ in range(h)]
    
    r = random.randint(1, h-2)
    c = random.randint(1, w-2)
    
    colors = [random.randint(1, 9) for _ in range(4)]
    grid[r-1][c] = colors[0]
    grid[r+1][c] = colors[1]
    grid[r][c-1] = colors[2]
    grid[r][c+1] = colors[3]
    
    color_count = {}
    for color in colors:
        color_count[color] = color_count.get(color, 0) + 1
    max_count = max(color_count.values())
    candidates = [color for color, cnt in color_count.items() if cnt == max_count]
    fill_color = max(candidates)
    
    output = [row[:] for row in grid]
    output[r][c] = fill_color
    
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0])
    
    def find_holes(grid):
        h = len(grid)
        w = len(grid[0])
        visited = [[False] * w for _ in range(h)]
        holes = []
        directions = [(1,0), (-1,0), (0,1), (0,-1)]
        
        for i in range(h):
            for j in range(w):
                if grid[i][j] == 0 and not visited[i][j]:
                    component = []
                    queue = [(i, j)]
                    visited[i][j] = True
                    while queue:
                        r, c = queue.pop(0)
                        component.append((r, c))
                        for dr, dc in directions:
                            nr, nc = r + dr, c + dc
                            if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] == 0:
                                visited[nr][nc] = True
                                queue.append((nr, nc))
                    
                    connected_to_edge = False
                    for r, c in component:
                        if r == 0 or r == h-1 or c == 0 or c == w-1:
                            connected_to_edge = True
                            break
                    if not connected_to_edge:
                        holes.append(component)
        return holes
    
    holes = find_holes(grid)
    if not holes:
        return input_grid
    smallest_hole = min(holes, key=len)
    
    adjacent_colors = []
    directions = [(1,0), (-1,0), (0,1), (0,-1)]
    for r, c in smallest_hole:
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            if 0 <= nr < h and 0 <= nc < w and grid[nr][nc] != 0:
                adjacent_colors.append(grid[nr][nc])
    
    from collections import Counter
    count = Counter(adjacent_colors)
    max_count = max(count.values())
    candidates = [color for color, cnt in count.items() if cnt == max_count]
    fill_color = max(candidates)
    
    for r, c in smallest_hole:
        grid[r][c] = fill_color
    
    return [tuple(row) for row in grid]
