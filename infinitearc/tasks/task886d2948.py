# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 886d2948
Difficulty: hard

=== Tags ===
- Coordinate warp
- Shape morphing

=== Description ===
The input grids are composed of multiple distinct colored shapes (each a
connected region of identical color, represented by a single number between 1
and 9) on a uniform background (color 0). Shapes are at least 2×2 in size and do
not overlap with the background or other shapes. The grid dimensions range from
5×5 to 30×30, ensuring sufficient space for visible transformations.  The
transformation follows two sequential steps: 1. **Coordinate Warp**: Apply a
horizontal shear transformation where each cell at position (r, c) in the input
grid moves to position (r, (c + r) mod width) in the output grid. This shifts
each row to the right by a number of columns equal to its row index, with wrap-
around behavior to maintain grid boundaries (e.g., a shift of 3 in a 5-column
grid moves column 4 to column 2). 2. **Shape Morphing**: After the warp, replace
each shape with its hollowed version by retaining only the perimeter pixels of
the shape's bounding box (the interior pixels are set to the background color).
This creates a frame-like structure for each shape while preserving its original
bounding box dimensions.  The output grid must contain all original pixels
rearranged via the warp, with each shape's interior removed to form a hollow
outline. The transformation requires recognizing both the row-dependent
coordinate shift and the subsequent perimeter-based shape modification, making
it challenging due to the need to sequentially apply non-trivial geometric and
topological rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, conway_sprite

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = grid(width, height, 0)
    
    num_shapes = random.randint(2, 4)
    used_colors = []
    
    for _ in range(num_shapes):
        color = random.randint(1, 9)
        while color in used_colors:
            color = random.randint(1, 9)
        used_colors.append(color)
        
        rows, cols = conway_sprite(3, 3, random.randint(0, 2))
        r_start = random.randint(0, height - 3)
        c_start = random.randint(0, width - 3)
        
        for r, c in zip(rows, cols):
            input_grid[r_start + r][c_start + c] = color
    
    temp_grid = apply_warp(input_grid)
    output_grid = hollow_shapes(temp_grid)
    
    return {"input": input_grid, "output": output_grid}

def apply_warp(grid):
    width = len(grid[0])
    height = len(grid)
    new_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            old_c = (c - r) % width
            new_grid[r][c] = grid[r][old_c]
    return new_grid

def hollow_shapes(grid):
    width = len(grid[0])
    height = len(grid)
    output = [row[:] for row in grid]
    
    colors = set()
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                colors.add(grid[r][c])
    
    for color in colors:
        pixels = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == color]
        if not pixels:
            continue
        min_r = min(r for r, c in pixels)
        max_r = max(r for r, c in pixels)
        min_c = min(c for r, c in pixels)
        max_c = max(c for r, c in pixels)
        
        for r in range(min_r, max_r + 1):
            for c in range(min_c, max_c + 1):
                if r == min_r or r == max_r or c == min_c or c == max_c:
                    continue
                else:
                    output[r][c] = 0
    return output


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
from common import grid, conway_sprite

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    width = len(input_list[0])
    height = len(input_list)
    
    temp = apply_warp(input_list)
    output = hollow_shapes(temp)
    
    return tuple(tuple(row) for row in output)

def apply_warp(grid):
    width = len(grid[0])
    height = len(grid)
    new_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            old_c = (c - r) % width
            new_grid[r][c] = grid[r][old_c]
    return new_grid

def hollow_shapes(grid):
    width = len(grid[0])
    height = len(grid)
    output = [row[:] for row in grid]
    
    colors = set()
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                colors.add(grid[r][c])
    
    for color in colors:
        pixels = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == color]
        if not pixels:
            continue
        min_r = min(r for r, c in pixels)
        max_r = max(r for r, c in pixels)
        min_c = min(c for r, c in pixels)
        max_c = max(c for r, c in pixels)
        
        for r in range(min_r, max_r + 1):
            for c in range(min_c, max_c + 1):
                if r == min_r or r == max_r or c == min_c or c == max_c:
                    continue
                else:
                    output[r][c] = 0
    return output
