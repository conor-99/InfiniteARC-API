# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: b38b337e
Difficulty: hard

=== Tags ===
- Mirror pair coordination
- Pressure release
- Momentum conservation path
- Multi stage dependency chain
- Take negative

=== Description ===
Input grids depict a complex pathfinding environment on a uniform background.
The grid contains multiple "mirror pairs" – two identically colored cells
positioned diagonally (e.g., one at (r,c) and another at (r+1,c+1)), each pair
representing a coordinated horizontal-vertical mirror system. A path originates
from the left edge, moving rightward through background cells. The path
encounters mirror pairs sequentially, but reflection only occurs after both
mirrors in a pair are hit in order (first mirror hit, then second mirror). Upon
hitting the second mirror, "pressure release" triggers a reflection: horizontal
mirrors (aligned horizontally in the pair) reflect the path vertically (right →
up), while vertical mirrors (aligned vertically in the pair) reflect
horizontally (up → left). This reflection follows "momentum conservation path"
rules, where each reflection alternates the axis of reflection (horizontal →
vertical → horizontal → vertical) to maintain consistent directional momentum.
The "take negative" rule applies after every two reflections, inverting the
path's direction vector (e.g., after right → up → left, the next reflection
would be down instead of right). The output grid visualizes the complete path
with segments colored by the mirror pair's color, preserving all original mirror
pairs and background. The transformation requires a multi-stage dependency
chain: each reflection depends on the successful completion of the prior
reflection's condition, and the path continues until exiting the grid boundary.
No path segments overwrite mirror pairs, and all reflections strictly adhere to
the momentum and dependency rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    # Create scenes where a path will hit a sequence of mirror pairs.
    # Keep some reserved filler colors (8 and 9) to mark the left column above the start
    # so that the solver can find the intended starting row.
    for attempt in range(500):
        width = random.randint(6, 20)
        height = random.randint(6, 20)
        input_grid = common.grid(width, height, 0)
        output_grid = common.grid(width, height, 0)

        num_pairs = random.randint(2, 5)
        # reserve 8 and 9 for left-column fillers; choose pair colors from 1..7
        available_colors = list(range(1, 8))
        if num_pairs > len(available_colors):
            continue
        colors = random.sample(available_colors, num_pairs)

        # choose a start row with margins to allow upward and downward reflections
        start_row = random.randint(2, max(2, height - 3))
        # mark rows above start_row on left column with alternating filler colors (8 and 9)
        for rr in range(0, start_row):
            input_grid[rr][0] = 8 if (rr % 2 == 0) else 9

        # initialize path
        r, c = start_row, 0
        direction = 'right'
        path = [(r, c)]

        occupied = set()  # cells occupied by mirror pairs
        mirror_pairs = []

        reflection_count = 0
        success = True

        def rotate_left(d):
            return {'right': 'up', 'up': 'left', 'left': 'down', 'down': 'right'}[d]

        def opposite(d):
            return {'right': 'left', 'left': 'right', 'up': 'down', 'down': 'up'}[d]

        # Place pairs sequentially along the planned path so each will be hit in order.
        for i in range(num_pairs):
            color = colors[i]
            placed = False

            if direction == 'right':
                row = r
                min_c1 = c + 1
                max_c1 = width - 2
                if min_c1 > max_c1:
                    success = False
                    break
                cols = list(range(min_c1, max_c1 + 1))
                random.shuffle(cols)
                for c1 in cols:
                    first = (row, c1)
                    second = (row, c1 + 1)
                    if first in occupied or second in occupied:
                        continue
                    blocked = False
                    for cc in range(c + 1, c1 + 1):
                        if (row, cc) in occupied:
                            blocked = True
                            break
                    if blocked:
                        continue
                    # place pair
                    input_grid[first[0]][first[1]] = color
                    input_grid[second[0]][second[1]] = color
                    occupied.add(first)
                    occupied.add(second)
                    mirror_pairs.append({'orientation': 'horizontal', 'first': first, 'second': second, 'color': color})
                    # append path
                    rr, cc = r, c
                    while (rr, cc) != first:
                        cc += 1
                        path.append((rr, cc))
                    cc += 1
                    path.append((rr, cc))
                    r, c = rr, cc
                    reflection_count += 1
                    direction = rotate_left(direction)
                    if reflection_count % 2 == 0:
                        direction = opposite(direction)
                    placed = True
                    break

            elif direction == 'left':
                row = r
                min_c1 = 1
                max_c1 = c - 1
                if min_c1 > max_c1:
                    success = False
                    break
                cols = list(range(min_c1, max_c1 + 1))
                random.shuffle(cols)
                for c1 in cols:
                    first = (row, c1)
                    second = (row, c1 - 1)
                    if first in occupied or second in occupied:
                        continue
                    blocked = False
                    for cc in range(c - 1, c1 - 1, -1):
                        if (row, cc) in occupied:
                            blocked = True
                            break
                    if blocked:
                        continue
                    input_grid[first[0]][first[1]] = color
                    input_grid[second[0]][second[1]] = color
                    occupied.add(first)
                    occupied.add(second)
                    mirror_pairs.append({'orientation': 'horizontal', 'first': first, 'second': second, 'color': color})
                    rr, cc = r, c
                    while (rr, cc) != first:
                        cc -= 1
                        path.append((rr, cc))
                    cc -= 1
                    path.append((rr, cc))
                    r, c = rr, cc
                    reflection_count += 1
                    direction = rotate_left(direction)
                    if reflection_count % 2 == 0:
                        direction = opposite(direction)
                    placed = True
                    break

            elif direction == 'down':
                col = c
                min_r1 = r + 1
                max_r1 = height - 2
                if min_r1 > max_r1:
                    success = False
                    break
                rows = list(range(min_r1, max_r1 + 1))
                random.shuffle(rows)
                for r1 in rows:
                    first = (r1, col)
                    second = (r1 + 1, col)
                    if first in occupied or second in occupied:
                        continue
                    blocked = False
                    for rr in range(r + 1, r1 + 1):
                        if (rr, col) in occupied:
                            blocked = True
                            break
                    if blocked:
                        continue
                    input_grid[first[0]][first[1]] = color
                    input_grid[second[0]][second[1]] = color
                    occupied.add(first)
                    occupied.add(second)
                    mirror_pairs.append({'orientation': 'vertical', 'first': first, 'second': second, 'color': color})
                    rr, cc = r, c
                    while (rr, cc) != first:
                        rr += 1
                        path.append((rr, cc))
                    rr += 1
                    path.append((rr, cc))
                    r, c = rr, cc
                    reflection_count += 1
                    direction = rotate_left(direction)
                    if reflection_count % 2 == 0:
                        direction = opposite(direction)
                    placed = True
                    break

            elif direction == 'up':
                col = c
                min_r1 = 1
                max_r1 = r - 1
                if min_r1 > max_r1:
                    success = False
                    break
                rows = list(range(min_r1, max_r1 + 1))
                random.shuffle(rows)
                for r1 in rows:
                    first = (r1, col)
                    second = (r1 - 1, col)
                    if first in occupied or second in occupied:
                        continue
                    blocked = False
                    for rr in range(r - 1, r1 - 1, -1):
                        if (rr, col) in occupied:
                            blocked = True
                            break
                    if blocked:
                        continue
                    input_grid[first[0]][first[1]] = color
                    input_grid[second[0]][second[1]] = color
                    occupied.add(first)
                    occupied.add(second)
                    mirror_pairs.append({'orientation': 'vertical', 'first': first, 'second': second, 'color': color})
                    rr, cc = r, c
                    while (rr, cc) != first:
                        rr -= 1
                        path.append((rr, cc))
                    rr -= 1
                    path.append((rr, cc))
                    r, c = rr, cc
                    reflection_count += 1
                    direction = rotate_left(direction)
                    if reflection_count % 2 == 0:
                        direction = opposite(direction)
                    placed = True
                    break

            if not placed:
                success = False
                break

        if not success:
            continue

        # continue until exit
        rr, cc = r, c
        while True:
            if direction == 'right':
                cc += 1
            elif direction == 'left':
                cc -= 1
            elif direction == 'up':
                rr -= 1
            elif direction == 'down':
                rr += 1
            if not (0 <= rr < height and 0 <= cc < width):
                break
            path.append((rr, cc))

        # collect second indices
        second_list = []
        for pair in mirror_pairs:
            if pair['second'] in path:
                pair['second_index'] = path.index(pair['second'])
                second_list.append((pair['second_index'], pair['color']))
            else:
                success = False
                break

        if not success or len(second_list) == 0:
            continue

        # copy input to output
        for rr in range(height):
            for cc in range(width):
                output_grid[rr][cc] = input_grid[rr][cc]

        second_list.sort()
        second_indices = [si for si, _ in second_list]
        second_index_to_color = {si: col for si, col in second_list}
        last_color = second_list[-1][1]

        mirror_cells = set(occupied)
        L = len(path)
        for idx in range(L):
            pos = path[idx]
            if pos in mirror_cells:
                continue
            color = None
            for si in second_indices:
                if si > idx:
                    color = second_index_to_color[si]
                    break
            if color is None:
                color = last_color
            output_grid[pos[0]][pos[1]] = color

        if input_grid == output_grid:
            continue

        return {'input': input_grid, 'output': output_grid}

    # fallback (unlikely)
    width, height = 6, 6
    input_grid = common.grid(width, height, 0)
    output_grid = common.grid(width, height, 0)
    return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = [row[:] for row in input_grid]

    # identify mirror pairs (store both cell coordinates)
    mirror_pairs = []
    cell_to_pair = {}
    for r in range(height):
        for c in range(width):
            val = input_grid[r][c]
            if val == 0:
                continue
            # horizontal pairs: record once at left cell
            if c + 1 < width and input_grid[r][c + 1] == val:
                pair_id = len(mirror_pairs)
                first = (r, c)
                second = (r, c + 1)
                mirror_pairs.append({'cells': (first, second), 'color': val})
                cell_to_pair[first] = pair_id
                cell_to_pair[second] = pair_id
            # vertical pairs: record once at top cell
            if r + 1 < height and input_grid[r + 1][c] == val:
                pair_id = len(mirror_pairs)
                first = (r, c)
                second = (r + 1, c)
                mirror_pairs.append({'cells': (first, second), 'color': val})
                cell_to_pair[first] = pair_id
                cell_to_pair[second] = pair_id

    # start at the topmost left cell that is background
    start_row = 0
    while start_row < height and input_grid[start_row][0] != 0:
        start_row += 1
    if start_row >= height:
        start_row = 0

    r, c = start_row, 0
    direction = 'right'
    path = [(r, c)]

    reflection_count = 0
    triggered = set()
    seen_cells = set()

    def rotate_left(d):
        return {'right': 'up', 'up': 'left', 'left': 'down', 'down': 'right'}[d]

    def opposite(d):
        return {'right': 'left', 'left': 'right', 'up': 'down', 'down': 'up'}[d]

    second_list = []

    # traverse until leaving grid
    while True:
        if direction == 'right':
            c += 1
        elif direction == 'left':
            c -= 1
        elif direction == 'up':
            r -= 1
        elif direction == 'down':
            r += 1

        if not (0 <= r < height and 0 <= c < width):
            break

        path.append((r, c))

        # handle mirror logic using dynamic order: if the other cell of the pair
        # was already seen earlier then the current cell is the second and triggers.
        if (r, c) in cell_to_pair:
            pid = cell_to_pair[(r, c)]
            pair = mirror_pairs[pid]
            a, b = pair['cells']
            other = b if (r, c) == a else a
            if other in seen_cells and pid not in triggered:
                triggered.add(pid)
                reflection_count += 1
                # record second index as where the reflection happened
                second_list.append((len(path) - 1, pair['color']))
                direction = rotate_left(direction)
                if reflection_count % 2 == 0:
                    direction = opposite(direction)
            else:
                # mark this cell as seen so its partner can trigger later
                seen_cells.add((r, c))

    # sort second_list by index, then color path accordingly
    second_list.sort()

    mirror_cells = set()
    for pair in mirror_pairs:
        mirror_cells.update(pair['cells'])

    if len(second_list) == 0:
        return output_grid

    second_indices = [si for si, _ in second_list]
    second_index_to_color = {si: col for si, col in second_list}
    last_color = second_list[-1][1]

    L = len(path)
    for idx in range(L):
        pos = path[idx]
        if pos in mirror_cells:
            continue
        color = None
        for si in second_indices:
            if si > idx:
                color = second_index_to_color[si]
                break
        if color is None:
            color = last_color
        output_grid[pos[0]][pos[1]] = color

    return output_grid

