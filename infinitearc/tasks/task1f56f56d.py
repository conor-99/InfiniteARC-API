# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 1f56f56d
Difficulty: medium–hard

=== Tags ===
- Constraint satisfaction coloring
- Texture transfer
- Boolean color logic
- Motif extraction

=== Description ===
Pattern Constraint Resonance  Input grids feature a background color (0) and
multiple solid-colored regions (1-9). A unique 2x2 repeating color pattern (the
motif) appears in exactly one location within the grid, forming a consistent
texture. The output grid must fill all regions with dimensions at least 3×3 with
the motif pattern, repeating it to cover the entire region, but only if the
region's color does not appear in the motif. Regions whose color matches any
color present in the motif remain unchanged. All background cells, regions
smaller than 3×3, and regions matching the motif's colors retain their original
appearance from the input grid. The transformation requires identifying the
motif through its repeating texture and applying Boolean color logic to
determine which regions should be transformed.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid


def generate_motif():
    # Create a 2x2 motif that is not uniform (not all four the same color)
    while True:
        a = random.randint(1, 9)
        b = random.randint(1, 9)
        c = random.randint(1, 9)
        d = random.randint(1, 9)
        if not (a == b == c == d):
            return [[a, b], [c, d]]


def generate():
    # Choose a reasonably sized canvas so the motif block and regions fit comfortably
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    input_grid = grid(width, height, 0)

    # Create motif and place it as a tiled 2x2 repeating texture somewhere with at least a 1-cell margin
    motif = generate_motif()
    motif_colors = set([motif[0][0], motif[0][1], motif[1][0], motif[1][1]])

    max_tiles_x = min(4, (width - 2) // 2)
    max_tiles_y = min(4, (height - 2) // 2)
    tiles_x = random.randint(2, max_tiles_x)
    tiles_y = random.randint(2, max_tiles_y)
    block_w = tiles_x * 2
    block_h = tiles_y * 2

    r0 = random.randint(1, height - block_h - 1)
    c0 = random.randint(1, width - block_w - 1)

    occupied = [[False] * width for _ in range(height)]

    # Fill the motif tiled block
    for tr in range(tiles_y):
        for tc in range(tiles_x):
            br = r0 + tr * 2
            bc = c0 + tc * 2
            input_grid[br][bc] = motif[0][0]
            input_grid[br][bc + 1] = motif[0][1]
            input_grid[br + 1][bc] = motif[1][0]
            input_grid[br + 1][bc + 1] = motif[1][1]
            occupied[br][bc] = True
            occupied[br][bc + 1] = True
            occupied[br + 1][bc] = True
            occupied[br + 1][bc + 1] = True

    # Helper to test and place rectangles (solid-colored regions)
    def can_place(r, c, w, h):
        if r < 0 or c < 0 or r + h > height or c + w > width:
            return False
        for rr in range(r, r + h):
            for cc in range(c, c + w):
                if occupied[rr][cc]:
                    return False
        return True

    def place_rect(wr, hr, color, tries=200):
        for _ in range(tries):
            rr = random.randint(0, height - hr)
            cc = random.randint(0, width - wr)
            if can_place(rr, cc, wr, hr):
                for r2 in range(rr, rr + hr):
                    for c2 in range(cc, cc + wr):
                        input_grid[r2][c2] = color
                        occupied[r2][c2] = True
                return (rr, cc, wr, hr)
        return None

    colors_all = list(range(1, 10))
    non_motif_colors = [c for c in colors_all if c not in motif_colors]

    # Ensure at least one transformable (non-motif-color) large region is placed
    placed_transformable = False
    if non_motif_colors:
        # Try larger rectangles first, then smaller
        for max_size in [6, 5, 4, 3]:
            if placed_transformable:
                break
            w_try = min(max_size, width - 2)
            h_try = min(max_size, height - 2)
            for _ in range(80):
                wr = random.randint(3, max(3, w_try))
                hr = random.randint(3, max(3, h_try))
                color = random.choice(non_motif_colors)
                res = place_rect(wr, hr, color)
                if res:
                    placed_transformable = True
                    break
        # Fallback: exhaustive small scan for a 3x3 spot if everything else failed
        if not placed_transformable:
            color = random.choice(non_motif_colors)
            for rr in range(0, height - 3 + 1):
                if placed_transformable:
                    break
                for cc in range(0, width - 3 + 1):
                    if can_place(rr, cc, 3, 3):
                        place_rect(3, 3, color)
                        placed_transformable = True
                        break

    # Place one (optional) region that uses a motif color and is large (should remain unchanged)
    motif_color_example = random.choice(list(motif_colors))
    _ = place_rect(random.randint(3, min(6, width - 2)), random.randint(3, min(6, height - 2)), motif_color_example)

    # Scatter several small regions (1x1 or 2x2)
    for _ in range(random.randint(3, 8)):
        color = random.choice(colors_all)
        wr = random.randint(1, 2)
        hr = random.randint(1, 2)
        place_rect(wr, hr, color)

    # Optionally place a few more medium regions of various colors
    for _ in range(random.randint(0, 3)):
        color = random.choice(colors_all)
        wr = random.randint(2, min(6, width - 2))
        hr = random.randint(2, min(6, height - 2))
        place_rect(wr, hr, color)

    # Build the output by applying the transformation rules used by the solver
    output_grid = [row[:] for row in input_grid]

    # Find connected regions (4-connected) of same color (non-zero)
    visited = [[False] * width for _ in range(height)]
    regions = []
    for r in range(height):
        for c in range(width):
            if visited[r][c] or input_grid[r][c] == 0:
                continue
            color = input_grid[r][c]
            stack = [(r, c)]
            visited[r][c] = True
            pixels = []
            while stack:
                cr, cc = stack.pop()
                pixels.append((cr, cc))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            regions.append((color, pixels))

    # Apply motif fill to qualifying regions: bounding dimensions at least 3x3 and color not in motif_colors
    for color, pixels in regions:
        if color in motif_colors:
            continue
        min_r = min(p[0] for p in pixels)
        max_r = max(p[0] for p in pixels)
        min_c = min(p[1] for p in pixels)
        max_c = max(p[1] for p in pixels)
        width_box = max_c - min_c + 1
        height_box = max_r - min_r + 1
        if width_box >= 3 and height_box >= 3:
            for (pr, pc) in pixels:
                output_grid[pr][pc] = motif[(pr - min_r) % 2][(pc - min_c) % 2]

    return {
        "input": input_grid,
        "output": output_grid
    }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # Find the most common non-zero, non-uniform 2x2 pattern (the motif)
    pattern_count = {}
    for r in range(height - 1):
        for c in range(width - 1):
            a = grid[r][c]
            b = grid[r][c + 1]
            c2 = grid[r + 1][c]
            d = grid[r + 1][c + 1]
            # Ignore patterns that include background or are uniform
            if a == 0 or b == 0 or c2 == 0 or d == 0:
                continue
            if a == b == c2 == d:
                continue
            key = (a, b, c2, d)
            pattern_count[key] = pattern_count.get(key, 0) + 1

    motif_pattern = None
    if pattern_count:
        # Choose the pattern with maximum occurrences
        motif_pattern = max(pattern_count.keys(), key=lambda k: pattern_count[k])
    else:
        # Fallback: find any 2x2 non-uniform block
        for r in range(height - 1):
            for c in range(width - 1):
                a = grid[r][c]
                b = grid[r][c + 1]
                c2 = grid[r + 1][c]
                d = grid[r + 1][c + 1]
                if a == 0 or b == 0 or c2 == 0 or d == 0:
                    continue
                if a == b == c2 == d:
                    continue
                motif_pattern = (a, b, c2, d)
                break
            if motif_pattern:
                break

    if motif_pattern is None:
        # As an ultimate fallback, return the input unchanged
        return grid

    motif = [[motif_pattern[0], motif_pattern[1]], [motif_pattern[2], motif_pattern[3]]]
    motif_colors = set(motif_pattern)

    # Find connected regions (4-connected) of same color (non-zero)
    visited = [[False] * width for _ in range(height)]
    regions = []
    for r in range(height):
        for c in range(width):
            if visited[r][c] or grid[r][c] == 0:
                continue
            color = grid[r][c]
            stack = [(r, c)]
            visited[r][c] = True
            pixels = []
            while stack:
                cr, cc = stack.pop()
                pixels.append((cr, cc))
                for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            regions.append((color, pixels))

    output = [row[:] for row in grid]

    # Apply motif to qualifying regions: bounding width and height at least 3 and color not part of motif
    for color, pixels in regions:
        if color in motif_colors:
            continue
        min_r = min(p[0] for p in pixels)
        max_r = max(p[0] for p in pixels)
        min_c = min(p[1] for p in pixels)
        max_c = max(p[1] for p in pixels)
        width_box = max_c - min_c + 1
        height_box = max_r - min_r + 1
        if width_box >= 3 and height_box >= 3:
            for (pr, pc) in pixels:
                output[pr][pc] = motif[(pr - min_r) % 2][(pc - min_c) % 2]

    return output

