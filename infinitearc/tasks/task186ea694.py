# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 186ea694
Difficulty: very hard

=== Tags ===
- Stateful propagation
- Elastic wave
- Simple tile repeat
- Image reflection

=== Description ===
**Task Name: Elastic Wave Reflection Grid**  **Description:**   Input grids are
large (15×15 to 30×30) with a uniform background color. The grid contains a
regular grid of small 3×3 tiles (arranged in a ≥3×3 matrix) scattered across the
background. Each tile has a unique color indicating its behavior: **color A**
(mirror tiles) reflect the tile’s pattern horizontally, **color B** (transmitter
tiles) copy the tile unchanged, and **color C** (absorber tiles) erase the tile
from the output. The "elastic wave" is a stateful propagation rule: starting
from the top-left tile, each tile’s behavior influences adjacent tiles. Mirror
tiles (A) reflect the wave direction (e.g., a wave moving right becomes left
upon reflection), transmitter tiles (B) propagate the wave unchanged, and
absorber tiles (C) halt propagation. The wave’s path forms a cascading pattern
across the grid, determined by the sequence of tile types. The output grid
replaces each tile with its transformed version (reflected for A, copied for B,
erased for C), while retaining the original tile positions. The resulting
pattern creates a visually complex, wave-like structure where reflection states
propagate through the grid, forming a non-repeating, state-dependent wavefront.
The task requires identifying the propagation path, applying the correct
reflection state to each tile, and recognizing the emergent wave pattern formed
by the interaction of mirror/transmitter tiles. Absorber tiles act as barriers,
creating fragmented wave segments that must be resolved in sequence.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    size = random.choice([15, 18, 21, 24, 27, 30])
    bg = 0
    input_grid = grid(size, size, bg)
    num_tiles = size // 3
    
    # Create tile pattern for each 3x3 block
    for i in range(num_tiles):
        for j in range(num_tiles):
            # Center cell determines behavior
            center_r, center_c = 3*i + 1, 3*j + 1
            behavior = random.choice([1, 2, 3])
            
            # Ensure top-left tile is not absorber
            if i == 0 and j == 0:
                behavior = random.choice([1, 2])
                
            input_grid[center_r][center_c] = behavior
            
            # Fill surrounding cells with random pattern colors (4-9)
            for dr in [-1, 0, 1]:
                for dc in [-1, 0, 1]:
                    if dr == 0 and dc == 0:
                        continue
                    r, c = center_r + dr, center_c + dc
                    if 0 <= r < size and 0 <= c < size:
                        input_grid[r][c] = random.randint(4, 9)

    # Create output grid by transforming tiles
    output_grid = [row[:] for row in input_grid]
    for i in range(num_tiles):
        for j in range(num_tiles):
            center_r, center_c = 3*i + 1, 3*j + 1
            behavior = input_grid[center_r][center_c]
            
            # Extract 3x3 block
            block = [output_grid[3*i + r][3*j + c] for r in range(3) for c in range(3)]
            block = [block[i:i+3] for i in range(0, 9, 3)]
            
            if behavior == 1:  # Mirror: reflect horizontally
                block = [row[::-1] for row in block]
            elif behavior == 3:  # Absorber: erase
                block = [[0]*3 for _ in range(3)]
            
            # Place transformed block back
            for r in range(3):
                for c in range(3):
                    output_grid[3*i + r][3*j + c] = block[r][c]

    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable list of lists
    grid = [list(row) for row in input_grid]
    size = len(grid)
    num_tiles = size // 3
    
    for i in range(num_tiles):
        for j in range(num_tiles):
            center_r, center_c = 3*i + 1, 3*j + 1
            behavior = grid[center_r][center_c]
            
            # Extract 3x3 block
            block = [grid[3*i + r][3*j + c] for r in range(3) for c in range(3)]
            block = [block[i:i+3] for i in range(0, 9, 3)]
            
            if behavior == 1:  # Mirror: reflect horizontally
                block = [row[::-1] for row in block]
            elif behavior == 3:  # Absorber: erase
                block = [[0]*3 for _ in range(3)]
            
            # Place transformed block back
            for r in range(3):
                for c in range(3):
                    grid[3*i + r][3*j + c] = block[r][c]
    
    return grid
