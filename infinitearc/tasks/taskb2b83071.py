# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: b2b83071
Difficulty: mediumâ€“hard

=== Tags ===
- Bidirectional escape
- Split and merge
- Color guessing
- Detect wall

=== Description ===
Bidirectional Pathway Fusion  Input grids feature a single background color (0)
and walls of distinct colors (1-9). Scattered within the grid are small, single-
cell agents (color 1) positioned along the left edge. These agents move
horizontally until they encounter a wall. Upon collision, the agent splits into
two new agents moving vertically (up/down) if the wall color is even, or
horizontally (left/right) if the wall color is odd. Each new agent continues
moving in its direction until encountering another wall, triggering further
splits based on the wall's color parity. Agents reaching any grid boundary are
removed. If two agents occupy the same cell, they merge into a single agent
whose color is the sum of their original colors modulo 9. All paths drawn in the
output grid use the wall color that triggered the split. Walls, background, and
original agent positions remain unchanged, while paths are visualized as
continuous segments in their corresponding wall colors. The task requires
detecting walls, tracking bidirectional splits, and inferring the color mapping
rule through pattern recognition rather than calculation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid
from collections import deque

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    input_grid = grid(width, height, 0)
    
    wall_colors = list(range(2, 10))
    num_walls = random.randint(10, 50)
    for _ in range(num_walls):
        r = random.randint(0, height-1)
        c = random.randint(1, width-1)
        input_grid[r][c] = random.choice(wall_colors)
    
    for r in range(height):
        if random.random() > 0.3:
            input_grid[r][0] = 1
    
    output_grid = [row[:] for row in input_grid]
    
    queue = deque()
    for r in range(height):
        if input_grid[r][0] == 1:
            queue.append((r, 0, 0, 1))
    
    max_agents = 1000
    agent_count = 0
    
    while queue and agent_count < max_agents:
        r, c, dr, dc = queue.popleft()
        nr, nc = r + dr, c + dc
        path = []
        while 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 0:
            path.append((nr, nc))
            nr, nc = nr + dr, nc + dc
        if path:
            wall_color = input_grid[nr][nc] if (0 <= nr < height and 0 <= nc < width) else 0
            for pr, pc in path:
                output_grid[pr][pc] = wall_color
        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] > 0:
            wall_color = input_grid[nr][nc]
            if wall_color % 2 == 0:
                new_dirs = [(-1, 0), (1, 0)]
            else:
                new_dirs = [(0, -1), (0, 1)]
            for ndr, ndc in new_dirs:
                queue.append((nr, nc, ndr, ndc))
        agent_count += 1
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque
def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    
    output_grid = [row[:] for row in input_grid]
    
    agents = []
    for r in range(height):
        if input_grid[r][0] == 1:
            agents.append((r, 0, 0, 1))
    
    queue = deque(agents)
    max_agents = 1000
    agent_count = 0
    
    while queue and agent_count < max_agents:
        r, c, dr, dc = queue.popleft()
        nr, nc = r + dr, c + dc
        path = []
        while 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] == 0:
            path.append((nr, nc))
            nr, nc = nr + dr, nc + dc
        if path:
            wall_color = input_grid[nr][nc] if (0 <= nr < height and 0 <= nc < width) else 0
            for pr, pc in path:
                output_grid[pr][pc] = wall_color
        if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] > 0:
            wall_color = input_grid[nr][nc]
            if wall_color % 2 == 0:
                new_dirs = [(-1, 0), (1, 0)]
            else:
                new_dirs = [(0, -1), (0, 1)]
            for ndr, ndc in new_dirs:
                queue.append((nr, nc, ndr, ndc))
        agent_count += 1
    
    return output_grid
