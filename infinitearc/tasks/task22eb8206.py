# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 22eb8206
Difficulty: hard

=== Tags ===
- Echo trail

=== Description ===
# Echo Trail  Input grids are large (width and height both greater than 15) and
contain a single background color. Over this background, there are two main
elements: a laser and a pattern strip. The laser is an L-shaped cluster of three
connected cells of a single color, oriented to face one of four diagonal
directions (northeast, southeast, northwest, southwest), with the uncolored
corner cell (background) at the tip of the L being the laser's origin. The
pattern strip is a horizontal sequence of 2×2 color blocks positioned along the
top edge of the grid, starting with a block matching the laser's color, followed
by one or more additional blocks of distinct colors. The grid also contains
walls—1-cell-thick horizontal or vertical blocks of a single color—that do not
touch each other or other elements.  The output grid retains all input elements
(laser, walls, pattern strip, and background) but adds a trail along the path
taken by the laser's beam. The beam starts at the laser's origin and moves
diagonally in the laser's facing direction, traveling through background cells
only. Upon hitting a wall, the beam reflects perfectly (changing direction
according to mirror symmetry) and continues moving diagonally. Each cell along
the beam's path (beginning with the first cell after the origin) is colored with
the next color in the pattern strip sequence, cycling through the sequence
repeatedly. The trail is drawn only on background cells and never overlaps with
walls, lasers, or the pattern strip. The beam continues until it exits the grid,
with the trail extending exactly to the cell where the beam exits. The pattern
strip's sequence of colors is determined by the order of the 2×2 blocks in the
input, with the first block matching the laser's color.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    """
    Generate an ARC-style input/output pair implementing the "Echo Trail" task.

    The function builds a large grid (16x16 up to 30x30) with a single background
    color, a 2-row pattern strip made of contiguous 2x2 blocks across the top,
    a 3-cell L-shaped laser (one corner of a 2x2 left uncolored = origin) and several
    1-cell-thick horizontal or vertical walls. The output grid is the input grid
    with the laser beam traced diagonally from the origin, reflecting off walls
    and cycling through the pattern colors.
    """
    # Try until a valid configuration is found
    global_attempts = 0
    while True:
        global_attempts += 1
        if global_attempts > 2000:
            raise RuntimeError("Unable to generate a valid puzzle after many attempts")

        width = random.randint(16, 30)
        height = random.randint(16, 30)

        # Background color (dominant)
        bg_color = random.randint(0, 9)

        # Laser color must differ from background
        colors = list(range(10))
        laser_color = random.choice([c for c in colors if c != bg_color])

        # Pattern length: at least 2 blocks, each block is 2x2. Fit it into the width.
        max_blocks = max(2, min(6, width // 2))
        pattern_len = random.randint(2, max_blocks)

        # Build the pattern colors: first is laser_color, others distinct and != bg
        pool = [c for c in colors if c != bg_color and c != laser_color]
        random.shuffle(pool)
        pattern_colors = [laser_color] + pool[: pattern_len - 1]

        # Create input grid filled with background
        inp = common.grid(width, height, bg_color)

        # Place pattern strip on the top two rows. Choose a random left offset
        max_offset = width - 2 * pattern_len
        start_col = random.randint(0, max_offset)
        pattern_cells = set()
        for i, col_color in enumerate(pattern_colors):
            block_c = start_col + 2 * i
            for r in (0, 1):
                for c in (block_c, block_c + 1):
                    inp[r][c] = col_color
                    pattern_cells.add((r, c))

        occupied = set(pattern_cells)  # cells occupied by pattern (and later walls/laser)

        # Helper: check a 2x2 block and its 8-neighborhood is free of other elements
        def block_and_neighbors_free(r0, c0):
            # block cells must be inside grid
            if r0 < 0 or c0 < 0 or r0 + 1 >= height or c0 + 1 >= width:
                return False
            block = [(r0, c0), (r0, c0 + 1), (r0 + 1, c0), (r0 + 1, c0 + 1)]
            # Block itself must be background
            for (r, c) in block:
                if inp[r][c] != bg_color:
                    return False
            # None of the neighbors (around the 2x2) may be occupied (to enforce a gap)
            for (r, c) in block:
                for dr in (-1, 0, 1):
                    for dc in (-1, 0, 1):
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < height and 0 <= nc < width:
                            if (nr, nc) in occupied and (nr, nc) not in block:
                                return False
            return True

        # Place laser: find a 2x2 block where three cells will be laser_color and one is origin (bg)
        orientations = ["NE", "SE", "NW", "SW"]
        placed_laser = False
        laser_origin = None
        laser_positions = []
        laser_dx = laser_dy = None

        attempts = 0
        while attempts < 800 and not placed_laser:
            attempts += 1
            orient = random.choice(orientations)
            r0 = random.randint(0, height - 2)
            c0 = random.randint(0, width - 2)
            if not block_and_neighbors_free(r0, c0):
                continue

            # Determine which corner is the origin and which three cells are colored
            if orient == "NE":
                origin = (r0, c0 + 1)
                colored = [(r0, c0), (r0 + 1, c0), (r0 + 1, c0 + 1)]
                dx, dy = -1, 1
            elif orient == "SE":
                origin = (r0 + 1, c0 + 1)
                colored = [(r0, c0), (r0, c0 + 1), (r0 + 1, c0)]
                dx, dy = 1, 1
            elif orient == "NW":
                origin = (r0, c0)
                colored = [(r0, c0 + 1), (r0 + 1, c0), (r0 + 1, c0 + 1)]
                dx, dy = -1, -1
            else:  # SW
                origin = (r0 + 1, c0)
                colored = [(r0, c0), (r0, c0 + 1), (r0 + 1, c0 + 1)]
                dx, dy = 1, -1

            ox, oy = origin
            nx, ny = ox + dx, oy + dy

            # The first step from the origin must be inside the grid and be a background cell
            if not (0 <= nx < height and 0 <= ny < width):
                continue
            if inp[nx][ny] != bg_color:
                continue

            # Everything is ok: place the three colored laser cells
            for (r, c) in colored:
                inp[r][c] = laser_color
                occupied.add((r, c))
            placed_laser = True
            laser_origin = origin
            laser_positions = colored
            laser_dx, laser_dy = dx, dy

        if not placed_laser:
            # try a new grid config
            continue

        # Place walls: several 1-cell-thick horizontal or vertical blocks that do not touch other elements
        wall_count = random.randint(3, 5)
        wall_colors_used = set()
        wall_attempts = 0
        for _ in range(wall_count):
            placed_wall = False
            for _try in range(400):
                wall_attempts += 1
                orient = random.choice(["H", "V"])
                if orient == "H":
                    max_len = min(6, width)
                    length = random.randint(1, max_len)
                    r = random.randint(0, height - 1)
                    c = random.randint(0, width - length)
                    cells = [(r, c + i) for i in range(length)]
                else:
                    max_len = min(6, height)
                    length = random.randint(1, max_len)
                    c = random.randint(0, width - 1)
                    r = random.randint(0, height - length)
                    cells = [(r + i, c) for i in range(length)]

                # Check all candidate cells are background and none of their neighbors are occupied
                ok = True
                for (rr, cc) in cells:
                    if inp[rr][cc] != bg_color:
                        ok = False
                        break
                    for dr in (-1, 0, 1):
                        for dc in (-1, 0, 1):
                            nr, nc = rr + dr, cc + dc
                            if 0 <= nr < height and 0 <= nc < width:
                                if (nr, nc) in occupied and (nr, nc) not in cells:
                                    ok = False
                                    break
                        if not ok:
                            break
                    if not ok:
                        break
                if not ok:
                    continue

                # Pick a wall color different from bg, laser, and pattern colors
                wall_color_candidates = [c for c in colors if c != bg_color and c != laser_color and c not in pattern_colors]
                if not wall_color_candidates:
                    continue
                wcolor = random.choice(wall_color_candidates)

                # Place the wall
                for (rr, cc) in cells:
                    inp[rr][cc] = wcolor
                    occupied.add((rr, cc))
                wall_colors_used.add(wcolor)
                placed_wall = True
                break
            # If a wall wasn't placed after many attempts that's okay; continue with fewer walls

        # Now simulate the beam on the original input grid to create the output
        orig = [row[:] for row in inp]
        out = [row[:] for row in inp]

        # Beam starts at laser_origin and moves in (laser_dx, laser_dy)
        prev_r, prev_c = laser_origin
        dx, dy = laser_dx, laser_dy
        color_idx = 0
        steps = 0
        max_steps = width * height * 10

        while True:
            if steps > max_steps:
                # Abandon this configuration (avoid infinite loops)
                break
            steps += 1

            nr, nc = prev_r + dx, prev_c + dy
            # If beam exits grid, stop
            if not (0 <= nr < height and 0 <= nc < width):
                break

            # If the next cell is not background, reflect according to orthogonal neighbors
            if orig[nr][nc] != bg_color:
                # Check the orthogonal neighbors relative to prev
                vert_r, vert_c = prev_r + dx, prev_c
                horiz_r, horiz_c = prev_r, prev_c + dy

                blocked_vert = not (0 <= vert_r < height and 0 <= vert_c < width) or orig[vert_r][vert_c] != bg_color
                blocked_horiz = not (0 <= horiz_r < height and 0 <= horiz_c < width) or orig[horiz_r][horiz_c] != bg_color

                if blocked_vert and blocked_horiz:
                    dx, dy = -dx, -dy
                elif blocked_vert:
                    dx = -dx
                elif blocked_horiz:
                    dy = -dy
                else:
                    # diagonal-only obstacle (no orth neighbors blocked): reflect both
                    dx, dy = -dx, -dy

                # After reflection, stay at the same prev position and try the new direction
                continue

            # Paint the trail cell in the output (do not modify orig)
            out[nr][nc] = pattern_colors[color_idx % len(pattern_colors)]
            color_idx += 1
            prev_r, prev_c = nr, nc

        # Ensure at least one trail cell was drawn and input != output
        if color_idx == 0:
            # try a new configuration
            continue

        if inp == out:
            # no visible change, try again
            continue

        return {"input": inp, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import collections

def p(input_grid):
    # Convert to mutable lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Determine background color (most frequent color)
    counts = {}
    for r in range(height):
        for c in range(width):
            counts[grid[r][c]] = counts.get(grid[r][c], 0) + 1
    bg_color = max(counts.items(), key=lambda x: x[1])[0]

    # Find pattern strip by scanning the top two rows for contiguous 2x2 uniform blocks
    pattern_colors = []
    start_col = None
    for sc in range(width - 1):
        if grid[0][sc] == grid[0][sc + 1] == grid[1][sc] == grid[1][sc + 1] and grid[0][sc] != bg_color:
            start_col = sc
            break
    if start_col is None:
        # No pattern found; return input as-is
        return grid

    c = start_col
    while c <= width - 2 and grid[0][c] == grid[0][c + 1] == grid[1][c] == grid[1][c + 1] and grid[0][c] != bg_color:
        pattern_colors.append(grid[0][c])
        c += 2

    if not pattern_colors:
        return grid

    # Instead of searching among all same-colored cells, locate the 2x2 block outside the top rows
    # that contains exactly three same-colored cells and one background cell. That 2x2 is the laser.
    laser_origin = None
    laser_dx = laser_dy = None
    laser_color = pattern_colors[0]

    found = False
    for r0 in range(height - 1):
        if found:
            break
        for c0 in range(width - 1):
            coords = [(r0, c0), (r0, c0 + 1), (r0 + 1, c0), (r0 + 1, c0 + 1)]
            vals = [grid[r][c] for (r, c) in coords]
            # exactly three must match the laser color and the remaining one must be background
            nonbg = [v for v in vals if v != bg_color]
            if len(nonbg) != 3:
                continue
            if len(set(nonbg)) != 1:
                continue
            if nonbg[0] != laser_color:
                continue
            # ensure not the pattern area (we expect the laser to be away from top two rows)
            # require at least one of the colored cells to be in row >= 2
            colored_positions = [coords[i] for i, v in enumerate(vals) if v != bg_color]
            if all(r < 2 for (r, c) in colored_positions):
                continue
            # The missing corner is the origin
            for i, v in enumerate(vals):
                if v == bg_color:
                    origin = coords[i]
                    # Determine direction
                    ox, oy = origin
                    dx = -1 if ox == r0 else 1
                    dy = -1 if oy == c0 else 1
                    laser_origin = origin
                    laser_dx, laser_dy = dx, dy
                    found = True
                    break
            if found:
                break

    if not found or laser_origin is None:
        # Fallback: find laser cells by color outside top rows
        laser_cells = [(r, c) for r in range(2, height) for c in range(width) if grid[r][c] == laser_color]
        if len(laser_cells) < 3:
            return grid
        # Try to find elbow
        comp_set = set(laser_cells)
        elbow = None
        for (r, c) in laser_cells:
            neigh = 0
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                if (r + dr, c + dc) in comp_set:
                    neigh += 1
            if neigh == 2:
                elbow = (r, c)
                break
        if elbow is None:
            return grid
        rs = [p[0] for p in laser_cells]
        cs = [p[1] for p in laser_cells]
        r0, r1 = min(rs), max(rs)
        c0, c1 = min(cs), max(cs)
        if not (r1 - r0 == 1 and c1 - c0 == 1):
            return grid
        corners = {(r0, c0), (r0, c1), (r1, c0), (r1, c1)}
        missing = list(corners - set(laser_cells))
        if not missing:
            return grid
        origin = missing[0]
        ox, oy = origin
        dx = -1 if ox == r0 else 1
        dy = -1 if oy == c0 else 1
        laser_origin = origin
        laser_dx, laser_dy = dx, dy

    # Simulate beam on original grid
    orig = [row[:] for row in grid]
    out = [row[:] for row in grid]

    prev_r, prev_c = laser_origin
    dx, dy = laser_dx, laser_dy
    color_idx = 0

    steps = 0
    max_steps = width * height * 10
    while True:
        if steps > max_steps:
            break
        steps += 1
        nr, nc = prev_r + dx, prev_c + dy
        if not (0 <= nr < height and 0 <= nc < width):
            break
        if orig[nr][nc] != bg_color:
            vert_r, vert_c = prev_r + dx, prev_c
            horiz_r, horiz_c = prev_r, prev_c + dy
            blocked_vert = not (0 <= vert_r < height and 0 <= vert_c < width) or orig[vert_r][vert_c] != bg_color
            blocked_horiz = not (0 <= horiz_r < height and 0 <= horiz_c < width) or orig[horiz_r][horiz_c] != bg_color
            if blocked_vert and blocked_horiz:
                dx, dy = -dx, -dy
            elif blocked_vert:
                dx = -dx
            elif blocked_horiz:
                dy = -dy
            else:
                dx, dy = -dx, -dy
            continue
        out[nr][nc] = pattern_colors[color_idx % len(pattern_colors)]
        color_idx += 1
        prev_r, prev_c = nr, nc

    return out

