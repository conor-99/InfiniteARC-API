# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: f2d9a009
Difficulty: easy

=== Tags ===
- Repaint border
- Column parity coloring
- Jigsaw
- Count patterns

=== Description ===
The task involves transforming an input grid into an output grid by repainting
the border cells based on column parity and the count of connected regions
(jigsaw patterns) in the input. The border consists of all cells in the first
row, last row, first column, and last column. First, the number of connected
regions (using 4-connectivity, ignoring color 0) in the input grid is counted.
If this count is even, border cells in even-indexed columns are set to color 1
and those in odd-indexed columns to color 2. If the count is odd, the colors are
swapped (even columns become color 2, odd columns become color 1). All inner
cells (non-border) remain unchanged from the input. This rule combines border
repainting, column parity-based coloring, jigsaw-like pattern counting
(connected regions), and a parity-based color mapping.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def count_connected_regions(grid):
    if not grid or not grid[0]:
        return 0
    visited = [[False] * len(grid[0]) for _ in range(len(grid))]
    count = 0
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            if grid[r][c] != 0 and not visited[r][c]:
                count += 1
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and not visited[nr][nc] and grid[nr][nc] != 0:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
    return count

def generate():
    while True:
        w = random.randint(1, 30)
        h = random.randint(1, 30)
        input_grid = [[random.randint(0, 9) for _ in range(w)] for _ in range(h)]
        count = count_connected_regions(input_grid)
        even_col, odd_col = (1, 2) if count % 2 == 0 else (2, 1)
        output_grid = [row[:] for row in input_grid]
        for r in range(h):
            for c in range(w):
                if r == 0 or r == h-1 or c == 0 or c == w-1:
                    output_grid[r][c] = even_col if c % 2 == 0 else odd_col
        if input_grid != output_grid:
            return {'input': input_grid, 'output': output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random

def count_connected_regions(grid):
    if not grid or not grid[0]:
        return 0
    visited = [[False] * len(grid[0]) for _ in range(len(grid))]
    count = 0
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            if grid[r][c] != 0 and not visited[r][c]:
                count += 1
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and not visited[nr][nc] and grid[nr][nc] != 0:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
    return count

def p(input):
    if isinstance(input, tuple):
        input = [list(row) for row in input]
    h = len(input)
    w = len(input[0])
    count = count_connected_regions(input)
    even_col, odd_col = (1, 2) if count % 2 == 0 else (2, 1)
    output = [row[:] for row in input]
    for r in range(h):
        for c in range(w):
            if r == 0 or r == h-1 or c == 0 or c == w-1:
                output[r][c] = even_col if c % 2 == 0 else odd_col
    return output
