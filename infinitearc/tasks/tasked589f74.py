# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: ed589f74
Difficulty: hard

=== Tags ===
- Multi stage rule chain
- Sequential path painting
- Path scarring
- Center object in canvas
- Reflect by color

=== Description ===
Input grids feature a central colored object (a solid, contiguous shape of a
single color) positioned precisely at the grid's geometric center. Surrounding
this central object are multiple disjoint colored structures (each a contiguous
shape of a single color) and background cells (a single uniform color). The
transformation requires tracing four directional paths originating from the
central object's perimeter: one path extending upward, one downward, one
leftward, and one rightward. Each path moves in a straight line until it
contacts a non-background colored structure. Upon contact, the path's direction
changes according to a fixed, consistent mapping between structure colors and
reflection directions (e.g., red structures always cause a clockwise 90° turn,
blue structures cause a counterclockwise 90° turn). The path continues in the
new direction, leaving a trail of the contacted structure's color along its
trajectory. This reflection process repeats at every subsequent contact with a
colored structure until the path exits the grid. The output grid preserves all
original structures and background, with the paths drawn as colored trails
reflecting the contacted structure's color at each reflection point. The color-
direction mapping is not explicitly provided and must be inferred from input-
output pairs, requiring sequential reasoning across multiple reflection stages
to reconstruct the path scarring pattern.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    size = random.randint(5, 29)
    if size % 2 == 0:
        size += 1
    width, height = size, size
    
    bg_color = random.randint(0, 9)
    central_color = random.randint(0, 9)
    while central_color == bg_color:
        central_color = random.randint(0, 9)
    
    grid = common.grid(width, height, bg_color)
    center_x, center_y = width // 2, height // 2
    grid[center_y][center_x] = central_color
    
    structure_colors = []
    while len(structure_colors) < 4:
        color = random.randint(0, 9)
        if color != bg_color and color != central_color:
            structure_colors.append(color)

    directions = {
        'up': (center_x, center_y - 2),
        'down': (center_x, center_y + 2),
        'left': (center_x - 2, center_y),
        'right': (center_x + 2, center_y)
    }
    
    for i, (x, y) in enumerate(directions.values()):
        if 0 <= x < width and 0 <= y < height:
            size_x = random.randint(1, 2)
            size_y = random.randint(1, 2)
            pixels = common.rand_sprite('el', size_x, size_y)
            for (r, c) in pixels:
                new_x, new_y = x + c, y + r
                if 0 <= new_x < width and 0 <= new_y < height:
                    grid[new_y][new_x] = structure_colors[i]

    output = [row[:] for row in grid]
    
    directions = {
        'up': (-1, 0),
        'down': (1, 0),
        'left': (0, -1),
        'right': (0, 1)
    }
    
    for direction_name, (dr, dc) in directions.items():
        start = (center_y + dr, center_x + dc)
        if not (0 <= start[0] < height and 0 <= start[1] < width):
            continue
        if grid[start[0]][start[1]] != bg_color:
            continue
        
        current = start
        current_dr, current_dc = dr, dc
        steps = 0
        while steps < 100:
            steps += 1
            next_r = current[0] + current_dr
            next_c = current[1] + current_dc
            if next_r < 0 or next_r >= height or next_c < 0 or next_c >= width:
                break
            if grid[next_r][next_c] != bg_color and grid[next_r][next_c] != central_color:
                struct_color = grid[next_r][next_c]
                output[current[0]][current[1]] = struct_color
                
                if struct_color % 2 == 1:
                    current_dr, current_dc = current_dc, -current_dr
                else:
                    current_dr, current_dc = -current_dc, current_dr
                
                current = (next_r, next_c)
            else:
                current = (next_r, next_c)
    
    return {'input': grid, 'output': output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    h = len(input_grid)
    w = len(input_grid[0])
    all_colors = [cell for row in input_grid for cell in row]
    from collections import Counter
    color_count = Counter(all_colors)
    central_color = input_grid[h//2][w//2]
    bg_color = max([c for c in color_count if c != central_color], key=color_count.get)
    
    output = [row[:] for row in input_grid]
    center_x, center_y = w//2, h//2
    
    directions = {
        'up': (-1, 0),
        'down': (1, 0),
        'left': (0, -1),
        'right': (0, 1)
    }
    
    for direction_name, (dr, dc) in directions.items():
        start = (center_y + dr, center_x + dc)
        if not (0 <= start[0] < h and 0 <= start[1] < w):
            continue
        if input_grid[start[0]][start[1]] != bg_color:
            continue
        
        current = start
        current_dr, current_dc = dr, dc
        steps = 0
        while steps < 100:
            steps += 1
            next_r = current[0] + current_dr
            next_c = current[1] + current_dc
            if next_r < 0 or next_r >= h or next_c < 0 or next_c >= w:
                break
            if input_grid[next_r][next_c] != bg_color and input_grid[next_r][next_c] != central_color:
                struct_color = input_grid[next_r][next_c]
                output[current[0]][current[1]] = struct_color
                
                if struct_color % 2 == 1:
                    current_dr, current_dc = current_dc, -current_dr
                else:
                    current_dr, current_dc = -current_dc, current_dr
                
                current = (next_r, next_c)
            else:
                current = (next_r, next_c)
    
    return output
