# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 8d0b10e3
Difficulty: medium–hard

=== Tags ===
- Cut and unfold
- Multi exit routes
- Proximity guessing

=== Description ===
Input grids feature a large background area (20×20 or larger) with multiple
contiguous rectangular regions of distinct non-background colors. Each region
has a thin border (1 pixel wide) of a specific color indicating it is "folded"
over an adjacent region. The folded region is a mirror image of the region it
overlaps, with the mirror axis determined by the proximity of the nearest non-
background element to the fold border.   "Cut and unfold" refers to the process
of removing fold borders and replacing mirrored regions with their actual
content. The mirror direction (horizontal or vertical) is determined by
"proximity guessing": for each fold border, the solver must identify the closest
non-background element (e.g., another region's color) to determine whether the
mirror is horizontal (closest element above/below) or vertical (closest element
left/right).   "Multi exit routes" manifests as overlapping fold lines across
the grid, where each fold segment may require independent direction
determination based on local proximity. The output grid shows all regions in
their correct, non-mirrored positions with fold borders removed, while
preserving the relative spacing and background color. Regions not marked as
folded remain unchanged. The transformation requires sequentially resolving each
fold's mirror direction using proximity clues, with no overlapping regions in
the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

# Improved generator that ensures regions (except paired source/folded pairs) are separated by at least
# 1 cell to avoid BFS merging of distinct regions.

fold_color = 9


def _rect_fits(occupancy, r, c, h, w, size):
    if r < 0 or c < 0 or r + h > size or c + w > size:
        return False
    for rr in range(r, r + h):
        for cc in range(c, c + w):
            if occupancy[rr][cc]:
                return False
    return True


def _mark_occ(occupancy, r, c, h, w):
    for rr in range(max(0, r), min(len(occupancy), r + h)):
        for cc in range(max(0, c), min(len(occupancy[0]), c + w)):
            occupancy[rr][cc] = True


def generate():
    size = random.randint(20, 26)
    inp = common.grid(size, size, 0)
    out = common.grid(size, size, 0)
    occupancy = [[False] * size for _ in range(size)]

    # parameters
    num_regions = random.randint(3, 6)
    max_pairs = max(1, num_regions // 2)
    pairs_count = random.randint(1, max_pairs)

    regions = []

    def draw_quadrant_pattern(grid, top, left, h, w, colors):
        rmid = h // 2
        cmid = w // 2
        for dr in range(h):
            for dc in range(w):
                if dr < rmid and dc < cmid:
                    val = colors[0]
                elif dr < rmid and dc >= cmid:
                    val = colors[1]
                elif dr >= rmid and dc < cmid:
                    val = colors[2]
                else:
                    val = colors[3]
                grid[top + dr][left + dc] = val

    placed_pairs = 0
    attempts = 0
    while placed_pairs < pairs_count and attempts < 1000:
        attempts += 1
        h_s = random.randint(3, 6)
        w_s = random.randint(3, 6)
        h_f = h_s + 2
        w_f = w_s + 2

        orientation = random.choice(['right', 'left', 'down', 'up'])

        if orientation == 'right':
            max_cA = size - (w_s + w_f)
            if max_cA < 0:
                continue
            cA = random.randint(0, max_cA)
            rA = random.randint(0, size - max(h_s, h_f))
            cB = cA + w_s
            rB = rA
            source_side = 'left'
        elif orientation == 'left':
            max_cB = size - (w_s + w_f)
            if max_cB < 0:
                continue
            cB = random.randint(0, max_cB)
            rB = random.randint(0, size - max(h_s, h_f))
            cA = cB + w_f
            rA = rB
            source_side = 'right'
        elif orientation == 'down':
            max_rA = size - (h_s + h_f)
            if max_rA < 0:
                continue
            rA = random.randint(0, max_rA)
            cA = random.randint(0, size - max(w_s, w_f))
            rB = rA + h_s
            cB = cA
            source_side = 'up'
        else:  # up
            max_rB = size - (h_s + h_f)
            if max_rB < 0:
                continue
            rB = random.randint(0, max_rB)
            cB = random.randint(0, size - max(w_s, w_f))
            rA = rB + h_f
            cA = cB
            source_side = 'down'

        # For pairs, ensure both core rectangles fit within occupancy (which includes padding reserved earlier)
        if not _rect_fits(occupancy, rA, cA, h_s, w_s, size):
            continue
        if not _rect_fits(occupancy, rB, cB, h_f, w_f, size):
            continue

        # Reserve the cores
        _mark_occ(occupancy, rA, cA, h_s, w_s)
        _mark_occ(occupancy, rB, cB, h_f, w_f)

        # Draw source region (same in input and output)
        colors = random.sample([i for i in range(1, 9)], 4)
        draw_quadrant_pattern(inp, rA, cA, h_s, w_s, colors)
        draw_quadrant_pattern(out, rA, cA, h_s, w_s, colors)

        # Draw folded region in input (border + mirrored interior)
        for rr in range(rB, rB + h_f):
            for cc in range(cB, cB + w_f):
                if rr == rB or rr == rB + h_f - 1 or cc == cB or cc == cB + w_f - 1:
                    inp[rr][cc] = fold_color
                else:
                    inner_r = rr - (rB + 1)
                    inner_c = cc - (cB + 1)
                    if source_side in ('left', 'right'):
                        src_r = rA + inner_r
                        src_c = cA + (w_s - 1 - inner_c)
                    else:
                        src_r = rA + (h_s - 1 - inner_r)
                        src_c = cA + inner_c
                    inp[rr][cc] = inp[src_r][src_c]

        # Output: remove border and copy true source content into interior
        for rr in range(rB, rB + h_f):
            for cc in range(cB, cB + w_f):
                if rr == rB or rr == rB + h_f - 1 or cc == cB or cc == cB + w_f - 1:
                    out[rr][cc] = 0
                else:
                    inner_r = rr - (rB + 1)
                    inner_c = cc - (cB + 1)
                    out[rr][cc] = out[rA + inner_r][cA + inner_c]

        # After successful placement, mark padding area (1 pixel around both rectangles)
        pad_r1 = min(rA, rB) - 1
        pad_c1 = min(cA, cB) - 1
        pad_r2 = max(rA + h_s - 1, rB + h_f - 1) + 1
        pad_c2 = max(cA + w_s - 1, cB + w_f - 1) + 1
        pad_h = pad_r2 - pad_r1 + 1
        pad_w = pad_c2 - pad_c1 + 1
        _mark_occ(occupancy, pad_r1, pad_c1, pad_h, pad_w)

        regions.append({'type': 'pair', 'source': (rA, cA, h_s, w_s), 'folded': (rB, cB, h_f, w_f), 'side': source_side})
        placed_pairs += 1

    # Place remaining standalone regions (not folded) with padding to prevent adjacency
    remaining = num_regions - 2 * placed_pairs
    if remaining < 0:
        remaining = 0

    placed = 0
    attempts2 = 0
    while placed < remaining and attempts2 < 1000:
        attempts2 += 1
        h = random.randint(3, 6)
        w = random.randint(3, 6)
        r = random.randint(0, size - h)
        c = random.randint(0, size - w)
        if not _rect_fits(occupancy, r, c, h, w, size):
            continue
        # Reserve core
        _mark_occ(occupancy, r, c, h, w)
        colors = random.sample([i for i in range(1, 9)], 4)
        draw_quadrant_pattern(inp, r, c, h, w, colors)
        draw_quadrant_pattern(out, r, c, h, w, colors)
        # mark padding
        pad_r1 = r - 1
        pad_c1 = c - 1
        pad_r2 = r + h
        pad_c2 = c + w
        pad_h = pad_r2 - pad_r1 + 1
        pad_w = pad_c2 - pad_c1 + 1
        _mark_occ(occupancy, pad_r1, pad_c1, pad_h, pad_w)
        regions.append({'type': 'standalone', 'rect': (r, c, h, w)})
        placed += 1

    # fallback if nothing placed
    if len(regions) == 0:
        r = 2
        c = 2
        h = 4
        w = 5
        colors = [1, 2, 3, 4]
        draw_quadrant_pattern(inp, r, c, h, w, colors)
        draw_quadrant_pattern(out, r, c, h, w, colors)

    return {'input': inp, 'output': out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert immutable input to mutable list
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0]) if h > 0 else 0
    output = [row[:] for row in grid]
    fold_color = 9

    # Find all fold border pixels
    visited = [[False] * w for _ in range(h)]
    components = []

    for r in range(h):
        for c in range(w):
            if grid[r][c] != fold_color or visited[r][c]:
                continue
            # BFS to collect component
            stack = [(r, c)]
            comp = []
            visited[r][c] = True
            while stack:
                rr, cc = stack.pop()
                comp.append((rr, cc))
                for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nr, nc = rr + dr, cc + dc
                    if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] == fold_color:
                        visited[nr][nc] = True
                        stack.append((nr, nc))
            components.append(comp)

    # For each component, compute bounding box and resolve the folded region
    for comp in components:
        min_r = min(p[0] for p in comp)
        max_r = max(p[0] for p in comp)
        min_c = min(p[1] for p in comp)
        max_c = max(p[1] for p in comp)

        # interior (inside the border)
        inner_r1 = min_r + 1
        inner_r2 = max_r - 1
        inner_c1 = min_c + 1
        inner_c2 = max_c - 1

        # Skip degenerate borders
        if inner_r1 > inner_r2 or inner_c1 > inner_c2:
            continue

        # Find nearest external non-background pixel (excluding fold_color and 0), outside the bounding box
        best = None
        best_dist = None
        for rr in range(h):
            for cc in range(w):
                val = grid[rr][cc]
                # skip inside the folded rectangle (including border) and skip background/fold color
                if min_r <= rr <= max_r and min_c <= cc <= max_c:
                    continue
                if val == 0 or val == fold_color:
                    continue
                # distance to rectangle (Manhattan distance to nearest perimeter cell)
                dx = 0
                if cc < min_c:
                    dx = min_c - cc
                elif cc > max_c:
                    dx = cc - max_c
                dy = 0
                if rr < min_r:
                    dy = min_r - rr
                elif rr > max_r:
                    dy = rr - max_r
                dist = dx + dy
                if best_dist is None or dist < best_dist:
                    best_dist = dist
                    best = (rr, cc)
        if best is None:
            continue
        sr, sc = best

        # Determine side of the source relative to the folded rectangle
        if sc < min_c:
            side = 'left'
        elif sc > max_c:
            side = 'right'
        elif sr < min_r:
            side = 'up'
        else:
            side = 'down'

        # Flood-fill from the best pixel to find the full source region (any non-zero, non-fold_color)
        color_ok = lambda rr, cc: 0 <= rr < h and 0 <= cc < w and grid[rr][cc] != 0 and grid[rr][cc] != fold_color
        stack = [best]
        seen = {best}
        src_cells = []
        while stack:
            rr, cc = stack.pop()
            src_cells.append((rr, cc))
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = rr + dr, cc + dc
                if 0 <= nr < h and 0 <= nc < w and (nr, nc) not in seen and color_ok(nr, nc):
                    seen.add((nr, nc))
                    stack.append((nr, nc))

        if not src_cells:
            continue

        src_min_r = min(p[0] for p in src_cells)
        src_max_r = max(p[0] for p in src_cells)
        src_min_c = min(p[1] for p in src_cells)
        src_max_c = max(p[1] for p in src_cells)

        src_h = src_max_r - src_min_r + 1
        src_w = src_max_c - src_min_c + 1

        inner_h = inner_r2 - inner_r1 + 1
        inner_w = inner_c2 - inner_c1 + 1

        # If sizes match (expected), copy source content into folded interior in non-mirrored orientation
        if src_h == inner_h and src_w == inner_w:
            for dr in range(inner_h):
                for dc in range(inner_w):
                    output[inner_r1 + dr][inner_c1 + dc] = grid[src_min_r + dr][src_min_c + dc]
            # Remove border by setting perimeter to background (0)
            for cc in range(min_c, max_c + 1):
                output[min_r][cc] = 0
                output[max_r][cc] = 0
            for rr in range(min_r, max_r + 1):
                output[rr][min_c] = 0
                output[rr][max_c] = 0
        else:
            # Fallback: attempt to copy overlapping region (should rarely be used)
            copy_h = min(inner_h, src_h)
            copy_w = min(inner_w, src_w)
            for dr in range(copy_h):
                for dc in range(copy_w):
                    output[inner_r1 + dr][inner_c1 + dc] = grid[src_min_r + dr][src_min_c + dc]
            for cc in range(min_c, max_c + 1):
                output[min_r][cc] = 0
                output[max_r][cc] = 0
            for rr in range(min_r, max_r + 1):
                output[rr][min_c] = 0
                output[rr][max_c] = 0

    return output

