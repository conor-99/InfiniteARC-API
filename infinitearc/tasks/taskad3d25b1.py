# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: ad3d25b1
Difficulty: insane

=== Tags ===
- Layered path system
- Local to global rule inference
- Rule embedding
- Directed cave maze

=== Description ===
Input grids are large (25×25) with a single background color (0). Walls (colors
1–9) form a maze with a single continuous passage from the left edge to the top
edge, creating a directional cave system. Embedded within the walls are 2×2
direction tiles, each displaying a unique color arrangement. Each tile's color
configuration encodes a directional rule through its diagonal relationships: the
main diagonal (top-left to bottom-right) indicates rightward movement when both
cells share a hue category (e.g., warm colors), while the anti-diagonal (top-
right to bottom-left) indicates upward movement when both cells share a
complementary hue category (e.g., cool colors). The maze contains no dead ends,
and tiles are placed such that each tile is adjacent to the passage path at
critical turning points. The path starts at the leftmost passage cell and
follows the directional rules encoded in the nearest tile at each step, exiting
at the top edge. The output grid preserves all walls, tiles, and background
unchanged, but replaces the passage cells with a repeating color cycle (e.g., 5
→ 6 → 7 → 5 → 6 → 7...) based on path segment position. The cycle advances one
step per cell traversed, with the first cell colored 5, the second 6, etc. No
path cell overlaps walls, tiles, or background color 0. The task requires
inferring the diagonal hue categories and directional mapping from a minimal set
of input-output pairs, making the rule non-obvious and dependent on global
pattern recognition within the maze structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque

def generate():
    size = 25
    grid_in = [[0] * size for _ in range(size)]
    
    # Generate path from (0,12) to (5,0)
    path = []
    x, y = 0, 12
    path.append((x, y))
    for _ in range(5):
        x += 1
        path.append((x, y))
    for _ in range(12):
        y -= 1
        path.append((x, y))
    
    # Set all non-path cells to random walls (1-9)
    for i in range(size):
        for j in range(size):
            if (i, j) not in path:
                grid_in[i][j] = random.randint(1, 9)
    
    # Place a tile at the turn (x=5, y=12) for up direction
    tile_x, tile_y = 5, 13
    cool_color = random.randint(4, 6)
    grid_in[tile_x][tile_y + 1] = cool_color  # (5,14)
    grid_in[tile_x + 1][tile_y] = cool_color  # (6,13)
    grid_in[tile_x][tile_y] = random.randint(1, 9)
    grid_in[tile_x + 1][tile_y + 1] = random.randint(1, 9)
    
    # Create output grid: replace path cells with color cycle
    grid_out = [row[:] for row in grid_in]
    cycle = [5, 6, 7]
    for idx, (x, y) in enumerate(path):
        grid_out[x][y] = cycle[idx % 3]
    
    return {
        "input": grid_in,
        "output": grid_out
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    grid = [list(row) for row in input_grid]
    size = len(grid)
    
    # Find all 0 cells connected to left edge
    visited = [[False] * size for _ in range(size)]
    queue = deque()
    for y in range(size):
        if grid[0][y] == 0:
            queue.append((0, y))
            visited[0][y] = True
    
    path_cells = []
    while queue:
        x, y = queue.popleft()
        path_cells.append((x, y))
        for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:
            nx, ny = x + dx, y + dy
            if 0 <= nx < size and 0 <= ny < size and not visited[nx][ny] and grid[nx][ny] == 0:
                visited[nx][ny] = True
                queue.append((nx, ny))
    
    # Find start (left edge) and end (top edge)
    start = next((x, y) for x, y in path_cells if x == 0)
    end = next((x, y) for x, y in path_cells if y == 0)
    
    # Reconstruct path order from start to end
    parent = {}
    queue = deque([start])
    visited = {start: True}
    while queue:
        x, y = queue.popleft()
        if (x, y) == end:
            break
        for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:
            nx, ny = x + dx, y + dy
            if (nx, ny) in path_cells and (nx, ny) not in visited:
                visited[(nx, ny)] = True
                parent[(nx, ny)] = (x, y)
                queue.append((nx, ny))
    
    # Build path in order
    path_ordered = []
    curr = end
    while curr != start:
        path_ordered.append(curr)
        curr = parent[curr]
    path_ordered.append(start)
    path_ordered = path_ordered[::-1]
    
    # Apply color cycle
    cycle = [5, 6, 7]
    for idx, (x, y) in enumerate(path_ordered):
        grid[x][y] = cycle[idx % 3]
    
    return tuple(tuple(row) for row in grid)
