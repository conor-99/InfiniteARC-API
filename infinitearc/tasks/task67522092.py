# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 67522092
Difficulty: easy

=== Tags ===
- Adapt image to grid
- Associate images to numbers
- Pattern completion
- Associate colors to patterns

=== Description ===
The task involves input grids containing a single connected region (4-connected)
of a non-zero color, where the color value does not equal the region's size. The
output grid replaces every cell in this region with the region's size count (a
single digit between 1 and 9), while all other cells remain unchanged. For
example, a 2×2 square (size 4) colored with 3 becomes a 2×2 square of 4s. The
largest region is always unique in the input grid, ensuring deterministic
transformation. The rule relies on abstract reasoning about connected regions
and numeric association, avoiding visual matching or memorization.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    max_size = min(9, width * height)
    n = random.randint(1, max_size)
    c = random.randint(1, 9)
    while c == n:
        c = random.randint(1, 9)
    pixels = common.continuous_creature(n, width, height)
    input_grid = common.grid(width, height, 0)
    for r, c_pos in pixels:
        input_grid[r][c_pos] = c
    output_grid = common.grid(width, height, 0)
    for r, c_pos in pixels:
        output_grid[r][c_pos] = n
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    non_zero = []
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                non_zero.append((r, c))
    if not non_zero:
        return input_grid
    visited = set()
    stack = [non_zero[0]]
    component = []
    while stack:
        r, c = stack.pop()
        if (r, c) in visited:
            continue
        visited.add((r, c))
        component.append((r, c))
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and input_grid[nr][nc] != 0 and (nr, nc) not in visited:
                stack.append((nr, nc))
    size = len(component)
    output = [[input_grid[i][j] for j in range(width)] for i in range(height)]
    for r, c in component:
        output[r][c] = size
    return output
