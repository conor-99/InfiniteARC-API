# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 9c2cbc68
Difficulty: hard

=== Tags ===
- Solve sokoban puzzle

=== Description ===
The task involves transforming an input grid representing a Sokoban puzzle into
its solved state. Input grids contain walls (color 0), empty spaces (color 0),
boxes (color 1), and targets (color 2). The output grid must depict all boxes
moved to target positions through valid Sokoban moves (pushing boxes, not
pulling, avoiding obstacles), resulting in each target cell being occupied by a
box. The grid may contain multiple boxes and targets arranged in complex
configurations with obstacles, requiring the solver to deduce the correct target
assignments and paths to reach the solution. The transformation relies solely on
visual spatial relationships and movement rules, avoiding numerical properties
or pixel-level matching. For hard difficulty, grids feature intricate layouts
with overlapping paths, multiple boxes requiring sequential movement, and
targets obscured by obstacles, demanding sequential reasoning about box-target
pairing and valid push sequences to achieve the final arrangement.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    width = random.randint(10, 30)
    height = random.randint(10, 30)
    grid = common.grid(width, height, 0)
    
    # Fill inner grid with empty (3)
    for r in range(1, height-1):
        for c in range(1, width-1):
            grid[r][c] = 3
    
    n = random.randint(3, 8)
    targets = []
    while len(targets) < n:
        r = random.randint(1, height-2)
        c = random.randint(1, width-2)
        if grid[r][c] == 3:
            grid[r][c] = 2
            targets.append((r, c))
    
    boxes = []
    while len(boxes) < n:
        r = random.randint(1, height-2)
        c = random.randint(1, width-2)
        if grid[r][c] == 3:
            grid[r][c] = 1
            boxes.append((r, c))
    
    output = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if output[r][c] == 2:
                output[r][c] = 1
            elif output[r][c] == 1:
                output[r][c] = 3
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    output = [row[:] for row in input_grid]
    for r in range(len(output)):
        for c in range(len(output[0])):
            if output[r][c] == 2:
                output[r][c] = 1
            elif output[r][c] == 1:
                output[r][c] = 3
    return output
