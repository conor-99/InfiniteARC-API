# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 25a669e6
Difficulty: hard

=== Tags ===
- Region partitioning
- Pattern guided construction
- Permute rows by length

=== Description ===
The input grid is a 2D array with dimensions between 1×1 and 30×30, featuring a
single background color (0) and multiple non-background regions (colors 1-9).
Each region is a connected component of identical non-zero color, with no
overlapping regions. Regions may vary in size and shape, separated by background
cells, and may include irregular shapes, varying densities, and multiple regions
intersecting the same row.  The output grid is constructed through the following
steps:   1. Partition the input grid into connected regions using 4-connectivity
(up/down/left/right).   2. For each row, count the number of distinct regions
that intersect that row (i.e., regions containing at least one cell in the row).
3. Sort the rows of the input grid in descending order based on this
intersection count. Rows with identical counts retain their original relative
order.    The output grid is the input grid with rows reordered according to
this sorted sequence. The transformation requires recognizing region boundaries,
quantifying row-region intersections, and applying a deterministic permutation
based on intersection counts.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import math
from collections import deque
import common


def generate():
    """
    Generate a random grid and its row-permuted output according to the task rules:
    - Build several non-overlapping 4-connected regions (colors 1-9) on a background 0.
    - Compute connected components (4-connectivity, same color) and for each row count
      how many distinct components intersect that row.
    - Sort rows in descending order of that count (stable for ties) to make the output.

    The generator avoids pathological infinite loops by bounding attempts and always
    falling back to a simple grid if generation repeatedly fails (highly unlikely).
    """
    # Try multiple times to produce a grid where the output differs from the input.
    for global_attempt in range(300):
        # Keep sizes moderate to make placement reliable and varied.
        width = random.randint(2, 12)
        height = random.randint(2, 12)
        area = width * height

        grid = [[0 for _ in range(width)] for _ in range(height)]
        occupied = set()

        # Number of regions: at least 2, at most 6, but also not exceeding available area
        max_regions = min(6, max(2, area // 4))
        num_regions = random.randint(2, max_regions)

        colors = list(range(1, 10))
        random.shuffle(colors)

        placed_regions = 0

        for region_idx in range(num_regions):
            remaining_regions = num_regions - region_idx
            remaining_capacity = area - len(occupied)
            if remaining_capacity <= 0:
                break

            # Limit individual region size so placement remains easy
            max_size = min(8, remaining_capacity - (remaining_regions - 1))
            if max_size <= 0:
                break
            size = random.randint(1, max(1, max_size))

            # Choose a small bounding box for the creature that can contain `size` cells
            box_width = random.randint(1, min(width, size))
            box_height = int(math.ceil(size / box_width))
            # If the computed box is too tall, swap strategy
            if box_height > height:
                box_height = min(height, size)
                box_width = int(math.ceil(size / box_height))

            # As a last resort force 1x1
            if box_width > width or box_height > height:
                box_width = 1
                box_height = 1
                size = 1

            # Build a contiguous creature inside the bounding box
            pixels_local = common.continuous_creature(size, width=box_width, height=box_height)

            # Try multiple anchor positions within the full grid until a non-overlapping spot is found
            possible_positions = [(r, c) for r in range(0, height - box_height + 1) for c in range(0, width - box_width + 1)]
            random.shuffle(possible_positions)
            placed = False
            for (top_r, left_c) in possible_positions[:max(1, min(len(possible_positions), 40))]:
                adjusted = [(r + top_r, c + left_c) for r, c in pixels_local]
                if any((r, c) in occupied for r, c in adjusted):
                    continue
                # Place region with a random color
                color = random.choice(colors)
                for r, c in adjusted:
                    grid[r][c] = color
                    occupied.add((r, c))
                placed = True
                placed_regions += 1
                break

            if not placed:
                # Fallback: place one free cell if possible
                free_positions = [(r, c) for r in range(height) for c in range(width) if (r, c) not in occupied]
                if not free_positions:
                    break
                r0, c0 = random.choice(free_positions)
                grid[r0][c0] = random.choice(colors)
                occupied.add((r0, c0))
                placed_regions += 1

        # Require at least two placed regions to make the problem meaningful
        if placed_regions < 2:
            continue

        # Compute connected components (4-connectivity, same non-zero color)
        visited = [[False] * width for _ in range(height)]
        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        components_rows = []  # list of sets of row indices for each component

        for r in range(height):
            for c in range(width):
                if grid[r][c] != 0 and not visited[r][c]:
                    col = grid[r][c]
                    dq = deque([(r, c)])
                    visited[r][c] = True
                    comp_rows = set()
                    while dq:
                        cr, cc = dq.popleft()
                        comp_rows.add(cr)
                        for dr, dc in directions:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == col:
                                visited[nr][nc] = True
                                dq.append((nr, nc))
                    components_rows.append(comp_rows)

        # For each row count how many distinct components intersect it
        row_counts = [0] * height
        for comp in components_rows:
            for rr in comp:
                row_counts[rr] += 1

        # Stable sort rows by descending count (Python sort is stable so ties keep original order)
        sorted_indices = sorted(range(height), key=lambda i: row_counts[i], reverse=True)
        output_grid = [list(grid[i]) for i in sorted_indices]

        # Ensure the transformation actually changes the grid (generator must not return input==output)
        if output_grid == grid:
            # try again with a new random seed / layout
            continue

        return {"input": grid, "output": output_grid}

    # Fallback if generation failed many times (very unlikely): small handcrafted instance
    fallback = [[0, 1, 0], [2, 0, 2], [0, 3, 0]]
    return {"input": fallback, "output": [fallback[1], fallback[0], fallback[2]]}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    # Convert tuple-of-tuples to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    if height == 0:
        return []
    width = len(grid[0])

    visited = [[False] * width for _ in range(height)]
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]

    components_rows = []

    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and not visited[r][c]:
                color = grid[r][c]
                dq = deque([(r, c)])
                visited[r][c] = True
                comp_rows = set()
                while dq:
                    cr, cc = dq.popleft()
                    comp_rows.add(cr)
                    for dr, dc in directions:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            dq.append((nr, nc))
                components_rows.append(comp_rows)

    # Count how many distinct components intersect each row
    row_counts = [0] * height
    for comp in components_rows:
        for rr in comp:
            row_counts[rr] += 1

    # Stable sort rows by descending count (ties keep original order)
    sorted_indices = sorted(range(height), key=lambda i: row_counts[i], reverse=True)
    output = [list(grid[i]) for i in sorted_indices]
    return output

