# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: f67741c5
Difficulty: hard

=== Tags ===
- Variable binding by color
- Split and merge

=== Description ===
Task Name: Dynamic Color Morphology  Description: Input grids are 25×25 with a
background color (0) and multiple distinct contiguous regions (blobs) of colors
1–9. Each blob's color determines its transformation behavior:  - **Splitting**:
A blob of color *C* splits into two blobs of colors *S(C)* and *M(C)* if it
shares an edge with any blob of color *C*. The split occurs symmetrically,
dividing the original blob into two connected components while maintaining the
original blob's overall shape. *S(C)* and *M(C)* follow a fixed cyclic mapping:
color 1 splits into 2 and 9, color 2 into 3 and 1, color 3 into 4 and 2, ...,
color 9 into 1 and 8.  - **Merging**: A blob of color *C* merges with all edge-
adjacent blobs of color *C* into a single larger blob of color *C*. Merges are
applied only after all splits are resolved.  The transformation sequence is: 1.
Simultaneously apply all splitting rules to the input grid. 2. Apply all merging
rules to the grid resulting from step 1.  The output grid reflects all splits
and merges, with new blobs maintaining connectivity and non-overlapping
properties. Background color (0) remains unchanged. No blob changes if it lacks
required neighbors. The cyclic color mapping creates interdependent
transformations (e.g., a split blob of color 1 may create blobs that trigger
further splits), requiring sequential reasoning across the grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common
from collections import deque

# Generator for ARC task: Dynamic Color Morphology
# Produces a 25x25 input grid with multiple rectangular blobs and an output grid
# after applying deterministic splitting rules (and conceptual merging).

NEIGHBORS = [(1,0),(-1,0),(0,1),(0,-1)]


def find_all_blobs(ingrid):
    h = len(ingrid)
    w = len(ingrid[0])
    visited = [[False]*w for _ in range(h)]
    blobs = []  # list of tuples (color, blob_pixels_list)
    for r in range(h):
        for c in range(w):
            if ingrid[r][c] != 0 and not visited[r][c]:
                color = ingrid[r][c]
                stack = [(r,c)]
                visited[r][c] = True
                blob = []
                while stack:
                    cr,cc = stack.pop()
                    blob.append((cr,cc))
                    for dr,dc in NEIGHBORS:
                        nr,nc = cr+dr, cc+dc
                        if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and ingrid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr,nc))
                blobs.append((color, blob))
    return blobs


def needs_split(blob, ingrid, color):
    h = len(ingrid)
    w = len(ingrid[0])
    # A blob needs to split if any of its pixels is edge-adjacent to a pixel of a different non-background color
    for (r,c) in blob:
        for dr,dc in NEIGHBORS:
            nr,nc = r+dr, c+dc
            if 0 <= nr < h and 0 <= nc < w:
                v = ingrid[nr][nc]
                if v != 0 and v != color:
                    return True
    return False


def split_blob(blob):
    # Split a connected blob into two connected parts using deterministic two-seed BFS expansion.
    if len(blob) <= 1:
        return blob[:], []
    blob_set = set(blob)
    # find the farthest pair (deterministic)
    maxd = -1
    s1 = blob[0]
    s2 = blob[0]
    for p in blob:
        for q in blob:
            d = abs(p[0]-q[0]) + abs(p[1]-q[1])
            if d > maxd:
                maxd = d
                s1, s2 = p, q
    if s1 == s2:
        # fallback: choose two different pixels lexicographically
        s1 = min(blob)
        s2 = max(blob)
        if s1 == s2:
            return blob[:], []

    a1 = set([s1])
    a2 = set([s2])
    assigned = set([s1, s2])
    q1 = deque([s1])
    q2 = deque([s2])

    # alternate expansion favoring the smaller region to keep parts balanced
    while len(assigned) < len(blob):
        # choose which queue to expand
        if (len(a1) <= len(a2) and q1) or not q2:
            if not q1:
                # nothing to expand, break to avoid infinite loop
                break
            cr,cc = q1.popleft()
            for dr,dc in NEIGHBORS:
                nxt = (cr+dr, cc+dc)
                if nxt in blob_set and nxt not in assigned:
                    assigned.add(nxt)
                    a1.add(nxt)
                    q1.append(nxt)
        else:
            if not q2:
                break
            cr,cc = q2.popleft()
            for dr,dc in NEIGHBORS:
                nxt = (cr+dr, cc+dc)
                if nxt in blob_set and nxt not in assigned:
                    assigned.add(nxt)
                    a2.add(nxt)
                    q2.append(nxt)
    # in rare case some pixels remain unassigned (shouldn't happen), assign them to a1
    for p in blob:
        if p not in assigned:
            a1.add(p)
    return list(a1), list(a2)


def can_place(r,c,h,w,ingrid):
    H = len(ingrid)
    W = len(ingrid[0])
    if r < 0 or c < 0 or r + h > H or c + w > W:
        return False
    for rr in range(h):
        for cc in range(w):
            if ingrid[r+rr][c+cc] != 0:
                return False
    return True


def place_rect(r,c,h,w,color,ingrid,records):
    for rr in range(h):
        for cc in range(w):
            ingrid[r+rr][c+cc] = color
    records.append({'r':r,'c':c,'h':h,'w':w,'color':color})


def generate():
    W, H = 25, 25
    ingrid = common.grid(W, H, 0)
    placed = []

    num = random.randint(5, 9)
    # place the first rectangle
    for i in range(num):
        # rectangle sizes
        h = random.randint(2, 6)
        w = random.randint(2, 6)
        color = random.randint(1, 9)
        placed_ok = False
        if i == 0:
            # place first randomly
            for _ in range(200):
                r = random.randint(0, H - h)
                c = random.randint(0, W - w)
                if can_place(r,c,h,w,ingrid):
                    place_rect(r,c,h,w,color,ingrid,placed)
                    placed_ok = True
                    break
        elif i == 1:
            # ensure second rectangle touches the first to guarantee at least one splitting event
            prev = placed[0]
            sides = ['left','right','top','bottom']
            random.shuffle(sides)
            for side in sides:
                for attempt in range(100):
                    if side == 'right':
                        c = prev['c'] + prev['w']
                        r_min = prev['r'] - h + 1
                        r_max = prev['r'] + prev['h'] - 1
                        r = random.randint(max(0, r_min), min(H - h, r_max))
                    elif side == 'left':
                        c = prev['c'] - w
                        r_min = prev['r'] - h + 1
                        r_max = prev['r'] + prev['h'] - 1
                        r = random.randint(max(0, r_min), min(H - h, r_max))
                    elif side == 'bottom':
                        r = prev['r'] + prev['h']
                        c_min = prev['c'] - w + 1
                        c_max = prev['c'] + prev['w'] - 1
                        c = random.randint(max(0, c_min), min(W - w, c_max))
                    else:  # top
                        r = prev['r'] - h
                        c_min = prev['c'] - w + 1
                        c_max = prev['c'] + prev['w'] - 1
                        c = random.randint(max(0, c_min), min(W - w, c_max))
                    if can_place(r,c,h,w,ingrid):
                        place_rect(r,c,h,w,color,ingrid,placed)
                        placed_ok = True
                        break
                if placed_ok:
                    break
            if not placed_ok:
                # fallback to random
                for _ in range(200):
                    r = random.randint(0, H - h)
                    c = random.randint(0, W - w)
                    if can_place(r,c,h,w,ingrid):
                        place_rect(r,c,h,w,color,ingrid,placed)
                        placed_ok = True
                        break
        else:
            # place other rectangles randomly (allow occasional adjacency)
            for _ in range(300):
                r = random.randint(0, H - h)
                c = random.randint(0, W - w)
                if can_place(r,c,h,w,ingrid):
                    place_rect(r,c,h,w,color,ingrid,placed)
                    placed_ok = True
                    break
        if not placed_ok:
            # if placement failed (rare), skip this rectangle
            continue

    # Now compute the output grid by applying the deterministic splitting rule
    blobs = find_all_blobs(ingrid)
    to_split = []  # list of tuples (color, blob)
    for color, blob in blobs:
        if needs_split(blob, ingrid, color) and len(blob) > 1:
            to_split.append((color, blob))

    outgrid = [row[:] for row in ingrid]

    for color, blob in to_split:
        part1, part2 = split_blob(blob)
        s_color = (color % 9) + 1
        m_color = ((color + 7) % 9) + 1
        # assign part1 to s_color, part2 to m_color
        for (r,c) in part1:
            outgrid[r][c] = s_color
        for (r,c) in part2:
            outgrid[r][c] = m_color

    return {"input": ingrid, "output": outgrid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

NEIGHBORS = [(1,0),(-1,0),(0,1),(0,-1)]


def find_all_blobs(ingrid):
    h = len(ingrid)
    w = len(ingrid[0])
    visited = [[False]*w for _ in range(h)]
    blobs = []  # list of tuples (color, blob_pixels_list)
    for r in range(h):
        for c in range(w):
            if ingrid[r][c] != 0 and not visited[r][c]:
                color = ingrid[r][c]
                stack = [(r,c)]
                visited[r][c] = True
                blob = []
                while stack:
                    cr,cc = stack.pop()
                    blob.append((cr,cc))
                    for dr,dc in NEIGHBORS:
                        nr,nc = cr+dr, cc+dc
                        if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and ingrid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr,nc))
                blobs.append((color, blob))
    return blobs


def needs_split(blob, ingrid, color):
    h = len(ingrid)
    w = len(ingrid[0])
    # same deterministic rule as generator: split if touches a different non-zero color
    for (r,c) in blob:
        for dr,dc in NEIGHBORS:
            nr,nc = r+dr, c+dc
            if 0 <= nr < h and 0 <= nc < w:
                v = ingrid[nr][nc]
                if v != 0 and v != color:
                    return True
    return False


def split_blob(blob):
    if len(blob) <= 1:
        return blob[:], []
    blob_set = set(blob)
    maxd = -1
    s1 = blob[0]
    s2 = blob[0]
    for p in blob:
        for q in blob:
            d = abs(p[0]-q[0]) + abs(p[1]-q[1])
            if d > maxd:
                maxd = d
                s1, s2 = p, q
    if s1 == s2:
        s1 = min(blob)
        s2 = max(blob)
        if s1 == s2:
            return blob[:], []

    a1 = set([s1])
    a2 = set([s2])
    assigned = set([s1, s2])
    q1 = deque([s1])
    q2 = deque([s2])

    while len(assigned) < len(blob):
        if (len(a1) <= len(a2) and q1) or not q2:
            if not q1:
                break
            cr,cc = q1.popleft()
            for dr,dc in NEIGHBORS:
                nxt = (cr+dr, cc+dc)
                if nxt in blob_set and nxt not in assigned:
                    assigned.add(nxt)
                    a1.add(nxt)
                    q1.append(nxt)
        else:
            if not q2:
                break
            cr,cc = q2.popleft()
            for dr,dc in NEIGHBORS:
                nxt = (cr+dr, cc+dc)
                if nxt in blob_set and nxt not in assigned:
                    assigned.add(nxt)
                    a2.add(nxt)
                    q2.append(nxt)
    for p in blob:
        if p not in assigned:
            a1.add(p)
    return list(a1), list(a2)


def p(input_grid):
    # convert to mutable list of lists
    ingrid = [list(row) for row in input_grid]
    h = len(ingrid)
    w = len(ingrid[0])

    blobs = find_all_blobs(ingrid)
    to_split = []
    for color, blob in blobs:
        if needs_split(blob, ingrid, color) and len(blob) > 1:
            to_split.append((color, blob))

    outgrid = [row[:] for row in ingrid]
    for color, blob in to_split:
        part1, part2 = split_blob(blob)
        s_color = (color % 9) + 1
        m_color = ((color + 7) % 9) + 1
        for (r,c) in part1:
            outgrid[r][c] = s_color
        for (r,c) in part2:
            outgrid[r][c] = m_color

    return outgrid

