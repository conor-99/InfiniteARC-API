# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: b57be776
Difficulty: mediumâ€“hard

=== Tags ===
- Tunnel connection
- Friction path
- Cooperative rule network
- Paired color flow
- Fill single gap

=== Description ===
Input grids feature a background color and multiple tunnel paths, each formed by
two alternating non-background colors (e.g., red and blue) along a continuous
route. Each tunnel connects two endpoints, but exactly one tunnel contains a
single background cell (gap) within its path, surrounded by two cells of the
same color (e.g., red on both sides). The output grid fills this gap with the
complementary color of the surrounding cells, restoring the alternating pattern.
All other tunnels and background elements remain unchanged, with no other
modifications applied. The transformation requires identifying the tunnel with
the gap, recognizing the alternating color pair, and applying the complementary
color rule to the single missing segment while preserving all other structural
features.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    input_grid = common.grid(width, height, 0)
    output_grid = common.grid(width, height, 0)
    
    colors = list(range(1, 10))
    c1, c2 = random.sample(colors, 2)
    
    start_col = random.randint(2, width - 6)
    path1 = [(0, start_col + i) for i in range(6)]
    for i, (r, c) in enumerate(path1):
        color = c1 if i % 2 == 0 else c2
        input_grid[r][c] = color
        output_grid[r][c] = color
    gap_idx = random.randint(1, 4)
    r_gap, c_gap = path1[gap_idx]
    input_grid[r_gap][c_gap] = 0
    fill_color = c1 if gap_idx % 2 == 0 else c2
    output_grid[r_gap][c_gap] = fill_color
    
    start_row = random.randint(2, height - 5)
    path2 = [(start_row + i, 0) for i in range(5)]
    for i, (r, c) in enumerate(path2):
        color = c1 if i % 2 == 0 else c2
        input_grid[r][c] = color
        output_grid[r][c] = color
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    input_list = [list(row) for row in input_grid]
    width = len(input_list[0])
    height = len(input_list)
    
    gap_r, gap_c = None, None
    for r in range(height):
        for c in range(width):
            if input_list[r][c] == 0:
                # Check vertical neighbors (up and down)
                if r > 0 and r < height - 1:
                    if input_list[r-1][c] != 0 and input_list[r+1][c] != 0 and input_list[r-1][c] == input_list[r+1][c]:
                        Y = input_list[r-2][c] if input_list[r-2][c] != 0 else input_list[r+2][c]
                        gap_r, gap_c = r, c
                        break
                # Check horizontal neighbors (left and right)
                if c > 0 and c < width - 1:
                    if input_list[r][c-1] != 0 and input_list[r][c+1] != 0 and input_list[r][c-1] == input_list[r][c+1]:
                        Y = input_list[r][c-2] if input_list[r][c-2] != 0 else input_list[r][c+2]
                        gap_r, gap_c = r, c
                        break
        if gap_r is not None:
            break
    
    if gap_r is not None:
        input_list[gap_r][gap_c] = Y
    
    return tuple(tuple(row) for row in input_list)
