# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 1136b258
Difficulty: mediumâ€“hard

=== Tags ===
- Topological invariance
- Pattern coloring
- Cluster by color

=== Description ===
Input grids feature disconnected clusters of various colors. The output grid
preserves only the highest cluster for each color (the cluster whose topmost
cell is in the smallest row index), with all other cells of that color set to
background (0). The background color remains 0, and all other grid elements
unchanged.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    w = common.randint(5, 30)
    h = common.randint(5, 30)
    input_grid = common.grid(w, h, 0)
    colors_to_use = common.sample(range(1, 6), common.randint(1, 3))
    creatures = []
    for color in colors_to_use:
        creature = common.continuous_creature(3, 3, 3)
        creatures.append(creature)
        for (r, c) in creature:
            input_grid[r][c] = color
        br = h - 3
        bc = w - 3
        for (r, c) in creature:
            input_grid[br + r][bc + c] = color
    output_grid = [row[:] for row in input_grid]
    for i, color in enumerate(colors_to_use):
        br = h - 3
        bc = w - 3
        for (r, c) in creatures[i]:
            output_grid[br + r][bc + c] = 0
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    w = len(input_grid[0])
    h = len(input_grid)
    output_grid = [[0] * w for _ in range(h)]
    for color in range(1, 10):
        visited = [[False] * w for _ in range(h)]
        top_component = None
        min_row = float('inf')
        for r in range(h):
            for c in range(w):
                if input_grid[r][c] == color and not visited[r][c]:
                    component = []
                    queue = [(r, c)]
                    visited[r][c] = True
                    while queue:
                        cr, cc = queue.pop(0)
                        component.append((cr, cc))
                        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                            nr, nc = cr + dr, cc + dc
                            if 0 <= nr < h and 0 <= nc < w and input_grid[nr][nc] == color and not visited[nr][nc]:
                                visited[nr][nc] = True
                                queue.append((nr, nc))
                    comp_min_row = min(comp_row for comp_row, _ in component)
                    if comp_min_row < min_row:
                        min_row = comp_min_row
                        top_component = component
        if top_component is not None:
            for (r, c) in top_component:
                output_grid[r][c] = color
    return output_grid
