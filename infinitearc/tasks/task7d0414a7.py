# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 7d0414a7
Difficulty: insane

=== Tags ===
- Stepwise color transition
- Hollow shape detection
- Folded grid reasoning
- Path following
- Color majority column

=== Description ===
**Task: Folded Path Color Sequence**  **Description:**   Input grids are large
(20×20 or larger) with a background color (0). Overlaid on this background are
multiple axis-aligned hollow rectangles (borders of non-background color, empty
interiors), each with a unique border color. The grid is vertically folded along
its central line (x = width/2), causing paths crossing this line to reflect
direction.    The transformation begins at the top-left corner (0,0), moving
east. For each step, the path's direction is determined by the majority non-
background color in the current column (mode of non-zero values; ties resolved
by smallest color). The path color advances sequentially through a fixed cycle
(2 → 3 → 4 → 2 → ...), drawn only on background cells. Upon reaching the
vertical fold line, the path's direction reflects (e.g., east becomes west,
south becomes north). The path exits the grid after finite steps without
overlapping hollow borders or entering non-background cells.    The output grid
retains all input elements unchanged, with the path drawn using stepwise colors
and direction changes based on column majority and fold reflection.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(20, 30)
    height = random.randint(20, 30)
    input_grid = [[0] * width for _ in range(height)]
    
    num_rects = random.randint(3, 5)
    used_colors = set()
    for _ in range(num_rects):
        color = random.choice([c for c in range(1, 10) if c not in used_colors])
        used_colors.add(color)
        
        top = random.randint(2, height - 4)
        bottom = random.randint(top + 2, height - 2)
        left = random.randint(2, width - 4)
        right = random.randint(left + 2, width - 2)
        
        valid = True
        for r in range(top, bottom + 1):
            for c in range(left, right + 1):
                if r == top or r == bottom or c == left or c == right:
                    if input_grid[r][c] != 0:
                        valid = False
                        break
            if not valid:
                break
        if not valid:
            continue
        
        for r in range(top, bottom + 1):
            for c in range(left, right + 1):
                if r == top or r == bottom or c == left or c == right:
                    input_grid[r][c] = color
    
    col_0 = [input_grid[r][0] for r in range(height)]
    non_zero = [x for x in col_0 if x != 0]
    if non_zero:
        mode = max(set(non_zero), key=non_zero.count)
        if mode != 2:
            zero_indices = [r for r in range(1, height) if input_grid[r][0] == 0]
            if zero_indices:
                num_to_add = (len(non_zero) - non_zero.count(mode)) // 2 + 1
                for r in zero_indices[:num_to_add]:
                    input_grid[r][0] = 2
    else:
        zero_indices = [r for r in range(1, height) if input_grid[r][0] == 0]
        num_to_add = len(zero_indices) // 2
        for r in zero_indices[:num_to_add]:
            input_grid[r][0] = 2
    
    output_grid = [row[:] for row in input_grid]
    fold_line = width // 2
    
    colors = [2, 3, 4]
    current_color_idx = 0
    r, c = 0, 0
    steps = 0
    max_steps = 1000
    while r >= 0 and r < height and c >= 0 and c < width and steps < max_steps:
        if input_grid[r][c] != 0:
            break
        output_grid[r][c] = colors[current_color_idx]
        current_color_idx = (current_color_idx + 1) % 3
        
        col = [input_grid[r][c] for r in range(height)]
        non_zero = [x for x in col if x != 0]
        if non_zero:
            mode = max(set(non_zero), key=non_zero.count)
            if mode == 2:
                dr, dc = 0, 1
            elif mode == 3:
                dr, dc = -1, 0
            elif mode == 4:
                dr, dc = 0, -1
            elif mode == 5:
                dr, dc = 1, 0
            else:
                dr, dc = 0, 1
        else:
            dr, dc = 0, 1
        
        if dc != 0:
            next_c = c + dc
            if next_c == fold_line:
                dc = -dc
        
        r += dr
        c += dc
        steps += 1
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to list of lists if it's a tuple
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    else:
        input_grid = [list(row) for row in input_grid]
    
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = [row[:] for row in input_grid]
    fold_line = width // 2
    
    colors = [2, 3, 4]
    current_color_idx = 0
    r, c = 0, 0
    steps = 0
    max_steps = 1000
    while r >= 0 and r < height and c >= 0 and c < width and steps < max_steps:
        if input_grid[r][c] != 0:
            break
        output_grid[r][c] = colors[current_color_idx]
        current_color_idx = (current_color_idx + 1) % 3
        
        col = [input_grid[r][c] for r in range(height)]
        non_zero = [x for x in col if x != 0]
        if non_zero:
            mode = max(set(non_zero), key=non_zero.count)
            if mode == 2:
                dr, dc = 0, 1
            elif mode == 3:
                dr, dc = -1, 0
            elif mode == 4:
                dr, dc = 0, -1
            elif mode == 5:
                dr, dc = 1, 0
            else:
                dr, dc = 0, 1
        else:
            dr, dc = 0, 1
        
        if dc != 0:
            next_c = c + dc
            if next_c == fold_line:
                dc = -dc
        
        r += dr
        c += dc
        steps += 1
    
    return output_grid
