# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: c9e9f1a0
Difficulty: medium–hard

=== Tags ===
- Collision marking
- Threshold by touch count
- Create grid

=== Description ===
Input grids contain a background color (0) and multiple distinct colored regions
(1–8), each representing a contiguous object. Objects are non-overlapping,
separated by background cells, and may vary in size from single cells to larger
connected blocks. The grid features regions where background cells or object
cells are adjacent to two or more different colored objects (i.e., orthogonally
adjacent to cells of distinct non-background colors).  The output grid is
generated by marking all cells that satisfy the threshold condition: a cell must
have at least two orthogonally adjacent cells belonging to different colored
objects (ignoring background). This includes both background cells surrounded by
multiple objects and object cells bordered by multiple distinct objects. Marked
cells are replaced with a consistent collision color (9), while all other cells
retain their original colors. Cells with fewer than two adjacent different
objects remain unchanged. The transformation requires identifying object
adjacency relationships and applying a threshold-based marking rule, avoiding
numerical sums or pixel-level matching. The task demands visual pattern
recognition across the grid to identify collision points without overwriting
existing object structures.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common
from common import randint

# Generator for ARC Task 451: Collision marking by touch count
# Produces input and output grids where cells adjacent to >=2 distinct non-zero neighbor colors
# are marked with color 9 in the output. Objects are contiguous, non-overlapping, and separated
# by at least one background cell (orthogonally).

# Helper: orthogonal neighbors inside bounds

def orth_neighbors(r, c, height, width):
    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
        nr, nc = r + dr, c + dc
        if 0 <= nr < height and 0 <= nc < width:
            yield (nr, nc)

# Check if cell would be orthogonally adjacent to any occupied coordinates
# (used to preserve separation between objects)

def adjacent_to_occupied(pos, occupied, height, width):
    r, c = pos
    for nr, nc in orth_neighbors(r, c, height, width):
        if (nr, nc) in occupied:
            return True
    return False

# Expand a contiguous shape starting from seed to target size while avoiding adjacency to other
# occupied coordinates. Returns a set of coordinates or None if expansion fails.

def expand_shape(seed, size, occupied, height, width, max_attempts=50):
    # simple randomized BFS-like growth
    shape = set([seed])
    attempts = 0
    while len(shape) < size and attempts < max_attempts:
        attempts += 1
        # gather candidate neighbors of the current shape
        candidates = []
        for (sr, sc) in list(shape):
            for nr, nc in orth_neighbors(sr, sc, height, width):
                if (nr, nc) in shape: continue
                if (nr, nc) in occupied: continue
                # new cell must not be orthogonally adjacent to any existing occupied cell
                if adjacent_to_occupied((nr, nc), occupied, height, width):
                    continue
                candidates.append((nr, nc))
        if not candidates:
            break
        # choose one candidate at random
        newcell = random.choice(candidates)
        shape.add(newcell)
    if len(shape) >= 1:
        return shape
    return None


def generate():
    # Try repeatedly until a valid configuration is built
    tries = 0
    while True:
        tries += 1
        # Choose a modest grid size to allow multiple objects but not too large.
        width = randint(4, 15)
        height = randint(4, 15)
        grid = [[0 for _ in range(width)] for _ in range(height)]
        occupied = set()  # cells occupied by objects

        # Choose number of objects (distinct colors) between 2 and up to 7 but not more than 8 colors
        max_objects = min(7, width * height // 4, 8)
        if max_objects < 2:
            continue
        num_objects = randint(2, max_objects)
        colors = random.sample(list(range(1, 9)), num_objects)

        # Decide how many collision centers to create (each requires at least 2 objects adjacent)
        max_collision_centers = min(3, num_objects // 2)
        if max_collision_centers < 1:
            continue
        num_centers = randint(1, max_collision_centers)

        # Decide degrees (how many object-neighbors around each center), ensuring resource constraints
        degs = []
        remaining = num_objects
        for i in range(num_centers):
            remaining_centers = num_centers - i - 1
            min_need_for_rest = max(0, remaining_centers * 2)
            max_possible = min(4, remaining - min_need_for_rest)
            if max_possible < 2:
                break
            deg = randint(2, max_possible)
            degs.append(deg)
            remaining -= deg
        # If we couldn't allocate degrees correctly, restart
        if sum(degs) > num_objects or len(degs) != num_centers:
            continue

        # Pool of colors to assign to objects
        color_pool = colors[:]
        random.shuffle(color_pool)

        success = True
        centers = []
        # For each collision center, attempt to place it with deg neighbor objects
        for deg in degs:
            placed = False
            attempts_center = 0
            while attempts_center < 120 and not placed:
                attempts_center += 1
                # pick a candidate center away from edges to increase chances
                r = randint(1, height - 2)
                c = randint(1, width - 2)
                if grid[r][c] != 0:
                    continue
                # find neighbor directions that are available to place objects (not occupied and not adjacent to occupied)
                available_dirs = []
                neighbor_positions = [(r+1,c),(r-1,c),(r,c+1),(r,c-1)]
                for pos in neighbor_positions:
                    nr, nc = pos
                    if grid[nr][nc] != 0: continue
                    # neighbor must not be adjacent to any existing occupied cell
                    if adjacent_to_occupied(pos, occupied, height, width):
                        continue
                    available_dirs.append(pos)
                if len(available_dirs) < deg:
                    continue
                # choose deg neighbor positions
                chosen = random.sample(available_dirs, deg)
                # for each chosen neighbor, try to build an object shape anchored at that neighbor
                shapes = []
                temp_occupied = set()
                ok = True
                for _ in range(deg):
                    if not color_pool:
                        ok = False
                        break
                    color = color_pool.pop()  # reserve a color
                    # choose size for this object (1..3)
                    size = randint(1, min(4, width * height))
                    seed = chosen.pop()  # take one chosen neighbor
                    # ensure seed is not adjacent to other occupied cells (we checked earlier), and not overlapping temp_occupied
                    if seed in occupied or seed in temp_occupied:
                        ok = False
                        break
                    shape = expand_shape(seed, size, occupied.union(temp_occupied), height, width)
                    if not shape:
                        # revert this color back and try smaller shape
                        color_pool.append(color)
                        ok = False
                        break
                    shapes.append((shape, color))
                    temp_occupied.update(shape)
                if not ok:
                    # in case of failure, return any popped colors back to pool and try another center
                    # (we popped some colors; ensure color_pool includes them)
                    # To simplify, re-create color_pool as remaining + unused colors
                    # We'll instead reset color_pool by merging colors back from shapes
                    for (s, col) in shapes:
                        color_pool.append(col)
                    random.shuffle(color_pool)
                    continue
                # Commit shapes to grid
                for (shape, col) in shapes:
                    for (sr, sc) in shape:
                        grid[sr][sc] = col
                        occupied.add((sr, sc))
                centers.append((r, c))
                placed = True
            if not placed:
                success = False
                break
        if not success:
            # give up and restart generation
            continue

        # Place remaining colors (each becomes a separated object) if any colors left
        leftover_colors = color_pool[:]
        random.shuffle(leftover_colors)
        for col in leftover_colors:
            placed = False
            attempts_obj = 0
            while attempts_obj < 200 and not placed:
                attempts_obj += 1
                r = randint(0, height - 1)
                c = randint(0, width - 1)
                if grid[r][c] != 0: continue
                if adjacent_to_occupied((r, c), occupied, height, width):
                    continue
                # size for leftover object
                size = randint(1, 4)
                shape = expand_shape((r, c), size, occupied, height, width)
                if not shape:
                    continue
                for (sr, sc) in shape:
                    grid[sr][sc] = col
                    occupied.add((sr, sc))
                placed = True
            # if we couldn't place this leftover color reasonably, skip it

        # Now we have a grid with multiple separated objects. Compute the output by marking
        # any cell (background or object) that has >=2 distinct non-zero neighbor colors.
        output = [row[:] for row in grid]
        changed = False
        for r in range(height):
            for c in range(width):
                neigh_colors = set()
                for nr, nc in orth_neighbors(r, c, height, width):
                    col = grid[nr][nc]
                    if col != 0:
                        neigh_colors.add(col)
                if len(neigh_colors) >= 2:
                    output[r][c] = 9
                    if grid[r][c] != 9:
                        changed = True
        # Ensure there is at least one change
        if not changed:
            # generation failed to create any collision, retry
            if tries > 200:
                # fallback: create a simple guaranteed collision layout
                # place two single-cell objects adjacent to a central background cell
                if height < 3 or width < 3:
                    # make a small 3x3
                    width, height = 3, 3
                    grid = [[0 for _ in range(width)] for _ in range(height)]
                    occupied = set()
                colors_fb = random.sample(list(range(1,9)), 2)
                rc = (height // 2, width // 2)
                # place two objects left and right of center
                left = (rc[0], rc[1] - 1)
                right = (rc[0], rc[1] + 1)
                grid[left[0]][left[1]] = colors_fb[0]
                grid[right[0]][right[1]] = colors_fb[1]
                output = [row[:] for row in grid]
                output[rc[0]][rc[1]] = 9
                return {"input": grid, "output": output}
            continue

        # Sanity checks before returning
        if grid == output:
            # no change, try again
            continue
        return {"input": grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input (tuple of tuples) to a mutable list of lists
    grid_in = [list(row) for row in input_grid]
    height = len(grid_in)
    width = len(grid_in[0]) if height > 0 else 0
    # Keep original for adjacency checks
    original = [row[:] for row in grid_in]
    output = [row[:] for row in original]

    def orth_neighbors(r, c):
        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width:
                yield nr, nc

    for r in range(height):
        for c in range(width):
            neigh_colors = set()
            for nr, nc in orth_neighbors(r, c):
                col = original[nr][nc]
                if col != 0:
                    neigh_colors.add(col)
            if len(neigh_colors) >= 2:
                output[r][c] = 9
    return output

