# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 54490eb4
Difficulty: insane

=== Tags ===
- Contextual rule switch
- Color carving
- Extrapolate image from grid

=== Description ===
The input grid consists of a background color (0) overlaid with multiple
disconnected, solid-colored regions (colors 1-8), each forming a contiguous
block of a single color. Within each region, a small central marker (color 9) is
positioned, indicating the focal point for transformation. The output grid is
generated by applying a context-dependent carving operation to each region: the
shape of the carved area (square, circle, triangle, etc.) is determined by the
region's color, with the carving centered on the marker. Crucially, the exact
shape corresponding to each color is not provided but must be inferred through
pattern recognition in the training examples (e.g., regions of color 3
consistently carve a circle, while color 5 carves a triangle). The carving
removes the region's color within the specified shape, revealing the background.
The transformation requires recognizing that the region's color acts as a
contextual switch for the carving rule, and the combined carved shapes across
the grid collectively form a hidden symbolic pattern (e.g., a letter or
geometric motif), demanding both rule inference and visual extrapolation to
complete the transformation. This task challenges the solver to simultaneously
decode the color-shape mapping, apply spatial carving rules, and recognize the
emergent pattern in the output, making it exceptionally complex for an ARC task.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# Generator for ARC task 446: regions with central markers (9). Each region has a color (1-8)
# and a carving shape determined by the color. The carving removes the region's color
# within a shape centered on the marker, revealing background 0. Marker (9) remains.

def _shape_mask(shape, radius):
    """Return list of (dr,dc) offsets included in the shape centered at (0,0)."""
    pts = []
    for dr in range(-radius, radius + 1):
        for dc in range(-radius, radius + 1):
            if shape == "square":
                pts.append((dr, dc))
            elif shape == "circle":
                if dr * dr + dc * dc <= radius * radius:
                    pts.append((dr, dc))
            elif shape == "diamond":
                if abs(dr) + abs(dc) <= radius:
                    pts.append((dr, dc))
            elif shape == "plus":
                if (dr == 0 and abs(dc) <= radius) or (dc == 0 and abs(dr) <= radius):
                    pts.append((dr, dc))
            elif shape == "x":
                if abs(dr) == abs(dc) and abs(dr) <= radius:
                    pts.append((dr, dc))
            elif shape == "hline":
                if dr == 0 and abs(dc) <= radius:
                    pts.append((dr, dc))
            elif shape == "vline":
                if dc == 0 and abs(dr) <= radius:
                    pts.append((dr, dc))
            else:
                # fallback to single pixel
                if dr == 0 and dc == 0:
                    pts.append((dr, dc))
    return pts


def generate():
    # Random grid size but keep within ARC limits and not too small
    width = random.randint(11, 19)
    height = random.randint(11, 19)
    ing = grid(width, height, 0)

    # Fixed mapping from color to carving shape and radius (deterministic across generator and solver)
    color_to_shape = {
        1: ("square", 1),   # 3x3 square
        2: ("circle", 2),   # circle radius 2
        3: ("diamond", 2),  # diamond (Manhattan radius 2)
        4: ("plus", 2),     # plus with arm length 2
        5: ("x", 2),        # X (diagonals) radius 2
        6: ("hline", 2),    # horizontal line length 5
        7: ("vline", 2),    # vertical line length 5
        8: ("square", 2),   # 5x5 filled square
    }

    # Choose number of regions
    num_regions = random.randint(3, 6)

    occupied = set()
    regions = []  # list of tuples (center_r, center_c, color, shape, radius, footprint_cells)

    tries_limit = 500
    attempt = 0
    while len(regions) < num_regions and attempt < tries_limit:
        attempt += 1
        color = random.randint(1, 8)
        shape, radius = color_to_shape[color]
        # Minimum required odd width/height so that center exists
        min_dim = 2 * radius + 1
        # Random odd dimensions >= min_dim
        add_w = random.randint(0, 4)
        add_h = random.randint(0, 4)
        w = min_dim + add_w
        h = min_dim + add_h
        # make odd
        if w % 2 == 0:
            w += 1
        if h % 2 == 0:
            h += 1
        # choose center ensuring the rectangle fits
        center_r = random.randint(h // 2, height - 1 - (h // 2))
        center_c = random.randint(w // 2, width - 1 - (w // 2))
        # build rectangle footprint
        top = center_r - (h // 2)
        left = center_c - (w // 2)
        footprint = [(r, c) for r in range(top, top + h) for c in range(left, left + w)]
        # ensure no overlap with previous regions
        if any((r, c) in occupied for (r, c) in footprint):
            continue
        # Accept region
        for (r, c) in footprint:
            ing[r][c] = color
            occupied.add((r, c))
        # center marker
        ing[center_r][center_c] = 9
        regions.append((center_r, center_c, color, shape, radius, footprint))

    # Ensure we created at least one region; if not, fallback to a single small region
    if not regions:
        center_r = height // 2
        center_c = width // 2
        color = 1
        shape, radius = color_to_shape[color]
        w = h = 3
        top = center_r - 1
        left = center_c - 1
        footprint = [(r, c) for r in range(top, top + h) for c in range(left, left + w)]
        for (r, c) in footprint:
            ing[r][c] = color
        ing[center_r][center_c] = 9
        regions.append((center_r, center_c, color, shape, radius, footprint))

    # Build output by carving shapes (only remove region color; marker 9 stays)
    out = [row[:] for row in ing]
    for (cr, cc, color, shape, radius, _) in regions:
        mask = _shape_mask(shape, radius)
        for (dr, dc) in mask:
            r = cr + dr
            c = cc + dc
            if 0 <= r < height and 0 <= c < width:
                if out[r][c] == color:
                    out[r][c] = 0
    
    return {"input": ing, "output": out}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # Same deterministic mapping as generator
    color_to_shape = {
        1: ("square", 1),
        2: ("circle", 2),
        3: ("diamond", 2),
        4: ("plus", 2),
        5: ("x", 2),
        6: ("hline", 2),
        7: ("vline", 2),
        8: ("square", 2),
    }

    def shape_mask(shape, radius):
        pts = []
        for dr in range(-radius, radius + 1):
            for dc in range(-radius, radius + 1):
                if shape == "square":
                    pts.append((dr, dc))
                elif shape == "circle":
                    if dr * dr + dc * dc <= radius * radius:
                        pts.append((dr, dc))
                elif shape == "diamond":
                    if abs(dr) + abs(dc) <= radius:
                        pts.append((dr, dc))
                elif shape == "plus":
                    if (dr == 0 and abs(dc) <= radius) or (dc == 0 and abs(dr) <= radius):
                        pts.append((dr, dc))
                elif shape == "x":
                    if abs(dr) == abs(dc) and abs(dr) <= radius:
                        pts.append((dr, dc))
                elif shape == "hline":
                    if dr == 0 and abs(dc) <= radius:
                        pts.append((dr, dc))
                elif shape == "vline":
                    if dc == 0 and abs(dr) <= radius:
                        pts.append((dr, dc))
                else:
                    if dr == 0 and dc == 0:
                        pts.append((dr, dc))
        return pts

    # find markers
    markers = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 9:
                markers.append((r, c))

    # For each marker determine region color (look in 8-neighborhood)
    mapping = []  # list of tuples (r,c,color,shape,radius)
    for (r, c) in markers:
        region_color = None
        for dr in (-1, 0, 1):
            for dc in (-1, 0, 1):
                if dr == 0 and dc == 0:
                    continue
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width:
                    val = grid[nr][nc]
                    if val != 0 and val != 9:
                        region_color = val
                        break
            if region_color is not None:
                break
        # if not found in immediate neighborhood, search expanding radius until found
        if region_color is None:
            max_rad = max(height, width)
            found = False
            for rad in range(2, max_rad):
                for dr in range(-rad, rad + 1):
                    for dc in range(-rad, rad + 1):
                        nr, nc = r + dr, c + dc
                        if 0 <= nr < height and 0 <= nc < width:
                            val = grid[nr][nc]
                            if val != 0 and val != 9:
                                region_color = val
                                found = True
                                break
                    if found:
                        break
                if found:
                    break
        if region_color is None:
            # default to 0 (should not happen with generator)
            region_color = 0
        shape, radius = color_to_shape.get(region_color, ("square", 0))
        mapping.append((r, c, region_color, shape, radius))

    # Apply carving to produce output
    out = [row[:] for row in grid]
    for (cr, cc, color, shape, radius) in mapping:
        mask = shape_mask(shape, radius)
        for (dr, dc) in mask:
            r = cr + dr
            c = cc + dc
            if 0 <= r < height and 0 <= c < width:
                if out[r][c] == color:
                    out[r][c] = 0
    return out

