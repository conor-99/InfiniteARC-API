# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 83f60740
Difficulty: mediumâ€“hard

=== Tags ===
- Emergent behavior
- Directional routing
- Boundary tracing

=== Description ===
Directional Boundary Tracer  Input grids feature a single background color (0)
with multiple disjoint, closed regions (each a contiguous area of non-background
colors 1-8). Each cell on the boundary of a region (i.e., cells adjacent to
background or other regions) contains a directional indicator color (1-4), where
1 = right, 2 = down, 3 = left, 4 = up. These indicators are placed such that
following them sequentially forms a continuous, non-intersecting loop around
each region. The loop direction is consistent per region (e.g., all clockwise).
The output grid retains the original regions and background. For each region, a
continuous path is drawn along its boundary using a new color (9), following the
directional indicators. Starting from any boundary cell, the path moves to the
next cell in the direction indicated, continuing until returning to the start.
The path never overlaps with original region cells or background, and all
directional indicators are followed exactly. Multiple regions may exist, each
with their own traced path.  Emergent behavior arises from the interaction of
directional indicators, where the sequence of turns defines the path shape. The
path is uniquely determined by the input's directional cues, with no ambiguity
in the traversal. Boundary cells with directional indicators are never
overwritten in the output, and the traced path forms a closed loop without self-
intersections.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    grid_data = grid(width, height, 0)
    region_colors = random.sample([5,6,7,8], 2)
    regions = []
    for color in region_colors:
        w = random.randint(3, width//3)
        h = random.randint(3, height//3)
        r_start = random.randint(1, height - h - 1)
        c_start = random.randint(1, width - w - 1)
        regions.append((r_start, c_start, w, h, color))
    
    for (r_start, c_start, w, h, color) in regions:
        for r in range(r_start, r_start + h):
            for c in range(c_start, c_start + w):
                if r == r_start:
                    grid_data[r][c] = 4
                elif r == r_start + h - 1:
                    grid_data[r][c] = 2
                elif c == c_start:
                    grid_data[r][c] = 3
                elif c == c_start + w - 1:
                    grid_data[r][c] = 1
                else:
                    grid_data[r][c] = color
    
    output = [row[:] for row in grid_data]
    for r in range(height):
        for c in range(width):
            if grid_data[r][c] == 1:
                if c + 1 < width and grid_data[r][c+1] == 0:
                    output[r][c+1] = 9
            elif grid_data[r][c] == 2:
                if r + 1 < height and grid_data[r+1][c] == 0:
                    output[r+1][c] = 9
            elif grid_data[r][c] == 3:
                if c - 1 >= 0 and grid_data[r][c-1] == 0:
                    output[r][c-1] = 9
            elif grid_data[r][c] == 4:
                if r - 1 >= 0 and grid_data[r-1][c] == 0:
                    output[r-1][c] = 9
    
    return {"input": grid_data, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    for r in range(height):
        for c in range(width):
            if 1 <= grid[r][c] <= 4:
                dr, dc = 0, 0
                if grid[r][c] == 1:
                    dc = 1
                elif grid[r][c] == 2:
                    dr = 1
                elif grid[r][c] == 3:
                    dc = -1
                elif grid[r][c] == 4:
                    dr = -1
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 0:
                    grid[nr][nc] = 9
    
    return grid
