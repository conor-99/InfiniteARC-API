# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 9f7b2195
Difficulty: insane

=== Tags ===
- Blockwise rule application
- Swap positions of two objects

=== Description ===
Input grids consist of multiple distinct connected regions (objects), each
formed by a contiguous block of cells with a single non-background color (0),
surrounded by background. Objects must be fully enclosed by background or grid
boundaries, with no two objects sharing adjacent cells. The output grid is
generated through two sequential, deterministic transformations:  1. **Blockwise
Vertical Mirroring**: Each object is replaced with its vertical mirror image
(left-right flip) within its original bounding box. This preserves the object's
shape and size while flipping its orientation.  2. **Bounding Box Area Swap**:
The two objects with the smallest and largest bounding box areas (width × height
of the minimal rectangle enclosing the object) are identified. Their positions
within the grid are swapped—meaning the entire mirrored object at the smallest
bounding box location moves to the largest bounding box location, and vice
versa. All other objects and background remain unchanged.  The transformation
sequence ensures no overlapping occurs during the swap, as the input grid is
constructed such that the smallest and largest objects have identical
dimensions. The output grid maintains all original grid dimensions, with all
non-swap operations applied before the position swap. This task demands multi-
step reasoning: identifying connected components, computing bounding boxes,
applying geometric transformations, and executing a precise positional swap—all
based purely on visual structural properties rather than color values or
numerical properties.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def min_manhattan_between_rects(r1min,r1max,c1min,c1max,r2min,r2max,c2min,c2max):
    if r1max < r2min:
        dx = r2min - r1max
    elif r2max < r1min:
        dx = r1min - r2max
    else:
        dx = 0
    if c1max < c2min:
        dy = c2min - c1max
    elif c2max < c1min:
        dy = c1min - c2max
    else:
        dy = 0
    return dx + dy


def generate():
    # Generate a grid with two non-adjacent filled rectangles (identical bbox dims)
    for _ in range(200):
        width = random.randint(6, 20)
        height = random.randint(6, 20)
        bbw = random.randint(2, min(10, width - 2))
        bbh = random.randint(2, min(10, height - 2))
        if bbw > width or bbh > height:
            continue
        # pick first bbox
        r1 = random.randint(0, height - bbh)
        c1 = random.randint(0, width - bbw)
        # pick second bbox non-adjacent
        found = False
        for _ in range(300):
            r2 = random.randint(0, height - bbh)
            c2 = random.randint(0, width - bbw)
            if r1 == r2 and c1 == c2:
                continue
            d = min_manhattan_between_rects(r1, r1 + bbh - 1, c1, c1 + bbw - 1,
                                            r2, r2 + bbh - 1, c2, c2 + bbw - 1)
            if d >= 2:
                found = True
                break
        if not found:
            continue
        color1, color2 = random.sample(range(1, 10), 2)
        grid = [[0 for _ in range(width)] for _ in range(height)]
        for rr in range(r1, r1 + bbh):
            for cc in range(c1, c1 + bbw):
                grid[rr][cc] = color1
        for rr in range(r2, r2 + bbh):
            for cc in range(c2, c2 + bbw):
                grid[rr][cc] = color2
        # Step 1: mirror each rectangle inside its bbox (no visible change for filled rect)
        out_step1 = [row[:] for row in grid]
        # build subs
        sub1 = [[grid[r1 + dr][c1 + dc] for dc in range(bbw)] for dr in range(bbh)]
        sub2 = [[grid[r2 + dr][c2 + dc] for dc in range(bbw)] for dr in range(bbh)]
        mir1 = [list(reversed(row)) for row in sub1]
        mir2 = [list(reversed(row)) for row in sub2]
        for dr in range(bbh):
            for dc in range(bbw):
                out_step1[r1 + dr][c1 + dc] = mir1[dr][dc]
                out_step1[r2 + dr][c2 + dc] = mir2[dr][dc]
        # Step 2: swap the two mirrored bounding boxes
        out_final = [row[:] for row in out_step1]
        for dr in range(bbh):
            for dc in range(bbw):
                out_final[r2 + dr][c2 + dc] = mir1[dr][dc]
                out_final[r1 + dr][c1 + dc] = mir2[dr][dc]
        if out_final != grid:
            return {"input": grid, "output": out_final}
    # fallback
    grid = [[0]*6 for _ in range(6)]
    for r in range(1,3):
        for c in range(1,4):
            grid[r][c] = 1
    for r in range(3,5):
        for c in range(3,6):
            grid[r][c] = 2
    out = [row[:] for row in grid]
    # mirror
    for r in range(1,3):
        for c in range(1,4):
            out[r][c] = grid[r][1 + (3 - 1) - (c - 1)]
    for r in range(3,5):
        for c in range(3,6):
            out[r][c] = grid[r][3 + (3 - 1) - (c - 3)]
    # swap
    for r in range(1,3):
        for c in range(1,4):
            out[r + 2][c + 2] = grid[r][c]
            out[r][c] = grid[r + 2][c + 2]
    return {"input": grid, "output": out}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    # Convert input (tuple-of-tuples) to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0
    visited = [[False]*width for _ in range(height)]
    objects = []  # list of dicts with bbox and mirrored subgrid
    dirs = [(1,0),(-1,0),(0,1),(0,-1)]
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0 and not visited[r][c]:
                color = grid[r][c]
                q = deque()
                q.append((r,c))
                visited[r][c] = True
                pixels = []
                while q:
                    cr, cc = q.popleft()
                    pixels.append((cr, cc))
                    for dr, dc in dirs:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            q.append((nr, nc))
                rows = [p[0] for p in pixels]
                cols = [p[1] for p in pixels]
                min_r, max_r = min(rows), max(rows)
                min_c, max_c = min(cols), max(cols)
                h = max_r - min_r + 1
                w = max_c - min_c + 1
                # extract bounding-box subgrid
                sub = [[grid[min_r + dr][min_c + dc] for dc in range(w)] for dr in range(h)]
                # mirror horizontally (left-right) within the bounding box
                mirrored = [list(reversed(row)) for row in sub]
                area = h * w
                objects.append({
                    'min_r': min_r, 'max_r': max_r,
                    'min_c': min_c, 'max_c': max_c,
                    'h': h, 'w': w, 'area': area,
                    'mirrored': mirrored
                })
    if not objects:
        return grid
    # Sort objects by area (bounding-box area)
    objects_sorted = sorted(objects, key=lambda x: x['area'])
    sm = objects_sorted[0]
    lg = objects_sorted[-1]
    # Step 1: place all mirrored objects in their original bounding boxes
    out_step1 = [row[:] for row in grid]
    for obj in objects:
        for dr in range(obj['h']):
            for dc in range(obj['w']):
                out_step1[obj['min_r'] + dr][obj['min_c'] + dc] = obj['mirrored'][dr][dc]
    # Step 2: swap the mirrored contents of smallest and largest bounding boxes
    out = [row[:] for row in out_step1]
    if sm['h'] == lg['h'] and sm['w'] == lg['w']:
        for dr in range(sm['h']):
            for dc in range(sm['w']):
                out[lg['min_r'] + dr][lg['min_c'] + dc] = sm['mirrored'][dr][dc]
                out[sm['min_r'] + dr][sm['min_c'] + dc] = lg['mirrored'][dr][dc]
    return out
