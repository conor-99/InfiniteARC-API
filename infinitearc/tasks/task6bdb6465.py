# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 6bdb6465
Difficulty: insane

=== Tags ===
- Collision marking
- Relational projection
- Mirror pair coordination
- Pathfinding with state
- Separate image
- Image within image

=== Description ===
Input grids are 20×20 grids with a uniform background color (e.g., gray).
Overlaid on the background are two symmetric sets of colored agents (single
cells) positioned left and right of a central 3×3 embedded image. The embedded
image contains a path formed by a sequence of distinct colors (e.g., red, blue,
green), where the direction between consecutive cells in the embedded path
dictates the movement direction for agents in the main grid (e.g., rightward
movement in the embedded path corresponds to rightward movement in the main
grid). Each agent moves step-by-step along the main grid, following the embedded
path’s direction sequence, leaving a trail of its original color. When agents
from mirror pairs (left and right) occupy the same cell (collision), that cell
is marked with a collision color (e.g., orange), and both agents change
direction according to a fixed rule (e.g., turn 90° clockwise). Mirror pair
coordination ensures agents on opposite sides mirror each other’s movement
relative to the grid’s central axis. Pathfinding with state requires agents to
dynamically update their movement direction based on the embedded path’s current
direction and collision events. The output grid displays the main grid with all
agent paths drawn, collision markers at collision points, and the embedded image
remains visually unchanged as a distinct component within the grid. The embedded
path’s sequence and collision rules create a complex interplay of relational
projection, mirror coordination, and state-dependent pathfinding, requiring
users to disentangle multiple layers of interaction to reconstruct the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

# A small deterministic call counter to guarantee uniqueness across multiple calls
_CALL_COUNT = 0

LEFT_COLOR = 2
RIGHT_COLOR = 3
COLLISION_COLOR = 6


def generate():
    """Generate a single training example for the ARC task.

    The generator places a 3x3 embedded image at rows 8-10, cols 8-10 containing a
    short self-avoiding path whose consecutive directions are used to move three
    agents on the left and three mirrored agents on the right. Agents leave
    trails of their original colors; collisions (when a mirrored pair land on
    the same cell) are marked and cause that pair to rotate 90° clockwise for
    future steps. Embedded colors are never overwritten.
    """
    global _CALL_COUNT

    # Deterministic choice pools so every call produces a unique configuration
    # across many calls while remaining varied (ensures 100 unique examples).
    # Use 0 for background so we always have enough distinct colors available for the embedded path.
    bg_choices = [0]
    left_cols = [0, 1, 2, 3, 4]
    base_rows = list(range(4, 16))  # keep agents away from absolute edges

    # Map the call count into a combination of choices to guarantee uniqueness
    idx = _CALL_COUNT
    bg = bg_choices[idx % len(bg_choices)]
    idx //= len(bg_choices)
    left_col = left_cols[idx % len(left_cols)]
    idx //= len(left_cols)
    base_row = base_rows[idx % len(base_rows)]

    # Advance counter and create an RNG seeded from it for deterministic-but-varied
    # path and color choices per call.
    _CALL_COUNT += 1
    rng = random.Random(123456789 ^ (_CALL_COUNT * 9973))

    # Create base grids
    inp = grid(20, 20, bg)
    out = [row[:] for row in inp]

    # Generate a self-avoiding path inside the 3x3 embedded area (positions are 0..2)
    def gen_path():
        moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        for attempt in range(500):
            L = rng.randint(3, 6)  # path length between 3 and 6
            start = (rng.randint(0, 2), rng.randint(0, 2))
            path = [start]
            while len(path) < L:
                r, c = path[-1]
                neighbors = []
                for dr, dc in moves:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < 3 and 0 <= nc < 3 and (nr, nc) not in path:
                        neighbors.append((nr, nc))
                if not neighbors:
                    break
                path.append(rng.choice(neighbors))
            if len(path) == L:
                return path
        # fallback minimal adjacent pair
        return [(0, 0), (0, 1)]

    path = gen_path()

    # Select distinct colors for the embedded path (avoid bg, agent colors, collision)
    # Since bg is 0, this leaves at least 6 colors in 1..9 excluding agent/collision.
    available = [c for c in range(1, 10) if c not in [LEFT_COLOR, RIGHT_COLOR, COLLISION_COLOR]]
    rng.shuffle(available)
    sel = available[: len(path)]
    sel.sort()  # enforce increasing color order along the path so the solver can recover orientation
    path_colors = sel

    # Place embedded path at rows 8..10, cols 8..10
    for (pr, pc), col in zip(path, path_colors):
        inp[8 + pr][8 + pc] = col
        out[8 + pr][8 + pc] = col

    # Place three agents on the left and three mirrored agents on the right
    left_positions = [(base_row - 1, left_col), (base_row, left_col), (base_row + 1, left_col)]
    right_col = 18 - left_col  # symmetric about the embedded center column 9
    right_positions = [(base_row - 1, right_col), (base_row, right_col), (base_row + 1, right_col)]

    for r, c in left_positions:
        inp[r][c] = LEFT_COLOR
        out[r][c] = LEFT_COLOR
    for r, c in right_positions:
        inp[r][c] = RIGHT_COLOR
        out[r][c] = RIGHT_COLOR

    # Build direction sequence from the embedded path (differences between consecutive cells)
    directions = []
    for i in range(1, len(path)):
        dr = path[i][0] - path[i - 1][0]
        dc = path[i][1] - path[i - 1][1]
        directions.append((dr, dc))

    # Helpers
    def rotate(dr, dc, k):
        k = k % 4
        for _ in range(k):
            dr, dc = dc, -dr
        return (dr, dc)

    def clamp(v, a, b):
        return max(a, min(b, v))

    # Simulate movement for the three mirror pairs. Each pair has its own rotation state.
    left_pos = left_positions[:]
    right_pos = right_positions[:]
    rotations = [0, 0, 0]
    collision_cells = set()

    for base_dr, base_dc in directions:
        new_left = []
        new_right = []
        for j in range(3):
            ldr, ldc = rotate(base_dr, base_dc, rotations[j])
            rdr, rdc = ldr, -ldc  # horizontal mirror for the right agent
            lr, lc = left_pos[j]
            rr, rc = right_pos[j]
            nlr = clamp(lr + ldr, 0, 19)
            nlc = clamp(lc + ldc, 0, 19)
            nrr = clamp(rr + rdr, 0, 19)
            nrc = clamp(rc + rdc, 0, 19)
            new_left.append((nlr, nlc))
            new_right.append((nrr, nrc))

        # Check collisions between paired agents and update their rotation state
        for j in range(3):
            if new_left[j] == new_right[j]:
                collision_cells.add(new_left[j])
                rotations[j] = (rotations[j] + 1) % 4

        # Commit positions
        left_pos = new_left
        right_pos = new_right

        # Draw trails on the output grid but do not overwrite embedded pixels
        for (r, c) in left_pos:
            if 0 <= r < 20 and 0 <= c < 20 and inp[r][c] == bg:
                out[r][c] = LEFT_COLOR
        for (r, c) in right_pos:
            if 0 <= r < 20 and 0 <= c < 20 and inp[r][c] == bg:
                out[r][c] = RIGHT_COLOR

    # Mark collisions on the output grid (but never overwrite the embedded image)
    for (r, c) in collision_cells:
        if 0 <= r < 20 and 0 <= c < 20 and inp[r][c] == bg:
            out[r][c] = COLLISION_COLOR

    return {
        'input': inp,
        'output': out,
    }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import Counter

def p(input_grid):
    # Work with a mutable copy of the input
    orig = [list(row) for row in input_grid]
    h = len(orig)
    w = len(orig[0])

    LEFT_COLOR = 2
    RIGHT_COLOR = 3
    COLLISION_COLOR = 6

    # Determine background as the most common color
    counter = Counter()
    for r in range(h):
        for c in range(w):
            counter[orig[r][c]] += 1
    bg = counter.most_common(1)[0][0]

    # Embedded area is fixed at rows 8-10, cols 8-10
    # Extract path cells (collect coordinates and their colors)
    embedded_cells = []  # list of ((r8,c8), color)
    for r in range(8, 11):
        for c in range(8, 11):
            val = orig[r][c]
            if val != bg and val not in (LEFT_COLOR, RIGHT_COLOR, COLLISION_COLOR):
                embedded_cells.append(((r - 8, c - 8), val))

    # Attempt to order by color (generator enforces increasing color order along the path)
    ordered = []
    if embedded_cells:
        # sort by color value
        embedded_cells_sorted = sorted(embedded_cells, key=lambda x: x[1])
        coords_by_color = [coord for coord, _ in embedded_cells_sorted]

        # verify that the color-sorted coordinates form a contiguous 4-connected chain
        def adjacent(a, b):
            return abs(a[0] - b[0]) + abs(a[1] - b[1]) == 1

        ok = True
        for i in range(1, len(coords_by_color)):
            if not adjacent(coords_by_color[i - 1], coords_by_color[i]):
                ok = False
                break
        if ok:
            ordered = coords_by_color

    # Fallback: if color sorting didn't yield a proper chain, reconstruct by adjacency
    if not ordered:
        path_set = set(coord for coord, _ in embedded_cells)

        def neighs(p):
            r, c = p
            for dr, dc in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                q = (r + dr, c + dc)
                if q in path_set:
                    yield q

        if path_set:
            start = None
            for p in path_set:
                if len(list(neighs(p))) <= 1:
                    start = p
                    break
            if start is None:
                start = next(iter(path_set))
            ordered = [start]
            visited = {start}
            while True:
                cur = ordered[-1]
                nxt = None
                for q in neighs(cur):
                    if q not in visited:
                        nxt = q
                        break
                if nxt is None:
                    break
                ordered.append(nxt)
                visited.add(nxt)

    # Compute the direction sequence from the embedded path (in embedded coordinates)
    directions = []
    for i in range(1, len(ordered)):
        dr = ordered[i][0] - ordered[i - 1][0]
        dc = ordered[i][1] - ordered[i - 1][1]
        directions.append((dr, dc))

    # Find agent initial positions
    left_positions = [(r, c) for r in range(h) for c in range(w) if orig[r][c] == LEFT_COLOR]
    right_positions = [(r, c) for r in range(h) for c in range(w) if orig[r][c] == RIGHT_COLOR]

    left_positions = sorted(left_positions, key=lambda x: (x[0], x[1]))
    right_positions = sorted(right_positions, key=lambda x: (x[0], x[1]))

    # Prepare result grid
    result = [row[:] for row in orig]

    # Simulation helpers
    def rotate(dr, dc, k):
        k = k % 4
        for _ in range(k):
            dr, dc = dc, -dr
        return (dr, dc)

    def clamp(v, a, b):
        return max(a, min(b, v))

    # Simulate the same rules as the generator
    left_pos = left_positions[:]
    right_pos = right_positions[:]
    rotations = [0] * max(1, len(left_pos))
    collision_cells = set()

    for base_dr, base_dc in directions:
        new_left = []
        new_right = []
        for j in range(len(left_pos)):
            lr, lc = left_pos[j]
            rr, rc = right_pos[j]
            ldr, ldc = rotate(base_dr, base_dc, rotations[j])
            rdr, rdc = ldr, -ldc
            nlr = clamp(lr + ldr, 0, h - 1)
            nlc = clamp(lc + ldc, 0, w - 1)
            nrr = clamp(rr + rdr, 0, h - 1)
            nrc = clamp(rc + rdc, 0, w - 1)
            new_left.append((nlr, nlc))
            new_right.append((nrr, nrc))

        # Detect collisions and update rotation state for that pair
        for j in range(len(new_left)):
            if new_left[j] == new_right[j]:
                collision_cells.add(new_left[j])
                rotations[j] = (rotations[j] + 1) % 4

        left_pos = new_left
        right_pos = new_right

        # Draw trails on cells that were background in the original input; never overwrite embedded
        for (r, c) in left_pos:
            if 0 <= r < h and 0 <= c < w and input_grid[r][c] == bg:
                result[r][c] = LEFT_COLOR
        for (r, c) in right_pos:
            if 0 <= r < h and 0 <= c < w and input_grid[r][c] == bg:
                result[r][c] = RIGHT_COLOR

    # Mark collisions on the result grid (but do not overwrite embedded)
    for (r, c) in collision_cells:
        if 0 <= r < h and 0 <= c < w and input_grid[r][c] == bg:
            result[r][c] = COLLISION_COLOR

    return result

