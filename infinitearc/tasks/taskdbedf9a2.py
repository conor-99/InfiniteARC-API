# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: dbedf9a2
Difficulty: insane

=== Tags ===
- Mask based logic
- Periodic reflection
- Simulate billiards shot
- Color the row with most dots
- Periodic tiling

=== Description ===
Input grids are large (20×20 or larger) and feature a periodic tiling of 3×3
blocks where each block contains a unique mask pattern (a subset of cells
forming reflection structures). The grid also includes a single ball
(represented by color 1) moving diagonally at 45° in a fixed direction (e.g.,
northeast).   The transformation involves: 1. Simulating the ball’s path through
the grid: each time the ball crosses a tile boundary, its direction reflects
according to the mask in the target tile (mirroring the ball’s trajectory if the
mask contains a vertical/horizontal line segment). 2. Drawing the path as a
continuous diagonal line (using color 2) over background cells, avoiding overlap
with masks or other structures. 3. Identifying the horizontal row containing the
highest number of path cells (color 2 cells). 4. Coloring every cell in that row
with color 3, while preserving all other elements of the grid.   The masks are
designed to ensure the path is deterministic, the row with the most path cells
is uniquely determined, and the output grid reflects the simulated trajectory
and row coloring. The task requires recognizing periodic mask patterns,
simulating billiard physics, and applying multiple layered transformations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    N = 21
    input_grid = [[0] * N for _ in range(N)]
    
    input_grid[0][0] = 1
    
    mask_types = {}
    for i in range(0, N, 3):
        for j in range(0, N, 3):
            mask_types[(i, j)] = 'vertical' if random.choice([True, False]) else 'horizontal'
    
    for (i, j), t in mask_types.items():
        if t == 'vertical':
            for r in range(3):
                input_grid[i + r][j + 1] = 4
        else:
            for c in range(3):
                input_grid[i + 1][j + c] = 4
    
    x, y = 0, 0
    dx, dy = 1, 1
    path_cells = []
    
    while True:
        nx, ny = x + dx, y + dy
        if nx >= N or ny >= N:
            break
        if input_grid[nx][ny] != 0:
            break
        current_block = (x // 3, y // 3)
        next_block = (nx // 3, ny // 3)
        if next_block != current_block:
            if next_block in mask_types:
                mt = mask_types[next_block]
                if mt == 'vertical':
                    dx = -dx
                elif mt == 'horizontal':
                    dy = -dy
        x, y = nx, ny
        path_cells.append((x, y))
    
    output_grid = [row[:] for row in input_grid]
    
    for r, c in path_cells:
        output_grid[r][c] = 2
    
    row_counts = [0] * N
    for r in range(N):
        for c in range(N):
            if output_grid[r][c] == 2:
                row_counts[r] += 1
    
    max_row = row_counts.index(max(row_counts))
    
    for c in range(N):
        output_grid[max_row][c] = 3
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input_grid to list of lists if needed
    if isinstance(input_grid[0], tuple):
        input_grid = [list(row) for row in input_grid]
    N = len(input_grid)
    ball_pos = None
    for r in range(N):
        for c in range(N):
            if input_grid[r][c] == 1:
                ball_pos = (r, c)
    if ball_pos is None:
        ball_pos = (0, 0)
    
    x, y = ball_pos
    dx, dy = 1, 1
    path_cells = []
    
    while True:
        nx, ny = x + dx, y + dy
        if nx >= N or ny >= N:
            break
        if input_grid[nx][ny] != 0:
            break
        current_block = (x // 3, y // 3)
        next_block = (nx // 3, ny // 3)
        if next_block != current_block:
            i_block = 3 * next_block[0]
            j_block = 3 * next_block[1]
            if (input_grid[i_block][j_block+1] == 4 and 
                input_grid[i_block+1][j_block+1] == 4 and 
                input_grid[i_block+2][j_block+1] == 4):
                dx = -dx
            elif (input_grid[i_block+1][j_block] == 4 and 
                  input_grid[i_block+1][j_block+1] == 4 and 
                  input_grid[i_block+1][j_block+2] == 4):
                dy = -dy
        x, y = nx, ny
        path_cells.append((x, y))
    
    output_grid = [row[:] for row in input_grid]
    for r, c in path_cells:
        output_grid[r][c] = 2
    
    row_counts = [0] * N
    for r in range(N):
        for c in range(N):
            if output_grid[r][c] == 2:
                row_counts[r] += 1
    
    max_row = row_counts.index(max(row_counts))
    
    for c in range(N):
        output_grid[max_row][c] = 3
    
    return output_grid
