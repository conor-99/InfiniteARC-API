# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 372dcc7e
Difficulty: insane

=== Tags ===
- Color modulated motion
- Inverse rule reconstruction
- Mirror pad edges
- Pattern expansion

=== Description ===
Input grids consist of a central core pattern (3×3 to 5×5) surrounded by four
mirror pads (top, bottom, left, right) each one cell thick. Each mirror pad is a
reflection of the adjacent core edge: the top pad mirrors the core's top row
horizontally, the bottom pad mirrors the core's bottom row horizontally, the
left pad mirrors the core's left column vertically, and the right pad mirrors
the core's right column vertically. The mirror pads are colored with unique
edge-specific colors (e.g., red for top, blue for bottom), but these colors are
*not* the core's actual colors—instead, they are derived from the core via
reflection. The core contains four distinct color-coded elements (values 1–4),
each representing a direction: 1 → right, 2 → down, 3 → left, 4 → up. The
background is a single color (0).  The output grid is generated through three
key operations: 1. **Inverse Rule Reconstruction**: The mirror pads' colors must
be inverted to reconstruct the core's true colors. For example, if the top
mirror pad (red) reflects the core's top row, the core's actual top-row colors
are the horizontal mirror of the pad's colors. 2. **Color Modulated Motion**:
Each element moves one cell per step in its direction. Upon hitting a mirror
pad, it reflects (reversing direction) and changes color to match the pad's
color. Reflections alter direction (e.g., right → left, down → up). 3. **Pattern
Expansion**: After exactly 3 steps of motion (simulating the movement of all
elements), the output grid displays the expanded motion paths, with elements now
visible in new positions. The reconstructed core remains intact, while the
mirror pads are integrated into the expanded pattern. The background remains
unchanged, and no two elements occupy the same cell.  The task requires solving
the inverse reflection rule *before* simulating motion, making it impossible to
proceed without reconstructing the core's true colors. The output grid maintains
the same dimensions as the input but shows a visually expanded pattern formed by
the motion paths, with color changes and reflections adhering strictly to the
reconstructed rules.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    s = random.randint(3, 5)
    size = s + 2
    grid_input = [[0] * size for _ in range(size)]
    
    # Set mirror pads
    for c in range(1, s+1):
        grid_input[0][c] = 5  # Top
        grid_input[s+1][c] = 6  # Bottom
    for r in range(1, s+1):
        grid_input[r][0] = 7  # Left
        grid_input[r][s+1] = 8  # Right
    
    # Randomly place elements 1-4 in core
    core_positions = [(r, c) for r in range(1, s+1) for c in range(1, s+1)]
    positions = random.sample(core_positions, 4)
    for i, (r, c) in enumerate(positions):
        grid_input[r][c] = i+1
    
    # Simulate 3 steps for all elements
    output = [row[:] for row in grid_input]
    directions = {
        1: (0, 1),  # right
        2: (1, 0),  # down
        3: (0, -1), # left
        4: (-1, 0)  # up
    }
    
    elements = []
    for r in range(1, s+1):
        for c in range(1, s+1):
            if grid_input[r][c] in [1,2,3,4]:
                elements.append((r, c, grid_input[r][c]))
    
    for r, c, d in elements:
        for _ in range(3):
            dr, dc = directions[d]
            nr, nc = r + dr, c + dc
            if nr < 0 or nr >= size or nc < 0 or nc >= size:
                continue
            if output[nr][nc] in [5, 6, 7, 8]:
                # Reflect direction
                if d == 1: d = 3
                elif d == 2: d = 4
                elif d == 3: d = 1
                elif d == 4: d = 2
                output[nr][nc] = output[nr][nc]
                output[r][c] = 0
                r, c = nr, nc
            else:
                output[r][c] = 0
                output[nr][nc] = grid_input[r][c]
                r, c = nr, nc
    
    return {
        "input": grid_input,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    size = len(grid)
    s = size - 2
    
    directions = {
        1: (0, 1),  # right
        2: (1, 0),  # down
        3: (0, -1), # left
        4: (-1, 0)  # up
    }
    
    elements = []
    for r in range(1, s+1):
        for c in range(1, s+1):
            if grid[r][c] in [1, 2, 3, 4]:
                elements.append((r, c, grid[r][c]))
    
    for r, c, d in elements:
        for _ in range(3):
            dr, dc = directions[d]
            nr, nc = r + dr, c + dc
            if nr < 0 or nr >= size or nc < 0 or nc >= size:
                continue
            if grid[nr][nc] in [5, 6, 7, 8]:
                if d == 1: d = 3
                elif d == 2: d = 4
                elif d == 3: d = 1
                elif d == 4: d = 2
                grid[nr][nc] = grid[nr][nc]
                grid[r][c] = 0
                r, c = nr, nc
            else:
                grid[r][c] = 0
                grid[nr][nc] = input_grid[r][c]
                r, c = nr, nc
    
    return grid
