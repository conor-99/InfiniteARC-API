# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 08fec030
Difficulty: very hard

=== Tags ===
- Boundary tracing
- Local to global rule inference
- Region partitioning
- Symmetry axis completion
- Tiled majority vote

=== Description ===
Input grids feature irregularly shaped colored regions (each region is a
connected component of a single color, using 4-connectivity) on a black
background (color 0), with no overlapping regions. The regions vary in size and
orientation, and their boundaries exhibit partial symmetry relative to different
axes.   The transformation process begins with **boundary tracing** to identify
the outer perimeter of each region. Next, **local to global rule inference** is
applied: for each region, the optimal symmetry axis (vertical, horizontal, or
diagonal) is determined by the axis that maximizes the number of matching
mirrored cells within the region. The global symmetry axis for the entire grid
is then selected as the axis that applies to the majority of regions.
Following this, **region partitioning** is refined using the global axis, and
each region is **symmetry axis completed** by mirroring its cells across the
global axis. This may require overwriting background cells or adjacent regions
to maintain the symmetry. Finally, **tiled majority vote** is applied: the
completed grid is divided into non-overlapping 3x3 tiles, and for each tile, the
output color is the majority color within that tile (with ties broken by the
lowest numerical color value).  The output grid reflects all transformations
sequentially: regions are symmetrically completed relative to the inferred
global axis, and the grid is smoothed through local majority voting across
fixed-size tiles, resulting in a visually coherent yet complex pattern that
requires multi-step reasoning to deduce from input examples.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    from common import grid, continuous_creature

    # Choose a square canvas size (multiple of 3 gives nicer tiling, but edge tiles are allowed)
    size_choices = [3, 6, 9, 12, 15, 18, 21, 24, 27, 30]
    width = random.choice(size_choices)
    height = width
    axes = ['V', 'H', 'D1', 'D2']

    # Try a few times to create a non-trivial pair where output differs from input
    for attempt in range(120):
        input_grid = grid(width, height, 0)
        occupied = set()
        # Number of regions: at least 2, up to a small constant dependent on grid area
        max_regions = min(6, max(2, (width * height) // 20))
        num_regions = random.randint(2, max_regions)
        # pick distinct non-zero colors for clarity
        colors = random.sample(list(range(1, 10)), num_regions)

        regions = []  # list of (color, [(r,c), ...])
        for color in colors:
            placed = False
            # Try multiple times to place a contiguous creature without overlapping existing regions
            for _ in range(80):
                b_w = random.randint(2, min(8, width))
                b_h = random.randint(2, min(8, height))
                # choose creature size (at least 2, at most bounding box area)
                size_pixels = random.randint(2, b_w * b_h)
                pixels_rel = continuous_creature(size_pixels, b_w, b_h)
                # pick an offset so the bounding box fits in the canvas
                r_off = random.randint(0, height - b_h)
                c_off = random.randint(0, width - b_w)
                pixels_abs = [(r_off + r, c_off + c) for (r, c) in pixels_rel]
                # ensure no overlap with already placed regions
                if any((rr, cc) in occupied for (rr, cc) in pixels_abs):
                    continue
                # place the region
                for (rr, cc) in pixels_abs:
                    input_grid[rr][cc] = color
                    occupied.add((rr, cc))
                regions.append((color, pixels_abs))
                placed = True
                break
            # if not placed after many tries, skip this color

        # need at least two placed regions to infer a majority axis
        if len(regions) < 2:
            continue

        # Determine best local symmetry axis for each region
        axis_counts = {a: 0 for a in axes}
        region_axes = []
        for color, pixels in regions:
            pixel_set = set(pixels)
            best_axis = 'V'
            best_count = -1
            for axis in axes:
                count = 0
                for (r, c) in pixels:
                    if axis == 'V':
                        mr, mc = r, width - 1 - c
                    elif axis == 'H':
                        mr, mc = height - 1 - r, c
                    elif axis == 'D1':
                        mr, mc = c, r
                    else:  # D2
                        mr, mc = width - 1 - c, height - 1 - r
                    if (mr, mc) in pixel_set:
                        count += 1
                if count > best_count:
                    best_count = count
                    best_axis = axis
            region_axes.append(best_axis)
            axis_counts[best_axis] += 1

        # Global axis: majority of region axes (ties broken by the order in `axes`)
        global_axis = max(axis_counts, key=axis_counts.get)

        # Symmetry completion: mirror every region across the global axis (overwrite allowed)
        sym_grid = [row[:] for row in input_grid]
        for color, pixels in regions:
            for (r, c) in pixels:
                if global_axis == 'V':
                    mr, mc = r, width - 1 - c
                elif global_axis == 'H':
                    mr, mc = height - 1 - r, c
                elif global_axis == 'D1':
                    mr, mc = c, r
                else:  # D2
                    mr, mc = width - 1 - c, height - 1 - r
                if 0 <= mr < height and 0 <= mc < width:
                    sym_grid[mr][mc] = color

        # Tiled majority vote with 3x3 non-overlapping tiles (partial tiles at edges allowed)
        output_grid = [[0 for _ in range(width)] for _ in range(height)]
        for r in range(0, height, 3):
            for c in range(0, width, 3):
                counts = {}
                for dr in range(3):
                    for dc in range(3):
                        rr = r + dr
                        cc = c + dc
                        if 0 <= rr < height and 0 <= cc < width:
                            col = sym_grid[rr][cc]
                            counts[col] = counts.get(col, 0) + 1
                if not counts:
                    continue
                # majority with ties broken by smallest color value
                majority = sorted(counts.keys(), key=lambda x: (-counts[x], x))[0]
                for dr in range(3):
                    for dc in range(3):
                        rr = r + dr
                        cc = c + dc
                        if 0 <= rr < height and 0 <= cc < width:
                            output_grid[rr][cc] = majority

        # Ensure the output is actually different from the input; otherwise regenerate
        if output_grid != input_grid:
            return {"input": input_grid, "output": output_grid}

    # Fallback deterministic small example (should almost never be used)
    width, height = 3, 3
    input_grid = grid(width, height, 0)
    input_grid[0][0] = 1
    input_grid[1][0] = 2
    sym_grid = [row[:] for row in input_grid]
    # force a symmetric completion across vertical axis for the fallback
    sym_grid[0][2] = 1
    sym_grid[1][2] = 2
    output_grid = [[0 for _ in range(width)] for _ in range(height)]
    for r in range(0, height, 3):
        for c in range(0, width, 3):
            counts = {}
            for dr in range(3):
                for dc in range(3):
                    rr = r + dr
                    cc = c + dc
                    if 0 <= rr < height and 0 <= cc < width:
                        col = sym_grid[rr][cc]
                        counts[col] = counts.get(col, 0) + 1
            majority = sorted(counts.keys(), key=lambda x: (-counts[x], x))[0]
            for dr in range(3):
                for dc in range(3):
                    rr = r + dr
                    cc = c + dc
                    if 0 <= rr < height and 0 <= cc < width:
                        output_grid[rr][cc] = majority
    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to mutable list-of-lists
    input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])

    # Find connected regions (4-connectivity) of non-zero colors
    visited = [[False] * width for _ in range(height)]
    regions = []  # list of (color, [(r,c), ...])
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0 and not visited[r][c]:
                color = input_grid[r][c]
                stack = [(r, c)]
                visited[r][c] = True
                pixels = []
                while stack:
                    cr, cc = stack.pop()
                    pixels.append((cr, cc))
                    for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                regions.append((color, pixels))

    axes = ['V', 'H', 'D1', 'D2']
    axis_counts = {a: 0 for a in axes}

    # Local axis inference per region: choose the axis that maximizes mirrored matches
    for color, pixels in regions:
        pixel_set = set(pixels)
        best_axis = 'V'
        best_count = -1
        for axis in axes:
            count = 0
            for (r, c) in pixels:
                if axis == 'V':
                    mr, mc = r, width - 1 - c
                elif axis == 'H':
                    mr, mc = height - 1 - r, c
                elif axis == 'D1':
                    mr, mc = c, r
                else:  # D2
                    mr, mc = width - 1 - c, height - 1 - r
                if (mr, mc) in pixel_set:
                    count += 1
            if count > best_count:
                best_count = count
                best_axis = axis
        axis_counts[best_axis] += 1

    # Global axis: majority of region axes, ties broken by the order in `axes`
    global_axis = max(axis_counts, key=axis_counts.get)

    # Symmetry completion across the global axis (overwrites allowed)
    sym_grid = [row[:] for row in input_grid]
    for color, pixels in regions:
        for (r, c) in pixels:
            if global_axis == 'V':
                mr, mc = r, width - 1 - c
            elif global_axis == 'H':
                mr, mc = height - 1 - r, c
            elif global_axis == 'D1':
                mr, mc = c, r
            else:  # D2
                mr, mc = width - 1 - c, height - 1 - r
            if 0 <= mr < height and 0 <= mc < width:
                sym_grid[mr][mc] = color

    # Tiled majority vote with 3x3 non-overlapping tiles
    output_grid = [[0 for _ in range(width)] for _ in range(height)]
    for r in range(0, height, 3):
        for c in range(0, width, 3):
            counts = {}
            for dr in range(3):
                for dc in range(3):
                    rr = r + dr
                    cc = c + dc
                    if 0 <= rr < height and 0 <= cc < width:
                        col = sym_grid[rr][cc]
                        counts[col] = counts.get(col, 0) + 1
            if not counts:
                continue
            majority = sorted(counts.keys(), key=lambda x: (-counts[x], x))[0]
            for dr in range(3):
                for dc in range(3):
                    rr = r + dr
                    cc = c + dc
                    if 0 <= rr < height and 0 <= cc < width:
                        output_grid[rr][cc] = majority

    return output_grid

