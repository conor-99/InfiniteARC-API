# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: cf6e3506
Difficulty: medium–hard

=== Tags ===
- Color particle fall
- Simulate billiards shot
- Color clock

=== Description ===
Input grids feature a background color (0), with horizontal and vertical walls
represented as continuous lines of non-zero colors (e.g., horizontal walls span
multiple columns in a single row, vertical walls span multiple rows in a single
column). Scattered at the top of the grid are small colored particles (each
occupying a single cell, color >0), initially positioned above all walls.
Particles move downward under gravity until colliding with a wall. Upon
collision:   - Horizontal walls cause vertical direction reversal (e.g.,
downward → upward).   - Vertical walls cause horizontal direction reversal
(e.g., right → left).   - Each collision increments the particle’s color through
a fixed, cyclic sequence (e.g., color 1 → 2 → 3 → 1...), which remains
consistent across all particles.    The output grid preserves all walls
unchanged and renders the complete trajectory of each particle as a path of
connected cells. Each segment of the path (between collisions) is colored
according to the particle’s color *during* that segment (i.e., the color before
the collision). Particles exit the grid when their movement reaches any
boundary. Paths do not intersect, walls never change, and color transitions
follow the cyclic sequence without exception. The task requires identifying wall
orientations, tracking directional changes, and inferring the color cycle from
input-output examples.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    """
    Generate an input-output pair for a simplified billiards-like particle task.
    This version places only horizontal walls (to avoid ambiguous intersections) and uses
    a fixed color cycle [1,2,3] for particles. Each example contains exactly one particle
    to avoid multi-particle ordering/interaction issues.
    """
    cycle = [1, 2, 3]
    max_attempts = 200
    attempt = 0
    while attempt < max_attempts:
        attempt += 1
        width = random.randint(10, 20)
        height = random.randint(10, 20)
        ingrid = grid(width, height, 0)

        # Reserve a small top area for particles only
        top_margin = random.randint(1, 3)
        mid = height // 2

        # Colors available for walls (avoid cycle colors)
        wall_color_pool = [c for c in range(1, 10) if c not in cycle]
        random.shuffle(wall_color_pool)

        used_wall_colors = []

        # Place a few horizontal walls in the upper-middle area (below the particle area)
        hor_count = random.randint(1, 3)
        for _ in range(hor_count):
            if not wall_color_pool:
                break
            row = random.randint(top_margin + 1, max(top_margin + 1, mid - 1))
            max_len = max(2, width // 3)
            length = random.randint(2, max_len)
            start_col = random.randint(1, max(1, width - length - 2))
            color = wall_color_pool.pop()
            used_wall_colors.append(color)
            for c in range(start_col, start_col + length):
                if 0 <= c < width:
                    ingrid[row][c] = color

        # No vertical walls in this simplified generator: avoid intersections

        # Compute minimum wall row to ensure particles are placed above all walls
        wall_rows = [r for r in range(height) for c in range(width) if ingrid[r][c] != 0]
        min_wall_row = min(wall_rows) if wall_rows else height
        if min_wall_row <= 0:
            # walls reach the top, try again
            continue

        # Place exactly one particle in the top area (above min_wall_row)
        particle_positions = []
        available_cols = [c for c in range(width) if all(ingrid[r][c] == 0 for r in range(0, min_wall_row))]
        if not available_cols:
            continue
        particle_rows = list(range(0, min_wall_row))
        if not particle_rows:
            continue

        col = random.choice(available_cols)
        row = random.choice(particle_rows)
        color = random.choice(cycle)
        ingrid[row][col] = color
        particle_positions.append((row, col, color))

        # Simulate trajectories to create the output grid, rejecting configurations that trap particles
        outgrid = [row[:] for row in ingrid]
        occupied = set()  # cells used by particle paths (to avoid intersections)
        valid = True
        # helper to get next color in cycle
        def next_color(col):
            idx = cycle.index(col)
            return cycle[(idx + 1) % len(cycle)]

        for (prow, pcol, pcolor) in particle_positions:
            r, c = prow, pcol
            color = pcolor
            # start moving downward
            dr, dc = 1, 0
            steps = 0
            max_steps = width * height * 8
            visited_states = set()
            while True:
                # paint current cell (but never overwrite walls)
                if ingrid[r][c] != 0 and ingrid[r][c] not in cycle:
                    # we are on a wall which shouldn't happen for particles
                    valid = False
                    break
                if (r, c) in occupied:
                    valid = False
                    break
                outgrid[r][c] = color
                occupied.add((r, c))

                # advance
                nr, nc = r + dr, c + dc
                # if exit grid -> done for this particle
                if not (0 <= nr < height and 0 <= nc < width):
                    break

                # collision with wall (only horizontal walls exist in this generator)
                if ingrid[nr][nc] != 0:
                    # determine orientation of the wall cell at (nr,nc)
                    left = (nc - 1 >= 0 and ingrid[nr][nc - 1] != 0)
                    right = (nc + 1 < width and ingrid[nr][nc + 1] != 0)
                    up = (nr - 1 >= 0 and ingrid[nr - 1][nc] != 0)
                    down = (nr + 1 < height and ingrid[nr + 1][nc] != 0)
                    is_horizontal = left or right
                    is_vertical = up or down
                    # Prefer horizontal if both (shouldn't occur here since no vertical walls)
                    if is_horizontal:
                        dr = -dr  # invert vertical component
                    elif is_vertical:
                        dc = -dc  # invert horizontal component
                    else:
                        if abs(dr) == 1:
                            dr = -dr
                        else:
                            dc = -dc
                    # increment color for the next segment
                    color = next_color(color)

                    # detect loops by state (r,c,dr,dc,color)
                    state = (r, c, dr, dc, color)
                    if state in visited_states:
                        valid = False
                        break
                    visited_states.add(state)

                    steps += 1
                    if steps > max_steps:
                        valid = False
                        break

                    # continue from same cell with new direction and color
                    continue

                # otherwise move into next cell
                r, c = nr, nc
                steps += 1
                if steps > max_steps:
                    valid = False
                    break

            if not valid:
                break

        if not valid:
            continue

        # ensure output is different from input (at least one painted cell)
        identical = True
        for r in range(height):
            for c in range(width):
                if ingrid[r][c] != outgrid[r][c]:
                    identical = False
                    break
            if not identical:
                break
        if identical:
            continue

        return {"input": ingrid, "output": outgrid}

    # fallback (should not normally be reached)
    w, h = 10, 10
    ingrid = grid(w, h, 0)
    # one horizontal wall
    for c in range(2, 6):
        ingrid[5][c] = 4
    # one particle above
    ingrid[1][3] = 1
    outgrid = [row[:] for row in ingrid]
    for r in range(1, 5):
        outgrid[r][3] = 1
    for r in range(4, -1, -1):
        outgrid[r][3] = 2
    return {"input": ingrid, "output": outgrid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    # Define the color cycle used by the generator
    cycle = [1, 2, 3]

    # Helper to get next color in the cycle
    def next_color(col):
        try:
            idx = cycle.index(col)
            return cycle[(idx + 1) % len(cycle)]
        except ValueError:
            # If the starting color isn't in the cycle for some reason,
            # fall back to cycling through the cycle starting at first color.
            return cycle[0]

    # Identify particles as non-zero cells that have no same-color orthogonal neighbor
    particles = []
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0:
                continue
            color = grid[r][c]
            # check for any orthogonal neighbor with same color (part of a wall)
            has_same_neighbor = False
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == color:
                    has_same_neighbor = True
                    break
            if not has_same_neighbor:
                particles.append((r, c, color))

    out = [row[:] for row in grid]

    # Simulate each particle's trajectory and paint it on the output grid
    for (pr, pc, pcolor) in particles:
        r, c = pr, pc
        color = pcolor
        # initial direction is down
        dr, dc = 1, 0
        steps = 0
        max_steps = width * height * 8
        visited_states = set()
        while True:
            # paint current position (do not overwrite walls)
            if grid[r][c] == 0 or grid[r][c] in cycle:
                out[r][c] = color
            else:
                # this would be a wall cell, which should not happen for a particle path
                break

            nr, nc = r + dr, c + dc
            # exit grid
            if not (0 <= nr < height and 0 <= nc < width):
                break

            # collision if next cell is a wall (non-zero in the input)
            if grid[nr][nc] != 0:
                left = (nc - 1 >= 0 and grid[nr][nc - 1] != 0)
                right = (nc + 1 < width and grid[nr][nc + 1] != 0)
                up = (nr - 1 >= 0 and grid[nr - 1][nc] != 0)
                down = (nr + 1 < height and grid[nr + 1][nc] != 0)
                is_horizontal = left or right
                is_vertical = up or down
                # prefer horizontal if both true to be deterministic
                if is_horizontal:
                    dr = -dr
                elif is_vertical:
                    dc = -dc
                else:
                    # single isolated cell: invert the component that was moving into it
                    if abs(dr) == 1:
                        dr = -dr
                    else:
                        dc = -dc

                color = next_color(color)

                state = (r, c, dr, dc, color)
                if state in visited_states:
                    break
                visited_states.add(state)

                steps += 1
                if steps > max_steps:
                    break

                # continue from same cell with new direction and color
                continue

            # otherwise move into next cell
            r, c = nr, nc
            steps += 1
            if steps > max_steps:
                break

    return out

