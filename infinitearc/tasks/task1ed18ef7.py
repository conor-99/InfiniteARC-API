# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 1ed18ef7
Difficulty: hard

=== Tags ===
- Cooperative beams
- Minimal path fill
- Cooperative rule network
- Local symmetry matching
- Seal gaps inside shape
- Take maximum

=== Description ===
**Task Description: Cooperative Beam Sealing**    Input grids feature a
background (color 0) overlaid with multiple closed, convex-shaped regions (non-
background colors 1–9) that enclose internal gaps. Each gap is a small,
connected background region (1–3 cells) completely surrounded by the shape’s
boundary, with no adjacency to the grid edge. The shape’s boundary exhibits
local symmetry around each gap—e.g., mirror symmetry across a horizontal,
vertical, or diagonal axis passing through the gap.    The output grid fills
each gap by sealing it with a minimal path (shortest possible single-cell line)
from the gap to the boundary, aligned with the local symmetry axis. The fill
color is determined by taking the *maximum color value* of the two boundary
segments adjacent to the gap along the symmetry axis. Paths are drawn without
overlapping existing shape or gap cells, preserving all original shape
boundaries. Gaps are filled in descending order of size to prevent interference,
with larger gaps prioritized.    This task requires simultaneous detection of
local symmetry axes, identification of boundary color values, application of the
"take maximum" rule, and minimal path routing—creating a cooperative rule
network where symmetry guides path direction and color selection. The complexity
arises from overlapping symmetry axes in dense regions and the need to resolve
priority conflicts between gaps.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    n = random.randint(15, 25)
    grid = [[0] * n for _ in range(n)]
    
    r_start, r_end = 3, n-4
    c_start, c_end = 3, n-4
    
    colors = list(range(1, 10))
    random.shuffle(colors)
    top_color, bottom_color, left_color, right_color = colors[:4]
    
    for r in range(r_start, r_end+1):
        for c in range(c_start, c_end+1):
            grid[r][c] = 1
    
    top_rows = r_start + (r_end - r_start) // 3
    for r in range(r_start, top_rows+1):
        for c in range(c_start, c_end+1):
            grid[r][c] = top_color
    
    bottom_rows = r_end - (r_end - r_start) // 3
    for r in range(bottom_rows, r_end+1):
        for c in range(c_start, c_end+1):
            grid[r][c] = bottom_color
    
    left_cols = c_start + (c_end - c_start) // 3
    for c in range(c_start, left_cols+1):
        for r in range(r_start, r_end+1):
            grid[r][c] = left_color
    
    right_cols = c_end - (c_end - c_start) // 3
    for c in range(right_cols, c_end+1):
        for r in range(r_start, r_end+1):
            grid[r][c] = right_color
    
    gaps = []
    num_gaps = random.randint(2, 3)
    attempts = 0
    while len(gaps) < num_gaps and attempts < 50:
        r = random.randint(r_start+1, r_end-1)
        c = random.randint(c_start+1, c_end-1)
        if (top_rows <= r < bottom_rows) and (left_cols <= c < right_cols):
            neighbors = [(r+1,c), (r-1,c), (r,c+1), (r,c-1)]
            if all(0 <= nr < n and 0 <= nc < n and grid[nr][nc] > 0 for nr, nc in neighbors):
                grid[r][c] = 0
                gaps.append((r, c))
        attempts += 1
    
    output = [row[:] for row in grid]
    for r, c in gaps:
        if c > c_start and c < c_end and grid[r][c-1] > 0 and grid[r][c+1] > 0:
            max_color = max(grid[r][c-1], grid[r][c+1])
            output[r][c] = max_color
        elif r > r_start and r < r_end and grid[r-1][c] > 0 and grid[r+1][c] > 0:
            max_color = max(grid[r-1][c], grid[r+1][c])
            output[r][c] = max_color
    return {'input': grid, 'output': output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    n = len(input_grid)
    output = [row[:] for row in input_grid]
    gaps = []
    for r in range(n):
        for c in range(n):
            if input_grid[r][c] == 0:
                neighbors = [(r+1,c), (r-1,c), (r,c+1), (r,c-1)]
                if all(0 <= nr < n and 0 <= nc < n and input_grid[nr][nc] > 0 for nr, nc in neighbors):
                    gaps.append((r, c))
    for r, c in gaps:
        if c > 0 and c < n-1 and input_grid[r][c-1] > 0 and input_grid[r][c+1] > 0:
            max_color = max(input_grid[r][c-1], input_grid[r][c+1])
            output[r][c] = max_color
        elif r > 0 and r < n-1 and input_grid[r-1][c] > 0 and input_grid[r+1][c] > 0:
            max_color = max(input_grid[r-1][c], input_grid[r+1][c])
            output[r][c] = max_color
    return output
