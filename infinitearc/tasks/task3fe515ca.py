# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 3fe515ca
Difficulty: hard

=== Tags ===
- Discover grid scale
- Global consistency enforcement
- Analogical mapping between pairs

=== Description ===
The input grid features a 2D arrangement of colored objects (non-zero values)
against a neutral background (value 0). Each distinct color (excluding 0)
represents a unique visual feature. The output grid is derived by scaling the
input uniformly: the scaling factor *k* is determined by counting the number of
distinct non-zero colors present in the input. For example, if four distinct
colors (e.g., red, blue, green, yellow) appear in the input, each pixel in the
input is replaced by a *k*×*k* block of the same color in the output. The
background (0) expands to *k*×*k* blocks of 0. This transformation requires
recognizing the global color diversity in the input to compute *k*, then
applying consistent scaling across all elements to maintain structural
coherence. The output grid dimensions scale proportionally to *k* times the
input dimensions, ensuring all visual features are proportionally enlarged while
preserving their relative positions and color relationships. The task demands
careful visual analysis to identify the color count and apply the scaling rule
universally, making it challenging due to the necessity of global pattern
recognition and consistent spatial transformation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    k = random.randint(2, 9)
    max_size = 30 // k
    while True:
        w = random.randint(1, max_size)
        h = random.randint(1, max_size)
        if w * h >= k:
            break
    input_grid = common.grid(w, h, 0)
    colors = random.sample(range(1, 10), k)
    cells = [(r, c) for r in range(h) for c in range(w)]
    random.shuffle(cells)
    for i, color in enumerate(colors):
        r, c = cells[i]
        input_grid[r][c] = color
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] == 0:
                if random.random() < 0.5:
                    input_grid[r][c] = random.choice(colors)
    output_grid = []
    for r in range(h):
        for _ in range(k):
            new_row = []
            for c in range(w):
                for _ in range(k):
                    new_row.append(input_grid[r][c])
            output_grid.append(new_row)
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import random
import common

def p(input_grid):
    non_zero = set()
    for row in input_grid:
        for cell in row:
            if cell != 0:
                non_zero.add(cell)
    k = len(non_zero)
    h = len(input_grid)
    w = len(input_grid[0])
    output = []
    for r in range(h):
        for _ in range(k):
            new_row = []
            for c in range(w):
                for _ in range(k):
                    new_row.append(input_grid[r][c])
            output.append(new_row)
    return output
