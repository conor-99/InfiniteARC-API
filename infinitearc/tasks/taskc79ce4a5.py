# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: c79ce4a5
Difficulty: hard

=== Tags ===
- Associate images to numbers
- Take complement
- Draw rectangle

=== Description ===
The task involves transforming an input grid into an output grid through a
sequence of visual operations. The input grid contains a background (value 0)
and multiple foreground shapes (non-zero values representing distinct colors).
The transformation follows these steps:  1. **Complement Association**: Replace
all background cells (0) with a fixed "complement" color (value 9), while
replacing all foreground shape cells (non-zero) with 0. This creates a new grid
where the former background is now a uniform region (9), and the shapes are
removed (0).  2. **Bounding Rectangle Drawing**: Identify the minimal axis-
aligned bounding box that contains all 9s (the complement region). Draw a
rectangle around this bounding box by setting all border cells of the bounding
box to a fixed "rectangle" color (value 8), while leaving the interior cells
unchanged.  The output grid thus features: - A uniform complement region (9)
replacing the original background. - The original shapes removed (0). - A border
(8) outlining the smallest rectangle enclosing the complement region.  This
transformation requires recognizing the background as the complement of all
shapes, then geometrically defining and drawing a rectangle around the union of
all background areas. The complexity arises from handling disconnected
background regions (e.g., fragmented gaps between shapes) and correctly
computing the bounding box of the combined complement area. The rules are purely
visual, relying on spatial relationships rather than numerical properties or
color values.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    input_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if random.random() < 0.3:
                input_grid[r][c] = random.randint(1, 9)
    bg_positions = [(r, c) for r in range(height) for c in range(width) if input_grid[r][c] == 0]
    if not bg_positions:
        return generate()
    min_r = min(r for r, c in bg_positions)
    max_r = max(r for r, c in bg_positions)
    min_c = min(c for r, c in bg_positions)
    max_c = max(c for r, c in bg_positions)
    if max_r - min_r < 1 or max_c - min_c < 1:
        return generate()
    output_grid = [[9 if cell == 0 else 0 for cell in row] for row in input_grid]
    for r in range(min_r, max_r + 1):
        output_grid[r][min_c] = 8
        output_grid[r][max_c] = 8
    for c in range(min_c, max_c + 1):
        output_grid[min_r][c] = 8
        output_grid[max_r][c] = 8
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = [[9 if cell == 0 else 0 for cell in row] for row in input_grid]
    bg_positions = []
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] == 9:
                bg_positions.append((r, c))
    if not bg_positions:
        return output_grid
    min_r = min(r for r, c in bg_positions)
    max_r = max(r for r, c in bg_positions)
    min_c = min(c for r, c in bg_positions)
    max_c = max(c for r, c in bg_positions)
    for r in range(min_r, max_r + 1):
        output_grid[r][min_c] = 8
        output_grid[r][max_c] = 8
    for c in range(min_c, max_c + 1):
        output_grid[min_r][c] = 8
        output_grid[max_r][c] = 8
    return output_grid
