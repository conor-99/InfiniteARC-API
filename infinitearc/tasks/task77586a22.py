# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 77586a22
Difficulty: medium

=== Tags ===
- Pattern reflection
- Remove noise
- Create image from info

=== Description ===
The input grid contains a primary pattern composed of non-zero pixels,
surrounded by minor noise consisting of small, disconnected non-zero pixels. The
task requires two consistent steps: first, remove the noise by retaining only
the largest connected component of non-zero pixels (using 4-connectivity), and
second, reflect the resulting grid horizontally (left-right flip). The output
grid is formed by applying these operations in sequence, ensuring the primary
pattern is isolated and mirrored across the vertical axis.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import random_el, grid

def generate():
    w = random.randint(5, 30)
    h = random.randint(5, 30)
    input_grid = grid(w, h, 0)
    
    main_pixels = random_el(w, h)
    for r, c in main_pixels:
        input_grid[r][c] = 1
    
    for _ in range(random.randint(1, 3)):
        r, c = random.randint(0, h-1), random.randint(0, w-1)
        if (r, c) in main_pixels:
            continue
        adjacent = False
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < h and 0 <= nc < w and (nr, nc) in main_pixels:
                adjacent = True
                break
        if adjacent:
            continue
        input_grid[r][c] = 2
    
    output_grid = grid(w, h, 0)
    for r, c in main_pixels:
        output_grid[r][w - 1 - c] = 1
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid or not input_grid[0]:
        return input_grid
    h = len(input_grid)
    w = len(input_grid[0])
    
    non_zero = []
    for r in range(h):
        for c in range(w):
            if input_grid[r][c] != 0:
                non_zero.append((r, c))
    
    if not non_zero:
        return input_grid
    
    def bfs(start):
        queue = [start]
        comp = []
        visited = set([start])
        while queue:
            r, c = queue.pop(0)
            comp.append((r, c))
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < h and 0 <= nc < w and (nr, nc) in non_zero and (nr, nc) not in visited:
                    visited.add((nr, nc))
                    queue.append((nr, nc))
        return comp
    
    visited = set()
    components = []
    for pixel in non_zero:
        if pixel not in visited:
            comp = bfs(pixel)
            visited.update(comp)
            components.append(comp)
    
    largest_comp = max(components, key=len)
    
    output_grid = [[0] * w for _ in range(h)]
    for r, c in largest_comp:
        output_grid[r][c] = input_grid[r][c]
    
    output_grid = [row[::-1] for row in output_grid]
    
    return output_grid
