# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 3730adf9
Difficulty: very hard

=== Tags ===
- Mutual reflection
- Route switching
- Analogical mapping between pairs
- Count patterns
- Remove intruder

=== Description ===
Input grids consist of multiple distinct colored regions (each region is a
contiguous group of cells with the same non-background color, 1-9, separated by
background 0). These regions are arranged to form mirror pairs across a central
axis (horizontal or vertical), but exactly one region is an intruder—lacking any
mirror counterpart. Each mirror pair is associated with a "route" that connects
the regions, and the direction of the route (horizontal or vertical alignment)
is determined by the count of regions in the grid's rows and columns.
Specifically, for a region in a row containing an even number of regions, the
mirror axis is vertical; for an odd count, the axis is horizontal.   The
transformation requires three sequential steps: (1) Identify and remove the
single intruder region (the only region without a mirror pair), (2) Determine
the correct mirror axis (horizontal or vertical) for each remaining region based
on the count of regions in its row, and (3) Reflect each region across its
determined axis to form a symmetric pair with its mirror. The output grid must
exhibit perfect symmetry across the central axis for all remaining regions, with
the intruder completely removed and all reflections precisely aligned.
Background cells remain unchanged, and no new regions are added—only existing
regions are reflected into their mirror positions. The task demands precise
visual pattern recognition, multi-step reasoning, and dynamic rule application
based on contextual counts, making it exceptionally challenging.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_colors, random_color

def generate():
    # Dimensions (wider grid to ensure safe gaps between mirrored components)
    width = random.randint(18, 24)
    height = random.randint(14, 24)
    bg = 0
    W = width
    H = height
    inp = grid(W, H, bg)
    axis = W // 2

    # Place original regions in the top half so horizontal reflections land cleanly in the bottom half.
    n_pairs = random.randint(2, 4)
    colors = random_colors(n_pairs, exclude=[bg])
    used_colors = list(colors)

    comps = []  # store placed components as {'color': color, 'cells': [...]}
    occupied = set()

    def rect_cells(r, c, h, w):
        return [(rr, cc) for rr in range(r, r + h) for cc in range(c, c + w)]

    attempts_limit = 200
    for color in colors:
        placed = False
        for _ in range(attempts_limit):
            h = random.randint(2, 4)
            w = random.randint(2, 4)
            # choose a row inside top half so horizontal reflections go to bottom half
            max_r = max(1, H // 2 - h - 1)
            r = random.randint(1, max_r)
            # leave a margin from the central axis to avoid accidental touching/merging
            max_c = max(1, axis - w - 2)
            c = random.randint(1, max_c)

            left_cells = rect_cells(r, c, h, w)
            # mirrored rectangle top-left on right side
            c2 = W - c - w
            right_cells = rect_cells(r, c2, h, w)

            if any((rr, cc) in occupied for rr, cc in left_cells):
                continue
            if any((rr, cc) in occupied for rr, cc in right_cells):
                continue

            # commit both rectangles
            for rr, cc in left_cells:
                inp[rr][cc] = color
                occupied.add((rr, cc))
            for rr, cc in right_cells:
                inp[rr][cc] = color
                occupied.add((rr, cc))

            comps.append({'color': color, 'cells': left_cells})
            comps.append({'color': color, 'cells': right_cells})
            placed = True
            break

        if not placed:
            # fallback: place a single pixel pair somewhere free in top half
            found = False
            for rr in range(1, H // 2):
                for cc in range(1, axis - 1):
                    cc2 = W - 1 - cc
                    if (rr, cc) in occupied or (rr, cc2) in occupied:
                        continue
                    inp[rr][cc] = color
                    inp[rr][cc2] = color
                    occupied.add((rr, cc))
                    occupied.add((rr, cc2))
                    comps.append({'color': color, 'cells': [(rr, cc)]})
                    comps.append({'color': color, 'cells': [(rr, cc2)]})
                    found = True
                    break
                if found:
                    break

    # Place a single intruder region (only one component of its color)
    intruder_color = random_color(exclude=used_colors + [bg])
    used_colors.append(intruder_color)
    intruder_cells = None
    for _ in range(attempts_limit):
        h = random.randint(1, 3)
        w = random.randint(1, 3)
        max_r = max(1, H // 2 - h - 1)
        r = random.randint(1, max_r)
        max_c = max(1, axis - w - 2)
        c = random.randint(1, max_c)
        cells = rect_cells(r, c, h, w)
        if any((rr, cc) in occupied for rr, cc in cells):
            continue
        for rr, cc in cells:
            inp[rr][cc] = intruder_color
            occupied.add((rr, cc))
        intruder_cells = cells
        comps.append({'color': intruder_color, 'cells': cells})
        break

    if intruder_cells is None:
        # fallback single pixel intruder
        for rr in range(1, H // 2):
            placed = False
            for cc in range(1, axis - 1):
                if (rr, cc) in occupied:
                    continue
                inp[rr][cc] = intruder_color
                occupied.add((rr, cc))
                intruder_cells = [(rr, cc)]
                comps.append({'color': intruder_color, 'cells': intruder_cells})
                placed = True
                break
            if placed:
                break

    # Build the output: remove the intruder and reflect every remaining component according to the parity rule
    out = [row[:] for row in inp]

    color_map = {}
    for comp in comps:
        color_map.setdefault(comp['color'], []).append(comp)

    intruder_comp = None
    for color, clist in color_map.items():
        if len(clist) == 1:
            intruder_comp = clist[0]
            break

    # remove the intruder
    if intruder_comp is not None:
        for rr, cc in intruder_comp['cells']:
            out[rr][cc] = bg

    comps_to_process = [comp for comp in comps if comp is not intruder_comp]

    for comp in comps_to_process:
        color = comp['color']
        min_r = min(rr for rr, cc in comp['cells'])
        # count how many components occupy that reference row
        row_count = sum(1 for other in comps_to_process if any(pr == min_r for pr, pc in other['cells']))
        if row_count % 2 == 0:
            # vertical reflection across central vertical axis
            for rr, cc in comp['cells']:
                cc2 = W - 1 - cc
                out[rr][cc2] = color
        else:
            # horizontal reflection across central horizontal axis
            for rr, cc in comp['cells']:
                rr2 = H - 1 - rr
                out[rr2][cc] = color

    return {
        "input": inp,
        "output": out
    }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    H = len(grid)
    W = len(grid[0])
    bg = 0

    # find connected components (4-connected) grouped by color
    visited = [[False] * W for _ in range(H)]
    comps = []
    for r in range(H):
        for c in range(W):
            if not visited[r][c] and grid[r][c] != bg:
                color = grid[r][c]
                stack = [(r, c)]
                visited[r][c] = True
                pixels = []
                while stack:
                    cr, cc = stack.pop()
                    pixels.append((cr, cc))
                    for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < H and 0 <= nc < W and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                comps.append({'color': color, 'cells': pixels})

    # map colors to component lists to find the single intruder color (color with only one component)
    color_map = {}
    for comp in comps:
        color_map.setdefault(comp['color'], []).append(comp)

    intruder_comp = None
    for color, clist in color_map.items():
        if len(clist) == 1:
            intruder_comp = clist[0]
            break

    out = [row[:] for row in grid]

    # remove intruder pixels
    if intruder_comp is not None:
        for rr, cc in intruder_comp['cells']:
            out[rr][cc] = bg

    comps_to_process = [comp for comp in comps if comp is not intruder_comp]

    for comp in comps_to_process:
        color = comp['color']
        min_r = min(rr for rr, cc in comp['cells'])
        row_count = sum(1 for other in comps_to_process if any(pr == min_r for pr, pc in other['cells']))
        if row_count % 2 == 0:
            # vertical reflection
            for rr, cc in comp['cells']:
                cc2 = W - 1 - cc
                out[rr][cc2] = color
        else:
            # horizontal reflection
            for rr, cc in comp['cells']:
                rr2 = H - 1 - rr
                out[rr2][cc] = color

    return tuple(tuple(row) for row in out)

