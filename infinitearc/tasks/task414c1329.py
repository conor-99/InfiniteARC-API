# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 414c1329
Difficulty: very hard

=== Tags ===
- Symbolic circuit
- Multi condition recolor
- Reactive surface
- Flood fill region

=== Description ===
Input grids feature a background color (0) and a closed, non-orthogonal symbolic
circuit formed by alternating colors 1 and 2 along its continuous loop path. The
circuit contains directional changes (90° corners) where the path turns from
horizontal to vertical, creating distinct corner segments. The circuit encloses
a single contiguous region and avoids self-intersections.   The output grid is
generated through two layered transformations:   1. **Reactive Surface
Recoloring**: All cells adjacent (orthogonally or diagonally) to the circuit
path are recolored based on multi-condition rules:    - Adjacent *only* to
color-1 segments → recolor to 3    - Adjacent *only* to color-2 segments →
recolor to 4    - Adjacent to *both* color-1 and color-2 segments (e.g.,
diagonally between segments) → recolor to 5    - Adjacent to a *corner segment*
(where the circuit turns 90°) → recolor to 6  2. **Enclosed Region Flood Fill**:
The interior region enclosed by the circuit is filled with a single color
determined by the circuit's boundary sequence. Starting from the topmost circuit
segment (highest row index), the clockwise sequence of colors (1,2,1,2,...) is
read. The fill color cycles through 7,8,9 based on the segment position:    -
Position 1 (color 1) → fill with 7    - Position 2 (color 2) → fill with 8    -
Position 3 (color 1) → fill with 9    - Position 4 (color 2) → fill with 7,
repeating the cycle  The circuit's path must be correctly identified to
distinguish corner segments from straight segments, and the boundary sequence
must be traversed clockwise from the topmost point to determine the fill color.
The reactive surface recoloring requires analyzing both orthogonal and diagonal
adjacencies to the circuit, while the flood fill depends on the circuit's color
sequence and directionality. All transformations are deterministic, visually
grounded, and require sequential reasoning to apply correctly.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    r = random.randint(0, height - 4)
    c = random.randint(0, width - 4)
    w = random.randint(3, width - c - 1)
    h = random.randint(3, height - r - 1)
    
    perimeter = []
    for i in range(w):
        perimeter.append((r, c + i))
    for i in range(1, h - 1):
        perimeter.append((r + i, c + w - 1))
    for i in range(w - 1, -1, -1):
        perimeter.append((r + h - 1, c + i))
    for i in range(h - 2, 0, -1):
        perimeter.append((r + i, c))
    
    circuit_colors = [1 if i % 2 == 0 else 2 for i in range(len(perimeter))]
    
    input_grid = [[0] * width for _ in range(height)]
    for (i, j), color in zip(perimeter, circuit_colors):
        if 0 <= i < height and 0 <= j < width:
            input_grid[i][j] = color
    
    output_grid = [row[:] for row in input_grid]
    corners = [
        (r, c),
        (r, c + w - 1),
        (r + h - 1, c + w - 1),
        (r + h - 1, c)
    ]
    
    for i in range(height):
        for j in range(width):
            if input_grid[i][j] != 0:
                continue
            has_circuit = False
            colors_present = set()
            for di in (-1, 0, 1):
                for dj in (-1, 0, 1):
                    ni, nj = i + di, j + dj
                    if 0 <= ni < height and 0 <= nj < width and input_grid[ni][nj] != 0:
                        has_circuit = True
                        colors_present.add(input_grid[ni][nj])
            if not has_circuit:
                continue
            adjacent_to_corner = False
            for di in (-1, 0, 1):
                for dj in (-1, 0, 1):
                    ni, nj = i + di, j + dj
                    if 0 <= ni < height and 0 <= nj < width and (ni, nj) in corners:
                        adjacent_to_corner = True
                        break
                if adjacent_to_corner:
                    break
            if adjacent_to_corner:
                output_grid[i][j] = 6
            else:
                if len(colors_present) == 1:
                    output_grid[i][j] = 3 if 1 in colors_present else 4
                else:
                    output_grid[i][j] = 5
    
    for i in range(r + 1, r + h - 1):
        for j in range(c + 1, c + w - 1):
            if 0 <= i < height and 0 <= j < width:
                output_grid[i][j] = 7
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    circuit_cells = []
    for i in range(height):
        for j in range(width):
            if grid[i][j] in (1, 2):
                circuit_cells.append((i, j))
    
    if not circuit_cells:
        return grid
    
    min_i = min(i for i, j in circuit_cells)
    max_i = max(i for i, j in circuit_cells)
    min_j = min(j for i, j in circuit_cells)
    max_j = max(j for i, j in circuit_cells)
    
    corners = [
        (min_i, min_j),
        (min_i, max_j),
        (max_i, max_j),
        (max_i, min_j)
    ]
    
    for i in range(height):
        for j in range(width):
            if grid[i][j] != 0:
                continue
            has_circuit = False
            colors_present = set()
            for di in (-1, 0, 1):
                for dj in (-1, 0, 1):
                    ni, nj = i + di, j + dj
                    if 0 <= ni < height and 0 <= nj < width:
                        if grid[ni][nj] in (1, 2):
                            has_circuit = True
                            colors_present.add(grid[ni][nj])
            if not has_circuit:
                continue
            adjacent_to_corner = False
            for di in (-1, 0, 1):
                for dj in (-1, 0, 1):
                    ni, nj = i + di, j + dj
                    if 0 <= ni < height and 0 <= nj < width and (ni, nj) in corners:
                        adjacent_to_corner = True
                        break
                if adjacent_to_corner:
                    break
            if adjacent_to_corner:
                grid[i][j] = 6
            else:
                if len(colors_present) == 1:
                    grid[i][j] = 3 if 1 in colors_present else 4
                else:
                    grid[i][j] = 5
    
    for i in range(min_i + 1, max_i):
        for j in range(min_j + 1, max_j):
            if 0 <= i < height and 0 <= j < width:
                grid[i][j] = 7
    
    return grid
