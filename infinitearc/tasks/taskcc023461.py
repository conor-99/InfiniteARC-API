# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: cc023461
Difficulty: easy

=== Tags ===
- Separate images
- Take negative
- Trim trailing background
- Remove noise

=== Description ===
The task involves transforming an input grid where a single connected shape
(composed of non-zero values) is placed on a zero background. The output grid is
generated through three sequential operations: first, inverting the colors (non-
zero values become zero, and zero becomes non-zero), second, removing isolated
non-zero pixels (noise) that do not belong to the main shape, and third,
cropping the grid to the smallest bounding box that contains all remaining non-
zero pixels. This process results in a simplified, noise-free representation of
the inverted shape, with all unnecessary background padding removed. The
operations are visually intuitive, relying on the spatial arrangement of
elements rather than numerical values or complex computations.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    shape_size = random.randint(1, 5)
    
    pixels = common.continuous_creature(shape_size, width, height)
    
    input_grid = common.grid(width, height, 0)
    for r, c in pixels:
        input_grid[r][c] = 1
    
    inverted = [[1 if input_grid[r][c] == 0 else 0 for c in range(width)] for r in range(height)]
    
    ones = []
    for r in range(height):
        for c in range(width):
            if inverted[r][c] == 1:
                ones.append((r, c))
    
    if not ones:
        return generate()
    
    visited = set()
    components = []
    for (r, c) in ones:
        if (r, c) not in visited:
            component = []
            queue = [(r, c)]
            visited.add((r, c))
            while queue:
                r0, c0 = queue.pop(0)
                component.append((r0, c0))
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r0 + dr, c0 + dc
                    if 0 <= nr < height and 0 <= nc < width and (nr, nc) in ones and (nr, nc) not in visited:
                        visited.add((nr, nc))
                        queue.append((nr, nc))
            components.append(component)
    
    largest_component = max(components, key=len)
    
    temp = [[0]*width for _ in range(height)]
    for (r, c) in largest_component:
        temp[r][c] = 1
    
    min_r = min(r for r, c in largest_component)
    max_r = max(r for r, c in largest_component)
    min_c = min(c for r, c in largest_component)
    max_c = max(c for r, c in largest_component)
    
    output_grid = []
    for r in range(min_r, max_r + 1):
        output_grid.append(temp[r][min_c:max_c+1])
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    
    inverted = [[1 if input_grid[r][c] == 0 else 0 for c in range(width)] for r in range(height)]
    
    ones = []
    for r in range(height):
        for c in range(width):
            if inverted[r][c] == 1:
                ones.append((r, c))
    
    if not ones:
        return [[0]]
    
    visited = set()
    components = []
    for (r, c) in ones:
        if (r, c) not in visited:
            component = []
            queue = [(r, c)]
            visited.add((r, c))
            while queue:
                r0, c0 = queue.pop(0)
                component.append((r0, c0))
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r0 + dr, c0 + dc
                    if 0 <= nr < height and 0 <= nc < width and inverted[nr][nc] == 1 and (nr, nc) not in visited:
                        visited.add((nr, nc))
                        queue.append((nr, nc))
            components.append(component)
    
    largest_component = max(components, key=len)
    
    temp = [[0]*width for _ in range(height)]
    for (r, c) in largest_component:
        temp[r][c] = 1
    
    min_r = min(r for r, c in largest_component)
    max_r = max(r for r, c in largest_component)
    min_c = min(c for r, c in largest_component)
    max_c = max(c for r, c in largest_component)
    
    output = []
    for r in range(min_r, max_r + 1):
        output.append(temp[r][min_c:max_c+1])
    
    return output
