# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 4e22a223
Difficulty: insane

=== Tags ===
- Momentum transfer
- Conditional draw
- Rule composition
- Shape to color encoding

=== Description ===
Input grids consist of multiple contiguous regions formed by connected cells of
uniform color, where the actual color values are irrelevant to the
transformation. Each region's geometric shape—determined by its bounding box
dimensions—is analyzed to derive a target color: square regions (width = height)
transform to color 5, wider regions (width > height) to color 2, and taller
regions (height > width) to color 8. This initial color encoding is applied
uniformly across all regions. Subsequently, momentum transfer propagates colors
based on region size and shape: larger regions (by cell count) sequentially
transfer their encoded color to adjacent regions that meet the "tall" condition
(height ≥ 2×width), with transfers applied in descending order of region size.
The output grid reflects both the shape-encoded colors and the propagated
momentum, preserving all original region boundaries while ensuring conditional
transfer only affects eligible tall regions. This requires simultaneous analysis
of spatial relationships, hierarchical rule application, and iterative
propagation to achieve the correct configuration.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random
from typing import List, Dict

def apply_rule(grid):
    visited = set()
    regions = {}
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            if grid[r][c] == 0 or (r, c) in visited:
                continue
            color = grid[r][c]
            if color not in regions:
                regions[color] = []
            queue = [(r, c)]
            visited.add((r, c))
            while queue:
                cr, cc = queue.pop(0)
                regions[color].append((cr, cc))
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == color and (nr, nc) not in visited:
                        visited.add((nr, nc))
                        queue.append((nr, nc))
    
    region_info = []
    for color, pixels in regions.items():
        if not pixels:
            continue
        min_r = min(p[0] for p in pixels)
        max_r = max(p[0] for p in pixels)
        min_c = min(p[1] for p in pixels)
        max_c = max(p[1] for p in pixels)
        h = max_r - min_r + 1
        w = max_c - min_c + 1
        if h == w:
            encoded_color = 5
        elif w > h:
            encoded_color = 2
        else:
            encoded_color = 8
        region_info.append({
            'color': color,
            'pixels': pixels,
            'h': h,
            'w': w,
            'encoded_color': encoded_color,
            'size': len(pixels)
        })
    
    region_info.sort(key=lambda x: x['size'], reverse=True)
    
    output = [row[:] for row in grid]
    updated_regions = set()
    
    for region in region_info:
        for r, c in region['pixels']:
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]):
                    neighbor_color = grid[nr][nc]
                    if neighbor_color == 0 or neighbor_color == region['color']:
                        continue
                    neighbor_region = next(r for r in region_info if r['color'] == neighbor_color)
                    if neighbor_region['h'] >= 2 * neighbor_region['w']:
                        if neighbor_region['color'] not in updated_regions:
                            updated_regions.add(neighbor_region['color'])
                            for (rr, cc) in neighbor_region['pixels']:
                                output[rr][cc] = region['encoded_color']
    
    return output

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = common.grid(width, height, 0)
    
    # Target region: tall (h >= 2w)
    w_target_max = min(5, min(10, height) // 2)
    w_target = random.randint(2, w_target_max)
    h_target = random.randint(2 * w_target, min(10, height))
    for r in range(h_target):
        for c in range(w_target):
            grid[r][c] = 1
    
    # Source region: square, adjacent to target (now correctly placed)
    size_src = random.randint(2, 5)
    for r in range(size_src):
        for c in range(size_src):
            if w_target + c < width:
                grid[r][w_target + c] = 2
    
    output = apply_rule(grid)
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from typing import List, Tuple

def p(input_grid: Tuple[Tuple[int, ...], ...]) -> Tuple[Tuple[int, ...], ...]:
    grid = [list(row) for row in input_grid]
    
    visited = set()
    regions = {}
    for r in range(len(grid)):
        for c in range(len(grid[0])):
            if grid[r][c] == 0 or (r, c) in visited:
                continue
            color = grid[r][c]
            if color not in regions:
                regions[color] = []
            queue = [(r, c)]
            visited.add((r, c))
            while queue:
                cr, cc = queue.pop(0)
                regions[color].append((cr, cc))
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = cr + dr, cc + dc
                    if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == color and (nr, nc) not in visited:
                        visited.add((nr, nc))
                        queue.append((nr, nc))
    
    region_info = []
    for color, pixels in regions.items():
        if not pixels:
            continue
        min_r = min(p[0] for p in pixels)
        max_r = max(p[0] for p in pixels)
        min_c = min(p[1] for p in pixels)
        max_c = max(p[1] for p in pixels)
        h = max_r - min_r + 1
        w = max_c - min_c + 1
        if h == w:
            encoded_color = 5
        elif w > h:
            encoded_color = 2
        else:
            encoded_color = 8
        region_info.append({
            'color': color,
            'pixels': pixels,
            'h': h,
            'w': w,
            'encoded_color': encoded_color,
            'size': len(pixels)
        })
    
    region_info.sort(key=lambda x: x['size'], reverse=True)
    
    output = [row[:] for row in grid]
    updated_regions = set()
    
    for region in region_info:
        for r, c in region['pixels']:
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]):
                    neighbor_color = grid[nr][nc]
                    if neighbor_color == 0 or neighbor_color == region['color']:
                        continue
                    neighbor_region = next(r for r in region_info if r['color'] == neighbor_color)
                    if neighbor_region['h'] >= 2 * neighbor_region['w']:
                        if neighbor_region['color'] not in updated_regions:
                            updated_regions.add(neighbor_region['color'])
                            for (rr, cc) in neighbor_region['pixels']:
                                output[rr][cc] = region['encoded_color']
    
    return tuple(tuple(row) for row in output)
