# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 4b0223eb
Difficulty: insane

=== Tags ===
- Bridges
- Measure distance from side
- Diagonal symmetry
- Draw rectangle

=== Description ===
The task involves transforming an input grid into an output grid through the
following steps. First, for every non-zero cell in the input grid, calculate its
minimum distance to any side (top, bottom, left, right), defined as the smallest
of its row distance from the top/bottom and column distance from the left/right.
The maximum such distance across all non-zero cells is denoted as D. The output
grid is generated by drawing a filled square rectangle centered at the grid's
interior, spanning from (D, D) to (width - D - 1, height - D - 1), where the
rectangle's size is adjusted to be square (using the smaller dimension between
width - 2D and height - 2D to maintain diagonal symmetry). The rectangle is
filled with a fixed color (e.g., 1), and all other cells are set to 0. The
output grid inherently satisfies diagonal symmetry due to the square nature of
the rectangle, ensuring that for any cell (r, c) within the rectangle, the cell
(c, r) is also within the rectangle. The transformation relies on measuring
distances from sides for non-zero input elements, drawing a symmetric rectangle,
and leveraging diagonal symmetry as a core property of the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    input_grid = [[0] * width for _ in range(height)]
    non_zero_cells = []
    for _ in range(random.randint(1, width*height//2)):
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        if input_grid[r][c] == 0:
            input_grid[r][c] = random.randint(2, 9)
            non_zero_cells.append((r, c))
    if not non_zero_cells:
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        input_grid[r][c] = random.randint(2, 9)
        non_zero_cells = [(r, c)]
    
    D = 0
    for (r, c) in non_zero_cells:
        d = min(r, height-1 - r, c, width-1 - c)
        if d > D:
            D = d
    s = min(width - 2*D, height - 2*D)
    output_grid = [[0] * width for _ in range(height)]
    for r in range(D, D + s):
        for c in range(D, D + s):
            if r < height and c < width:
                output_grid[r][c] = 1
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    D = 0
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] > 0:
                d = min(r, height-1 - r, c, width-1 - c)
                if d > D:
                    D = d
    s = min(width - 2*D, height - 2*D)
    output_grid = [[0] * width for _ in range(height)]
    for r in range(D, D + s):
        for c in range(D, D + s):
            if r < height and c < width:
                output_grid[r][c] = 1
    return output_grid
