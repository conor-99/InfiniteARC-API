# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: edca1b3f
Difficulty: very hard

=== Tags ===
- Pattern cycle

=== Description ===
**Pattern Cycle**    Input grids feature a complex arrangement of geometric
shapes (e.g., squares, triangles, circles) positioned in a repeating grid
pattern, each shape embedded within a distinct colored "cell" on a neutral
background. Each shape-cell pair follows a unique, consistent sequence of visual
transformations that cycles through a predefined set of states. The
transformations include: (1) color shifts (e.g., red → green → blue → red), (2)
shape rotations (e.g., 0° → 90° → 180° → 270°), (3) positional shifts (e.g.,
moving left → down → right → up), or combinations thereof. The sequence length
for each shape-cell pair is fixed but varies across the grid (e.g., some cycle
every 3 steps, others every 4).    The input grid displays one state in the
sequence for all shape-cell pairs. The output grid must show the *next* state in
the cycle for each pair. Crucially, the cycle for each pair is independent but
adheres to a single overarching rule (e.g., all shape rotations progress
clockwise, all color shifts follow a fixed RGB order), requiring the solver to
deduce both the cycle direction and length from the input-output examples.
The complexity arises from:   - Multiple overlapping transformations (e.g., a
shape may rotate *and* shift color simultaneously).   - Non-uniform cycle
lengths across elements (e.g., one pair cycles every 2 steps, another every 4).
- Visual ambiguity due to overlapping or similar shapes, necessitating careful
comparison of subtle differences between input and output.   - No explicit
indicators of cycle direction or length; the solver must infer it through
iterative analysis of the pattern.    The output grid preserves all background
elements and shape-cell positions, modifying only the visual attributes (color,
rotation, position) to reflect the next step in each cycle. The task demands
hierarchical reasoning to disentangle individual cycle rules from the composite
visual noise of the input grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    width = common.randint(1, 30)
    height = common.randint(1, 30)
    input_grid = common.grid(width, height, 0)
    output_grid = common.grid(width, height, 0)
    
    for r in range(height):
        for c in range(width):
            if random.random() > 0.7:
                L = 2 if c % 2 == 0 else 3
                cycle = [1, 2, 3, 4, 5, 6, 7, 8, 9][:L]
                current = common.choice(cycle)
                input_grid[r][c] = current
                idx = cycle.index(current)
                next_val = cycle[(idx + 1) % L]
                output_grid[r][c] = next_val
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common
import random

def p(input_grid):
    input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = [[0]*width for _ in range(height)]
    
    for r in range(height):
        for c in range(width):
            val = input_grid[r][c]
            if val == 0:
                output_grid[r][c] = 0
            else:
                L = 2 if c % 2 == 0 else 3
                cycle = [1, 2, 3, 4, 5, 6, 7, 8, 9][:L]
                idx = cycle.index(val)
                next_val = cycle[(idx + 1) % L]
                output_grid[r][c] = next_val
    
    return tuple(tuple(row) for row in output_grid)
