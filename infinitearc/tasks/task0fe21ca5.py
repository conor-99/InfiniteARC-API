# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 0fe21ca5
Difficulty: very hard

=== Tags ===
- Color carving
- Connect all dots of same color
- Competitive agents
- Propagate label
- Permute rows by length

=== Description ===
Input grids consist of a background (0) and multiple foreground colors (1-9),
where each color appears in multiple disconnected regions. The transformation
requires four sequential steps:  1. **Connect all dots of same color**: For each
color, connect all its disconnected regions into a single connected component
using the shortest possible path (4-directional) between regions. Paths must
avoid crossing other colors, with ties resolved by selecting the path that
minimizes vertical movement first, then horizontal.  2. **Competitive
propagation**: Propagate each color to all reachable background cells (0) via
4-directional adjacency. When a background cell is adjacent to multiple colors,
it is assigned to the color with the smallest numeric value (e.g., color 1 takes
precedence over color 2).  3. **Color carving**: After propagation, all
background cells that remain (0) are retained as-is. The foreground colors are
now fully connected and propagated, but background cells are not altered
further.  4. **Permute rows by length**: Sort all rows in descending order based
on the length of the longest contiguous segment of any single color within the
row (ignoring background cells). If two rows have identical segment lengths, the
row with the higher numeric value in its first non-background cell is placed
earlier.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import collections

def is_connected(pixels, grid):
    if not pixels:
        return True
    visited = set()
    queue = [pixels[0]]
    visited.add(pixels[0])
    while queue:
        r, c = queue.pop(0)
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if (nr, nc) in pixels and (nr, nc) not in visited:
                visited.add((nr, nc))
                queue.append((nr, nc))
    return len(visited) == len(pixels)

def find_shortest_path(comp1, comp2, grid, color):
    width = len(grid[0])
    height = len(grid)
    visited = [[False] * width for _ in range(height)]
    parent = [[None] * width for _ in range(height)]
    
    queue = collections.deque()
    for (r, c) in comp1:
        visited[r][c] = True
        queue.append((r, c))
    
    directions = [(0,1), (0,-1), (1,0), (-1,0)]
    
    while queue:
        r, c = queue.popleft()
        if (r, c) in comp2:
            path = []
            while (r, c) != comp1[0]:
                path.append((r, c))
                r, c = parent[r][c]
            path.append(comp1[0])
            return path
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == 0:
                visited[nr][nc] = True
                parent[nr][nc] = (r, c)
                queue.append((nr, nc))
    
    return []

def apply_steps(grid):
    for color in range(1, 10):
        color_cells = []
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                if grid[r][c] == color:
                    color_cells.append((r, c))
        if color_cells and not is_connected(color_cells, grid):
            comp1 = color_cells[:len(color_cells)//2]
            comp2 = color_cells[len(color_cells)//2:]
            path = find_shortest_path(comp1, comp2, grid, color)
            for (r, c) in path:
                grid[r][c] = color
    
    new_grid = [row[:] for row in grid]
    for r in range(len(new_grid)):
        for c in range(len(new_grid[0])):
            if new_grid[r][c] == 0:
                neighbors = []
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < len(new_grid) and 0 <= nc < len(new_grid[0]) and new_grid[nr][nc] != 0:
                        neighbors.append(new_grid[nr][nc])
                if neighbors:
                    new_grid[r][c] = min(neighbors)
    
    row_keys = []
    for r in range(len(new_grid)):
        row = new_grid[r]
        max_seg = 0
        current_seg = 0
        current_color = 0
        for cell in row:
            if cell == 0:
                if current_seg > max_seg:
                    max_seg = current_seg
                current_seg = 0
                current_color = 0
            else:
                if cell == current_color:
                    current_seg += 1
                else:
                    if current_seg > max_seg:
                        max_seg = current_seg
                    current_seg = 1
                    current_color = cell
        if current_seg > max_seg:
            max_seg = current_seg
        first_nonzero = None
        for cell in row:
            if cell != 0:
                first_nonzero = cell
                break
        if first_nonzero is None:
            first_nonzero = 0
        row_keys.append((max_seg, first_nonzero))
    
    sorted_rows = [row for _, row in sorted(zip(row_keys, new_grid), key=lambda x: (-x[0][0], -x[0][1]))]
    return sorted_rows

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = [[0] * width for _ in range(height)]
    
    colors = random.sample(range(1, 10), random.randint(3, 5))
    
    for color in colors:
        r1 = random.randint(0, height//3)
        c1 = random.randint(0, width//3)
        for dr in range(2):
            for dc in range(2):
                if r1 + dr < height and c1 + dc < width:
                    grid[r1 + dr][c1 + dc] = color
        
        r2 = random.randint(height*2//3, height-1)
        c2 = random.randint(width*2//3, width-1)
        for dr in range(2):
            for dc in range(2):
                if r2 + dr < height and c2 + dc < width:
                    grid[r2 + dr][c2 + dc] = color
    
    output_grid = apply_steps(grid)
    return {"input": grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import collections

def is_connected(pixels, grid):
    if not pixels:
        return True
    visited = set()
    queue = [pixels[0]]
    visited.add(pixels[0])
    while queue:
        r, c = queue.pop(0)
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if (nr, nc) in pixels and (nr, nc) not in visited:
                visited.add((nr, nc))
                queue.append((nr, nc))
    return len(visited) == len(pixels)

def find_shortest_path(comp1, comp2, grid, color):
    width = len(grid[0])
    height = len(grid)
    visited = [[False] * width for _ in range(height)]
    parent = [[None] * width for _ in range(height)]
    
    queue = collections.deque()
    for (r, c) in comp1:
        visited[r][c] = True
        queue.append((r, c))
    
    directions = [(0,1), (0,-1), (1,0), (-1,0)]
    
    while queue:
        r, c = queue.popleft()
        if (r, c) in comp2:
            path = []
            while (r, c) != comp1[0]:
                path.append((r, c))
                r, c = parent[r][c]
            path.append(comp1[0])
            return path
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and grid[nr][nc] == 0:
                visited[nr][nc] = True
                parent[nr][nc] = (r, c)
                queue.append((nr, nc))
    
    return []

def p(input_grid):
    grid = [list(row) for row in input_grid]
    
    for color in range(1, 10):
        color_cells = []
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                if grid[r][c] == color:
                    color_cells.append((r, c))
        if color_cells and not is_connected(color_cells, grid):
            comp1 = color_cells[:len(color_cells)//2]
            comp2 = color_cells[len(color_cells)//2:]
            path = find_shortest_path(comp1, comp2, grid, color)
            for (r, c) in path:
                grid[r][c] = color
    
    new_grid = [row[:] for row in grid]
    for r in range(len(new_grid)):
        for c in range(len(new_grid[0])):
            if new_grid[r][c] == 0:
                neighbors = []
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < len(new_grid) and 0 <= nc < len(new_grid[0]) and new_grid[nr][nc] != 0:
                        neighbors.append(new_grid[nr][nc])
                if neighbors:
                    new_grid[r][c] = min(neighbors)
    
    row_keys = []
    for r in range(len(new_grid)):
        row = new_grid[r]
        max_seg = 0
        current_seg = 0
        current_color = 0
        for cell in row:
            if cell == 0:
                if current_seg > max_seg:
                    max_seg = current_seg
                current_seg = 0
                current_color = 0
            else:
                if cell == current_color:
                    current_seg += 1
                else:
                    if current_seg > max_seg:
                        max_seg = current_seg
                    current_seg = 1
                    current_color = cell
        if current_seg > max_seg:
            max_seg = current_seg
        first_nonzero = None
        for cell in row:
            if cell != 0:
                first_nonzero = cell
                break
        if first_nonzero is None:
            first_nonzero = 0
        row_keys.append((max_seg, first_nonzero))
    
    sorted_rows = [row for _, row in sorted(zip(row_keys, new_grid), key=lambda x: (-x[0][0], -x[0][1]))]
    return tuple(tuple(row) for row in sorted_rows)
