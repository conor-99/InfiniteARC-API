# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: d8e90031
Difficulty: very hard

=== Tags ===
- Connect the dots
- Local state machine
- Relay chain
- Pattern repetition
- Draw line from point

=== Description ===
Input grids feature a background of color 0 with multiple single-cell nodes of
distinct colors (1-9) arranged in a non-uniform pattern. Each node acts as a
relay point in a sequence that begins at the top-leftmost node (smallest row and
column indices). From this starting node, a line is drawn in a direction
determined by the node's color: red (1) → right, blue (2) → up, green (3) →
left, yellow (4) → down, repeating for higher colors. The line travels in this
initial direction until it intersects the next node in the sequence. At each
node, the direction changes according to a repeating pattern specific to the
node's color: for a node of color C, the pattern is a cyclic shift of [right,
up, left, down] such that the starting direction in the pattern corresponds to
the node's color position in the sequence (e.g., red starts with right, blue
starts with up). The line is drawn using the starting node's color and continues
until it exits the grid or completes the chain. Output grids display all
connecting lines between sequence nodes, with segments colored according to the
starting node's color, maintaining the direction changes at each node without
overlapping nodes or background elements. The pattern repetition ensures
direction sequences cycle predictably per node color, requiring solvers to
identify the color-specific pattern shifts through multiple input-output
examples.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    """
    Generate a grid containing distinct single-cell nodes (colors 1-9) and an output
    grid with connecting lines drawn according to the color-specific cyclic patterns.

    Rules implemented:
    - Directions indexed as 0:right, 1:up, 2:left, 3:down.
    - For a node of color C the pattern is P_C = [(C-1) + 0..3] mod 4, i.e. a cyclic
      shift of [right, up, left, down] so that P_C[0] == (C-1) % 4.
    - Start node is the top-leftmost nonzero cell. Its outgoing direction is P_start[0].
    - When a line arrives at a node, the incoming direction (the direction from which
      the line came) is matched in the node's pattern; the node emits the next
      direction in its pattern (index+1 mod 4).
    - Each drawn segment is colored by the node from which it started.

    The generator builds a chain of nodes sequentially, ensuring no accidental
    intersections with existing nodes and that every placed node has at least one
    free cell in its outgoing direction (so the final output always differs from input).
    """
    DIRS = [(0, 1), (-1, 0), (0, -1), (1, 0)]  # right, up, left, down

    def pattern(color):
        shift = (color - 1) % 4
        return [ (shift + k) % 4 for k in range(4) ]

    max_attempts = 200
    for attempt in range(max_attempts):
        w = random.randint(6, 18)
        h = random.randint(6, 18)
        grid_in = [[0 for _ in range(w)] for _ in range(h)]

        # pick a start location not forced against both edges to leave room
        r0 = random.randint(0, max(0, h - 3))
        c0 = random.randint(0, max(0, w - 3))

        available_colors = list(range(1, 10))
        start_color = random.choice(available_colors)
        available_colors.remove(start_color)

        start_out = pattern(start_color)[0]
        nodes = [{'r': r0, 'c': c0, 'color': start_color, 'out': start_out}]
        grid_in[r0][c0] = start_color

        # attempt to grow a chain of random length (at least 2 nodes, up to 5 additional)
        target_extra = random.randint(1, 4)
        for _ in range(target_extra):
            cur = nodes[-1]
            r, c, prev_dir = cur['r'], cur['c'], cur['out']
            dr, dc = DIRS[prev_dir]

            # collect candidate positions along prev_dir at distance >= 2
            candidates = []
            k = 1
            while True:
                nr = r + dr * k
                nc = c + dc * k
                if not (0 <= nr < h and 0 <= nc < w):
                    break
                if grid_in[nr][nc] != 0:
                    break
                if k >= 2 and (nr > r0 or (nr == r0 and nc > c0)):
                    candidates.append((nr, nc, k))
                k += 1

            if not candidates:
                break

            random.shuffle(candidates)
            placed = False

            # Try candidate positions and colors; ensure the chosen color's outgoing
            # direction from the candidate does not immediately collide with any
            # existing node and has at least one free cell.
            for nr, nc, dist in candidates:
                # try a shuffled subset of remaining colors
                colors_try = available_colors[:]
                random.shuffle(colors_try)
                for color in colors_try:
                    P = pattern(color)
                    incoming = (prev_dir + 2) % 4
                    try:
                        idx = P.index(incoming)
                    except ValueError:
                        continue
                    out_dir = P[(idx + 1) % 4]
                    od_r, od_c = DIRS[out_dir]

                    # Check outgoing path from candidate: there must be at least one
                    # free cell and there must be no existing node anywhere along
                    # that ray (to avoid accidental collision / cycle).
                    tr = nr + od_r
                    tc = nc + od_c
                    has_free = False
                    hits_existing = False
                    while 0 <= tr < h and 0 <= tc < w:
                        if grid_in[tr][tc] != 0:
                            hits_existing = True
                            break
                        has_free = True
                        tr += od_r
                        tc += od_c

                    if not has_free or hits_existing:
                        continue

                    # place node
                    nodes.append({'r': nr, 'c': nc, 'color': color, 'out': out_dir})
                    grid_in[nr][nc] = color
                    available_colors.remove(color)
                    placed = True
                    break
                if placed:
                    break

            if not placed:
                break

        if len(nodes) < 2:
            # try again
            continue

        # Build output grid by simulating the signal path using the same rules.
        grid_out = [row[:] for row in grid_in]
        # find start node by top-leftmost rule
        node_list = [(r, c, grid_in[r][c]) for r in range(h) for c in range(w) if grid_in[r][c] != 0]
        node_list.sort(key=lambda x: (x[0], x[1]))
        cur_r, cur_c, cur_color = node_list[0]
        cur_dir = pattern(cur_color)[0]

        visited = set()
        while True:
            dr, dc = DIRS[cur_dir]
            nr = cur_r + dr
            nc = cur_c + dc
            hit = None
            while 0 <= nr < h and 0 <= nc < w:
                if grid_in[nr][nc] != 0:
                    hit = (nr, nc, grid_in[nr][nc])
                    break
                nr += dr
                nc += dc

            if hit is None:
                # draw to edge
                tr = cur_r + dr
                tc = cur_c + dc
                while 0 <= tr < h and 0 <= tc < w:
                    grid_out[tr][tc] = cur_color
                    tr += dr
                    tc += dc
                break

            # draw between cur and hit using cur_color
            hr, hc, hcol = hit
            if hr == cur_r:
                step = 1 if hc > cur_c else -1
                for cc in range(cur_c + step, hc, step):
                    grid_out[cur_r][cc] = cur_color
            else:
                step = 1 if hr > cur_r else -1
                for rr in range(cur_r + step, hr, step):
                    grid_out[rr][cur_c] = cur_color

            # compute next outgoing direction based on hit node's pattern
            incoming = (cur_dir + 2) % 4
            P_hit = pattern(hcol)
            idx = P_hit.index(incoming)
            cur_dir = P_hit[(idx + 1) % 4]
            cur_r, cur_c, cur_color = hr, hc, hcol

            key = (cur_r, cur_c, cur_dir)
            if key in visited:
                # If we detect a cycle, draw the final ray from current and stop.
                tr = cur_r + DIRS[cur_dir][0]
                tc = cur_c + DIRS[cur_dir][1]
                while 0 <= tr < h and 0 <= tc < w:
                    grid_out[tr][tc] = cur_color
                    tr += DIRS[cur_dir][0]
                    tc += DIRS[cur_dir][1]
                break
            visited.add(key)

        return {"input": grid_in, "output": grid_out}

    # fallback (shouldn't happen with many attempts) -- simple valid case
    return {"input": [[1, 0, 0], [0, 0, 0], [0, 0, 0]], "output": [[1, 1, 1], [0, 0, 0], [0, 0, 0]]}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    h = len(grid)
    w = len(grid[0]) if h else 0

    # Directions: 0:right, 1:up, 2:left, 3:down
    DIRS = [(0, 1), (-1, 0), (0, -1), (1, 0)]

    def pattern(color):
        shift = (color - 1) % 4
        return [ (shift + k) % 4 for k in range(4) ]

    # find all nodes
    nodes = [(r, c, grid[r][c]) for r in range(h) for c in range(w) if grid[r][c] != 0]
    if not nodes:
        return grid

    # start is top-leftmost node
    nodes.sort(key=lambda x: (x[0], x[1]))
    sr, sc, scol = nodes[0]

    out = [row[:] for row in grid]

    cur_r, cur_c, cur_color = sr, sc, scol
    cur_dir = pattern(cur_color)[0]

    visited = set()
    while True:
        dr, dc = DIRS[cur_dir]
        nr = cur_r + dr
        nc = cur_c + dc
        hit = None
        while 0 <= nr < h and 0 <= nc < w:
            if grid[nr][nc] != 0:
                hit = (nr, nc, grid[nr][nc])
                break
            nr += dr
            nc += dc

        if hit is None:
            # draw to edge
            tr = cur_r + dr
            tc = cur_c + dc
            while 0 <= tr < h and 0 <= tc < w:
                out[tr][tc] = cur_color
                tr += dr
                tc += dc
            break

        hr, hc, hcol = hit
        # draw between cur node and hit node with cur node's color
        if hr == cur_r:
            step = 1 if hc > cur_c else -1
            for cc in range(cur_c + step, hc, step):
                out[cur_r][cc] = cur_color
        else:
            step = 1 if hr > cur_r else -1
            for rr in range(cur_r + step, hr, step):
                out[rr][cur_c] = cur_color

        # compute next outgoing direction using hit node's pattern
        incoming = (cur_dir + 2) % 4
        P = pattern(hcol)
        idx = P.index(incoming)
        cur_dir = P[(idx + 1) % 4]

        cur_r, cur_c, cur_color = hr, hc, hcol
        key = (cur_r, cur_c, cur_dir)
        if key in visited:
            # on cycle, draw final ray outward and stop
            tr = cur_r + DIRS[cur_dir][0]
            tc = cur_c + DIRS[cur_dir][1]
            while 0 <= tr < h and 0 <= tc < w:
                out[tr][tc] = cur_color
                tr += DIRS[cur_dir][0]
                tc += DIRS[cur_dir][1]
            break
        visited.add(key)

    return out

