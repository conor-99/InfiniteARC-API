# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 0aaf4216
Difficulty: insane

=== Tags ===
- Pattern deconstruction

=== Description ===
The input grid contains multiple disconnected shapes (connected components) of
non-zero colors, each shape being a contiguous block of the same color. The
background color (0) is ignored, and all shapes are considered regardless of
their color. The output grid is formed by extracting the bounding box of each
shape, sorting these bounding boxes by their top-left coordinates (row-major
order), and arranging them horizontally side by side in the output grid. The
height of the output grid is determined by the maximum height of all extracted
shapes, while the width is the sum of the widths of all shapes. Each shape's
bounding box is placed adjacent to the previous one without overlapping,
maintaining the original shape's internal structure within its bounds. This
transformation requires identifying all distinct shapes, determining their
spatial relationships, and precisely reassembling them into a new grid structure
that reveals the deconstructed pattern.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    width = common.randint(8, 15)
    height = common.randint(8, 15)
    grid = common.grid(width, height, 0)
    colors = common.random_colors(3, exclude=[0])
    
    # Place three rectangles in different corners
    for r in range(0, 3):
        for c in range(0, 3):
            grid[r][c] = colors[0]
    
    for r in range(0, 3):
        for c in range(width-3, width):
            grid[r][c] = colors[1]
    
    for r in range(height-3, height):
        for c in range(0, 3):
            grid[r][c] = colors[2]
    
    # Compute components
    components = []
    for color in colors:
        pixels = []
        for r in range(height):
            for c in range(width):
                if grid[r][c] == color:
                    pixels.append((r, c))
        components.append(pixels)
    
    bounding_boxes = []
    for pixels in components:
        rows = [p[0] for p in pixels]
        cols = [p[1] for p in pixels]
        min_row, max_row = min(rows), max(rows)
        min_col, max_col = min(cols), max(cols)
        bounding_boxes.append((min_row, max_row, min_col, max_col))
    
    bounding_boxes.sort(key=lambda x: (x[0], x[2]))
    
    max_height = max(max_row - min_row + 1 for (min_row, max_row, min_col, max_col) in bounding_boxes)
    
    output_grid = []
    for (min_row, max_row, min_col, max_col) in bounding_boxes:
        subgrid = []
        for r in range(min_row, max_row + 1):
            row = []
            for c in range(min_col, max_col + 1):
                row.append(grid[r][c])
            subgrid.append(row)
        padding = max_height - len(subgrid)
        for _ in range(padding):
            subgrid.append([0] * (max_col - min_col + 1))
        if not output_grid:
            output_grid = subgrid
        else:
            for i in range(len(output_grid)):
                output_grid[i] += subgrid[i]
    
    return {"input": grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import common

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    visited = [[False] * width for _ in range(height)]
    components = []
    
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and input_grid[r][c] != 0:
                color = input_grid[r][c]
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                components.append(component)
    
    bounding_boxes = []
    for comp in components:
        rows = [p[0] for p in comp]
        cols = [p[1] for p in comp]
        min_row, max_row = min(rows), max(rows)
        min_col, max_col = min(cols), max(cols)
        bounding_boxes.append((min_row, max_row, min_col, max_col))
    
    bounding_boxes.sort(key=lambda x: (x[0], x[2]))
    
    max_height = max(max_row - min_row + 1 for (min_row, max_row, min_col, max_col) in bounding_boxes)
    
    output_grid = []
    for (min_row, max_row, min_col, max_col) in bounding_boxes:
        subgrid = []
        for r in range(min_row, max_row + 1):
            row = []
            for c in range(min_col, max_col + 1):
                row.append(input_grid[r][c])
            subgrid.append(row)
        pad_rows = max_height - len(subgrid)
        for _ in range(pad_rows):
            subgrid.append([0] * (max_col - min_col + 1))
        if not output_grid:
            output_grid = subgrid
        else:
            for i in range(len(output_grid)):
                output_grid[i] += subgrid[i]
    
    return output_grid
