# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-07
# ---------------------------------------------------------------

"""
Task ID: 25dbd645
Difficulty: medium

=== Tags ===
- Grid coloring
- Pattern rotation
- Divide by n
- Fractal repetition

=== Description ===
The input grid is divided into a grid of n√ón blocks, where n is a fixed integer
(e.g., 3) such that both the width and height of the grid are multiples of n.
Each block is rotated 90 degrees clockwise. The output grid is formed by
concatenating these rotated blocks. This transformation results in a fractal-
like repetition of the original pattern at smaller scales, with colors preserved
through the rotation. The grid coloring is transformed by the rotation,
maintaining consistent color relationships within each block while creating a
self-similar, scaled-down pattern across the entire grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import math
import random

def generate():
    n = 3
    a = random.randint(1, 10)
    b = random.randint(1, 10)
    while math.gcd(a, b) != 1:
        b = random.randint(1, 10)
    width = n * a
    height = n * b
    input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
    output_grid = [[0] * width for _ in range(height)]
    
    for i in range(0, height, n):
        for j in range(0, width, n):
            block = [row[j:j+n] for row in input_grid[i:i+n]]
            rotated_block = [list(x)[::-1] for x in zip(*block[::-1])]
            for r in range(n):
                for c in range(n):
                    output_grid[i + r][j + c] = rotated_block[r][c]
    
    if input_grid == output_grid:
        return generate()
    
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

import math

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    n = math.gcd(width, height)
    output_grid = [[0] * width for _ in range(height)]
    
    for i in range(0, height, n):
        for j in range(0, width, n):
            block = [row[j:j+n] for row in input_grid[i:i+n]]
            rotated_block = [list(x)[::-1] for x in zip(*block[::-1])]
            for r in range(n):
                for c in range(n):
                    output_grid[i + r][j + c] = rotated_block[r][c]
    
    return output_grid
