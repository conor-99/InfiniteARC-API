# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 3885c5bb
Difficulty: very hard

=== Tags ===
- Energy absorption
- Color majority row
- Color permutation

=== Description ===
The task involves a grid transformation where each row is processed based on its
majority color, followed by a global color permutation determined by the
sequence of these majority colors. For each row, the majority color (the most
frequent color, with ties broken by selecting the leftmost color achieving the
highest count) is identified. The row is then cyclically shifted so that the
first occurrence of this majority color is positioned at the center of the row
(for even-length rows, the left-center position is used). This process embodies
"energy absorption," as the majority color is dynamically relocated to a central
position within its row. Subsequently, the sequence of majority colors across
all rows (from top to bottom) determines a cyclic permutation of colors in the
entire grid. This permutation cycles through the unique majority colors in the
order they first appear, mapping each color to the next in the sequence (e.g.,
if the unique majority sequence is [3, 7, 1], then 3→7, 7→1, 1→3, with all other
colors unchanged). The output grid reflects both the row-centered majority
shifts and the global color permutation, resulting in a visually distinct
transformation that requires multi-step reasoning to deduce.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
    
    def transform(grid):
        shifted = []
        majorities = []
        for row in grid:
            count = [0] * 10
            for c in row:
                count[c] += 1
            max_count = max(count)
            maj = next(c for c in range(10) if count[c] == max_count)
            majorities.append(maj)
            idx = row.index(maj)
            n = len(row)
            target = (n - 1) // 2 if n % 2 else n // 2 - 1
            shift = (idx - target) % n
            shifted.append(row[shift:] + row[:shift])
        
        unique = []
        for m in majorities:
            if m not in unique:
                unique.append(m)
        perm = {}
        for i in range(len(unique)):
            perm[unique[i]] = unique[(i + 1) % len(unique)]
        
        result = []
        for row in shifted:
            result.append([perm.get(c, c) for c in row])
        return result
    
    output_grid = transform(input_grid)
    if input_grid == output_grid:
        for _ in range(10):
            width = random.randint(1, 30)
            height = random.randint(1, 30)
            input_grid = [[random.randint(0, 9) for _ in range(width)] for _ in range(height)]
            output_grid = transform(input_grid)
            if input_grid != output_grid:
                break
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    def transform(grid):
        shifted = []
        majorities = []
        for row in grid:
            count = [0] * 10
            for c in row:
                count[c] += 1
            max_count = max(count)
            maj = next(c for c in range(10) if count[c] == max_count)
            majorities.append(maj)
            idx = row.index(maj)
            n = len(row)
            target = (n - 1) // 2 if n % 2 else n // 2 - 1
            shift = (idx - target) % n
            shifted.append(row[shift:] + row[:shift])
        
        unique = []
        for m in majorities:
            if m not in unique:
                unique.append(m)
        perm = {}
        for i in range(len(unique)):
            perm[unique[i]] = unique[(i + 1) % len(unique)]
        
        result = []
        for row in shifted:
            result.append([perm.get(c, c) for c in row])
        return result
    return transform(input_grid)
