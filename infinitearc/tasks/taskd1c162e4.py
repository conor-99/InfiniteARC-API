# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: d1c162e4
Difficulty: medium–hard

=== Tags ===
- Non rectangular tiling
- Inverse rule reconstruction
- Path merging
- Hierarchical logic composition

=== Description ===
## Task Description: Hierarchical Path Tessellation  Input grids consist of a
uniform background color overlaid with a complete tiling of non-rectangular,
contiguous colored regions (tiles) that perfectly cover the grid without gaps or
overlaps. Each tile forms a unique, irregular polygonal shape (e.g., L, T, or
S-shaped clusters) and uses a distinct color. Superimposed on this tiling are
two or more orthogonal paths (each path consists of a sequence of connected
cells in a different color) that traverse through the tiles. These paths
originate from opposite grid edges and are intentionally fragmented at tile
boundaries—each path segment within a tile appears as a disjointed segment in
the input.  The output grid merges all path segments into a single continuous
path by applying hierarchical rules: (1) At tile boundaries where path segments
meet, segments are joined in the order they originated from their respective
edges; (2) The merged path preserves the original path color but eliminates all
gaps between segments; (3) Tile boundaries remain visually intact, with paths
only traversing through background cells within tiles (never crossing tile
edges). The transformation requires inverse rule reconstruction: the input path
fragmentation results from a prior tiling-based path splitting process, and the
solver must reverse this by identifying tile boundaries to reconnect segments.
Hierarchical logic composition is essential, as the solution requires first
recognizing tile shapes (to determine path fragmentation points) before applying
path merging rules. The task demands careful spatial reasoning to distinguish
between tile edges and path segments while maintaining the integrity of the non-
rectangular tiling structure.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common
from common import grid


def generate():
    # Grid size
    width = random.randint(8, 16)
    height = random.randint(8, 16)

    # Number of tiles: leave room for two distinct path colors (total colors <= 9)
    max_tiles = min(6, width * height)  # keep tiles reasonable
    num_tiles = random.randint(3, max(3, max_tiles))

    # Choose distinct colors for tiles and for two orthogonal paths
    colors = list(range(1, 10))
    tile_colors = random.sample(colors, num_tiles)
    remaining = [c for c in colors if c not in tile_colors]
    path_h_color, path_v_color = random.sample(remaining, 2)

    # Multi-source randomized expansion to partition the grid into contiguous tiles
    all_cells = [(r, c) for r in range(height) for c in range(width)]
    seeds = random.sample(all_cells, num_tiles)

    tile_idx = [[-1 for _ in range(width)] for _ in range(height)]
    assigned = set()
    frontiers = [set() for _ in range(num_tiles)]

    # Initialize seeds
    for i, (r, c) in enumerate(seeds):
        tile_idx[r][c] = i
        assigned.add((r, c))
        # add neighbors to frontier
        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in assigned:
                frontiers[i].add((nr, nc))

    unassigned = set(all_cells) - assigned

    # Expand until all cells assigned
    while unassigned:
        non_empty = [i for i in range(num_tiles) if frontiers[i]]
        if non_empty:
            i = random.choice(non_empty)
            cell = frontiers[i].pop()
            if cell in assigned:
                continue
            r, c = cell
            tile_idx[r][c] = i
            assigned.add(cell)
            unassigned.discard(cell)
            # add new frontier neighbors
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in assigned:
                    frontiers[i].add((nr, nc))
            # remove this cell from other frontiers
            for j in range(num_tiles):
                if j != i:
                    frontiers[j].discard(cell)
        else:
            # Fallback: pick an unassigned cell and attach it to a nearby tile
            cell = random.choice(list(unassigned))
            r, c = cell
            # find adjacent assigned tiles
            adjacent_tiles = []
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and (nr, nc) in assigned:
                    adjacent_tiles.append(tile_idx[nr][nc])
            if adjacent_tiles:
                i = random.choice(adjacent_tiles)
            else:
                # attach to nearest seed by Manhattan distance
                min_d = None
                i = 0
                for j, s in enumerate(seeds):
                    d = abs(s[0] - r) + abs(s[1] - c)
                    if min_d is None or d < min_d:
                        min_d = d
                        i = j
            tile_idx[r][c] = i
            assigned.add(cell)
            unassigned.discard(cell)
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = r + dr, c + dc
                if 0 <= nr < height and 0 <= nc < width and (nr, nc) not in assigned:
                    frontiers[i].add((nr, nc))
            for j in range(num_tiles):
                if j != i:
                    frontiers[j].discard(cell)

    # Build base grid painted with tile colors
    input_grid = grid(width, height, 0)
    for r in range(height):
        for c in range(width):
            tid = tile_idx[r][c]
            input_grid[r][c] = tile_colors[tid]

    # Choose orthogonal paths (one horizontal row, one vertical column)
    row = random.randint(0, height - 1)
    col = random.randint(0, width - 1)

    # Helper: a cell is a tile-boundary cell if any of its 4-neighbors has a different tile id
    def is_boundary(r, c):
        tid = tile_idx[r][c]
        for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width:
                if tile_idx[nr][nc] != tid:
                    return True
        return False

    # Draw full horizontal path first, but fragment it by erasing cells that lie on tile boundaries
    for cc in range(width):
        if not is_boundary(row, cc):
            input_grid[row][cc] = path_h_color
    # Ensure at least one endpoint remains so the path color is detectable
    input_grid[row][0] = path_h_color
    input_grid[row][width - 1] = path_h_color

    # Draw full vertical path second, fragment it similarly (this will overwrite horizontal where present)
    for rr in range(height):
        if not is_boundary(rr, col):
            input_grid[rr][col] = path_v_color
    # Ensure at least one endpoint remains
    input_grid[0][col] = path_v_color
    input_grid[height - 1][col] = path_v_color

    # Create the expected output by re-joining the segments into continuous lines
    output_grid = [list(r) for r in input_grid]
    # horizontal full (drawn first)
    for cc in range(width):
        output_grid[row][cc] = path_h_color
    # vertical full (drawn second, overwrites intersection)
    for rr in range(height):
        output_grid[rr][col] = path_v_color

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert tuple-of-tuples to mutable list-of-lists
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # Collect cells by color
    color_cells = {}
    for r in range(height):
        for c in range(width):
            color = grid[r][c]
            if color == 0:
                continue
            color_cells.setdefault(color, []).append((r, c))

    # Identify path colors: colors that lie entirely in one row or one column
    horizontal_paths = []  # tuples (color, row)
    vertical_paths = []    # tuples (color, col)

    for color, cells in color_cells.items():
        rows = {r for r, _ in cells}
        cols = {c for _, c in cells}
        # Horizontal candidate: all cells are in same row and color touches both left and right edges
        if len(rows) == 1:
            row = next(iter(rows))
            has_left = any(c == 0 for _, c in cells)
            has_right = any(c == width - 1 for _, c in cells)
            if has_left and has_right:
                horizontal_paths.append((color, row))
                continue
        # Vertical candidate: all cells are in same column and color touches top and bottom edges
        if len(cols) == 1:
            col = next(iter(cols))
            has_top = any(r == 0 for r, _ in cells)
            has_bottom = any(r == height - 1 for r, _ in cells)
            if has_top and has_bottom:
                vertical_paths.append((color, col))
                continue

    # Fallback: if detection failed (rare), accept single-row or single-column colors without edge checks
    if not horizontal_paths or not vertical_paths:
        for color, cells in color_cells.items():
            rows = {r for r, _ in cells}
            cols = {c for _, c in cells}
            if not horizontal_paths and len(rows) == 1:
                horizontal_paths.append((color, next(iter(rows))))
            if not vertical_paths and len(cols) == 1:
                vertical_paths.append((color, next(iter(cols))))

    # Build output by reconstructing full lines. Horizontal first, then vertical (vertical overwrites intersection)
    output = [row[:] for row in grid]
    for color, row in horizontal_paths:
        for c in range(width):
            output[row][c] = color
    for color, col in vertical_paths:
        for r in range(height):
            output[r][col] = color

    return output

