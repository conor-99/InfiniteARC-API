# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: 1ab3f0e2
Difficulty: hard

=== Tags ===
- Kinetic collision
- Conditional draw
- Wavefront timing
- Bouncing

=== Description ===
In this task, input grids contain particles represented by colors 1–4
(indicating movement directions: 1=right, 2=down, 3=left, 4=up) and walls
represented by color 5. The output grid shows the positions of all particles
after exactly five discrete time steps, following these deterministic rules:  1.
**Directional Movement**: Each particle moves one cell in its current direction
per step. 2. **Wall Bouncing**: If a particle's next cell is a wall (color 5),
it reverses direction *before* moving (e.g., a right-moving particle
encountering a wall now moves left). 3. **Elastic Collisions**: If two particles
would move into each other's cells during a step, both reverse direction
*before* moving (simulating a bounce). 4. **Simultaneous Resolution**: All
movements and collisions are resolved *in parallel* for each step—no sequential
ordering of particle updates. 5. **Wavefront Timing**: Each step corresponds to
a fixed time unit, with collision effects propagating instantaneously across the
grid. The simulation halts after exactly five steps, regardless of particle
positions. 6. **Conditional Draw**: Particles that remain stationary for all
five steps (e.g., stuck between walls) do not appear in the output; only
particles that moved at least once are visible.  The challenge lies in
accurately tracking directional changes through multiple collision chains (e.g.,
a particle bouncing between walls and colliding with others) while maintaining
strict step-by-step consistency. Output grids must reflect all movement dynamics
without overlapping particles or invalid positions, requiring combinatorial
reasoning across all particles and walls in the input.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    grid = [[0] * width for _ in range(height)]
    
    # Fix for empty range in random.randint
    max_walls = max(1, width * height // 5)
    num_walls = random.randint(1, max_walls)
    for _ in range(num_walls):
        r = random.randint(0, height-1)
        c = random.randint(0, width-1)
        grid[r][c] = 5
    
    # Fix for empty range in random.randint
    max_particles = max(1, min(10, width * height // 2))
    num_particles = random.randint(1, max_particles)
    for _ in range(num_particles):
        r, c = random.randint(0, height-1), random.randint(0, width-1)
        if grid[r][c] == 0:
            color = random.randint(1, 4)
            grid[r][c] = color
    
    input_grid = [row[:] for row in grid]
    output_grid = simulate_5_steps(grid)
    
    if input_grid == output_grid:
        return generate()
    
    return {
        "input": input_grid,
        "output": output_grid
    }

def simulate_5_steps(grid):
    height = len(grid)
    width = len(grid[0])
    
    particles = []
    for r in range(height):
        for c in range(width):
            if 1 <= grid[r][c] <= 4:
                particles.append((r, c, grid[r][c], r, c))
    
    moved = [False] * len(particles)
    
    for step in range(5):
        next_positions = []
        for idx, (r, c, color, r0, c0) in enumerate(particles):
            dr, dc = 0, 0
            if color == 1: dr, dc = 0, 1
            elif color == 2: dr, dc = 1, 0
            elif color == 3: dr, dc = 0, -1
            elif color == 4: dr, dc = -1, 0
            next_r, next_c = r + dr, c + dc
            next_positions.append((next_r, next_c, color, r, c, r0, c0))
        
        wall_reversals = set()
        collision_positions = {}
        for idx, (next_r, next_c, color, r, c, r0, c0) in enumerate(next_positions):
            if 0 <= next_r < height and 0 <= next_c < width and grid[next_r][next_c] == 5:
                wall_reversals.add(idx)
            key = (next_r, next_c)
            if key not in collision_positions:
                collision_positions[key] = []
            collision_positions[key].append(idx)
        
        for key, idxs in collision_positions.items():
            if len(idxs) > 1:
                for idx in idxs:
                    wall_reversals.add(idx)
        
        new_directions = []
        for idx, (next_r, next_c, color, r, c, r0, c0) in enumerate(next_positions):
            if idx in wall_reversals:
                if color == 1: new_color = 3
                elif color == 2: new_color = 4
                elif color == 3: new_color = 1
                elif color == 4: new_color = 2
                new_directions.append(new_color)
            else:
                new_directions.append(color)
        
        for idx, (next_r, next_c, color, r, c, r0, c0) in enumerate(next_positions):
            new_color = new_directions[idx]
            if 0 <= next_r < height and 0 <= next_c < width and grid[next_r][next_c] != 5:
                if next_r != r or next_c != c:
                    moved[idx] = True
                grid[r][c] = 0
                grid[next_r][next_c] = new_color
                particles[idx] = (next_r, next_c, new_color, r0, c0)
            else:
                grid[r][c] = new_color
                particles[idx] = (r, c, new_color, r0, c0)
    
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 5:
                output_grid[r][c] = 5
    for idx, (r, c, color, r0, c0) in enumerate(particles):
        if moved[idx]:
            output_grid[r][c] = color
    
    return output_grid


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    particles = []
    for r in range(height):
        for c in range(width):
            if 1 <= grid[r][c] <= 4:
                particles.append((r, c, grid[r][c], r, c))
    
    moved = [False] * len(particles)
    
    for step in range(5):
        next_positions = []
        for idx, (r, c, color, r0, c0) in enumerate(particles):
            dr, dc = 0, 0
            if color == 1: dr, dc = 0, 1
            elif color == 2: dr, dc = 1, 0
            elif color == 3: dr, dc = 0, -1
            elif color == 4: dr, dc = -1, 0
            next_r, next_c = r + dr, c + dc
            next_positions.append((next_r, next_c, color, r, c, r0, c0))
        
        wall_reversals = set()
        collision_positions = {}
        for idx, (next_r, next_c, color, r, c, r0, c0) in enumerate(next_positions):
            if 0 <= next_r < height and 0 <= next_c < width and grid[next_r][next_c] == 5:
                wall_reversals.add(idx)
            key = (next_r, next_c)
            if key not in collision_positions:
                collision_positions[key] = []
            collision_positions[key].append(idx)
        
        for key, idxs in collision_positions.items():
            if len(idxs) > 1:
                for idx in idxs:
                    wall_reversals.add(idx)
        
        new_directions = []
        for idx, (next_r, next_c, color, r, c, r0, c0) in enumerate(next_positions):
            if idx in wall_reversals:
                if color == 1: new_color = 3
                elif color == 2: new_color = 4
                elif color == 3: new_color = 1
                elif color == 4: new_color = 2
                new_directions.append(new_color)
            else:
                new_directions.append(color)
        
        for idx, (next_r, next_c, color, r, c, r0, c0) in enumerate(next_positions):
            new_color = new_directions[idx]
            if 0 <= next_r < height and 0 <= next_c < width and grid[next_r][next_c] != 5:
                if next_r != r or next_c != c:
                    moved[idx] = True
                grid[r][c] = 0
                grid[next_r][next_c] = new_color
                particles[idx] = (next_r, next_c, new_color, r0, c0)
            else:
                grid[r][c] = new_color
                particles[idx] = (r, c, new_color, r0, c0)
    
    output_grid = [[0] * width for _ in range(height)]
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 5:
                output_grid[r][c] = 5
    for idx, (r, c, color, r0, c0) in enumerate(particles):
        if moved[idx]:
            output_grid[r][c] = color
    
    return tuple(tuple(row) for row in output_grid)
