# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: dadf44ea
Difficulty: hard

=== Tags ===
- State transition by contact
- Dual grid translation
- Infer hidden grid
- Alternating direction
- Snap objects to gridlines
- Divide by n

=== Description ===
Convergent Grid States  Input grids are 20×20 with a background color (0) and
scattered colored objects (1-9) arranged in clusters. The input also contains
"guide lines" formed by a single color (e.g., color 5), which are horizontal and
vertical lines spaced at regular intervals, creating a hidden grid of sections.
The guide lines are not part of the background and appear as continuous lines
through the grid.  The output grid is generated through the following sequence
of transformations:  1. **Infer Hidden Grid**: The guide lines (color 5) define
a grid that divides the input into rectangular sections. For example, vertical
guide lines at columns 4, 8, 12, 16 and horizontal guide lines at rows 3, 6, 9,
12 create a 4×4 grid of sections. The spacing between guide lines is determined
by the input's specific pattern.  2. **Divide by n**: Each section is a
rectangle bounded by guide lines. The number of sections (n) is determined by
the guide line spacing (e.g., 4 vertical divisions, 4 horizontal divisions).  3.
**State Transition by Contact**: Within each section, adjacent objects
(horizontally or vertically) of different colors trigger a state transition. The
new color is calculated as (color_A + color_B) mod 9 + 1. Transitions occur in a
top-left to bottom-right order, resolving sequential changes (e.g., a cell
transitioning twice uses the result of the second transition).  4. **Alternating
Direction**: After transitions, objects within each section move in a direction
alternating per section row. Sections in even-numbered rows (0-based) move
right, odd-numbered rows move left. Movement occurs one cell per step until
hitting a guide line, section boundary, or another object.  5. **Snap Objects to
Gridlines**: After movement, objects are snapped to the nearest guide line
within their section (e.g., a section with vertical guide lines at columns 4 and
8 places an object at column 5 to column 4 or 8 based on proximity). Objects
snap to the closest guide line, preserving guide lines as visible features in
the output.  The output grid preserves all guide lines (color 5), background
(color 0), and shows transformed objects in their snapped positions. Guide lines
remain unchanged, and no object overwrites a guide line. The transformation
requires inferring the hidden grid from input patterns, applying sequential
state transitions, coordinating directional movement, and resolving snapping to
gridlines.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    size = 20
    input_grid = grid(size, size, 0)
    
    # Place vertical guide lines (color 5)
    v_spacing = random.randint(2, 5)
    for col in range(v_spacing, size, v_spacing):
        for row in range(size):
            input_grid[row][col] = 5

    # Place horizontal guide lines (color 5)
    h_spacing = random.randint(2, 5)
    for row in range(h_spacing, size, h_spacing):
        for col in range(size):
            input_grid[row][col] = 5

    # Place objects (1-9) in sections
    v_guides = [col for col in range(size) if all(input_grid[row][col] == 5 for row in range(size))]
    h_guides = [row for row in range(size) if all(input_grid[row][col] == 5 for col in range(size))]

    # Define sections
    v_sections = []
    if v_guides:
        v_sections.append((0, v_guides[0]-1))
        for i in range(len(v_guides)-1):
            v_sections.append((v_guides[i]+1, v_guides[i+1]-1))
        v_sections.append((v_guides[-1]+1, size-1))
    else:
        v_sections = [(0, size-1)]

    h_sections = []
    if h_guides:
        h_sections.append((0, h_guides[0]-1))
        for i in range(len(h_guides)-1):
            h_sections.append((h_guides[i]+1, h_guides[i+1]-1))
        h_sections.append((h_guides[-1]+1, size-1))
    else:
        h_sections = [(0, size-1)]

    # Place objects in sections
    for v_start, v_end in v_sections:
        for h_start, h_end in h_sections:
            for row in range(h_start, h_end+1):
                for col in range(v_start, v_end+1):
                    if random.random() < 0.3:
                        input_grid[row][col] = random.randint(1, 9)

    # Create working copy for transformations
    output_grid = [row[:] for row in input_grid]

    # Apply state transitions (top-left to bottom-right)
    for i in range(size):
        for j in range(size):
            if output_grid[i][j] != 5:
                # Check right neighbor
                if j+1 < size and output_grid[i][j+1] != 5 and output_grid[i][j] != output_grid[i][j+1]:
                    new_color = (output_grid[i][j] + output_grid[i][j+1]) % 9 + 1
                    output_grid[i][j] = new_color
                    output_grid[i][j+1] = new_color
                # Check down neighbor
                if i+1 < size and output_grid[i+1][j] != 5 and output_grid[i][j] != output_grid[i+1][j]:
                    new_color = (output_grid[i][j] + output_grid[i+1][j]) % 9 + 1
                    output_grid[i][j] = new_color
                    output_grid[i+1][j] = new_color

    # Apply movement and snapping
    # Determine section rows
    section_rows = []
    for i in range(len(h_sections)):
        section_rows.append((h_sections[i][0], h_sections[i][1]))

    # Track moving objects
    moving_objects = []
    for i in range(size):
        for j in range(size):
            if output_grid[i][j] not in [0, 5]:
                moving_objects.append((i, j, output_grid[i][j]))

    # Group objects by section row
    objects_by_section = [[] for _ in range(len(section_rows))]
    for (i, j, color) in moving_objects:
        for idx, (start, end) in enumerate(section_rows):
            if start <= i <= end:
                objects_by_section[idx].append((i, j, color))
                break

    # Apply movement and snapping
    for idx, section_objs in enumerate(objects_by_section):
        direction = 1 if idx % 2 == 0 else -1
        for (i, j, color) in section_objs:
            # Move until blocked
            while True:
                new_j = j + direction
                if new_j < 0 or new_j >= size or output_grid[i][new_j] == 5:
                    break
                if output_grid[i][new_j] != 0:
                    break
                output_grid[i][j] = 0
                j = new_j
                output_grid[i][j] = color
            
            # Snap to nearest guide line
            left_guide = None
            right_guide = None
            for guide in v_guides:
                if guide < j:
                    left_guide = guide
                elif guide > j:
                    right_guide = guide
                    break
            if left_guide is None and right_guide is None:
                continue
            elif left_guide is None:
                snap_j = right_guide - 1
            elif right_guide is None:
                snap_j = left_guide + 1
            else:
                if j - left_guide <= right_guide - j:
                    snap_j = left_guide + 1
                else:
                    snap_j = right_guide - 1
            
            # Apply snap
            output_grid[i][j] = 0
            output_grid[i][snap_j] = color

    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    size = len(input_grid)
    grid = [list(row) for row in input_grid]
    
    # Identify guide lines (color 5)
    v_guides = []
    h_guides = []
    for col in range(size):
        if all(grid[row][col] == 5 for row in range(size)):
            v_guides.append(col)
    for row in range(size):
        if all(grid[row][col] == 5 for col in range(size)):
            h_guides.append(row)

    # Define sections
    v_sections = []
    if v_guides:
        v_sections.append((0, v_guides[0]-1))
        for i in range(len(v_guides)-1):
            v_sections.append((v_guides[i]+1, v_guides[i+1]-1))
        v_sections.append((v_guides[-1]+1, size-1))
    else:
        v_sections = [(0, size-1)]

    h_sections = []
    if h_guides:
        h_sections.append((0, h_guides[0]-1))
        for i in range(len(h_guides)-1):
            h_sections.append((h_guides[i]+1, h_guides[i+1]-1))
        h_sections.append((h_guides[-1]+1, size-1))
    else:
        h_sections = [(0, size-1)]

    # Apply state transitions (top-left to bottom-right)
    for i in range(size):
        for j in range(size):
            if grid[i][j] != 5:
                # Check right neighbor
                if j+1 < size and grid[i][j+1] != 5 and grid[i][j] != grid[i][j+1]:
                    new_color = (grid[i][j] + grid[i][j+1]) % 9 + 1
                    grid[i][j] = new_color
                    grid[i][j+1] = new_color
                # Check down neighbor
                if i+1 < size and grid[i+1][j] != 5 and grid[i][j] != grid[i+1][j]:
                    new_color = (grid[i][j] + grid[i+1][j]) % 9 + 1
                    grid[i][j] = new_color
                    grid[i+1][j] = new_color

    # Apply movement and snapping
    section_rows = []
    for i in range(len(h_sections)):
        section_rows.append((h_sections[i][0], h_sections[i][1]))

    # Track moving objects
    moving_objects = []
    for i in range(size):
        for j in range(size):
            if grid[i][j] not in [0, 5]:
                moving_objects.append((i, j, grid[i][j]))

    # Group objects by section row
    objects_by_section = [[] for _ in range(len(section_rows))]
    for (i, j, color) in moving_objects:
        for idx, (start, end) in enumerate(section_rows):
            if start <= i <= end:
                objects_by_section[idx].append((i, j, color))
                break

    # Apply movement and snapping
    for idx, section_objs in enumerate(objects_by_section):
        direction = 1 if idx % 2 == 0 else -1
        for (i, j, color) in section_objs:
            # Move until blocked
            while True:
                new_j = j + direction
                if new_j < 0 or new_j >= size or grid[i][new_j] == 5:
                    break
                if grid[i][new_j] != 0:
                    break
                grid[i][j] = 0
                j = new_j
                grid[i][j] = color
            
            # Snap to nearest guide line
            left_guide = None
            right_guide = None
            for guide in v_guides:
                if guide < j:
                    left_guide = guide
                elif guide > j:
                    right_guide = guide
                    break
            if left_guide is None and right_guide is None:
                continue
            elif left_guide is None:
                snap_j = right_guide - 1
            elif right_guide is None:
                snap_j = left_guide + 1
            else:
                if j - left_guide <= right_guide - j:
                    snap_j = left_guide + 1
                else:
                    snap_j = right_guide - 1
            
            # Apply snap
            grid[i][j] = 0
            grid[i][snap_j] = color

    return [tuple(row) for row in grid]
