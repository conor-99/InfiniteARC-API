# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: cfc205f5
Difficulty: medium–hard

=== Tags ===
- Nested structure detection
- Perimeter smoothing
- Multi stage dependency chain
- Multi condition recolor
- Tiled majority vote

=== Description ===
Input grids feature multiple concentric rectangular structures, each defined by
a distinct color and separated by a consistent background color. The rectangles
are not perfectly aligned, resulting in jagged perimeter edges where adjacent
structures meet background areas. The background color is uniform throughout the
grid (e.g., gray), and each rectangle is at least 3 cells wide/tall with 2+
background cells separating consecutive layers. The grid contains 3–4 nested
rectangles, with the outermost being the largest and each inner rectangle fully
enclosed by the one before it.  The output grid requires sequential application
of three core transformations:   1. **Nested Structure Detection**: Identify all
concentric rectangles by analyzing connected components of non-background
colors, ensuring each inner rectangle is fully enclosed by the previous layer.
2. **Perimeter Smoothing**: For each rectangle, smooth its jagged perimeter by
replacing any cell adjacent (orthogonally) to the background with the background
color. This creates clean, straight-edged rectangles without jagged transitions.
3. **Tiled Majority Vote with Multi-Condition Recolor**: Divide the grid into
non-overlapping 3×3 tiles. For each tile:      - If the tile intersects the
*outermost* rectangle, recolor it to the majority non-background color within
the tile.      - If the tile intersects the *middle* rectangle, recolor it to
the rectangle’s original color (ignoring majority).      - If the tile
intersects the *innermost* rectangle, recolor it to the inverted color of the
rectangle (e.g., 2 → 7, 3 → 6, 4 → 5).      - Tiles containing only background
cells remain unchanged.      - Tiles overlapping multiple rectangles use the
*outermost* intersected layer for recoloring rules.    The background color
remains consistent, and no grid cell is recolored to a color not present in the
input. The transformation requires careful dependency tracking between perimeter
smoothing and tile-based recoloring, with no direct numerical or positional
shortcuts.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    size = random.randint(15, 30)
    bg = random.randint(0, 9)
    grid = [[bg]*size for _ in range(size)]
    
    colors = [c for c in range(10) if c != bg]
    if len(colors) < 3:
        colors = [c for c in range(10) if c != bg][:3]
    num_frames = random.randint(3, 4)
    frame_colors = random.sample(colors, num_frames)
    
    frames = []
    for i in range(num_frames):
        top = 2 + 2*i
        left = 2 + 2*i
        bottom = size - 3 - 2*i
        right = size - 3 - 2*i
        if top >= bottom or left >= right:
            break
        frames.append((top, left, bottom, right))
    
    for (top, left, bottom, right), color in zip(frames, frame_colors):
        for c in range(left, right + 1):
            if random.random() < 0.2:
                grid[top][c] = bg
            else:
                grid[top][c] = color
        for c in range(left, right + 1):
            if random.random() < 0.2:
                grid[bottom][c] = bg
            else:
                grid[bottom][c] = color
        for r in range(top, bottom + 1):
            if random.random() < 0.2:
                grid[r][left] = bg
            else:
                grid[r][left] = color
        for r in range(top, bottom + 1):
            if random.random() < 0.2:
                grid[r][right] = bg
            else:
                grid[r][right] = color
    
    output_grid = [row[:] for row in grid]
    size = len(grid)
    
    non_bg = [(r, c) for r in range(size) for c in range(size) if grid[r][c] != bg]
    if not non_bg:
        return {
            "input": grid,
            "output": grid
        }
    
    visited = set()
    components = []
    for pixel in non_bg:
        if pixel not in visited:
            comp = []
            queue = [pixel]
            visited.add(pixel)
            while queue:
                r, c = queue.pop(0)
                comp.append((r, c))
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < size and 0 <= nc < size and grid[nr][nc] != bg and (nr, nc) not in visited:
                        visited.add((nr, nc))
                        queue.append((nr, nc))
            components.append(comp)
    
    components.sort(key=len, reverse=True)
    
    for comp in components:
        for (r, c) in comp:
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < size and 0 <= nc < size and output_grid[nr][nc] == bg:
                    output_grid[r][c] = bg
    
    frame_colors = [grid[comp[0][0]][comp[0][1]] for comp in components]
    
    for r in range(0, size, 3):
        for c in range(0, size, 3):
            found = False
            for idx, comp in enumerate(components):
                for dr in range(3):
                    for dc in range(3):
                        if r + dr < size and c + dc < size:
                            if (r + dr, c + dc) in comp:
                                if idx == 0:
                                    tile_colors = []
                                    for dr2 in range(3):
                                        for dc2 in range(3):
                                            if r + dr2 < size and c + dc2 < size:
                                                val = output_grid[r + dr2][c + dc2]
                                                if val != bg:
                                                    tile_colors.append(val)
                                    if tile_colors:
                                        maj_color = max(set(tile_colors), key=tile_colors.count)
                                        for dr2 in range(3):
                                            for dc2 in range(3):
                                                if r + dr2 < size and c + dc2 < size:
                                                    output_grid[r + dr2][c + dc2] = maj_color
                                elif idx == 1:
                                    for dr2 in range(3):
                                        for dc2 in range(3):
                                            if r + dr2 < size and c + dc2 < size:
                                                output_grid[r + dr2][c + dc2] = frame_colors[1]
                                else:
                                    orig_color = frame_colors[idx]
                                    new_color = 9 - orig_color
                                    for dr2 in range(3):
                                        for dc2 in range(3):
                                            if r + dr2 < size and c + dc2 < size:
                                                output_grid[r + dr2][c + dc2] = new_color
                                found = True
                                break
                    if found:
                        break
                if found:
                    break
    
    return {
        "input": grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    size = len(grid)
    
    bg_count = {}
    for row in grid:
        for cell in row:
            bg_count[cell] = bg_count.get(cell, 0) + 1
    bg = max(bg_count, key=bg_count.get)
    
    non_bg = [(r, c) for r in range(size) for c in range(size) if grid[r][c] != bg]
    if not non_bg:
        return grid
    
    visited = set()
    components = []
    for pixel in non_bg:
        if pixel not in visited:
            comp = []
            queue = [pixel]
            visited.add(pixel)
            while queue:
                r, c = queue.pop(0)
                comp.append((r, c))
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < size and 0 <= nc < size and grid[nr][nc] != bg and (nr, nc) not in visited:
                        visited.add((nr, nc))
                        queue.append((nr, nc))
            components.append(comp)
    
    components.sort(key=len, reverse=True)
    
    output_grid = [row[:] for row in grid]
    
    for comp in components:
        for (r, c) in comp:
            for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < size and 0 <= nc < size and output_grid[nr][nc] == bg:
                    output_grid[r][c] = bg
    
    frame_colors = []
    for comp in components:
        if comp:
            frame_colors.append(grid[comp[0][0]][comp[0][1]])
        else:
            frame_colors.append(bg)
    
    for r in range(0, size, 3):
        for c in range(0, size, 3):
            found = False
            for idx, comp in enumerate(components):
                for dr in range(3):
                    for dc in range(3):
                        if r + dr < size and c + dc < size:
                            if (r + dr, c + dc) in comp:
                                if idx == 0:
                                    tile_colors = []
                                    for dr2 in range(3):
                                        for dc2 in range(3):
                                            if r + dr2 < size and c + dc2 < size:
                                                val = output_grid[r + dr2][c + dc2]
                                                if val != bg:
                                                    tile_colors.append(val)
                                    if tile_colors:
                                        maj_color = max(set(tile_colors), key=tile_colors.count)
                                        for dr2 in range(3):
                                            for dc2 in range(3):
                                                if r + dr2 < size and c + dc2 < size:
                                                    output_grid[r + dr2][c + dc2] = maj_color
                                elif idx == 1:
                                    for dr2 in range(3):
                                        for dc2 in range(3):
                                            if r + dr2 < size and c + dc2 < size:
                                                output_grid[r + dr2][c + dc2] = frame_colors[1]
                                else:
                                    orig_color = frame_colors[idx]
                                    new_color = 9 - orig_color
                                    for dr2 in range(3):
                                        for dc2 in range(3):
                                            if r + dr2 < size and c + dc2 < size:
                                                output_grid[r + dr2][c + dc2] = new_color
                                found = True
                                break
                    if found:
                        break
                if found:
                    break
    
    return output_grid
