# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 9b0a53aa
Difficulty: mediumâ€“hard

=== Tags ===
- Intersecting currents
- Spacing
- Summarize

=== Description ===
The input grids consist of a background (color 0) with multiple horizontal and
vertical "current" lines, each represented by contiguous cells of the same non-
zero color. Horizontal lines run left-right across rows, vertical lines run top-
bottom through columns. These lines may intersect where a horizontal and
vertical line share a common cell. The output grid applies a single, consistent
transformation: for every cell that is part of both a horizontal and vertical
line (i.e., an intersection point), the cell is recolored to a fixed summary
color (color 5), while all other cells remain unchanged. This "summarizes" the
intersection of two perpendicular currents into a single visual marker (color
5), effectively replacing the crossing point with a distinct symbol. The
transformation requires recognizing geometric intersections (not color values or
numerical properties) and applying the rule uniformly across all such
intersections. The task demands distinguishing between continuous lines and
their intersections, with the summary color serving as the sole visual cue for
the transformation.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(5, 30)
    height = random.randint(5, 30)
    grid = [[0] * width for _ in range(height)]
    line_color = random.choice([1,2,3,4,6,7,8,9])  # Avoid 5 to prevent input==output
    
    # Generate horizontal lines (length > 2)
    num_h_lines = random.randint(2, 5)
    horizontal_segments = []
    for _ in range(num_h_lines):
        r = random.randint(0, height - 1)
        c_start = random.randint(0, width - 3)
        c_end = random.randint(c_start + 2, width - 1)
        horizontal_segments.append((r, c_start, c_end))
        for c in range(c_start, c_end + 1):
            grid[r][c] = line_color

    # Generate vertical lines (length > 2)
    num_v_lines = random.randint(2, 5)
    vertical_segments = []
    for _ in range(num_v_lines):
        c = random.randint(0, width - 1)
        r_start = random.randint(0, height - 3)
        r_end = random.randint(r_start + 2, height - 1)
        vertical_segments.append((c, r_start, r_end))
        for r in range(r_start, r_end + 1):
            grid[r][c] = line_color

    # Ensure at least one intersection (not on segment edges)
    intersection_exists = False
    for (r, c_start, c_end) in horizontal_segments:
        for (c, r_start, r_end) in vertical_segments:
            if c_start < c < c_end and r_start < r < r_end:
                intersection_exists = True
                break
        if intersection_exists:
            break
    
    if not intersection_exists:
        return generate()

    output = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            if grid[r][c] != 0:
                has_horizontal = (c > 0 and grid[r][c-1] == grid[r][c]) or (c < width - 1 and grid[r][c+1] == grid[r][c])
                has_vertical = (r > 0 and grid[r-1][c] == grid[r][c]) or (r < height - 1 and grid[r+1][c] == grid[r][c])
                if has_horizontal and has_vertical:
                    output[r][c] = 5

    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    
    height = len(input_grid)
    width = len(input_grid[0])
    output = [row[:] for row in input_grid]
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] != 0:
                has_horizontal = (c > 0 and input_grid[r][c-1] == input_grid[r][c]) or (c < width - 1 and input_grid[r][c+1] == input_grid[r][c])
                has_vertical = (r > 0 and input_grid[r-1][c] == input_grid[r][c]) or (r < height - 1 and input_grid[r+1][c] == input_grid[r][c])
                if has_horizontal and has_vertical:
                    output[r][c] = 5
    return output
