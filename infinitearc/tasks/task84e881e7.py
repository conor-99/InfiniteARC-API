# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 84e881e7
Difficulty: very hard

=== Tags ===
- Elastic reflection
- Color wavefront
- Pattern cycle
- Energy absorption
- Cluster by shape
- Take negative

=== Description ===
Input grids feature a grid with a single wavefront source cell (color 1) at the
top-left corner, surrounded by a background of color 0. Multiple disconnected
clusters of connected cells exist throughout the grid, each forming a distinct
shape (e.g., horizontal lines, L-shapes, squares, or T-shapes) and colored
uniformly with unique colors from 2-9. The wavefront propagates diagonally in
four directions (northeast, northwest, southeast, southwest) from the source,
cycling through colors 1→2→3→...→9→1 with each step. When the wavefront
encounters a cluster cell, it reflects elastically (direction changes per
standard diagonal reflection rules), absorbs energy by updating the cluster's
color to 9 minus the wavefront's current color (e.g., hitting a cluster with
wave color 3 changes the cluster to color 6), and advances the wavefront's color
to the next in the cycle. The wavefront continues until it exits the grid
boundaries. Output grids display all clusters with their updated colors (if
impacted), while untouched clusters retain their original colors. Clusters not
intersected by the wavefront remain unchanged. The task requires identifying the
wavefront's color progression, reflection path, and color transformation rule to
determine the final grid configuration, with complexity arising from multi-step
reflections, color cycle dependencies, and shape-dependent propagation paths.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    # Grid size (keep moderate to ensure runtime and variety)
    width = random.randint(4, 14)
    height = random.randint(4, 14)
    grid = common.grid(width, height, 0)
    # source in top-left
    grid[0][0] = 1

    # available cluster colors (2..9)
    colors = list(range(2, 10))
    random.shuffle(colors)

    # number of clusters (at least 1, up to 6)
    num_clusters = random.randint(1, min(6, len(colors)))

    # Templates for small connected shapes (relative coordinates)
    shape_templates = [
        [(0, 0), (0, 1), (0, 2)],             # horizontal line 3
        [(0, 0), (1, 0), (2, 0)],             # vertical line 3
        [(0, 0), (0, 1), (1, 0), (1, 1)],     # square 2x2
        [(0, 0), (1, 0), (1, 1)],             # small L (3)
        [(0, 1), (1, 0), (1, 1), (1, 2)],     # T-like (4)
        [(0, 1), (1, 0), (1, 1), (1, 2), (2, 1)],  # cross (5)
        [(0, 0), (0, 1), (0, 2), (1, 0)],     # L-like (4)
    ]

    def transform(coords, rot, flip_h, flip_v):
        # Rotate coords rot*90deg clockwise, then optional flips
        out = []
        for (r, c) in coords:
            rr, cc = r, c
            for _ in range(rot % 4):
                rr, cc = cc, -rr
            if flip_h:
                cc = -cc
            if flip_v:
                rr = -rr
            out.append((rr, cc))
        return out

    def normalize(coords):
        # shift coords so they are as small as possible (not strictly necessary)
        minr = min(r for r, _ in coords)
        minc = min(c for _, c in coords)
        return [(r - minr, c - minc) for r, c in coords]

    # helper to check if a candidate absolute placement is valid
    def can_place_abs(abs_coords, grid_ref, forbidden_diag):
        h = len(grid_ref)
        w = len(grid_ref[0])
        for (r, c) in abs_coords:
            if not (0 <= r < h and 0 <= c < w):
                return False
            if grid_ref[r][c] != 0:
                return False
            if (r, c) == (0, 0):
                return False
            # do not place in forbidden diagonal cells (which protect the seeded path)
            if (r, c) in forbidden_diag:
                return False
            # ensure no 4-neighbour adjacency to existing clusters
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                rr, cc = r + dr, c + dc
                if 0 <= rr < h and 0 <= cc < w and grid_ref[rr][cc] != 0:
                    return False
        return True

    # pick a diagonal target k (distance from (0,0)) to guarantee at least one impacted cluster
    maxk = min(width - 1, height - 1)
    if maxk < 1:
        # degenerate: nothing to do
        return {"input": grid, "output": [row[:] for row in grid]}

    # choose k between 1 and min(4,maxk) to allow multi-step paths but keep it small
    k = random.randint(1, min(4, maxk))
    # forbid other clusters from occupying earlier diagonal cells so this seeded cluster is the first
    forbidden_diag = set((i, i) for i in range(1, k + 1))

    # compute the wave color at the time of hitting (k steps from source)
    # color progression: start at 1, each step do cur = (cur % 9) + 1, so after k steps cur = (k % 9) + 1
    cur_color_at_hit = (k % 9) + 1
    new_color_on_hit = 9 - cur_color_at_hit

    # choose seed color different from new_color_on_hit to guarantee input != output
    seed_color_candidates = [c for c in colors if c != new_color_on_hit]
    if not seed_color_candidates:
        seed_color = colors[0]
    else:
        seed_color = random.choice(seed_color_candidates)

    placed_colors = []

    # Try to place seeded cluster so that one of its cells is at (k,k)
    placed = False
    seed_attempts = 0
    while not placed and seed_attempts < 300:
        seed_attempts += 1
        base = random.choice(shape_templates)
        rot = random.randint(0, 3)
        flip_h = random.choice([False, True])
        flip_v = random.choice([False, True])
        coords_rel = transform(base, rot, flip_h, flip_v)
        # choose a pivot cell within the shape to be mapped to (k,k)
        pivot = random.choice(coords_rel)
        offset_r = k - pivot[0]
        offset_c = k - pivot[1]
        abs_coords = [(r + offset_r, c + offset_c) for r, c in coords_rel]
        if can_place_abs(abs_coords, grid, forbidden_diag):
            for (r, c) in abs_coords:
                grid[r][c] = seed_color
            placed = True
            placed_colors.append(seed_color)
            break
    # fallback: put single cell at (k,k) (rare)
    if not placed:
        if grid[k][k] == 0:
            grid[k][k] = seed_color
            placed = True
            placed_colors.append(seed_color)

    # place additional clusters (avoid forbidden diagonal cells and adjacency)
    remaining_colors = [c for c in colors if c not in placed_colors]
    for color in remaining_colors[: max(0, num_clusters - 1)]:
        placed_flag = False
        for attempt in range(300):
            base = random.choice(shape_templates)
            rot = random.randint(0, 3)
            flip_h = random.choice([False, True])
            flip_v = random.choice([False, True])
            coords_rel = transform(base, rot, flip_h, flip_v)
            # bounding box of relative coords
            minr = min(r for r, _ in coords_rel)
            maxr = max(r for r, _ in coords_rel)
            minc = min(c for _, c in coords_rel)
            maxc = max(c for _, c in coords_rel)
            low_r = -minr
            high_r = height - 1 - maxr
            low_c = -minc
            high_c = width - 1 - maxc
            if low_r > high_r or low_c > high_c:
                continue
            anchor_r = random.randint(low_r, high_r)
            anchor_c = random.randint(low_c, high_c)
            abs_coords = [(r + anchor_r, c + anchor_c) for r, c in coords_rel]
            if can_place_abs(abs_coords, grid, forbidden_diag):
                for (r, c) in abs_coords:
                    grid[r][c] = color
                placed_flag = True
                placed_colors.append(color)
                break
        # if couldn't place, skip this cluster

    input_grid = [row[:] for row in grid]

    # Simulation of diagonal wave rays with reflection and absorption
    def simulate(grid_in):
        g = [row[:] for row in grid_in]
        h = len(g)
        w = len(g[0])
        directions = [(1, 1), (1, -1), (-1, 1), (-1, -1)]
        for dr, dc in directions:
            r, c = 0, 0
            cur_color = 1
            steps = 0
            max_steps = w * h * 50 + 1000
            while steps < max_steps:
                nr = r + dr
                nc = c + dc
                if not (0 <= nr < h and 0 <= nc < w):
                    break
                # advance color as the wave moves one step
                cur_color = (cur_color % 9) + 1
                # encounter cluster cell?
                if g[nr][nc] >= 2:
                    # absorption: update cluster color
                    g[nr][nc] = 9 - cur_color
                    # wave advances its color again after absorption
                    cur_color = (cur_color % 9) + 1
                    # check the two orthogonal neighbors adjacent to the diagonal target
                    v_r, v_c = nr, c
                    h_r, h_c = r, nc
                    blocked_v = False
                    blocked_h = False
                    if not (0 <= v_r < h and 0 <= v_c < w):
                        blocked_v = True
                    elif g[v_r][v_c] >= 2:
                        blocked_v = True
                    if not (0 <= h_r < h and 0 <= h_c < w):
                        blocked_h = True
                    elif g[h_r][h_c] >= 2:
                        blocked_h = True
                    # reflection rules
                    if blocked_v and blocked_h:
                        dr = -dr
                        dc = -dc
                    elif blocked_v:
                        dr = -dr
                    elif blocked_h:
                        dc = -dc
                    else:
                        # isolated diagonal blocker -> bounce back
                        dr = -dr
                        dc = -dc
                    # move into the hit cell and continue
                    r, c = nr, nc
                else:
                    # empty cell: just move
                    r, c = nr, nc
                steps += 1
        return g

    output_grid = simulate(input_grid)

    # Guarantee input != output (should be true because we seeded a hit), but be safe
    if output_grid == input_grid:
        rr, cc = k, k
        output_grid[rr][cc] = (output_grid[rr][cc] + 1) % 10

    return {"input": input_grid, "output": output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable grid
    g = [list(row) for row in input_grid]
    h = len(g)
    w = len(g[0])

    directions = [(1, 1), (1, -1), (-1, 1), (-1, -1)]
    for dr, dc in directions:
        r, c = 0, 0
        cur_color = 1
        steps = 0
        max_steps = w * h * 50 + 1000
        while steps < max_steps:
            nr = r + dr
            nc = c + dc
            if not (0 <= nr < h and 0 <= nc < w):
                break
            # advance color for this move
            cur_color = (cur_color % 9) + 1
            if g[nr][nc] >= 2:
                # absorption
                g[nr][nc] = 9 - cur_color
                # advance color after absorption
                cur_color = (cur_color % 9) + 1
                # check orthogonal neighbors relative to the diagonal target
                v_r, v_c = nr, c
                h_r, h_c = r, nc
                blocked_v = False
                blocked_h = False
                if not (0 <= v_r < h and 0 <= v_c < w):
                    blocked_v = True
                elif g[v_r][v_c] >= 2:
                    blocked_v = True
                if not (0 <= h_r < h and 0 <= h_c < w):
                    blocked_h = True
                elif g[h_r][h_c] >= 2:
                    blocked_h = True
                if blocked_v and blocked_h:
                    dr = -dr
                    dc = -dc
                elif blocked_v:
                    dr = -dr
                elif blocked_h:
                    dc = -dc
                else:
                    dr = -dr
                    dc = -dc
                r, c = nr, nc
            else:
                r, c = nr, nc
            steps += 1

    return tuple(tuple(row) for row in g)

