# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 930e2f25
Difficulty: hard

=== Tags ===
- Elastic wave
- Paired color flow
- Reflective maze
- Implicit topology

=== Description ===
**Task Name: Reflective Color Wave Maze**    **Tags:** Elastic wave, Paired
color flow, Reflective maze, Implicit topology    **Description:**    Input
grids feature a large, intricate maze structure (minimum 20×20) composed of
walls in a single, consistent color (e.g., color 1), set against a uniform
background (color 0). The maze contains interconnected corridors with no dead
ends, ensuring all paths eventually lead to the grid’s edges. Along the bottom-
left edge (column 0, row > 5), a single source cell of color 2 emits an upward-
moving wave. Along the top-right edge (row 0, column < width - 5), a single
source cell of color 3 emits a leftward-moving wave. These sources are the
starting points of two independent wave streams that follow paired color flow
rules.    The output grid preserves all original maze walls and sources. The two
waves propagate through the background corridors as follows:   1. Each wave
travels in its initial direction (upward for the bottom-left wave, leftward for
the top-right wave) until encountering a wall.   2. Upon hitting a wall, the
wave reflects (changes direction by 90°, maintaining the same
directionality—e.g., upward becomes left, left becomes downward), and its color
alternates between the paired colors (2 → 3 → 2 → 3...).   3. The wave continues
moving in the new direction, alternating colors with each reflection, until it
exits the grid through an edge.   4. The wave’s path is drawn as a continuous
line of its current color, occupying only background cells (never overwriting
walls, sources, or other waves).    The maze’s topology is “implicit” because
the path of each wave requires deducing the reflection sequence through the
maze’s structure, rather than following a visible pattern. The paired color flow
ensures that the wave’s color alternates predictably with each reflection, but
the reflection points depend entirely on the maze’s layout.    No two waves
intersect, and all waves exit the grid after a finite number of reflections. The
output grid includes the wave paths drawn with the alternating colors, while all
walls and sources remain unchanged. The task demands simultaneous tracking of
directional changes, color transitions, and maze topology to reconstruct the
output from the input.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    from common import random_pixels, grid
    size = random.randint(20, 30)
    grid_in = grid(size, size, 0)
    
    # Generate walls using random pixels
    walls = random_pixels(size, size, prob=0.35)
    for r, c in walls:
        grid_in[r][c] = 1
    
    # Find valid source position for color 2 (bottom-left)
    source2_row = None
    for r in range(6, size-6):
        if grid_in[r][0] != 0:
            continue
        neighbors = [(r-1, 0), (r+1, 0), (r, 1)]
        valid = True
        for nr, nc in neighbors:
            if 0 <= nr < size and 0 <= nc < size and grid_in[nr][nc] != 0:
                valid = False
                break
        if valid:
            source2_row = r
            break
    
    if source2_row is None:
        source2_row = random.randint(6, size-6)
    
    # Find valid source position for color 3 (top-right)
    source3_col = None
    for c in range(5, size-5):
        if grid_in[0][c] != 0:
            continue
        neighbors = [(1, c), (0, c-1), (0, c+1)]
        valid = True
        for nr, nc in neighbors:
            if 0 <= nr < size and 0 <= nc < size and grid_in[nr][nc] != 0:
                valid = False
                break
        if valid:
            source3_col = c
            break
    
    if source3_col is None:
        source3_col = random.randint(5, size-5)
    
    # Place sources
    grid_in[source2_row][0] = 2
    grid_in[0][source3_col] = 3
    
    # Create output grid (copy of input)
    grid_out = [row[:] for row in grid_in]
    
    # Simulate wave from bottom-left source (color 2)
    r, c = source2_row, 0
    dr, dc = -1, 0  # moving upward
    color = 2
    steps = 0
    max_steps = 10000
    while steps < max_steps:
        steps += 1
        nr, nc = r + dr, c + dc
        if not (0 <= nr < size and 0 <= nc < size):
            break
        if grid_in[nr][nc] == 1:  # wall hit
            dr, dc = -dc, dr  # 90° CCW reflection
            color = 3 if color == 2 else 2
            continue
        if grid_out[nr][nc] == 0:  # draw on background
            grid_out[nr][nc] = color
        r, c = nr, nc
    
    # Simulate wave from top-right source (color 3)
    r, c = 0, source3_col
    dr, dc = 0, -1  # moving left
    color = 3
    steps = 0
    max_steps = 10000
    while steps < max_steps:
        steps += 1
        nr, nc = r + dr, c + dc
        if not (0 <= nr < size and 0 <= nc < size):
            break
        if grid_in[nr][nc] == 1:  # wall hit
            dr, dc = -dc, dr  # 90° CCW reflection
            color = 2 if color == 3 else 3
            continue
        if grid_out[nr][nc] == 0:  # draw on background
            grid_out[nr][nc] = color
        r, c = nr, nc
    
    return {"input": grid_in, "output": grid_out}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid_in = [list(row) for row in input_grid]
    size = len(grid_in)
    
    # Find source positions
    source2_row = None
    for r in range(6, size-6):
        if grid_in[r][0] == 2:
            source2_row = r
            break
    
    source3_col = None
    for c in range(5, size-5):
        if grid_in[0][c] == 3:
            source3_col = c
            break
    
    if source2_row is None or source3_col is None:
        # Fallback to any valid positions
        for r in range(size):
            if 6 <= r <= size-6 and grid_in[r][0] == 2:
                source2_row = r
        for c in range(size):
            if 5 <= c <= size-5 and grid_in[0][c] == 3:
                source3_col = c
    
    grid_out = [row[:] for row in grid_in]
    
    # Simulate wave from bottom-left source
    r, c = source2_row, 0
    dr, dc = -1, 0
    color = 2
    steps = 0
    max_steps = 10000
    while steps < max_steps:
        steps += 1
        nr, nc = r + dr, c + dc
        if not (0 <= nr < size and 0 <= nc < size):
            break
        if grid_in[nr][nc] == 1:
            dr, dc = -dc, dr
            color = 3 if color == 2 else 2
            continue
        if grid_out[nr][nc] == 0:
            grid_out[nr][nc] = color
        r, c = nr, nc
    
    # Simulate wave from top-right source
    r, c = 0, source3_col
    dr, dc = 0, -1
    color = 3
    steps = 0
    max_steps = 10000
    while steps < max_steps:
        steps += 1
        nr, nc = r + dr, c + dc
        if not (0 <= nr < size and 0 <= nc < size):
            break
        if grid_in[nr][nc] == 1:
            dr, dc = -dc, dr
            color = 2 if color == 3 else 3
            continue
        if grid_out[nr][nc] == 0:
            grid_out[nr][nc] = color
        r, c = nr, nc
    
    return tuple(tuple(row) for row in grid_out)
