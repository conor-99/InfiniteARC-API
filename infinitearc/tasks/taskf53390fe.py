# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: f53390fe
Difficulty: hard

=== Tags ===
- Connect components by property
- Non rectangular tiling
- Solve sokoban puzzle
- Detect symmetry

=== Description ===
The input grid represents a Sokoban puzzle where colored boxes must be pushed
onto target positions within a maze formed by non-rectangular regions (e.g.,
L-shaped rooms enclosed by walls). The solution requires detecting the grid's
symmetry (vertical or horizontal) to identify corresponding target positions.
Boxes are moved to their symmetric counterparts, resulting in an output grid
where all boxes occupy target positions and the arrangement exhibits perfect
symmetry. Additionally, disconnected regions (components) are connected through
the symmetric placement of boxes, forming a continuous bridge of a distinct
color between them. The transformation must account for both the Sokoban
movement constraints and the symmetry property to determine the correct output
configuration.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_pixels, connected

def generate():
    width = random.randint(5, 15)
    height = random.randint(5, 15)
    while True:
        pixels = random_pixels(width, height, prob=0.7)
        if connected(pixels):
            break
    grid_input = [[1] * width for _ in range(height)]
    for r, c in pixels:
        grid_input[r][c] = 0
    
    targets = []
    for r, c in pixels:
        mirror_c = width - 1 - c
        if (r, mirror_c) in pixels and (r, c) not in targets:
            targets.append((r, c))
            targets.append((r, mirror_c))
    targets = list(set(targets))
    for r, c in targets:
        grid_input[r][c] = 3
    
    boxes = []
    for r, c in targets:
        if c > 0 and (r, c-1) in pixels:
            grid_input[r][c-1] = 2
            boxes.append((r, c-1))
        elif c < width-1 and (r, c+1) in pixels:
            grid_input[r][c+1] = 2
            boxes.append((r, c+1))
    
    grid_output = [row[:] for row in grid_input]
    for r, c in boxes:
        mirror_c = width - 1 - c
        if grid_input[r][mirror_c] == 3:
            grid_output[r][c] = 0
            grid_output[r][mirror_c] = 2
    
    return {"input": grid_input, "output": grid_output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    width = len(input_grid[0])
    output_grid = [row[:] for row in input_grid]
    for r in range(len(input_grid)):
        for c in range(width):
            if input_grid[r][c] == 2:
                mirror_c = width - 1 - c
                if input_grid[r][mirror_c] == 3:
                    output_grid[r][c] = 0
                    output_grid[r][mirror_c] = 2
    return output_grid
