# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: ec5fc8bb
Difficulty: hard

=== Tags ===
- Pattern activation
- Split and merge
- Select every nth row
- Fill between lines

=== Description ===
Input grids feature a background color (0) with horizontal separator lines
(color 1) dividing the grid into distinct horizontal bands. The top row (row 0)
contains a sequence of non-background colors (2-9) that determines the step size
`n` for row selection: `n` equals the number of unique colors in row 0. For
example, if row 0 contains colors [2, 3, 2, 4], `n = 3` (unique colors 2, 3, 4).
The transformation process involves four sequential steps:   1. **Row
Selection**: From the input grid, select all rows at positions 0, `n`, `2n`,
etc., that fall within grid boundaries.   2. **Section Splitting**: Divide the
grid into horizontal sections bounded by separator lines (color 1 rows). Each
section spans from one separator row to the next.   3. **Section Processing**:
Within each section, select rows that are multiples of `n` relative to the
section's starting row. If a section has insufficient rows, select all rows
within it.   4. **Fill Between Lines**: Merge all selected rows into the output
grid in order. Then, fill all background cells (0) between separator lines in
the original grid's non-selected rows with color 5, while preserving all non-
background input cells. Fill operations must not overwrite existing non-
background values.  The output grid retains all non-background cells from the
input, merges selected rows, and fills background gaps between separators with
color 5. The transformation requires identifying separator lines, deriving `n`
from row 0's color pattern, applying selective row extraction, and performing
precise background filling without overwriting.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    grid = [[0] * width for _ in range(height)]
    
    row0 = []
    while True:
        row0 = [random.choice([2,3,4,5,6,7,8,9]) for _ in range(width)]
        if len(set(row0)) >= 2:
            break
    n = len(set(row0))
    
    for c in range(width):
        grid[0][c] = row0[c]
    
    separator_rows = []
    if height > 3:
        num_separators = random.randint(1, 3)
        separator_rows = sorted(random.sample(range(1, height-1), num_separators))
    for r in separator_rows:
        for c in range(width):
            grid[r][c] = 1
    
    for r in range(height):
        if r == 0 or r in separator_rows:
            continue
        for c in range(width):
            if random.random() > 0.5:
                grid[r][c] = 0
            else:
                grid[r][c] = random.choice([2,3,4,5,6,7,8,9])
    
    output = [row[:] for row in grid]
    
    for r in range(height):
        if all(x == 1 for x in grid[r]):
            continue
        prev_sep = -1
        for sep in separator_rows:
            if sep < r:
                prev_sep = sep
        start_row = prev_sep + 1 if prev_sep >= 0 else 0
        next_sep = height
        for sep in separator_rows:
            if sep > r:
                next_sep = sep
                break
        if (r - start_row) % n != 0:
            for c in range(width):
                if grid[r][c] == 0:
                    output[r][c] = 5
    
    return {
        "input": grid,
        "output": output
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    row0 = grid[0]
    n = len(set(row0))
    
    separator_rows = []
    for r in range(height):
        if all(x == 1 for x in grid[r]):
            separator_rows.append(r)
    
    output = [row[:] for row in grid]
    
    for r in range(height):
        if all(x == 1 for x in grid[r]):
            continue
        prev_sep = -1
        for sep in separator_rows:
            if sep < r:
                prev_sep = sep
        start_row = prev_sep + 1 if prev_sep >= 0 else 0
        next_sep = height
        for sep in separator_rows:
            if sep > r:
                next_sep = sep
                break
        if (r - start_row) % n != 0:
            for c in range(width):
                if grid[r][c] == 0:
                    output[r][c] = 5
    
    return output
