# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: a4bdf9c3
Difficulty: hard

=== Tags ===
- Agent memory trace
- Loopless path
- Laser diffusion
- Count touches

=== Description ===
Task: Diffuse Path Count  Input grids feature a single laser source (a cell of
color 1) positioned within a background of color 0, surrounded by walls (color
2) that form 1-cell-thick horizontal or vertical barriers. Walls never intersect
or touch other walls, and are placed to block laser diffusion in certain
directions. The output grid transforms the input by diffusing the laser from the
source in all four cardinal directions (up, down, left, right) until
encountering a wall or grid boundary. Each cell along these diffusion paths
(excluding the source) is recolored based on the number of adjacent walls (count
touches) it has—1 adjacent wall → color 1, 2 adjacent walls → color 2, etc.
Walls (color 2) and non-path background cells (color 0) remain unchanged. The
laser source retains its original color (1), and all diffusion paths are
strictly loopless by design (straight lines only), ensuring no cell is traversed
more than once per direction. The transformation requires recognizing the
diffusion pattern, tracking wall adjacency, and applying the count-based
coloring rule to generate the output.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    while True:
        width = random.randint(5, 30)
        height = random.randint(5, 30)
        grid = [[0] * width for _ in range(height)]
        
        r, c = random.randint(0, height-1), random.randint(0, width-1)
        grid[r][c] = 1
        
        horizontal_walls = random.randint(1, 3)
        for _ in range(horizontal_walls):
            r_h = random.randint(0, height-1)
            if abs(r_h - r) < 2:
                r_h = r + 2 if r_h < r else r - 2
            if r_h < 0 or r_h >= height:
                continue
            c_start = random.randint(0, width - 1)
            length = random.randint(1, 3)
            c_end = c_start + length - 1
            if c_end >= width:
                c_start = max(0, width - length)
                c_end = width - 1
            for c_idx in range(c_start, c_end + 1):
                grid[r_h][c_idx] = 2
        
        vertical_walls = random.randint(1, 3)
        for _ in range(vertical_walls):
            c_v = random.randint(0, width-1)
            if abs(c_v - c) < 2:
                c_v = c + 2 if c_v < c else c - 2
            if c_v < 0 or c_v >= width:
                continue
            r_start = random.randint(0, height - 1)
            length = random.randint(1, 3)
            r_end = r_start + length - 1
            if r_end >= height:
                r_start = max(0, height - length)
                r_end = height - 1
            for r_idx in range(r_start, r_end + 1):
                grid[r_idx][c_v] = 2
        
        output = [row[:] for row in grid]
        for i in range(height):
            for j in range(width):
                if grid[i][j] == 1:
                    source_r, source_c = i, j
                    break
            else:
                continue
            break
        
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        for dr, dc in directions:
            r_cur, c_cur = source_r + dr, source_c + dc
            while 0 <= r_cur < height and 0 <= c_cur < width and grid[r_cur][c_cur] != 2:
                count = 0
                for ddr, ddc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    nr, nc = r_cur + ddr, c_cur + ddc
                    if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 2:
                        count += 1
                output[r_cur][c_cur] = count
                r_cur += dr
                c_cur += dc
        
        # Ensure input != output
        if tuple(map(tuple, grid)) != tuple(map(tuple, output)):
            return {
                "input": grid,
                "output": output
            }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])
    
    source_r, source_c = -1, -1
    for i in range(height):
        for j in range(width):
            if grid[i][j] == 1:
                source_r, source_c = i, j
                break
        if source_r != -1:
            break
    
    if source_r == -1:
        return grid
    
    output = [row[:] for row in grid]
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    for dr, dc in directions:
        r_cur, c_cur = source_r + dr, source_c + dc
        while 0 <= r_cur < height and 0 <= c_cur < width and grid[r_cur][c_cur] != 2:
            count = 0
            for ddr, ddc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                nr, nc = r_cur + ddr, c_cur + ddc
                if 0 <= nr < height and 0 <= nc < width and grid[nr][nc] == 2:
                    count += 1
            output[r_cur][c_cur] = count
            r_cur += dr
            c_cur += dc
    
    return output
