# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 243b2867
Difficulty: mediumâ€“hard

=== Tags ===
- State transition by contact
- Periodic offset matching
- Directed field
- Substitution rule discovery
- Center object in canvas
- Draw line to nearest object of same color

=== Description ===
The input grid consists of multiple disjoint colored regions (each region is a
contiguous group of cells with the same color value between 1 and 9), separated
by background (color 0). Regions are surrounded by background with no two
regions of the same color touching in the input.   For the output
transformation, two sequential operations are applied: 1. **State Transition by
Contact**: For any two regions of the same color that are horizontally or
vertically adjacent (sharing an edge), they transition to a new color according
to a consistent substitution rule (e.g., color = (original color % 8) + 1,
ensuring no color becomes 0). This transition is applied to all such adjacent
pairs before other operations. 2. **Directed Line Drawing**: After state
transitions, for each region (now in its new color), a straight line (using a
fixed line color 9) is drawn over background cells to the nearest other region
of the same color (after transition). The line follows the shortest path
(horizontal, vertical, or diagonal) between the closest points of the two
regions. If no such region exists for a given region, no line is drawn from it.
Lines are drawn exclusively over background cells without overlapping existing
regions or other lines.  The transformation requires identifying the
substitution rule through pattern observation (e.g., adjacent same-color regions
incrementing by 1), then applying the rule before drawing lines. The output grid
must maintain all original regions (after transition), add lines only to nearest
same-color regions, and preserve background. Regions must remain fully
surrounded by background after transition, and lines must not intersect or
overwrite non-background cells.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    # Create a grid with multiple small disjoint regions (pairs of same-color regions)
    # Each pair uses a unique color in 1..4. After generation the solver will map colors
    # that appear in multiple disconnected components to a new color and draw lines (9)
    # between the two nearest points of each pair. We ensure the straight-line path
    # between paired regions passes exclusively through background cells so lines can be drawn.

    def bresenham_line(p1, p2):
        (r1, c1), (r2, c2) = p1, p2
        dr = r2 - r1
        dc = c2 - c1
        steps = max(abs(dr), abs(dc))
        if steps == 0:
            return [(r1, c1)]
        pts = []
        for i in range(steps + 1):
            # Use rounding interpolation so diagonal/horizontal/vertical lines are possible
            r = r1 + int(round(dr * i / steps))
            c = c1 + int(round(dc * i / steps))
            if not pts or pts[-1] != (r, c):
                pts.append((r, c))
        return pts

    def shape_cells(shape_type, top, left):
        if shape_type == 'dot':
            return [(top, left)]
        if shape_type == 'hbar':
            return [(top, left), (top, left + 1)]
        if shape_type == 'vbar':
            return [(top, left), (top + 1, left)]
        if shape_type == 'square':
            return [(top, left), (top, left + 1), (top + 1, left), (top + 1, left + 1)]
        # default
        return [(top, left)]

    # grid size
    width = random.randint(10, 20)
    height = random.randint(10, 20)

    # number of color pairs (each pair will have exactly two disconnected regions of same color)
    num_pairs = random.randint(2, 4)
    # available base colors 1..4, one per pair to avoid mapping collisions
    base_colors = list(range(1, 5))
    random.shuffle(base_colors)
    colors_for_pairs = base_colors[:num_pairs]

    max_attempts = 2000

    occupied = set()     # cells occupied by shapes
    reserved_paths = set()  # interior path cells reserved for lines
    shapes = []  # list of tuples (color, list of coords)

    shape_types = ['dot', 'hbar', 'vbar', 'square']

    attempts = 0
    for color in colors_for_pairs:
        placed = False
        attempts_for_pair = 0
        while not placed and attempts_for_pair < 500:
            attempts_for_pair += 1
            # choose shape types for the two regions in this pair
            st1 = random.choice(shape_types)
            st2 = random.choice(shape_types)
            # pick random top-left positions ensuring shapes fit
            # compute max top/left for each shape type
            def bounds_for(st):
                h = 1 if st in ('dot','hbar') else 2
                w = 1 if st in ('dot','vbar') else 2
                return h, w
            h1, w1 = bounds_for(st1)
            h2, w2 = bounds_for(st2)

            t1 = random.randint(0, height - h1)
            l1 = random.randint(0, width - w1)
            t2 = random.randint(0, height - h2)
            l2 = random.randint(0, width - w2)

            cells1 = shape_cells(st1, t1, l1)
            cells2 = shape_cells(st2, t2, l2)

            # quick reject if shapes overlap or are adjacent (must be separated by background)
            bad = False
            for (r,c) in cells1 + cells2:
                if (r,c) in occupied:
                    bad = True
                    break
            if bad:
                continue
            # require shapes not touch by 4-neighborhood to ensure they're surrounded by background
            def touches_4(cell, taken):
                r,c = cell
                for dr,dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                    if (r+dr, c+dc) in taken:
                        return True
                return False
            # check cells1 not adjacent to any existing occupied
            adjacent_found = False
            for cell in cells1:
                if touches_4(cell, occupied):
                    adjacent_found = True
                    break
            if adjacent_found:
                continue
            adjacent_found = False
            for cell in cells2:
                if touches_4(cell, occupied) or touches_4(cell, set(cells1)):
                    adjacent_found = True
                    break
            if adjacent_found:
                continue

            # ensure interior line between closest points passes exclusively through background and doesn't conflict with reserved_paths
            # find closest pair by Chebyshev distance
            min_cheb = None
            best_pair = None
            for a in cells1:
                for b in cells2:
                    cheb = max(abs(a[0]-b[0]), abs(a[1]-b[1]))
                    if min_cheb is None or cheb < min_cheb:
                        min_cheb = cheb
                        best_pair = (a,b)
            if best_pair is None:
                continue
            path = bresenham_line(best_pair[0], best_pair[1])
            # interior cells only (exclude endpoints which are part of regions)
            interior = path[1:-1]
            # must be within grid and not overlap existing occupied or reserved path
            path_ok = True
            for (r,c) in interior:
                if r < 0 or r >= height or c < 0 or c >= width:
                    path_ok = False
                    break
                if (r,c) in occupied:
                    path_ok = False
                    break
                if (r,c) in reserved_paths:
                    path_ok = False
                    break
            if not path_ok:
                continue

            # commit this pair: add shapes and reserve the interior path
            for cell in cells1 + cells2:
                occupied.add(cell)
            for cell in interior:
                reserved_paths.add(cell)
            shapes.append((color, cells1))
            shapes.append((color, cells2))
            placed = True
        if not placed:
            # if placement fails for this color after many tries, restart entire generation to keep logic simple
            return generate()

    # Now create the input grid
    grid = [[0 for _ in range(width)] for __ in range(height)]
    for color, coords in shapes:
        for (r,c) in coords:
            grid[r][c] = color

    # Compute the output grid following the described transformation
    # 1) State transition by contact: any color that appears in multiple disconnected regions (>=2 regions)
    #    is substituted with new_color = color + 4 (this keeps new colors in 5..8 and avoids collisions)

    # helper to compute connected components
    def components(grid):
        h = len(grid)
        w = len(grid[0])
        visited = [[False]*w for _ in range(h)]
        comps = []  # list of (color, list of coords)
        for r in range(h):
            for c in range(w):
                if grid[r][c] == 0 or visited[r][c]:
                    continue
                color = grid[r][c]
                stack = [(r,c)]
                visited[r][c] = True
                comp = []
                while stack:
                    cr, cc = stack.pop()
                    comp.append((cr, cc))
                    for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                comps.append((color, comp))
        return comps

    comps = components(grid)
    # group components by color
    by_color = {}
    for color, comp in comps:
        by_color.setdefault(color, []).append(comp)

    output = [row[:] for row in grid]

    color_map = {}
    for color, comp_list in by_color.items():
        if len(comp_list) >= 2:
            # apply substitution rule consistently
            color_map[color] = color + 4  # safe mapping within 1..9 since color in 1..4 -> maps to 5..8

    # apply mapping
    for r in range(height):
        for c in range(width):
            col = output[r][c]
            if col in color_map:
                output[r][c] = color_map[col]

    # 2) Directed Line Drawing: for each region (after substitution), draw a straight line (color 9)
    #    over background cells to the nearest other region of the same color. We will draw interior
    #    path cells only (exclude endpoints which are parts of regions). We use same bresenham_line.

    comps2 = components(output)
    # group regions by color
    regions_by_color = {}
    for color, comp in comps2:
        regions_by_color.setdefault(color, []).append(comp)

    # draw lines for each region to its nearest other region with same color
    drawn_paths = set()
    for color, comps_list in regions_by_color.items():
        if color == 0 or color == 9:
            continue
        if len(comps_list) < 2:
            continue
        # for each region, find its nearest other region and draw
        for comp in comps_list:
            min_cheb = None
            best_pair = None
            best_other = None
            for other in comps_list:
                if other is comp:
                    continue
                for a in comp:
                    for b in other:
                        cheb = max(abs(a[0]-b[0]), abs(a[1]-b[1]))
                        if min_cheb is None or cheb < min_cheb:
                            min_cheb = cheb
                            best_pair = (a,b)
                            best_other = other
            if best_pair is None:
                continue
            path = bresenham_line(best_pair[0], best_pair[1])
            interior = path[1:-1]
            # draw only if interior cells are background and not already used by another line
            ok = True
            for (r,c) in interior:
                if output[r][c] != 0 or (r,c) in drawn_paths:
                    ok = False
                    break
            if not ok or not interior:
                continue
            for (r,c) in interior:
                output[r][c] = 9
                drawn_paths.add((r,c))

    return {
        "input": grid,
        "output": output
    }



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert to mutable grid
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0])

    def components(g):
        h = len(g)
        w = len(g[0])
        visited = [[False]*w for _ in range(h)]
        comps = []  # list of (color, list of coords)
        for r in range(h):
            for c in range(w):
                if g[r][c] == 0 or visited[r][c]:
                    continue
                color = g[r][c]
                stack = [(r,c)]
                visited[r][c] = True
                comp = []
                while stack:
                    cr, cc = stack.pop()
                    comp.append((cr, cc))
                    for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and g[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                comps.append((color, comp))
        return comps

    def bresenham_line(p1, p2):
        (r1, c1), (r2, c2) = p1, p2
        dr = r2 - r1
        dc = c2 - c1
        steps = max(abs(dr), abs(dc))
        if steps == 0:
            return [(r1, c1)]
        pts = []
        for i in range(steps + 1):
            r = r1 + int(round(dr * i / steps))
            c = c1 + int(round(dc * i / steps))
            if not pts or pts[-1] != (r, c):
                pts.append((r, c))
        return pts

    # Step 1: state transition by contact
    comps = components(grid)
    by_color = {}
    for color, comp in comps:
        by_color.setdefault(color, []).append(comp)

    # Colors that have multiple disconnected components are substituted
    color_map = {}
    for color, comp_list in by_color.items():
        if len(comp_list) >= 2:
            # use same mapping as generator
            color_map[color] = color + 4

    output = [row[:] for row in grid]
    for r in range(height):
        for c in range(width):
            col = output[r][c]
            if col in color_map:
                output[r][c] = color_map[col]

    # Step 2: directed line drawing between nearest regions of same color (after substitution)
    comps2 = components(output)
    regions_by_color = {}
    for color, comp in comps2:
        regions_by_color.setdefault(color, []).append(comp)

    drawn = set()
    for color, comps_list in regions_by_color.items():
        if color == 0 or color == 9:
            continue
        if len(comps_list) < 2:
            continue
        for comp in comps_list:
            # find nearest other region of the same color
            min_cheb = None
            best_pair = None
            for other in comps_list:
                if other is comp:
                    continue
                for a in comp:
                    for b in other:
                        cheb = max(abs(a[0]-b[0]), abs(a[1]-b[1]))
                        if min_cheb is None or cheb < min_cheb:
                            min_cheb = cheb
                            best_pair = (a,b)
            if best_pair is None:
                continue
            path = bresenham_line(best_pair[0], best_pair[1])
            interior = path[1:-1]
            # draw only background cells and avoid overwriting non-zero
            if not interior:
                continue
            ok = True
            for (r,c) in interior:
                if not (0 <= r < height and 0 <= c < width):
                    ok = False
                    break
                if output[r][c] != 0 and output[r][c] != 9:
                    ok = False
                    break
                if (r,c) in drawn:
                    ok = False
                    break
            if not ok:
                continue
            for (r,c) in interior:
                if output[r][c] == 0:
                    output[r][c] = 9
                    drawn.add((r,c))

    return tuple(tuple(row) for row in output)

