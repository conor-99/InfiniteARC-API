# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: a2798a2d
Difficulty: easy

=== Tags ===
- Pattern deconstruction
- Detect repetition
- Expand to square canvas
- Take intersection

=== Description ===
The input grid contains a repeating rectangular pattern that tiles the entire
grid. The task requires deconstructing the input to identify the smallest
repeating unit (detecting repetition), then expanding this unit to a square
canvas by padding with copies of its last row or column as needed. The output
grid is formed by taking the intersection of the repeating pattern with the
square canvas, resulting in a square grid that preserves the pattern's structure
while conforming to square dimensions. The transformation is visually intuitive,
as the repeating pattern is clearly identifiable through consistent horizontal
or vertical repetition, and the padding follows a simple, deterministic rule.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    w = random.randint(1, 3)
    h = random.randint(1, 3)
    unit = []
    for _ in range(h):
        row = [random.randint(1, 9) for _ in range(w)]
        unit.append(row)
    
    max_k = 30 // w
    max_l = 30 // h
    k = random.randint(1, max_k)
    l = random.randint(1, max_l)
    
    if w == h:
        while k == 1 and l == 1:
            k = random.randint(1, max_k)
            l = random.randint(1, max_l)
    
    W = w * k
    H = h * l
    input_grid = [[0] * W for _ in range(H)]
    for i in range(H):
        for j in range(W):
            input_grid[i][j] = unit[i % h][j % w]
    
    s = max(w, h)
    output_grid = [[0] * s for _ in range(s)]
    for i in range(h):
        for j in range(w):
            output_grid[i][j] = unit[i][j]
    if w < s:
        for i in range(h):
            for j in range(w, s):
                output_grid[i][j] = unit[i][w-1]
    if h < s:
        for i in range(h, s):
            output_grid[i] = output_grid[h-1][:]
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    H = len(input_grid)
    W = len(input_grid[0])
    
    w = None
    for w_candidate in range(1, 4):
        if W % w_candidate != 0:
            continue
        valid = True
        for i in range(H):
            for j in range(W):
                if input_grid[i][j] != input_grid[i][j % w_candidate]:
                    valid = False
                    break
            if not valid:
                break
        if valid:
            w = w_candidate
            break
    
    h = None
    for h_candidate in range(1, 4):
        if H % h_candidate != 0:
            continue
        valid = True
        for i in range(H):
            for j in range(W):
                if input_grid[i][j] != input_grid[i % h_candidate][j]:
                    valid = False
                    break
            if not valid:
                break
        if valid:
            h = h_candidate
            break
    
    if w is None or h is None:
        w, h = W, H
    
    unit = [row[:w] for row in input_grid[:h]]
    
    s = max(w, h)
    output = [[0] * s for _ in range(s)]
    for i in range(h):
        for j in range(w):
            output[i][j] = unit[i][j]
    if w < s:
        for i in range(h):
            for j in range(w, s):
                output[i][j] = unit[i][w-1]
    if h < s:
        for i in range(h, s):
            output[i] = output[h-1][:]
    
    return output
