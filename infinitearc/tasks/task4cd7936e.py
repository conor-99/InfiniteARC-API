# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 4cd7936e
Difficulty: hard

=== Tags ===
- Pattern bounce
- Shape to color encoding
- Infer hidden grid
- Rule transfer between regions
- Image within image
- Bring patterns close

=== Description ===
Input grids are 20×20 with a single background color (0). Scattered throughout
are multiple distinct colored shapes (each shape is a contiguous region of a
single non-zero color, size ≥2×2), arranged such that their positions and colors
encode a hidden 3×3 grid. The hidden grid is inferred by dividing the input into
nine 6×6 subgrids (top-left to bottom-right), where each subgrid's dominant
color (the color of the shape within it) becomes the value in the hidden grid.
If a subgrid contains no shape, its value is 0.    The hidden grid's values are
mapped to movement directions: 1 → up, 2 → right, 3 → down, 4 → left (values 5–9
are ignored). The main grid contains two clusters of shapes (each cluster is a
connected region of the same color, different from background and other
clusters), positioned at opposite ends of the grid. The output grid is generated
by moving each cluster in the direction specified by the hidden grid's center
cell (position [1][1] in 0-based indexing), with the following rules:   - Each
cluster moves one cell per step in the direction, repeating until it would move
beyond the grid edge.   - When a cluster hits a grid edge, it bounces (reverses
direction) and continues moving.   - Movement continues until the clusters are
closer together than in the input (i.e., the Manhattan distance between their
centroids decreases).   - The background remains unchanged; clusters move
without overlapping or altering other shapes.    The hidden grid's center
direction dictates the movement direction for both clusters, causing them to
"bounce" toward each other through edge reflections. The output grid shows the
final positions after all movements, with clusters brought closer together
through the bounce pattern encoded in the hidden grid.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common
from common import grid


def generate():
    size = 20
    # create empty grid
    input_grid = grid(size, size, 0)
    subgrid_size = 6
    # subgrids start at 1,7,13 to leave a one-cell margin on each edge (rows/cols 0 and 19)
    starts = [1 + i * subgrid_size for i in range(3)]

    hidden_grid = [[0 for _ in range(3)] for _ in range(3)]

    # choose center color to encode direction (must be 1..4)
    center_color = random.choice([1, 2, 3, 4])

    # place one (optional) colored rectangle per subgrid; center always has a shape
    for i, sr in enumerate(starts):
        for j, sc in enumerate(starts):
            if i == 1 and j == 1:
                color = center_color
                h = random.randint(2, min(4, subgrid_size))
                w = random.randint(2, min(4, subgrid_size))
                r0 = random.randint(sr, sr + subgrid_size - h)
                c0 = random.randint(sc, sc + subgrid_size - w)
                for r in range(r0, r0 + h):
                    for c in range(c0, c0 + w):
                        input_grid[r][c] = color
                hidden_grid[i][j] = color
            else:
                # sometimes leave subgrid empty
                if random.random() < 0.6:
                    color = random.choice([1, 2, 3, 4])
                    h = random.randint(2, min(4, subgrid_size))
                    w = random.randint(2, min(4, subgrid_size))
                    r0 = random.randint(sr, sr + subgrid_size - h)
                    c0 = random.randint(sc, sc + subgrid_size - w)
                    for r in range(r0, r0 + h):
                        for c in range(c0, c0 + w):
                            input_grid[r][c] = color
                    hidden_grid[i][j] = color
                else:
                    hidden_grid[i][j] = 0

    # pick two cluster colors from 5..9 so they don't collide with 1..4 used in subgrids
    cluster_colors = random.sample([5, 6, 7, 8, 9], 2)

    # mapping center color to movement direction
    dir_map = {1: (-1, 0), 2: (0, 1), 3: (1, 0), 4: (0, -1)}
    dr, dc = dir_map[center_color]

    # place two clusters at opposite ends in the margin rows/cols (0 or 19)
    clusters = []
    if dr != 0:
        # vertical movement: put clusters at top (row 0) and bottom (row 19) in the same column (0 or 19)
        col = random.choice([0, 19])
        h1 = random.randint(2, 4)
        h2 = random.randint(2, 4)
        pixelsA = [(r, col) for r in range(0, h1)]
        pixelsB = [(r, col) for r in range(size - h2, size)]
    else:
        # horizontal movement: put clusters at left (col 0) and right (col 19) in the same row (0 or 19)
        row = random.choice([0, 19])
        w1 = random.randint(2, 4)
        w2 = random.randint(2, 4)
        pixelsA = [(row, c) for c in range(0, w1)]
        pixelsB = [(row, c) for c in range(size - w2, size)]

    # draw clusters into the input grid
    for color, pixels in zip(cluster_colors, (pixelsA, pixelsB)):
        for r, c in pixels:
            input_grid[r][c] = color

    # helper to compute centroid
    def centroid(pixels):
        return (sum(p[0] for p in pixels) / len(pixels), sum(p[1] for p in pixels) / len(pixels))

    cA0 = centroid(pixelsA)
    cB0 = centroid(pixelsB)
    initial_distance = abs(cA0[0] - cB0[0]) + abs(cA0[1] - cB0[1])

    # simulate movement step-by-step; each cluster has its own direction and bounces off edges
    drs = [dr, dr]
    dcs = [dc, dc]
    cur_pixels = [list(pixelsA), list(pixelsB)]
    final_pixels = None

    for _ in range(200):
        new_clusters = []
        for i, pixels in enumerate(cur_pixels):
            drr = drs[i]
            dcc = dcs[i]
            attempted = [(r + drr, c + dcc) for r, c in pixels]
            # if any attempted pixel would be outside bounds, bounce (reverse) and recompute
            out_of_bounds = any(r < 0 or r >= size or c < 0 or c >= size for r, c in attempted)
            if out_of_bounds:
                drr = -drr
                dcc = -dcc
                drs[i] = drr
                dcs[i] = dcc
                attempted = [(r + drr, c + dcc) for r, c in pixels]
            new_clusters.append(attempted)

        # compute centroids and check distance
        cA = centroid(new_clusters[0])
        cB = centroid(new_clusters[1])
        new_dist = abs(cA[0] - cB[0]) + abs(cA[1] - cB[1])
        cur_pixels = new_clusters
        if new_dist < initial_distance:
            final_pixels = new_clusters
            break

    if final_pixels is None:
        final_pixels = cur_pixels

    # build output grid: start with input grid but clear original cluster pixels and set final positions
    output_grid = [row[:] for row in input_grid]
    for r, c in pixelsA:
        output_grid[r][c] = 0
    for r, c in pixelsB:
        output_grid[r][c] = 0
    for color, pixels in zip(cluster_colors, final_pixels):
        for r, c in pixels:
            output_grid[r][c] = color

    return {'input': input_grid, 'output': output_grid}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # convert to mutable list of lists
    grid_in = [list(row) for row in input_grid]
    size = len(grid_in)
    subgrid_size = 6
    starts = [1 + i * subgrid_size for i in range(3)]

    # infer hidden 3x3 grid by dominant color in each 6x6 subgrid
    hidden = [[0 for _ in range(3)] for _ in range(3)]
    for i, sr in enumerate(starts):
        for j, sc in enumerate(starts):
            counts = {}
            for r in range(sr, sr + subgrid_size):
                for c in range(sc, sc + subgrid_size):
                    v = grid_in[r][c]
                    if v == 0:
                        continue
                    counts[v] = counts.get(v, 0) + 1
            if counts:
                dominant = max(counts, key=lambda k: counts[k])
            else:
                dominant = 0
            hidden[i][j] = dominant

    center_color = hidden[1][1]
    dir_map = {1: (-1, 0), 2: (0, 1), 3: (1, 0), 4: (0, -1)}
    dr, dc = dir_map.get(center_color, (0, 0))

    # find connected components of non-zero colors
    visited = [[False] * size for _ in range(size)]
    components = []
    for r in range(size):
        for c in range(size):
            if grid_in[r][c] != 0 and not visited[r][c]:
                color = grid_in[r][c]
                stack = [(r, c)]
                visited[r][c] = True
                comp = []
                while stack:
                    cr, cc = stack.pop()
                    comp.append((cr, cc))
                    for drr, dcc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                        nr, nc = cr + drr, cc + dcc
                        if 0 <= nr < size and 0 <= nc < size and not visited[nr][nc] and grid_in[nr][nc] == color:
                            visited[nr][nc] = True
                            stack.append((nr, nc))
                components.append((color, comp))

    # filter components that touch the outer border (clusters are placed in margins)
    border_comps = []
    for color, pixels in components:
        for r, c in pixels:
            if r == 0 or r == size - 1 or c == 0 or c == size - 1:
                border_comps.append((color, pixels))
                break

    if len(border_comps) < 2:
        # nothing to move or malformed; return input unchanged
        return grid_in

    # pick the two largest border components (robust if extras appear)
    border_comps.sort(key=lambda x: -len(x[1]))
    clusterA = border_comps[0]
    clusterB = border_comps[1]

    # helper centroid
    def centroid(pixels):
        return (sum(p[0] for p in pixels) / len(pixels), sum(p[1] for p in pixels) / len(pixels))

    A_pixels_init = list(clusterA[1])
    B_pixels_init = list(clusterB[1])
    cA0 = centroid(A_pixels_init)
    cB0 = centroid(B_pixels_init)
    initial_distance = abs(cA0[0] - cB0[0]) + abs(cA0[1] - cB0[1])

    # simulate movement using same rules as generator
    drs = [dr, dr]
    dcs = [dc, dc]
    cur_pixels = [list(A_pixels_init), list(B_pixels_init)]
    final_pixels = None
    for _ in range(200):
        new_clusters = []
        for i, pixels in enumerate(cur_pixels):
            drr = drs[i]
            dcc = dcs[i]
            attempted = [(r + drr, c + dcc) for r, c in pixels]
            out_of_bounds = any(r < 0 or r >= size or c < 0 or c >= size for r, c in attempted)
            if out_of_bounds:
                drr = -drr
                dcc = -dcc
                drs[i] = drr
                dcs[i] = dcc
                attempted = [(r + drr, c + dcc) for r, c in pixels]
            new_clusters.append(attempted)

        cA = centroid(new_clusters[0])
        cB = centroid(new_clusters[1])
        new_distance = abs(cA[0] - cB[0]) + abs(cA[1] - cB[1])
        cur_pixels = new_clusters
        if new_distance < initial_distance:
            final_pixels = new_clusters
            break

    if final_pixels is None:
        final_pixels = cur_pixels

    # build output grid: clear original clusters and draw moved clusters
    out = [row[:] for row in grid_in]
    for r, c in A_pixels_init:
        out[r][c] = 0
    for r, c in B_pixels_init:
        out[r][c] = 0
    for (color, _), pixels in zip((clusterA, clusterB), final_pixels):
        for r, c in pixels:
            out[r][c] = color

    return out

