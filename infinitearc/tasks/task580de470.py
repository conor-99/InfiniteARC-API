# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 580de470
Difficulty: hard

=== Tags ===
- Exclusive or coloring
- Pattern expansion
- Enlarge image

=== Description ===
Input grids consist of multiple contiguous regions of non-background colors
(each region is a solid block of a single color, at least 2×2 in size),
separated by background (color 0). Regions are orthogonally adjacent but never
diagonally connected, and no region touches the grid boundary. Output grids are
exactly twice the size of the input in both dimensions (e.g., a 5×5 input
becomes 10×10). Each input cell (r, c) maps to a 2×2 block in the output. For
non-background input cells (color C ≠ 0): the top-left cell of the block retains
color C; the top-right cell uses color C only if the input cell to the right (r,
c+1) is part of the same region (same color C), otherwise it uses the fixed
boundary-exclusive color 5; similarly, the bottom-left cell uses C only if the
cell below (r+1, c) is part of the same region, else color 5; the bottom-right
cell uses C only if both right and bottom neighbors are part of the same region,
else color 5. Background input cells (0) map to 2×2 blocks of color 0. The
boundary-exclusive color 5 (visible only at region boundaries in the output) is
the sole visual indicator of region adjacency, requiring inference of the
"exclusive" nature of boundary coloring. This task demands simultaneous
application of grid enlargement, region boundary detection, and color rule
induction, with no numerical or pixel-matching heuristics available.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

def generate():
    import random
    W = random.randint(4, 15)
    H = random.randint(4, 15)
    input_grid = [[0] * W for _ in range(H)]
    colors = list(range(1, 10))
    num_regions = random.randint(1, 3)
    placed = []
    for _ in range(num_regions):
        color = random.choice(colors)
        colors.remove(color)
        h = random.randint(2, min(5, H - 2))
        w = random.randint(2, min(5, W - 2))
        max_attempts = 100
        attempts = 0
        while attempts < max_attempts:
            attempts += 1
            r = random.randint(1, H - h - 1)
            c = random.randint(1, W - w - 1)
            valid = True
            for (r0, c0, h0, w0) in placed:
                if r <= r0 + h0 and r + h >= r0 and c <= c0 + w0 and c + w >= c0:
                    valid = False
                    break
                if (r <= r0 + h0 + 1 and r + h >= r0 - 1 and
                    c <= c0 + w0 + 1 and c + w >= c0 - 1):
                    valid = False
                    break
            if valid:
                break
        if attempts == max_attempts:
            continue  # Skip if couldn't place region
        placed.append((r, c, h, w))
        for i in range(r, r + h):
            for j in range(c, c + w):
                input_grid[i][j] = color
    output_grid = [[0] * (2 * W) for _ in range(2 * H)]
    for r in range(H):
        for c in range(W):
            val = input_grid[r][c]
            if val == 0:
                continue
            output_grid[2*r][2*c] = val
            if c + 1 < W and input_grid[r][c+1] == val:
                output_grid[2*r][2*c+1] = val
            else:
                output_grid[2*r][2*c+1] = 5
            if r + 1 < H and input_grid[r+1][c] == val:
                output_grid[2*r+1][2*c] = val
            else:
                output_grid[2*r+1][2*c] = 5
            if (c + 1 < W and input_grid[r][c+1] == val and
                r + 1 < H and input_grid[r+1][c] == val):
                output_grid[2*r+1][2*c+1] = val
            else:
                output_grid[2*r+1][2*c+1] = 5
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    H = len(input_grid)
    W = len(input_grid[0])
    output = [[0] * (2 * W) for _ in range(2 * H)]
    for r in range(H):
        for c in range(W):
            color = input_grid[r][c]
            if color == 0:
                continue
            output[2*r][2*c] = color
            if c + 1 < W and input_grid[r][c+1] == color:
                output[2*r][2*c+1] = color
            else:
                output[2*r][2*c+1] = 5
            if r + 1 < H and input_grid[r+1][c] == color:
                output[2*r+1][2*c] = color
            else:
                output[2*r+1][2*c] = 5
            if (c + 1 < W and input_grid[r][c+1] == color and
                r + 1 < H and input_grid[r+1][c] == color):
                output[2*r+1][2*c+1] = color
            else:
                output[2*r+1][2*c+1] = 5
    return output
