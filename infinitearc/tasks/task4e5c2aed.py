# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: 4e5c2aed
Difficulty: hard

=== Tags ===
- Axis inference

=== Description ===
The task involves input grids where a single pixel of color 9 is present,
marking the vertical axis of symmetry. The output grid is the input grid
mirrored over this vertical axis. The axis position is determined by the column
index of the color 9 pixel. For instance, if color 9 appears at column 3
(0-based), each column i in the input is mirrored to column (2*3 - i) in the
output. The challenge is to identify the unique color 9 pixel in the input grid,
which may be positioned anywhere within the grid, and apply the mirroring
transformation correctly. The difficulty arises from the need to precisely
locate the single marker pixel in potentially large grids (up to 30Ã—30) and
compute the mirrored columns without error, as the axis position is not fixed
and must be inferred from the input's content.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
def generate():
    width = random.randint(1, 30)
    height = random.randint(1, 30)
    c = (width - 1) // 2
    r = random.randint(0, height - 1)
    
    input_grid = [[random.randint(0, 8) for _ in range(width)] for _ in range(height)]
    input_grid[r][c] = 9
    
    symmetric = True
    for i in range(height):
        for j in range(width):
            mirror_j = 2 * c - j
            if 0 <= mirror_j < width and input_grid[i][j] != input_grid[i][mirror_j]:
                symmetric = False
                break
        if not symmetric:
            break
    
    if symmetric:
        for i in range(height):
            for j in range(width):
                if j != c:
                    mirror_j = 2 * c - j
                    if 0 <= mirror_j < width and input_grid[i][j] == input_grid[i][mirror_j]:
                        input_grid[i][j] = (input_grid[i][j] + 1) % 9
                        break
            if not symmetric:
                break
    
    output_grid = [[input_grid[i][2*c - j] if 0 <= 2*c - j < width else input_grid[i][j] for j in range(width)] for i in range(height)]
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    c = None
    for i in range(height):
        for j in range(width):
            if input_grid[i][j] == 9:
                c = j
                break
        if c is not None:
            break
    
    output_grid = [[0] * width for _ in range(height)]
    for i in range(height):
        for j in range(width):
            mirror_j = 2 * c - j
            if 0 <= mirror_j < width:
                output_grid[i][j] = input_grid[i][mirror_j]
            else:
                output_grid[i][j] = input_grid[i][j]
    
    return output_grid
