# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: d03bdbc4
Difficulty: insane

=== Tags ===
- State transition by contact
- Split and merge
- Color majority column
- Detect hor lines

=== Description ===
Input grids consist of a 2D grid with colors 0-9 (0 = background), containing
distinct horizontal line segments (color 1), vertical line segments (color 2),
and isolated transmitter cells (colors 3-9). Horizontal lines are continuous
sequences of color 1 in a row, vertical lines are continuous sequences of color
2 in a column, and transmitters are single cells surrounded by background with
no adjacent lines or other transmitters.  The transformation to the output grid
involves four sequential steps:  1. **State transition by contact**: Each
transmitter cell changes color based on adjacent lines. If adjacent to a
horizontal line (color 1), it becomes color 1; if adjacent to a vertical line
(color 2), it becomes color 2; if adjacent to both, it becomes color 3 (conflict
marker). Transmitters with no adjacent lines remain unchanged.  2. **Split and
merge**: For each horizontal line segment (color 1), if any cell in the segment
has a transmitter (now color 1 or 3) directly above or below it in the same
column, the segment splits into two separate horizontal segments with a single
background cell gap between them. Vertical lines remain unaffected.  3. **Color
majority column**: For each column, determine the majority non-background color
(ignoring background 0). In case of ties, the lowest-numbered color is chosen.
All non-background cells in the column are recolored to this majority color.  4.
**Detect hor lines**: After color recoloring, horizontal line segments are
identified as consecutive non-background cells of the same color in a row. Any
gaps within these segments are filled to ensure continuous horizontal lines,
with colors determined by the majority column rule.  The output grid reflects
all transformations: horizontal lines are split where transmitters were present,
columns are uniformly colored by majority, and all horizontal segments are
continuous and uninterrupted. The process requires simultaneous application of
multiple rules across the grid, with interactions between elements creating
complex emergent patterns.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    """
    Generate an input/output pair for the ARC task.
    Ensures at least one transmitter is adjacent to a horizontal line so that
    the output differs from the input.
    """
    # Local solver (identical logic to the public solver 'p' below)
    def _solve(inp):
        grid = [list(row) for row in inp]
        height = len(grid)
        width = len(grid[0]) if height > 0 else 0

        # Step 1: state transition by contact (simultaneous)
        original = [row[:] for row in grid]
        trans = []
        for r in range(height):
            for c in range(width):
                if 3 <= original[r][c] <= 9:
                    trans.append((r, c))
        after1 = [row[:] for row in original]
        for (r, c) in trans:
            has_h = False
            has_v = False
            for dr, dc in ((-1, 0), (1, 0), (0, -1), (0, 1)):
                rr, cc = r + dr, c + dc
                if 0 <= rr < height and 0 <= cc < width:
                    if original[rr][cc] == 1:
                        has_h = True
                    if original[rr][cc] == 2:
                        has_v = True
            if has_h and has_v:
                after1[r][c] = 3
            elif has_h:
                after1[r][c] = 1
            elif has_v:
                after1[r][c] = 2
            else:
                after1[r][c] = original[r][c]

        # Step 2: split horizontal segments where a transmitter (now 1 or 3)
        # is directly above or below any cell of the horizontal segment.
        after2 = [row[:] for row in after1]
        for r in range(height):
            c = 0
            while c < width:
                if after1[r][c] == 1:
                    start = c
                    while c < width and after1[r][c] == 1:
                        c += 1
                    end = c - 1
                    for col in range(start, end + 1):
                        above = (r - 1 >= 0 and after1[r - 1][col] in (1, 3))
                        below = (r + 1 < height and after1[r + 1][col] in (1, 3))
                        if above or below:
                            after2[r][col] = 0
                else:
                    c += 1

        # Step 3: majority color per column (ignore background 0)
        after3 = [row[:] for row in after2]
        for c in range(width):
            freq = {}
            for r in range(height):
                v = after2[r][c]
                if v != 0:
                    freq[v] = freq.get(v, 0) + 1
            if freq:
                maxcount = max(freq.values())
                # choose smallest color among those with max count
                candidates = [color for color, cnt in freq.items() if cnt == maxcount]
                majority = min(candidates)
                for r in range(height):
                    if after3[r][c] != 0:
                        after3[r][c] = majority

        # Step 4: fill horizontal gaps between two equal non-background colors
        after4 = [row[:] for row in after3]
        for r in range(height):
            c = 0
            while c < width:
                if after4[r][c] == 0:
                    c += 1
                    continue
                color = after4[r][c]
                j = c + 1
                # find next non-zero cell
                while j < width and after4[r][j] == 0:
                    j += 1
                if j < width and after4[r][j] == color and j > c + 1:
                    for k in range(c + 1, j):
                        after4[r][k] = color
                c = j

        # Return as a list of lists (generator expects lists)
        return [row[:] for row in after4]

    # Try to generate valid configuration that causes a change
    tries = 0
    while True:
        tries += 1
        width = random.randint(5, 15)
        height = random.randint(5, 15)
        grid = [[0 for _ in range(width)] for _ in range(height)]

        # Place horizontal segments
        num_h = random.randint(1, min(4, height))
        rows = random.sample(range(height), num_h)
        segments = []
        for r in rows:
            seg_len = random.randint(2, max(2, min(width, max(2, width // 3))))
            start = random.randint(0, max(0, width - seg_len))
            end = start + seg_len - 1
            for c in range(start, end + 1):
                grid[r][c] = 1
            segments.append((r, start, end))

        # Place vertical segments in columns that don't collide with horizontals
        num_v = random.randint(1, min(4, width))
        cols = random.sample(range(width), num_v)
        for c in cols:
            placed = False
            for _ in range(30):
                sr = random.randint(0, height - 2)
                er = random.randint(sr + 1, height - 1)
                conflict = False
                for rr in range(sr, er + 1):
                    if grid[rr][c] != 0:
                        conflict = True
                        break
                if not conflict:
                    for rr in range(sr, er + 1):
                        grid[rr][c] = 2
                    placed = True
                    break
            # if not placed, skip this column

        # Ensure at least one transmitter sits directly above or below a horizontal cell
        candidates = []
        for (r, s, e) in segments:
            for col in range(s, e + 1):
                if r - 1 >= 0 and grid[r - 1][col] == 0:
                    candidates.append((r, col, r - 1, col))
                if r + 1 < height and grid[r + 1][col] == 0:
                    candidates.append((r, col, r + 1, col))

        if not candidates:
            # regenerate if no place to attach a transmitter
            if tries > 200:
                # relax parameters and retry
                continue
            else:
                continue

        # Pick one guaranteed transmitter that will touch a horizontal line
        _, _, tr, tc = random.choice(candidates)
        grid[tr][tc] = random.randint(3, 9)
        transmitters = {(tr, tc)}

        # Place a few more transmitters randomly but not adjacent to existing ones
        max_extra = random.randint(0, min(3, (width * height) // 10))
        empties = [(r, c) for r in range(height) for c in range(width) if grid[r][c] == 0]
        random.shuffle(empties)
        for (r, c) in empties:
            if len(transmitters) >= 1 + max_extra:
                break
            # not adjacent to other transmitters
            ok = True
            for (tr0, tc0) in list(transmitters):
                if abs(tr0 - r) + abs(tc0 - c) == 1:
                    ok = False
                    break
            if not ok:
                continue
            grid[r][c] = random.randint(3, 9)
            transmitters.add((r, c))

        input_grid = [row[:] for row in grid]
        output_grid = _solve(input_grid)

        # Ensure input and output differ
        if output_grid != input_grid:
            return {"input": input_grid, "output": output_grid}
        # otherwise try again


# quick manual test when running generator directly
if __name__ == '__main__':
    pair = generate()
    print('IN:')
    for row in pair['input']:
        print(row)
    print('\nOUT:')
    for row in pair['output']:
        print(row)



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0

    # Step 1: state transition by contact (simultaneous)
    original = [row[:] for row in grid]
    trans = []
    for r in range(height):
        for c in range(width):
            if 3 <= original[r][c] <= 9:
                trans.append((r, c))
    after1 = [row[:] for row in original]
    for (r, c) in trans:
        has_h = False
        has_v = False
        for dr, dc in ((-1, 0), (1, 0), (0, -1), (0, 1)):
            rr, cc = r + dr, c + dc
            if 0 <= rr < height and 0 <= cc < width:
                if original[rr][cc] == 1:
                    has_h = True
                if original[rr][cc] == 2:
                    has_v = True
        if has_h and has_v:
            after1[r][c] = 3
        elif has_h:
            after1[r][c] = 1
        elif has_v:
            after1[r][c] = 2
        else:
            after1[r][c] = original[r][c]

    # Step 2: split horizontal segments where a transmitter (now 1 or 3)
    # is directly above or below any cell of the horizontal segment.
    after2 = [row[:] for row in after1]
    for r in range(height):
        c = 0
        while c < width:
            if after1[r][c] == 1:
                start = c
                while c < width and after1[r][c] == 1:
                    c += 1
                end = c - 1
                for col in range(start, end + 1):
                    above = (r - 1 >= 0 and after1[r - 1][col] in (1, 3))
                    below = (r + 1 < height and after1[r + 1][col] in (1, 3))
                    if above or below:
                        after2[r][col] = 0
            else:
                c += 1

    # Step 3: majority color per column (ignore background 0)
    after3 = [row[:] for row in after2]
    for c in range(width):
        freq = {}
        for r in range(height):
            v = after2[r][c]
            if v != 0:
                freq[v] = freq.get(v, 0) + 1
        if freq:
            maxcount = max(freq.values())
            candidates = [color for color, cnt in freq.items() if cnt == maxcount]
            majority = min(candidates)
            for r in range(height):
                if after3[r][c] != 0:
                    after3[r][c] = majority

    # Step 4: fill horizontal gaps between two equal non-background colors
    after4 = [row[:] for row in after3]
    for r in range(height):
        c = 0
        while c < width:
            if after4[r][c] == 0:
                c += 1
                continue
            color = after4[r][c]
            j = c + 1
            # find next non-zero cell
            while j < width and after4[r][j] == 0:
                j += 1
            if j < width and after4[r][j] == color and j > c + 1:
                for k in range(c + 1, j):
                    after4[r][k] = color
            c = j

    return tuple(tuple(row) for row in after4)

