# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-03
# ---------------------------------------------------------------

"""
Task ID: 9088207f
Difficulty: medium

=== Tags ===
- Image within image
- Adapt image to grid

=== Description ===
The task involves a 2D grid where a distinct foreground image (composed of non-
zero values) is embedded within a background of zeros. The foreground image may
be any connected shape or pattern, but it is always surrounded by background
zeros on all sides. The transformation requires identifying the minimal bounding
rectangle that fully contains all non-background pixels of the input grid. The
output grid is this bounding rectangle, preserving the relative positions and
values of the foreground pixels while removing all surrounding background. This
process adapts the embedded image to a new grid that exactly fits its spatial
extent, without any resizing, rotation, or additional modifications. The
solution relies purely on visual spatial reasoning to isolate the foreground
region from its background context.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import random_el, random_you, random_aitch, random_color

def generate():
    shape_types = ['el', 'you', 'aitch']
    shape_type = random.choice(shape_types)
    width, height = random.randint(3, 5), random.randint(3, 5)
    if shape_type == 'el':
        shape_pixels = random_el(width, height)
    elif shape_type == 'you':
        shape_pixels = random_you(width, height)
    else:  # 'aitch'
        shape_pixels = random_aitch(width, height)
    
    if not shape_pixels:
        return generate()
    
    rows, cols = zip(*shape_pixels)
    min_r, max_r = min(rows), max(rows)
    min_c, max_c = min(cols), max(cols)
    shape_h = max_r - min_r + 1
    shape_w = max_c - min_c + 1
    
    input_h = random.randint(shape_h + 2, 30)
    input_w = random.randint(shape_w + 2, 30)
    
    input_grid = [[0] * input_w for _ in range(input_h)]
    color = random_color(exclude=[0])
    
    top_pad = random.randint(1, input_h - shape_h - 1)
    left_pad = random.randint(1, input_w - shape_w - 1)
    
    for (r, c) in shape_pixels:
        input_grid[r + top_pad][c + left_pad] = color
    
    non_zero = [(i, j) for i in range(input_h) for j in range(input_w) if input_grid[i][j] != 0]
    if not non_zero:
        return generate()
    
    rows, cols = zip(*non_zero)
    min_r, max_r = min(rows), max(rows)
    min_c, max_c = min(cols), max(cols)
    
    output_grid = [row[min_c:max_c+1] for row in input_grid[min_r:max_r+1]]
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    non_zero = [(i, j) for i in range(len(input_grid)) for j in range(len(input_grid[0])) if input_grid[i][j] != 0]
    if not non_zero:
        return []
    rows, cols = zip(*non_zero)
    min_r, max_r = min(rows), max(rows)
    min_c, max_c = min(cols), max(cols)
    return [row[min_c:max_c+1] for row in input_grid[min_r:max_r+1]]
