# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 9ac6e295
Difficulty: hard

=== Tags ===
- Symbolic spatial binding
- Hierarchical agent routing

=== Description ===
Input grids are large (20×20) with a single background color (0). The grid
contains four distinct agent symbols (colors 1–4), each represented as a single
cell, and four binding symbols (colors 5–8), each represented as a single cell.
Each binding symbol color corresponds to a specific agent color (binding color 5
binds to agent 1, 6 to 2, 7 to 3, 8 to 4). The grid also contains obstacles
(color 9) placed to create complex spatial barriers.   The output grid is
generated by drawing the shortest path from each agent to its binding symbol
using 4-directional movement, moving only through background cells (0). Paths
are drawn in the agent’s color (1–4), replacing background cells along the path.
Agents are processed in descending order of their color (4 → 3 → 2 → 1), meaning
higher-priority agents (higher color values) draw their paths first, blocking
lower-priority agents from traversing those cells. If a path is blocked by a
higher-priority path, the agent takes the alternative shortest path around the
obstacle. All paths must avoid obstacles (9) and previously drawn paths, and the
binding symbols remain unchanged at their original positions. The output grid
shows all paths drawn in their respective agent colors, with the background,
obstacles, and binding symbols preserved.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from collections import deque

def generate():
    size = 20
    agent_colors = [1, 2, 3, 4]
    binding_colors = [5, 6, 7, 8]
    all_cells = [(r, c) for r in range(size) for c in range(size)]

    def bfs_prev(grid, start, target):
        n = len(grid)
        prev = [[None] * n for _ in range(n)]
        visited = [[False] * n for _ in range(n)]
        q = deque()
        q.append(start)
        visited[start[0]][start[1]] = True
        while q:
            r, c = q.popleft()
            if (r, c) == target:
                break
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = r + dr, c + dc
                if 0 <= nr < n and 0 <= nc < n and not visited[nr][nc]:
                    if (nr, nc) == target or grid[nr][nc] == 0:
                        visited[nr][nc] = True
                        prev[nr][nc] = (r, c)
                        q.append((nr, nc))
        if not visited[target[0]][target[1]]:
            return None
        return prev

    # Try a small number of randomized layouts to keep generation fast
    for attempt in range(40):
        # pick agents
        agents_positions = random.sample(all_cells, 4)
        remaining = [cell for cell in all_cells if cell not in agents_positions]
        # pick bindings per agent ensuring minimal separation
        bindings_positions = []
        ok_bind = True
        for i in range(4):
            found = False
            for _ in range(40):
                candidate = random.choice(remaining)
                if abs(candidate[0] - agents_positions[i][0]) + abs(candidate[1] - agents_positions[i][1]) > 1:
                    bindings_positions.append(candidate)
                    remaining.remove(candidate)
                    found = True
                    break
            if not found:
                ok_bind = False
                break
        if not ok_bind:
            continue

        base_grid = [[0] * size for _ in range(size)]
        for i, (r, c) in enumerate(agents_positions):
            base_grid[r][c] = agent_colors[i]
        for i, (r, c) in enumerate(bindings_positions):
            base_grid[r][c] = binding_colors[i]

        free_cells = [cell for cell in all_cells if cell not in agents_positions and cell not in bindings_positions]

        # try a few obstacle layouts
        for _ in range(6):
            grid = [row[:] for row in base_grid]
            obstacle_count = random.randint(35, 80)
            obstacle_count = min(obstacle_count, len(free_cells))
            obstacles = random.sample(free_cells, obstacle_count)
            for (r, c) in obstacles:
                grid[r][c] = 9

            input_grid = [row[:] for row in grid]
            output = [row[:] for row in grid]

            success = True
            # draw paths in descending priority
            for i in range(3, -1, -1):
                agent_pos = agents_positions[i]
                binding_pos = bindings_positions[i]
                prev = bfs_prev(output, agent_pos, binding_pos)
                if prev is None:
                    success = False
                    break
                # reconstruct
                cur = binding_pos
                path = []
                while cur != agent_pos:
                    p = prev[cur[0]][cur[1]]
                    if p is None:
                        success = False
                        break
                    path.append(cur)
                    cur = p
                if not success:
                    break
                path.reverse()
                for (r, c) in path[:-1]:
                    if output[r][c] == 0:
                        output[r][c] = agent_colors[i]
            if success and output != input_grid:
                return {"input": input_grid, "output": output}
    # deterministic fallback (guaranteed valid and fast)
    grid = [[0] * size for _ in range(size)]
    agents_positions = [(1, 1), (1, 18), (18, 1), (18, 18)]
    bindings_positions = [(1, 4), (4, 18), (17, 1), (18, 15)]
    for i, (r, c) in enumerate(agents_positions):
        grid[r][c] = agent_colors[i]
    for i, (r, c) in enumerate(bindings_positions):
        grid[r][c] = binding_colors[i]
    for c in range(5, 15):
        grid[10][c] = 9
    input_grid = [row[:] for row in grid]
    output = [row[:] for row in grid]
    for i in range(3, -1, -1):
        prev = bfs_prev(output, agents_positions[i], bindings_positions[i])
        if prev is None:
            continue
        cur = bindings_positions[i]
        path = []
        while cur != agents_positions[i]:
            p = prev[cur[0]][cur[1]]
            if p is None:
                break
            path.append(cur)
            cur = p
        path.reverse()
        for (r, c) in path[:-1]:
            if output[r][c] == 0:
                output[r][c] = agent_colors[i]
    return {"input": input_grid, "output": output}



# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    # convert to mutable list of lists
    grid = [list(row) for row in input_grid]
    size = len(grid)
    agent_colors = [1, 2, 3, 4]
    binding_colors = [5, 6, 7, 8]

    # find agent and binding positions
    agent_pos_map = {}
    binding_pos_map = {}
    for r in range(size):
        for c in range(size):
            val = grid[r][c]
            if 1 <= val <= 4:
                agent_pos_map[val] = (r, c)
            elif 5 <= val <= 8:
                binding_pos_map[val] = (r, c)

    output = [row[:] for row in grid]

    def bfs_prev(grid_state, start, target):
        n = len(grid_state)
        prev = [[None] * n for _ in range(n)]
        visited = [[False] * n for _ in range(n)]
        q = deque()
        q.append(start)
        visited[start[0]][start[1]] = True
        while q:
            r, c = q.popleft()
            if (r, c) == target:
                break
            for dr, dc in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                nr, nc = r + dr, c + dc
                if 0 <= nr < n and 0 <= nc < n and not visited[nr][nc]:
                    if (nr, nc) == target or grid_state[nr][nc] == 0:
                        visited[nr][nc] = True
                        prev[nr][nc] = (r, c)
                        q.append((nr, nc))
        if not visited[target[0]][target[1]]:
            return None
        return prev

    # process agents in descending priority
    for color in [4, 3, 2, 1]:
        if color not in agent_pos_map:
            continue
        agent_pos = agent_pos_map[color]
        binding_pos = binding_pos_map.get(color + 4)
        if binding_pos is None:
            continue

        prev = bfs_prev(output, agent_pos, binding_pos)
        if prev is None:
            continue
        # reconstruct and paint path (excluding binding cell)
        path = []
        cur = binding_pos
        while cur != agent_pos:
            p = prev[cur[0]][cur[1]]
            if p is None:
                path = []
                break
            path.append(cur)
            cur = p
        path.reverse()
        for r, c in path[:-1]:
            if output[r][c] == 0:
                output[r][c] = color

    return output

