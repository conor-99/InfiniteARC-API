# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: e4690b4c
Difficulty: very hard

=== Tags ===
- Compositional reflection
- Multi stage color switch
- Threshold by area
- Recolor by count

=== Description ===
Input grids feature multiple contiguous colored regions (connected via edge-
adjacency) with distinct colors between 1-9. Each region's area (number of
cells) determines its transformation. The output grid is generated through two
sequential transformations:  1. **Compositional Reflection**: Regions with area
exceeding a fixed threshold (e.g., 5 cells) are horizontally reflected across
the grid's vertical midline. Reflection is applied per-region by mirroring each
cell's column index relative to the midline (e.g., column c becomes width - c -
1), while preserving the region's original color and connectivity.  2. **Multi-
stage Color Switch**: After reflection, all regions are recolored based on the
count of regions sharing their *original color* (before reflection).
Specifically, if a region originated as color C and there were K regions of
color C in the input, all regions that started as color C are recolored to color
K. This recoloring uses the input's original color assignments, not the
reflected state.  The threshold value (e.g., 5) is fixed for all examples. The
task requires identifying contiguous regions, applying reflection selectively
based on area, and correctly mapping original color counts to new colorsâ€”without
conflating reflected positions with original color labels. The complexity arises
from the interplay between spatial reflection (dependent on area) and color
remapping (dependent on global count), requiring careful separation of
transformation stages.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import common

def generate():
    W = random.randint(5, 30)
    H = random.randint(5, 30)
    grid = [[0] * W for _ in range(H)]
    
    num_regions = random.randint(3, 5)
    for i in range(num_regions):
        color = random.randint(1, 9)
        size = random.randint(6, 15) if i % 2 == 0 else random.randint(1, 5)
        pixels = common.continuous_creature(size, W, H)
        
        if size > 5:
            if not all(c < W // 2 for r, c in pixels):
                continue
        else:
            if not all(c >= W // 2 for r, c in pixels):
                continue
        
        for r, c in pixels:
            grid[r][c] = color
    
    visited = set()
    input_regions = []
    for r in range(H):
        for c in range(W):
            if grid[r][c] > 0 and (r, c) not in visited:
                region = []
                stack = [(r, c)]
                visited.add((r, c))
                while stack:
                    cr, cc = stack.pop()
                    region.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < H and 0 <= nc < W and grid[nr][nc] == grid[r][c] and (nr, nc) not in visited:
                            visited.add((nr, nc))
                            stack.append((nr, nc))
                input_regions.append(region)
    
    color_counts = {}
    for region in input_regions:
        color = grid[region[0][0]][region[0][1]]
        color_counts[color] = color_counts.get(color, 0) + 1
    
    output = [[0] * W for _ in range(H)]
    for r in range(H):
        for c in range(W):
            if grid[r][c] == 0:
                continue
            region_area = None
            for region in input_regions:
                if (r, c) in region:
                    region_area = len(region)
                    break
            if region_area > 5:
                new_c = W - 1 - c
            else:
                new_c = c
            output[r][new_c] = color_counts[grid[r][c]]
    
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    W = len(grid[0])
    H = len(grid)
    
    visited = set()
    input_regions = []
    for r in range(H):
        for c in range(W):
            if grid[r][c] > 0 and (r, c) not in visited:
                region = []
                stack = [(r, c)]
                visited.add((r, c))
                while stack:
                    cr, cc = stack.pop()
                    region.append((cr, cc))
                    for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < H and 0 <= nc < W and grid[nr][nc] == grid[r][c] and (nr, nc) not in visited:
                            visited.add((nr, nc))
                            stack.append((nr, nc))
                input_regions.append(region)
    
    color_counts = {}
    for region in input_regions:
        color = grid[region[0][0]][region[0][1]]
        color_counts[color] = color_counts.get(color, 0) + 1
    
    output = [[0] * W for _ in range(H)]
    for r in range(H):
        for c in range(W):
            if grid[r][c] == 0:
                continue
            region_area = None
            for region in input_regions:
                if (r, c) in region:
                    region_area = len(region)
                    break
            if region_area > 5:
                new_c = W - 1 - c
            else:
                new_c = c
            output[r][new_c] = color_counts[grid[r][c]]
    
    return output
