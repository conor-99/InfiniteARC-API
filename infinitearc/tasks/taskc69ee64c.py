# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: c69ee64c
Difficulty: medium

=== Tags ===
- Reflect by color
- Contouring
- Trace perimeter
- Stripe detection

=== Description ===
The input grid consists of a 2D array of colors (0-9), where a single horizontal
or vertical stripe (a full row or column of identical non-zero color) exists.
The output grid is generated by reflecting the input grid across the axis of
this stripe. If the stripe is horizontal (a row), the grid is reflected
vertically over that row (e.g., row i swaps with row N-1-i relative to the
stripe's position). If the stripe is vertical (a column), the grid is reflected
horizontally over that column (e.g., column j swaps with column M-1-j relative
to the stripe's position). The stripe acts as the contour traced perimeter for
reflection, aligning with "Contouring" and "Trace perimeter" tags, while the
stripe's color determines the reflection axis for "Reflect by color." The
transformation is deterministic, requiring only one stripe to exist in the
input, ensuring the output differs from the input.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = random.randint(2, 30)
    height = random.randint(2, 30)
    is_horizontal = random.choice([True, False])
    stripe_color = random.randint(1, 9)
    if is_horizontal:
        stripe_pos = random.randint(0, height-1)
        input_grid = grid(width, height, 0)
        for c in range(width):
            input_grid[stripe_pos][c] = stripe_color
        for r in range(height):
            if r == stripe_pos:
                continue
            for c in range(width):
                input_grid[r][c] = random.randint(0, 9)
            if all(x == input_grid[r][0] for x in input_grid[r]):
                input_grid[r][0] = (input_grid[r][0] + 1) % 10
    else:
        stripe_pos = random.randint(0, width-1)
        input_grid = grid(width, height, 0)
        for r in range(height):
            input_grid[r][stripe_pos] = stripe_color
        for c in range(width):
            if c == stripe_pos:
                continue
            for r in range(height):
                input_grid[r][c] = random.randint(0, 9)
            if all(input_grid[r][c] == input_grid[0][c] for r in range(height)):
                input_grid[0][c] = (input_grid[0][c] + 1) % 10
    output_grid = []
    if is_horizontal:
        for r in range(height):
            new_r = 2 * stripe_pos - r
            if new_r < 0:
                new_r = 0
            elif new_r >= height:
                new_r = height - 1
            output_grid.append(input_grid[new_r])
    else:
        for r in range(height):
            new_row = []
            for c in range(width):
                new_c = 2 * stripe_pos - c
                if new_c < 0:
                    new_c = 0
                elif new_c >= width:
                    new_c = width - 1
                new_row.append(input_grid[r][new_c])
            output_grid.append(new_row)
    if input_grid == output_grid:
        for _ in range(5):
            if is_horizontal:
                r = random.choice([i for i in range(height) if i != stripe_pos])
                c = random.randint(0, width-1)
                input_grid[r][c] = (input_grid[r][c] + 1) % 10
            else:
                c = random.choice([i for i in range(width) if i != stripe_pos])
                r = random.randint(0, height-1)
                input_grid[r][c] = (input_grid[r][c] + 1) % 10
            if is_horizontal:
                output_grid = [input_grid[2*stripe_pos - i] for i in range(height)]
            else:
                output_grid = [[input_grid[i][2*stripe_pos - j] for j in range(width)] for i in range(height)]
            if input_grid != output_grid:
                break
        if input_grid == output_grid:
            input_grid[0][0] = (input_grid[0][0] + 1) % 10
            if is_horizontal:
                output_grid = [input_grid[2*stripe_pos - i] for i in range(height)]
            else:
                output_grid = [[input_grid[i][2*stripe_pos - j] for j in range(width)] for i in range(height)]
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    for r in range(height):
        if all(x == input_grid[r][0] and input_grid[r][0] != 0 for x in input_grid[r]):
            output = []
            for i in range(height):
                new_r = 2 * r - i
                if new_r < 0:
                    new_r = 0
                elif new_r >= height:
                    new_r = height - 1
                output.append(input_grid[new_r])
            return output
    for c in range(width):
        if all(input_grid[r][c] == input_grid[0][c] and input_grid[0][c] != 0 for r in range(height)):
            output = []
            for i in range(height):
                new_row = []
                for j in range(width):
                    new_c = 2 * c - j
                    if new_c < 0:
                        new_c = 0
                    elif new_c >= width:
                        new_c = width - 1
                    new_row.append(input_grid[i][new_c])
                output.append(new_row)
            return output
    return input_grid
