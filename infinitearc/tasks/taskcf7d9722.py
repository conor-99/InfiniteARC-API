# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: cf7d9722
Difficulty: hard

=== Tags ===
- Symmetry completion
- Pocket fill
- Loop filling
- Ex nihilo

=== Description ===
The task involves transforming input grids into output grids through a sequence
of four distinct, interdependent rules. Input grids feature asymmetric patterns,
enclosed pockets (small regions surrounded by a specific color and disconnected
from the grid's border), broken loops (open paths of a single color), and areas
with no prior structure. The output grid is generated by applying the following
rules in sequence:  1. **Symmetry Completion**: The grid is mirrored along a
vertical axis (left-to-right), completing any asymmetric patterns by reflecting
the left half to the right half.   2. **Pocket Fill**: All enclosed pockets
(regions of empty space not connected to the grid's border) are filled with a
fixed, consistent color (e.g., color 5 in numeric terms), regardless of the
surrounding color.   3. **Loop Filling**: Any open loop (a sequence of connected
cells of a single color that does not form a closed shape) is completed by
adding the missing segment(s) to close the loop, using the same color as the
loop.   4. **Ex Nihilo**: A new loop (e.g., a small 3x3 square loop) is added in
the grid's center using a distinct, predefined color (e.g., color 6), even if no
prior structure existed there.    These rules interact dynamically: symmetry
completion may alter pocket locations, loop filling may affect pocket
boundaries, and ex nihilo introduces a new structural element in a fixed
position. The solver must recognize all four transformations simultaneously, as
the input grids contain multiple overlapping features requiring sequential
application of these rules. The complexity arises from the need to identify and
resolve multiple independent transformations within a single grid, with no
single rule dominating the solution.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid, random_el

def generate():
    width = random.randint(10, 20)
    height = random.randint(10, 20)
    input_grid = [[2] * width for _ in range(height)]
    
    # Random pocket location (ensuring enclosure)
    pocket_x = random.randint(2, width - 5)
    pocket_y = random.randint(2, height - 5)
    for r in range(pocket_y, pocket_y + 3):
        for c in range(pocket_x, pocket_x + 3):
            input_grid[r][c] = 0
    
    # Random broken loop
    loop_row = random.randint(2, height - 3)
    loop_start = random.randint(2, width - 6)
    gap_pos = random.randint(0, 4)
    for c in range(loop_start, loop_start + 5):
        if c - loop_start != gap_pos:
            input_grid[loop_row][c] = 3
    
    # Random asymmetric pattern
    el_pixels = random_el(width, height)
    for (r, c) in el_pixels:
        if c < width // 2:
            input_grid[r][c] = 4
    
    output_grid = [row[:] for row in input_grid]
    
    # Symmetry completion
    for r in range(height):
        for c in range(width // 2, width):
            mirror_c = width - 1 - c
            output_grid[r][c] = output_grid[r][mirror_c]
    
    # Pocket fill
    visited = [[False] * width for _ in range(height)]
    queue = []
    for r in range(height):
        for c in [0, width - 1]:
            if output_grid[r][c] == 0 and not visited[r][c]:
                visited[r][c] = True
                queue.append((r, c))
    for c in range(width):
        for r in [0, height - 1]:
            if output_grid[r][c] == 0 and not visited[r][c]:
                visited[r][c] = True
                queue.append((r, c))
    
    while queue:
        r, c = queue.pop(0)
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and output_grid[nr][nc] == 0:
                visited[nr][nc] = True
                queue.append((nr, nc))
    
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] == 0 and not visited[r][c]:
                output_grid[r][c] = 5
    
    # Loop filling
    for r in range(height):
        for c in range(width):
            if output_grid[r][c] == 0:
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and output_grid[nr][nc] != 0:
                        output_grid[r][c] = output_grid[nr][nc]
                        break
    
    # Ex nihilo
    center_x = width // 2
    center_y = height // 2
    for r in range(center_y - 1, center_y + 2):
        for c in range(center_x - 1, center_x + 2):
            if r == center_y - 1 or r == center_y + 1 or c == center_x - 1 or c == center_x + 1:
                output_grid[r][c] = 6
            else:
                output_grid[r][c] = 0
    
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Ensure input_grid is list of lists
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    height = len(input_grid)
    width = len(input_grid[0])
    output = [row[:] for row in input_grid]
    
    # Symmetry completion
    for r in range(height):
        for c in range(width // 2, width):
            mirror_c = width - 1 - c
            output[r][c] = output[r][mirror_c]
    
    # Pocket fill
    visited = [[False] * width for _ in range(height)]
    queue = []
    for r in range(height):
        for c in [0, width - 1]:
            if output[r][c] == 0 and not visited[r][c]:
                visited[r][c] = True
                queue.append((r, c))
    for c in range(width):
        for r in [0, height - 1]:
            if output[r][c] == 0 and not visited[r][c]:
                visited[r][c] = True
                queue.append((r, c))
    
    while queue:
        r, c = queue.pop(0)
        for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and output[nr][nc] == 0:
                visited[nr][nc] = True
                queue.append((nr, nc))
    
    for r in range(height):
        for c in range(width):
            if output[r][c] == 0 and not visited[r][c]:
                output[r][c] = 5
    
    # Loop filling
    for r in range(height):
        for c in range(width):
            if output[r][c] == 0:
                for dr, dc in [(1,0), (-1,0), (0,1), (0,-1)]:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < height and 0 <= nc < width and output[nr][nc] != 0:
                        output[r][c] = output[nr][nc]
                        break
    
    # Ex nihilo
    center_x = width // 2
    center_y = height // 2
    for r in range(center_y - 1, center_y + 2):
        for c in range(center_x - 1, center_x + 2):
            if r == center_y - 1 or r == center_y + 1 or c == center_x - 1 or c == center_x + 1:
                output[r][c] = 6
            else:
                output[r][c] = 0
    
    return output
