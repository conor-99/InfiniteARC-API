# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-04
# ---------------------------------------------------------------

"""
Task ID: 3b518bef
Difficulty: hard

=== Tags ===
- Relay chain

=== Description ===
Input grids are large (20Ã—20 or larger) with a neutral background color,
featuring multiple single-cell symbols of distinct colors corresponding to the
standard rainbow sequence (red, orange, yellow, green, blue, indigo, violet).
Each symbol's color maps to its standard name (e.g., red = color 2, orange =
color 7, etc.), but symbols are positioned arbitrarily without spatial
correlation to the sequence. Non-rainbow colors (e.g., gray, pink) appear as
distracting elements but are ignored in the transformation. The output grid
retains all input symbols and background unchanged, except for a continuous
straight-line path connecting the symbols in the exact rainbow sequence order.
The path uses a new color (e.g., gray) and consists of horizontal/vertical
segments between consecutive symbols, forming the shortest possible connections
without diagonals. The path must traverse all rainbow-colored symbols exactly
once, skipping any non-rainbow elements, and the direction of traversal is
determined solely by the rainbow sequence order, not spatial proximity.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(20, 30)
    height = random.randint(20, 30)
    grid = [[0] * width for _ in range(height)]
    rainbow_colors = [2, 7, 4, 3, 1, 6, 9]
    positions = []
    for color in rainbow_colors:
        while True:
            r = random.randint(0, height - 1)
            c = random.randint(0, width - 1)
            if (r, c) not in positions:
                grid[r][c] = color
                positions.append((r, c))
                break
    valid = True
    for i in range(len(positions) - 1):
        r1, c1 = positions[i]
        r2, c2 = positions[i+1]
        path_cells = []
        start_c = min(c1, c2)
        end_c = max(c1, c2)
        for c in range(start_c + 1, end_c):
            path_cells.append((r1, c))
        start_r = min(r1, r2)
        end_r = max(r1, r2)
        for r in range(start_r + 1, end_r):
            path_cells.append((r, c2))
        for cell in path_cells:
            if cell in positions:
                valid = False
                break
        if not valid:
            break
    if not valid:
        return generate()
    for r in range(height):
        for c in range(width):
            if grid[r][c] == 0 and random.random() < 0.2:
                grid[r][c] = random.choice([5, 8])
    output = [row[:] for row in grid]
    for i in range(len(positions) - 1):
        r1, c1 = positions[i]
        r2, c2 = positions[i+1]
        start_c = min(c1, c2)
        end_c = max(c1, c2)
        for c in range(start_c + 1, end_c):
            output[r1][c] = 5
        start_r = min(r1, r2)
        end_r = max(r1, r2)
        for r in range(start_r + 1, end_r):
            output[r][c2] = 5
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    rainbow_colors = [2, 7, 4, 3, 1, 6, 9]
    color_to_index = {2: 0, 7: 1, 4: 2, 3: 3, 1: 4, 6: 5, 9: 6}
    positions = []
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] in rainbow_colors:
                positions.append((r, c))
    positions.sort(key=lambda pos: color_to_index[input_grid[pos[0]][pos[1]]])
    output = [list(row) for row in input_grid]
    for i in range(len(positions) - 1):
        r1, c1 = positions[i]
        r2, c2 = positions[i+1]
        start_c = min(c1, c2)
        end_c = max(c1, c2)
        for c in range(start_c + 1, end_c):
            output[r1][c] = 5
        start_r = min(r1, r2)
        end_r = max(r1, r2)
        for r in range(start_r + 1, end_r):
            output[r][c2] = 5
    return output
