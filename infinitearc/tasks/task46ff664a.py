# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-10
# ---------------------------------------------------------------

"""
Task ID: 46ff664a
Difficulty: medium–hard

=== Tags ===
- Color stream
- Truth table visualization
- Associate images to images
- Image within image

=== Description ===
Input grids are 6×6 to 12×12 in size, featuring a 2×2 truth table visualization
in the top-left corner where each cell contains one of four distinct colors
representing logical outputs (e.g., red for true, blue for false, green for XOR,
yellow for AND). The rest of the grid contains a 3×3 "image within image"
pattern placed in the bottom-right quadrant, with each cell colored using only
the four truth table colors. The background is a neutral gray color.  The output
grid retains the truth table and background unchanged but transforms the 3×3
image by replacing each cell's color with the color from the truth table cell
corresponding to the cell's position modulo 2. For example, a cell at (row 0,
column 1) in the 3×3 image maps to the top-right truth table cell (0, 1), while
a cell at (row 2, column 2) maps to the top-left truth table cell (0, 0) due to
modulo wrapping. This creates a color stream where the image's colors are
dynamically associated with the truth table's logical pattern, producing a
visually coherent transformation that maintains the integrity of the input's
color relationships while demonstrating the "truth table visualization" through
direct color association.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
import time

def generate():
    time.sleep(0.09)
    size = random.randint(6, 12)
    grid = [[5] * size for _ in range(size)]
    colors = random.sample([1, 2, 3, 4, 6, 7, 8, 9], 4)
    truth_table = [
        [colors[0], colors[1]],
        [colors[2], colors[3]]
    ]
    for r in range(2):
        for c in range(2):
            grid[r][c] = truth_table[r][c]
    start_row = size - 3
    start_col = size - 3
    for r in range(start_row, start_row + 3):
        for c in range(start_col, start_col + 3):
            grid[r][c] = random.choice(colors)
    output = [row[:] for row in grid]
    for r in range(start_row, start_row + 3):
        for c in range(start_col, start_col + 3):
            rel_r = r - start_row
            rel_c = c - start_col
            new_r = rel_r % 2
            new_c = rel_c % 2
            output[r][c] = truth_table[new_r][new_c]
    if grid == output:
        return generate()
    return {"input": grid, "output": output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    # Convert input to list of lists to handle tuple inputs
    input_grid = [list(row) for row in input_grid]
    size = len(input_grid)
    truth_table = [
        [input_grid[0][0], input_grid[0][1]],
        [input_grid[1][0], input_grid[1][1]]
    ]
    start_row = size - 3
    start_col = size - 3
    output = [row[:] for row in input_grid]
    for r in range(start_row, start_row + 3):
        for c in range(start_col, start_col + 3):
            rel_r = r - start_row
            rel_c = c - start_col
            new_r = rel_r % 2
            new_c = rel_c % 2
            output[r][c] = truth_table[new_r][new_c]
    return output
