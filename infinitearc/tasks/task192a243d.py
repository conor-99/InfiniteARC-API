# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: 192a243d
Difficulty: medium

=== Tags ===
- Out of boundary
- Separate images
- Color matching

=== Description ===
The input grid contains multiple disconnected regions (separate images), each
composed of a single color. Each region that touches any edge of the grid (top,
bottom, left, or right) must be shifted inward by one cell toward the grid's
center. Regions touching multiple edges (e.g., top-left corner) are shifted in
all applicable directions. The background color (0) fills the vacated positions.
The output grid reflects these shifts, ensuring all regions are entirely
contained within the grid's interior without touching any boundary. The
transformation preserves the original color of each region while moving it
inward, satisfying the "color matching" requirement through consistent color
retention during the shift.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    width = random.randint(3, 30)
    height = random.randint(3, 30)
    input_grid = [[0] * width for _ in range(height)]
    color = random.randint(1, 9)
    region = [(0, 0), (0, 1), (1, 0), (1, 1)]
    for r, c in region:
        input_grid[r][c] = color
    output_grid = [[0] * width for _ in range(height)]
    for r, c in region:
        new_r = r + 1
        new_c = c + 1
        output_grid[new_r][new_c] = color
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    height = len(input_grid)
    width = len(input_grid[0])
    output_grid = [[0] * width for _ in range(height)]
    visited = [[False] * width for _ in range(height)]
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    for r in range(height):
        for c in range(width):
            if not visited[r][c] and input_grid[r][c] != 0:
                color = input_grid[r][c]
                component = []
                queue = [(r, c)]
                visited[r][c] = True
                while queue:
                    cr, cc = queue.pop(0)
                    component.append((cr, cc))
                    for dr, dc in directions:
                        nr, nc = cr + dr, cc + dc
                        if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == color:
                            visited[nr][nc] = True
                            queue.append((nr, nc))
                touch_top = any(cr == 0 for cr, cc in component)
                touch_bottom = any(cr == height - 1 for cr, cc in component)
                touch_left = any(cc == 0 for cr, cc in component)
                touch_right = any(cc == width - 1 for cr, cc in component)
                shift_down = 1 if touch_top else 0
                shift_up = 1 if touch_bottom else 0
                shift_right = 1 if touch_left else 0
                shift_left = 1 if touch_right else 0
                for cr, cc in component:
                    new_r = cr + shift_down - shift_up
                    new_c = cc + shift_right - shift_left
                    output_grid[new_r][new_c] = color
    return output_grid
