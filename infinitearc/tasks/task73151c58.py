# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-11
# ---------------------------------------------------------------

"""
Task ID: 73151c58
Difficulty: hard

=== Tags ===
- Color particle fall
- Periodic offset matching
- Multi source interaction
- Maze
- Duplicate row pattern

=== Description ===
Input grids are 20Ã—20 grids with a background color (0) and walls formed by a
single wall color (1) that create a maze-like structure. The maze exhibits a
repeating row pattern every three rows, where each segment of three rows mirrors
the segment three rows above it (e.g., row 0 matches row 3, row 1 matches row 4,
etc.). Sources (color 2) appear only in the top row (row 0) on background cells
(0) that are not adjacent to walls, with at least one background cell separating
each source from walls or other sources. The maze is designed to allow a single
continuous path from each source to the bottom or right edge.  Output grids
retain all sources (color 2), walls (color 1), and background (0), but each
source emits a particle that travels downward through background cells. Upon
hitting a wall (color 1), the particle's direction changes based on the row's
position within the repeating pattern: in rows aligned with the first segment of
the pattern (e.g., rows 0, 3, 6), the particle bounces right; in rows aligned
with the second segment (e.g., rows 1, 4, 7), it bounces left; and in rows
aligned with the third segment (e.g., rows 2, 5, 8), it bounces right again. The
particle continues moving in the new direction, bouncing off walls as it
progresses, and leaves a trail of color 3 on background cells it traverses. The
trail never overlaps with walls, sources, or other trails, and all paths exit
the grid within a finite number of steps without intersecting. The periodic row
pattern ensures that bounce directions alternate in a consistent, repeating
cycle, creating a visually distinct path pattern for each particle.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random
from common import grid

def generate():
    width = 20
    height = 20
    base = grid(width, 3, 0)
    for c in range(width):
        if random.random() < 0.3:
            base[1][c] = 1
    valid_sources = [c for c in range(width) if base[1][c] == 0]
    if not valid_sources:
        base[1] = [0] * width
        valid_sources = list(range(width))
    source_cols = []
    if len(valid_sources) > 0:
        random.shuffle(valid_sources)
        source_cols.append(valid_sources[0])
        if len(valid_sources) > 1 and abs(valid_sources[0] - valid_sources[1]) >= 2:
            source_cols.append(valid_sources[1])
    input_grid = []
    for i in range(height):
        input_grid.append(base[i % 3][:])
    for c in source_cols:
        input_grid[0][c] = 2
    output_grid = [row[:] for row in input_grid]
    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]
    for c in source_cols:
        r, c_pos = 0, c
        dir_idx = 0
        current_r, current_c = r, c_pos
        while True:
            dr, dc = directions[dir_idx]
            next_r = current_r + dr
            next_c = current_c + dc
            if next_r < 0 or next_r >= height or next_c < 0 or next_c >= width:
                break
            if input_grid[next_r][next_c] == 1:
                if next_r % 3 == 0 or next_r % 3 == 2:
                    dir_idx = (dir_idx + 1) % 4
                else:
                    dir_idx = (dir_idx + 3) % 4
                if input_grid[current_r][current_c] == 0:
                    output_grid[current_r][current_c] = 3
            else:
                output_grid[next_r][next_c] = 3
                current_r, current_c = next_r, next_c
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    width = len(input_grid[0])
    height = len(input_grid)
    output_grid = [list(row) for row in input_grid]
    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]
    for c in range(width):
        if input_grid[0][c] == 2:
            dir_idx = 0
            r, c_pos = 0, c
            current_r, current_c = r, c_pos
            while True:
                dr, dc = directions[dir_idx]
                next_r = current_r + dr
                next_c = current_c + dc
                if next_r < 0 or next_r >= height or next_c < 0 or next_c >= width:
                    break
                if input_grid[next_r][next_c] == 1:
                    if next_r % 3 == 0 or next_r % 3 == 2:
                        dir_idx = (dir_idx + 1) % 4
                    else:
                        dir_idx = (dir_idx + 3) % 4
                    if input_grid[current_r][current_c] == 0:
                        output_grid[current_r][current_c] = 3
                else:
                    output_grid[next_r][next_c] = 3
                    current_r, current_c = next_r, next_c
    return output_grid
