# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: e0cf511f
Difficulty: hard

=== Tags ===
- Teleporter network routing
- Measure area

=== Description ===
The task involves input grids containing a distinct color representing
"teleporter" cells, which form a connected network. The output grid is derived
by identifying the minimal axis-aligned bounding box that encloses all
teleporter cells in the input. The bounding box is defined by the smallest and
largest row and column indices of the teleporter cells. The output grid is then
created with dimensions matching the bounding box's width and height, where
teleporter cells are repositioned such that their relative positions within the
bounding box mirror their original spatial relationships. Background cells in
the output grid are filled with a neutral color (e.g., 0). The "measure area"
component refers to the bounding box's area (width Ã— height), which directly
determines the output grid's dimensions. This task requires precise spatial
reasoning to compute bounding box boundaries and map positions, making it
challenging due to the need to process irregularly spaced teleporter networks
and avoid relying on numerical sums or color values.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    while True:
        W = common.randint(1, 30)
        H = common.randint(1, 30)
        if W * H >= 3:
            break
    teleporter_color = common.randint(1, 9)
    size = common.randint(2, W * H - 1)
    pixels = common.continuous_creature(size, W, H)
    input_grid = [[0] * W for _ in range(H)]
    for (r, c) in pixels:
        input_grid[r][c] = teleporter_color
    min_r = min(p[0] for p in pixels)
    max_r = max(p[0] for p in pixels)
    min_c = min(p[1] for p in pixels)
    max_c = max(p[1] for p in pixels)
    width_out = max_r - min_r + 1
    height_out = max_c - min_c + 1
    output_grid = [[0] * width_out for _ in range(height_out)]
    for (r, c) in pixels:
        output_grid[c - min_c][r - min_r] = teleporter_color
    if input_grid == output_grid:
        for _ in range(10):
            size = common.randint(2, W * H - 1)
            pixels = common.continuous_creature(size, W, H)
            min_r = min(p[0] for p in pixels)
            max_r = max(p[0] for p in pixels)
            min_c = min(p[1] for p in pixels)
            max_c = max(p[1] for p in pixels)
            width_out = max_r - min_r + 1
            height_out = max_c - min_c + 1
            output_grid = [[0] * width_out for _ in range(height_out)]
            for (r, c) in pixels:
                output_grid[c - min_c][r - min_r] = teleporter_color
            if input_grid != output_grid:
                break
        else:
            size = max(2, size - 1)
            pixels = common.continuous_creature(size, W, H)
            min_r = min(p[0] for p in pixels)
            max_r = max(p[0] for p in pixels)
            min_c = min(p[1] for p in pixels)
            max_c = max(p[1] for p in pixels)
            width_out = max_r - min_r + 1
            height_out = max_c - min_c + 1
            output_grid = [[0] * width_out for _ in range(height_out)]
            for (r, c) in pixels:
                output_grid[c - min_c][r - min_r] = teleporter_color
    return {"input": input_grid, "output": output_grid}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    non_zero = []
    for r in range(len(input_grid)):
        for c in range(len(input_grid[0])):
            if input_grid[r][c] != 0:
                non_zero.append((r, c))
    if not non_zero:
        return []
    min_r = min(p[0] for p in non_zero)
    max_r = max(p[0] for p in non_zero)
    min_c = min(p[1] for p in non_zero)
    max_c = max(p[1] for p in non_zero)
    width_out = max_r - min_r + 1
    height_out = max_c - min_c + 1
    output_grid = [[0] * width_out for _ in range(height_out)]
    for (r, c) in non_zero:
        output_grid[c - min_c][r - min_r] = input_grid[r][c]
    return output_grid
