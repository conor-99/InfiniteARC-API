# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-09
# ---------------------------------------------------------------

"""
Task ID: 741a65a6
Difficulty: insane

=== Tags ===
- Pattern translation
- Take negative

=== Description ===
Pattern Translation Take Negative  Input grids are 20×20 with background color 0
(black). The grid contains multiple distinct, non-overlapping, 4-connected
patterns (groups of contiguous cells of the same color) where each pattern is a
single color from 1-9 (non-background). Patterns are separated by at least one
background cell and are not adjacent to other patterns of different colors. Each
pattern has a clear bounding box with width > 1 and height > 1.  The
transformation process requires three sequential steps:  1. **Pattern
Identification and Translation**: For each pattern of color C (1-9), determine
the pattern's centroid (average row and column of all cells in the pattern).
Translate the entire pattern by a vector (dx, dy) where:    - dx = (C mod 4) - 1
(left if negative, right if positive)    - dy = (C // 4) (up if negative, down
if positive)  2. **Pattern Inversion**: After translation, replace each cell in
the translated pattern with the inverted color (9 - C). This inversion applies
only to the translated pattern; background remains 0.  3. **Overlap
Resolution**: If translated patterns overlap, the pattern with the higher
original color value (C) is drawn last (overwriting patterns with lower C).
Patterns that translate partially outside the grid are truncated to fit within
the 20×20 boundaries.  The output grid contains the translated, inverted
patterns with all background cells remaining 0. Patterns that translate entirely
outside the grid are not visible. No pattern may overlap with another pattern of
the same color after translation. The transformation must account for both the
direction of translation based on color value and the inversion of color, with
careful handling of edge cases where patterns move across grid boundaries or
overlap.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    input_grid = [[0] * 20 for _ in range(20)]
    colors = random.sample(range(1, 10), random.randint(3, 5))
    for C in colors:
        pattern_type = random.choice(['el', 'you', 'aitch'])
        pixels = common.rand_sprite(pattern_type, 3, 3)
        r0 = random.randint(0, 19)
        c0 = random.randint(0, 19)
        for (r, c) in pixels:
            nr, nc = r0 + r, c0 + c
            if 0 <= nr < 20 and 0 <= nc < 20:
                input_grid[nr][nc] = C
    output_grid = [[0] * 20 for _ in range(20)]
    cells = []
    for r in range(20):
        for c in range(20):
            if input_grid[r][c] != 0:
                cells.append((r, c, input_grid[r][c]))
    cells.sort(key=lambda x: x[2], reverse=True)
    for r, c, C in cells:
        dx = (C % 4) - 1
        dy = C // 4
        new_r = r + dy
        new_c = c + dx
        if 0 <= new_r < 20 and 0 <= new_c < 20:
            output_grid[new_r][new_c] = 9 - C
    if input_grid == output_grid:
        return generate()
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    grid = [list(row) for row in input_grid]
    rows = len(grid)
    cols = len(grid[0])
    cells = []
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] != 0:
                cells.append((r, c, grid[r][c]))
    cells.sort(key=lambda x: x[2], reverse=True)
    output = [[0] * cols for _ in range(rows)]
    for r, c, C in cells:
        dx = (C % 4) - 1
        dy = C // 4
        nr = r + dy
        nc = c + dx
        if 0 <= nr < rows and 0 <= nc < cols:
            output[nr][nc] = 9 - C
    return tuple(tuple(row) for row in output)
