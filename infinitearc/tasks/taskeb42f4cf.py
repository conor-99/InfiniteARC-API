# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-06
# ---------------------------------------------------------------

"""
Task ID: eb42f4cf
Difficulty: medium

=== Tags ===
- Connect all dots of same color
- Pattern expansion
- Divide by n

=== Description ===
The task involves transforming an input grid where each color may form
disconnected regions into an output grid through two primary steps. First, all
disconnected cells of the same color are connected into a single contiguous
region using orthogonal adjacency (up, down, left, right), filling gaps between
disconnected clusters with the same color. Second, the entire grid is scaled up
by a factor of n (where n is a small integer, such as 2 or 3), such that each
cell in the input becomes an n×n block of identical color in the output. The
scaling factor n is chosen such that the input grid dimensions are divisible by
n (e.g., a 6×6 input grid with n=2 produces a 12×12 output grid). This results
in a visually expanded pattern where connected color regions are preserved and
uniformly scaled, ensuring the output grid maintains all original color
connections while adhering to the pattern expansion rule.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import random

def generate():
    W = random.randint(3, 15)
    H = random.randint(3, 15)
    c = random.randint(1, 9)
    input_grid = [[0] * H for _ in range(W)]
    input_grid[0][0] = c
    input_grid[0][H-1] = c
    input_grid[W-1][0] = c
    input_grid[W-1][H-1] = c
    connected = [[c] * H for _ in range(W)]
    output_grid = []
    for r in range(W):
        for _ in range(2):
            new_row = []
            for val in connected[r]:
                new_row.extend([val] * 2)
            output_grid.append(new_row)
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid:
        return []
    W = len(input_grid)
    H = len(input_grid[0])
    connected = [[0] * H for _ in range(W)]
    colors = set()
    for r in range(W):
        for c in range(H):
            if input_grid[r][c] != 0:
                colors.add(input_grid[r][c])
    for color in colors:
        min_r, max_r = W, -1
        min_c, max_c = H, -1
        for r in range(W):
            for c in range(H):
                if input_grid[r][c] == color:
                    min_r = min(min_r, r)
                    max_r = max(max_r, r)
                    min_c = min(min_c, c)
                    max_c = max(max_c, c)
        for r in range(min_r, max_r + 1):
            for c in range(min_c, max_c + 1):
                connected[r][c] = color
    n = 2
    output_W = W * n
    output_H = H * n
    output = [[0] * output_H for _ in range(output_W)]
    for r in range(W):
        for c in range(H):
            for dr in range(n):
                for dc in range(n):
                    output[r * n + dr][c * n + dc] = connected[r][c]
    return output
