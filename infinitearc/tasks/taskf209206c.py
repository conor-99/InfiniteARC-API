# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-02
# ---------------------------------------------------------------

"""
Task ID: f209206c
Difficulty: medium

=== Tags ===
- Detect repetition
- Separate images

=== Description ===
The task involves input grids containing two or more identical connected shapes
(using 4-connectivity) that are adjacent and overlapping. The output grid
separates each instance of the shape by inserting a single background cell
(value 0) between them, ensuring no adjacency. The transformation requires
detecting the repeating pattern through visual identification of identical
connected components, then applying a consistent spatial separation rule. For
example, if two identical 2x2 blocks share an edge, the output shifts one block
to create a 0-cell gap, resulting in non-overlapping instances. The rule is
deterministic: identify the repeating shape, separate all adjacent copies with
0s, and maintain all other grid elements unchanged.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common
import random

def generate():
    c = common.random_color(exclude=[0])
    width_s = random.randint(3, 5)
    height_s = random.randint(3, 5)
    tries = random.randint(0, 5)
    rows, cols = common.conway_sprite(width_s, height_s, tries)
    if not rows:
        return generate()
    min_r, max_r = min(rows), max(rows)
    min_c, max_c = min(cols), max(cols)
    shape_width = max_c - min_c + 1
    shape_height = max_r - min_r + 1
    input_width = 2 * shape_width
    input_height = shape_height
    input_grid = common.grid(input_width, input_height, 0)
    for r, c in zip(rows, cols):
        input_grid[r - min_r][c - min_c] = c
        input_grid[r - min_r][c - min_c + shape_width] = c
    output_width = input_width + 1
    output_height = input_height
    output_grid = common.grid(output_width, output_height, 0)
    for r, c in zip(rows, cols):
        output_grid[r - min_r][c - min_c] = c
        output_grid[r - min_r][c - min_c + shape_width + 1] = c
    return {
        "input": input_grid,
        "output": output_grid
    }


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

def p(input_grid):
    if not input_grid:
        return []
    width = len(input_grid[0])
    height = len(input_grid)
    sep_col = width // 2
    output = [[0] * (width + 1) for _ in range(height)]
    for r in range(height):
        for c in range(sep_col):
            output[r][c] = input_grid[r][c]
        output[r][sep_col] = 0
        for c in range(sep_col, width):
            output[r][c + 1] = input_grid[r][c]
    return output
