# ---------------------------------------------------------------
# This file was automatically generated. DO NOT EDIT MANUALLY.
# 
# Generated by: conor-99/InfiniteARC/prepare.py
# Date: 2025-11-08
# ---------------------------------------------------------------

"""
Task ID: e7019a26
Difficulty: medium

=== Tags ===
- Detect closed curves

=== Description ===
The task involves transforming input grids containing one or more closed loops
into output grids where the interior of each loop is filled with a specific
color. Input grids consist of 2D arrays of integers between 0 and 9, where
closed loops are defined as connected cycles of pixels (each pixel in the loop
has exactly two adjacent loop pixels in the horizontal/vertical directions,
forming a continuous loop with no endpoints). The output grid preserves the
original loop structure but fills all enclosed interior areas with a fixed color
(e.g., 2), while leaving background pixels unchanged. For example, a loop
forming a square outline (with original color 1) in the input will have its
inner area replaced with color 2 in the output, creating a filled square.
Multiple non-overlapping loops are handled independently, with each interior
filled. The transformation requires identifying cyclic connectivity and
distinguishing enclosed regions from external areas through abstract reasoning.
"""


# ---------------------------------------------------------------
# Generator Code
# ---------------------------------------------------------------

import common

def generate():
    width = common.randint(3, 30)
    height = common.randint(3, 30)
    grid_input = common.grid(width, height, 0)
    loop_color = common.random_color(exclude=[0, 2])
    max_w = min(width - 1, 10)
    if max_w < 3:
        max_w = 3
    w = common.randint(3, max_w)
    max_h = min(height - 1, 10)
    if max_h < 3:
        max_h = 3
    h = common.randint(3, max_h)
    r = common.randint(0, height - h)
    c = common.randint(0, width - w)
    
    for col in range(c, c + w):
        grid_input[r][col] = loop_color
        grid_input[r + h - 1][col] = loop_color
    for row in range(r + 1, r + h - 1):
        grid_input[row][c] = loop_color
        grid_input[row][c + w - 1] = loop_color
    
    grid_output = [row[:] for row in grid_input]
    for row in range(r + 1, r + h - 1):
        for col in range(c + 1, c + w - 1):
            grid_output[row][col] = 2
    
    return {"input": grid_input, "output": grid_output}


# ---------------------------------------------------------------
# Solver Code
# ---------------------------------------------------------------

from collections import deque

def p(input_grid):
    if isinstance(input_grid, tuple):
        input_grid = [list(row) for row in input_grid]
    if not input_grid or not input_grid[0]:
        return input_grid
    width = len(input_grid[0])
    height = len(input_grid)
    output = [row[:] for row in input_grid]
    visited = [[False] * width for _ in range(height)]
    queue = deque()
    
    for i in range(width):
        if input_grid[0][i] == 0 and not visited[0][i]:
            visited[0][i] = True
            queue.append((0, i))
        if input_grid[height-1][i] == 0 and not visited[height-1][i]:
            visited[height-1][i] = True
            queue.append((height-1, i))
    for j in range(height):
        if input_grid[j][0] == 0 and not visited[j][0]:
            visited[j][0] = True
            queue.append((j, 0))
        if input_grid[j][width-1] == 0 and not visited[j][width-1]:
            visited[j][width-1] = True
            queue.append((j, width-1))
    
    directions = [(1,0), (-1,0), (0,1), (0,-1)]
    while queue:
        r, c = queue.popleft()
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            if 0 <= nr < height and 0 <= nc < width and not visited[nr][nc] and input_grid[nr][nc] == 0:
                visited[nr][nc] = True
                queue.append((nr, nc))
    
    for r in range(height):
        for c in range(width):
            if input_grid[r][c] == 0 and not visited[r][c]:
                output[r][c] = 2
    return output
